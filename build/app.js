/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/aes-decrypter/dist/aes-decrypter.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/aes-decrypter/dist/aes-decrypter.es.js ***!
  \*************************************************************/
/*! exports provided: decrypt, Decrypter, AsyncStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decrypt\", function() { return decrypt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Decrypter\", function() { return Decrypter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AsyncStream\", function() { return AsyncStream; });\n/* harmony import */ var pkcs7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pkcs7 */ \"./node_modules/pkcs7/dist/pkcs7.es.js\");\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n/**\n * @file aes.js\n *\n * This file contains an adaptation of the AES decryption algorithm\n * from the Standford Javascript Cryptography Library. That work is\n * covered by the following copyright and permissions notice:\n *\n * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation\n * are those of the authors and should not be interpreted as representing\n * official policies, either expressed or implied, of the authors.\n */\n\n/**\n * Expand the S-box tables.\n *\n * @private\n */\nvar precompute = function precompute() {\n  var tables = [[[], [], [], [], []], [[], [], [], [], []]];\n  var encTable = tables[0];\n  var decTable = tables[1];\n  var sbox = encTable[4];\n  var sboxInv = decTable[4];\n  var i = void 0;\n  var x = void 0;\n  var xInv = void 0;\n  var d = [];\n  var th = [];\n  var x2 = void 0;\n  var x4 = void 0;\n  var x8 = void 0;\n  var s = void 0;\n  var tEnc = void 0;\n  var tDec = void 0;\n\n  // Compute double and third tables\n  for (i = 0; i < 256; i++) {\n    th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\n  }\n\n  for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n    // Compute sbox\n    s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\n    s = s >> 8 ^ s & 255 ^ 99;\n    sbox[x] = s;\n    sboxInv[s] = x;\n\n    // Compute MixColumns\n    x8 = d[x4 = d[x2 = d[x]]];\n    tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n    tEnc = d[s] * 0x101 ^ s * 0x1010100;\n\n    for (i = 0; i < 4; i++) {\n      encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n      decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\n    }\n  }\n\n  // Compactify. Considerable speedup on Firefox.\n  for (i = 0; i < 5; i++) {\n    encTable[i] = encTable[i].slice(0);\n    decTable[i] = decTable[i].slice(0);\n  }\n  return tables;\n};\nvar aesTables = null;\n\n/**\n * Schedule out an AES key for both encryption and decryption. This\n * is a low-level class. Use a cipher mode to do bulk encryption.\n *\n * @class AES\n * @param key {Array} The key as an array of 4, 6 or 8 words.\n */\n\nvar AES = function () {\n  function AES(key) {\n    classCallCheck(this, AES);\n\n    /**\n     * The expanded S-box and inverse S-box tables. These will be computed\n     * on the client so that we don't have to send them down the wire.\n     *\n     * There are two tables, _tables[0] is for encryption and\n     * _tables[1] is for decryption.\n     *\n     * The first 4 sub-tables are the expanded S-box with MixColumns. The\n     * last (_tables[01][4]) is the S-box itself.\n     *\n     * @private\n     */\n    // if we have yet to precompute the S-box tables\n    // do so now\n    if (!aesTables) {\n      aesTables = precompute();\n    }\n    // then make a copy of that object for use\n    this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];\n    var i = void 0;\n    var j = void 0;\n    var tmp = void 0;\n    var encKey = void 0;\n    var decKey = void 0;\n    var sbox = this._tables[0][4];\n    var decTable = this._tables[1];\n    var keyLen = key.length;\n    var rcon = 1;\n\n    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n      throw new Error('Invalid aes key size');\n    }\n\n    encKey = key.slice(0);\n    decKey = [];\n    this._key = [encKey, decKey];\n\n    // schedule encryption keys\n    for (i = keyLen; i < 4 * keyLen + 28; i++) {\n      tmp = encKey[i - 1];\n\n      // apply sbox\n      if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {\n        tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];\n\n        // shift rows and add rcon\n        if (i % keyLen === 0) {\n          tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\n          rcon = rcon << 1 ^ (rcon >> 7) * 283;\n        }\n      }\n\n      encKey[i] = encKey[i - keyLen] ^ tmp;\n    }\n\n    // schedule decryption keys\n    for (j = 0; i; j++, i--) {\n      tmp = encKey[j & 3 ? i : i - 4];\n      if (i <= 4 || j < 4) {\n        decKey[j] = tmp;\n      } else {\n        decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];\n      }\n    }\n  }\n\n  /**\n   * Decrypt 16 bytes, specified as four 32-bit words.\n   *\n   * @param {Number} encrypted0 the first word to decrypt\n   * @param {Number} encrypted1 the second word to decrypt\n   * @param {Number} encrypted2 the third word to decrypt\n   * @param {Number} encrypted3 the fourth word to decrypt\n   * @param {Int32Array} out the array to write the decrypted words\n   * into\n   * @param {Number} offset the offset into the output array to start\n   * writing results\n   * @return {Array} The plaintext.\n   */\n\n\n  AES.prototype.decrypt = function decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {\n    var key = this._key[1];\n    // state variables a,b,c,d are loaded with pre-whitened data\n    var a = encrypted0 ^ key[0];\n    var b = encrypted3 ^ key[1];\n    var c = encrypted2 ^ key[2];\n    var d = encrypted1 ^ key[3];\n    var a2 = void 0;\n    var b2 = void 0;\n    var c2 = void 0;\n\n    // key.length === 2 ?\n    var nInnerRounds = key.length / 4 - 2;\n    var i = void 0;\n    var kIndex = 4;\n    var table = this._tables[1];\n\n    // load up the tables\n    var table0 = table[0];\n    var table1 = table[1];\n    var table2 = table[2];\n    var table3 = table[3];\n    var sbox = table[4];\n\n    // Inner rounds. Cribbed from OpenSSL.\n    for (i = 0; i < nInnerRounds; i++) {\n      a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];\n      b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];\n      c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];\n      d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];\n      kIndex += 4;\n      a = a2;b = b2;c = c2;\n    }\n\n    // Last round.\n    for (i = 0; i < 4; i++) {\n      out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];\n      a2 = a;a = b;b = c;c = d;d = a2;\n    }\n  };\n\n  return AES;\n}();\n\n/**\n * @file stream.js\n */\n/**\n * A lightweight readable stream implemention that handles event dispatching.\n *\n * @class Stream\n */\nvar Stream = function () {\n  function Stream() {\n    classCallCheck(this, Stream);\n\n    this.listeners = {};\n  }\n\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {String} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n\n  Stream.prototype.on = function on(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n    this.listeners[type].push(listener);\n  };\n\n  /**\n   * Remove a listener for a specified event type.\n   *\n   * @param {String} type the event name\n   * @param {Function} listener  a function previously registered for this\n   * type of event through `on`\n   * @return {Boolean} if we could turn it off or not\n   */\n\n\n  Stream.prototype.off = function off(type, listener) {\n    if (!this.listeners[type]) {\n      return false;\n    }\n\n    var index = this.listeners[type].indexOf(listener);\n\n    this.listeners[type].splice(index, 1);\n    return index > -1;\n  };\n\n  /**\n   * Trigger an event of the specified type on this stream. Any additional\n   * arguments to this function are passed as parameters to event listeners.\n   *\n   * @param {String} type the event name\n   */\n\n\n  Stream.prototype.trigger = function trigger(type) {\n    var callbacks = this.listeners[type];\n\n    if (!callbacks) {\n      return;\n    }\n\n    // Slicing the arguments on every invocation of this method\n    // can add a significant amount of overhead. Avoid the\n    // intermediate object creation for the common case of a\n    // single callback argument\n    if (arguments.length === 2) {\n      var length = callbacks.length;\n\n      for (var i = 0; i < length; ++i) {\n        callbacks[i].call(this, arguments[1]);\n      }\n    } else {\n      var args = Array.prototype.slice.call(arguments, 1);\n      var _length = callbacks.length;\n\n      for (var _i = 0; _i < _length; ++_i) {\n        callbacks[_i].apply(this, args);\n      }\n    }\n  };\n\n  /**\n   * Destroys the stream and cleans up.\n   */\n\n\n  Stream.prototype.dispose = function dispose() {\n    this.listeners = {};\n  };\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   *\n   * @param {Stream} destination the stream that will receive all `data` events\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n\n\n  Stream.prototype.pipe = function pipe(destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n  };\n\n  return Stream;\n}();\n\n/**\n * @file async-stream.js\n */\n/**\n * A wrapper around the Stream class to use setTiemout\n * and run stream \"jobs\" Asynchronously\n *\n * @class AsyncStream\n * @extends Stream\n */\n\nvar AsyncStream = function (_Stream) {\n  inherits(AsyncStream, _Stream);\n\n  function AsyncStream() {\n    classCallCheck(this, AsyncStream);\n\n    var _this = possibleConstructorReturn(this, _Stream.call(this, Stream));\n\n    _this.jobs = [];\n    _this.delay = 1;\n    _this.timeout_ = null;\n    return _this;\n  }\n\n  /**\n   * process an async job\n   *\n   * @private\n   */\n\n\n  AsyncStream.prototype.processJob_ = function processJob_() {\n    this.jobs.shift()();\n    if (this.jobs.length) {\n      this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\n    } else {\n      this.timeout_ = null;\n    }\n  };\n\n  /**\n   * push a job into the stream\n   *\n   * @param {Function} job the job to push into the stream\n   */\n\n\n  AsyncStream.prototype.push = function push(job) {\n    this.jobs.push(job);\n    if (!this.timeout_) {\n      this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\n    }\n  };\n\n  return AsyncStream;\n}(Stream);\n\n/**\n * @file decrypter.js\n *\n * An asynchronous implementation of AES-128 CBC decryption with\n * PKCS#7 padding.\n */\n\n/**\n * Convert network-order (big-endian) bytes into their little-endian\n * representation.\n */\nvar ntoh = function ntoh(word) {\n  return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n};\n\n/**\n * Decrypt bytes using AES-128 with CBC and PKCS#7 padding.\n *\n * @param {Uint8Array} encrypted the encrypted bytes\n * @param {Uint32Array} key the bytes of the decryption key\n * @param {Uint32Array} initVector the initialization vector (IV) to\n * use for the first round of CBC.\n * @return {Uint8Array} the decrypted bytes\n *\n * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29\n * @see https://tools.ietf.org/html/rfc2315\n */\nvar decrypt = function decrypt(encrypted, key, initVector) {\n  // word-level access to the encrypted bytes\n  var encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);\n\n  var decipher = new AES(Array.prototype.slice.call(key));\n\n  // byte and word-level access for the decrypted output\n  var decrypted = new Uint8Array(encrypted.byteLength);\n  var decrypted32 = new Int32Array(decrypted.buffer);\n\n  // temporary variables for working with the IV, encrypted, and\n  // decrypted data\n  var init0 = void 0;\n  var init1 = void 0;\n  var init2 = void 0;\n  var init3 = void 0;\n  var encrypted0 = void 0;\n  var encrypted1 = void 0;\n  var encrypted2 = void 0;\n  var encrypted3 = void 0;\n\n  // iteration variable\n  var wordIx = void 0;\n\n  // pull out the words of the IV to ensure we don't modify the\n  // passed-in reference and easier access\n  init0 = initVector[0];\n  init1 = initVector[1];\n  init2 = initVector[2];\n  init3 = initVector[3];\n\n  // decrypt four word sequences, applying cipher-block chaining (CBC)\n  // to each decrypted block\n  for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {\n    // convert big-endian (network order) words into little-endian\n    // (javascript order)\n    encrypted0 = ntoh(encrypted32[wordIx]);\n    encrypted1 = ntoh(encrypted32[wordIx + 1]);\n    encrypted2 = ntoh(encrypted32[wordIx + 2]);\n    encrypted3 = ntoh(encrypted32[wordIx + 3]);\n\n    // decrypt the block\n    decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);\n\n    // XOR with the IV, and restore network byte-order to obtain the\n    // plaintext\n    decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);\n    decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);\n    decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);\n    decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3);\n\n    // setup the IV for the next round\n    init0 = encrypted0;\n    init1 = encrypted1;\n    init2 = encrypted2;\n    init3 = encrypted3;\n  }\n\n  return decrypted;\n};\n\n/**\n * The `Decrypter` class that manages decryption of AES\n * data through `AsyncStream` objects and the `decrypt`\n * function\n *\n * @param {Uint8Array} encrypted the encrypted bytes\n * @param {Uint32Array} key the bytes of the decryption key\n * @param {Uint32Array} initVector the initialization vector (IV) to\n * @param {Function} done the function to run when done\n * @class Decrypter\n */\n\nvar Decrypter = function () {\n  function Decrypter(encrypted, key, initVector, done) {\n    classCallCheck(this, Decrypter);\n\n    var step = Decrypter.STEP;\n    var encrypted32 = new Int32Array(encrypted.buffer);\n    var decrypted = new Uint8Array(encrypted.byteLength);\n    var i = 0;\n\n    this.asyncStream_ = new AsyncStream();\n\n    // split up the encryption job and do the individual chunks asynchronously\n    this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\n    for (i = step; i < encrypted32.length; i += step) {\n      initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);\n      this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\n    }\n    // invoke the done() callback when everything is finished\n    this.asyncStream_.push(function () {\n      // remove pkcs#7 padding from the decrypted bytes\n      done(null, Object(pkcs7__WEBPACK_IMPORTED_MODULE_0__[\"unpad\"])(decrypted));\n    });\n  }\n\n  /**\n   * a getter for step the maximum number of bytes to process at one time\n   *\n   * @return {Number} the value of step 32000\n   */\n\n\n  /**\n   * @private\n   */\n  Decrypter.prototype.decryptChunk_ = function decryptChunk_(encrypted, key, initVector, decrypted) {\n    return function () {\n      var bytes = decrypt(encrypted, key, initVector);\n\n      decrypted.set(bytes, encrypted.byteOffset);\n    };\n  };\n\n  createClass(Decrypter, null, [{\n    key: 'STEP',\n    get: function get$$1() {\n      // 4 * 8000;\n      return 32000;\n    }\n  }]);\n  return Decrypter;\n}();\n\n/**\n * @file index.js\n *\n * Index module to easily import the primary components of AES-128\n * decryption. Like this:\n *\n * ```js\n * import {Decrypter, decrypt, AsyncStream} from 'aes-decrypter';\n * ```\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWVzLWRlY3J5cHRlci9kaXN0L2Flcy1kZWNyeXB0ZXIuZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWVzLWRlY3J5cHRlci9kaXN0L2Flcy1kZWNyeXB0ZXIuZXMuanM/MzlmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1bnBhZCB9IGZyb20gJ3BrY3M3JztcblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cblxuXG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cbi8qKlxuICogQGZpbGUgYWVzLmpzXG4gKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGFuIGFkYXB0YXRpb24gb2YgdGhlIEFFUyBkZWNyeXB0aW9uIGFsZ29yaXRobVxuICogZnJvbSB0aGUgU3RhbmRmb3JkIEphdmFzY3JpcHQgQ3J5cHRvZ3JhcGh5IExpYnJhcnkuIFRoYXQgd29yayBpc1xuICogY292ZXJlZCBieSB0aGUgZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgcGVybWlzc2lvbnMgbm90aWNlOlxuICpcbiAqIENvcHlyaWdodCAyMDA5LTIwMTAgRW1pbHkgU3RhcmssIE1pa2UgSGFtYnVyZywgRGFuIEJvbmVoLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBBVVRIT1JTIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1MgT1JcbiAqIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SXG4gKiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFXG4gKiBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOXG4gKiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBUaGUgdmlld3MgYW5kIGNvbmNsdXNpb25zIGNvbnRhaW5lZCBpbiB0aGUgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb25cbiAqIGFyZSB0aG9zZSBvZiB0aGUgYXV0aG9ycyBhbmQgc2hvdWxkIG5vdCBiZSBpbnRlcnByZXRlZCBhcyByZXByZXNlbnRpbmdcbiAqIG9mZmljaWFsIHBvbGljaWVzLCBlaXRoZXIgZXhwcmVzc2VkIG9yIGltcGxpZWQsIG9mIHRoZSBhdXRob3JzLlxuICovXG5cbi8qKlxuICogRXhwYW5kIHRoZSBTLWJveCB0YWJsZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIHByZWNvbXB1dGUgPSBmdW5jdGlvbiBwcmVjb21wdXRlKCkge1xuICB2YXIgdGFibGVzID0gW1tbXSwgW10sIFtdLCBbXSwgW11dLCBbW10sIFtdLCBbXSwgW10sIFtdXV07XG4gIHZhciBlbmNUYWJsZSA9IHRhYmxlc1swXTtcbiAgdmFyIGRlY1RhYmxlID0gdGFibGVzWzFdO1xuICB2YXIgc2JveCA9IGVuY1RhYmxlWzRdO1xuICB2YXIgc2JveEludiA9IGRlY1RhYmxlWzRdO1xuICB2YXIgaSA9IHZvaWQgMDtcbiAgdmFyIHggPSB2b2lkIDA7XG4gIHZhciB4SW52ID0gdm9pZCAwO1xuICB2YXIgZCA9IFtdO1xuICB2YXIgdGggPSBbXTtcbiAgdmFyIHgyID0gdm9pZCAwO1xuICB2YXIgeDQgPSB2b2lkIDA7XG4gIHZhciB4OCA9IHZvaWQgMDtcbiAgdmFyIHMgPSB2b2lkIDA7XG4gIHZhciB0RW5jID0gdm9pZCAwO1xuICB2YXIgdERlYyA9IHZvaWQgMDtcblxuICAvLyBDb21wdXRlIGRvdWJsZSBhbmQgdGhpcmQgdGFibGVzXG4gIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgIHRoWyhkW2ldID0gaSA8PCAxIF4gKGkgPj4gNykgKiAyODMpIF4gaV0gPSBpO1xuICB9XG5cbiAgZm9yICh4ID0geEludiA9IDA7ICFzYm94W3hdOyB4IF49IHgyIHx8IDEsIHhJbnYgPSB0aFt4SW52XSB8fCAxKSB7XG4gICAgLy8gQ29tcHV0ZSBzYm94XG4gICAgcyA9IHhJbnYgXiB4SW52IDw8IDEgXiB4SW52IDw8IDIgXiB4SW52IDw8IDMgXiB4SW52IDw8IDQ7XG4gICAgcyA9IHMgPj4gOCBeIHMgJiAyNTUgXiA5OTtcbiAgICBzYm94W3hdID0gcztcbiAgICBzYm94SW52W3NdID0geDtcblxuICAgIC8vIENvbXB1dGUgTWl4Q29sdW1uc1xuICAgIHg4ID0gZFt4NCA9IGRbeDIgPSBkW3hdXV07XG4gICAgdERlYyA9IHg4ICogMHgxMDEwMTAxIF4geDQgKiAweDEwMDAxIF4geDIgKiAweDEwMSBeIHggKiAweDEwMTAxMDA7XG4gICAgdEVuYyA9IGRbc10gKiAweDEwMSBeIHMgKiAweDEwMTAxMDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBlbmNUYWJsZVtpXVt4XSA9IHRFbmMgPSB0RW5jIDw8IDI0IF4gdEVuYyA+Pj4gODtcbiAgICAgIGRlY1RhYmxlW2ldW3NdID0gdERlYyA9IHREZWMgPDwgMjQgXiB0RGVjID4+PiA4O1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbXBhY3RpZnkuIENvbnNpZGVyYWJsZSBzcGVlZHVwIG9uIEZpcmVmb3guXG4gIGZvciAoaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICBlbmNUYWJsZVtpXSA9IGVuY1RhYmxlW2ldLnNsaWNlKDApO1xuICAgIGRlY1RhYmxlW2ldID0gZGVjVGFibGVbaV0uc2xpY2UoMCk7XG4gIH1cbiAgcmV0dXJuIHRhYmxlcztcbn07XG52YXIgYWVzVGFibGVzID0gbnVsbDtcblxuLyoqXG4gKiBTY2hlZHVsZSBvdXQgYW4gQUVTIGtleSBmb3IgYm90aCBlbmNyeXB0aW9uIGFuZCBkZWNyeXB0aW9uLiBUaGlzXG4gKiBpcyBhIGxvdy1sZXZlbCBjbGFzcy4gVXNlIGEgY2lwaGVyIG1vZGUgdG8gZG8gYnVsayBlbmNyeXB0aW9uLlxuICpcbiAqIEBjbGFzcyBBRVNcbiAqIEBwYXJhbSBrZXkge0FycmF5fSBUaGUga2V5IGFzIGFuIGFycmF5IG9mIDQsIDYgb3IgOCB3b3Jkcy5cbiAqL1xuXG52YXIgQUVTID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBRVMoa2V5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQUVTKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBleHBhbmRlZCBTLWJveCBhbmQgaW52ZXJzZSBTLWJveCB0YWJsZXMuIFRoZXNlIHdpbGwgYmUgY29tcHV0ZWRcbiAgICAgKiBvbiB0aGUgY2xpZW50IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBzZW5kIHRoZW0gZG93biB0aGUgd2lyZS5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSB0d28gdGFibGVzLCBfdGFibGVzWzBdIGlzIGZvciBlbmNyeXB0aW9uIGFuZFxuICAgICAqIF90YWJsZXNbMV0gaXMgZm9yIGRlY3J5cHRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3QgNCBzdWItdGFibGVzIGFyZSB0aGUgZXhwYW5kZWQgUy1ib3ggd2l0aCBNaXhDb2x1bW5zLiBUaGVcbiAgICAgKiBsYXN0IChfdGFibGVzWzAxXVs0XSkgaXMgdGhlIFMtYm94IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgLy8gaWYgd2UgaGF2ZSB5ZXQgdG8gcHJlY29tcHV0ZSB0aGUgUy1ib3ggdGFibGVzXG4gICAgLy8gZG8gc28gbm93XG4gICAgaWYgKCFhZXNUYWJsZXMpIHtcbiAgICAgIGFlc1RhYmxlcyA9IHByZWNvbXB1dGUoKTtcbiAgICB9XG4gICAgLy8gdGhlbiBtYWtlIGEgY29weSBvZiB0aGF0IG9iamVjdCBmb3IgdXNlXG4gICAgdGhpcy5fdGFibGVzID0gW1thZXNUYWJsZXNbMF1bMF0uc2xpY2UoKSwgYWVzVGFibGVzWzBdWzFdLnNsaWNlKCksIGFlc1RhYmxlc1swXVsyXS5zbGljZSgpLCBhZXNUYWJsZXNbMF1bM10uc2xpY2UoKSwgYWVzVGFibGVzWzBdWzRdLnNsaWNlKCldLCBbYWVzVGFibGVzWzFdWzBdLnNsaWNlKCksIGFlc1RhYmxlc1sxXVsxXS5zbGljZSgpLCBhZXNUYWJsZXNbMV1bMl0uc2xpY2UoKSwgYWVzVGFibGVzWzFdWzNdLnNsaWNlKCksIGFlc1RhYmxlc1sxXVs0XS5zbGljZSgpXV07XG4gICAgdmFyIGkgPSB2b2lkIDA7XG4gICAgdmFyIGogPSB2b2lkIDA7XG4gICAgdmFyIHRtcCA9IHZvaWQgMDtcbiAgICB2YXIgZW5jS2V5ID0gdm9pZCAwO1xuICAgIHZhciBkZWNLZXkgPSB2b2lkIDA7XG4gICAgdmFyIHNib3ggPSB0aGlzLl90YWJsZXNbMF1bNF07XG4gICAgdmFyIGRlY1RhYmxlID0gdGhpcy5fdGFibGVzWzFdO1xuICAgIHZhciBrZXlMZW4gPSBrZXkubGVuZ3RoO1xuICAgIHZhciByY29uID0gMTtcblxuICAgIGlmIChrZXlMZW4gIT09IDQgJiYga2V5TGVuICE9PSA2ICYmIGtleUxlbiAhPT0gOCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFlcyBrZXkgc2l6ZScpO1xuICAgIH1cblxuICAgIGVuY0tleSA9IGtleS5zbGljZSgwKTtcbiAgICBkZWNLZXkgPSBbXTtcbiAgICB0aGlzLl9rZXkgPSBbZW5jS2V5LCBkZWNLZXldO1xuXG4gICAgLy8gc2NoZWR1bGUgZW5jcnlwdGlvbiBrZXlzXG4gICAgZm9yIChpID0ga2V5TGVuOyBpIDwgNCAqIGtleUxlbiArIDI4OyBpKyspIHtcbiAgICAgIHRtcCA9IGVuY0tleVtpIC0gMV07XG5cbiAgICAgIC8vIGFwcGx5IHNib3hcbiAgICAgIGlmIChpICUga2V5TGVuID09PSAwIHx8IGtleUxlbiA9PT0gOCAmJiBpICUga2V5TGVuID09PSA0KSB7XG4gICAgICAgIHRtcCA9IHNib3hbdG1wID4+PiAyNF0gPDwgMjQgXiBzYm94W3RtcCA+PiAxNiAmIDI1NV0gPDwgMTYgXiBzYm94W3RtcCA+PiA4ICYgMjU1XSA8PCA4IF4gc2JveFt0bXAgJiAyNTVdO1xuXG4gICAgICAgIC8vIHNoaWZ0IHJvd3MgYW5kIGFkZCByY29uXG4gICAgICAgIGlmIChpICUga2V5TGVuID09PSAwKSB7XG4gICAgICAgICAgdG1wID0gdG1wIDw8IDggXiB0bXAgPj4+IDI0IF4gcmNvbiA8PCAyNDtcbiAgICAgICAgICByY29uID0gcmNvbiA8PCAxIF4gKHJjb24gPj4gNykgKiAyODM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZW5jS2V5W2ldID0gZW5jS2V5W2kgLSBrZXlMZW5dIF4gdG1wO1xuICAgIH1cblxuICAgIC8vIHNjaGVkdWxlIGRlY3J5cHRpb24ga2V5c1xuICAgIGZvciAoaiA9IDA7IGk7IGorKywgaS0tKSB7XG4gICAgICB0bXAgPSBlbmNLZXlbaiAmIDMgPyBpIDogaSAtIDRdO1xuICAgICAgaWYgKGkgPD0gNCB8fCBqIDwgNCkge1xuICAgICAgICBkZWNLZXlbal0gPSB0bXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWNLZXlbal0gPSBkZWNUYWJsZVswXVtzYm94W3RtcCA+Pj4gMjRdXSBeIGRlY1RhYmxlWzFdW3Nib3hbdG1wID4+IDE2ICYgMjU1XV0gXiBkZWNUYWJsZVsyXVtzYm94W3RtcCA+PiA4ICYgMjU1XV0gXiBkZWNUYWJsZVszXVtzYm94W3RtcCAmIDI1NV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNyeXB0IDE2IGJ5dGVzLCBzcGVjaWZpZWQgYXMgZm91ciAzMi1iaXQgd29yZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmNyeXB0ZWQwIHRoZSBmaXJzdCB3b3JkIHRvIGRlY3J5cHRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuY3J5cHRlZDEgdGhlIHNlY29uZCB3b3JkIHRvIGRlY3J5cHRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuY3J5cHRlZDIgdGhlIHRoaXJkIHdvcmQgdG8gZGVjcnlwdFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5jcnlwdGVkMyB0aGUgZm91cnRoIHdvcmQgdG8gZGVjcnlwdFxuICAgKiBAcGFyYW0ge0ludDMyQXJyYXl9IG91dCB0aGUgYXJyYXkgdG8gd3JpdGUgdGhlIGRlY3J5cHRlZCB3b3Jkc1xuICAgKiBpbnRvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgdGhlIG9mZnNldCBpbnRvIHRoZSBvdXRwdXQgYXJyYXkgdG8gc3RhcnRcbiAgICogd3JpdGluZyByZXN1bHRzXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgcGxhaW50ZXh0LlxuICAgKi9cblxuXG4gIEFFUy5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uIGRlY3J5cHQoZW5jcnlwdGVkMCwgZW5jcnlwdGVkMSwgZW5jcnlwdGVkMiwgZW5jcnlwdGVkMywgb3V0LCBvZmZzZXQpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5fa2V5WzFdO1xuICAgIC8vIHN0YXRlIHZhcmlhYmxlcyBhLGIsYyxkIGFyZSBsb2FkZWQgd2l0aCBwcmUtd2hpdGVuZWQgZGF0YVxuICAgIHZhciBhID0gZW5jcnlwdGVkMCBeIGtleVswXTtcbiAgICB2YXIgYiA9IGVuY3J5cHRlZDMgXiBrZXlbMV07XG4gICAgdmFyIGMgPSBlbmNyeXB0ZWQyIF4ga2V5WzJdO1xuICAgIHZhciBkID0gZW5jcnlwdGVkMSBeIGtleVszXTtcbiAgICB2YXIgYTIgPSB2b2lkIDA7XG4gICAgdmFyIGIyID0gdm9pZCAwO1xuICAgIHZhciBjMiA9IHZvaWQgMDtcblxuICAgIC8vIGtleS5sZW5ndGggPT09IDIgP1xuICAgIHZhciBuSW5uZXJSb3VuZHMgPSBrZXkubGVuZ3RoIC8gNCAtIDI7XG4gICAgdmFyIGkgPSB2b2lkIDA7XG4gICAgdmFyIGtJbmRleCA9IDQ7XG4gICAgdmFyIHRhYmxlID0gdGhpcy5fdGFibGVzWzFdO1xuXG4gICAgLy8gbG9hZCB1cCB0aGUgdGFibGVzXG4gICAgdmFyIHRhYmxlMCA9IHRhYmxlWzBdO1xuICAgIHZhciB0YWJsZTEgPSB0YWJsZVsxXTtcbiAgICB2YXIgdGFibGUyID0gdGFibGVbMl07XG4gICAgdmFyIHRhYmxlMyA9IHRhYmxlWzNdO1xuICAgIHZhciBzYm94ID0gdGFibGVbNF07XG5cbiAgICAvLyBJbm5lciByb3VuZHMuIENyaWJiZWQgZnJvbSBPcGVuU1NMLlxuICAgIGZvciAoaSA9IDA7IGkgPCBuSW5uZXJSb3VuZHM7IGkrKykge1xuICAgICAgYTIgPSB0YWJsZTBbYSA+Pj4gMjRdIF4gdGFibGUxW2IgPj4gMTYgJiAyNTVdIF4gdGFibGUyW2MgPj4gOCAmIDI1NV0gXiB0YWJsZTNbZCAmIDI1NV0gXiBrZXlba0luZGV4XTtcbiAgICAgIGIyID0gdGFibGUwW2IgPj4+IDI0XSBeIHRhYmxlMVtjID4+IDE2ICYgMjU1XSBeIHRhYmxlMltkID4+IDggJiAyNTVdIF4gdGFibGUzW2EgJiAyNTVdIF4ga2V5W2tJbmRleCArIDFdO1xuICAgICAgYzIgPSB0YWJsZTBbYyA+Pj4gMjRdIF4gdGFibGUxW2QgPj4gMTYgJiAyNTVdIF4gdGFibGUyW2EgPj4gOCAmIDI1NV0gXiB0YWJsZTNbYiAmIDI1NV0gXiBrZXlba0luZGV4ICsgMl07XG4gICAgICBkID0gdGFibGUwW2QgPj4+IDI0XSBeIHRhYmxlMVthID4+IDE2ICYgMjU1XSBeIHRhYmxlMltiID4+IDggJiAyNTVdIF4gdGFibGUzW2MgJiAyNTVdIF4ga2V5W2tJbmRleCArIDNdO1xuICAgICAga0luZGV4ICs9IDQ7XG4gICAgICBhID0gYTI7YiA9IGIyO2MgPSBjMjtcbiAgICB9XG5cbiAgICAvLyBMYXN0IHJvdW5kLlxuICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIG91dFsoMyAmIC1pKSArIG9mZnNldF0gPSBzYm94W2EgPj4+IDI0XSA8PCAyNCBeIHNib3hbYiA+PiAxNiAmIDI1NV0gPDwgMTYgXiBzYm94W2MgPj4gOCAmIDI1NV0gPDwgOCBeIHNib3hbZCAmIDI1NV0gXiBrZXlba0luZGV4KytdO1xuICAgICAgYTIgPSBhO2EgPSBiO2IgPSBjO2MgPSBkO2QgPSBhMjtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEFFUztcbn0oKTtcblxuLyoqXG4gKiBAZmlsZSBzdHJlYW0uanNcbiAqL1xuLyoqXG4gKiBBIGxpZ2h0d2VpZ2h0IHJlYWRhYmxlIHN0cmVhbSBpbXBsZW1lbnRpb24gdGhhdCBoYW5kbGVzIGV2ZW50IGRpc3BhdGNoaW5nLlxuICpcbiAqIEBjbGFzcyBTdHJlYW1cbiAqL1xudmFyIFN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RyZWFtKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmVhbSk7XG5cbiAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIHNwZWNpZmllZCBldmVudCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgZXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciB0aGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGFuIGV2ZW50IG9mXG4gICAqIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnNcbiAgICovXG5cblxuICBTdHJlYW0ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyICBhIGZ1bmN0aW9uIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBmb3IgdGhpc1xuICAgKiB0eXBlIG9mIGV2ZW50IHRocm91Z2ggYG9uYFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBpZiB3ZSBjb3VsZCB0dXJuIGl0IG9mZiBvciBub3RcbiAgICovXG5cblxuICBTdHJlYW0ucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLmxpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGxpc3RlbmVyKTtcblxuICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIGluZGV4ID4gLTE7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9uIHRoaXMgc3RyZWFtLiBBbnkgYWRkaXRpb25hbFxuICAgKiBhcmd1bWVudHMgdG8gdGhpcyBmdW5jdGlvbiBhcmUgcGFzc2VkIGFzIHBhcmFtZXRlcnMgdG8gZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgZXZlbnQgbmFtZVxuICAgKi9cblxuXG4gIFN0cmVhbS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIodHlwZSkge1xuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLmxpc3RlbmVyc1t0eXBlXTtcblxuICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2xpY2luZyB0aGUgYXJndW1lbnRzIG9uIGV2ZXJ5IGludm9jYXRpb24gb2YgdGhpcyBtZXRob2RcbiAgICAvLyBjYW4gYWRkIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mIG92ZXJoZWFkLiBBdm9pZCB0aGVcbiAgICAvLyBpbnRlcm1lZGlhdGUgb2JqZWN0IGNyZWF0aW9uIGZvciB0aGUgY29tbW9uIGNhc2Ugb2YgYVxuICAgIC8vIHNpbmdsZSBjYWxsYmFjayBhcmd1bWVudFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY2FsbGJhY2tzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjYWxsYmFja3NbaV0uY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICB2YXIgX2xlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfbGVuZ3RoOyArK19pKSB7XG4gICAgICAgIGNhbGxiYWNrc1tfaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgc3RyZWFtIGFuZCBjbGVhbnMgdXAuXG4gICAqL1xuXG5cbiAgU3RyZWFtLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICB9O1xuICAvKipcbiAgICogRm9yd2FyZHMgYWxsIGBkYXRhYCBldmVudHMgb24gdGhpcyBzdHJlYW0gdG8gdGhlIGRlc3RpbmF0aW9uIHN0cmVhbS4gVGhlXG4gICAqIGRlc3RpbmF0aW9uIHN0cmVhbSBzaG91bGQgcHJvdmlkZSBhIG1ldGhvZCBgcHVzaGAgdG8gcmVjZWl2ZSB0aGUgZGF0YVxuICAgKiBldmVudHMgYXMgdGhleSBhcnJpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyZWFtfSBkZXN0aW5hdGlvbiB0aGUgc3RyZWFtIHRoYXQgd2lsbCByZWNlaXZlIGFsbCBgZGF0YWAgZXZlbnRzXG4gICAqIEBzZWUgaHR0cDovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9yZWFkYWJsZV9waXBlX2Rlc3RpbmF0aW9uX29wdGlvbnNcbiAgICovXG5cblxuICBTdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiBwaXBlKGRlc3RpbmF0aW9uKSB7XG4gICAgdGhpcy5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGRhdGEpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTdHJlYW07XG59KCk7XG5cbi8qKlxuICogQGZpbGUgYXN5bmMtc3RyZWFtLmpzXG4gKi9cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgU3RyZWFtIGNsYXNzIHRvIHVzZSBzZXRUaWVtb3V0XG4gKiBhbmQgcnVuIHN0cmVhbSBcImpvYnNcIiBBc3luY2hyb25vdXNseVxuICpcbiAqIEBjbGFzcyBBc3luY1N0cmVhbVxuICogQGV4dGVuZHMgU3RyZWFtXG4gKi9cblxudmFyIEFzeW5jU3RyZWFtID0gZnVuY3Rpb24gKF9TdHJlYW0pIHtcbiAgaW5oZXJpdHMoQXN5bmNTdHJlYW0sIF9TdHJlYW0pO1xuXG4gIGZ1bmN0aW9uIEFzeW5jU3RyZWFtKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEFzeW5jU3RyZWFtKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1N0cmVhbS5jYWxsKHRoaXMsIFN0cmVhbSkpO1xuXG4gICAgX3RoaXMuam9icyA9IFtdO1xuICAgIF90aGlzLmRlbGF5ID0gMTtcbiAgICBfdGhpcy50aW1lb3V0XyA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIHByb2Nlc3MgYW4gYXN5bmMgam9iXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQXN5bmNTdHJlYW0ucHJvdG90eXBlLnByb2Nlc3NKb2JfID0gZnVuY3Rpb24gcHJvY2Vzc0pvYl8oKSB7XG4gICAgdGhpcy5qb2JzLnNoaWZ0KCkoKTtcbiAgICBpZiAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgICAgdGhpcy50aW1lb3V0XyA9IHNldFRpbWVvdXQodGhpcy5wcm9jZXNzSm9iXy5iaW5kKHRoaXMpLCB0aGlzLmRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50aW1lb3V0XyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBwdXNoIGEgam9iIGludG8gdGhlIHN0cmVhbVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2IgdGhlIGpvYiB0byBwdXNoIGludG8gdGhlIHN0cmVhbVxuICAgKi9cblxuXG4gIEFzeW5jU3RyZWFtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaChqb2IpIHtcbiAgICB0aGlzLmpvYnMucHVzaChqb2IpO1xuICAgIGlmICghdGhpcy50aW1lb3V0Xykge1xuICAgICAgdGhpcy50aW1lb3V0XyA9IHNldFRpbWVvdXQodGhpcy5wcm9jZXNzSm9iXy5iaW5kKHRoaXMpLCB0aGlzLmRlbGF5KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEFzeW5jU3RyZWFtO1xufShTdHJlYW0pO1xuXG4vKipcbiAqIEBmaWxlIGRlY3J5cHRlci5qc1xuICpcbiAqIEFuIGFzeW5jaHJvbm91cyBpbXBsZW1lbnRhdGlvbiBvZiBBRVMtMTI4IENCQyBkZWNyeXB0aW9uIHdpdGhcbiAqIFBLQ1MjNyBwYWRkaW5nLlxuICovXG5cbi8qKlxuICogQ29udmVydCBuZXR3b3JrLW9yZGVyIChiaWctZW5kaWFuKSBieXRlcyBpbnRvIHRoZWlyIGxpdHRsZS1lbmRpYW5cbiAqIHJlcHJlc2VudGF0aW9uLlxuICovXG52YXIgbnRvaCA9IGZ1bmN0aW9uIG50b2god29yZCkge1xuICByZXR1cm4gd29yZCA8PCAyNCB8ICh3b3JkICYgMHhmZjAwKSA8PCA4IHwgKHdvcmQgJiAweGZmMDAwMCkgPj4gOCB8IHdvcmQgPj4+IDI0O1xufTtcblxuLyoqXG4gKiBEZWNyeXB0IGJ5dGVzIHVzaW5nIEFFUy0xMjggd2l0aCBDQkMgYW5kIFBLQ1MjNyBwYWRkaW5nLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZW5jcnlwdGVkIHRoZSBlbmNyeXB0ZWQgYnl0ZXNcbiAqIEBwYXJhbSB7VWludDMyQXJyYXl9IGtleSB0aGUgYnl0ZXMgb2YgdGhlIGRlY3J5cHRpb24ga2V5XG4gKiBAcGFyYW0ge1VpbnQzMkFycmF5fSBpbml0VmVjdG9yIHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgKElWKSB0b1xuICogdXNlIGZvciB0aGUgZmlyc3Qgcm91bmQgb2YgQ0JDLlxuICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIGRlY3J5cHRlZCBieXRlc1xuICpcbiAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BZHZhbmNlZF9FbmNyeXB0aW9uX1N0YW5kYXJkXG4gKiBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmxvY2tfY2lwaGVyX21vZGVfb2Zfb3BlcmF0aW9uI0NpcGhlcl9CbG9ja19DaGFpbmluZ18uMjhDQkMuMjlcbiAqIEBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIzMTVcbiAqL1xudmFyIGRlY3J5cHQgPSBmdW5jdGlvbiBkZWNyeXB0KGVuY3J5cHRlZCwga2V5LCBpbml0VmVjdG9yKSB7XG4gIC8vIHdvcmQtbGV2ZWwgYWNjZXNzIHRvIHRoZSBlbmNyeXB0ZWQgYnl0ZXNcbiAgdmFyIGVuY3J5cHRlZDMyID0gbmV3IEludDMyQXJyYXkoZW5jcnlwdGVkLmJ1ZmZlciwgZW5jcnlwdGVkLmJ5dGVPZmZzZXQsIGVuY3J5cHRlZC5ieXRlTGVuZ3RoID4+IDIpO1xuXG4gIHZhciBkZWNpcGhlciA9IG5ldyBBRVMoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoa2V5KSk7XG5cbiAgLy8gYnl0ZSBhbmQgd29yZC1sZXZlbCBhY2Nlc3MgZm9yIHRoZSBkZWNyeXB0ZWQgb3V0cHV0XG4gIHZhciBkZWNyeXB0ZWQgPSBuZXcgVWludDhBcnJheShlbmNyeXB0ZWQuYnl0ZUxlbmd0aCk7XG4gIHZhciBkZWNyeXB0ZWQzMiA9IG5ldyBJbnQzMkFycmF5KGRlY3J5cHRlZC5idWZmZXIpO1xuXG4gIC8vIHRlbXBvcmFyeSB2YXJpYWJsZXMgZm9yIHdvcmtpbmcgd2l0aCB0aGUgSVYsIGVuY3J5cHRlZCwgYW5kXG4gIC8vIGRlY3J5cHRlZCBkYXRhXG4gIHZhciBpbml0MCA9IHZvaWQgMDtcbiAgdmFyIGluaXQxID0gdm9pZCAwO1xuICB2YXIgaW5pdDIgPSB2b2lkIDA7XG4gIHZhciBpbml0MyA9IHZvaWQgMDtcbiAgdmFyIGVuY3J5cHRlZDAgPSB2b2lkIDA7XG4gIHZhciBlbmNyeXB0ZWQxID0gdm9pZCAwO1xuICB2YXIgZW5jcnlwdGVkMiA9IHZvaWQgMDtcbiAgdmFyIGVuY3J5cHRlZDMgPSB2b2lkIDA7XG5cbiAgLy8gaXRlcmF0aW9uIHZhcmlhYmxlXG4gIHZhciB3b3JkSXggPSB2b2lkIDA7XG5cbiAgLy8gcHVsbCBvdXQgdGhlIHdvcmRzIG9mIHRoZSBJViB0byBlbnN1cmUgd2UgZG9uJ3QgbW9kaWZ5IHRoZVxuICAvLyBwYXNzZWQtaW4gcmVmZXJlbmNlIGFuZCBlYXNpZXIgYWNjZXNzXG4gIGluaXQwID0gaW5pdFZlY3RvclswXTtcbiAgaW5pdDEgPSBpbml0VmVjdG9yWzFdO1xuICBpbml0MiA9IGluaXRWZWN0b3JbMl07XG4gIGluaXQzID0gaW5pdFZlY3RvclszXTtcblxuICAvLyBkZWNyeXB0IGZvdXIgd29yZCBzZXF1ZW5jZXMsIGFwcGx5aW5nIGNpcGhlci1ibG9jayBjaGFpbmluZyAoQ0JDKVxuICAvLyB0byBlYWNoIGRlY3J5cHRlZCBibG9ja1xuICBmb3IgKHdvcmRJeCA9IDA7IHdvcmRJeCA8IGVuY3J5cHRlZDMyLmxlbmd0aDsgd29yZEl4ICs9IDQpIHtcbiAgICAvLyBjb252ZXJ0IGJpZy1lbmRpYW4gKG5ldHdvcmsgb3JkZXIpIHdvcmRzIGludG8gbGl0dGxlLWVuZGlhblxuICAgIC8vIChqYXZhc2NyaXB0IG9yZGVyKVxuICAgIGVuY3J5cHRlZDAgPSBudG9oKGVuY3J5cHRlZDMyW3dvcmRJeF0pO1xuICAgIGVuY3J5cHRlZDEgPSBudG9oKGVuY3J5cHRlZDMyW3dvcmRJeCArIDFdKTtcbiAgICBlbmNyeXB0ZWQyID0gbnRvaChlbmNyeXB0ZWQzMlt3b3JkSXggKyAyXSk7XG4gICAgZW5jcnlwdGVkMyA9IG50b2goZW5jcnlwdGVkMzJbd29yZEl4ICsgM10pO1xuXG4gICAgLy8gZGVjcnlwdCB0aGUgYmxvY2tcbiAgICBkZWNpcGhlci5kZWNyeXB0KGVuY3J5cHRlZDAsIGVuY3J5cHRlZDEsIGVuY3J5cHRlZDIsIGVuY3J5cHRlZDMsIGRlY3J5cHRlZDMyLCB3b3JkSXgpO1xuXG4gICAgLy8gWE9SIHdpdGggdGhlIElWLCBhbmQgcmVzdG9yZSBuZXR3b3JrIGJ5dGUtb3JkZXIgdG8gb2J0YWluIHRoZVxuICAgIC8vIHBsYWludGV4dFxuICAgIGRlY3J5cHRlZDMyW3dvcmRJeF0gPSBudG9oKGRlY3J5cHRlZDMyW3dvcmRJeF0gXiBpbml0MCk7XG4gICAgZGVjcnlwdGVkMzJbd29yZEl4ICsgMV0gPSBudG9oKGRlY3J5cHRlZDMyW3dvcmRJeCArIDFdIF4gaW5pdDEpO1xuICAgIGRlY3J5cHRlZDMyW3dvcmRJeCArIDJdID0gbnRvaChkZWNyeXB0ZWQzMlt3b3JkSXggKyAyXSBeIGluaXQyKTtcbiAgICBkZWNyeXB0ZWQzMlt3b3JkSXggKyAzXSA9IG50b2goZGVjcnlwdGVkMzJbd29yZEl4ICsgM10gXiBpbml0Myk7XG5cbiAgICAvLyBzZXR1cCB0aGUgSVYgZm9yIHRoZSBuZXh0IHJvdW5kXG4gICAgaW5pdDAgPSBlbmNyeXB0ZWQwO1xuICAgIGluaXQxID0gZW5jcnlwdGVkMTtcbiAgICBpbml0MiA9IGVuY3J5cHRlZDI7XG4gICAgaW5pdDMgPSBlbmNyeXB0ZWQzO1xuICB9XG5cbiAgcmV0dXJuIGRlY3J5cHRlZDtcbn07XG5cbi8qKlxuICogVGhlIGBEZWNyeXB0ZXJgIGNsYXNzIHRoYXQgbWFuYWdlcyBkZWNyeXB0aW9uIG9mIEFFU1xuICogZGF0YSB0aHJvdWdoIGBBc3luY1N0cmVhbWAgb2JqZWN0cyBhbmQgdGhlIGBkZWNyeXB0YFxuICogZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGVuY3J5cHRlZCB0aGUgZW5jcnlwdGVkIGJ5dGVzXG4gKiBAcGFyYW0ge1VpbnQzMkFycmF5fSBrZXkgdGhlIGJ5dGVzIG9mIHRoZSBkZWNyeXB0aW9uIGtleVxuICogQHBhcmFtIHtVaW50MzJBcnJheX0gaW5pdFZlY3RvciB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIChJVikgdG9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgdGhlIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIGRvbmVcbiAqIEBjbGFzcyBEZWNyeXB0ZXJcbiAqL1xuXG52YXIgRGVjcnlwdGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEZWNyeXB0ZXIoZW5jcnlwdGVkLCBrZXksIGluaXRWZWN0b3IsIGRvbmUpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBEZWNyeXB0ZXIpO1xuXG4gICAgdmFyIHN0ZXAgPSBEZWNyeXB0ZXIuU1RFUDtcbiAgICB2YXIgZW5jcnlwdGVkMzIgPSBuZXcgSW50MzJBcnJheShlbmNyeXB0ZWQuYnVmZmVyKTtcbiAgICB2YXIgZGVjcnlwdGVkID0gbmV3IFVpbnQ4QXJyYXkoZW5jcnlwdGVkLmJ5dGVMZW5ndGgpO1xuICAgIHZhciBpID0gMDtcblxuICAgIHRoaXMuYXN5bmNTdHJlYW1fID0gbmV3IEFzeW5jU3RyZWFtKCk7XG5cbiAgICAvLyBzcGxpdCB1cCB0aGUgZW5jcnlwdGlvbiBqb2IgYW5kIGRvIHRoZSBpbmRpdmlkdWFsIGNodW5rcyBhc3luY2hyb25vdXNseVxuICAgIHRoaXMuYXN5bmNTdHJlYW1fLnB1c2godGhpcy5kZWNyeXB0Q2h1bmtfKGVuY3J5cHRlZDMyLnN1YmFycmF5KGksIGkgKyBzdGVwKSwga2V5LCBpbml0VmVjdG9yLCBkZWNyeXB0ZWQpKTtcbiAgICBmb3IgKGkgPSBzdGVwOyBpIDwgZW5jcnlwdGVkMzIubGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgIGluaXRWZWN0b3IgPSBuZXcgVWludDMyQXJyYXkoW250b2goZW5jcnlwdGVkMzJbaSAtIDRdKSwgbnRvaChlbmNyeXB0ZWQzMltpIC0gM10pLCBudG9oKGVuY3J5cHRlZDMyW2kgLSAyXSksIG50b2goZW5jcnlwdGVkMzJbaSAtIDFdKV0pO1xuICAgICAgdGhpcy5hc3luY1N0cmVhbV8ucHVzaCh0aGlzLmRlY3J5cHRDaHVua18oZW5jcnlwdGVkMzIuc3ViYXJyYXkoaSwgaSArIHN0ZXApLCBrZXksIGluaXRWZWN0b3IsIGRlY3J5cHRlZCkpO1xuICAgIH1cbiAgICAvLyBpbnZva2UgdGhlIGRvbmUoKSBjYWxsYmFjayB3aGVuIGV2ZXJ5dGhpbmcgaXMgZmluaXNoZWRcbiAgICB0aGlzLmFzeW5jU3RyZWFtXy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHJlbW92ZSBwa2NzIzcgcGFkZGluZyBmcm9tIHRoZSBkZWNyeXB0ZWQgYnl0ZXNcbiAgICAgIGRvbmUobnVsbCwgdW5wYWQoZGVjcnlwdGVkKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogYSBnZXR0ZXIgZm9yIHN0ZXAgdGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHRvIHByb2Nlc3MgYXQgb25lIHRpbWVcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSB0aGUgdmFsdWUgb2Ygc3RlcCAzMjAwMFxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRGVjcnlwdGVyLnByb3RvdHlwZS5kZWNyeXB0Q2h1bmtfID0gZnVuY3Rpb24gZGVjcnlwdENodW5rXyhlbmNyeXB0ZWQsIGtleSwgaW5pdFZlY3RvciwgZGVjcnlwdGVkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBieXRlcyA9IGRlY3J5cHQoZW5jcnlwdGVkLCBrZXksIGluaXRWZWN0b3IpO1xuXG4gICAgICBkZWNyeXB0ZWQuc2V0KGJ5dGVzLCBlbmNyeXB0ZWQuYnl0ZU9mZnNldCk7XG4gICAgfTtcbiAgfTtcblxuICBjcmVhdGVDbGFzcyhEZWNyeXB0ZXIsIG51bGwsIFt7XG4gICAga2V5OiAnU1RFUCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAvLyA0ICogODAwMDtcbiAgICAgIHJldHVybiAzMjAwMDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERlY3J5cHRlcjtcbn0oKTtcblxuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICpcbiAqIEluZGV4IG1vZHVsZSB0byBlYXNpbHkgaW1wb3J0IHRoZSBwcmltYXJ5IGNvbXBvbmVudHMgb2YgQUVTLTEyOFxuICogZGVjcnlwdGlvbi4gTGlrZSB0aGlzOlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQge0RlY3J5cHRlciwgZGVjcnlwdCwgQXN5bmNTdHJlYW19IGZyb20gJ2Flcy1kZWNyeXB0ZXInO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHsgZGVjcnlwdCwgRGVjcnlwdGVyLCBBc3luY1N0cmVhbSB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/aes-decrypter/dist/aes-decrypter.es.js\n");

/***/ }),

/***/ "./node_modules/for-each/index.js":
/*!****************************************!*\
  !*** ./node_modules/for-each/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isCallable = __webpack_require__(/*! is-callable */ \"./node_modules/is-callable/index.js\");\n\nvar toStr = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar forEachArray = function forEachArray(array, iterator, receiver) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            if (receiver == null) {\n                iterator(array[i], i, array);\n            } else {\n                iterator.call(receiver, array[i], i, array);\n            }\n        }\n    }\n};\n\nvar forEachString = function forEachString(string, iterator, receiver) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        if (receiver == null) {\n            iterator(string.charAt(i), i, string);\n        } else {\n            iterator.call(receiver, string.charAt(i), i, string);\n        }\n    }\n};\n\nvar forEachObject = function forEachObject(object, iterator, receiver) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            if (receiver == null) {\n                iterator(object[k], k, object);\n            } else {\n                iterator.call(receiver, object[k], k, object);\n            }\n        }\n    }\n};\n\nvar forEach = function forEach(list, iterator, thisArg) {\n    if (!isCallable(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    var receiver;\n    if (arguments.length >= 3) {\n        receiver = thisArg;\n    }\n\n    if (toStr.call(list) === '[object Array]') {\n        forEachArray(list, iterator, receiver);\n    } else if (typeof list === 'string') {\n        forEachString(list, iterator, receiver);\n    } else {\n        forEachObject(list, iterator, receiver);\n    }\n};\n\nmodule.exports = forEach;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanM/ZDAyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmb3JFYWNoQXJyYXkgPSBmdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoU3RyaW5nID0gZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoT2JqZWN0ID0gZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoIWlzQ2FsbGFibGUoaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciByZWNlaXZlcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJlY2VpdmVyID0gdGhpc0FyZztcbiAgICB9XG5cbiAgICBpZiAodG9TdHIuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/for-each/index.js\n");

/***/ }),

/***/ "./node_modules/global/document.js":
/*!*****************************************!*\
  !*** ./node_modules/global/document.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var topLevel = typeof global !== 'undefined' ? global :\n    typeof window !== 'undefined' ? window : {}\nvar minDoc = __webpack_require__(/*! min-document */ 0);\n\nvar doccy;\n\nif (typeof document !== 'undefined') {\n    doccy = document;\n} else {\n    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\n    if (!doccy) {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n}\n\nmodule.exports = doccy;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2xvYmFsL2RvY3VtZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsb2JhbC9kb2N1bWVudC5qcz9lZjM0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b3BMZXZlbCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDpcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9XG52YXIgbWluRG9jID0gcmVxdWlyZSgnbWluLWRvY3VtZW50Jyk7XG5cbnZhciBkb2NjeTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkb2NjeSA9IGRvY3VtZW50O1xufSBlbHNlIHtcbiAgICBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J107XG5cbiAgICBpZiAoIWRvY2N5KSB7XG4gICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXSA9IG1pbkRvYztcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9jY3k7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/global/document.js\n");

/***/ }),

/***/ "./node_modules/global/window.js":
/*!***************************************!*\
  !*** ./node_modules/global/window.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2xvYmFsL3dpbmRvdy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzP2JlMDkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHdpbjtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW4gPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW4gPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICB3aW4gPSBzZWxmO1xufSBlbHNlIHtcbiAgICB3aW4gPSB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aW47XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/global/window.js\n");

/***/ }),

/***/ "./node_modules/is-callable/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-callable/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar fnToStr = Function.prototype.toString;\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isCallable(value) {\n\tif (!value) { return false; }\n\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\tif (typeof value === 'function' && !value.prototype) { return true; }\n\tif (hasToStringTag) { return tryFunctionObject(value); }\n\tif (isES6ClassFn(value)) { return false; }\n\tvar strClass = toStr.call(value);\n\treturn strClass === fnClass || strClass === genClass;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtY2FsbGFibGUvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtY2FsbGFibGUvaW5kZXguanM/MjFkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzXFxiLztcbnZhciBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRnVuY3Rpb24odmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3QoZm5TdHIpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvblRvU3RyKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG52YXIgZ2VuQ2xhc3MgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdmFsdWUucHJvdG90eXBlKSB7IHJldHVybiB0cnVlOyB9XG5cdGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9XG5cdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0cmV0dXJuIHN0ckNsYXNzID09PSBmbkNsYXNzIHx8IHN0ckNsYXNzID09PSBnZW5DbGFzcztcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/is-callable/index.js\n");

/***/ }),

/***/ "./node_modules/is-function/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-function/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtZnVuY3Rpb24vaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtZnVuY3Rpb24vaW5kZXguanM/ODM2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb25cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChmbikge1xuICB2YXIgc3RyaW5nID0gdG9TdHJpbmcuY2FsbChmbilcbiAgcmV0dXJuIHN0cmluZyA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fFxuICAgICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgc3RyaW5nICE9PSAnW29iamVjdCBSZWdFeHBdJykgfHxcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgLy8gSUU4IGFuZCBiZWxvd1xuICAgICAoZm4gPT09IHdpbmRvdy5zZXRUaW1lb3V0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmFsZXJ0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmNvbmZpcm0gfHxcbiAgICAgIGZuID09PSB3aW5kb3cucHJvbXB0KSlcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/is-function/index.js\n");

/***/ }),

/***/ "./node_modules/m3u8-parser/dist/m3u8-parser.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/m3u8-parser/dist/m3u8-parser.es.js ***!
  \*********************************************************/
/*! exports provided: LineStream, ParseStream, Parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineStream\", function() { return LineStream; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseStream\", function() { return ParseStream; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Parser\", function() { return Parser; });\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n\n\n\n\n\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n/**\n * @file stream.js\n */\n/**\n * A lightweight readable stream implemention that handles event dispatching.\n *\n * @class Stream\n */\nvar Stream = function () {\n  function Stream() {\n    classCallCheck(this, Stream);\n\n    this.listeners = {};\n  }\n\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {String} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n\n  Stream.prototype.on = function on(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n    this.listeners[type].push(listener);\n  };\n\n  /**\n   * Remove a listener for a specified event type.\n   *\n   * @param {String} type the event name\n   * @param {Function} listener  a function previously registered for this\n   * type of event through `on`\n   * @return {Boolean} if we could turn it off or not\n   */\n\n\n  Stream.prototype.off = function off(type, listener) {\n    if (!this.listeners[type]) {\n      return false;\n    }\n\n    var index = this.listeners[type].indexOf(listener);\n\n    this.listeners[type].splice(index, 1);\n    return index > -1;\n  };\n\n  /**\n   * Trigger an event of the specified type on this stream. Any additional\n   * arguments to this function are passed as parameters to event listeners.\n   *\n   * @param {String} type the event name\n   */\n\n\n  Stream.prototype.trigger = function trigger(type) {\n    var callbacks = this.listeners[type];\n    var i = void 0;\n    var length = void 0;\n    var args = void 0;\n\n    if (!callbacks) {\n      return;\n    }\n    // Slicing the arguments on every invocation of this method\n    // can add a significant amount of overhead. Avoid the\n    // intermediate object creation for the common case of a\n    // single callback argument\n    if (arguments.length === 2) {\n      length = callbacks.length;\n      for (i = 0; i < length; ++i) {\n        callbacks[i].call(this, arguments[1]);\n      }\n    } else {\n      args = Array.prototype.slice.call(arguments, 1);\n      length = callbacks.length;\n      for (i = 0; i < length; ++i) {\n        callbacks[i].apply(this, args);\n      }\n    }\n  };\n\n  /**\n   * Destroys the stream and cleans up.\n   */\n\n\n  Stream.prototype.dispose = function dispose() {\n    this.listeners = {};\n  };\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   *\n   * @param {Stream} destination the stream that will receive all `data` events\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n\n\n  Stream.prototype.pipe = function pipe(destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n  };\n\n  return Stream;\n}();\n\n/**\n * @file m3u8/line-stream.js\n */\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\nvar LineStream = function (_Stream) {\n  inherits(LineStream, _Stream);\n\n  function LineStream() {\n    classCallCheck(this, LineStream);\n\n    var _this = possibleConstructorReturn(this, _Stream.call(this));\n\n    _this.buffer = '';\n    return _this;\n  }\n\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {String} data the text to process\n   */\n\n\n  LineStream.prototype.push = function push(data) {\n    var nextNewline = void 0;\n\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  };\n\n  return LineStream;\n}(Stream);\n\n/**\n * @file m3u8/parse-stream.js\n */\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\nvar attributeSeparator = function attributeSeparator() {\n  var key = '[^=]*';\n  var value = '\"[^\"]*\"|[^,]*';\n  var keyvalue = '(?:' + key + ')=(?:' + value + ')';\n\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n\n/**\n * Parse attributes from a line given the seperator\n *\n * @param {String} attributes the attibute line to parse\n */\nvar parseAttributes = function parseAttributes(attributes) {\n  // split the string using attributes as the separator\n  var attrs = attributes.split(attributeSeparator());\n  var result = {};\n  var i = attrs.length;\n  var attr = void 0;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    }\n\n    // split the key and value\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);\n    // trim whitespace and remove optional quotes around the value\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n  return result;\n};\n\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\nvar ParseStream = function (_Stream) {\n  inherits(ParseStream, _Stream);\n\n  function ParseStream() {\n    classCallCheck(this, ParseStream);\n\n    var _this = possibleConstructorReturn(this, _Stream.call(this));\n\n    _this.customParsers = [];\n    return _this;\n  }\n\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {String} line a single line of an M3U8 file to parse\n   */\n\n\n  ParseStream.prototype.push = function push(line) {\n    var match = void 0;\n    var event = void 0;\n\n    // strip whitespace\n    line = line.replace(/^[\\u0000\\s]+|[\\u0000\\s]+$/g, '');\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    }\n\n    // URIs\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    }\n\n    for (var i = 0; i < this.customParsers.length; i++) {\n      if (this.customParsers[i].call(this, line)) {\n        return;\n      }\n    }\n\n    // Comments\n    if (line.indexOf('#EXT') !== 0) {\n      this.trigger('data', {\n        type: 'comment',\n        text: line.slice(1)\n      });\n      return;\n    }\n\n    // strip off any carriage returns here so the regex matching\n    // doesn't have to account for them.\n    line = line.replace('\\r', '');\n\n    // Tags\n    match = /^#EXTM3U/.exec(line);\n    if (match) {\n      this.trigger('data', {\n        type: 'tag',\n        tagType: 'm3u'\n      });\n      return;\n    }\n    match = /^#EXTINF:?([0-9\\.]*)?,?(.*)?$/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'inf'\n      };\n      if (match[1]) {\n        event.duration = parseFloat(match[1]);\n      }\n      if (match[2]) {\n        event.title = match[2];\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'targetduration'\n      };\n      if (match[1]) {\n        event.duration = parseInt(match[1], 10);\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#ZEN-TOTAL-DURATION:?([0-9.]*)?/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'totalduration'\n      };\n      if (match[1]) {\n        event.duration = parseInt(match[1], 10);\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'version'\n      };\n      if (match[1]) {\n        event.version = parseInt(match[1], 10);\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-MEDIA-SEQUENCE:?(\\-?[0-9.]*)?/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'media-sequence'\n      };\n      if (match[1]) {\n        event.number = parseInt(match[1], 10);\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\\-?[0-9.]*)?/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'discontinuity-sequence'\n      };\n      if (match[1]) {\n        event.number = parseInt(match[1], 10);\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'playlist-type'\n      };\n      if (match[1]) {\n        event.playlistType = match[1];\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-BYTERANGE:?([0-9.]*)?@?([0-9.]*)?/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'byterange'\n      };\n      if (match[1]) {\n        event.length = parseInt(match[1], 10);\n      }\n      if (match[2]) {\n        event.offset = parseInt(match[2], 10);\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'allow-cache'\n      };\n      if (match[1]) {\n        event.allowed = !/NO/.test(match[1]);\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-MAP:?(.*)$/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'map'\n      };\n\n      if (match[1]) {\n        var attributes = parseAttributes(match[1]);\n\n        if (attributes.URI) {\n          event.uri = attributes.URI;\n        }\n        if (attributes.BYTERANGE) {\n          var _attributes$BYTERANGE = attributes.BYTERANGE.split('@'),\n              length = _attributes$BYTERANGE[0],\n              offset = _attributes$BYTERANGE[1];\n\n          event.byterange = {};\n          if (length) {\n            event.byterange.length = parseInt(length, 10);\n          }\n          if (offset) {\n            event.byterange.offset = parseInt(offset, 10);\n          }\n        }\n      }\n\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'stream-inf'\n      };\n      if (match[1]) {\n        event.attributes = parseAttributes(match[1]);\n\n        if (event.attributes.RESOLUTION) {\n          var split = event.attributes.RESOLUTION.split('x');\n          var resolution = {};\n\n          if (split[0]) {\n            resolution.width = parseInt(split[0], 10);\n          }\n          if (split[1]) {\n            resolution.height = parseInt(split[1], 10);\n          }\n          event.attributes.RESOLUTION = resolution;\n        }\n        if (event.attributes.BANDWIDTH) {\n          event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n        }\n        if (event.attributes['PROGRAM-ID']) {\n          event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n        }\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-MEDIA:?(.*)$/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'media'\n      };\n      if (match[1]) {\n        event.attributes = parseAttributes(match[1]);\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-ENDLIST/.exec(line);\n    if (match) {\n      this.trigger('data', {\n        type: 'tag',\n        tagType: 'endlist'\n      });\n      return;\n    }\n    match = /^#EXT-X-DISCONTINUITY/.exec(line);\n    if (match) {\n      this.trigger('data', {\n        type: 'tag',\n        tagType: 'discontinuity'\n      });\n      return;\n    }\n    match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'program-date-time'\n      };\n      if (match[1]) {\n        event.dateTimeString = match[1];\n        event.dateTimeObject = new Date(match[1]);\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-KEY:?(.*)$/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'key'\n      };\n      if (match[1]) {\n        event.attributes = parseAttributes(match[1]);\n        // parse the IV string into a Uint32Array\n        if (event.attributes.IV) {\n          if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n            event.attributes.IV = event.attributes.IV.substring(2);\n          }\n\n          event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n          event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n          event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n          event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n          event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n          event.attributes.IV = new Uint32Array(event.attributes.IV);\n        }\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-START:?(.*)$/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'start'\n      };\n      if (match[1]) {\n        event.attributes = parseAttributes(match[1]);\n\n        event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n        event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'cue-out-cont'\n      };\n      if (match[1]) {\n        event.data = match[1];\n      } else {\n        event.data = '';\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'cue-out'\n      };\n      if (match[1]) {\n        event.data = match[1];\n      } else {\n        event.data = '';\n      }\n      this.trigger('data', event);\n      return;\n    }\n    match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(line);\n    if (match) {\n      event = {\n        type: 'tag',\n        tagType: 'cue-in'\n      };\n      if (match[1]) {\n        event.data = match[1];\n      } else {\n        event.data = '';\n      }\n      this.trigger('data', event);\n      return;\n    }\n\n    // unknown tag type\n    this.trigger('data', {\n      type: 'tag',\n      data: line.slice(4)\n    });\n  };\n\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  ParseStream.prototype.addParser = function addParser(_ref) {\n    var _this2 = this;\n\n    var expression = _ref.expression,\n        customType = _ref.customType,\n        dataParser = _ref.dataParser,\n        segment = _ref.segment;\n\n    if (typeof dataParser !== 'function') {\n      dataParser = function dataParser(line) {\n        return line;\n      };\n    }\n    this.customParsers.push(function (line) {\n      var match = expression.exec(line);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType: customType,\n          segment: segment\n        });\n        return true;\n      }\n    });\n  };\n\n  return ParseStream;\n}(Stream);\n\n/**\n * @file m3u8/parser.js\n */\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @extends Stream\n */\n\nvar Parser = function (_Stream) {\n  inherits(Parser, _Stream);\n\n  function Parser() {\n    classCallCheck(this, Parser);\n\n    var _this = possibleConstructorReturn(this, _Stream.call(this));\n\n    _this.lineStream = new LineStream();\n    _this.parseStream = new ParseStream();\n    _this.lineStream.pipe(_this.parseStream);\n\n    /* eslint-disable consistent-this */\n    var self = _this;\n    /* eslint-enable consistent-this */\n    var uris = [];\n    var currentUri = {};\n    // if specified, the active EXT-X-MAP definition\n    var currentMap = void 0;\n    // if specified, the active decryption key\n    var _key = void 0;\n    var noop = function noop() {};\n    var defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    };\n    // group segments into numbered timelines delineated by discontinuities\n    var currentTimeline = 0;\n\n    // the manifest is empty until the parse stream begins delivering data\n    _this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      segments: []\n    };\n\n    // update the manifest with the m3u8 entry from the parse stream\n    _this.parseStream.on('data', function (entry) {\n      var mediaGroup = void 0;\n      var rendition = void 0;\n\n      ({\n        tag: function tag() {\n          // switch based on the tag type\n          (({\n            'allow-cache': function allowCache() {\n              this.manifest.allowCache = entry.allowed;\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n            byterange: function byterange() {\n              var byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  this.trigger('info', {\n                    message: 'defaulting offset to zero'\n                  });\n                  entry.offset = 0;\n                }\n              }\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n            },\n            endlist: function endlist() {\n              this.manifest.endList = true;\n            },\n            inf: function inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n            key: function key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              }\n              // clear the active encryption key\n              if (entry.attributes.METHOD === 'NONE') {\n                _key = null;\n                return;\n              }\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              }\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              }\n\n              // setup an encryption key for upcoming segments\n              _key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                _key.iv = entry.attributes.IV;\n              }\n            },\n            'media-sequence': function mediaSequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n              this.manifest.mediaSequence = entry.number;\n            },\n            'discontinuity-sequence': function discontinuitySequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n            'playlist-type': function playlistType() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n              this.manifest.playlistType = entry.playlistType;\n            },\n            map: function map() {\n              currentMap = {};\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n            },\n            'stream-inf': function streamInf() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n              _extends(currentUri.attributes, entry.attributes);\n            },\n            media: function media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              }\n\n              // find the media group, creating defaults as necessary\n              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']];\n\n              // collect the rendition metadata\n              rendition = {\n                'default': /yes/i.test(entry.attributes.DEFAULT)\n              };\n              if (rendition['default']) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              }\n\n              // insert the new rendition\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n            discontinuity: function discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n            'program-date-time': function programDateTime() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n            },\n            targetduration: function targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n              this.manifest.targetDuration = entry.duration;\n            },\n            totalduration: function totalduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid total duration: ' + entry.duration\n                });\n                return;\n              }\n              this.manifest.totalDuration = entry.duration;\n            },\n            start: function start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n            'cue-out': function cueOut() {\n              currentUri.cueOut = entry.data;\n            },\n            'cue-out-cont': function cueOutCont() {\n              currentUri.cueOutCont = entry.data;\n            },\n            'cue-in': function cueIn() {\n              currentUri.cueIn = entry.data;\n            }\n          })[entry.tagType] || noop).call(self);\n        },\n        uri: function uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri);\n\n          // if no explicit duration was declared, use the target duration\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          }\n          // annotate with encryption information, if necessary\n          if (_key) {\n            currentUri.key = _key;\n          }\n          currentUri.timeline = currentTimeline;\n          // annotate with initialization segment information, if necessary\n          if (currentMap) {\n            currentUri.map = currentMap;\n          }\n\n          // prepare for the next URI\n          currentUri = {};\n        },\n        comment: function comment() {\n          // comments are not important for playback\n        },\n        custom: function custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data;\n            // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n      })[entry.type].call(self);\n    });\n    return _this;\n  }\n\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {String} chunk a potentially incomplete portion of the manifest\n   */\n\n\n  Parser.prototype.push = function push(chunk) {\n    this.lineStream.push(chunk);\n  };\n\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n\n\n  Parser.prototype.end = function end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n  };\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.type         the type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  Parser.prototype.addParser = function addParser(options) {\n    this.parseStream.addParser(options);\n  };\n\n  return Parser;\n}(Stream);\n\n/**\n * @file m3u8/index.js\n *\n * Utilities for parsing M3U8 files. If the entire manifest is available,\n * `Parser` will create an object representation with enough detail for managing\n * playback. `ParseStream` and `LineStream` are lower-level parsing primitives\n * that do not assume the entirety of the manifest is ready and expose a\n * ReadableStream-like interface.\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbTN1OC1wYXJzZXIvZGlzdC9tM3U4LXBhcnNlci5lcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tM3U4LXBhcnNlci9kaXN0L20zdTgtcGFyc2VyLmVzLmpzP2Q3NDkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuXG5cblxuXG5cblxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cbi8qKlxuICogQGZpbGUgc3RyZWFtLmpzXG4gKi9cbi8qKlxuICogQSBsaWdodHdlaWdodCByZWFkYWJsZSBzdHJlYW0gaW1wbGVtZW50aW9uIHRoYXQgaGFuZGxlcyBldmVudCBkaXNwYXRjaGluZy5cbiAqXG4gKiBAY2xhc3MgU3RyZWFtXG4gKi9cbnZhciBTdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJlYW0pO1xuXG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBzcGVjaWZpZWQgZXZlbnQgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIGV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBhbiBldmVudCBvZlxuICAgKiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzXG4gICAqL1xuXG5cbiAgU3RyZWFtLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGxpc3RlbmVyIGZvciBhIHNwZWNpZmllZCBldmVudCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgZXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAgYSBmdW5jdGlvbiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgZm9yIHRoaXNcbiAgICogdHlwZSBvZiBldmVudCB0aHJvdWdoIGBvbmBcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gaWYgd2UgY291bGQgdHVybiBpdCBvZmYgb3Igbm90XG4gICAqL1xuXG5cbiAgU3RyZWFtLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5saXN0ZW5lcnNbdHlwZV0uaW5kZXhPZihsaXN0ZW5lcik7XG5cbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiBpbmRleCA+IC0xO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvbiB0aGlzIHN0cmVhbS4gQW55IGFkZGl0aW9uYWxcbiAgICogYXJndW1lbnRzIHRvIHRoaXMgZnVuY3Rpb24gYXJlIHBhc3NlZCBhcyBwYXJhbWV0ZXJzIHRvIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIGV2ZW50IG5hbWVcbiAgICovXG5cblxuICBTdHJlYW0ucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyKHR5cGUpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5saXN0ZW5lcnNbdHlwZV07XG4gICAgdmFyIGkgPSB2b2lkIDA7XG4gICAgdmFyIGxlbmd0aCA9IHZvaWQgMDtcbiAgICB2YXIgYXJncyA9IHZvaWQgMDtcblxuICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFNsaWNpbmcgdGhlIGFyZ3VtZW50cyBvbiBldmVyeSBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kXG4gICAgLy8gY2FuIGFkZCBhIHNpZ25pZmljYW50IGFtb3VudCBvZiBvdmVyaGVhZC4gQXZvaWQgdGhlXG4gICAgLy8gaW50ZXJtZWRpYXRlIG9iamVjdCBjcmVhdGlvbiBmb3IgdGhlIGNvbW1vbiBjYXNlIG9mIGFcbiAgICAvLyBzaW5nbGUgY2FsbGJhY2sgYXJndW1lbnRcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgbGVuZ3RoID0gY2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjYWxsYmFja3NbaV0uY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIGxlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIHN0cmVhbSBhbmQgY2xlYW5zIHVwLlxuICAgKi9cblxuXG4gIFN0cmVhbS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgfTtcbiAgLyoqXG4gICAqIEZvcndhcmRzIGFsbCBgZGF0YWAgZXZlbnRzIG9uIHRoaXMgc3RyZWFtIHRvIHRoZSBkZXN0aW5hdGlvbiBzdHJlYW0uIFRoZVxuICAgKiBkZXN0aW5hdGlvbiBzdHJlYW0gc2hvdWxkIHByb3ZpZGUgYSBtZXRob2QgYHB1c2hgIHRvIHJlY2VpdmUgdGhlIGRhdGFcbiAgICogZXZlbnRzIGFzIHRoZXkgYXJyaXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmVhbX0gZGVzdGluYXRpb24gdGhlIHN0cmVhbSB0aGF0IHdpbGwgcmVjZWl2ZSBhbGwgYGRhdGFgIGV2ZW50c1xuICAgKiBAc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fcmVhZGFibGVfcGlwZV9kZXN0aW5hdGlvbl9vcHRpb25zXG4gICAqL1xuXG5cbiAgU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gcGlwZShkZXN0aW5hdGlvbikge1xuICAgIHRoaXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgZGVzdGluYXRpb24ucHVzaChkYXRhKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gU3RyZWFtO1xufSgpO1xuXG4vKipcbiAqIEBmaWxlIG0zdTgvbGluZS1zdHJlYW0uanNcbiAqL1xuLyoqXG4gKiBBIHN0cmVhbSB0aGF0IGJ1ZmZlcnMgc3RyaW5nIGlucHV0IGFuZCBnZW5lcmF0ZXMgYSBgZGF0YWAgZXZlbnQgZm9yIGVhY2hcbiAqIGxpbmUuXG4gKlxuICogQGNsYXNzIExpbmVTdHJlYW1cbiAqIEBleHRlbmRzIFN0cmVhbVxuICovXG5cbnZhciBMaW5lU3RyZWFtID0gZnVuY3Rpb24gKF9TdHJlYW0pIHtcbiAgaW5oZXJpdHMoTGluZVN0cmVhbSwgX1N0cmVhbSk7XG5cbiAgZnVuY3Rpb24gTGluZVN0cmVhbSgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lU3RyZWFtKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1N0cmVhbS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLmJ1ZmZlciA9ICcnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbmV3IGRhdGEgdG8gYmUgcGFyc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0aGUgdGV4dCB0byBwcm9jZXNzXG4gICAqL1xuXG5cbiAgTGluZVN0cmVhbS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2goZGF0YSkge1xuICAgIHZhciBuZXh0TmV3bGluZSA9IHZvaWQgMDtcblxuICAgIHRoaXMuYnVmZmVyICs9IGRhdGE7XG4gICAgbmV4dE5ld2xpbmUgPSB0aGlzLmJ1ZmZlci5pbmRleE9mKCdcXG4nKTtcblxuICAgIGZvciAoOyBuZXh0TmV3bGluZSA+IC0xOyBuZXh0TmV3bGluZSA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1xcbicpKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcoMCwgbmV4dE5ld2xpbmUpKTtcbiAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKG5leHROZXdsaW5lICsgMSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBMaW5lU3RyZWFtO1xufShTdHJlYW0pO1xuXG4vKipcbiAqIEBmaWxlIG0zdTgvcGFyc2Utc3RyZWFtLmpzXG4gKi9cbi8qKlxuICogXCJmb3JnaXZpbmdcIiBhdHRyaWJ1dGUgbGlzdCBwc3VlZG8tZ3JhbW1hcjpcbiAqIGF0dHJpYnV0ZXMgLT4ga2V5dmFsdWUgKCcsJyBrZXl2YWx1ZSkqXG4gKiBrZXl2YWx1ZSAgIC0+IGtleSAnPScgdmFsdWVcbiAqIGtleSAgICAgICAgLT4gW149XSpcbiAqIHZhbHVlICAgICAgLT4gJ1wiJyBbXlwiXSogJ1wiJyB8IFteLF0qXG4gKi9cbnZhciBhdHRyaWJ1dGVTZXBhcmF0b3IgPSBmdW5jdGlvbiBhdHRyaWJ1dGVTZXBhcmF0b3IoKSB7XG4gIHZhciBrZXkgPSAnW149XSonO1xuICB2YXIgdmFsdWUgPSAnXCJbXlwiXSpcInxbXixdKic7XG4gIHZhciBrZXl2YWx1ZSA9ICcoPzonICsga2V5ICsgJyk9KD86JyArIHZhbHVlICsgJyknO1xuXG4gIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefCwpKCcgKyBrZXl2YWx1ZSArICcpJyk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGF0dHJpYnV0ZXMgZnJvbSBhIGxpbmUgZ2l2ZW4gdGhlIHNlcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVzIHRoZSBhdHRpYnV0ZSBsaW5lIHRvIHBhcnNlXG4gKi9cbnZhciBwYXJzZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAvLyBzcGxpdCB0aGUgc3RyaW5nIHVzaW5nIGF0dHJpYnV0ZXMgYXMgdGhlIHNlcGFyYXRvclxuICB2YXIgYXR0cnMgPSBhdHRyaWJ1dGVzLnNwbGl0KGF0dHJpYnV0ZVNlcGFyYXRvcigpKTtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgaSA9IGF0dHJzLmxlbmd0aDtcbiAgdmFyIGF0dHIgPSB2b2lkIDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIC8vIGZpbHRlciBvdXQgdW5tYXRjaGVkIHBvcnRpb25zIG9mIHRoZSBzdHJpbmdcbiAgICBpZiAoYXR0cnNbaV0gPT09ICcnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBzcGxpdCB0aGUga2V5IGFuZCB2YWx1ZVxuICAgIGF0dHIgPSAvKFtePV0qKT0oLiopLy5leGVjKGF0dHJzW2ldKS5zbGljZSgxKTtcbiAgICAvLyB0cmltIHdoaXRlc3BhY2UgYW5kIHJlbW92ZSBvcHRpb25hbCBxdW90ZXMgYXJvdW5kIHRoZSB2YWx1ZVxuICAgIGF0dHJbMF0gPSBhdHRyWzBdLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgICBhdHRyWzFdID0gYXR0clsxXS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gICAgYXR0clsxXSA9IGF0dHJbMV0ucmVwbGFjZSgvXlsnXCJdKC4qKVsnXCJdJC9nLCAnJDEnKTtcbiAgICByZXN1bHRbYXR0clswXV0gPSBhdHRyWzFdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEEgbGluZS1sZXZlbCBNM1U4IHBhcnNlciBldmVudCBzdHJlYW0uIEl0IGV4cGVjdHMgdG8gcmVjZWl2ZSBpbnB1dCBvbmVcbiAqIGxpbmUgYXQgYSB0aW1lIGFuZCBwZXJmb3JtcyBhIGNvbnRleHQtZnJlZSBwYXJzZSBvZiBpdHMgY29udGVudHMuIEEgc3RyZWFtXG4gKiBpbnRlcnByZXRhdGlvbiBvZiBhIG1hbmlmZXN0IGNhbiBiZSB1c2VmdWwgaWYgdGhlIG1hbmlmZXN0IGlzIGV4cGVjdGVkIHRvXG4gKiBiZSB0b28gbGFyZ2UgdG8gZml0IGNvbWZvcnRhYmx5IGludG8gbWVtb3J5IG9yIHRoZSBlbnRpcmV0eSBvZiB0aGUgaW5wdXRcbiAqIGlzIG5vdCBpbW1lZGlhdGVseSBhdmFpbGFibGUuIE90aGVyd2lzZSwgaXQncyBwcm9iYWJseSBtdWNoIGVhc2llciB0byB3b3JrXG4gKiB3aXRoIGEgcmVndWxhciBgUGFyc2VyYCBvYmplY3QuXG4gKlxuICogUHJvZHVjZXMgYGRhdGFgIGV2ZW50cyB3aXRoIGFuIG9iamVjdCB0aGF0IGNhcHR1cmVzIHRoZSBwYXJzZXInc1xuICogaW50ZXJwcmV0YXRpb24gb2YgdGhlIGlucHV0LiBUaGF0IG9iamVjdCBoYXMgYSBwcm9wZXJ0eSBgdGFnYCB0aGF0IGlzIG9uZVxuICogb2YgYHVyaWAsIGBjb21tZW50YCwgb3IgYHRhZ2AuIFVSSXMgb25seSBoYXZlIGEgc2luZ2xlIGFkZGl0aW9uYWxcbiAqIHByb3BlcnR5LCBgbGluZWAsIHdoaWNoIGNhcHR1cmVzIHRoZSBlbnRpcmV0eSBvZiB0aGUgaW5wdXQgd2l0aG91dFxuICogaW50ZXJwcmV0YXRpb24uIENvbW1lbnRzIHNpbWlsYXJseSBoYXZlIGEgc2luZ2xlIGFkZGl0aW9uYWwgcHJvcGVydHlcbiAqIGB0ZXh0YCB3aGljaCBpcyB0aGUgaW5wdXQgd2l0aG91dCB0aGUgbGVhZGluZyBgI2AuXG4gKlxuICogVGFncyBhbHdheXMgaGF2ZSBhIHByb3BlcnR5IGB0YWdUeXBlYCB3aGljaCBpcyB0aGUgbG93ZXItY2FzZWQgdmVyc2lvbiBvZlxuICogdGhlIE0zVTggZGlyZWN0aXZlIHdpdGhvdXQgdGhlIGAjRVhUYCBvciBgI0VYVC1YLWAgcHJlZml4LiBGb3IgaW5zdGFuY2UsXG4gKiBgI0VYVC1YLU1FRElBLVNFUVVFTkNFYCBiZWNvbWVzIGBtZWRpYS1zZXF1ZW5jZWAgd2hlbiBwYXJzZWQuIFVucmVjb2duaXplZFxuICogdGFncyBhcmUgZ2l2ZW4gdGhlIHRhZyB0eXBlIGB1bmtub3duYCBhbmQgYSBzaW5nbGUgYWRkaXRpb25hbCBwcm9wZXJ0eVxuICogYGRhdGFgIHdpdGggdGhlIHJlbWFpbmRlciBvZiB0aGUgaW5wdXQuXG4gKlxuICogQGNsYXNzIFBhcnNlU3RyZWFtXG4gKiBAZXh0ZW5kcyBTdHJlYW1cbiAqL1xuXG52YXIgUGFyc2VTdHJlYW0gPSBmdW5jdGlvbiAoX1N0cmVhbSkge1xuICBpbmhlcml0cyhQYXJzZVN0cmVhbSwgX1N0cmVhbSk7XG5cbiAgZnVuY3Rpb24gUGFyc2VTdHJlYW0oKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyc2VTdHJlYW0pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU3RyZWFtLmNhbGwodGhpcykpO1xuXG4gICAgX3RoaXMuY3VzdG9tUGFyc2VycyA9IFtdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gYWRkaXRpb25hbCBsaW5lIG9mIGlucHV0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZSBhIHNpbmdsZSBsaW5lIG9mIGFuIE0zVTggZmlsZSB0byBwYXJzZVxuICAgKi9cblxuXG4gIFBhcnNlU3RyZWFtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaChsaW5lKSB7XG4gICAgdmFyIG1hdGNoID0gdm9pZCAwO1xuICAgIHZhciBldmVudCA9IHZvaWQgMDtcblxuICAgIC8vIHN0cmlwIHdoaXRlc3BhY2VcbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9eW1xcdTAwMDBcXHNdK3xbXFx1MDAwMFxcc10rJC9nLCAnJyk7XG4gICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBpZ25vcmUgZW1wdHkgbGluZXNcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBVUklzXG4gICAgaWYgKGxpbmVbMF0gIT09ICcjJykge1xuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywge1xuICAgICAgICB0eXBlOiAndXJpJyxcbiAgICAgICAgdXJpOiBsaW5lXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY3VzdG9tUGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuY3VzdG9tUGFyc2Vyc1tpXS5jYWxsKHRoaXMsIGxpbmUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21tZW50c1xuICAgIGlmIChsaW5lLmluZGV4T2YoJyNFWFQnKSAhPT0gMCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywge1xuICAgICAgICB0eXBlOiAnY29tbWVudCcsXG4gICAgICAgIHRleHQ6IGxpbmUuc2xpY2UoMSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN0cmlwIG9mZiBhbnkgY2FycmlhZ2UgcmV0dXJucyBoZXJlIHNvIHRoZSByZWdleCBtYXRjaGluZ1xuICAgIC8vIGRvZXNuJ3QgaGF2ZSB0byBhY2NvdW50IGZvciB0aGVtLlxuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoJ1xccicsICcnKTtcblxuICAgIC8vIFRhZ3NcbiAgICBtYXRjaCA9IC9eI0VYVE0zVS8uZXhlYyhsaW5lKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIHtcbiAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgIHRhZ1R5cGU6ICdtM3UnXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWF0Y2ggPSAvXiNFWFRJTkY6PyhbMC05XFwuXSopPyw/KC4qKT8kLy5leGVjKGxpbmUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgZXZlbnQgPSB7XG4gICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICB0YWdUeXBlOiAnaW5mJ1xuICAgICAgfTtcbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBldmVudC5kdXJhdGlvbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgIGV2ZW50LnRpdGxlID0gbWF0Y2hbMl07XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdGNoID0gL14jRVhULVgtVEFSR0VURFVSQVRJT046PyhbMC05Ll0qKT8vLmV4ZWMobGluZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBldmVudCA9IHtcbiAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgIHRhZ1R5cGU6ICd0YXJnZXRkdXJhdGlvbidcbiAgICAgIH07XG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgZXZlbnQuZHVyYXRpb24gPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXRjaCA9IC9eI1pFTi1UT1RBTC1EVVJBVElPTjo/KFswLTkuXSopPy8uZXhlYyhsaW5lKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGV2ZW50ID0ge1xuICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgdGFnVHlwZTogJ3RvdGFsZHVyYXRpb24nXG4gICAgICB9O1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGV2ZW50LmR1cmF0aW9uID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWF0Y2ggPSAvXiNFWFQtWC1WRVJTSU9OOj8oWzAtOS5dKik/Ly5leGVjKGxpbmUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgZXZlbnQgPSB7XG4gICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICB0YWdUeXBlOiAndmVyc2lvbidcbiAgICAgIH07XG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgZXZlbnQudmVyc2lvbiA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdGNoID0gL14jRVhULVgtTUVESUEtU0VRVUVOQ0U6PyhcXC0/WzAtOS5dKik/Ly5leGVjKGxpbmUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgZXZlbnQgPSB7XG4gICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICB0YWdUeXBlOiAnbWVkaWEtc2VxdWVuY2UnXG4gICAgICB9O1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGV2ZW50Lm51bWJlciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdGNoID0gL14jRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRTo/KFxcLT9bMC05Ll0qKT8vLmV4ZWMobGluZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBldmVudCA9IHtcbiAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgIHRhZ1R5cGU6ICdkaXNjb250aW51aXR5LXNlcXVlbmNlJ1xuICAgICAgfTtcbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBldmVudC5udW1iZXIgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXRjaCA9IC9eI0VYVC1YLVBMQVlMSVNULVRZUEU6PyguKik/JC8uZXhlYyhsaW5lKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGV2ZW50ID0ge1xuICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgdGFnVHlwZTogJ3BsYXlsaXN0LXR5cGUnXG4gICAgICB9O1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGV2ZW50LnBsYXlsaXN0VHlwZSA9IG1hdGNoWzFdO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXRjaCA9IC9eI0VYVC1YLUJZVEVSQU5HRTo/KFswLTkuXSopP0A/KFswLTkuXSopPy8uZXhlYyhsaW5lKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGV2ZW50ID0ge1xuICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgdGFnVHlwZTogJ2J5dGVyYW5nZSdcbiAgICAgIH07XG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgZXZlbnQubGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICBldmVudC5vZmZzZXQgPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXRjaCA9IC9eI0VYVC1YLUFMTE9XLUNBQ0hFOj8oWUVTfE5PKT8vLmV4ZWMobGluZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBldmVudCA9IHtcbiAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgIHRhZ1R5cGU6ICdhbGxvdy1jYWNoZSdcbiAgICAgIH07XG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgZXZlbnQuYWxsb3dlZCA9ICEvTk8vLnRlc3QobWF0Y2hbMV0pO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXRjaCA9IC9eI0VYVC1YLU1BUDo/KC4qKSQvLmV4ZWMobGluZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBldmVudCA9IHtcbiAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgIHRhZ1R5cGU6ICdtYXAnXG4gICAgICB9O1xuXG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobWF0Y2hbMV0pO1xuXG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLlVSSSkge1xuICAgICAgICAgIGV2ZW50LnVyaSA9IGF0dHJpYnV0ZXMuVVJJO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLkJZVEVSQU5HRSkge1xuICAgICAgICAgIHZhciBfYXR0cmlidXRlcyRCWVRFUkFOR0UgPSBhdHRyaWJ1dGVzLkJZVEVSQU5HRS5zcGxpdCgnQCcpLFxuICAgICAgICAgICAgICBsZW5ndGggPSBfYXR0cmlidXRlcyRCWVRFUkFOR0VbMF0sXG4gICAgICAgICAgICAgIG9mZnNldCA9IF9hdHRyaWJ1dGVzJEJZVEVSQU5HRVsxXTtcblxuICAgICAgICAgIGV2ZW50LmJ5dGVyYW5nZSA9IHt9O1xuICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGV2ZW50LmJ5dGVyYW5nZS5sZW5ndGggPSBwYXJzZUludChsZW5ndGgsIDEwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgZXZlbnQuYnl0ZXJhbmdlLm9mZnNldCA9IHBhcnNlSW50KG9mZnNldCwgMTApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdGNoID0gL14jRVhULVgtU1RSRUFNLUlORjo/KC4qKSQvLmV4ZWMobGluZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBldmVudCA9IHtcbiAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgIHRhZ1R5cGU6ICdzdHJlYW0taW5mJ1xuICAgICAgfTtcbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBldmVudC5hdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKG1hdGNoWzFdKTtcblxuICAgICAgICBpZiAoZXZlbnQuYXR0cmlidXRlcy5SRVNPTFVUSU9OKSB7XG4gICAgICAgICAgdmFyIHNwbGl0ID0gZXZlbnQuYXR0cmlidXRlcy5SRVNPTFVUSU9OLnNwbGl0KCd4Jyk7XG4gICAgICAgICAgdmFyIHJlc29sdXRpb24gPSB7fTtcblxuICAgICAgICAgIGlmIChzcGxpdFswXSkge1xuICAgICAgICAgICAgcmVzb2x1dGlvbi53aWR0aCA9IHBhcnNlSW50KHNwbGl0WzBdLCAxMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzcGxpdFsxXSkge1xuICAgICAgICAgICAgcmVzb2x1dGlvbi5oZWlnaHQgPSBwYXJzZUludChzcGxpdFsxXSwgMTApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzLlJFU09MVVRJT04gPSByZXNvbHV0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5hdHRyaWJ1dGVzLkJBTkRXSURUSCkge1xuICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMuQkFORFdJRFRIID0gcGFyc2VJbnQoZXZlbnQuYXR0cmlidXRlcy5CQU5EV0lEVEgsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQuYXR0cmlidXRlc1snUFJPR1JBTS1JRCddKSB7XG4gICAgICAgICAgZXZlbnQuYXR0cmlidXRlc1snUFJPR1JBTS1JRCddID0gcGFyc2VJbnQoZXZlbnQuYXR0cmlidXRlc1snUFJPR1JBTS1JRCddLCAxMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWF0Y2ggPSAvXiNFWFQtWC1NRURJQTo/KC4qKSQvLmV4ZWMobGluZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBldmVudCA9IHtcbiAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgIHRhZ1R5cGU6ICdtZWRpYSdcbiAgICAgIH07XG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgZXZlbnQuYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhtYXRjaFsxXSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdGNoID0gL14jRVhULVgtRU5ETElTVC8uZXhlYyhsaW5lKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIHtcbiAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgIHRhZ1R5cGU6ICdlbmRsaXN0J1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdGNoID0gL14jRVhULVgtRElTQ09OVElOVUlUWS8uZXhlYyhsaW5lKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIHtcbiAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgIHRhZ1R5cGU6ICdkaXNjb250aW51aXR5J1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdGNoID0gL14jRVhULVgtUFJPR1JBTS1EQVRFLVRJTUU6PyguKikkLy5leGVjKGxpbmUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgZXZlbnQgPSB7XG4gICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICB0YWdUeXBlOiAncHJvZ3JhbS1kYXRlLXRpbWUnXG4gICAgICB9O1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGV2ZW50LmRhdGVUaW1lU3RyaW5nID0gbWF0Y2hbMV07XG4gICAgICAgIGV2ZW50LmRhdGVUaW1lT2JqZWN0ID0gbmV3IERhdGUobWF0Y2hbMV0pO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXRjaCA9IC9eI0VYVC1YLUtFWTo/KC4qKSQvLmV4ZWMobGluZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBldmVudCA9IHtcbiAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgIHRhZ1R5cGU6ICdrZXknXG4gICAgICB9O1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobWF0Y2hbMV0pO1xuICAgICAgICAvLyBwYXJzZSB0aGUgSVYgc3RyaW5nIGludG8gYSBVaW50MzJBcnJheVxuICAgICAgICBpZiAoZXZlbnQuYXR0cmlidXRlcy5JVikge1xuICAgICAgICAgIGlmIChldmVudC5hdHRyaWJ1dGVzLklWLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09PSAnMHgnKSB7XG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzLklWID0gZXZlbnQuYXR0cmlidXRlcy5JVi5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXZlbnQuYXR0cmlidXRlcy5JViA9IGV2ZW50LmF0dHJpYnV0ZXMuSVYubWF0Y2goLy57OH0vZyk7XG4gICAgICAgICAgZXZlbnQuYXR0cmlidXRlcy5JVlswXSA9IHBhcnNlSW50KGV2ZW50LmF0dHJpYnV0ZXMuSVZbMF0sIDE2KTtcbiAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzLklWWzFdID0gcGFyc2VJbnQoZXZlbnQuYXR0cmlidXRlcy5JVlsxXSwgMTYpO1xuICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMuSVZbMl0gPSBwYXJzZUludChldmVudC5hdHRyaWJ1dGVzLklWWzJdLCAxNik7XG4gICAgICAgICAgZXZlbnQuYXR0cmlidXRlcy5JVlszXSA9IHBhcnNlSW50KGV2ZW50LmF0dHJpYnV0ZXMuSVZbM10sIDE2KTtcbiAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzLklWID0gbmV3IFVpbnQzMkFycmF5KGV2ZW50LmF0dHJpYnV0ZXMuSVYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdGNoID0gL14jRVhULVgtU1RBUlQ6PyguKikkLy5leGVjKGxpbmUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgZXZlbnQgPSB7XG4gICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICB0YWdUeXBlOiAnc3RhcnQnXG4gICAgICB9O1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobWF0Y2hbMV0pO1xuXG4gICAgICAgIGV2ZW50LmF0dHJpYnV0ZXNbJ1RJTUUtT0ZGU0VUJ10gPSBwYXJzZUZsb2F0KGV2ZW50LmF0dHJpYnV0ZXNbJ1RJTUUtT0ZGU0VUJ10pO1xuICAgICAgICBldmVudC5hdHRyaWJ1dGVzLlBSRUNJU0UgPSAvWUVTLy50ZXN0KGV2ZW50LmF0dHJpYnV0ZXMuUFJFQ0lTRSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdGNoID0gL14jRVhULVgtQ1VFLU9VVC1DT05UOj8oLiopPyQvLmV4ZWMobGluZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBldmVudCA9IHtcbiAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgIHRhZ1R5cGU6ICdjdWUtb3V0LWNvbnQnXG4gICAgICB9O1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGV2ZW50LmRhdGEgPSBtYXRjaFsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50LmRhdGEgPSAnJztcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWF0Y2ggPSAvXiNFWFQtWC1DVUUtT1VUOj8oLiopPyQvLmV4ZWMobGluZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBldmVudCA9IHtcbiAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgIHRhZ1R5cGU6ICdjdWUtb3V0J1xuICAgICAgfTtcbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBldmVudC5kYXRhID0gbWF0Y2hbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudC5kYXRhID0gJyc7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdGNoID0gL14jRVhULVgtQ1VFLUlOOj8oLiopPyQvLmV4ZWMobGluZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBldmVudCA9IHtcbiAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgIHRhZ1R5cGU6ICdjdWUtaW4nXG4gICAgICB9O1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGV2ZW50LmRhdGEgPSBtYXRjaFsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50LmRhdGEgPSAnJztcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1bmtub3duIHRhZyB0eXBlXG4gICAgdGhpcy50cmlnZ2VyKCdkYXRhJywge1xuICAgICAgdHlwZTogJ3RhZycsXG4gICAgICBkYXRhOiBsaW5lLnNsaWNlKDQpXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHBhcnNlciBmb3IgY3VzdG9tIGhlYWRlcnNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucyAgICAgICAgICAgICAgYSBtYXAgb2Ygb3B0aW9ucyBmb3IgdGhlIGFkZGVkIHBhcnNlclxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gICBvcHRpb25zLmV4cHJlc3Npb24gICBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCB0aGUgY3VzdG9tIGhlYWRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBvcHRpb25zLmN1c3RvbVR5cGUgICB0aGUgY3VzdG9tIHR5cGUgdG8gcmVnaXN0ZXIgdG8gdGhlIG91dHB1dFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5kYXRhUGFyc2VyXSBmdW5jdGlvbiB0byBwYXJzZSB0aGUgbGluZSBpbnRvIGFuIG9iamVjdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy5zZWdtZW50XSAgICBzaG91bGQgdGFnIGRhdGEgYmUgYXR0YWNoZWQgdG8gdGhlIHNlZ21lbnQgb2JqZWN0XG4gICAqL1xuXG5cbiAgUGFyc2VTdHJlYW0ucHJvdG90eXBlLmFkZFBhcnNlciA9IGZ1bmN0aW9uIGFkZFBhcnNlcihfcmVmKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgZXhwcmVzc2lvbiA9IF9yZWYuZXhwcmVzc2lvbixcbiAgICAgICAgY3VzdG9tVHlwZSA9IF9yZWYuY3VzdG9tVHlwZSxcbiAgICAgICAgZGF0YVBhcnNlciA9IF9yZWYuZGF0YVBhcnNlcixcbiAgICAgICAgc2VnbWVudCA9IF9yZWYuc2VnbWVudDtcblxuICAgIGlmICh0eXBlb2YgZGF0YVBhcnNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGF0YVBhcnNlciA9IGZ1bmN0aW9uIGRhdGFQYXJzZXIobGluZSkge1xuICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuY3VzdG9tUGFyc2Vycy5wdXNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBleHByZXNzaW9uLmV4ZWMobGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBfdGhpczIudHJpZ2dlcignZGF0YScsIHtcbiAgICAgICAgICB0eXBlOiAnY3VzdG9tJyxcbiAgICAgICAgICBkYXRhOiBkYXRhUGFyc2VyKGxpbmUpLFxuICAgICAgICAgIGN1c3RvbVR5cGU6IGN1c3RvbVR5cGUsXG4gICAgICAgICAgc2VnbWVudDogc2VnbWVudFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFBhcnNlU3RyZWFtO1xufShTdHJlYW0pO1xuXG4vKipcbiAqIEBmaWxlIG0zdTgvcGFyc2VyLmpzXG4gKi9cbi8qKlxuICogQSBwYXJzZXIgZm9yIE0zVTggZmlsZXMuIFRoZSBjdXJyZW50IGludGVycHJldGF0aW9uIG9mIHRoZSBpbnB1dCBpc1xuICogZXhwb3NlZCBhcyBhIHByb3BlcnR5IGBtYW5pZmVzdGAgb24gcGFyc2VyIG9iamVjdHMuIEl0J3MganVzdCB0d28gbGluZXMgdG9cbiAqIGNyZWF0ZSBhbmQgcGFyc2UgYSBtYW5pZmVzdCBvbmNlIHlvdSBoYXZlIHRoZSBjb250ZW50cyBhdmFpbGFibGUgYXMgYSBzdHJpbmc6XG4gKlxuICogYGBganNcbiAqIHZhciBwYXJzZXIgPSBuZXcgbTN1OC5QYXJzZXIoKTtcbiAqIHBhcnNlci5wdXNoKHhoci5yZXNwb25zZVRleHQpO1xuICogYGBgXG4gKlxuICogTmV3IGlucHV0IGNhbiBsYXRlciBiZSBhcHBsaWVkIHRvIHVwZGF0ZSB0aGUgbWFuaWZlc3Qgb2JqZWN0IGJ5IGNhbGxpbmdcbiAqIGBwdXNoYCBhZ2Fpbi5cbiAqXG4gKiBUaGUgcGFyc2VyIGF0dGVtcHRzIHRvIGNyZWF0ZSBhIHVzYWJsZSBtYW5pZmVzdCBvYmplY3QgZXZlbiBpZiB0aGVcbiAqIHVuZGVybHlpbmcgaW5wdXQgaXMgc29tZXdoYXQgbm9uc2Vuc2ljYWwuIEl0IGVtaXRzIGBpbmZvYCBhbmQgYHdhcm5pbmdgXG4gKiBldmVudHMgZHVyaW5nIHRoZSBwYXJzZSBpZiBpdCBlbmNvdW50ZXJzIGlucHV0IHRoYXQgc2VlbXMgaW52YWxpZCBvclxuICogcmVxdWlyZXMgc29tZSBwcm9wZXJ0eSBvZiB0aGUgbWFuaWZlc3Qgb2JqZWN0IHRvIGJlIGRlZmF1bHRlZC5cbiAqXG4gKiBAY2xhc3MgUGFyc2VyXG4gKiBAZXh0ZW5kcyBTdHJlYW1cbiAqL1xuXG52YXIgUGFyc2VyID0gZnVuY3Rpb24gKF9TdHJlYW0pIHtcbiAgaW5oZXJpdHMoUGFyc2VyLCBfU3RyZWFtKTtcblxuICBmdW5jdGlvbiBQYXJzZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyc2VyKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1N0cmVhbS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLmxpbmVTdHJlYW0gPSBuZXcgTGluZVN0cmVhbSgpO1xuICAgIF90aGlzLnBhcnNlU3RyZWFtID0gbmV3IFBhcnNlU3RyZWFtKCk7XG4gICAgX3RoaXMubGluZVN0cmVhbS5waXBlKF90aGlzLnBhcnNlU3RyZWFtKTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtdGhpcyAqL1xuICAgIHZhciBzZWxmID0gX3RoaXM7XG4gICAgLyogZXNsaW50LWVuYWJsZSBjb25zaXN0ZW50LXRoaXMgKi9cbiAgICB2YXIgdXJpcyA9IFtdO1xuICAgIHZhciBjdXJyZW50VXJpID0ge307XG4gICAgLy8gaWYgc3BlY2lmaWVkLCB0aGUgYWN0aXZlIEVYVC1YLU1BUCBkZWZpbml0aW9uXG4gICAgdmFyIGN1cnJlbnRNYXAgPSB2b2lkIDA7XG4gICAgLy8gaWYgc3BlY2lmaWVkLCB0aGUgYWN0aXZlIGRlY3J5cHRpb24ga2V5XG4gICAgdmFyIF9rZXkgPSB2b2lkIDA7XG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG4gICAgdmFyIGRlZmF1bHRNZWRpYUdyb3VwcyA9IHtcbiAgICAgICdBVURJTyc6IHt9LFxuICAgICAgJ1ZJREVPJzoge30sXG4gICAgICAnQ0xPU0VELUNBUFRJT05TJzoge30sXG4gICAgICAnU1VCVElUTEVTJzoge31cbiAgICB9O1xuICAgIC8vIGdyb3VwIHNlZ21lbnRzIGludG8gbnVtYmVyZWQgdGltZWxpbmVzIGRlbGluZWF0ZWQgYnkgZGlzY29udGludWl0aWVzXG4gICAgdmFyIGN1cnJlbnRUaW1lbGluZSA9IDA7XG5cbiAgICAvLyB0aGUgbWFuaWZlc3QgaXMgZW1wdHkgdW50aWwgdGhlIHBhcnNlIHN0cmVhbSBiZWdpbnMgZGVsaXZlcmluZyBkYXRhXG4gICAgX3RoaXMubWFuaWZlc3QgPSB7XG4gICAgICBhbGxvd0NhY2hlOiB0cnVlLFxuICAgICAgZGlzY29udGludWl0eVN0YXJ0czogW10sXG4gICAgICBzZWdtZW50czogW11cbiAgICB9O1xuXG4gICAgLy8gdXBkYXRlIHRoZSBtYW5pZmVzdCB3aXRoIHRoZSBtM3U4IGVudHJ5IGZyb20gdGhlIHBhcnNlIHN0cmVhbVxuICAgIF90aGlzLnBhcnNlU3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICB2YXIgbWVkaWFHcm91cCA9IHZvaWQgMDtcbiAgICAgIHZhciByZW5kaXRpb24gPSB2b2lkIDA7XG5cbiAgICAgICh7XG4gICAgICAgIHRhZzogZnVuY3Rpb24gdGFnKCkge1xuICAgICAgICAgIC8vIHN3aXRjaCBiYXNlZCBvbiB0aGUgdGFnIHR5cGVcbiAgICAgICAgICAoKHtcbiAgICAgICAgICAgICdhbGxvdy1jYWNoZSc6IGZ1bmN0aW9uIGFsbG93Q2FjaGUoKSB7XG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QuYWxsb3dDYWNoZSA9IGVudHJ5LmFsbG93ZWQ7XG4gICAgICAgICAgICAgIGlmICghKCdhbGxvd2VkJyBpbiBlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2luZm8nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnZGVmYXVsdGluZyBhbGxvd0NhY2hlIHRvIFlFUydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmFsbG93Q2FjaGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnl0ZXJhbmdlOiBmdW5jdGlvbiBieXRlcmFuZ2UoKSB7XG4gICAgICAgICAgICAgIHZhciBieXRlcmFuZ2UgPSB7fTtcblxuICAgICAgICAgICAgICBpZiAoJ2xlbmd0aCcgaW4gZW50cnkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VXJpLmJ5dGVyYW5nZSA9IGJ5dGVyYW5nZTtcbiAgICAgICAgICAgICAgICBieXRlcmFuZ2UubGVuZ3RoID0gZW50cnkubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoJ29mZnNldCcgaW4gZW50cnkpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2luZm8nLCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdkZWZhdWx0aW5nIG9mZnNldCB0byB6ZXJvJ1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBlbnRyeS5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoJ29mZnNldCcgaW4gZW50cnkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VXJpLmJ5dGVyYW5nZSA9IGJ5dGVyYW5nZTtcbiAgICAgICAgICAgICAgICBieXRlcmFuZ2Uub2Zmc2V0ID0gZW50cnkub2Zmc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kbGlzdDogZnVuY3Rpb24gZW5kbGlzdCgpIHtcbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5lbmRMaXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmY6IGZ1bmN0aW9uIGluZigpIHtcbiAgICAgICAgICAgICAgaWYgKCEoJ21lZGlhU2VxdWVuY2UnIGluIHRoaXMubWFuaWZlc3QpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5tZWRpYVNlcXVlbmNlID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2luZm8nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnZGVmYXVsdGluZyBtZWRpYSBzZXF1ZW5jZSB0byB6ZXJvJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghKCdkaXNjb250aW51aXR5U2VxdWVuY2UnIGluIHRoaXMubWFuaWZlc3QpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5kaXNjb250aW51aXR5U2VxdWVuY2UgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignaW5mbycsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdkZWZhdWx0aW5nIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgdG8gemVybydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZW50cnkuZHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFVyaS5kdXJhdGlvbiA9IGVudHJ5LmR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGVudHJ5LmR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFVyaS5kdXJhdGlvbiA9IDAuMDE7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdpbmZvJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ3VwZGF0aW5nIHplcm8gc2VnbWVudCBkdXJhdGlvbiB0byBhIHNtYWxsIHZhbHVlJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5zZWdtZW50cyA9IHVyaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5OiBmdW5jdGlvbiBrZXkoKSB7XG4gICAgICAgICAgICAgIGlmICghZW50cnkuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpZ25vcmluZyBrZXkgZGVjbGFyYXRpb24gd2l0aG91dCBhdHRyaWJ1dGUgbGlzdCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gY2xlYXIgdGhlIGFjdGl2ZSBlbmNyeXB0aW9uIGtleVxuICAgICAgICAgICAgICBpZiAoZW50cnkuYXR0cmlidXRlcy5NRVRIT0QgPT09ICdOT05FJykge1xuICAgICAgICAgICAgICAgIF9rZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWVudHJ5LmF0dHJpYnV0ZXMuVVJJKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2lnbm9yaW5nIGtleSBkZWNsYXJhdGlvbiB3aXRob3V0IFVSSSdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFlbnRyeS5hdHRyaWJ1dGVzLk1FVEhPRCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdkZWZhdWx0aW5nIGtleSBtZXRob2QgdG8gQUVTLTEyOCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIHNldHVwIGFuIGVuY3J5cHRpb24ga2V5IGZvciB1cGNvbWluZyBzZWdtZW50c1xuICAgICAgICAgICAgICBfa2V5ID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogZW50cnkuYXR0cmlidXRlcy5NRVRIT0QgfHwgJ0FFUy0xMjgnLFxuICAgICAgICAgICAgICAgIHVyaTogZW50cnkuYXR0cmlidXRlcy5VUklcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5LmF0dHJpYnV0ZXMuSVYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgX2tleS5pdiA9IGVudHJ5LmF0dHJpYnV0ZXMuSVY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWVkaWEtc2VxdWVuY2UnOiBmdW5jdGlvbiBtZWRpYVNlcXVlbmNlKCkge1xuICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGVudHJ5Lm51bWJlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaWdub3JpbmcgaW52YWxpZCBtZWRpYSBzZXF1ZW5jZTogJyArIGVudHJ5Lm51bWJlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0Lm1lZGlhU2VxdWVuY2UgPSBlbnRyeS5udW1iZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2Rpc2NvbnRpbnVpdHktc2VxdWVuY2UnOiBmdW5jdGlvbiBkaXNjb250aW51aXR5U2VxdWVuY2UoKSB7XG4gICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoZW50cnkubnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpZ25vcmluZyBpbnZhbGlkIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2U6ICcgKyBlbnRyeS5udW1iZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5kaXNjb250aW51aXR5U2VxdWVuY2UgPSBlbnRyeS5udW1iZXI7XG4gICAgICAgICAgICAgIGN1cnJlbnRUaW1lbGluZSA9IGVudHJ5Lm51bWJlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncGxheWxpc3QtdHlwZSc6IGZ1bmN0aW9uIHBsYXlsaXN0VHlwZSgpIHtcbiAgICAgICAgICAgICAgaWYgKCEvVk9EfEVWRU5ULy50ZXN0KGVudHJ5LnBsYXlsaXN0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaWdub3JpbmcgdW5rbm93biBwbGF5bGlzdCB0eXBlOiAnICsgZW50cnkucGxheWxpc3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5wbGF5bGlzdFR5cGUgPSBlbnRyeS5wbGF5bGlzdFR5cGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFwOiBmdW5jdGlvbiBtYXAoKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRNYXAgPSB7fTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5LnVyaSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXAudXJpID0gZW50cnkudXJpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChlbnRyeS5ieXRlcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFwLmJ5dGVyYW5nZSA9IGVudHJ5LmJ5dGVyYW5nZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdzdHJlYW0taW5mJzogZnVuY3Rpb24gc3RyZWFtSW5mKCkge1xuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LnBsYXlsaXN0cyA9IHVyaXM7XG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QubWVkaWFHcm91cHMgPSB0aGlzLm1hbmlmZXN0Lm1lZGlhR3JvdXBzIHx8IGRlZmF1bHRNZWRpYUdyb3VwcztcblxuICAgICAgICAgICAgICBpZiAoIWVudHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaWdub3JpbmcgZW1wdHkgc3RyZWFtLWluZiBhdHRyaWJ1dGVzJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghY3VycmVudFVyaS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFVyaS5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2V4dGVuZHMoY3VycmVudFVyaS5hdHRyaWJ1dGVzLCBlbnRyeS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZWRpYTogZnVuY3Rpb24gbWVkaWEoKSB7XG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QubWVkaWFHcm91cHMgPSB0aGlzLm1hbmlmZXN0Lm1lZGlhR3JvdXBzIHx8IGRlZmF1bHRNZWRpYUdyb3VwcztcblxuICAgICAgICAgICAgICBpZiAoIShlbnRyeS5hdHRyaWJ1dGVzICYmIGVudHJ5LmF0dHJpYnV0ZXMuVFlQRSAmJiBlbnRyeS5hdHRyaWJ1dGVzWydHUk9VUC1JRCddICYmIGVudHJ5LmF0dHJpYnV0ZXMuTkFNRSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaWdub3JpbmcgaW5jb21wbGV0ZSBvciBtaXNzaW5nIG1lZGlhIGdyb3VwJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGZpbmQgdGhlIG1lZGlhIGdyb3VwLCBjcmVhdGluZyBkZWZhdWx0cyBhcyBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgdmFyIG1lZGlhR3JvdXBUeXBlID0gdGhpcy5tYW5pZmVzdC5tZWRpYUdyb3Vwc1tlbnRyeS5hdHRyaWJ1dGVzLlRZUEVdO1xuXG4gICAgICAgICAgICAgIG1lZGlhR3JvdXBUeXBlW2VudHJ5LmF0dHJpYnV0ZXNbJ0dST1VQLUlEJ11dID0gbWVkaWFHcm91cFR5cGVbZW50cnkuYXR0cmlidXRlc1snR1JPVVAtSUQnXV0gfHwge307XG4gICAgICAgICAgICAgIG1lZGlhR3JvdXAgPSBtZWRpYUdyb3VwVHlwZVtlbnRyeS5hdHRyaWJ1dGVzWydHUk9VUC1JRCddXTtcblxuICAgICAgICAgICAgICAvLyBjb2xsZWN0IHRoZSByZW5kaXRpb24gbWV0YWRhdGFcbiAgICAgICAgICAgICAgcmVuZGl0aW9uID0ge1xuICAgICAgICAgICAgICAgICdkZWZhdWx0JzogL3llcy9pLnRlc3QoZW50cnkuYXR0cmlidXRlcy5ERUZBVUxUKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAocmVuZGl0aW9uWydkZWZhdWx0J10pIHtcbiAgICAgICAgICAgICAgICByZW5kaXRpb24uYXV0b3NlbGVjdCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGl0aW9uLmF1dG9zZWxlY3QgPSAveWVzL2kudGVzdChlbnRyeS5hdHRyaWJ1dGVzLkFVVE9TRUxFQ1QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChlbnRyeS5hdHRyaWJ1dGVzLkxBTkdVQUdFKSB7XG4gICAgICAgICAgICAgICAgcmVuZGl0aW9uLmxhbmd1YWdlID0gZW50cnkuYXR0cmlidXRlcy5MQU5HVUFHRTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZW50cnkuYXR0cmlidXRlcy5VUkkpIHtcbiAgICAgICAgICAgICAgICByZW5kaXRpb24udXJpID0gZW50cnkuYXR0cmlidXRlcy5VUkk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGVudHJ5LmF0dHJpYnV0ZXNbJ0lOU1RSRUFNLUlEJ10pIHtcbiAgICAgICAgICAgICAgICByZW5kaXRpb24uaW5zdHJlYW1JZCA9IGVudHJ5LmF0dHJpYnV0ZXNbJ0lOU1RSRUFNLUlEJ107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGVudHJ5LmF0dHJpYnV0ZXMuQ0hBUkFDVEVSSVNUSUNTKSB7XG4gICAgICAgICAgICAgICAgcmVuZGl0aW9uLmNoYXJhY3RlcmlzdGljcyA9IGVudHJ5LmF0dHJpYnV0ZXMuQ0hBUkFDVEVSSVNUSUNTO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChlbnRyeS5hdHRyaWJ1dGVzLkZPUkNFRCkge1xuICAgICAgICAgICAgICAgIHJlbmRpdGlvbi5mb3JjZWQgPSAveWVzL2kudGVzdChlbnRyeS5hdHRyaWJ1dGVzLkZPUkNFRCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBpbnNlcnQgdGhlIG5ldyByZW5kaXRpb25cbiAgICAgICAgICAgICAgbWVkaWFHcm91cFtlbnRyeS5hdHRyaWJ1dGVzLk5BTUVdID0gcmVuZGl0aW9uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc2NvbnRpbnVpdHk6IGZ1bmN0aW9uIGRpc2NvbnRpbnVpdHkoKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRUaW1lbGluZSArPSAxO1xuICAgICAgICAgICAgICBjdXJyZW50VXJpLmRpc2NvbnRpbnVpdHkgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmRpc2NvbnRpbnVpdHlTdGFydHMucHVzaCh1cmlzLmxlbmd0aCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3Byb2dyYW0tZGF0ZS10aW1lJzogZnVuY3Rpb24gcHJvZ3JhbURhdGVUaW1lKCkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFuaWZlc3QuZGF0ZVRpbWVTdHJpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gUFJPR1JBTS1EQVRFLVRJTUUgaXMgYSBtZWRpYS1zZWdtZW50IHRhZywgYnV0IGZvciBiYWNrd2FyZHNcbiAgICAgICAgICAgICAgICAvLyBjb21wYXRpYmlsaXR5LCB3ZSBhZGQgdGhlIGZpcnN0IG9jY3VyZW5jZSBvZiB0aGUgUFJPR1JBTS1EQVRFLVRJTUUgdGFnXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIG1hbmlmZXN0IG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IENvbnNpZGVyIHJlbW92aW5nIHRoaXMgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25cbiAgICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmRhdGVUaW1lU3RyaW5nID0gZW50cnkuZGF0ZVRpbWVTdHJpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5kYXRlVGltZU9iamVjdCA9IGVudHJ5LmRhdGVUaW1lT2JqZWN0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY3VycmVudFVyaS5kYXRlVGltZVN0cmluZyA9IGVudHJ5LmRhdGVUaW1lU3RyaW5nO1xuICAgICAgICAgICAgICBjdXJyZW50VXJpLmRhdGVUaW1lT2JqZWN0ID0gZW50cnkuZGF0ZVRpbWVPYmplY3Q7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGFyZ2V0ZHVyYXRpb246IGZ1bmN0aW9uIHRhcmdldGR1cmF0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGVudHJ5LmR1cmF0aW9uKSB8fCBlbnRyeS5kdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaWdub3JpbmcgaW52YWxpZCB0YXJnZXQgZHVyYXRpb246ICcgKyBlbnRyeS5kdXJhdGlvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LnRhcmdldER1cmF0aW9uID0gZW50cnkuZHVyYXRpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG90YWxkdXJhdGlvbjogZnVuY3Rpb24gdG90YWxkdXJhdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShlbnRyeS5kdXJhdGlvbikgfHwgZW50cnkuZHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2lnbm9yaW5nIGludmFsaWQgdG90YWwgZHVyYXRpb246ICcgKyBlbnRyeS5kdXJhdGlvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LnRvdGFsRHVyYXRpb24gPSBlbnRyeS5kdXJhdGlvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgICAgICAgIGlmICghZW50cnkuYXR0cmlidXRlcyB8fCBpc05hTihlbnRyeS5hdHRyaWJ1dGVzWydUSU1FLU9GRlNFVCddKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpZ25vcmluZyBzdGFydCBkZWNsYXJhdGlvbiB3aXRob3V0IGFwcHJvcHJpYXRlIGF0dHJpYnV0ZSBsaXN0J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LnN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgIHRpbWVPZmZzZXQ6IGVudHJ5LmF0dHJpYnV0ZXNbJ1RJTUUtT0ZGU0VUJ10sXG4gICAgICAgICAgICAgICAgcHJlY2lzZTogZW50cnkuYXR0cmlidXRlcy5QUkVDSVNFXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2N1ZS1vdXQnOiBmdW5jdGlvbiBjdWVPdXQoKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRVcmkuY3VlT3V0ID0gZW50cnkuZGF0YTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnY3VlLW91dC1jb250JzogZnVuY3Rpb24gY3VlT3V0Q29udCgpIHtcbiAgICAgICAgICAgICAgY3VycmVudFVyaS5jdWVPdXRDb250ID0gZW50cnkuZGF0YTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnY3VlLWluJzogZnVuY3Rpb24gY3VlSW4oKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRVcmkuY3VlSW4gPSBlbnRyeS5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pW2VudHJ5LnRhZ1R5cGVdIHx8IG5vb3ApLmNhbGwoc2VsZik7XG4gICAgICAgIH0sXG4gICAgICAgIHVyaTogZnVuY3Rpb24gdXJpKCkge1xuICAgICAgICAgIGN1cnJlbnRVcmkudXJpID0gZW50cnkudXJpO1xuICAgICAgICAgIHVyaXMucHVzaChjdXJyZW50VXJpKTtcblxuICAgICAgICAgIC8vIGlmIG5vIGV4cGxpY2l0IGR1cmF0aW9uIHdhcyBkZWNsYXJlZCwgdXNlIHRoZSB0YXJnZXQgZHVyYXRpb25cbiAgICAgICAgICBpZiAodGhpcy5tYW5pZmVzdC50YXJnZXREdXJhdGlvbiAmJiAhKCdkdXJhdGlvbicgaW4gY3VycmVudFVyaSkpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ2RlZmF1bHRpbmcgc2VnbWVudCBkdXJhdGlvbiB0byB0aGUgdGFyZ2V0IGR1cmF0aW9uJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50VXJpLmR1cmF0aW9uID0gdGhpcy5tYW5pZmVzdC50YXJnZXREdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYW5ub3RhdGUgd2l0aCBlbmNyeXB0aW9uIGluZm9ybWF0aW9uLCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICBpZiAoX2tleSkge1xuICAgICAgICAgICAgY3VycmVudFVyaS5rZXkgPSBfa2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50VXJpLnRpbWVsaW5lID0gY3VycmVudFRpbWVsaW5lO1xuICAgICAgICAgIC8vIGFubm90YXRlIHdpdGggaW5pdGlhbGl6YXRpb24gc2VnbWVudCBpbmZvcm1hdGlvbiwgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgaWYgKGN1cnJlbnRNYXApIHtcbiAgICAgICAgICAgIGN1cnJlbnRVcmkubWFwID0gY3VycmVudE1hcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwcmVwYXJlIGZvciB0aGUgbmV4dCBVUklcbiAgICAgICAgICBjdXJyZW50VXJpID0ge307XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1lbnQ6IGZ1bmN0aW9uIGNvbW1lbnQoKSB7XG4gICAgICAgICAgLy8gY29tbWVudHMgYXJlIG5vdCBpbXBvcnRhbnQgZm9yIHBsYXliYWNrXG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbTogZnVuY3Rpb24gY3VzdG9tKCkge1xuICAgICAgICAgIC8vIGlmIHRoaXMgaXMgc2VnbWVudC1sZXZlbCBkYXRhIGF0dGFjaCB0aGUgb3V0cHV0IHRvIHRoZSBzZWdtZW50XG4gICAgICAgICAgaWYgKGVudHJ5LnNlZ21lbnQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRVcmkuY3VzdG9tID0gY3VycmVudFVyaS5jdXN0b20gfHwge307XG4gICAgICAgICAgICBjdXJyZW50VXJpLmN1c3RvbVtlbnRyeS5jdXN0b21UeXBlXSA9IGVudHJ5LmRhdGE7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIG1hbmlmZXN0LWxldmVsIGRhdGEgYXR0YWNoIHRvIHRoZSB0b3AgbGV2ZWwgbWFuaWZlc3Qgb2JqZWN0XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFuaWZlc3QuY3VzdG9tID0gdGhpcy5tYW5pZmVzdC5jdXN0b20gfHwge307XG4gICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmN1c3RvbVtlbnRyeS5jdXN0b21UeXBlXSA9IGVudHJ5LmRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVtlbnRyeS50eXBlXS5jYWxsKHNlbGYpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgaW5wdXQgc3RyaW5nIGFuZCB1cGRhdGUgdGhlIG1hbmlmZXN0IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNodW5rIGEgcG90ZW50aWFsbHkgaW5jb21wbGV0ZSBwb3J0aW9uIG9mIHRoZSBtYW5pZmVzdFxuICAgKi9cblxuXG4gIFBhcnNlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2goY2h1bmspIHtcbiAgICB0aGlzLmxpbmVTdHJlYW0ucHVzaChjaHVuayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZsdXNoIGFueSByZW1haW5pbmcgaW5wdXQuIFRoaXMgY2FuIGJlIGhhbmR5IGlmIHRoZSBsYXN0IGxpbmUgb2YgYW4gTTNVOFxuICAgKiBtYW5pZmVzdCBkaWQgbm90IGNvbnRhaW4gYSB0cmFpbGluZyBuZXdsaW5lIGJ1dCB0aGUgZmlsZSBoYXMgYmVlblxuICAgKiBjb21wbGV0ZWx5IHJlY2VpdmVkLlxuICAgKi9cblxuXG4gIFBhcnNlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKCkge1xuICAgIC8vIGZsdXNoIGFueSBidWZmZXJlZCBpbnB1dFxuICAgIHRoaXMubGluZVN0cmVhbS5wdXNoKCdcXG4nKTtcbiAgfTtcbiAgLyoqXG4gICAqIEFkZCBhbiBhZGRpdGlvbmFsIHBhcnNlciBmb3Igbm9uLXN0YW5kYXJkIHRhZ3NcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucyAgICAgICAgICAgICAgYSBtYXAgb2Ygb3B0aW9ucyBmb3IgdGhlIGFkZGVkIHBhcnNlclxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gICBvcHRpb25zLmV4cHJlc3Npb24gICBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCB0aGUgY3VzdG9tIGhlYWRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBvcHRpb25zLnR5cGUgICAgICAgICB0aGUgdHlwZSB0byByZWdpc3RlciB0byB0aGUgb3V0cHV0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmRhdGFQYXJzZXJdIGZ1bmN0aW9uIHRvIHBhcnNlIHRoZSBsaW5lIGludG8gYW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIFtvcHRpb25zLnNlZ21lbnRdICAgIHNob3VsZCB0YWcgZGF0YSBiZSBhdHRhY2hlZCB0byB0aGUgc2VnbWVudCBvYmplY3RcbiAgICovXG5cblxuICBQYXJzZXIucHJvdG90eXBlLmFkZFBhcnNlciA9IGZ1bmN0aW9uIGFkZFBhcnNlcihvcHRpb25zKSB7XG4gICAgdGhpcy5wYXJzZVN0cmVhbS5hZGRQYXJzZXIob3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFBhcnNlcjtcbn0oU3RyZWFtKTtcblxuLyoqXG4gKiBAZmlsZSBtM3U4L2luZGV4LmpzXG4gKlxuICogVXRpbGl0aWVzIGZvciBwYXJzaW5nIE0zVTggZmlsZXMuIElmIHRoZSBlbnRpcmUgbWFuaWZlc3QgaXMgYXZhaWxhYmxlLFxuICogYFBhcnNlcmAgd2lsbCBjcmVhdGUgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIHdpdGggZW5vdWdoIGRldGFpbCBmb3IgbWFuYWdpbmdcbiAqIHBsYXliYWNrLiBgUGFyc2VTdHJlYW1gIGFuZCBgTGluZVN0cmVhbWAgYXJlIGxvd2VyLWxldmVsIHBhcnNpbmcgcHJpbWl0aXZlc1xuICogdGhhdCBkbyBub3QgYXNzdW1lIHRoZSBlbnRpcmV0eSBvZiB0aGUgbWFuaWZlc3QgaXMgcmVhZHkgYW5kIGV4cG9zZSBhXG4gKiBSZWFkYWJsZVN0cmVhbS1saWtlIGludGVyZmFjZS5cbiAqL1xuXG5leHBvcnQgeyBMaW5lU3RyZWFtLCBQYXJzZVN0cmVhbSwgUGFyc2VyIH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/m3u8-parser/dist/m3u8-parser.es.js\n");

/***/ }),

/***/ "./node_modules/mithril/mithril.js":
/*!*****************************************!*\
  !*** ./node_modules/mithril/mithril.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(setImmediate, global) {;(function() {\n\"use strict\"\nfunction Vnode(tag, key, attrs0, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode(\"[\", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node != null && typeof node !== \"object\") return Vnode(\"#\", undefined, undefined, node === false ? \"\" : node, undefined, undefined)\n\treturn node\n}\nVnode.normalizeChildren = function normalizeChildren(children) {\n\tfor (var i = 0; i < children.length; i++) {\n\t\tchildren[i] = Vnode.normalize(children[i])\n\t}\n\treturn children\n}\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*(\"|'|)((?:\\\\[\"'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = {}\nvar hasOwn = {}.hasOwnProperty\nfunction isEmpty(object) {\n\tfor (var key in object) if (hasOwn.call(object, key)) return false\n\treturn true\n}\nfunction compileSelector(selector) {\n\tvar match, tag = \"div\", classes = [], attrs = {}\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === \"\" && value !== \"\") tag = value\n\t\telse if (type === \"#\") attrs.id = value\n\t\telse if (type === \".\") classes.push(value)\n\t\telse if (match[3][0] === \"[\") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\([\"'])/g, \"$1\").replace(/\\\\\\\\/g, \"\\\\\")\n\t\t\tif (match[4] === \"class\") classes.push(attrValue)\n\t\t\telse attrs[match[4]] = attrValue === \"\" ? attrValue : attrValue || true\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(\" \")\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs}\n}\nfunction execSelector(state, attrs, children) {\n\tvar hasAttrs = false, childList, text\n\tvar className = attrs.className || attrs.class\n\tif (!isEmpty(state.attrs) && !isEmpty(attrs)) {\n\t\tvar newAttrs = {}\n\t\tfor(var key in attrs) {\n\t\t\tif (hasOwn.call(attrs, key)) {\n\t\t\t\tnewAttrs[key] = attrs[key]\n\t\t\t}\n\t\t}\n\t\tattrs = newAttrs\n\t}\n\tfor (var key in state.attrs) {\n\t\tif (hasOwn.call(state.attrs, key)) {\n\t\t\tattrs[key] = state.attrs[key]\n\t\t}\n\t}\n\tif (className !== undefined) {\n\t\tif (attrs.class !== undefined) {\n\t\t\tattrs.class = undefined\n\t\t\tattrs.className = className\n\t\t}\n\t\tif (state.attrs.className != null) {\n\t\t\tattrs.className = state.attrs.className + \" \" + className\n\t\t}\n\t}\n\tfor (var key in attrs) {\n\t\tif (hasOwn.call(attrs, key) && key !== \"key\") {\n\t\t\thasAttrs = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === \"#\") {\n\t\ttext = children[0].children\n\t} else {\n\t\tchildList = children\n\t}\n\treturn Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)\n}\nfunction hyperscript(selector) {\n\t// Because sloppy mode sucks\n\tvar attrs = arguments[1], start = 2, children\n\tif (selector == null || typeof selector !== \"string\" && typeof selector !== \"function\" && typeof selector.view !== \"function\") {\n\t\tthrow Error(\"The selector must be either a string or a component.\");\n\t}\n\tif (typeof selector === \"string\") {\n\t\tvar cached = selectorCache[selector] || compileSelector(selector)\n\t}\n\tif (attrs == null) {\n\t\tattrs = {}\n\t} else if (typeof attrs !== \"object\" || attrs.tag != null || Array.isArray(attrs)) {\n\t\tattrs = {}\n\t\tstart = 1\n\t}\n\tif (arguments.length === start + 1) {\n\t\tchildren = arguments[start]\n\t\tif (!Array.isArray(children)) children = [children]\n\t} else {\n\t\tchildren = []\n\t\twhile (start < arguments.length) children.push(arguments[start++])\n\t}\n\tvar normalized = Vnode.normalizeChildren(children)\n\tif (typeof selector === \"string\") {\n\t\treturn execSelector(cached, attrs, normalized)\n\t} else {\n\t\treturn Vnode(selector, attrs.key, attrs, normalized)\n\t}\n}\nhyperscript.trust = function(html) {\n\tif (html == null) html = \"\"\n\treturn Vnode(\"<\", undefined, undefined, html, undefined, undefined)\n}\nhyperscript.fragment = function(attrs1, children) {\n\treturn Vnode(\"[\", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)\n}\nvar m = hyperscript\n/** @constructor */\nvar PromisePolyfill = function(executor) {\n\tif (!(this instanceof PromisePolyfill)) throw new Error(\"Promise must be called with `new`\")\n\tif (typeof executor !== \"function\") throw new TypeError(\"executor must be a function\")\n\tvar self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)\n\tvar instance = self._instance = {resolvers: resolvers, rejectors: rejectors}\n\tvar callAsync = typeof setImmediate === \"function\" ? setImmediate : setTimeout\n\tfunction handler(list, shouldAbsorb) {\n\t\treturn function execute(value) {\n\t\t\tvar then\n\t\t\ttry {\n\t\t\t\tif (shouldAbsorb && value != null && (typeof value === \"object\" || typeof value === \"function\") && typeof (then = value.then) === \"function\") {\n\t\t\t\t\tif (value === self) throw new TypeError(\"Promise can't be resolved w/ itself\")\n\t\t\t\t\texecuteOnce(then.bind(value))\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallAsync(function() {\n\t\t\t\t\t\tif (!shouldAbsorb && list.length === 0) console.error(\"Possible unhandled promise rejection:\", value)\n\t\t\t\t\t\tfor (var i = 0; i < list.length; i++) list[i](value)\n\t\t\t\t\t\tresolvers.length = 0, rejectors.length = 0\n\t\t\t\t\t\tinstance.state = shouldAbsorb\n\t\t\t\t\t\tinstance.retry = function() {execute(value)}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\trejectCurrent(e)\n\t\t\t}\n\t\t}\n\t}\n\tfunction executeOnce(then) {\n\t\tvar runs = 0\n\t\tfunction run(fn) {\n\t\t\treturn function(value) {\n\t\t\t\tif (runs++ > 0) return\n\t\t\t\tfn(value)\n\t\t\t}\n\t\t}\n\t\tvar onerror = run(rejectCurrent)\n\t\ttry {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}\n\t}\n\texecuteOnce(executor)\n}\nPromisePolyfill.prototype.then = function(onFulfilled, onRejection) {\n\tvar self = this, instance = self._instance\n\tfunction handle(callback, list, next, state) {\n\t\tlist.push(function(value) {\n\t\t\tif (typeof callback !== \"function\") next(value)\n\t\t\telse try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}\n\t\t})\n\t\tif (typeof instance.retry === \"function\" && state === instance.state) instance.retry()\n\t}\n\tvar resolveNext, rejectNext\n\tvar promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})\n\thandle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)\n\treturn promise\n}\nPromisePolyfill.prototype.catch = function(onRejection) {\n\treturn this.then(null, onRejection)\n}\nPromisePolyfill.resolve = function(value) {\n\tif (value instanceof PromisePolyfill) return value\n\treturn new PromisePolyfill(function(resolve) {resolve(value)})\n}\nPromisePolyfill.reject = function(value) {\n\treturn new PromisePolyfill(function(resolve, reject) {reject(value)})\n}\nPromisePolyfill.all = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tvar total = list.length, count = 0, values = []\n\t\tif (list.length === 0) resolve([])\n\t\telse for (var i = 0; i < list.length; i++) {\n\t\t\t(function(i) {\n\t\t\t\tfunction consume(value) {\n\t\t\t\t\tcount++\n\t\t\t\t\tvalues[i] = value\n\t\t\t\t\tif (count === total) resolve(values)\n\t\t\t\t}\n\t\t\t\tif (list[i] != null && (typeof list[i] === \"object\" || typeof list[i] === \"function\") && typeof list[i].then === \"function\") {\n\t\t\t\t\tlist[i].then(consume, reject)\n\t\t\t\t}\n\t\t\t\telse consume(list[i])\n\t\t\t})(i)\n\t\t}\n\t})\n}\nPromisePolyfill.race = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tlist[i].then(resolve, reject)\n\t\t}\n\t})\n}\nif (typeof window !== \"undefined\") {\n\tif (typeof window.Promise === \"undefined\") window.Promise = PromisePolyfill\n\tvar PromisePolyfill = window.Promise\n} else if (typeof global !== \"undefined\") {\n\tif (typeof global.Promise === \"undefined\") global.Promise = PromisePolyfill\n\tvar PromisePolyfill = global.Promise\n} else {\n}\nvar buildQueryString = function(object) {\n\tif (Object.prototype.toString.call(object) !== \"[object Object]\") return \"\"\n\tvar args = []\n\tfor (var key0 in object) {\n\t\tdestructure(key0, object[key0])\n\t}\n\treturn args.join(\"&\")\n\tfunction destructure(key0, value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tdestructure(key0 + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value) === \"[object Object]\") {\n\t\t\tfor (var i in value) {\n\t\t\t\tdestructure(key0 + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key0) + (value != null && value !== \"\" ? \"=\" + encodeURIComponent(value) : \"\"))\n\t}\n}\nvar FILE_PROTOCOL_REGEX = new RegExp(\"^file://\", \"i\")\nvar _8 = function($window, Promise) {\n\tvar callbackCount = 0\n\tvar oncompletion\n\tfunction setCompletionCallback(callback) {oncompletion = callback}\n\tfunction finalizer() {\n\t\tvar count = 0\n\t\tfunction complete() {if (--count === 0 && typeof oncompletion === \"function\") oncompletion()}\n\t\treturn function finalize(promise0) {\n\t\t\tvar then0 = promise0.then\n\t\t\tpromise0.then = function() {\n\t\t\t\tcount++\n\t\t\t\tvar next = then0.apply(promise0, arguments)\n\t\t\t\tnext.then(complete, function(e) {\n\t\t\t\t\tcomplete()\n\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t})\n\t\t\t\treturn finalize(next)\n\t\t\t}\n\t\t\treturn promise0\n\t\t}\n\t}\n\tfunction normalize(args, extra) {\n\t\tif (typeof args === \"string\") {\n\t\t\tvar url = args\n\t\t\targs = extra || {}\n\t\t\tif (args.url == null) args.url = url\n\t\t}\n\t\treturn args\n\t}\n\tfunction request(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tif (args.method == null) args.method = \"GET\"\n\t\t\targs.method = args.method.toUpperCase()\n\t\t\tvar useBody = (args.method === \"GET\" || args.method === \"TRACE\") ? false : (typeof args.useBody === \"boolean\" ? args.useBody : true)\n\t\t\tif (typeof args.serialize !== \"function\") args.serialize = typeof FormData !== \"undefined\" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify\n\t\t\tif (typeof args.deserialize !== \"function\") args.deserialize = deserialize\n\t\t\tif (typeof args.extract !== \"function\") args.extract = extract\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\tif (useBody) args.data = args.serialize(args.data)\n\t\t\telse args.url = assemble(args.url, args.data)\n\t\t\tvar xhr = new $window.XMLHttpRequest(),\n\t\t\t\taborted = false,\n\t\t\t\t_abort = xhr.abort\n\t\t\txhr.abort = function abort() {\n\t\t\t\taborted = true\n\t\t\t\t_abort.call(xhr)\n\t\t\t}\n\t\t\txhr.open(args.method, args.url, typeof args.async === \"boolean\" ? args.async : true, typeof args.user === \"string\" ? args.user : undefined, typeof args.password === \"string\" ? args.password : undefined)\n\t\t\tif (args.serialize === JSON.stringify && useBody && !(args.headers && args.headers.hasOwnProperty(\"Content-Type\"))) {\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\t\t}\n\t\t\tif (args.deserialize === deserialize && !(args.headers && args.headers.hasOwnProperty(\"Accept\"))) {\n\t\t\t\txhr.setRequestHeader(\"Accept\", \"application/json, text/*\")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tfor (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {\n\t\t\t\txhr.setRequestHeader(key, args.headers[key])\n\t\t\t}\n\t\t\tif (typeof args.config === \"function\") xhr = args.config(xhr, args) || xhr\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t// Don't throw errors on xhr.abort().\n\t\t\t\tif(aborted) return\n\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))\n\t\t\t\t\t\tif ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {\n\t\t\t\t\t\t\tresolve(cast(args.type, response))\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar error = new Error(xhr.responseText)\n\t\t\t\t\t\t\tfor (var key in response) error[key] = response[key]\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useBody && (args.data != null)) xhr.send(args.data)\n\t\t\telse xhr.send()\n\t\t})\n\t\treturn args.background === true ? promise0 : finalize(promise0)\n\t}\n\tfunction jsonp(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tvar callbackName = args.callbackName || \"_mithril_\" + Math.round(Math.random() * 1e16) + \"_\" + callbackCount++\n\t\t\tvar script = $window.document.createElement(\"script\")\n\t\t\t$window[callbackName] = function(data) {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\tresolve(cast(args.type, data))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tscript.onerror = function() {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\treject(new Error(\"JSONP request failed\"))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tif (args.data == null) args.data = {}\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\targs.data[args.callbackKey || \"callback\"] = callbackName\n\t\t\tscript.src = assemble(args.url, args.data)\n\t\t\t$window.document.documentElement.appendChild(script)\n\t\t})\n\t\treturn args.background === true? promise0 : finalize(promise0)\n\t}\n\tfunction interpolate(url, data) {\n\t\tif (data == null) return url\n\t\tvar tokens = url.match(/:[^\\/]+/gi) || []\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar key = tokens[i].slice(1)\n\t\t\tif (data[key] != null) {\n\t\t\t\turl = url.replace(tokens[i], data[key])\n\t\t\t}\n\t\t}\n\t\treturn url\n\t}\n\tfunction assemble(url, data) {\n\t\tvar querystring = buildQueryString(data)\n\t\tif (querystring !== \"\") {\n\t\t\tvar prefix = url.indexOf(\"?\") < 0 ? \"?\" : \"&\"\n\t\t\turl += prefix + querystring\n\t\t}\n\t\treturn url\n\t}\n\tfunction deserialize(data) {\n\t\ttry {return data !== \"\" ? JSON.parse(data) : null}\n\t\tcatch (e) {throw new Error(data)}\n\t}\n\tfunction extract(xhr) {return xhr.responseText}\n\tfunction cast(type0, data) {\n\t\tif (typeof type0 === \"function\") {\n\t\t\tif (Array.isArray(data)) {\n\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\tdata[i] = new type0(data[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\telse return new type0(data)\n\t\t}\n\t\treturn data\n\t}\n\treturn {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}\n}\nvar requestService = _8(window, PromisePolyfill)\nvar coreRenderer = function($window) {\n\tvar $doc = $window.document\n\tvar $emptyFragment = $doc.createDocumentFragment()\n\tvar nameSpace = {\n\t\tsvg: \"http://www.w3.org/2000/svg\",\n\t\tmath: \"http://www.w3.org/1998/Math/MathML\"\n\t}\n\tvar onevent\n\tfunction setEventCallback(callback) {return onevent = callback}\n\tfunction getNameSpace(vnode) {\n\t\treturn vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]\n\t}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === \"string\") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase \"#\": return createText(parent, vnode, nextSibling)\n\t\t\t\tcase \"<\": return createHTML(parent, vnode, nextSibling)\n\t\t\t\tcase \"[\": return createFragment(parent, vnode, hooks, ns, nextSibling)\n\t\t\t\tdefault: return createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse return createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = $doc.createTextNode(vnode.children)\n\t\tinsertNode(parent, vnode.dom, nextSibling)\n\t\treturn vnode.dom\n\t}\n\tfunction createHTML(parent, vnode, nextSibling) {\n\t\tvar match1 = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\tvar parent1 = {caption: \"table\", thead: \"table\", tbody: \"table\", tfoot: \"table\", tr: \"tbody\", th: \"tr\", td: \"tr\", colgroup: \"table\", col: \"colgroup\"}[match1[1]] || \"div\"\n\t\tvar temp = $doc.createElement(parent1)\n\t\ttemp.innerHTML = vnode.children\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tvar attrs2 = vnode.attrs\n\t\tvar is = attrs2 && attrs2.is\n\t\tns = getNameSpace(vnode) || ns\n\t\tvar element = ns ?\n\t\t\tis ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :\n\t\t\tis ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)\n\t\tvnode.dom = element\n\t\tif (attrs2 != null) {\n\t\t\tsetAttrs(vnode, attrs2, ns)\n\t\t}\n\t\tinsertNode(parent, element, nextSibling)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse {\n\t\t\tif (vnode.text != null) {\n\t\t\t\tif (vnode.text !== \"\") element.textContent = vnode.text\n\t\t\t\telse vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\t}\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tsetLateAttrs(vnode)\n\t\t\t}\n\t\t}\n\t\treturn element\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === \"function\") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === \"function\") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tvnode._state = vnode.state\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tinitLifecycle(vnode._state, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tvar element = createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0\n\t\t\tinsertNode(parent, element, nextSibling)\n\t\t\treturn element\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t\treturn $emptyFragment\n\t\t}\n\t}\n\t//update\n\tfunction updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)\n\t\telse if (vnodes == null) removeNodes(old, 0, old.length, vnodes)\n\t\telse {\n\t\t\tif (old.length === vnodes.length) {\n\t\t\t\tvar isUnkeyed = false\n\t\t\t\tfor (var i = 0; i < vnodes.length; i++) {\n\t\t\t\t\tif (vnodes[i] != null && old[i] != null) {\n\t\t\t\t\t\tisUnkeyed = vnodes[i].key == null && old[i].key == null\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isUnkeyed) {\n\t\t\t\t\tfor (var i = 0; i < old.length; i++) {\n\t\t\t\t\t\tif (old[i] === vnodes[i]) continue\n\t\t\t\t\t\telse if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))\n\t\t\t\t\t\telse if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)\n\t\t\t\t\t\telse updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\trecycling = recycling || isRecyclable(old, vnodes)\n\t\t\tif (recycling) {\n\t\t\t\tvar pool = old.pool\n\t\t\t\told = old.concat(old.pool)\n\t\t\t}\n\t\t\tvar oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldStart], v = vnodes[start]\n\t\t\t\tif (o === v && !recycling) oldStart++, start++\n\t\t\t\telse if (o == null) oldStart++\n\t\t\t\telse if (v == null) start++\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar o = old[oldEnd]\n\t\t\t\t\tif (o === v && !recycling) oldEnd--, start++\n\t\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\t\telse if (v == null) start++\n\t\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\t\tif (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))\n\t\t\t\t\t\toldEnd--, start++\n\t\t\t\t\t}\n\t\t\t\t\telse break\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldEnd], v = vnodes[end]\n\t\t\t\tif (o === v && !recycling) oldEnd--, end--\n\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\telse if (v == null) end--\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t\tif (o.dom != null) nextSibling = o.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!map) map = getKeyMap(old, oldEnd)\n\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\tvar oldIndex = map[v.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tvar movable = old[oldIndex]\n\t\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\t\tupdateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)\n\t\t\t\t\t\t\tinsertNode(parent, toFragment(movable), nextSibling)\n\t\t\t\t\t\t\told[oldIndex].skip = true\n\t\t\t\t\t\t\tif (movable.dom != null) nextSibling = movable.dom\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar dom = createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\tnextSibling = dom\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tend--\n\t\t\t\t}\n\t\t\t\tif (end < start) break\n\t\t\t}\n\t\t\tcreateNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\tremoveNodes(old, oldStart, oldEnd + 1, vnodes)\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode._state = old._state\n\t\t\tvnode.events = old.events\n\t\t\tif (!recycling && shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === \"string\") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tif (recycling) {\n\t\t\t\t\t\tvnode.state = {}\n\t\t\t\t\t\tinitLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t\t}\n\t\t\t\t\telse updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase \"#\": updateText(old, vnode); break\n\t\t\t\t\tcase \"<\": updateHTML(parent, old, vnode, nextSibling); break\n\t\t\t\t\tcase \"[\": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, recycling, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(old, null)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\ttoFragment(old)\n\t\t\tcreateHTML(parent, vnode, nextSibling)\n\t\t}\n\t\telse vnode.dom = old.dom, vnode.domSize = old.domSize\n\t}\n\tfunction updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode, recycling, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tns = getNameSpace(vnode) || ns\n\t\tif (vnode.tag === \"textarea\") {\n\t\t\tif (vnode.attrs == null) vnode.attrs = {}\n\t\t\tif (vnode.text != null) {\n\t\t\t\tvnode.attrs.value = vnode.text //FIXME handle0 multiple children\n\t\t\t\tvnode.text = undefined\n\t\t\t}\n\t\t}\n\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse if (old.text != null && vnode.text != null && vnode.text !== \"\") {\n\t\t\tif (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text\n\t\t}\n\t\telse {\n\t\t\tif (old.text != null) old.children = [Vnode(\"#\", undefined, undefined, old.text, undefined, old.dom.firstChild)]\n\t\t\tif (vnode.text != null) vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\tupdateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tif (recycling) {\n\t\t\tinitComponent(vnode, hooks)\n\t\t} else {\n\t\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tupdateLifecycle(vnode._state, vnode, hooks)\n\t\t}\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(old.instance, null)\n\t\t\tvnode.dom = undefined\n\t\t\tvnode.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction isRecyclable(old, vnodes) {\n\t\tif (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {\n\t\t\tvar oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0\n\t\t\tvar poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0\n\t\t\tvar vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0\n\t\t\tif (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfunction getKeyMap(vnodes, end) {\n\t\tvar map = {}, i = 0\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key2 = vnode.key\n\t\t\t\tif (key2 != null) map[key2] = i\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\tfunction toFragment(vnode) {\n\t\tvar count0 = vnode.domSize\n\t\tif (count0 != null || vnode.dom == null) {\n\t\t\tvar fragment = $doc.createDocumentFragment()\n\t\t\tif (count0 > 0) {\n\t\t\t\tvar dom = vnode.dom\n\t\t\t\twhile (--count0) fragment.appendChild(dom.nextSibling)\n\t\t\t\tfragment.insertBefore(dom, fragment.firstChild)\n\t\t\t}\n\t\t\treturn fragment\n\t\t}\n\t\telse return vnode.dom\n\t}\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\tfunction insertNode(parent, dom, nextSibling) {\n\t\tif (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\tfunction setContentEditable(vnode) {\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === \"<\") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (vnode.text != null || children != null && children.length !== 0) throw new Error(\"Child node of a contenteditable must be trusted\")\n\t}\n\t//remove\n\tfunction removeNodes(vnodes, start, end, context) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tif (vnode.skip) vnode.skip = false\n\t\t\t\telse removeNode(vnode, context)\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNode(vnode, context) {\n\t\tvar expected = 1, called = 0\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === \"function\") {\n\t\t\tvar result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onbeforeremove === \"function\") {\n\t\t\tvar result = vnode._state.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tcontinuation()\n\t\tfunction continuation() {\n\t\t\tif (++called === expected) {\n\t\t\t\tonremove(vnode)\n\t\t\t\tif (vnode.dom) {\n\t\t\t\t\tvar count0 = vnode.domSize || 1\n\t\t\t\t\tif (count0 > 1) {\n\t\t\t\t\t\tvar dom = vnode.dom\n\t\t\t\t\t\twhile (--count0) {\n\t\t\t\t\t\t\tremoveNodeFromDOM(dom.nextSibling)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tremoveNodeFromDOM(vnode.dom)\n\t\t\t\t\tif (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === \"string\") { //TODO test custom elements\n\t\t\t\t\t\tif (!context.pool) context.pool = [vnode]\n\t\t\t\t\t\telse context.pool.push(vnode)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNodeFromDOM(node) {\n\t\tvar parent = node.parentNode\n\t\tif (parent != null) parent.removeChild(node)\n\t}\n\tfunction onremove(vnode) {\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === \"function\") vnode.attrs.onremove.call(vnode.state, vnode)\n\t\tif (typeof vnode.tag !== \"string\") {\n\t\t\tif (typeof vnode._state.onremove === \"function\") vnode._state.onremove.call(vnode.state, vnode)\n\t\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\t} else {\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//attrs2\n\tfunction setAttrs(vnode, attrs2, ns) {\n\t\tfor (var key2 in attrs2) {\n\t\t\tsetAttr(vnode, key2, null, attrs2[key2], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key2, old, value, ns) {\n\t\tvar element = vnode.dom\n\t\tif (key2 === \"key\" || key2 === \"is\" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== \"object\" || typeof value === \"undefined\" || isLifecycleMethod(key2)) return\n\t\tvar nsLastIndex = key2.indexOf(\":\")\n\t\tif (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === \"xlink\") {\n\t\t\telement.setAttributeNS(\"http://www.w3.org/1999/xlink\", key2.slice(nsLastIndex + 1), value)\n\t\t}\n\t\telse if (key2[0] === \"o\" && key2[1] === \"n\" && typeof value === \"function\") updateEvent(vnode, key2, value)\n\t\telse if (key2 === \"style\") updateStyle(element, old, value)\n\t\telse if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {\n\t\t\tif (key2 === \"value\") {\n\t\t\t\tvar normalized0 = \"\" + value // eslint-disable-line no-implicit-coercion\n\t\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\t\tif ((vnode.tag === \"input\" || vnode.tag === \"textarea\") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === \"select\") {\n\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\tif (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === \"option\" && old != null && vnode.dom.value === normalized0) return\n\t\t\t}\n\t\t\t// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.\n\t\t\tif (vnode.tag === \"input\" && key2 === \"type\") {\n\t\t\t\telement.setAttribute(key2, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t\telement[key2] = value\n\t\t}\n\t\telse {\n\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\tif (value) element.setAttribute(key2, \"\")\n\t\t\t\telse element.removeAttribute(key2)\n\t\t\t}\n\t\t\telse element.setAttribute(key2 === \"className\" ? \"class\" : key2, value)\n\t\t}\n\t}\n\tfunction setLateAttrs(vnode) {\n\t\tvar attrs2 = vnode.attrs\n\t\tif (vnode.tag === \"select\" && attrs2 != null) {\n\t\t\tif (\"value\" in attrs2) setAttr(vnode, \"value\", null, attrs2.value, undefined)\n\t\t\tif (\"selectedIndex\" in attrs2) setAttr(vnode, \"selectedIndex\", null, attrs2.selectedIndex, undefined)\n\t\t}\n\t}\n\tfunction updateAttrs(vnode, old, attrs2, ns) {\n\t\tif (attrs2 != null) {\n\t\t\tfor (var key2 in attrs2) {\n\t\t\t\tsetAttr(vnode, key2, old && old[key2], attrs2[key2], ns)\n\t\t\t}\n\t\t}\n\t\tif (old != null) {\n\t\t\tfor (var key2 in old) {\n\t\t\t\tif (attrs2 == null || !(key2 in attrs2)) {\n\t\t\t\t\tif (key2 === \"className\") key2 = \"class\"\n\t\t\t\t\tif (key2[0] === \"o\" && key2[1] === \"n\" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)\n\t\t\t\t\telse if (key2 !== \"key\") vnode.dom.removeAttribute(key2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === \"value\" || attr === \"checked\" || attr === \"selectedIndex\" || attr === \"selected\" && vnode.dom === $doc.activeElement\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === \"oninit\" || attr === \"oncreate\" || attr === \"onupdate\" || attr === \"onremove\" || attr === \"onbeforeremove\" || attr === \"onbeforeupdate\"\n\t}\n\tfunction isAttribute(attr) {\n\t\treturn attr === \"href\" || attr === \"list\" || attr === \"form\" || attr === \"width\" || attr === \"height\"// || attr === \"type\"\n\t}\n\tfunction isCustomElement(vnode){\n\t\treturn vnode.attrs.is || vnode.tag.indexOf(\"-\") > -1\n\t}\n\tfunction hasIntegrationMethods(source) {\n\t\treturn source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)\n\t}\n\t//style\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) element.style.cssText = \"\", old = null\n\t\tif (style == null) element.style.cssText = \"\"\n\t\telse if (typeof style === \"string\") element.style.cssText = style\n\t\telse {\n\t\t\tif (typeof old === \"string\") element.style.cssText = \"\"\n\t\t\tfor (var key2 in style) {\n\t\t\t\telement.style[key2] = style[key2]\n\t\t\t}\n\t\t\tif (old != null && typeof old !== \"string\") {\n\t\t\t\tfor (var key2 in old) {\n\t\t\t\t\tif (!(key2 in style)) element.style[key2] = \"\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//event\n\tfunction updateEvent(vnode, key2, value) {\n\t\tvar element = vnode.dom\n\t\tvar callback = typeof onevent !== \"function\" ? value : function(e) {\n\t\t\tvar result = value.call(element, e)\n\t\t\tonevent.call(element, e)\n\t\t\treturn result\n\t\t}\n\t\tif (key2 in element) element[key2] = typeof value === \"function\" ? callback : null\n\t\telse {\n\t\t\tvar eventName = key2.slice(2)\n\t\t\tif (vnode.events === undefined) vnode.events = {}\n\t\t\tif (vnode.events[key2] === callback) return\n\t\t\tif (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)\n\t\t\tif (typeof value === \"function\") {\n\t\t\t\tvnode.events[key2] = callback\n\t\t\t\telement.addEventListener(eventName, vnode.events[key2], false)\n\t\t\t}\n\t\t}\n\t}\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === \"function\") source.oninit.call(vnode.state, vnode)\n\t\tif (typeof source.oncreate === \"function\") hooks.push(source.oncreate.bind(vnode.state, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === \"function\") hooks.push(source.onupdate.bind(vnode.state, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tvar forceVnodeUpdate, forceComponentUpdate\n\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === \"function\") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onbeforeupdate === \"function\") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t\tvnode.instance = old.instance\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\tfunction render(dom, vnodes) {\n\t\tif (!dom) throw new Error(\"Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.\")\n\t\tvar hooks = []\n\t\tvar active = $doc.activeElement\n\t\tvar namespace = dom.namespaceURI\n\t\t// First time0 rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = \"\"\n\t\tif (!Array.isArray(vnodes)) vnodes = [vnodes]\n\t\tupdateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === \"http://www.w3.org/1999/xhtml\" ? undefined : namespace)\n\t\tdom.vnodes = vnodes\n\t\t// document.activeElement can return null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement\n\t\tif (active != null && $doc.activeElement !== active) active.focus()\n\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t}\n\treturn {render: render, setEventCallback: setEventCallback}\n}\nfunction throttle(callback) {\n\t//60fps translates to 16.6ms, round it down since setTimeout requires int\n\tvar time = 16\n\tvar last = 0, pending = null\n\tvar timeout = typeof requestAnimationFrame === \"function\" ? requestAnimationFrame : setTimeout\n\treturn function() {\n\t\tvar now = Date.now()\n\t\tif (last === 0 || now - last >= time) {\n\t\t\tlast = now\n\t\t\tcallback()\n\t\t}\n\t\telse if (pending === null) {\n\t\t\tpending = timeout(function() {\n\t\t\t\tpending = null\n\t\t\t\tcallback()\n\t\t\t\tlast = Date.now()\n\t\t\t}, time - (now - last))\n\t\t}\n\t}\n}\nvar _11 = function($window) {\n\tvar renderService = coreRenderer($window)\n\trenderService.setEventCallback(function(e) {\n\t\tif (e.redraw === false) e.redraw = undefined\n\t\telse redraw()\n\t})\n\tvar callbacks = []\n\tfunction subscribe(key1, callback) {\n\t\tunsubscribe(key1)\n\t\tcallbacks.push(key1, throttle(callback))\n\t}\n\tfunction unsubscribe(key1) {\n\t\tvar index = callbacks.indexOf(key1)\n\t\tif (index > -1) callbacks.splice(index, 2)\n\t}\n\tfunction redraw() {\n\t\tfor (var i = 1; i < callbacks.length; i += 2) {\n\t\t\tcallbacks[i]()\n\t\t}\n\t}\n\treturn {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}\n}\nvar redrawService = _11(window)\nrequestService.setCompletionCallback(redrawService.redraw)\nvar _16 = function(redrawService0) {\n\treturn function(root, component) {\n\t\tif (component === null) {\n\t\t\tredrawService0.render(root, [])\n\t\t\tredrawService0.unsubscribe(root)\n\t\t\treturn\n\t\t}\n\t\t\n\t\tif (component.view == null && typeof component !== \"function\") throw new Error(\"m.mount(element, component) expects a component, not a vnode\")\n\t\t\n\t\tvar run0 = function() {\n\t\t\tredrawService0.render(root, Vnode(component))\n\t\t}\n\t\tredrawService0.subscribe(root, run0)\n\t\tredrawService0.redraw()\n\t}\n}\nm.mount = _16(redrawService)\nvar Promise = PromisePolyfill\nvar parseQueryString = function(string) {\n\tif (string === \"\" || string == null) return {}\n\tif (string.charAt(0) === \"?\") string = string.slice(1)\n\tvar entries = string.split(\"&\"), data0 = {}, counters = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split(\"=\")\n\t\tvar key5 = decodeURIComponent(entry[0])\n\t\tvar value = entry.length === 2 ? decodeURIComponent(entry[1]) : \"\"\n\t\tif (value === \"true\") value = true\n\t\telse if (value === \"false\") value = false\n\t\tvar levels = key5.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data0\n\t\tif (key5.indexOf(\"[\") > -1) levels.pop()\n\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\tvar level = levels[j], nextLevel = levels[j + 1]\n\t\t\tvar isNumber = nextLevel == \"\" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tvar isValue = j === levels.length - 1\n\t\t\tif (level === \"\") {\n\t\t\t\tvar key5 = levels.slice(0, j).join()\n\t\t\t\tif (counters[key5] == null) counters[key5] = 0\n\t\t\t\tlevel = counters[key5]++\n\t\t\t}\n\t\t\tif (cursor[level] == null) {\n\t\t\t\tcursor[level] = isValue ? value : isNumber ? [] : {}\n\t\t\t}\n\t\t\tcursor = cursor[level]\n\t\t}\n\t}\n\treturn data0\n}\nvar coreRouter = function($window) {\n\tvar supportsPushState = typeof $window.history.pushState === \"function\"\n\tvar callAsync0 = typeof setImmediate === \"function\" ? setImmediate : setTimeout\n\tfunction normalize1(fragment0) {\n\t\tvar data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)\n\t\tif (fragment0 === \"pathname\" && data[0] !== \"/\") data = \"/\" + data\n\t\treturn data\n\t}\n\tvar asyncId\n\tfunction debounceAsync(callback0) {\n\t\treturn function() {\n\t\t\tif (asyncId != null) return\n\t\t\tasyncId = callAsync0(function() {\n\t\t\t\tasyncId = null\n\t\t\t\tcallback0()\n\t\t\t})\n\t\t}\n\t}\n\tfunction parsePath(path, queryData, hashData) {\n\t\tvar queryIndex = path.indexOf(\"?\")\n\t\tvar hashIndex = path.indexOf(\"#\")\n\t\tvar pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length\n\t\tif (queryIndex > -1) {\n\t\t\tvar queryEnd = hashIndex > -1 ? hashIndex : path.length\n\t\t\tvar queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))\n\t\t\tfor (var key4 in queryParams) queryData[key4] = queryParams[key4]\n\t\t}\n\t\tif (hashIndex > -1) {\n\t\t\tvar hashParams = parseQueryString(path.slice(hashIndex + 1))\n\t\t\tfor (var key4 in hashParams) hashData[key4] = hashParams[key4]\n\t\t}\n\t\treturn path.slice(0, pathEnd)\n\t}\n\tvar router = {prefix: \"#!\"}\n\trouter.getPath = function() {\n\t\tvar type2 = router.prefix.charAt(0)\n\t\tswitch (type2) {\n\t\t\tcase \"#\": return normalize1(\"hash\").slice(router.prefix.length)\n\t\t\tcase \"?\": return normalize1(\"search\").slice(router.prefix.length) + normalize1(\"hash\")\n\t\t\tdefault: return normalize1(\"pathname\").slice(router.prefix.length) + normalize1(\"search\") + normalize1(\"hash\")\n\t\t}\n\t}\n\trouter.setPath = function(path, data, options) {\n\t\tvar queryData = {}, hashData = {}\n\t\tpath = parsePath(path, queryData, hashData)\n\t\tif (data != null) {\n\t\t\tfor (var key4 in data) queryData[key4] = data[key4]\n\t\t\tpath = path.replace(/:([^\\/]+)/g, function(match2, token) {\n\t\t\t\tdelete queryData[token]\n\t\t\t\treturn data[token]\n\t\t\t})\n\t\t}\n\t\tvar query = buildQueryString(queryData)\n\t\tif (query) path += \"?\" + query\n\t\tvar hash = buildQueryString(hashData)\n\t\tif (hash) path += \"#\" + hash\n\t\tif (supportsPushState) {\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\t$window.onpopstate()\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)\n\t\t\telse $window.history.pushState(state, title, router.prefix + path)\n\t\t}\n\t\telse $window.location.href = router.prefix + path\n\t}\n\trouter.defineRoutes = function(routes, resolve, reject) {\n\t\tfunction resolveRoute() {\n\t\t\tvar path = router.getPath()\n\t\t\tvar params = {}\n\t\t\tvar pathname = parsePath(path, params, params)\n\t\t\tvar state = $window.history.state\n\t\t\tif (state != null) {\n\t\t\t\tfor (var k in state) params[k] = state[k]\n\t\t\t}\n\t\t\tfor (var route0 in routes) {\n\t\t\t\tvar matcher = new RegExp(\"^\" + route0.replace(/:[^\\/]+?\\.{3}/g, \"(.*?)\").replace(/:[^\\/]+/g, \"([^\\\\/]+)\") + \"\\/?$\")\n\t\t\t\tif (matcher.test(pathname)) {\n\t\t\t\t\tpathname.replace(matcher, function() {\n\t\t\t\t\t\tvar keys = route0.match(/:[^\\/]+/g) || []\n\t\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2)\n\t\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\tparams[keys[i].replace(/:|\\./g, \"\")] = decodeURIComponent(values[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(routes[route0], params, path, route0)\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\treject(path, params)\n\t\t}\n\t\tif (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)\n\t\telse if (router.prefix.charAt(0) === \"#\") $window.onhashchange = resolveRoute\n\t\tresolveRoute()\n\t}\n\treturn router\n}\nvar _20 = function($window, redrawService0) {\n\tvar routeService = coreRouter($window)\n\tvar identity = function(v) {return v}\n\tvar render1, component, attrs3, currentPath, lastUpdate\n\tvar route = function(root, defaultRoute, routes) {\n\t\tif (root == null) throw new Error(\"Ensure the DOM element that was passed to `m.route` is not undefined\")\n\t\tvar run1 = function() {\n\t\t\tif (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))\n\t\t}\n\t\tvar bail = function(path) {\n\t\t\tif (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})\n\t\t\telse throw new Error(\"Could not resolve default route \" + defaultRoute)\n\t\t}\n\t\trouteService.defineRoutes(routes, function(payload, params, path) {\n\t\t\tvar update = lastUpdate = function(routeResolver, comp) {\n\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\tcomponent = comp != null && (typeof comp.view === \"function\" || typeof comp === \"function\")? comp : \"div\"\n\t\t\t\tattrs3 = params, currentPath = path, lastUpdate = null\n\t\t\t\trender1 = (routeResolver.render || identity).bind(routeResolver)\n\t\t\t\trun1()\n\t\t\t}\n\t\t\tif (payload.view || typeof payload === \"function\") update({}, payload)\n\t\t\telse {\n\t\t\t\tif (payload.onmatch) {\n\t\t\t\t\tPromise.resolve(payload.onmatch(params, path)).then(function(resolved) {\n\t\t\t\t\t\tupdate(payload, resolved)\n\t\t\t\t\t}, bail)\n\t\t\t\t}\n\t\t\t\telse update(payload, \"div\")\n\t\t\t}\n\t\t}, bail)\n\t\tredrawService0.subscribe(root, run1)\n\t}\n\troute.set = function(path, data, options) {\n\t\tif (lastUpdate != null) {\n\t\t\toptions = options || {}\n\t\t\toptions.replace = true\n\t\t}\n\t\tlastUpdate = null\n\t\trouteService.setPath(path, data, options)\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = function(prefix0) {routeService.prefix = prefix0}\n\troute.link = function(vnode1) {\n\t\tvnode1.dom.setAttribute(\"href\", routeService.prefix + vnode1.attrs.href)\n\t\tvnode1.dom.onclick = function(e) {\n\t\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return\n\t\t\te.preventDefault()\n\t\t\te.redraw = false\n\t\t\tvar href = this.getAttribute(\"href\")\n\t\t\tif (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)\n\t\t\troute.set(href, undefined, undefined)\n\t\t}\n\t}\n\troute.param = function(key3) {\n\t\tif(typeof attrs3 !== \"undefined\" && typeof key3 !== \"undefined\") return attrs3[key3]\n\t\treturn attrs3\n\t}\n\treturn route\n}\nm.route = _20(window, redrawService)\nm.withAttr = function(attrName, callback1, context) {\n\treturn function(e) {\n\t\tcallback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))\n\t}\n}\nvar _28 = coreRenderer(window)\nm.render = _28.render\nm.redraw = redrawService.redraw\nm.request = requestService.request\nm.jsonp = requestService.jsonp\nm.parseQueryString = parseQueryString\nm.buildQueryString = buildQueryString\nm.version = \"1.1.6\"\nm.vnode = Vnode\nif (true) module[\"exports\"] = m\nelse {}\n}());\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWl0aHJpbC9taXRocmlsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pdGhyaWwvbWl0aHJpbC5qcz9jMzA3Il0sInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24oKSB7XG5cInVzZSBzdHJpY3RcIlxuZnVuY3Rpb24gVm5vZGUodGFnLCBrZXksIGF0dHJzMCwgY2hpbGRyZW4sIHRleHQsIGRvbSkge1xuXHRyZXR1cm4ge3RhZzogdGFnLCBrZXk6IGtleSwgYXR0cnM6IGF0dHJzMCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0ZXh0OiB0ZXh0LCBkb206IGRvbSwgZG9tU2l6ZTogdW5kZWZpbmVkLCBzdGF0ZTogdW5kZWZpbmVkLCBfc3RhdGU6IHVuZGVmaW5lZCwgZXZlbnRzOiB1bmRlZmluZWQsIGluc3RhbmNlOiB1bmRlZmluZWQsIHNraXA6IGZhbHNlfVxufVxuVm5vZGUubm9ybWFsaXplID0gZnVuY3Rpb24obm9kZSkge1xuXHRpZiAoQXJyYXkuaXNBcnJheShub2RlKSkgcmV0dXJuIFZub2RlKFwiW1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4obm9kZSksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRpZiAobm9kZSAhPSBudWxsICYmIHR5cGVvZiBub2RlICE9PSBcIm9iamVjdFwiKSByZXR1cm4gVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBub2RlID09PSBmYWxzZSA/IFwiXCIgOiBub2RlLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0cmV0dXJuIG5vZGVcbn1cblZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuID0gZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdGNoaWxkcmVuW2ldID0gVm5vZGUubm9ybWFsaXplKGNoaWxkcmVuW2ldKVxuXHR9XG5cdHJldHVybiBjaGlsZHJlblxufVxudmFyIHNlbGVjdG9yUGFyc2VyID0gLyg/OihefCN8XFwuKShbXiNcXC5cXFtcXF1dKykpfChcXFsoLis/KSg/Olxccyo9XFxzKihcInwnfCkoKD86XFxcXFtcIidcXF1dfC4pKj8pXFw1KT9cXF0pL2dcbnZhciBzZWxlY3RvckNhY2hlID0ge31cbnZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuZnVuY3Rpb24gaXNFbXB0eShvYmplY3QpIHtcblx0Zm9yICh2YXIga2V5IGluIG9iamVjdCkgaWYgKGhhc093bi5jYWxsKG9iamVjdCwga2V5KSkgcmV0dXJuIGZhbHNlXG5cdHJldHVybiB0cnVlXG59XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgPT09IFwiXCIgPyBhdHRyVmFsdWUgOiBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGlmICghaXNFbXB0eShzdGF0ZS5hdHRycykgJiYgIWlzRW1wdHkoYXR0cnMpKSB7XG5cdFx0dmFyIG5ld0F0dHJzID0ge31cblx0XHRmb3IodmFyIGtleSBpbiBhdHRycykge1xuXHRcdFx0aWYgKGhhc093bi5jYWxsKGF0dHJzLCBrZXkpKSB7XG5cdFx0XHRcdG5ld0F0dHJzW2tleV0gPSBhdHRyc1trZXldXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGF0dHJzID0gbmV3QXR0cnNcblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gc3RhdGUuYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoc3RhdGUuYXR0cnMsIGtleSkpIHtcblx0XHRcdGF0dHJzW2tleV0gPSBzdGF0ZS5hdHRyc1trZXldXG5cdFx0fVxuXHR9XG5cdGlmIChjbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChhdHRycy5jbGFzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRhdHRycy5jbGFzcyA9IHVuZGVmaW5lZFxuXHRcdFx0YXR0cnMuY2xhc3NOYW1lID0gY2xhc3NOYW1lXG5cdFx0fVxuXHRcdGlmIChzdGF0ZS5hdHRycy5jbGFzc05hbWUgIT0gbnVsbCkge1xuXHRcdFx0YXR0cnMuY2xhc3NOYW1lID0gc3RhdGUuYXR0cnMuY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWVcblx0XHR9XG5cdH1cblx0Zm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG5cdFx0aWYgKGhhc093bi5jYWxsKGF0dHJzLCBrZXkpICYmIGtleSAhPT0gXCJrZXlcIikge1xuXHRcdFx0aGFzQXR0cnMgPSB0cnVlXG5cdFx0XHRicmVha1xuXHRcdH1cblx0fVxuXHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdICE9IG51bGwgJiYgY2hpbGRyZW5bMF0udGFnID09PSBcIiNcIikge1xuXHRcdHRleHQgPSBjaGlsZHJlblswXS5jaGlsZHJlblxuXHR9IGVsc2Uge1xuXHRcdGNoaWxkTGlzdCA9IGNoaWxkcmVuXG5cdH1cblx0cmV0dXJuIFZub2RlKHN0YXRlLnRhZywgYXR0cnMua2V5LCBoYXNBdHRycyA/IGF0dHJzIDogdW5kZWZpbmVkLCBjaGlsZExpc3QsIHRleHQpXG59XG5mdW5jdGlvbiBoeXBlcnNjcmlwdChzZWxlY3Rvcikge1xuXHQvLyBCZWNhdXNlIHNsb3BweSBtb2RlIHN1Y2tzXG5cdHZhciBhdHRycyA9IGFyZ3VtZW50c1sxXSwgc3RhcnQgPSAyLCBjaGlsZHJlblxuXHRpZiAoc2VsZWN0b3IgPT0gbnVsbCB8fCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHNlbGVjdG9yICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHNlbGVjdG9yLnZpZXcgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHRocm93IEVycm9yKFwiVGhlIHNlbGVjdG9yIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgY29tcG9uZW50LlwiKTtcblx0fVxuXHRpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dmFyIGNhY2hlZCA9IHNlbGVjdG9yQ2FjaGVbc2VsZWN0b3JdIHx8IGNvbXBpbGVTZWxlY3RvcihzZWxlY3Rvcilcblx0fVxuXHRpZiAoYXR0cnMgPT0gbnVsbCkge1xuXHRcdGF0dHJzID0ge31cblx0fSBlbHNlIGlmICh0eXBlb2YgYXR0cnMgIT09IFwib2JqZWN0XCIgfHwgYXR0cnMudGFnICE9IG51bGwgfHwgQXJyYXkuaXNBcnJheShhdHRycykpIHtcblx0XHRhdHRycyA9IHt9XG5cdFx0c3RhcnQgPSAxXG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IHN0YXJ0ICsgMSkge1xuXHRcdGNoaWxkcmVuID0gYXJndW1lbnRzW3N0YXJ0XVxuXHRcdGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIGNoaWxkcmVuID0gW2NoaWxkcmVuXVxuXHR9IGVsc2Uge1xuXHRcdGNoaWxkcmVuID0gW11cblx0XHR3aGlsZSAoc3RhcnQgPCBhcmd1bWVudHMubGVuZ3RoKSBjaGlsZHJlbi5wdXNoKGFyZ3VtZW50c1tzdGFydCsrXSlcblx0fVxuXHR2YXIgbm9ybWFsaXplZCA9IFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKVxuXHRpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG5cdFx0cmV0dXJuIGV4ZWNTZWxlY3RvcihjYWNoZWQsIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBWbm9kZShzZWxlY3RvciwgYXR0cnMua2V5LCBhdHRycywgbm9ybWFsaXplZClcblx0fVxufVxuaHlwZXJzY3JpcHQudHJ1c3QgPSBmdW5jdGlvbihodG1sKSB7XG5cdGlmIChodG1sID09IG51bGwpIGh0bWwgPSBcIlwiXG5cdHJldHVybiBWbm9kZShcIjxcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGh0bWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxufVxuaHlwZXJzY3JpcHQuZnJhZ21lbnQgPSBmdW5jdGlvbihhdHRyczEsIGNoaWxkcmVuKSB7XG5cdHJldHVybiBWbm9kZShcIltcIiwgYXR0cnMxLmtleSwgYXR0cnMxLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbiksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxufVxudmFyIG0gPSBoeXBlcnNjcmlwdFxuLyoqIEBjb25zdHJ1Y3RvciAqL1xudmFyIFByb21pc2VQb2x5ZmlsbCA9IGZ1bmN0aW9uKGV4ZWN1dG9yKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlUG9seWZpbGwpKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlIG11c3QgYmUgY2FsbGVkIHdpdGggYG5ld2BcIilcblx0aWYgKHR5cGVvZiBleGVjdXRvciAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpXG5cdHZhciBzZWxmID0gdGhpcywgcmVzb2x2ZXJzID0gW10sIHJlamVjdG9ycyA9IFtdLCByZXNvbHZlQ3VycmVudCA9IGhhbmRsZXIocmVzb2x2ZXJzLCB0cnVlKSwgcmVqZWN0Q3VycmVudCA9IGhhbmRsZXIocmVqZWN0b3JzLCBmYWxzZSlcblx0dmFyIGluc3RhbmNlID0gc2VsZi5faW5zdGFuY2UgPSB7cmVzb2x2ZXJzOiByZXNvbHZlcnMsIHJlamVjdG9yczogcmVqZWN0b3JzfVxuXHR2YXIgY2FsbEFzeW5jID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dFxuXHRmdW5jdGlvbiBoYW5kbGVyKGxpc3QsIHNob3VsZEFic29yYikge1xuXHRcdHJldHVybiBmdW5jdGlvbiBleGVjdXRlKHZhbHVlKSB7XG5cdFx0XHR2YXIgdGhlblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHNob3VsZEFic29yYiAmJiB2YWx1ZSAhPSBudWxsICYmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiAodGhlbiA9IHZhbHVlLnRoZW4pID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IHNlbGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIHcvIGl0c2VsZlwiKVxuXHRcdFx0XHRcdGV4ZWN1dGVPbmNlKHRoZW4uYmluZCh2YWx1ZSkpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y2FsbEFzeW5jKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCFzaG91bGRBYnNvcmIgJiYgbGlzdC5sZW5ndGggPT09IDApIGNvbnNvbGUuZXJyb3IoXCJQb3NzaWJsZSB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb246XCIsIHZhbHVlKVxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSBsaXN0W2ldKHZhbHVlKVxuXHRcdFx0XHRcdFx0cmVzb2x2ZXJzLmxlbmd0aCA9IDAsIHJlamVjdG9ycy5sZW5ndGggPSAwXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5zdGF0ZSA9IHNob3VsZEFic29yYlxuXHRcdFx0XHRcdFx0aW5zdGFuY2UucmV0cnkgPSBmdW5jdGlvbigpIHtleGVjdXRlKHZhbHVlKX1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRyZWplY3RDdXJyZW50KGUpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGV4ZWN1dGVPbmNlKHRoZW4pIHtcblx0XHR2YXIgcnVucyA9IDBcblx0XHRmdW5jdGlvbiBydW4oZm4pIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAocnVucysrID4gMCkgcmV0dXJuXG5cdFx0XHRcdGZuKHZhbHVlKVxuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgb25lcnJvciA9IHJ1bihyZWplY3RDdXJyZW50KVxuXHRcdHRyeSB7dGhlbihydW4ocmVzb2x2ZUN1cnJlbnQpLCBvbmVycm9yKX0gY2F0Y2ggKGUpIHtvbmVycm9yKGUpfVxuXHR9XG5cdGV4ZWN1dGVPbmNlKGV4ZWN1dG9yKVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0aW9uKSB7XG5cdHZhciBzZWxmID0gdGhpcywgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZVxuXHRmdW5jdGlvbiBoYW5kbGUoY2FsbGJhY2ssIGxpc3QsIG5leHQsIHN0YXRlKSB7XG5cdFx0bGlzdC5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIG5leHQodmFsdWUpXG5cdFx0XHRlbHNlIHRyeSB7cmVzb2x2ZU5leHQoY2FsbGJhY2sodmFsdWUpKX0gY2F0Y2ggKGUpIHtpZiAocmVqZWN0TmV4dCkgcmVqZWN0TmV4dChlKX1cblx0XHR9KVxuXHRcdGlmICh0eXBlb2YgaW5zdGFuY2UucmV0cnkgPT09IFwiZnVuY3Rpb25cIiAmJiBzdGF0ZSA9PT0gaW5zdGFuY2Uuc3RhdGUpIGluc3RhbmNlLnJldHJ5KClcblx0fVxuXHR2YXIgcmVzb2x2ZU5leHQsIHJlamVjdE5leHRcblx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge3Jlc29sdmVOZXh0ID0gcmVzb2x2ZSwgcmVqZWN0TmV4dCA9IHJlamVjdH0pXG5cdGhhbmRsZShvbkZ1bGZpbGxlZCwgaW5zdGFuY2UucmVzb2x2ZXJzLCByZXNvbHZlTmV4dCwgdHJ1ZSksIGhhbmRsZShvblJlamVjdGlvbiwgaW5zdGFuY2UucmVqZWN0b3JzLCByZWplY3ROZXh0LCBmYWxzZSlcblx0cmV0dXJuIHByb21pc2Vcbn1cblByb21pc2VQb2x5ZmlsbC5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihvblJlamVjdGlvbikge1xuXHRyZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKVxufVxuUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlUG9seWZpbGwpIHJldHVybiB2YWx1ZVxuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlKSB7cmVzb2x2ZSh2YWx1ZSl9KVxufVxuUHJvbWlzZVBvbHlmaWxsLnJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge3JlamVjdCh2YWx1ZSl9KVxufVxuUHJvbWlzZVBvbHlmaWxsLmFsbCA9IGZ1bmN0aW9uKGxpc3QpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0dmFyIHRvdGFsID0gbGlzdC5sZW5ndGgsIGNvdW50ID0gMCwgdmFsdWVzID0gW11cblx0XHRpZiAobGlzdC5sZW5ndGggPT09IDApIHJlc29sdmUoW10pXG5cdFx0ZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdChmdW5jdGlvbihpKSB7XG5cdFx0XHRcdGZ1bmN0aW9uIGNvbnN1bWUodmFsdWUpIHtcblx0XHRcdFx0XHRjb3VudCsrXG5cdFx0XHRcdFx0dmFsdWVzW2ldID0gdmFsdWVcblx0XHRcdFx0XHRpZiAoY291bnQgPT09IHRvdGFsKSByZXNvbHZlKHZhbHVlcylcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobGlzdFtpXSAhPSBudWxsICYmICh0eXBlb2YgbGlzdFtpXSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbGlzdFtpXSA9PT0gXCJmdW5jdGlvblwiKSAmJiB0eXBlb2YgbGlzdFtpXS50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRsaXN0W2ldLnRoZW4oY29uc3VtZSwgcmVqZWN0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgY29uc3VtZShsaXN0W2ldKVxuXHRcdFx0fSkoaSlcblx0XHR9XG5cdH0pXG59XG5Qcm9taXNlUG9seWZpbGwucmFjZSA9IGZ1bmN0aW9uKGxpc3QpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsaXN0W2ldLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KVxuXHRcdH1cblx0fSlcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdGlmICh0eXBlb2Ygd2luZG93LlByb21pc2UgPT09IFwidW5kZWZpbmVkXCIpIHdpbmRvdy5Qcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG5cdHZhciBQcm9taXNlUG9seWZpbGwgPSB3aW5kb3cuUHJvbWlzZVxufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsLlByb21pc2UgPT09IFwidW5kZWZpbmVkXCIpIGdsb2JhbC5Qcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG5cdHZhciBQcm9taXNlUG9seWZpbGwgPSBnbG9iYWwuUHJvbWlzZVxufSBlbHNlIHtcbn1cbnZhciBidWlsZFF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24ob2JqZWN0KSB7XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIikgcmV0dXJuIFwiXCJcblx0dmFyIGFyZ3MgPSBbXVxuXHRmb3IgKHZhciBrZXkwIGluIG9iamVjdCkge1xuXHRcdGRlc3RydWN0dXJlKGtleTAsIG9iamVjdFtrZXkwXSlcblx0fVxuXHRyZXR1cm4gYXJncy5qb2luKFwiJlwiKVxuXHRmdW5jdGlvbiBkZXN0cnVjdHVyZShrZXkwLCB2YWx1ZSkge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRkZXN0cnVjdHVyZShrZXkwICsgXCJbXCIgKyBpICsgXCJdXCIsIHZhbHVlW2ldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIHZhbHVlKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgYXJncy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkwKSArICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBcIlwiID8gXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpIDogXCJcIikpXG5cdH1cbn1cbnZhciBGSUxFX1BST1RPQ09MX1JFR0VYID0gbmV3IFJlZ0V4cChcIl5maWxlOi8vXCIsIFwiaVwiKVxudmFyIF84ID0gZnVuY3Rpb24oJHdpbmRvdywgUHJvbWlzZSkge1xuXHR2YXIgY2FsbGJhY2tDb3VudCA9IDBcblx0dmFyIG9uY29tcGxldGlvblxuXHRmdW5jdGlvbiBzZXRDb21wbGV0aW9uQ2FsbGJhY2soY2FsbGJhY2spIHtvbmNvbXBsZXRpb24gPSBjYWxsYmFja31cblx0ZnVuY3Rpb24gZmluYWxpemVyKCkge1xuXHRcdHZhciBjb3VudCA9IDBcblx0XHRmdW5jdGlvbiBjb21wbGV0ZSgpIHtpZiAoLS1jb3VudCA9PT0gMCAmJiB0eXBlb2Ygb25jb21wbGV0aW9uID09PSBcImZ1bmN0aW9uXCIpIG9uY29tcGxldGlvbigpfVxuXHRcdHJldHVybiBmdW5jdGlvbiBmaW5hbGl6ZShwcm9taXNlMCkge1xuXHRcdFx0dmFyIHRoZW4wID0gcHJvbWlzZTAudGhlblxuXHRcdFx0cHJvbWlzZTAudGhlbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb3VudCsrXG5cdFx0XHRcdHZhciBuZXh0ID0gdGhlbjAuYXBwbHkocHJvbWlzZTAsIGFyZ3VtZW50cylcblx0XHRcdFx0bmV4dC50aGVuKGNvbXBsZXRlLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0Y29tcGxldGUoKVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gMCkgdGhyb3cgZVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRyZXR1cm4gZmluYWxpemUobmV4dClcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlMFxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBub3JtYWxpemUoYXJncywgZXh0cmEpIHtcblx0XHRpZiAodHlwZW9mIGFyZ3MgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZhciB1cmwgPSBhcmdzXG5cdFx0XHRhcmdzID0gZXh0cmEgfHwge31cblx0XHRcdGlmIChhcmdzLnVybCA9PSBudWxsKSBhcmdzLnVybCA9IHVybFxuXHRcdH1cblx0XHRyZXR1cm4gYXJnc1xuXHR9XG5cdGZ1bmN0aW9uIHJlcXVlc3QoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRpZiAoYXJncy5tZXRob2QgPT0gbnVsbCkgYXJncy5tZXRob2QgPSBcIkdFVFwiXG5cdFx0XHRhcmdzLm1ldGhvZCA9IGFyZ3MubWV0aG9kLnRvVXBwZXJDYXNlKClcblx0XHRcdHZhciB1c2VCb2R5ID0gKGFyZ3MubWV0aG9kID09PSBcIkdFVFwiIHx8IGFyZ3MubWV0aG9kID09PSBcIlRSQUNFXCIpID8gZmFsc2UgOiAodHlwZW9mIGFyZ3MudXNlQm9keSA9PT0gXCJib29sZWFuXCIgPyBhcmdzLnVzZUJvZHkgOiB0cnVlKVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLnNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLnNlcmlhbGl6ZSA9IHR5cGVvZiBGb3JtRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcmdzLmRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSA/IGZ1bmN0aW9uKHZhbHVlKSB7cmV0dXJuIHZhbHVlfSA6IEpTT04uc3RyaW5naWZ5XG5cdFx0XHRpZiAodHlwZW9mIGFyZ3MuZGVzZXJpYWxpemUgIT09IFwiZnVuY3Rpb25cIikgYXJncy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3MuZXh0cmFjdCAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmV4dHJhY3QgPSBleHRyYWN0XG5cdFx0XHRhcmdzLnVybCA9IGludGVycG9sYXRlKGFyZ3MudXJsLCBhcmdzLmRhdGEpXG5cdFx0XHRpZiAodXNlQm9keSkgYXJncy5kYXRhID0gYXJncy5zZXJpYWxpemUoYXJncy5kYXRhKVxuXHRcdFx0ZWxzZSBhcmdzLnVybCA9IGFzc2VtYmxlKGFyZ3MudXJsLCBhcmdzLmRhdGEpXG5cdFx0XHR2YXIgeGhyID0gbmV3ICR3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKSxcblx0XHRcdFx0YWJvcnRlZCA9IGZhbHNlLFxuXHRcdFx0XHRfYWJvcnQgPSB4aHIuYWJvcnRcblx0XHRcdHhoci5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuXHRcdFx0XHRhYm9ydGVkID0gdHJ1ZVxuXHRcdFx0XHRfYWJvcnQuY2FsbCh4aHIpXG5cdFx0XHR9XG5cdFx0XHR4aHIub3BlbihhcmdzLm1ldGhvZCwgYXJncy51cmwsIHR5cGVvZiBhcmdzLmFzeW5jID09PSBcImJvb2xlYW5cIiA/IGFyZ3MuYXN5bmMgOiB0cnVlLCB0eXBlb2YgYXJncy51c2VyID09PSBcInN0cmluZ1wiID8gYXJncy51c2VyIDogdW5kZWZpbmVkLCB0eXBlb2YgYXJncy5wYXNzd29yZCA9PT0gXCJzdHJpbmdcIiA/IGFyZ3MucGFzc3dvcmQgOiB1bmRlZmluZWQpXG5cdFx0XHRpZiAoYXJncy5zZXJpYWxpemUgPT09IEpTT04uc3RyaW5naWZ5ICYmIHVzZUJvZHkgJiYgIShhcmdzLmhlYWRlcnMgJiYgYXJncy5oZWFkZXJzLmhhc093blByb3BlcnR5KFwiQ29udGVudC1UeXBlXCIpKSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSAmJiAhKGFyZ3MuaGVhZGVycyAmJiBhcmdzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoXCJBY2NlcHRcIikpKSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC8qXCIpXG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJncy53aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSBhcmdzLndpdGhDcmVkZW50aWFsc1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZ3MuaGVhZGVycykgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXJncy5oZWFkZXJzLCBrZXkpKSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgYXJncy5oZWFkZXJzW2tleV0pXG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIGFyZ3MuY29uZmlnID09PSBcImZ1bmN0aW9uXCIpIHhociA9IGFyZ3MuY29uZmlnKHhociwgYXJncykgfHwgeGhyXG5cdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIERvbid0IHRocm93IGVycm9ycyBvbiB4aHIuYWJvcnQoKS5cblx0XHRcdFx0aWYoYWJvcnRlZCkgcmV0dXJuXG5cdFx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVzcG9uc2UgPSAoYXJncy5leHRyYWN0ICE9PSBleHRyYWN0KSA/IGFyZ3MuZXh0cmFjdCh4aHIsIGFyZ3MpIDogYXJncy5kZXNlcmlhbGl6ZShhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSlcblx0XHRcdFx0XHRcdGlmICgoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkgfHwgeGhyLnN0YXR1cyA9PT0gMzA0IHx8IEZJTEVfUFJPVE9DT0xfUkVHRVgudGVzdChhcmdzLnVybCkpIHtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShjYXN0KGFyZ3MudHlwZSwgcmVzcG9uc2UpKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcih4aHIucmVzcG9uc2VUZXh0KVxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gcmVzcG9uc2UpIGVycm9yW2tleV0gPSByZXNwb25zZVtrZXldXG5cdFx0XHRcdFx0XHRcdHJlamVjdChlcnJvcilcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHVzZUJvZHkgJiYgKGFyZ3MuZGF0YSAhPSBudWxsKSkgeGhyLnNlbmQoYXJncy5kYXRhKVxuXHRcdFx0ZWxzZSB4aHIuc2VuZCgpXG5cdFx0fSlcblx0XHRyZXR1cm4gYXJncy5iYWNrZ3JvdW5kID09PSB0cnVlID8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBqc29ucChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdHZhciBjYWxsYmFja05hbWUgPSBhcmdzLmNhbGxiYWNrTmFtZSB8fCBcIl9taXRocmlsX1wiICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMWUxNikgKyBcIl9cIiArIGNhbGxiYWNrQ291bnQrK1xuXHRcdFx0dmFyIHNjcmlwdCA9ICR3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKVxuXHRcdFx0JHdpbmRvd1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpXG5cdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIGRhdGEpKVxuXHRcdFx0XHRkZWxldGUgJHdpbmRvd1tjYWxsYmFja05hbWVdXG5cdFx0XHR9XG5cdFx0XHRzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpXG5cdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJKU09OUCByZXF1ZXN0IGZhaWxlZFwiKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3MuZGF0YSA9PSBudWxsKSBhcmdzLmRhdGEgPSB7fVxuXHRcdFx0YXJncy51cmwgPSBpbnRlcnBvbGF0ZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0YXJncy5kYXRhW2FyZ3MuY2FsbGJhY2tLZXkgfHwgXCJjYWxsYmFja1wiXSA9IGNhbGxiYWNrTmFtZVxuXHRcdFx0c2NyaXB0LnNyYyA9IGFzc2VtYmxlKGFyZ3MudXJsLCBhcmdzLmRhdGEpXG5cdFx0XHQkd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpXG5cdFx0fSlcblx0XHRyZXR1cm4gYXJncy5iYWNrZ3JvdW5kID09PSB0cnVlPyBwcm9taXNlMCA6IGZpbmFsaXplKHByb21pc2UwKVxuXHR9XG5cdGZ1bmN0aW9uIGludGVycG9sYXRlKHVybCwgZGF0YSkge1xuXHRcdGlmIChkYXRhID09IG51bGwpIHJldHVybiB1cmxcblx0XHR2YXIgdG9rZW5zID0gdXJsLm1hdGNoKC86W15cXC9dKy9naSkgfHwgW11cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGtleSA9IHRva2Vuc1tpXS5zbGljZSgxKVxuXHRcdFx0aWYgKGRhdGFba2V5XSAhPSBudWxsKSB7XG5cdFx0XHRcdHVybCA9IHVybC5yZXBsYWNlKHRva2Vuc1tpXSwgZGF0YVtrZXldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdXJsXG5cdH1cblx0ZnVuY3Rpb24gYXNzZW1ibGUodXJsLCBkYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5c3RyaW5nID0gYnVpbGRRdWVyeVN0cmluZyhkYXRhKVxuXHRcdGlmIChxdWVyeXN0cmluZyAhPT0gXCJcIikge1xuXHRcdFx0dmFyIHByZWZpeCA9IHVybC5pbmRleE9mKFwiP1wiKSA8IDAgPyBcIj9cIiA6IFwiJlwiXG5cdFx0XHR1cmwgKz0gcHJlZml4ICsgcXVlcnlzdHJpbmdcblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGRlc2VyaWFsaXplKGRhdGEpIHtcblx0XHR0cnkge3JldHVybiBkYXRhICE9PSBcIlwiID8gSlNPTi5wYXJzZShkYXRhKSA6IG51bGx9XG5cdFx0Y2F0Y2ggKGUpIHt0aHJvdyBuZXcgRXJyb3IoZGF0YSl9XG5cdH1cblx0ZnVuY3Rpb24gZXh0cmFjdCh4aHIpIHtyZXR1cm4geGhyLnJlc3BvbnNlVGV4dH1cblx0ZnVuY3Rpb24gY2FzdCh0eXBlMCwgZGF0YSkge1xuXHRcdGlmICh0eXBlb2YgdHlwZTAgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGF0YVtpXSA9IG5ldyB0eXBlMChkYXRhW2ldKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHJldHVybiBuZXcgdHlwZTAoZGF0YSlcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGFcblx0fVxuXHRyZXR1cm4ge3JlcXVlc3Q6IHJlcXVlc3QsIGpzb25wOiBqc29ucCwgc2V0Q29tcGxldGlvbkNhbGxiYWNrOiBzZXRDb21wbGV0aW9uQ2FsbGJhY2t9XG59XG52YXIgcmVxdWVzdFNlcnZpY2UgPSBfOCh3aW5kb3csIFByb21pc2VQb2x5ZmlsbClcbnZhciBjb3JlUmVuZGVyZXIgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciAkZG9jID0gJHdpbmRvdy5kb2N1bWVudFxuXHR2YXIgJGVtcHR5RnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHR2YXIgbmFtZVNwYWNlID0ge1xuXHRcdHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuXHRcdG1hdGg6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiXG5cdH1cblx0dmFyIG9uZXZlbnRcblx0ZnVuY3Rpb24gc2V0RXZlbnRDYWxsYmFjayhjYWxsYmFjaykge3JldHVybiBvbmV2ZW50ID0gY2FsbGJhY2t9XG5cdGZ1bmN0aW9uIGdldE5hbWVTcGFjZSh2bm9kZSkge1xuXHRcdHJldHVybiB2bm9kZS5hdHRycyAmJiB2bm9kZS5hdHRycy54bWxucyB8fCBuYW1lU3BhY2Vbdm5vZGUudGFnXVxuXHR9XG5cdC8vY3JlYXRlXG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRzd2l0Y2ggKHRhZykge1xuXHRcdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIjxcIjogcmV0dXJuIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCJbXCI6IHJldHVybiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHJldHVybiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dm5vZGUuZG9tID0gJGRvYy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS5jaGlsZHJlbilcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgdm5vZGUuZG9tLCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZhciBtYXRjaDEgPSB2bm9kZS5jaGlsZHJlbi5tYXRjaCgvXlxccyo/PChcXHcrKS9pbSkgfHwgW11cblx0XHR2YXIgcGFyZW50MSA9IHtjYXB0aW9uOiBcInRhYmxlXCIsIHRoZWFkOiBcInRhYmxlXCIsIHRib2R5OiBcInRhYmxlXCIsIHRmb290OiBcInRhYmxlXCIsIHRyOiBcInRib2R5XCIsIHRoOiBcInRyXCIsIHRkOiBcInRyXCIsIGNvbGdyb3VwOiBcInRhYmxlXCIsIGNvbDogXCJjb2xncm91cFwifVttYXRjaDFbMV1dIHx8IFwiZGl2XCJcblx0XHR2YXIgdGVtcCA9ICRkb2MuY3JlYXRlRWxlbWVudChwYXJlbnQxKVxuXHRcdHRlbXAuaW5uZXJIVE1MID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSB0ZW1wLmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gdGVtcC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0dmFyIGNoaWxkXG5cdFx0d2hpbGUgKGNoaWxkID0gdGVtcC5maXJzdENoaWxkKSB7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZClcblx0XHR9XG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGNyZWF0ZU5vZGVzKGZyYWdtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IGZyYWdtZW50LmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHR2YXIgYXR0cnMyID0gdm5vZGUuYXR0cnNcblx0XHR2YXIgaXMgPSBhdHRyczIgJiYgYXR0cnMyLmlzXG5cdFx0bnMgPSBnZXROYW1lU3BhY2Uodm5vZGUpIHx8IG5zXG5cdFx0dmFyIGVsZW1lbnQgPSBucyA/XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpIDpcblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50KHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50KHRhZylcblx0XHR2bm9kZS5kb20gPSBlbGVtZW50XG5cdFx0aWYgKGF0dHJzMiAhPSBudWxsKSB7XG5cdFx0XHRzZXRBdHRycyh2bm9kZSwgYXR0cnMyLCBucylcblx0XHR9XG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGVsZW1lbnQsIG5leHRTaWJsaW5nKVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHZub2RlLmF0dHJzLmNvbnRlbnRlZGl0YWJsZSAhPSBudWxsKSB7XG5cdFx0XHRzZXRDb250ZW50RWRpdGFibGUodm5vZGUpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodm5vZGUudGV4dCAhPT0gXCJcIikgZWxlbWVudC50ZXh0Q29udGVudCA9IHZub2RlLnRleHRcblx0XHRcdFx0ZWxzZSB2bm9kZS5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHZub2RlLnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKV1cblx0XHRcdH1cblx0XHRcdGlmICh2bm9kZS5jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRcdGNyZWF0ZU5vZGVzKGVsZW1lbnQsIGNoaWxkcmVuLCAwLCBjaGlsZHJlbi5sZW5ndGgsIGhvb2tzLCBudWxsLCBucylcblx0XHRcdFx0c2V0TGF0ZUF0dHJzKHZub2RlKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKSB7XG5cdFx0dmFyIHNlbnRpbmVsXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcudmlldyA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IE9iamVjdC5jcmVhdGUodm5vZGUudGFnKVxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS5zdGF0ZS52aWV3XG5cdFx0XHRpZiAoc2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgIT0gbnVsbCkgcmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IHRydWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSB2b2lkIDBcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUudGFnXG5cdFx0XHRpZiAoc2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgIT0gbnVsbCkgcmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IHRydWVcblx0XHRcdHZub2RlLnN0YXRlID0gKHZub2RlLnRhZy5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUudGFnLnByb3RvdHlwZS52aWV3ID09PSBcImZ1bmN0aW9uXCIpID8gbmV3IHZub2RlLnRhZyh2bm9kZSkgOiB2bm9kZS50YWcodm5vZGUpXG5cdFx0fVxuXHRcdHZub2RlLl9zdGF0ZSA9IHZub2RlLnN0YXRlXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRpbml0TGlmZWN5Y2xlKHZub2RlLl9zdGF0ZSwgdm5vZGUsIGhvb2tzKVxuXHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgPT09IHZub2RlKSB0aHJvdyBFcnJvcihcIkEgdmlldyBjYW5ub3QgcmV0dXJuIHRoZSB2bm9kZSBpdCByZWNlaXZlZCBhcyBhcmd1bWVudFwiKVxuXHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gbnVsbFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLmluc3RhbmNlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0dm5vZGUuZG9tID0gdm5vZGUuaW5zdGFuY2UuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gdm5vZGUuZG9tICE9IG51bGwgPyB2bm9kZS5pbnN0YW5jZS5kb21TaXplIDogMFxuXHRcdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGVsZW1lbnQsIG5leHRTaWJsaW5nKVxuXHRcdFx0cmV0dXJuIGVsZW1lbnRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdFx0cmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0fVxuXHR9XG5cdC8vdXBkYXRlXG5cdGZ1bmN0aW9uIHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLCB2bm9kZXMsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGlmIChvbGQgPT09IHZub2RlcyB8fCBvbGQgPT0gbnVsbCAmJiB2bm9kZXMgPT0gbnVsbCkgcmV0dXJuXG5cdFx0ZWxzZSBpZiAob2xkID09IG51bGwpIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCAwLCB2bm9kZXMubGVuZ3RoLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdGVsc2UgaWYgKHZub2RlcyA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIDAsIG9sZC5sZW5ndGgsIHZub2Rlcylcblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQubGVuZ3RoID09PSB2bm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpc1Vua2V5ZWQgPSBmYWxzZVxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiBvbGRbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aXNVbmtleWVkID0gdm5vZGVzW2ldLmtleSA9PSBudWxsICYmIG9sZFtpXS5rZXkgPT0gbnVsbFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzVW5rZXllZCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkW2ldID09PSB2bm9kZXNbaV0pIGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChvbGRbaV0gPT0gbnVsbCAmJiB2bm9kZXNbaV0gIT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2Rlc1tpXSwgaG9va3MsIG5zLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRlbHNlIGlmICh2bm9kZXNbaV0gPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCBpLCBpICsgMSwgdm5vZGVzKVxuXHRcdFx0XHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkW2ldLCB2bm9kZXNbaV0sIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWN5Y2xpbmcgPSByZWN5Y2xpbmcgfHwgaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKVxuXHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHR2YXIgcG9vbCA9IG9sZC5wb29sXG5cdFx0XHRcdG9sZCA9IG9sZC5jb25jYXQob2xkLnBvb2wpXG5cdFx0XHR9XG5cdFx0XHR2YXIgb2xkU3RhcnQgPSAwLCBzdGFydCA9IDAsIG9sZEVuZCA9IG9sZC5sZW5ndGggLSAxLCBlbmQgPSB2bm9kZXMubGVuZ3RoIC0gMSwgbWFwXG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRTdGFydF0sIHYgPSB2bm9kZXNbc3RhcnRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRTdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkU3RhcnQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdXG5cdFx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdFx0aWYgKHJlY3ljbGluZyB8fCBzdGFydCA8IGVuZCkgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgYnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXSwgdiA9IHZub2Rlc1tlbmRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRpZiAoby5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBvLmRvbVxuXHRcdFx0XHRcdG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICghbWFwKSBtYXAgPSBnZXRLZXlNYXAob2xkLCBvbGRFbmQpXG5cdFx0XHRcdFx0aWYgKHYgIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dmFyIG9sZEluZGV4ID0gbWFwW3Yua2V5XVxuXHRcdFx0XHRcdFx0aWYgKG9sZEluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1vdmFibGUgPSBvbGRbb2xkSW5kZXhdXG5cdFx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRJbmRleCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBtb3ZhYmxlLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0XHRcdGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG1vdmFibGUpLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0b2xkW29sZEluZGV4XS5za2lwID0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHRpZiAobW92YWJsZS5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBtb3ZhYmxlLmRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkb20gPSBjcmVhdGVOb2RlKHBhcmVudCwgdiwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0bmV4dFNpYmxpbmcgPSBkb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZW5kIDwgc3RhcnQpIGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCArIDEsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0XHRyZW1vdmVOb2RlcyhvbGQsIG9sZFN0YXJ0LCBvbGRFbmQgKyAxLCB2bm9kZXMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZU5vZGUocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpIHtcblx0XHR2YXIgb2xkVGFnID0gb2xkLnRhZywgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKG9sZFRhZyA9PT0gdGFnKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IG9sZC5zdGF0ZVxuXHRcdFx0dm5vZGUuX3N0YXRlID0gb2xkLl9zdGF0ZVxuXHRcdFx0dm5vZGUuZXZlbnRzID0gb2xkLmV2ZW50c1xuXHRcdFx0aWYgKCFyZWN5Y2xpbmcgJiYgc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpKSByZXR1cm5cblx0XHRcdGlmICh0eXBlb2Ygb2xkVGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHRcdFx0dm5vZGUuc3RhdGUgPSB7fVxuXHRcdFx0XHRcdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCAob2xkVGFnKSB7XG5cdFx0XHRcdFx0Y2FzZSBcIiNcIjogdXBkYXRlVGV4dChvbGQsIHZub2RlKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiPFwiOiB1cGRhdGVIVE1MKHBhcmVudCwgb2xkLCB2bm9kZSwgbmV4dFNpYmxpbmcpOyBicmVha1xuXHRcdFx0XHRcdGNhc2UgXCJbXCI6IHVwZGF0ZUZyYWdtZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKTsgYnJlYWtcblx0XHRcdFx0XHRkZWZhdWx0OiB1cGRhdGVFbGVtZW50KG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5zKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHVwZGF0ZUNvbXBvbmVudChwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZCwgbnVsbClcblx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlVGV4dChvbGQsIHZub2RlKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbi50b1N0cmluZygpICE9PSB2bm9kZS5jaGlsZHJlbi50b1N0cmluZygpKSB7XG5cdFx0XHRvbGQuZG9tLm5vZGVWYWx1ZSA9IHZub2RlLmNoaWxkcmVuXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVIVE1MKHBhcmVudCwgb2xkLCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAob2xkLmNoaWxkcmVuICE9PSB2bm9kZS5jaGlsZHJlbikge1xuXHRcdFx0dG9GcmFnbWVudChvbGQpXG5cdFx0XHRjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdH1cblx0XHRlbHNlIHZub2RlLmRvbSA9IG9sZC5kb20sIHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0dXBkYXRlTm9kZXMocGFyZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0dmFyIGRvbVNpemUgPSAwLCBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gbnVsbFxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkLmRvbSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHZub2RlLmRvbSA9PSBudWxsKSB2bm9kZS5kb20gPSBjaGlsZC5kb21cblx0XHRcdFx0XHRkb21TaXplICs9IGNoaWxkLmRvbVNpemUgfHwgMVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZG9tU2l6ZSAhPT0gMSkgdm5vZGUuZG9tU2l6ZSA9IGRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdG5zID0gZ2V0TmFtZVNwYWNlKHZub2RlKSB8fCBuc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzID09IG51bGwpIHZub2RlLmF0dHJzID0ge31cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuYXR0cnMudmFsdWUgPSB2bm9kZS50ZXh0IC8vRklYTUUgaGFuZGxlMCBtdWx0aXBsZSBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZS50ZXh0ID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQuYXR0cnMsIHZub2RlLmF0dHJzLCBucylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9PSBcIlwiKSB7XG5cdFx0XHRpZiAob2xkLnRleHQudG9TdHJpbmcoKSAhPT0gdm5vZGUudGV4dC50b1N0cmluZygpKSBvbGQuZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdm5vZGUudGV4dFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQudGV4dCAhPSBudWxsKSBvbGQuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGQudGV4dCwgdW5kZWZpbmVkLCBvbGQuZG9tLmZpcnN0Q2hpbGQpXVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkgdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR1cGRhdGVOb2RlcyhlbGVtZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0fVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAob2xkLmluc3RhbmNlID09IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZC5pbnN0YW5jZSwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmluc3RhbmNlLmRvbVNpemVcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLmluc3RhbmNlLCBudWxsKVxuXHRcdFx0dm5vZGUuZG9tID0gdW5kZWZpbmVkXG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpIHtcblx0XHRpZiAob2xkLnBvb2wgIT0gbnVsbCAmJiBNYXRoLmFicyhvbGQucG9vbC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSA8PSBNYXRoLmFicyhvbGQubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZFswXSAmJiBvbGRbMF0uY2hpbGRyZW4gJiYgb2xkWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgcG9vbENoaWxkcmVuTGVuZ3RoID0gb2xkLnBvb2xbMF0gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciB2bm9kZXNDaGlsZHJlbkxlbmd0aCA9IHZub2Rlc1swXSAmJiB2bm9kZXNbMF0uY2hpbGRyZW4gJiYgdm5vZGVzWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHRpZiAoTWF0aC5hYnMocG9vbENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpIDw9IE1hdGguYWJzKG9sZENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIGdldEtleU1hcCh2bm9kZXMsIGVuZCkge1xuXHRcdHZhciBtYXAgPSB7fSwgaSA9IDBcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBrZXkyID0gdm5vZGUua2V5XG5cdFx0XHRcdGlmIChrZXkyICE9IG51bGwpIG1hcFtrZXkyXSA9IGlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG5cdGZ1bmN0aW9uIHRvRnJhZ21lbnQodm5vZGUpIHtcblx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZVxuXHRcdGlmIChjb3VudDAgIT0gbnVsbCB8fCB2bm9kZS5kb20gPT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGlmIChjb3VudDAgPiAwKSB7XG5cdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdGZyYWdtZW50Lmluc2VydEJlZm9yZShkb20sIGZyYWdtZW50LmZpcnN0Q2hpbGQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJhZ21lbnRcblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcodm5vZGVzLCBpLCBuZXh0U2libGluZykge1xuXHRcdGZvciAoOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgdm5vZGVzW2ldLmRvbSAhPSBudWxsKSByZXR1cm4gdm5vZGVzW2ldLmRvbVxuXHRcdH1cblx0XHRyZXR1cm4gbmV4dFNpYmxpbmdcblx0fVxuXHRmdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudCwgZG9tLCBuZXh0U2libGluZykge1xuXHRcdGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnROb2RlKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9tKVxuXHR9XG5cdGZ1bmN0aW9uIHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCI8XCIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0XHRcdGlmICh2bm9kZS5kb20uaW5uZXJIVE1MICE9PSBjb250ZW50KSB2bm9kZS5kb20uaW5uZXJIVE1MID0gY29udGVudFxuXHRcdH1cblx0XHRlbHNlIGlmICh2bm9kZS50ZXh0ICE9IG51bGwgfHwgY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG5vZGUgb2YgYSBjb250ZW50ZWRpdGFibGUgbXVzdCBiZSB0cnVzdGVkXCIpXG5cdH1cblx0Ly9yZW1vdmVcblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZXModm5vZGVzLCBzdGFydCwgZW5kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnNraXApIHZub2RlLnNraXAgPSBmYWxzZVxuXHRcdFx0XHRlbHNlIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpIHtcblx0XHR2YXIgZXhwZWN0ZWQgPSAxLCBjYWxsZWQgPSAwXG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnRpbnVhdGlvbigpXG5cdFx0ZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuXHRcdFx0aWYgKCsrY2FsbGVkID09PSBleHBlY3RlZCkge1xuXHRcdFx0XHRvbnJlbW92ZSh2bm9kZSlcblx0XHRcdFx0aWYgKHZub2RlLmRvbSkge1xuXHRcdFx0XHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplIHx8IDFcblx0XHRcdFx0XHRpZiAoY291bnQwID4gMSkge1xuXHRcdFx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00odm5vZGUuZG9tKVxuXHRcdFx0XHRcdGlmIChjb250ZXh0ICE9IG51bGwgJiYgdm5vZGUuZG9tU2l6ZSA9PSBudWxsICYmICFoYXNJbnRlZ3JhdGlvbk1ldGhvZHModm5vZGUuYXR0cnMpICYmIHR5cGVvZiB2bm9kZS50YWcgPT09IFwic3RyaW5nXCIpIHsgLy9UT0RPIHRlc3QgY3VzdG9tIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnRleHQucG9vbCkgY29udGV4dC5wb29sID0gW3Zub2RlXVxuXHRcdFx0XHRcdFx0ZWxzZSBjb250ZXh0LnBvb2wucHVzaCh2bm9kZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZUZyb21ET00obm9kZSkge1xuXHRcdHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGVcblx0XHRpZiAocGFyZW50ICE9IG51bGwpIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKVxuXHR9XG5cdGZ1bmN0aW9uIG9ucmVtb3ZlKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5hdHRycy5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0aWYgKHR5cGVvZiB2bm9kZS5fc3RhdGUub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuX3N0YXRlLm9ucmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIG9ucmVtb3ZlKHZub2RlLmluc3RhbmNlKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsKSBvbnJlbW92ZShjaGlsZClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2F0dHJzMlxuXHRmdW5jdGlvbiBzZXRBdHRycyh2bm9kZSwgYXR0cnMyLCBucykge1xuXHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBudWxsLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQsIHZhbHVlLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0aWYgKGtleTIgPT09IFwia2V5XCIgfHwga2V5MiA9PT0gXCJpc1wiIHx8IChvbGQgPT09IHZhbHVlICYmICFpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGtleTIpKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IGlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSByZXR1cm5cblx0XHR2YXIgbnNMYXN0SW5kZXggPSBrZXkyLmluZGV4T2YoXCI6XCIpXG5cdFx0aWYgKG5zTGFzdEluZGV4ID4gLTEgJiYga2V5Mi5zdWJzdHIoMCwgbnNMYXN0SW5kZXgpID09PSBcInhsaW5rXCIpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIGtleTIuc2xpY2UobnNMYXN0SW5kZXggKyAxKSwgdmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgaW4gZWxlbWVudCAmJiAhaXNBdHRyaWJ1dGUoa2V5MikgJiYgbnMgPT09IHVuZGVmaW5lZCAmJiAhaXNDdXN0b21FbGVtZW50KHZub2RlKSkge1xuXHRcdFx0aWYgKGtleTIgPT09IFwidmFsdWVcIikge1xuXHRcdFx0XHR2YXIgbm9ybWFsaXplZDAgPSBcIlwiICsgdmFsdWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbXBsaWNpdC1jb2VyY2lvblxuXHRcdFx0XHQvL3NldHRpbmcgaW5wdXRbdmFsdWVdIHRvIHNhbWUgdmFsdWUgYnkgdHlwaW5nIG9uIGZvY3VzZWQgZWxlbWVudCBtb3ZlcyBjdXJzb3IgdG8gZW5kIGluIENocm9tZVxuXHRcdFx0XHRpZiAoKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiIHx8IHZub2RlLnRhZyA9PT0gXCJ0ZXh0YXJlYVwiKSAmJiB2bm9kZS5kb20udmFsdWUgPT09IG5vcm1hbGl6ZWQwICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdFx0Ly9zZXR0aW5nIHNlbGVjdFt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aWYgKHZub2RlLmRvbS5zZWxlY3RlZEluZGV4ID09PSAtMSAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChvbGQgIT09IG51bGwgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkMCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vc2V0dGluZyBvcHRpb25bdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwib3B0aW9uXCIgJiYgb2xkICE9IG51bGwgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkMCkgcmV0dXJuXG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB5b3UgYXNzaWduIGFuIGlucHV0IHR5cGUxIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRSAxMSB3aXRoIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiwgYW4gZXJyb3IwIHdpbGwgb2NjdXIuXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5MiA9PT0gXCJ0eXBlXCIpIHtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgdmFsdWUpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudFtrZXkyXSA9IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0aWYgKHZhbHVlKSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyLCBcIlwiKVxuXHRcdFx0XHRlbHNlIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleTIpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIgPT09IFwiY2xhc3NOYW1lXCIgPyBcImNsYXNzXCIgOiBrZXkyLCB2YWx1ZSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0TGF0ZUF0dHJzKHZub2RlKSB7XG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIiAmJiBhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0aWYgKFwidmFsdWVcIiBpbiBhdHRyczIpIHNldEF0dHIodm5vZGUsIFwidmFsdWVcIiwgbnVsbCwgYXR0cnMyLnZhbHVlLCB1bmRlZmluZWQpXG5cdFx0XHRpZiAoXCJzZWxlY3RlZEluZGV4XCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInNlbGVjdGVkSW5kZXhcIiwgbnVsbCwgYXR0cnMyLnNlbGVjdGVkSW5kZXgsIHVuZGVmaW5lZClcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQXR0cnModm5vZGUsIG9sZCwgYXR0cnMyLCBucykge1xuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBhdHRyczIpIHtcblx0XHRcdFx0c2V0QXR0cih2bm9kZSwga2V5Miwgb2xkICYmIG9sZFtrZXkyXSwgYXR0cnMyW2tleTJdLCBucylcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9sZCAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRpZiAoYXR0cnMyID09IG51bGwgfHwgIShrZXkyIGluIGF0dHJzMikpIHtcblx0XHRcdFx0XHRpZiAoa2V5MiA9PT0gXCJjbGFzc05hbWVcIikga2V5MiA9IFwiY2xhc3NcIlxuXHRcdFx0XHRcdGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiAhaXNMaWZlY3ljbGVNZXRob2Qoa2V5MikpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB1bmRlZmluZWQpXG5cdFx0XHRcdFx0ZWxzZSBpZiAoa2V5MiAhPT0gXCJrZXlcIikgdm5vZGUuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwgYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcInZhbHVlXCIgfHwgYXR0ciA9PT0gXCJjaGVja2VkXCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZEluZGV4XCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZFwiICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaXNMaWZlY3ljbGVNZXRob2QoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcIm9uaW5pdFwiIHx8IGF0dHIgPT09IFwib25jcmVhdGVcIiB8fCBhdHRyID09PSBcIm9udXBkYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmVyZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JldXBkYXRlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0F0dHJpYnV0ZShhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwiaHJlZlwiIHx8IGF0dHIgPT09IFwibGlzdFwiIHx8IGF0dHIgPT09IFwiZm9ybVwiIHx8IGF0dHIgPT09IFwid2lkdGhcIiB8fCBhdHRyID09PSBcImhlaWdodFwiLy8gfHwgYXR0ciA9PT0gXCJ0eXBlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodm5vZGUpe1xuXHRcdHJldHVybiB2bm9kZS5hdHRycy5pcyB8fCB2bm9kZS50YWcuaW5kZXhPZihcIi1cIikgPiAtMVxuXHR9XG5cdGZ1bmN0aW9uIGhhc0ludGVncmF0aW9uTWV0aG9kcyhzb3VyY2UpIHtcblx0XHRyZXR1cm4gc291cmNlICE9IG51bGwgJiYgKHNvdXJjZS5vbmNyZWF0ZSB8fCBzb3VyY2Uub251cGRhdGUgfHwgc291cmNlLm9uYmVmb3JlcmVtb3ZlIHx8IHNvdXJjZS5vbnJlbW92ZSlcblx0fVxuXHQvL3N0eWxlXG5cdGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKGVsZW1lbnQsIG9sZCwgc3R5bGUpIHtcblx0XHRpZiAob2xkID09PSBzdHlsZSkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIiwgb2xkID0gbnVsbFxuXHRcdGlmIChzdHlsZSA9PSBudWxsKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0ZWxzZSBpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBzdHlsZVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGQgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRcdGZvciAodmFyIGtleTIgaW4gc3R5bGUpIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZVtrZXkyXSA9IHN0eWxlW2tleTJdXG5cdFx0XHR9XG5cdFx0XHRpZiAob2xkICE9IG51bGwgJiYgdHlwZW9mIG9sZCAhPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRcdGlmICghKGtleTIgaW4gc3R5bGUpKSBlbGVtZW50LnN0eWxlW2tleTJdID0gXCJcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vZXZlbnRcblx0ZnVuY3Rpb24gdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHR2YXIgY2FsbGJhY2sgPSB0eXBlb2Ygb25ldmVudCAhPT0gXCJmdW5jdGlvblwiID8gdmFsdWUgOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdmFsdWUuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0b25ldmVudC5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdFx0fVxuXHRcdGlmIChrZXkyIGluIGVsZW1lbnQpIGVsZW1lbnRba2V5Ml0gPSB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhbGxiYWNrIDogbnVsbFxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGV2ZW50TmFtZSA9IGtleTIuc2xpY2UoMilcblx0XHRcdGlmICh2bm9kZS5ldmVudHMgPT09IHVuZGVmaW5lZCkgdm5vZGUuZXZlbnRzID0ge31cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gPT09IGNhbGxiYWNrKSByZXR1cm5cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gIT0gbnVsbCkgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2bm9kZS5ldmVudHNba2V5Ml0gPSBjYWxsYmFja1xuXHRcdFx0XHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB2bm9kZS5ldmVudHNba2V5Ml0sIGZhbHNlKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2xpZmVjeWNsZVxuXHRmdW5jdGlvbiBpbml0TGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25pbml0ID09PSBcImZ1bmN0aW9uXCIpIHNvdXJjZS5vbmluaXQuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub25jcmVhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUxpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9udXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9udXBkYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiBzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkge1xuXHRcdHZhciBmb3JjZVZub2RlVXBkYXRlLCBmb3JjZUNvbXBvbmVudFVwZGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZVZub2RlVXBkYXRlID0gdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlQ29tcG9uZW50VXBkYXRlID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKCEoZm9yY2VWbm9kZVVwZGF0ZSA9PT0gdW5kZWZpbmVkICYmIGZvcmNlQ29tcG9uZW50VXBkYXRlID09PSB1bmRlZmluZWQpICYmICFmb3JjZVZub2RlVXBkYXRlICYmICFmb3JjZUNvbXBvbmVudFVwZGF0ZSkge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IG9sZC5pbnN0YW5jZVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblx0ZnVuY3Rpb24gcmVuZGVyKGRvbSwgdm5vZGVzKSB7XG5cdFx0aWYgKCFkb20pIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgcGFzc2VkIHRvIG0ucm91dGUvbS5tb3VudC9tLnJlbmRlciBpcyBub3QgdW5kZWZpbmVkLlwiKVxuXHRcdHZhciBob29rcyA9IFtdXG5cdFx0dmFyIGFjdGl2ZSA9ICRkb2MuYWN0aXZlRWxlbWVudFxuXHRcdHZhciBuYW1lc3BhY2UgPSBkb20ubmFtZXNwYWNlVVJJXG5cdFx0Ly8gRmlyc3QgdGltZTAgcmVuZGVyaW5nIGludG8gYSBub2RlIGNsZWFycyBpdCBvdXRcblx0XHRpZiAoZG9tLnZub2RlcyA9PSBudWxsKSBkb20udGV4dENvbnRlbnQgPSBcIlwiXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KHZub2RlcykpIHZub2RlcyA9IFt2bm9kZXNdXG5cdFx0dXBkYXRlTm9kZXMoZG9tLCBkb20udm5vZGVzLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbih2bm9kZXMpLCBmYWxzZSwgaG9va3MsIG51bGwsIG5hbWVzcGFjZSA9PT0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIgPyB1bmRlZmluZWQgOiBuYW1lc3BhY2UpXG5cdFx0ZG9tLnZub2RlcyA9IHZub2Rlc1xuXHRcdC8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHJldHVybiBudWxsIGluIElFIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9hY3RpdmVFbGVtZW50XG5cdFx0aWYgKGFjdGl2ZSAhPSBudWxsICYmICRkb2MuYWN0aXZlRWxlbWVudCAhPT0gYWN0aXZlKSBhY3RpdmUuZm9jdXMoKVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIGhvb2tzW2ldKClcblx0fVxuXHRyZXR1cm4ge3JlbmRlcjogcmVuZGVyLCBzZXRFdmVudENhbGxiYWNrOiBzZXRFdmVudENhbGxiYWNrfVxufVxuZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2spIHtcblx0Ly82MGZwcyB0cmFuc2xhdGVzIHRvIDE2LjZtcywgcm91bmQgaXQgZG93biBzaW5jZSBzZXRUaW1lb3V0IHJlcXVpcmVzIGludFxuXHR2YXIgdGltZSA9IDE2XG5cdHZhciBsYXN0ID0gMCwgcGVuZGluZyA9IG51bGxcblx0dmFyIHRpbWVvdXQgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSBcImZ1bmN0aW9uXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBzZXRUaW1lb3V0XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKVxuXHRcdGlmIChsYXN0ID09PSAwIHx8IG5vdyAtIGxhc3QgPj0gdGltZSkge1xuXHRcdFx0bGFzdCA9IG5vd1xuXHRcdFx0Y2FsbGJhY2soKVxuXHRcdH1cblx0XHRlbHNlIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG5cdFx0XHRwZW5kaW5nID0gdGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0cGVuZGluZyA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2soKVxuXHRcdFx0XHRsYXN0ID0gRGF0ZS5ub3coKVxuXHRcdFx0fSwgdGltZSAtIChub3cgLSBsYXN0KSlcblx0XHR9XG5cdH1cbn1cbnZhciBfMTEgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciByZW5kZXJTZXJ2aWNlID0gY29yZVJlbmRlcmVyKCR3aW5kb3cpXG5cdHJlbmRlclNlcnZpY2Uuc2V0RXZlbnRDYWxsYmFjayhmdW5jdGlvbihlKSB7XG5cdFx0aWYgKGUucmVkcmF3ID09PSBmYWxzZSkgZS5yZWRyYXcgPSB1bmRlZmluZWRcblx0XHRlbHNlIHJlZHJhdygpXG5cdH0pXG5cdHZhciBjYWxsYmFja3MgPSBbXVxuXHRmdW5jdGlvbiBzdWJzY3JpYmUoa2V5MSwgY2FsbGJhY2spIHtcblx0XHR1bnN1YnNjcmliZShrZXkxKVxuXHRcdGNhbGxiYWNrcy5wdXNoKGtleTEsIHRocm90dGxlKGNhbGxiYWNrKSlcblx0fVxuXHRmdW5jdGlvbiB1bnN1YnNjcmliZShrZXkxKSB7XG5cdFx0dmFyIGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2Yoa2V5MSlcblx0XHRpZiAoaW5kZXggPiAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMilcblx0fVxuXHRmdW5jdGlvbiByZWRyYXcoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdGNhbGxiYWNrc1tpXSgpXG5cdFx0fVxuXHR9XG5cdHJldHVybiB7c3Vic2NyaWJlOiBzdWJzY3JpYmUsIHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSwgcmVkcmF3OiByZWRyYXcsIHJlbmRlcjogcmVuZGVyU2VydmljZS5yZW5kZXJ9XG59XG52YXIgcmVkcmF3U2VydmljZSA9IF8xMSh3aW5kb3cpXG5yZXF1ZXN0U2VydmljZS5zZXRDb21wbGV0aW9uQ2FsbGJhY2socmVkcmF3U2VydmljZS5yZWRyYXcpXG52YXIgXzE2ID0gZnVuY3Rpb24ocmVkcmF3U2VydmljZTApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKHJvb3QsIGNvbXBvbmVudCkge1xuXHRcdGlmIChjb21wb25lbnQgPT09IG51bGwpIHtcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCBbXSlcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnVuc3Vic2NyaWJlKHJvb3QpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGNvbXBvbmVudC52aWV3ID09IG51bGwgJiYgdHlwZW9mIGNvbXBvbmVudCAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJtLm1vdW50KGVsZW1lbnQsIGNvbXBvbmVudCkgZXhwZWN0cyBhIGNvbXBvbmVudCwgbm90IGEgdm5vZGVcIilcblx0XHRcblx0XHR2YXIgcnVuMCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFZub2RlKGNvbXBvbmVudCkpXG5cdFx0fVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4wKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnJlZHJhdygpXG5cdH1cbn1cbm0ubW91bnQgPSBfMTYocmVkcmF3U2VydmljZSlcbnZhciBQcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG52YXIgcGFyc2VRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHRpZiAoc3RyaW5nID09PSBcIlwiIHx8IHN0cmluZyA9PSBudWxsKSByZXR1cm4ge31cblx0aWYgKHN0cmluZy5jaGFyQXQoMCkgPT09IFwiP1wiKSBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMSlcblx0dmFyIGVudHJpZXMgPSBzdHJpbmcuc3BsaXQoXCImXCIpLCBkYXRhMCA9IHt9LCBjb3VudGVycyA9IHt9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBlbnRyeSA9IGVudHJpZXNbaV0uc3BsaXQoXCI9XCIpXG5cdFx0dmFyIGtleTUgPSBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMF0pXG5cdFx0dmFyIHZhbHVlID0gZW50cnkubGVuZ3RoID09PSAyID8gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5WzFdKSA6IFwiXCJcblx0XHRpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB2YWx1ZSA9IHRydWVcblx0XHRlbHNlIGlmICh2YWx1ZSA9PT0gXCJmYWxzZVwiKSB2YWx1ZSA9IGZhbHNlXG5cdFx0dmFyIGxldmVscyA9IGtleTUuc3BsaXQoL1xcXVxcWz98XFxbLylcblx0XHR2YXIgY3Vyc29yID0gZGF0YTBcblx0XHRpZiAoa2V5NS5pbmRleE9mKFwiW1wiKSA+IC0xKSBsZXZlbHMucG9wKClcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzW2pdLCBuZXh0TGV2ZWwgPSBsZXZlbHNbaiArIDFdXG5cdFx0XHR2YXIgaXNOdW1iZXIgPSBuZXh0TGV2ZWwgPT0gXCJcIiB8fCAhaXNOYU4ocGFyc2VJbnQobmV4dExldmVsLCAxMCkpXG5cdFx0XHR2YXIgaXNWYWx1ZSA9IGogPT09IGxldmVscy5sZW5ndGggLSAxXG5cdFx0XHRpZiAobGV2ZWwgPT09IFwiXCIpIHtcblx0XHRcdFx0dmFyIGtleTUgPSBsZXZlbHMuc2xpY2UoMCwgaikuam9pbigpXG5cdFx0XHRcdGlmIChjb3VudGVyc1trZXk1XSA9PSBudWxsKSBjb3VudGVyc1trZXk1XSA9IDBcblx0XHRcdFx0bGV2ZWwgPSBjb3VudGVyc1trZXk1XSsrXG5cdFx0XHR9XG5cdFx0XHRpZiAoY3Vyc29yW2xldmVsXSA9PSBudWxsKSB7XG5cdFx0XHRcdGN1cnNvcltsZXZlbF0gPSBpc1ZhbHVlID8gdmFsdWUgOiBpc051bWJlciA/IFtdIDoge31cblx0XHRcdH1cblx0XHRcdGN1cnNvciA9IGN1cnNvcltsZXZlbF1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGEwXG59XG52YXIgY29yZVJvdXRlciA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gdHlwZW9mICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPT09IFwiZnVuY3Rpb25cIlxuXHR2YXIgY2FsbEFzeW5jMCA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXRcblx0ZnVuY3Rpb24gbm9ybWFsaXplMShmcmFnbWVudDApIHtcblx0XHR2YXIgZGF0YSA9ICR3aW5kb3cubG9jYXRpb25bZnJhZ21lbnQwXS5yZXBsYWNlKC8oPzolW2EtZjg5XVthLWYwLTldKSsvZ2ltLCBkZWNvZGVVUklDb21wb25lbnQpXG5cdFx0aWYgKGZyYWdtZW50MCA9PT0gXCJwYXRobmFtZVwiICYmIGRhdGFbMF0gIT09IFwiL1wiKSBkYXRhID0gXCIvXCIgKyBkYXRhXG5cdFx0cmV0dXJuIGRhdGFcblx0fVxuXHR2YXIgYXN5bmNJZFxuXHRmdW5jdGlvbiBkZWJvdW5jZUFzeW5jKGNhbGxiYWNrMCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChhc3luY0lkICE9IG51bGwpIHJldHVyblxuXHRcdFx0YXN5bmNJZCA9IGNhbGxBc3luYzAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGFzeW5jSWQgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrMCgpXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSkge1xuXHRcdHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKVxuXHRcdHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpXG5cdFx0dmFyIHBhdGhFbmQgPSBxdWVyeUluZGV4ID4gLTEgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdGlmIChxdWVyeUluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBxdWVyeUVuZCA9IGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogcGF0aC5sZW5ndGhcblx0XHRcdHZhciBxdWVyeVBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSwgcXVlcnlFbmQpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBxdWVyeVBhcmFtcykgcXVlcnlEYXRhW2tleTRdID0gcXVlcnlQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0aWYgKGhhc2hJbmRleCA+IC0xKSB7XG5cdFx0XHR2YXIgaGFzaFBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShoYXNoSW5kZXggKyAxKSlcblx0XHRcdGZvciAodmFyIGtleTQgaW4gaGFzaFBhcmFtcykgaGFzaERhdGFba2V5NF0gPSBoYXNoUGFyYW1zW2tleTRdXG5cdFx0fVxuXHRcdHJldHVybiBwYXRoLnNsaWNlKDAsIHBhdGhFbmQpXG5cdH1cblx0dmFyIHJvdXRlciA9IHtwcmVmaXg6IFwiIyFcIn1cblx0cm91dGVyLmdldFBhdGggPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHlwZTIgPSByb3V0ZXIucHJlZml4LmNoYXJBdCgwKVxuXHRcdHN3aXRjaCAodHlwZTIpIHtcblx0XHRcdGNhc2UgXCIjXCI6IHJldHVybiBub3JtYWxpemUxKFwiaGFzaFwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aClcblx0XHRcdGNhc2UgXCI/XCI6IHJldHVybiBub3JtYWxpemUxKFwic2VhcmNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4gbm9ybWFsaXplMShcInBhdGhuYW1lXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikgKyBub3JtYWxpemUxKFwiaGFzaFwiKVxuXHRcdH1cblx0fVxuXHRyb3V0ZXIuc2V0UGF0aCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHR2YXIgcXVlcnlEYXRhID0ge30sIGhhc2hEYXRhID0ge31cblx0XHRwYXRoID0gcGFyc2VQYXRoKHBhdGgsIHF1ZXJ5RGF0YSwgaGFzaERhdGEpXG5cdFx0aWYgKGRhdGEgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBkYXRhKSBxdWVyeURhdGFba2V5NF0gPSBkYXRhW2tleTRdXG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC86KFteXFwvXSspL2csIGZ1bmN0aW9uKG1hdGNoMiwgdG9rZW4pIHtcblx0XHRcdFx0ZGVsZXRlIHF1ZXJ5RGF0YVt0b2tlbl1cblx0XHRcdFx0cmV0dXJuIGRhdGFbdG9rZW5dXG5cdFx0XHR9KVxuXHRcdH1cblx0XHR2YXIgcXVlcnkgPSBidWlsZFF1ZXJ5U3RyaW5nKHF1ZXJ5RGF0YSlcblx0XHRpZiAocXVlcnkpIHBhdGggKz0gXCI/XCIgKyBxdWVyeVxuXHRcdHZhciBoYXNoID0gYnVpbGRRdWVyeVN0cmluZyhoYXNoRGF0YSlcblx0XHRpZiAoaGFzaCkgcGF0aCArPSBcIiNcIiArIGhhc2hcblx0XHRpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcblx0XHRcdHZhciBzdGF0ZSA9IG9wdGlvbnMgPyBvcHRpb25zLnN0YXRlIDogbnVsbFxuXHRcdFx0dmFyIHRpdGxlID0gb3B0aW9ucyA/IG9wdGlvbnMudGl0bGUgOiBudWxsXG5cdFx0XHQkd2luZG93Lm9ucG9wc3RhdGUoKVxuXHRcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBsYWNlKSAkd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgcm91dGVyLnByZWZpeCArIHBhdGgpXG5cdFx0XHRlbHNlICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHR9XG5cdFx0ZWxzZSAkd2luZG93LmxvY2F0aW9uLmhyZWYgPSByb3V0ZXIucHJlZml4ICsgcGF0aFxuXHR9XG5cdHJvdXRlci5kZWZpbmVSb3V0ZXMgPSBmdW5jdGlvbihyb3V0ZXMsIHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGZ1bmN0aW9uIHJlc29sdmVSb3V0ZSgpIHtcblx0XHRcdHZhciBwYXRoID0gcm91dGVyLmdldFBhdGgoKVxuXHRcdFx0dmFyIHBhcmFtcyA9IHt9XG5cdFx0XHR2YXIgcGF0aG5hbWUgPSBwYXJzZVBhdGgocGF0aCwgcGFyYW1zLCBwYXJhbXMpXG5cdFx0XHR2YXIgc3RhdGUgPSAkd2luZG93Lmhpc3Rvcnkuc3RhdGVcblx0XHRcdGlmIChzdGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAodmFyIGsgaW4gc3RhdGUpIHBhcmFtc1trXSA9IHN0YXRlW2tdXG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciByb3V0ZTAgaW4gcm91dGVzKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVyID0gbmV3IFJlZ0V4cChcIl5cIiArIHJvdXRlMC5yZXBsYWNlKC86W15cXC9dKz9cXC57M30vZywgXCIoLio/KVwiKS5yZXBsYWNlKC86W15cXC9dKy9nLCBcIihbXlxcXFwvXSspXCIpICsgXCJcXC8/JFwiKVxuXHRcdFx0XHRpZiAobWF0Y2hlci50ZXN0KHBhdGhuYW1lKSkge1xuXHRcdFx0XHRcdHBhdGhuYW1lLnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIga2V5cyA9IHJvdXRlMC5tYXRjaCgvOlteXFwvXSsvZykgfHwgW11cblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgLTIpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cGFyYW1zW2tleXNbaV0ucmVwbGFjZSgvOnxcXC4vZywgXCJcIildID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlc1tpXSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlc29sdmUocm91dGVzW3JvdXRlMF0sIHBhcmFtcywgcGF0aCwgcm91dGUwKVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlamVjdChwYXRoLCBwYXJhbXMpXG5cdFx0fVxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkgJHdpbmRvdy5vbnBvcHN0YXRlID0gZGVib3VuY2VBc3luYyhyZXNvbHZlUm91dGUpXG5cdFx0ZWxzZSBpZiAocm91dGVyLnByZWZpeC5jaGFyQXQoMCkgPT09IFwiI1wiKSAkd2luZG93Lm9uaGFzaGNoYW5nZSA9IHJlc29sdmVSb3V0ZVxuXHRcdHJlc29sdmVSb3V0ZSgpXG5cdH1cblx0cmV0dXJuIHJvdXRlclxufVxudmFyIF8yMCA9IGZ1bmN0aW9uKCR3aW5kb3csIHJlZHJhd1NlcnZpY2UwKSB7XG5cdHZhciByb3V0ZVNlcnZpY2UgPSBjb3JlUm91dGVyKCR3aW5kb3cpXG5cdHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uKHYpIHtyZXR1cm4gdn1cblx0dmFyIHJlbmRlcjEsIGNvbXBvbmVudCwgYXR0cnMzLCBjdXJyZW50UGF0aCwgbGFzdFVwZGF0ZVxuXHR2YXIgcm91dGUgPSBmdW5jdGlvbihyb290LCBkZWZhdWx0Um91dGUsIHJvdXRlcykge1xuXHRcdGlmIChyb290ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIHRvIGBtLnJvdXRlYCBpcyBub3QgdW5kZWZpbmVkXCIpXG5cdFx0dmFyIHJ1bjEgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChyZW5kZXIxICE9IG51bGwpIHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCByZW5kZXIxKFZub2RlKGNvbXBvbmVudCwgYXR0cnMzLmtleSwgYXR0cnMzKSkpXG5cdFx0fVxuXHRcdHZhciBiYWlsID0gZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0aWYgKHBhdGggIT09IGRlZmF1bHRSb3V0ZSkgcm91dGVTZXJ2aWNlLnNldFBhdGgoZGVmYXVsdFJvdXRlLCBudWxsLCB7cmVwbGFjZTogdHJ1ZX0pXG5cdFx0XHRlbHNlIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIGRlZmF1bHQgcm91dGUgXCIgKyBkZWZhdWx0Um91dGUpXG5cdFx0fVxuXHRcdHJvdXRlU2VydmljZS5kZWZpbmVSb3V0ZXMocm91dGVzLCBmdW5jdGlvbihwYXlsb2FkLCBwYXJhbXMsIHBhdGgpIHtcblx0XHRcdHZhciB1cGRhdGUgPSBsYXN0VXBkYXRlID0gZnVuY3Rpb24ocm91dGVSZXNvbHZlciwgY29tcCkge1xuXHRcdFx0XHRpZiAodXBkYXRlICE9PSBsYXN0VXBkYXRlKSByZXR1cm5cblx0XHRcdFx0Y29tcG9uZW50ID0gY29tcCAhPSBudWxsICYmICh0eXBlb2YgY29tcC52aWV3ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGNvbXAgPT09IFwiZnVuY3Rpb25cIik/IGNvbXAgOiBcImRpdlwiXG5cdFx0XHRcdGF0dHJzMyA9IHBhcmFtcywgY3VycmVudFBhdGggPSBwYXRoLCBsYXN0VXBkYXRlID0gbnVsbFxuXHRcdFx0XHRyZW5kZXIxID0gKHJvdXRlUmVzb2x2ZXIucmVuZGVyIHx8IGlkZW50aXR5KS5iaW5kKHJvdXRlUmVzb2x2ZXIpXG5cdFx0XHRcdHJ1bjEoKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBheWxvYWQudmlldyB8fCB0eXBlb2YgcGF5bG9hZCA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGUoe30sIHBheWxvYWQpXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKHBheWxvYWQub25tYXRjaCkge1xuXHRcdFx0XHRcdFByb21pc2UucmVzb2x2ZShwYXlsb2FkLm9ubWF0Y2gocGFyYW1zLCBwYXRoKSkudGhlbihmdW5jdGlvbihyZXNvbHZlZCkge1xuXHRcdFx0XHRcdFx0dXBkYXRlKHBheWxvYWQsIHJlc29sdmVkKVxuXHRcdFx0XHRcdH0sIGJhaWwpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB1cGRhdGUocGF5bG9hZCwgXCJkaXZcIilcblx0XHRcdH1cblx0XHR9LCBiYWlsKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4xKVxuXHR9XG5cdHJvdXRlLnNldCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHRpZiAobGFzdFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXHRcdFx0b3B0aW9ucy5yZXBsYWNlID0gdHJ1ZVxuXHRcdH1cblx0XHRsYXN0VXBkYXRlID0gbnVsbFxuXHRcdHJvdXRlU2VydmljZS5zZXRQYXRoKHBhdGgsIGRhdGEsIG9wdGlvbnMpXG5cdH1cblx0cm91dGUuZ2V0ID0gZnVuY3Rpb24oKSB7cmV0dXJuIGN1cnJlbnRQYXRofVxuXHRyb3V0ZS5wcmVmaXggPSBmdW5jdGlvbihwcmVmaXgwKSB7cm91dGVTZXJ2aWNlLnByZWZpeCA9IHByZWZpeDB9XG5cdHJvdXRlLmxpbmsgPSBmdW5jdGlvbih2bm9kZTEpIHtcblx0XHR2bm9kZTEuZG9tLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgcm91dGVTZXJ2aWNlLnByZWZpeCArIHZub2RlMS5hdHRycy5ocmVmKVxuXHRcdHZub2RlMS5kb20ub25jbGljayA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkgfHwgZS53aGljaCA9PT0gMikgcmV0dXJuXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KClcblx0XHRcdGUucmVkcmF3ID0gZmFsc2Vcblx0XHRcdHZhciBocmVmID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpXG5cdFx0XHRpZiAoaHJlZi5pbmRleE9mKHJvdXRlU2VydmljZS5wcmVmaXgpID09PSAwKSBocmVmID0gaHJlZi5zbGljZShyb3V0ZVNlcnZpY2UucHJlZml4Lmxlbmd0aClcblx0XHRcdHJvdXRlLnNldChocmVmLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0XHR9XG5cdH1cblx0cm91dGUucGFyYW0gPSBmdW5jdGlvbihrZXkzKSB7XG5cdFx0aWYodHlwZW9mIGF0dHJzMyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Yga2V5MyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGF0dHJzM1trZXkzXVxuXHRcdHJldHVybiBhdHRyczNcblx0fVxuXHRyZXR1cm4gcm91dGVcbn1cbm0ucm91dGUgPSBfMjAod2luZG93LCByZWRyYXdTZXJ2aWNlKVxubS53aXRoQXR0ciA9IGZ1bmN0aW9uKGF0dHJOYW1lLCBjYWxsYmFjazEsIGNvbnRleHQpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKGUpIHtcblx0XHRjYWxsYmFjazEuY2FsbChjb250ZXh0IHx8IHRoaXMsIGF0dHJOYW1lIGluIGUuY3VycmVudFRhcmdldCA/IGUuY3VycmVudFRhcmdldFthdHRyTmFtZV0gOiBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSlcblx0fVxufVxudmFyIF8yOCA9IGNvcmVSZW5kZXJlcih3aW5kb3cpXG5tLnJlbmRlciA9IF8yOC5yZW5kZXJcbm0ucmVkcmF3ID0gcmVkcmF3U2VydmljZS5yZWRyYXdcbm0ucmVxdWVzdCA9IHJlcXVlc3RTZXJ2aWNlLnJlcXVlc3Rcbm0uanNvbnAgPSByZXF1ZXN0U2VydmljZS5qc29ucFxubS5wYXJzZVF1ZXJ5U3RyaW5nID0gcGFyc2VRdWVyeVN0cmluZ1xubS5idWlsZFF1ZXJ5U3RyaW5nID0gYnVpbGRRdWVyeVN0cmluZ1xubS52ZXJzaW9uID0gXCIxLjEuNlwiXG5tLnZub2RlID0gVm5vZGVcbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGVbXCJleHBvcnRzXCJdID0gbVxuZWxzZSB3aW5kb3cubSA9IG1cbn0oKSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mithril/mithril.js\n");

/***/ }),

/***/ "./node_modules/mpd-parser/dist/mpd-parser.es.js":
/*!*******************************************************!*\
  !*** ./node_modules/mpd-parser/dist/mpd-parser.es.js ***!
  \*******************************************************/
/*! exports provided: VERSION, parse, parseUTCTiming */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return VERSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseUTCTiming\", function() { return parseUTCTiming; });\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! global/window */ \"./node_modules/global/window.js\");\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(global_window__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * mpd-parser\n * @version 0.6.1\n * @copyright 2018 Brightcove, Inc\n * @license Apache-2.0\n */\n\n\n\nvar version = \"0.6.1\";\n\nvar formatAudioPlaylist = function formatAudioPlaylist(_ref) {\n  var _attributes;\n\n  var attributes = _ref.attributes,\n      segments = _ref.segments;\n\n  var playlist = {\n    attributes: (_attributes = {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      CODECS: attributes.codecs\n    }, _attributes['PROGRAM-ID'] = 1, _attributes),\n    uri: '',\n    endList: (attributes.type || 'static') === 'static',\n    timeline: attributes.periodIndex,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    segments: segments,\n    mediaSequence: segments.length ? segments[0].number : 1\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  return playlist;\n};\n\nvar formatVttPlaylist = function formatVttPlaylist(_ref2) {\n  var _attributes2;\n\n  var attributes = _ref2.attributes,\n      segments = _ref2.segments;\n\n  if (typeof segments === 'undefined') {\n    // vtt tracks may use single file in BaseURL\n    segments = [{\n      uri: attributes.baseUrl,\n      timeline: attributes.periodIndex,\n      resolvedUri: attributes.baseUrl || '',\n      duration: attributes.sourceDuration,\n      number: 0\n    }];\n    // targetDuration should be the same duration as the only segment\n    attributes.duration = attributes.sourceDuration;\n  }\n  return {\n    attributes: (_attributes2 = {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth\n    }, _attributes2['PROGRAM-ID'] = 1, _attributes2),\n    uri: '',\n    endList: (attributes.type || 'static') === 'static',\n    timeline: attributes.periodIndex,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    segments: segments,\n    mediaSequence: segments.length ? segments[0].number : 1\n  };\n};\n\nvar organizeAudioPlaylists = function organizeAudioPlaylists(playlists) {\n  return playlists.reduce(function (a, playlist) {\n    var role = playlist.attributes.role && playlist.attributes.role.value || 'main';\n    var language = playlist.attributes.lang || '';\n\n    var label = 'main';\n\n    if (language) {\n      label = playlist.attributes.lang + ' (' + role + ')';\n    }\n\n    // skip if we already have the highest quality audio for a language\n    if (a[label] && a[label].playlists[0].attributes.BANDWIDTH > playlist.attributes.bandwidth) {\n      return a;\n    }\n\n    a[label] = {\n      language: language,\n      autoselect: true,\n      'default': role === 'main',\n      playlists: [formatAudioPlaylist(playlist)],\n      uri: ''\n    };\n\n    return a;\n  }, {});\n};\n\nvar organizeVttPlaylists = function organizeVttPlaylists(playlists) {\n  return playlists.reduce(function (a, playlist) {\n    var label = playlist.attributes.lang || 'text';\n\n    // skip if we already have subtitles\n    if (a[label]) {\n      return a;\n    }\n\n    a[label] = {\n      language: label,\n      'default': false,\n      autoselect: false,\n      playlists: [formatVttPlaylist(playlist)],\n      uri: ''\n    };\n\n    return a;\n  }, {});\n};\n\nvar formatVideoPlaylist = function formatVideoPlaylist(_ref3) {\n  var _attributes3;\n\n  var attributes = _ref3.attributes,\n      segments = _ref3.segments;\n\n  var playlist = {\n    attributes: (_attributes3 = {\n      NAME: attributes.id,\n      AUDIO: 'audio',\n      SUBTITLES: 'subs',\n      RESOLUTION: {\n        width: attributes.width,\n        height: attributes.height\n      },\n      CODECS: attributes.codecs,\n      BANDWIDTH: attributes.bandwidth\n    }, _attributes3['PROGRAM-ID'] = 1, _attributes3),\n    uri: '',\n    endList: (attributes.type || 'static') === 'static',\n    timeline: attributes.periodIndex,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    segments: segments,\n    mediaSequence: segments.length ? segments[0].number : 1\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  return playlist;\n};\n\nvar toM3u8 = function toM3u8(dashPlaylists) {\n  var _mediaGroups;\n\n  if (!dashPlaylists.length) {\n    return {};\n  }\n\n  // grab all master attributes\n  var _dashPlaylists$0$attr = dashPlaylists[0].attributes,\n      duration = _dashPlaylists$0$attr.sourceDuration,\n      _dashPlaylists$0$attr2 = _dashPlaylists$0$attr.minimumUpdatePeriod,\n      minimumUpdatePeriod = _dashPlaylists$0$attr2 === undefined ? 0 : _dashPlaylists$0$attr2;\n\n\n  var videoOnly = function videoOnly(_ref4) {\n    var attributes = _ref4.attributes;\n    return attributes.mimeType === 'video/mp4' || attributes.contentType === 'video';\n  };\n  var audioOnly = function audioOnly(_ref5) {\n    var attributes = _ref5.attributes;\n    return attributes.mimeType === 'audio/mp4' || attributes.contentType === 'audio';\n  };\n  var vttOnly = function vttOnly(_ref6) {\n    var attributes = _ref6.attributes;\n    return attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n  };\n\n  var videoPlaylists = dashPlaylists.filter(videoOnly).map(formatVideoPlaylist);\n  var audioPlaylists = dashPlaylists.filter(audioOnly);\n  var vttPlaylists = dashPlaylists.filter(vttOnly);\n\n  var master = {\n    allowCache: true,\n    discontinuityStarts: [],\n    segments: [],\n    endList: true,\n    mediaGroups: (_mediaGroups = {\n      AUDIO: {},\n      VIDEO: {}\n    }, _mediaGroups['CLOSED-CAPTIONS'] = {}, _mediaGroups.SUBTITLES = {}, _mediaGroups),\n    uri: '',\n    duration: duration,\n    playlists: videoPlaylists,\n    minimumUpdatePeriod: minimumUpdatePeriod * 1000\n  };\n\n  if (audioPlaylists.length) {\n    master.mediaGroups.AUDIO.audio = organizeAudioPlaylists(audioPlaylists);\n  }\n\n  if (vttPlaylists.length) {\n    master.mediaGroups.SUBTITLES.subs = organizeVttPlaylists(vttPlaylists);\n  }\n\n  return master;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar isObject = function isObject(obj) {\n  return !!obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n};\n\nvar merge = function merge() {\n  for (var _len = arguments.length, objects = Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  return objects.reduce(function (result, source) {\n\n    Object.keys(source).forEach(function (key) {\n\n      if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n        result[key] = result[key].concat(source[key]);\n      } else if (isObject(result[key]) && isObject(source[key])) {\n        result[key] = merge(result[key], source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }, {});\n};\n\nvar resolveUrl = function resolveUrl(baseUrl, relativeUrl) {\n  // return early if we don't need to resolve\n  if (/^[a-z]+:/i.test(relativeUrl)) {\n    return relativeUrl;\n  }\n\n  // if the base URL is relative then combine with the current location\n  if (!/\\/\\//i.test(baseUrl)) {\n    baseUrl = url_toolkit__WEBPACK_IMPORTED_MODULE_0___default.a.buildAbsoluteURL(global_window__WEBPACK_IMPORTED_MODULE_1___default.a.location.href, baseUrl);\n  }\n\n  return url_toolkit__WEBPACK_IMPORTED_MODULE_0___default.a.buildAbsoluteURL(baseUrl, relativeUrl);\n};\n\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */\n\n/**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls, follows\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */\nvar urlTypeToSegment = function urlTypeToSegment(_ref) {\n  var _ref$baseUrl = _ref.baseUrl,\n      baseUrl = _ref$baseUrl === undefined ? '' : _ref$baseUrl,\n      _ref$source = _ref.source,\n      source = _ref$source === undefined ? '' : _ref$source,\n      _ref$range = _ref.range,\n      range = _ref$range === undefined ? '' : _ref$range;\n\n  var init = {\n    uri: source,\n    resolvedUri: resolveUrl(baseUrl || '', source)\n  };\n\n  if (range) {\n    var ranges = range.split('-');\n    var startRange = parseInt(ranges[0], 10);\n    var endRange = parseInt(ranges[1], 10);\n\n    init.byterange = {\n      length: endRange - startRange,\n      offset: startRange\n    };\n  }\n\n  return init;\n};\n\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */\nvar getLiveRValue = function getLiveRValue(attributes, time, duration) {\n  var NOW = attributes.NOW,\n      clientOffset = attributes.clientOffset,\n      availabilityStartTime = attributes.availabilityStartTime,\n      _attributes$timescale = attributes.timescale,\n      timescale = _attributes$timescale === undefined ? 1 : _attributes$timescale,\n      _attributes$start = attributes.start,\n      start = _attributes$start === undefined ? 0 : _attributes$start,\n      _attributes$minimumUp = attributes.minimumUpdatePeriod,\n      minimumUpdatePeriod = _attributes$minimumUp === undefined ? 0 : _attributes$minimumUp;\n\n  var now = (NOW + clientOffset) / 1000;\n  var periodStartWC = availabilityStartTime + start;\n  var periodEndWC = now + minimumUpdatePeriod;\n  var periodDuration = periodEndWC - periodStartWC;\n\n  return Math.ceil((periodDuration * timescale - time) / duration);\n};\n\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\nvar parseByTimeline = function parseByTimeline(attributes, segmentTimeline) {\n  var _attributes$type = attributes.type,\n      type = _attributes$type === undefined ? 'static' : _attributes$type,\n      _attributes$minimumUp2 = attributes.minimumUpdatePeriod,\n      minimumUpdatePeriod = _attributes$minimumUp2 === undefined ? 0 : _attributes$minimumUp2,\n      _attributes$media = attributes.media,\n      media = _attributes$media === undefined ? '' : _attributes$media,\n      sourceDuration = attributes.sourceDuration,\n      _attributes$timescale2 = attributes.timescale,\n      timescale = _attributes$timescale2 === undefined ? 1 : _attributes$timescale2,\n      _attributes$startNumb = attributes.startNumber,\n      startNumber = _attributes$startNumb === undefined ? 1 : _attributes$startNumb,\n      timeline = attributes.periodIndex;\n\n  var segments = [];\n  var time = -1;\n\n  for (var sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n    var S = segmentTimeline[sIndex];\n    var duration = S.d;\n    var repeat = S.r || 0;\n    var segmentTime = S.t || 0;\n\n    if (time < 0) {\n      // first segment\n      time = segmentTime;\n    }\n\n    if (segmentTime && segmentTime > time) {\n      // discontinuity\n\n      // TODO: How to handle this type of discontinuity\n      // timeline++ here would treat it like HLS discontuity and content would\n      // get appended without gap\n      // E.G.\n      //  <S t=\"0\" d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S t=\"5\" d=\"1\" />\n      // would have $Time$ values of [0, 1, 2, 5]\n      // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n      // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n      // does the value of sourceDuration consider this when calculating arbitrary\n      // negative @r repeat value?\n      // E.G. Same elements as above with this added at the end\n      //  <S d=\"1\" r=\"-1\" />\n      //  with a sourceDuration of 10\n      // Would the 2 gaps be included in the time duration calculations resulting in\n      // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n      // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n\n      time = segmentTime;\n    }\n\n    var count = void 0;\n\n    if (repeat < 0) {\n      var nextS = sIndex + 1;\n\n      if (nextS === segmentTimeline.length) {\n        // last segment\n        if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n          count = getLiveRValue(attributes, time, duration);\n        } else {\n          // TODO: This may be incorrect depending on conclusion of TODO above\n          count = (sourceDuration * timescale - time) / duration;\n        }\n      } else {\n        count = (segmentTimeline[nextS].t - time) / duration;\n      }\n    } else {\n      count = repeat + 1;\n    }\n\n    var end = startNumber + segments.length + count;\n    var number = startNumber + segments.length;\n\n    while (number < end) {\n      segments.push({ number: number, duration: duration / timescale, time: time, timeline: timeline });\n      time += duration;\n      number++;\n    }\n  }\n\n  return segments;\n};\n\nvar range = function range(start, end) {\n  var result = [];\n\n  for (var i = start; i < end; i++) {\n    result.push(i);\n  }\n\n  return result;\n};\n\nvar flatten = function flatten(lists) {\n  return lists.reduce(function (x, y) {\n    return x.concat(y);\n  }, []);\n};\n\nvar from = function from(list) {\n  if (!list.length) {\n    return [];\n  }\n\n  var result = [];\n\n  for (var i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n\n  return result;\n};\n\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */\nvar segmentRange = {\n  /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  'static': function _static(attributes) {\n    var duration = attributes.duration,\n        _attributes$timescale = attributes.timescale,\n        timescale = _attributes$timescale === undefined ? 1 : _attributes$timescale,\n        sourceDuration = attributes.sourceDuration;\n\n\n    return {\n      start: 0,\n      end: Math.ceil(sourceDuration / (duration / timescale))\n    };\n  },\n\n\n  /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  dynamic: function dynamic(attributes) {\n    var NOW = attributes.NOW,\n        clientOffset = attributes.clientOffset,\n        availabilityStartTime = attributes.availabilityStartTime,\n        _attributes$timescale2 = attributes.timescale,\n        timescale = _attributes$timescale2 === undefined ? 1 : _attributes$timescale2,\n        duration = attributes.duration,\n        _attributes$start = attributes.start,\n        start = _attributes$start === undefined ? 0 : _attributes$start,\n        _attributes$minimumUp = attributes.minimumUpdatePeriod,\n        minimumUpdatePeriod = _attributes$minimumUp === undefined ? 0 : _attributes$minimumUp,\n        _attributes$timeShift = attributes.timeShiftBufferDepth,\n        timeShiftBufferDepth = _attributes$timeShift === undefined ? Infinity : _attributes$timeShift;\n\n    var now = (NOW + clientOffset) / 1000;\n    var periodStartWC = availabilityStartTime + start;\n    var periodEndWC = now + minimumUpdatePeriod;\n    var periodDuration = periodEndWC - periodStartWC;\n    var segmentCount = Math.ceil(periodDuration * timescale / duration);\n    var availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n    var availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n\n    return {\n      start: Math.max(0, availableStart),\n      end: Math.min(segmentCount, availableEnd)\n    };\n  }\n};\n\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */\nvar toSegments = function toSegments(attributes) {\n  return function (number, index) {\n    var duration = attributes.duration,\n        _attributes$timescale3 = attributes.timescale,\n        timescale = _attributes$timescale3 === undefined ? 1 : _attributes$timescale3,\n        periodIndex = attributes.periodIndex,\n        _attributes$startNumb = attributes.startNumber,\n        startNumber = _attributes$startNumb === undefined ? 1 : _attributes$startNumb;\n\n\n    return {\n      number: startNumber + number,\n      duration: duration / timescale,\n      timeline: periodIndex,\n      time: index * duration\n    };\n  };\n};\n\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\nvar parseByDuration = function parseByDuration(attributes) {\n  var _attributes$type = attributes.type,\n      type = _attributes$type === undefined ? 'static' : _attributes$type,\n      duration = attributes.duration,\n      _attributes$timescale4 = attributes.timescale,\n      timescale = _attributes$timescale4 === undefined ? 1 : _attributes$timescale4,\n      sourceDuration = attributes.sourceDuration;\n\n  var _segmentRange$type = segmentRange[type](attributes),\n      start = _segmentRange$type.start,\n      end = _segmentRange$type.end;\n\n  var segments = range(start, end).map(toSegments(attributes));\n\n  if (type === 'static') {\n    var index = segments.length - 1;\n\n    // final segment may be less than full segment duration\n    segments[index].duration = sourceDuration - duration / timescale * index;\n  }\n\n  return segments;\n};\n\nvar identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */\n\n/**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */\nvar identifierReplacement = function identifierReplacement(values) {\n  return function (match, identifier, format, width) {\n    if (match === '$$') {\n      // escape sequence\n      return '$';\n    }\n\n    if (typeof values[identifier] === 'undefined') {\n      return match;\n    }\n\n    var value = '' + values[identifier];\n\n    if (identifier === 'RepresentationID') {\n      // Format tag shall not be present with RepresentationID\n      return value;\n    }\n\n    if (!format) {\n      width = 1;\n    } else {\n      width = parseInt(width, 10);\n    }\n\n    if (value.length >= width) {\n      return value;\n    }\n\n    return '' + new Array(width - value.length + 1).join('0') + value;\n  };\n};\n\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */\nvar constructTemplateUrl = function constructTemplateUrl(url, values) {\n  return url.replace(identifierPattern, identifierReplacement(values));\n};\n\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\nvar parseTemplateInfo = function parseTemplateInfo(attributes, segmentTimeline) {\n  if (!attributes.duration && !segmentTimeline) {\n    // if neither @duration or SegmentTimeline are present, then there shall be exactly\n    // one media segment\n    return [{\n      number: attributes.startNumber || 1,\n      duration: attributes.sourceDuration,\n      time: 0,\n      timeline: attributes.periodIndex\n    }];\n  }\n\n  if (attributes.duration) {\n    return parseByDuration(attributes);\n  }\n\n  return parseByTimeline(attributes, segmentTimeline);\n};\n\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */\nvar segmentsFromTemplate = function segmentsFromTemplate(attributes, segmentTimeline) {\n  var templateValues = {\n    RepresentationID: attributes.id,\n    Bandwidth: attributes.bandwidth || 0\n  };\n\n  var _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === undefined ? { sourceURL: '', range: '' } : _attributes$initializ;\n\n\n  var mapSegment = urlTypeToSegment({\n    baseUrl: attributes.baseUrl,\n    source: constructTemplateUrl(initialization.sourceURL, templateValues),\n    range: initialization.range\n  });\n\n  var segments = parseTemplateInfo(attributes, segmentTimeline);\n\n  return segments.map(function (segment) {\n    templateValues.Number = segment.number;\n    templateValues.Time = segment.time;\n\n    var uri = constructTemplateUrl(attributes.media || '', templateValues);\n\n    return {\n      uri: uri,\n      timeline: segment.timeline,\n      duration: segment.duration,\n      resolvedUri: resolveUrl(attributes.baseUrl || '', uri),\n      map: mapSegment,\n      number: segment.number\n    };\n  });\n};\n\nvar errors = {\n  INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n  DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n  DASH_INVALID_XML: 'DASH_INVALID_XML',\n  NO_BASE_URL: 'NO_BASE_URL',\n  MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n  SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n  UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n};\n\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */\nvar SegmentURLToSegmentObject = function SegmentURLToSegmentObject(attributes, segmentUrl) {\n  var baseUrl = attributes.baseUrl,\n      _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === undefined ? {} : _attributes$initializ;\n\n\n  var initSegment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n\n  var segment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: segmentUrl.media,\n    range: segmentUrl.mediaRange\n  });\n\n  segment.map = initSegment;\n\n  return segment;\n};\n\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */\nvar segmentsFromList = function segmentsFromList(attributes, segmentTimeline) {\n  var duration = attributes.duration,\n      _attributes$segmentUr = attributes.segmentUrls,\n      segmentUrls = _attributes$segmentUr === undefined ? [] : _attributes$segmentUr;\n\n  // Per spec (5.3.9.2.1) no way to determine segment duration OR\n  // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n  if (!duration && !segmentTimeline || duration && segmentTimeline) {\n    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n  }\n\n  var segmentUrlMap = segmentUrls.map(function (segmentUrlObject) {\n    return SegmentURLToSegmentObject(attributes, segmentUrlObject);\n  });\n  var segmentTimeInfo = void 0;\n\n  if (duration) {\n    segmentTimeInfo = parseByDuration(attributes);\n  }\n\n  if (segmentTimeline) {\n    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n  }\n\n  var segments = segmentTimeInfo.map(function (segmentTime, index) {\n    if (segmentUrlMap[index]) {\n      var segment = segmentUrlMap[index];\n\n      segment.timeline = segmentTime.timeline;\n      segment.duration = segmentTime.duration;\n      segment.number = segmentTime.number;\n      return segment;\n    }\n    // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n  }).filter(function (segment) {\n    return segment;\n  });\n\n  return segments;\n};\n\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */\nvar segmentsFromBase = function segmentsFromBase(attributes) {\n  var baseUrl = attributes.baseUrl,\n      _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === undefined ? {} : _attributes$initializ,\n      sourceDuration = attributes.sourceDuration,\n      _attributes$timescale = attributes.timescale,\n      timescale = _attributes$timescale === undefined ? 1 : _attributes$timescale,\n      _attributes$indexRang = attributes.indexRange,\n      indexRange = _attributes$indexRang === undefined ? '' : _attributes$indexRang,\n      duration = attributes.duration;\n\n  // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n  if (!baseUrl) {\n    throw new Error(errors.NO_BASE_URL);\n  }\n\n  var initSegment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  var segment = urlTypeToSegment({ baseUrl: baseUrl, source: baseUrl, range: indexRange });\n\n  segment.map = initSegment;\n\n  // If there is a duration, use it, otherwise use the given duration of the source\n  // (since SegmentBase is only for one total segment)\n  if (duration) {\n    var segmentTimeInfo = parseByDuration(attributes);\n\n    if (segmentTimeInfo.length) {\n      segment.duration = segmentTimeInfo[0].duration;\n      segment.timeline = segmentTimeInfo[0].timeline;\n    }\n  } else if (sourceDuration) {\n    segment.duration = sourceDuration / timescale;\n    segment.timeline = 0;\n  }\n\n  // This is used for mediaSequence\n  segment.number = 0;\n\n  return [segment];\n};\n\nvar generateSegments = function generateSegments(_ref) {\n  var attributes = _ref.attributes,\n      segmentInfo = _ref.segmentInfo;\n\n  var segmentAttributes = void 0;\n  var segmentsFn = void 0;\n\n  if (segmentInfo.template) {\n    segmentsFn = segmentsFromTemplate;\n    segmentAttributes = merge(attributes, segmentInfo.template);\n  } else if (segmentInfo.base) {\n    segmentsFn = segmentsFromBase;\n    segmentAttributes = merge(attributes, segmentInfo.base);\n  } else if (segmentInfo.list) {\n    segmentsFn = segmentsFromList;\n    segmentAttributes = merge(attributes, segmentInfo.list);\n  }\n\n  if (!segmentsFn) {\n    return { attributes: attributes };\n  }\n\n  var segments = segmentsFn(segmentAttributes, segmentInfo.timeline);\n\n  // The @duration attribute will be used to determin the playlist's targetDuration which\n  // must be in seconds. Since we've generated the segment list, we no longer need\n  // @duration to be in @timescale units, so we can convert it here.\n  if (segmentAttributes.duration) {\n    var _segmentAttributes = segmentAttributes,\n        duration = _segmentAttributes.duration,\n        _segmentAttributes$ti = _segmentAttributes.timescale,\n        timescale = _segmentAttributes$ti === undefined ? 1 : _segmentAttributes$ti;\n\n\n    segmentAttributes.duration = duration / timescale;\n  } else if (segments.length) {\n    // if there is no @duration attribute, use the largest segment duration as\n    // as target duration\n    segmentAttributes.duration = segments.reduce(function (max, segment) {\n      return Math.max(max, Math.ceil(segment.duration));\n    }, 0);\n  } else {\n    segmentAttributes.duration = 0;\n  }\n\n  return {\n    attributes: segmentAttributes,\n    segments: segments\n  };\n};\n\nvar toPlaylists = function toPlaylists(representations) {\n  return representations.map(generateSegments);\n};\n\nvar findChildren = function findChildren(element, name) {\n  return from(element.childNodes).filter(function (_ref) {\n    var tagName = _ref.tagName;\n    return tagName === name;\n  });\n};\n\nvar getContent = function getContent(element) {\n  return element.textContent.trim();\n};\n\nvar parseDuration = function parseDuration(str) {\n  var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n  var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n  var SECONDS_IN_DAY = 24 * 60 * 60;\n  var SECONDS_IN_HOUR = 60 * 60;\n  var SECONDS_IN_MIN = 60;\n\n  // P10Y10M10DT10H10M10.1S\n  var durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n  var match = durationRegex.exec(str);\n\n  if (!match) {\n    return 0;\n  }\n\n  var _match$slice = match.slice(1),\n      year = _match$slice[0],\n      month = _match$slice[1],\n      day = _match$slice[2],\n      hour = _match$slice[3],\n      minute = _match$slice[4],\n      second = _match$slice[5];\n\n  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\n\nvar parseDate = function parseDate(str) {\n  // Date format without timezone according to ISO 8601\n  // YYY-MM-DDThh:mm:ss.ssssss\n  var dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/;\n\n  // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n  // expressed by ending with 'Z'\n  if (dateRegex.test(str)) {\n    str += 'Z';\n  }\n\n  return Date.parse(str);\n};\n\n// TODO: maybe order these in some way that makes it easy to find specific attributes\nvar parsers = {\n  /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  mediaPresentationDuration: function mediaPresentationDuration(value) {\n    return parseDuration(value);\n  },\n\n\n  /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */\n  availabilityStartTime: function availabilityStartTime(value) {\n    return parseDate(value) / 1000;\n  },\n\n\n  /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  minimumUpdatePeriod: function minimumUpdatePeriod(value) {\n    return parseDuration(value);\n  },\n\n\n  /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  timeShiftBufferDepth: function timeShiftBufferDepth(value) {\n    return parseDuration(value);\n  },\n\n\n  /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  start: function start(value) {\n    return parseDuration(value);\n  },\n\n\n  /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */\n  width: function width(value) {\n    return parseInt(value, 10);\n  },\n\n\n  /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */\n  height: function height(value) {\n    return parseInt(value, 10);\n  },\n\n\n  /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */\n  bandwidth: function bandwidth(value) {\n    return parseInt(value, 10);\n  },\n\n\n  /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  startNumber: function startNumber(value) {\n    return parseInt(value, 10);\n  },\n\n\n  /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The aprsed timescale\n   */\n  timescale: function timescale(value) {\n    return parseInt(value, 10);\n  },\n\n\n  /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  duration: function duration(value) {\n    var parsedValue = parseInt(value, 10);\n\n    if (isNaN(parsedValue)) {\n      return parseDuration(value);\n    }\n\n    return parsedValue;\n  },\n\n\n  /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  d: function d(value) {\n    return parseInt(value, 10);\n  },\n\n\n  /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */\n  t: function t(value) {\n    return parseInt(value, 10);\n  },\n\n\n  /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  r: function r(value) {\n    return parseInt(value, 10);\n  },\n\n\n  /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */\n  DEFAULT: function DEFAULT(value) {\n    return value;\n  }\n};\n\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */\nvar parseAttributes = function parseAttributes(el) {\n  if (!(el && el.attributes)) {\n    return {};\n  }\n\n  return from(el.attributes).reduce(function (a, e) {\n    var parseFn = parsers[e.name] || parsers.DEFAULT;\n\n    a[e.name] = parseFn(e.value);\n\n    return a;\n  }, {});\n};\n\nfunction decodeB64ToUint8Array(b64Text) {\n  var decodedString = global_window__WEBPACK_IMPORTED_MODULE_1___default.a.atob(b64Text);\n  var array = new Uint8Array(decodedString.length);\n\n  for (var i = 0; i < decodedString.length; i++) {\n    array[i] = decodedString.charCodeAt(i);\n  }\n  return array;\n}\n\nvar keySystemsMap = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\n};\n\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {string[]} referenceUrls\n *        List of reference urls to resolve to\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {string[]}\n *         List of resolved urls\n */\nvar buildBaseUrls = function buildBaseUrls(referenceUrls, baseUrlElements) {\n  if (!baseUrlElements.length) {\n    return referenceUrls;\n  }\n\n  return flatten(referenceUrls.map(function (reference) {\n    return baseUrlElements.map(function (baseUrlElement) {\n      return resolveUrl(reference, getContent(baseUrlElement));\n    });\n  }));\n};\n\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} timeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */\n\n/**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */\nvar getSegmentInformation = function getSegmentInformation(adaptationSet) {\n  var segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n  var segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n  var segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(function (s) {\n    return merge({ tag: 'SegmentURL' }, parseAttributes(s));\n  });\n  var segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n  var segmentTimelineParentNode = segmentList || segmentTemplate;\n  var segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n  var segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n  var segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0];\n\n  // SegmentTemplate is handled slightly differently, since it can have both\n  // @initialization and an <Initialization> node.  @initialization can be templated,\n  // while the node can have a url and range specified.  If the <SegmentTemplate> has\n  // both @initialization and an <Initialization> subelement we opt to override with\n  // the node, as this interaction is not defined in the spec.\n  var template = segmentTemplate && parseAttributes(segmentTemplate);\n\n  if (template && segmentInitialization) {\n    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n  } else if (template && template.initialization) {\n    // If it is @initialization we convert it to an object since this is the format that\n    // later functions will rely on for the initialization segment.  This is only valid\n    // for <SegmentTemplate>\n    template.initialization = { sourceURL: template.initialization };\n  }\n\n  var segmentInfo = {\n    template: template,\n    timeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(function (s) {\n      return parseAttributes(s);\n    }),\n    list: segmentList && merge(parseAttributes(segmentList), {\n      segmentUrls: segmentUrls,\n      initialization: parseAttributes(segmentInitialization)\n    }),\n    base: segmentBase && merge(parseAttributes(segmentBase), {\n      initialization: parseAttributes(segmentInitialization)\n    })\n  };\n\n  Object.keys(segmentInfo).forEach(function (key) {\n    if (!segmentInfo[key]) {\n      delete segmentInfo[key];\n    }\n  });\n\n  return segmentInfo;\n};\n\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */\n\n/**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {string[]} adaptationSetBaseUrls\n *        Contains list of resolved base urls inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */\nvar inheritBaseUrls = function inheritBaseUrls(adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) {\n  return function (representation) {\n    var repBaseUrlElements = findChildren(representation, 'BaseURL');\n    var repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n    var attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n    var representationSegmentInfo = getSegmentInformation(representation);\n\n    return repBaseUrls.map(function (baseUrl) {\n      return {\n        segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n        attributes: merge(attributes, { baseUrl: baseUrl })\n      };\n    });\n  };\n};\n\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */\nvar generateKeySystemInformation = function generateKeySystemInformation(contentProtectionNodes) {\n  return contentProtectionNodes.reduce(function (acc, node) {\n    var attributes = parseAttributes(node);\n    var keySystem = keySystemsMap[attributes.schemeIdUri];\n\n    if (keySystem) {\n      acc[keySystem] = { attributes: attributes };\n\n      var psshNode = findChildren(node, 'cenc:pssh')[0];\n\n      if (psshNode) {\n        var pssh = getContent(psshNode);\n        var psshBuffer = pssh && decodeB64ToUint8Array(pssh);\n\n        acc[keySystem].pssh = psshBuffer;\n      }\n    }\n\n    return acc;\n  }, {});\n};\n\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {string[]} periodBaseUrls\n *        Contains list of resolved base urls inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */\nvar toRepresentations = function toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo) {\n  return function (adaptationSet) {\n    var adaptationSetAttributes = parseAttributes(adaptationSet);\n    var adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n    var role = findChildren(adaptationSet, 'Role')[0];\n    var roleAttributes = { role: parseAttributes(role) };\n\n    var attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n\n    var contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n\n    if (Object.keys(contentProtection).length) {\n      attrs = merge(attrs, { contentProtection: contentProtection });\n    }\n\n    var segmentInfo = getSegmentInformation(adaptationSet);\n    var representations = findChildren(adaptationSet, 'Representation');\n    var adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n\n    return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n  };\n};\n\n/**\n * Maps an Period node to a list of Representation inforamtion objects for all\n * AdaptationSet nodes contained within the Period\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {Node} period\n *        Period node from the mpd\n * @param {number} periodIndex\n *        Index of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n * @param {string[]} mpdBaseUrls\n *        Contains list of resolved base urls inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */\nvar toAdaptationSets = function toAdaptationSets(mpdAttributes, mpdBaseUrls) {\n  return function (period, periodIndex) {\n    var periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period, 'BaseURL'));\n    var periodAtt = parseAttributes(period);\n    var periodAttributes = merge(mpdAttributes, periodAtt, { periodIndex: periodIndex });\n    var adaptationSets = findChildren(period, 'AdaptationSet');\n    var periodSegmentInfo = getSegmentInformation(period);\n\n    return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n  };\n};\n\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */\nvar inheritAttributes = function inheritAttributes(mpd) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$manifestUri = options.manifestUri,\n      manifestUri = _options$manifestUri === undefined ? '' : _options$manifestUri,\n      _options$NOW = options.NOW,\n      NOW = _options$NOW === undefined ? Date.now() : _options$NOW,\n      _options$clientOffset = options.clientOffset,\n      clientOffset = _options$clientOffset === undefined ? 0 : _options$clientOffset;\n\n  var periods = findChildren(mpd, 'Period');\n\n  if (periods.length !== 1) {\n    // TODO add support for multiperiod\n    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n  }\n\n  var mpdAttributes = parseAttributes(mpd);\n  var mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, 'BaseURL'));\n\n  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n  mpdAttributes.NOW = NOW;\n  mpdAttributes.clientOffset = clientOffset;\n\n  return flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)));\n};\n\nvar stringToMpdXml = function stringToMpdXml(manifestString) {\n  if (manifestString === '') {\n    throw new Error(errors.DASH_EMPTY_MANIFEST);\n  }\n\n  var parser = new global_window__WEBPACK_IMPORTED_MODULE_1___default.a.DOMParser();\n  var xml = parser.parseFromString(manifestString, 'application/xml');\n  var mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n\n  if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n    throw new Error(errors.DASH_INVALID_XML);\n  }\n\n  return mpd;\n};\n\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\nvar parseUTCTimingScheme = function parseUTCTimingScheme(mpd) {\n  var UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n\n  if (!UTCTimingNode) {\n    return null;\n  }\n\n  var attributes = parseAttributes(UTCTimingNode);\n\n  switch (attributes.schemeIdUri) {\n    case 'urn:mpeg:dash:utc:http-head:2014':\n    case 'urn:mpeg:dash:utc:http-head:2012':\n      attributes.method = 'HEAD';\n      break;\n    case 'urn:mpeg:dash:utc:http-xsdate:2014':\n    case 'urn:mpeg:dash:utc:http-iso:2014':\n    case 'urn:mpeg:dash:utc:http-xsdate:2012':\n    case 'urn:mpeg:dash:utc:http-iso:2012':\n      attributes.method = 'GET';\n      break;\n    case 'urn:mpeg:dash:utc:direct:2014':\n    case 'urn:mpeg:dash:utc:direct:2012':\n      attributes.method = 'DIRECT';\n      attributes.value = Date.parse(attributes.value);\n      break;\n    case 'urn:mpeg:dash:utc:http-ntp:2014':\n    case 'urn:mpeg:dash:utc:ntp:2014':\n    case 'urn:mpeg:dash:utc:sntp:2014':\n    default:\n      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n  }\n\n  return attributes;\n};\n\nvar VERSION = version;\n\nvar parse = function parse(manifestString, options) {\n  return toM3u8(toPlaylists(inheritAttributes(stringToMpdXml(manifestString), options)));\n};\n\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\nvar parseUTCTiming = function parseUTCTiming(manifestString) {\n  return parseUTCTimingScheme(stringToMpdXml(manifestString));\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXBkLXBhcnNlci9kaXN0L21wZC1wYXJzZXIuZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXBkLXBhcnNlci9kaXN0L21wZC1wYXJzZXIuZXMuanM/ODQ4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG1wZC1wYXJzZXJcbiAqIEB2ZXJzaW9uIDAuNi4xXG4gKiBAY29weXJpZ2h0IDIwMTggQnJpZ2h0Y292ZSwgSW5jXG4gKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4gKi9cbmltcG9ydCBVUkxUb29sa2l0IGZyb20gJ3VybC10b29sa2l0JztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5cbnZhciB2ZXJzaW9uID0gXCIwLjYuMVwiO1xuXG52YXIgZm9ybWF0QXVkaW9QbGF5bGlzdCA9IGZ1bmN0aW9uIGZvcm1hdEF1ZGlvUGxheWxpc3QoX3JlZikge1xuICB2YXIgX2F0dHJpYnV0ZXM7XG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSBfcmVmLmF0dHJpYnV0ZXMsXG4gICAgICBzZWdtZW50cyA9IF9yZWYuc2VnbWVudHM7XG5cbiAgdmFyIHBsYXlsaXN0ID0ge1xuICAgIGF0dHJpYnV0ZXM6IChfYXR0cmlidXRlcyA9IHtcbiAgICAgIE5BTUU6IGF0dHJpYnV0ZXMuaWQsXG4gICAgICBCQU5EV0lEVEg6IGF0dHJpYnV0ZXMuYmFuZHdpZHRoLFxuICAgICAgQ09ERUNTOiBhdHRyaWJ1dGVzLmNvZGVjc1xuICAgIH0sIF9hdHRyaWJ1dGVzWydQUk9HUkFNLUlEJ10gPSAxLCBfYXR0cmlidXRlcyksXG4gICAgdXJpOiAnJyxcbiAgICBlbmRMaXN0OiAoYXR0cmlidXRlcy50eXBlIHx8ICdzdGF0aWMnKSA9PT0gJ3N0YXRpYycsXG4gICAgdGltZWxpbmU6IGF0dHJpYnV0ZXMucGVyaW9kSW5kZXgsXG4gICAgcmVzb2x2ZWRVcmk6ICcnLFxuICAgIHRhcmdldER1cmF0aW9uOiBhdHRyaWJ1dGVzLmR1cmF0aW9uLFxuICAgIHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICBtZWRpYVNlcXVlbmNlOiBzZWdtZW50cy5sZW5ndGggPyBzZWdtZW50c1swXS5udW1iZXIgOiAxXG4gIH07XG5cbiAgaWYgKGF0dHJpYnV0ZXMuY29udGVudFByb3RlY3Rpb24pIHtcbiAgICBwbGF5bGlzdC5jb250ZW50UHJvdGVjdGlvbiA9IGF0dHJpYnV0ZXMuY29udGVudFByb3RlY3Rpb247XG4gIH1cblxuICByZXR1cm4gcGxheWxpc3Q7XG59O1xuXG52YXIgZm9ybWF0VnR0UGxheWxpc3QgPSBmdW5jdGlvbiBmb3JtYXRWdHRQbGF5bGlzdChfcmVmMikge1xuICB2YXIgX2F0dHJpYnV0ZXMyO1xuXG4gIHZhciBhdHRyaWJ1dGVzID0gX3JlZjIuYXR0cmlidXRlcyxcbiAgICAgIHNlZ21lbnRzID0gX3JlZjIuc2VnbWVudHM7XG5cbiAgaWYgKHR5cGVvZiBzZWdtZW50cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyB2dHQgdHJhY2tzIG1heSB1c2Ugc2luZ2xlIGZpbGUgaW4gQmFzZVVSTFxuICAgIHNlZ21lbnRzID0gW3tcbiAgICAgIHVyaTogYXR0cmlidXRlcy5iYXNlVXJsLFxuICAgICAgdGltZWxpbmU6IGF0dHJpYnV0ZXMucGVyaW9kSW5kZXgsXG4gICAgICByZXNvbHZlZFVyaTogYXR0cmlidXRlcy5iYXNlVXJsIHx8ICcnLFxuICAgICAgZHVyYXRpb246IGF0dHJpYnV0ZXMuc291cmNlRHVyYXRpb24sXG4gICAgICBudW1iZXI6IDBcbiAgICB9XTtcbiAgICAvLyB0YXJnZXREdXJhdGlvbiBzaG91bGQgYmUgdGhlIHNhbWUgZHVyYXRpb24gYXMgdGhlIG9ubHkgc2VnbWVudFxuICAgIGF0dHJpYnV0ZXMuZHVyYXRpb24gPSBhdHRyaWJ1dGVzLnNvdXJjZUR1cmF0aW9uO1xuICB9XG4gIHJldHVybiB7XG4gICAgYXR0cmlidXRlczogKF9hdHRyaWJ1dGVzMiA9IHtcbiAgICAgIE5BTUU6IGF0dHJpYnV0ZXMuaWQsXG4gICAgICBCQU5EV0lEVEg6IGF0dHJpYnV0ZXMuYmFuZHdpZHRoXG4gICAgfSwgX2F0dHJpYnV0ZXMyWydQUk9HUkFNLUlEJ10gPSAxLCBfYXR0cmlidXRlczIpLFxuICAgIHVyaTogJycsXG4gICAgZW5kTGlzdDogKGF0dHJpYnV0ZXMudHlwZSB8fCAnc3RhdGljJykgPT09ICdzdGF0aWMnLFxuICAgIHRpbWVsaW5lOiBhdHRyaWJ1dGVzLnBlcmlvZEluZGV4LFxuICAgIHJlc29sdmVkVXJpOiBhdHRyaWJ1dGVzLmJhc2VVcmwgfHwgJycsXG4gICAgdGFyZ2V0RHVyYXRpb246IGF0dHJpYnV0ZXMuZHVyYXRpb24sXG4gICAgc2VnbWVudHM6IHNlZ21lbnRzLFxuICAgIG1lZGlhU2VxdWVuY2U6IHNlZ21lbnRzLmxlbmd0aCA/IHNlZ21lbnRzWzBdLm51bWJlciA6IDFcbiAgfTtcbn07XG5cbnZhciBvcmdhbml6ZUF1ZGlvUGxheWxpc3RzID0gZnVuY3Rpb24gb3JnYW5pemVBdWRpb1BsYXlsaXN0cyhwbGF5bGlzdHMpIHtcbiAgcmV0dXJuIHBsYXlsaXN0cy5yZWR1Y2UoZnVuY3Rpb24gKGEsIHBsYXlsaXN0KSB7XG4gICAgdmFyIHJvbGUgPSBwbGF5bGlzdC5hdHRyaWJ1dGVzLnJvbGUgJiYgcGxheWxpc3QuYXR0cmlidXRlcy5yb2xlLnZhbHVlIHx8ICdtYWluJztcbiAgICB2YXIgbGFuZ3VhZ2UgPSBwbGF5bGlzdC5hdHRyaWJ1dGVzLmxhbmcgfHwgJyc7XG5cbiAgICB2YXIgbGFiZWwgPSAnbWFpbic7XG5cbiAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgIGxhYmVsID0gcGxheWxpc3QuYXR0cmlidXRlcy5sYW5nICsgJyAoJyArIHJvbGUgKyAnKSc7XG4gICAgfVxuXG4gICAgLy8gc2tpcCBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIGhpZ2hlc3QgcXVhbGl0eSBhdWRpbyBmb3IgYSBsYW5ndWFnZVxuICAgIGlmIChhW2xhYmVsXSAmJiBhW2xhYmVsXS5wbGF5bGlzdHNbMF0uYXR0cmlidXRlcy5CQU5EV0lEVEggPiBwbGF5bGlzdC5hdHRyaWJ1dGVzLmJhbmR3aWR0aCkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgYVtsYWJlbF0gPSB7XG4gICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICBhdXRvc2VsZWN0OiB0cnVlLFxuICAgICAgJ2RlZmF1bHQnOiByb2xlID09PSAnbWFpbicsXG4gICAgICBwbGF5bGlzdHM6IFtmb3JtYXRBdWRpb1BsYXlsaXN0KHBsYXlsaXN0KV0sXG4gICAgICB1cmk6ICcnXG4gICAgfTtcblxuICAgIHJldHVybiBhO1xuICB9LCB7fSk7XG59O1xuXG52YXIgb3JnYW5pemVWdHRQbGF5bGlzdHMgPSBmdW5jdGlvbiBvcmdhbml6ZVZ0dFBsYXlsaXN0cyhwbGF5bGlzdHMpIHtcbiAgcmV0dXJuIHBsYXlsaXN0cy5yZWR1Y2UoZnVuY3Rpb24gKGEsIHBsYXlsaXN0KSB7XG4gICAgdmFyIGxhYmVsID0gcGxheWxpc3QuYXR0cmlidXRlcy5sYW5nIHx8ICd0ZXh0JztcblxuICAgIC8vIHNraXAgaWYgd2UgYWxyZWFkeSBoYXZlIHN1YnRpdGxlc1xuICAgIGlmIChhW2xhYmVsXSkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgYVtsYWJlbF0gPSB7XG4gICAgICBsYW5ndWFnZTogbGFiZWwsXG4gICAgICAnZGVmYXVsdCc6IGZhbHNlLFxuICAgICAgYXV0b3NlbGVjdDogZmFsc2UsXG4gICAgICBwbGF5bGlzdHM6IFtmb3JtYXRWdHRQbGF5bGlzdChwbGF5bGlzdCldLFxuICAgICAgdXJpOiAnJ1xuICAgIH07XG5cbiAgICByZXR1cm4gYTtcbiAgfSwge30pO1xufTtcblxudmFyIGZvcm1hdFZpZGVvUGxheWxpc3QgPSBmdW5jdGlvbiBmb3JtYXRWaWRlb1BsYXlsaXN0KF9yZWYzKSB7XG4gIHZhciBfYXR0cmlidXRlczM7XG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSBfcmVmMy5hdHRyaWJ1dGVzLFxuICAgICAgc2VnbWVudHMgPSBfcmVmMy5zZWdtZW50cztcblxuICB2YXIgcGxheWxpc3QgPSB7XG4gICAgYXR0cmlidXRlczogKF9hdHRyaWJ1dGVzMyA9IHtcbiAgICAgIE5BTUU6IGF0dHJpYnV0ZXMuaWQsXG4gICAgICBBVURJTzogJ2F1ZGlvJyxcbiAgICAgIFNVQlRJVExFUzogJ3N1YnMnLFxuICAgICAgUkVTT0xVVElPTjoge1xuICAgICAgICB3aWR0aDogYXR0cmlidXRlcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBhdHRyaWJ1dGVzLmhlaWdodFxuICAgICAgfSxcbiAgICAgIENPREVDUzogYXR0cmlidXRlcy5jb2RlY3MsXG4gICAgICBCQU5EV0lEVEg6IGF0dHJpYnV0ZXMuYmFuZHdpZHRoXG4gICAgfSwgX2F0dHJpYnV0ZXMzWydQUk9HUkFNLUlEJ10gPSAxLCBfYXR0cmlidXRlczMpLFxuICAgIHVyaTogJycsXG4gICAgZW5kTGlzdDogKGF0dHJpYnV0ZXMudHlwZSB8fCAnc3RhdGljJykgPT09ICdzdGF0aWMnLFxuICAgIHRpbWVsaW5lOiBhdHRyaWJ1dGVzLnBlcmlvZEluZGV4LFxuICAgIHJlc29sdmVkVXJpOiAnJyxcbiAgICB0YXJnZXREdXJhdGlvbjogYXR0cmlidXRlcy5kdXJhdGlvbixcbiAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgbWVkaWFTZXF1ZW5jZTogc2VnbWVudHMubGVuZ3RoID8gc2VnbWVudHNbMF0ubnVtYmVyIDogMVxuICB9O1xuXG4gIGlmIChhdHRyaWJ1dGVzLmNvbnRlbnRQcm90ZWN0aW9uKSB7XG4gICAgcGxheWxpc3QuY29udGVudFByb3RlY3Rpb24gPSBhdHRyaWJ1dGVzLmNvbnRlbnRQcm90ZWN0aW9uO1xuICB9XG5cbiAgcmV0dXJuIHBsYXlsaXN0O1xufTtcblxudmFyIHRvTTN1OCA9IGZ1bmN0aW9uIHRvTTN1OChkYXNoUGxheWxpc3RzKSB7XG4gIHZhciBfbWVkaWFHcm91cHM7XG5cbiAgaWYgKCFkYXNoUGxheWxpc3RzLmxlbmd0aCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8vIGdyYWIgYWxsIG1hc3RlciBhdHRyaWJ1dGVzXG4gIHZhciBfZGFzaFBsYXlsaXN0cyQwJGF0dHIgPSBkYXNoUGxheWxpc3RzWzBdLmF0dHJpYnV0ZXMsXG4gICAgICBkdXJhdGlvbiA9IF9kYXNoUGxheWxpc3RzJDAkYXR0ci5zb3VyY2VEdXJhdGlvbixcbiAgICAgIF9kYXNoUGxheWxpc3RzJDAkYXR0cjIgPSBfZGFzaFBsYXlsaXN0cyQwJGF0dHIubWluaW11bVVwZGF0ZVBlcmlvZCxcbiAgICAgIG1pbmltdW1VcGRhdGVQZXJpb2QgPSBfZGFzaFBsYXlsaXN0cyQwJGF0dHIyID09PSB1bmRlZmluZWQgPyAwIDogX2Rhc2hQbGF5bGlzdHMkMCRhdHRyMjtcblxuXG4gIHZhciB2aWRlb09ubHkgPSBmdW5jdGlvbiB2aWRlb09ubHkoX3JlZjQpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IF9yZWY0LmF0dHJpYnV0ZXM7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXMubWltZVR5cGUgPT09ICd2aWRlby9tcDQnIHx8IGF0dHJpYnV0ZXMuY29udGVudFR5cGUgPT09ICd2aWRlbyc7XG4gIH07XG4gIHZhciBhdWRpb09ubHkgPSBmdW5jdGlvbiBhdWRpb09ubHkoX3JlZjUpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IF9yZWY1LmF0dHJpYnV0ZXM7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXMubWltZVR5cGUgPT09ICdhdWRpby9tcDQnIHx8IGF0dHJpYnV0ZXMuY29udGVudFR5cGUgPT09ICdhdWRpbyc7XG4gIH07XG4gIHZhciB2dHRPbmx5ID0gZnVuY3Rpb24gdnR0T25seShfcmVmNikge1xuICAgIHZhciBhdHRyaWJ1dGVzID0gX3JlZjYuYXR0cmlidXRlcztcbiAgICByZXR1cm4gYXR0cmlidXRlcy5taW1lVHlwZSA9PT0gJ3RleHQvdnR0JyB8fCBhdHRyaWJ1dGVzLmNvbnRlbnRUeXBlID09PSAndGV4dCc7XG4gIH07XG5cbiAgdmFyIHZpZGVvUGxheWxpc3RzID0gZGFzaFBsYXlsaXN0cy5maWx0ZXIodmlkZW9Pbmx5KS5tYXAoZm9ybWF0VmlkZW9QbGF5bGlzdCk7XG4gIHZhciBhdWRpb1BsYXlsaXN0cyA9IGRhc2hQbGF5bGlzdHMuZmlsdGVyKGF1ZGlvT25seSk7XG4gIHZhciB2dHRQbGF5bGlzdHMgPSBkYXNoUGxheWxpc3RzLmZpbHRlcih2dHRPbmx5KTtcblxuICB2YXIgbWFzdGVyID0ge1xuICAgIGFsbG93Q2FjaGU6IHRydWUsXG4gICAgZGlzY29udGludWl0eVN0YXJ0czogW10sXG4gICAgc2VnbWVudHM6IFtdLFxuICAgIGVuZExpc3Q6IHRydWUsXG4gICAgbWVkaWFHcm91cHM6IChfbWVkaWFHcm91cHMgPSB7XG4gICAgICBBVURJTzoge30sXG4gICAgICBWSURFTzoge31cbiAgICB9LCBfbWVkaWFHcm91cHNbJ0NMT1NFRC1DQVBUSU9OUyddID0ge30sIF9tZWRpYUdyb3Vwcy5TVUJUSVRMRVMgPSB7fSwgX21lZGlhR3JvdXBzKSxcbiAgICB1cmk6ICcnLFxuICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICBwbGF5bGlzdHM6IHZpZGVvUGxheWxpc3RzLFxuICAgIG1pbmltdW1VcGRhdGVQZXJpb2Q6IG1pbmltdW1VcGRhdGVQZXJpb2QgKiAxMDAwXG4gIH07XG5cbiAgaWYgKGF1ZGlvUGxheWxpc3RzLmxlbmd0aCkge1xuICAgIG1hc3Rlci5tZWRpYUdyb3Vwcy5BVURJTy5hdWRpbyA9IG9yZ2FuaXplQXVkaW9QbGF5bGlzdHMoYXVkaW9QbGF5bGlzdHMpO1xuICB9XG5cbiAgaWYgKHZ0dFBsYXlsaXN0cy5sZW5ndGgpIHtcbiAgICBtYXN0ZXIubWVkaWFHcm91cHMuU1VCVElUTEVTLnN1YnMgPSBvcmdhbml6ZVZ0dFBsYXlsaXN0cyh2dHRQbGF5bGlzdHMpO1xuICB9XG5cbiAgcmV0dXJuIG1hc3Rlcjtcbn07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuICEhb2JqICYmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSA9PT0gJ29iamVjdCc7XG59O1xuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG9iamVjdHMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBvYmplY3RzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdHMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHNvdXJjZSkge1xuXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W2tleV0pICYmIEFycmF5LmlzQXJyYXkoc291cmNlW2tleV0pKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gcmVzdWx0W2tleV0uY29uY2F0KHNvdXJjZVtrZXldKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocmVzdWx0W2tleV0pICYmIGlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbn07XG5cbnZhciByZXNvbHZlVXJsID0gZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlVXJsLCByZWxhdGl2ZVVybCkge1xuICAvLyByZXR1cm4gZWFybHkgaWYgd2UgZG9uJ3QgbmVlZCB0byByZXNvbHZlXG4gIGlmICgvXlthLXpdKzovaS50ZXN0KHJlbGF0aXZlVXJsKSkge1xuICAgIHJldHVybiByZWxhdGl2ZVVybDtcbiAgfVxuXG4gIC8vIGlmIHRoZSBiYXNlIFVSTCBpcyByZWxhdGl2ZSB0aGVuIGNvbWJpbmUgd2l0aCB0aGUgY3VycmVudCBsb2NhdGlvblxuICBpZiAoIS9cXC9cXC8vaS50ZXN0KGJhc2VVcmwpKSB7XG4gICAgYmFzZVVybCA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiwgYmFzZVVybCk7XG4gIH1cblxuICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlVVJMKGJhc2VVcmwsIHJlbGF0aXZlVXJsKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2luZ2xlVXJpXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXJpIC0gcmVsYXRpdmUgbG9jYXRpb24gb2Ygc2VnbWVudFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlc29sdmVkVXJpIC0gcmVzb2x2ZWQgbG9jYXRpb24gb2Ygc2VnbWVudFxuICogQHByb3BlcnR5IHtPYmplY3R9IGJ5dGVyYW5nZSAtIE9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIG9uIGhvdyB0byBtYWtlIGJ5dGUgcmFuZ2VcbiAqICAgcmVxdWVzdHMgZm9sbG93aW5nIGJ5dGUtcmFuZ2Utc3BlYyBwZXIgUkZDMjYxNi5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBieXRlcmFuZ2UubGVuZ3RoIC0gbGVuZ3RoIG9mIHJhbmdlIHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBieXRlcmFuZ2Uub2Zmc2V0IC0gYnl0ZSBvZmZzZXQgb2YgcmFuZ2UgcmVxdWVzdFxuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMTQuaHRtbCNzZWMxNC4zNS4xXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVSTFR5cGUgbm9kZSAoNS4zLjkuMi4zIFRhYmxlIDEzKSB0byBhIHNlZ21lbnQgb2JqZWN0XG4gKiB0aGF0IGNvbmZvcm1zIHRvIGhvdyBtM3U4LXBhcnNlciBpcyBzdHJ1Y3R1cmVkXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy9tM3U4LXBhcnNlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVXJsIC0gYmFzZVVybCBwcm92aWRlZCBieSA8QmFzZVVybD4gbm9kZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSBzb3VyY2UgdXJsIGZvciBzZWdtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcmFuZ2UgLSBvcHRpb25hbCByYW5nZSB1c2VkIGZvciByYW5nZSBjYWxscywgZm9sbG93c1xuICogQHJldHVybiB7U2luZ2xlVXJpfSBmdWxsIHNlZ21lbnQgaW5mb3JtYXRpb24gdHJhbnNmb3JtZWQgaW50byBhIGZvcm1hdCBzaW1pbGFyXG4gKiAgIHRvIG0zdTgtcGFyc2VyXG4gKi9cbnZhciB1cmxUeXBlVG9TZWdtZW50ID0gZnVuY3Rpb24gdXJsVHlwZVRvU2VnbWVudChfcmVmKSB7XG4gIHZhciBfcmVmJGJhc2VVcmwgPSBfcmVmLmJhc2VVcmwsXG4gICAgICBiYXNlVXJsID0gX3JlZiRiYXNlVXJsID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYkYmFzZVVybCxcbiAgICAgIF9yZWYkc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJHNvdXJjZSxcbiAgICAgIF9yZWYkcmFuZ2UgPSBfcmVmLnJhbmdlLFxuICAgICAgcmFuZ2UgPSBfcmVmJHJhbmdlID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYkcmFuZ2U7XG5cbiAgdmFyIGluaXQgPSB7XG4gICAgdXJpOiBzb3VyY2UsXG4gICAgcmVzb2x2ZWRVcmk6IHJlc29sdmVVcmwoYmFzZVVybCB8fCAnJywgc291cmNlKVxuICB9O1xuXG4gIGlmIChyYW5nZSkge1xuICAgIHZhciByYW5nZXMgPSByYW5nZS5zcGxpdCgnLScpO1xuICAgIHZhciBzdGFydFJhbmdlID0gcGFyc2VJbnQocmFuZ2VzWzBdLCAxMCk7XG4gICAgdmFyIGVuZFJhbmdlID0gcGFyc2VJbnQocmFuZ2VzWzFdLCAxMCk7XG5cbiAgICBpbml0LmJ5dGVyYW5nZSA9IHtcbiAgICAgIGxlbmd0aDogZW5kUmFuZ2UgLSBzdGFydFJhbmdlLFxuICAgICAgb2Zmc2V0OiBzdGFydFJhbmdlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBpbml0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBSIChyZXBldGl0aW9uKSB2YWx1ZSBmb3IgYSBsaXZlIHN0cmVhbSAoZm9yIHRoZSBmaW5hbCBzZWdtZW50XG4gKiBpbiBhIG1hbmlmZXN0IHdoZXJlIHRoZSByIHZhbHVlIGlzIG5lZ2F0aXZlIDEpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyBhbGwgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgd2l0aCBhdHRyaWJ1dGVcbiAqICAgICAgICBuYW1lcyBhcyBrZXlzXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZVxuICogICAgICAgIGN1cnJlbnQgdGltZSAodHlwaWNhbGx5IHRoZSB0b3RhbCB0aW1lIHVwIHVudGlsIHRoZSBmaW5hbCBzZWdtZW50KVxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG4gKiAgICAgICAgZHVyYXRpb24gcHJvcGVydHkgZm9yIHRoZSBnaXZlbiA8UyAvPlxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICBSIHZhbHVlIHRvIHJlYWNoIHRoZSBlbmQgb2YgdGhlIGdpdmVuIHBlcmlvZFxuICovXG52YXIgZ2V0TGl2ZVJWYWx1ZSA9IGZ1bmN0aW9uIGdldExpdmVSVmFsdWUoYXR0cmlidXRlcywgdGltZSwgZHVyYXRpb24pIHtcbiAgdmFyIE5PVyA9IGF0dHJpYnV0ZXMuTk9XLFxuICAgICAgY2xpZW50T2Zmc2V0ID0gYXR0cmlidXRlcy5jbGllbnRPZmZzZXQsXG4gICAgICBhdmFpbGFiaWxpdHlTdGFydFRpbWUgPSBhdHRyaWJ1dGVzLmF2YWlsYWJpbGl0eVN0YXJ0VGltZSxcbiAgICAgIF9hdHRyaWJ1dGVzJHRpbWVzY2FsZSA9IGF0dHJpYnV0ZXMudGltZXNjYWxlLFxuICAgICAgdGltZXNjYWxlID0gX2F0dHJpYnV0ZXMkdGltZXNjYWxlID09PSB1bmRlZmluZWQgPyAxIDogX2F0dHJpYnV0ZXMkdGltZXNjYWxlLFxuICAgICAgX2F0dHJpYnV0ZXMkc3RhcnQgPSBhdHRyaWJ1dGVzLnN0YXJ0LFxuICAgICAgc3RhcnQgPSBfYXR0cmlidXRlcyRzdGFydCA9PT0gdW5kZWZpbmVkID8gMCA6IF9hdHRyaWJ1dGVzJHN0YXJ0LFxuICAgICAgX2F0dHJpYnV0ZXMkbWluaW11bVVwID0gYXR0cmlidXRlcy5taW5pbXVtVXBkYXRlUGVyaW9kLFxuICAgICAgbWluaW11bVVwZGF0ZVBlcmlvZCA9IF9hdHRyaWJ1dGVzJG1pbmltdW1VcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9hdHRyaWJ1dGVzJG1pbmltdW1VcDtcblxuICB2YXIgbm93ID0gKE5PVyArIGNsaWVudE9mZnNldCkgLyAxMDAwO1xuICB2YXIgcGVyaW9kU3RhcnRXQyA9IGF2YWlsYWJpbGl0eVN0YXJ0VGltZSArIHN0YXJ0O1xuICB2YXIgcGVyaW9kRW5kV0MgPSBub3cgKyBtaW5pbXVtVXBkYXRlUGVyaW9kO1xuICB2YXIgcGVyaW9kRHVyYXRpb24gPSBwZXJpb2RFbmRXQyAtIHBlcmlvZFN0YXJ0V0M7XG5cbiAgcmV0dXJuIE1hdGguY2VpbCgocGVyaW9kRHVyYXRpb24gKiB0aW1lc2NhbGUgLSB0aW1lKSAvIGR1cmF0aW9uKTtcbn07XG5cbi8qKlxuICogVXNlcyBpbmZvcm1hdGlvbiBwcm92aWRlZCBieSBTZWdtZW50VGVtcGxhdGUuU2VnbWVudFRpbWVsaW5lIHRvIGRldGVybWluZSBzZWdtZW50XG4gKiB0aW1pbmcgYW5kIGR1cmF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyBhbGwgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgd2l0aCBhdHRyaWJ1dGVcbiAqICAgICAgICBuYW1lcyBhcyBrZXlzXG4gKiBAcGFyYW0ge09iamVjdFtdfSBzZWdtZW50VGltZWxpbmVcbiAqICAgICAgICBMaXN0IG9mIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBhdHRyaWJ1dGVzIG9mIGVhY2ggUyBlbGVtZW50IGNvbnRhaW5lZCB3aXRoaW5cbiAqXG4gKiBAcmV0dXJuIHt7bnVtYmVyOiBudW1iZXIsIGR1cmF0aW9uOiBudW1iZXIsIHRpbWU6IG51bWJlciwgdGltZWxpbmU6IG51bWJlcn1bXX1cbiAqICAgICAgICAgTGlzdCBvZiBPYmplY3RzIHdpdGggc2VnbWVudCB0aW1pbmcgYW5kIGR1cmF0aW9uIGluZm9cbiAqL1xudmFyIHBhcnNlQnlUaW1lbGluZSA9IGZ1bmN0aW9uIHBhcnNlQnlUaW1lbGluZShhdHRyaWJ1dGVzLCBzZWdtZW50VGltZWxpbmUpIHtcbiAgdmFyIF9hdHRyaWJ1dGVzJHR5cGUgPSBhdHRyaWJ1dGVzLnR5cGUsXG4gICAgICB0eXBlID0gX2F0dHJpYnV0ZXMkdHlwZSA9PT0gdW5kZWZpbmVkID8gJ3N0YXRpYycgOiBfYXR0cmlidXRlcyR0eXBlLFxuICAgICAgX2F0dHJpYnV0ZXMkbWluaW11bVVwMiA9IGF0dHJpYnV0ZXMubWluaW11bVVwZGF0ZVBlcmlvZCxcbiAgICAgIG1pbmltdW1VcGRhdGVQZXJpb2QgPSBfYXR0cmlidXRlcyRtaW5pbXVtVXAyID09PSB1bmRlZmluZWQgPyAwIDogX2F0dHJpYnV0ZXMkbWluaW11bVVwMixcbiAgICAgIF9hdHRyaWJ1dGVzJG1lZGlhID0gYXR0cmlidXRlcy5tZWRpYSxcbiAgICAgIG1lZGlhID0gX2F0dHJpYnV0ZXMkbWVkaWEgPT09IHVuZGVmaW5lZCA/ICcnIDogX2F0dHJpYnV0ZXMkbWVkaWEsXG4gICAgICBzb3VyY2VEdXJhdGlvbiA9IGF0dHJpYnV0ZXMuc291cmNlRHVyYXRpb24sXG4gICAgICBfYXR0cmlidXRlcyR0aW1lc2NhbGUyID0gYXR0cmlidXRlcy50aW1lc2NhbGUsXG4gICAgICB0aW1lc2NhbGUgPSBfYXR0cmlidXRlcyR0aW1lc2NhbGUyID09PSB1bmRlZmluZWQgPyAxIDogX2F0dHJpYnV0ZXMkdGltZXNjYWxlMixcbiAgICAgIF9hdHRyaWJ1dGVzJHN0YXJ0TnVtYiA9IGF0dHJpYnV0ZXMuc3RhcnROdW1iZXIsXG4gICAgICBzdGFydE51bWJlciA9IF9hdHRyaWJ1dGVzJHN0YXJ0TnVtYiA9PT0gdW5kZWZpbmVkID8gMSA6IF9hdHRyaWJ1dGVzJHN0YXJ0TnVtYixcbiAgICAgIHRpbWVsaW5lID0gYXR0cmlidXRlcy5wZXJpb2RJbmRleDtcblxuICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgdmFyIHRpbWUgPSAtMTtcblxuICBmb3IgKHZhciBzSW5kZXggPSAwOyBzSW5kZXggPCBzZWdtZW50VGltZWxpbmUubGVuZ3RoOyBzSW5kZXgrKykge1xuICAgIHZhciBTID0gc2VnbWVudFRpbWVsaW5lW3NJbmRleF07XG4gICAgdmFyIGR1cmF0aW9uID0gUy5kO1xuICAgIHZhciByZXBlYXQgPSBTLnIgfHwgMDtcbiAgICB2YXIgc2VnbWVudFRpbWUgPSBTLnQgfHwgMDtcblxuICAgIGlmICh0aW1lIDwgMCkge1xuICAgICAgLy8gZmlyc3Qgc2VnbWVudFxuICAgICAgdGltZSA9IHNlZ21lbnRUaW1lO1xuICAgIH1cblxuICAgIGlmIChzZWdtZW50VGltZSAmJiBzZWdtZW50VGltZSA+IHRpbWUpIHtcbiAgICAgIC8vIGRpc2NvbnRpbnVpdHlcblxuICAgICAgLy8gVE9ETzogSG93IHRvIGhhbmRsZSB0aGlzIHR5cGUgb2YgZGlzY29udGludWl0eVxuICAgICAgLy8gdGltZWxpbmUrKyBoZXJlIHdvdWxkIHRyZWF0IGl0IGxpa2UgSExTIGRpc2NvbnR1aXR5IGFuZCBjb250ZW50IHdvdWxkXG4gICAgICAvLyBnZXQgYXBwZW5kZWQgd2l0aG91dCBnYXBcbiAgICAgIC8vIEUuRy5cbiAgICAgIC8vICA8UyB0PVwiMFwiIGQ9XCIxXCIgLz5cbiAgICAgIC8vICA8UyBkPVwiMVwiIC8+XG4gICAgICAvLyAgPFMgZD1cIjFcIiAvPlxuICAgICAgLy8gIDxTIHQ9XCI1XCIgZD1cIjFcIiAvPlxuICAgICAgLy8gd291bGQgaGF2ZSAkVGltZSQgdmFsdWVzIG9mIFswLCAxLCAyLCA1XVxuICAgICAgLy8gc2hvdWxkIHRoaXMgYmUgYXBwZW5lZCBhdCB0aW1lIHBvc2l0aW9ucyBbMCwgMSwgMiwgM10sKCNFWFQtWC1ESVNDT05USU5VSVRZKVxuICAgICAgLy8gb3IgWzAsIDEsIDIsIGdhcCwgZ2FwLCA1XT8gKCNFWFQtWC1HQVApXG4gICAgICAvLyBkb2VzIHRoZSB2YWx1ZSBvZiBzb3VyY2VEdXJhdGlvbiBjb25zaWRlciB0aGlzIHdoZW4gY2FsY3VsYXRpbmcgYXJiaXRyYXJ5XG4gICAgICAvLyBuZWdhdGl2ZSBAciByZXBlYXQgdmFsdWU/XG4gICAgICAvLyBFLkcuIFNhbWUgZWxlbWVudHMgYXMgYWJvdmUgd2l0aCB0aGlzIGFkZGVkIGF0IHRoZSBlbmRcbiAgICAgIC8vICA8UyBkPVwiMVwiIHI9XCItMVwiIC8+XG4gICAgICAvLyAgd2l0aCBhIHNvdXJjZUR1cmF0aW9uIG9mIDEwXG4gICAgICAvLyBXb3VsZCB0aGUgMiBnYXBzIGJlIGluY2x1ZGVkIGluIHRoZSB0aW1lIGR1cmF0aW9uIGNhbGN1bGF0aW9ucyByZXN1bHRpbmcgaW5cbiAgICAgIC8vIDggc2VnbWVudHMgd2l0aCAkVGltZSQgdmFsdWVzIG9mIFswLCAxLCAyLCA1LCA2LCA3LCA4LCA5XSBvciAxMCBzZWdtZW50c1xuICAgICAgLy8gd2l0aCAkVGltZSQgdmFsdWVzIG9mIFswLCAxLCAyLCA1LCA2LCA3LCA4LCA5LCAxMCwgMTFdID9cblxuICAgICAgdGltZSA9IHNlZ21lbnRUaW1lO1xuICAgIH1cblxuICAgIHZhciBjb3VudCA9IHZvaWQgMDtcblxuICAgIGlmIChyZXBlYXQgPCAwKSB7XG4gICAgICB2YXIgbmV4dFMgPSBzSW5kZXggKyAxO1xuXG4gICAgICBpZiAobmV4dFMgPT09IHNlZ21lbnRUaW1lbGluZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gbGFzdCBzZWdtZW50XG4gICAgICAgIGlmICh0eXBlID09PSAnZHluYW1pYycgJiYgbWluaW11bVVwZGF0ZVBlcmlvZCA+IDAgJiYgbWVkaWEuaW5kZXhPZignJE51bWJlciQnKSA+IDApIHtcbiAgICAgICAgICBjb3VudCA9IGdldExpdmVSVmFsdWUoYXR0cmlidXRlcywgdGltZSwgZHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRPRE86IFRoaXMgbWF5IGJlIGluY29ycmVjdCBkZXBlbmRpbmcgb24gY29uY2x1c2lvbiBvZiBUT0RPIGFib3ZlXG4gICAgICAgICAgY291bnQgPSAoc291cmNlRHVyYXRpb24gKiB0aW1lc2NhbGUgLSB0aW1lKSAvIGR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudCA9IChzZWdtZW50VGltZWxpbmVbbmV4dFNdLnQgLSB0aW1lKSAvIGR1cmF0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IHJlcGVhdCArIDE7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IHN0YXJ0TnVtYmVyICsgc2VnbWVudHMubGVuZ3RoICsgY291bnQ7XG4gICAgdmFyIG51bWJlciA9IHN0YXJ0TnVtYmVyICsgc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKG51bWJlciA8IGVuZCkge1xuICAgICAgc2VnbWVudHMucHVzaCh7IG51bWJlcjogbnVtYmVyLCBkdXJhdGlvbjogZHVyYXRpb24gLyB0aW1lc2NhbGUsIHRpbWU6IHRpbWUsIHRpbWVsaW5lOiB0aW1lbGluZSB9KTtcbiAgICAgIHRpbWUgKz0gZHVyYXRpb247XG4gICAgICBudW1iZXIrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHM7XG59O1xuXG52YXIgcmFuZ2UgPSBmdW5jdGlvbiByYW5nZShzdGFydCwgZW5kKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKGkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBmbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbihsaXN0cykge1xuICByZXR1cm4gbGlzdHMucmVkdWNlKGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIHguY29uY2F0KHkpO1xuICB9LCBbXSk7XG59O1xuXG52YXIgZnJvbSA9IGZ1bmN0aW9uIGZyb20obGlzdCkge1xuICBpZiAoIWxpc3QubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKGxpc3RbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRnVuY3Rpb25zIGZvciBjYWxjdWxhdGluZyB0aGUgcmFuZ2Ugb2YgYXZhaWxhYmxlIHNlZ21lbnRzIGluIHN0YXRpYyBhbmQgZHluYW1pY1xuICogbWFuaWZlc3RzLlxuICovXG52YXIgc2VnbWVudFJhbmdlID0ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZW50aXJlIHJhbmdlIG9mIGF2YWlsYWJsZSBzZWdtZW50cyBmb3IgYSBzdGF0aWMgTVBEXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gICAqICAgICAgICBJbmhlcml0aWVkIE1QRCBhdHRyaWJ1dGVzXG4gICAqIEByZXR1cm4ge3sgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIgfX1cbiAgICogICAgICAgICBUaGUgc3RhcnQgYW5kIGVuZCBudW1iZXJzIGZvciBhdmFpbGFibGUgc2VnbWVudHNcbiAgICovXG4gICdzdGF0aWMnOiBmdW5jdGlvbiBfc3RhdGljKGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgZHVyYXRpb24gPSBhdHRyaWJ1dGVzLmR1cmF0aW9uLFxuICAgICAgICBfYXR0cmlidXRlcyR0aW1lc2NhbGUgPSBhdHRyaWJ1dGVzLnRpbWVzY2FsZSxcbiAgICAgICAgdGltZXNjYWxlID0gX2F0dHJpYnV0ZXMkdGltZXNjYWxlID09PSB1bmRlZmluZWQgPyAxIDogX2F0dHJpYnV0ZXMkdGltZXNjYWxlLFxuICAgICAgICBzb3VyY2VEdXJhdGlvbiA9IGF0dHJpYnV0ZXMuc291cmNlRHVyYXRpb247XG5cblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGVuZDogTWF0aC5jZWlsKHNvdXJjZUR1cmF0aW9uIC8gKGR1cmF0aW9uIC8gdGltZXNjYWxlKSlcbiAgICB9O1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbGl2ZSB3aW5kb3cgcmFuZ2Ugb2YgYXZhaWxhYmxlIHNlZ21lbnRzIGZvciBhIGR5bmFtaWMgTVBEXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gICAqICAgICAgICBJbmhlcml0aWVkIE1QRCBhdHRyaWJ1dGVzXG4gICAqIEByZXR1cm4ge3sgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIgfX1cbiAgICogICAgICAgICBUaGUgc3RhcnQgYW5kIGVuZCBudW1iZXJzIGZvciBhdmFpbGFibGUgc2VnbWVudHNcbiAgICovXG4gIGR5bmFtaWM6IGZ1bmN0aW9uIGR5bmFtaWMoYXR0cmlidXRlcykge1xuICAgIHZhciBOT1cgPSBhdHRyaWJ1dGVzLk5PVyxcbiAgICAgICAgY2xpZW50T2Zmc2V0ID0gYXR0cmlidXRlcy5jbGllbnRPZmZzZXQsXG4gICAgICAgIGF2YWlsYWJpbGl0eVN0YXJ0VGltZSA9IGF0dHJpYnV0ZXMuYXZhaWxhYmlsaXR5U3RhcnRUaW1lLFxuICAgICAgICBfYXR0cmlidXRlcyR0aW1lc2NhbGUyID0gYXR0cmlidXRlcy50aW1lc2NhbGUsXG4gICAgICAgIHRpbWVzY2FsZSA9IF9hdHRyaWJ1dGVzJHRpbWVzY2FsZTIgPT09IHVuZGVmaW5lZCA/IDEgOiBfYXR0cmlidXRlcyR0aW1lc2NhbGUyLFxuICAgICAgICBkdXJhdGlvbiA9IGF0dHJpYnV0ZXMuZHVyYXRpb24sXG4gICAgICAgIF9hdHRyaWJ1dGVzJHN0YXJ0ID0gYXR0cmlidXRlcy5zdGFydCxcbiAgICAgICAgc3RhcnQgPSBfYXR0cmlidXRlcyRzdGFydCA9PT0gdW5kZWZpbmVkID8gMCA6IF9hdHRyaWJ1dGVzJHN0YXJ0LFxuICAgICAgICBfYXR0cmlidXRlcyRtaW5pbXVtVXAgPSBhdHRyaWJ1dGVzLm1pbmltdW1VcGRhdGVQZXJpb2QsXG4gICAgICAgIG1pbmltdW1VcGRhdGVQZXJpb2QgPSBfYXR0cmlidXRlcyRtaW5pbXVtVXAgPT09IHVuZGVmaW5lZCA/IDAgOiBfYXR0cmlidXRlcyRtaW5pbXVtVXAsXG4gICAgICAgIF9hdHRyaWJ1dGVzJHRpbWVTaGlmdCA9IGF0dHJpYnV0ZXMudGltZVNoaWZ0QnVmZmVyRGVwdGgsXG4gICAgICAgIHRpbWVTaGlmdEJ1ZmZlckRlcHRoID0gX2F0dHJpYnV0ZXMkdGltZVNoaWZ0ID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IF9hdHRyaWJ1dGVzJHRpbWVTaGlmdDtcblxuICAgIHZhciBub3cgPSAoTk9XICsgY2xpZW50T2Zmc2V0KSAvIDEwMDA7XG4gICAgdmFyIHBlcmlvZFN0YXJ0V0MgPSBhdmFpbGFiaWxpdHlTdGFydFRpbWUgKyBzdGFydDtcbiAgICB2YXIgcGVyaW9kRW5kV0MgPSBub3cgKyBtaW5pbXVtVXBkYXRlUGVyaW9kO1xuICAgIHZhciBwZXJpb2REdXJhdGlvbiA9IHBlcmlvZEVuZFdDIC0gcGVyaW9kU3RhcnRXQztcbiAgICB2YXIgc2VnbWVudENvdW50ID0gTWF0aC5jZWlsKHBlcmlvZER1cmF0aW9uICogdGltZXNjYWxlIC8gZHVyYXRpb24pO1xuICAgIHZhciBhdmFpbGFibGVTdGFydCA9IE1hdGguZmxvb3IoKG5vdyAtIHBlcmlvZFN0YXJ0V0MgLSB0aW1lU2hpZnRCdWZmZXJEZXB0aCkgKiB0aW1lc2NhbGUgLyBkdXJhdGlvbik7XG4gICAgdmFyIGF2YWlsYWJsZUVuZCA9IE1hdGguZmxvb3IoKG5vdyAtIHBlcmlvZFN0YXJ0V0MpICogdGltZXNjYWxlIC8gZHVyYXRpb24pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBNYXRoLm1heCgwLCBhdmFpbGFibGVTdGFydCksXG4gICAgICBlbmQ6IE1hdGgubWluKHNlZ21lbnRDb3VudCwgYXZhaWxhYmxlRW5kKVxuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogTWFwcyBhIHJhbmdlIG9mIG51bWJlcnMgdG8gb2JqZWN0cyB3aXRoIGluZm9ybWF0aW9uIG5lZWRlZCB0byBidWlsZCB0aGUgY29ycmVzcG9uZGluZ1xuICogc2VnbWVudCBsaXN0XG4gKlxuICogQG5hbWUgdG9TZWdtZW50c0NhbGxiYWNrXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAqICAgICAgICBOdW1iZXIgb2YgdGhlIHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogICAgICAgIEluZGV4IG9mIHRoZSBudW1iZXIgaW4gdGhlIHJhbmdlIGxpc3RcbiAqIEByZXR1cm4ge3sgbnVtYmVyOiBOdW1iZXIsIGR1cmF0aW9uOiBOdW1iZXIsIHRpbWVsaW5lOiBOdW1iZXIsIHRpbWU6IE51bWJlciB9fVxuICogICAgICAgICBPYmplY3Qgd2l0aCBzZWdtZW50IHRpbWluZyBhbmQgZHVyYXRpb24gaW5mb1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIGNhbGxiYWNrIGZvciBBcnJheS5wcm90b3R5cGUubWFwIGZvciBtYXBwaW5nIGEgcmFuZ2Ugb2YgbnVtYmVycyB0b1xuICogaW5mb3JtYXRpb24gbmVlZGVkIHRvIGJ1aWxkIHRoZSBzZWdtZW50IGxpc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICBJbmhlcml0ZWQgTVBEIGF0dHJpYnV0ZXNcbiAqIEByZXR1cm4ge3RvU2VnbWVudHNDYWxsYmFja31cbiAqICAgICAgICAgQ2FsbGJhY2sgbWFwIGZ1bmN0aW9uXG4gKi9cbnZhciB0b1NlZ21lbnRzID0gZnVuY3Rpb24gdG9TZWdtZW50cyhhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobnVtYmVyLCBpbmRleCkge1xuICAgIHZhciBkdXJhdGlvbiA9IGF0dHJpYnV0ZXMuZHVyYXRpb24sXG4gICAgICAgIF9hdHRyaWJ1dGVzJHRpbWVzY2FsZTMgPSBhdHRyaWJ1dGVzLnRpbWVzY2FsZSxcbiAgICAgICAgdGltZXNjYWxlID0gX2F0dHJpYnV0ZXMkdGltZXNjYWxlMyA9PT0gdW5kZWZpbmVkID8gMSA6IF9hdHRyaWJ1dGVzJHRpbWVzY2FsZTMsXG4gICAgICAgIHBlcmlvZEluZGV4ID0gYXR0cmlidXRlcy5wZXJpb2RJbmRleCxcbiAgICAgICAgX2F0dHJpYnV0ZXMkc3RhcnROdW1iID0gYXR0cmlidXRlcy5zdGFydE51bWJlcixcbiAgICAgICAgc3RhcnROdW1iZXIgPSBfYXR0cmlidXRlcyRzdGFydE51bWIgPT09IHVuZGVmaW5lZCA/IDEgOiBfYXR0cmlidXRlcyRzdGFydE51bWI7XG5cblxuICAgIHJldHVybiB7XG4gICAgICBudW1iZXI6IHN0YXJ0TnVtYmVyICsgbnVtYmVyLFxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uIC8gdGltZXNjYWxlLFxuICAgICAgdGltZWxpbmU6IHBlcmlvZEluZGV4LFxuICAgICAgdGltZTogaW5kZXggKiBkdXJhdGlvblxuICAgIH07XG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBzZWdtZW50IHRpbWluZyBhbmQgZHVyYXRpb24gaW5mbyB1c2VkIGZvclxuICogYnVpbGRpbmcgdGhlIGxpc3Qgb2Ygc2VnbWVudHMuIFRoaXMgdXNlcyB0aGUgQGR1cmF0aW9uIGF0dHJpYnV0ZSBzcGVjaWZpZWRcbiAqIGluIHRoZSBNUEQgbWFuaWZlc3QgdG8gZGVyaXZlIHRoZSByYW5nZSBvZiBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICAgICAgIEluaGVyaXRlZCBNUEQgYXR0cmlidXRlc1xuICogQHJldHVybiB7e251bWJlcjogbnVtYmVyLCBkdXJhdGlvbjogbnVtYmVyLCB0aW1lOiBudW1iZXIsIHRpbWVsaW5lOiBudW1iZXJ9W119XG4gKiAgICAgICAgIExpc3Qgb2YgT2JqZWN0cyB3aXRoIHNlZ21lbnQgdGltaW5nIGFuZCBkdXJhdGlvbiBpbmZvXG4gKi9cbnZhciBwYXJzZUJ5RHVyYXRpb24gPSBmdW5jdGlvbiBwYXJzZUJ5RHVyYXRpb24oYXR0cmlidXRlcykge1xuICB2YXIgX2F0dHJpYnV0ZXMkdHlwZSA9IGF0dHJpYnV0ZXMudHlwZSxcbiAgICAgIHR5cGUgPSBfYXR0cmlidXRlcyR0eXBlID09PSB1bmRlZmluZWQgPyAnc3RhdGljJyA6IF9hdHRyaWJ1dGVzJHR5cGUsXG4gICAgICBkdXJhdGlvbiA9IGF0dHJpYnV0ZXMuZHVyYXRpb24sXG4gICAgICBfYXR0cmlidXRlcyR0aW1lc2NhbGU0ID0gYXR0cmlidXRlcy50aW1lc2NhbGUsXG4gICAgICB0aW1lc2NhbGUgPSBfYXR0cmlidXRlcyR0aW1lc2NhbGU0ID09PSB1bmRlZmluZWQgPyAxIDogX2F0dHJpYnV0ZXMkdGltZXNjYWxlNCxcbiAgICAgIHNvdXJjZUR1cmF0aW9uID0gYXR0cmlidXRlcy5zb3VyY2VEdXJhdGlvbjtcblxuICB2YXIgX3NlZ21lbnRSYW5nZSR0eXBlID0gc2VnbWVudFJhbmdlW3R5cGVdKGF0dHJpYnV0ZXMpLFxuICAgICAgc3RhcnQgPSBfc2VnbWVudFJhbmdlJHR5cGUuc3RhcnQsXG4gICAgICBlbmQgPSBfc2VnbWVudFJhbmdlJHR5cGUuZW5kO1xuXG4gIHZhciBzZWdtZW50cyA9IHJhbmdlKHN0YXJ0LCBlbmQpLm1hcCh0b1NlZ21lbnRzKGF0dHJpYnV0ZXMpKTtcblxuICBpZiAodHlwZSA9PT0gJ3N0YXRpYycpIHtcbiAgICB2YXIgaW5kZXggPSBzZWdtZW50cy5sZW5ndGggLSAxO1xuXG4gICAgLy8gZmluYWwgc2VnbWVudCBtYXkgYmUgbGVzcyB0aGFuIGZ1bGwgc2VnbWVudCBkdXJhdGlvblxuICAgIHNlZ21lbnRzW2luZGV4XS5kdXJhdGlvbiA9IHNvdXJjZUR1cmF0aW9uIC0gZHVyYXRpb24gLyB0aW1lc2NhbGUgKiBpbmRleDtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50cztcbn07XG5cbnZhciBpZGVudGlmaWVyUGF0dGVybiA9IC9cXCQoW0Etel0qKSg/OiglMCkoWzAtOV0rKWQpP1xcJC9nO1xuXG4vKipcbiAqIFJlcGxhY2VzIHRlbXBsYXRlIGlkZW50aWZpZXJzIHdpdGggY29ycmVzcG9uZGluZyB2YWx1ZXMuIFRvIGJlIHVzZWQgYXMgdGhlIGNhbGxiYWNrXG4gKiBmb3IgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlXG4gKlxuICogQG5hbWUgcmVwbGFjZUNhbGxiYWNrXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaFxuICogICAgICAgIEVudGlyZSBtYXRjaCBvZiBpZGVudGlmaWVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllclxuICogICAgICAgIE5hbWUgb2YgbWF0Y2hlZCBpZGVudGlmaWVyXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0XG4gKiAgICAgICAgRm9ybWF0IHRhZyBzdHJpbmcuIEl0cyBwcmVzZW5jZSBpbmRpY2F0ZXMgdGhhdCBwYWRkaW5nIGlzIGV4cGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gd2lkdGhcbiAqICAgICAgICBEZXNpcmVkIGxlbmd0aCBvZiB0aGUgcmVwbGFjZWQgdmFsdWUuIFZhbHVlcyBsZXNzIHRoYW4gdGhpcyB3aWR0aCBzaGFsbCBiZSBsZWZ0XG4gKiAgICAgICAgemVybyBwYWRkZWRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgUmVwbGFjZW1lbnQgZm9yIHRoZSBtYXRjaGVkIGlkZW50aWZpZXJcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGFzIGEgY2FsbGJhY2sgZm9yIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSB0byByZXBsYWNlXG4gKiB0ZW1wbGF0ZSBpZGVudGlmaWVyc1xuICpcbiAqIEBwYXJhbSB7T2JlY3R9IHZhbHVlc1xuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIHZhbHVlcyB0aGF0IHNoYWxsIGJlIHVzZWQgdG8gcmVwbGFjZSBrbm93biBpZGVudGlmaWVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5SZXByZXNlbnRhdGlvbklEXG4gKiAgICAgICAgVmFsdWUgb2YgdGhlIFJlcHJlc2VudGF0aW9uQGlkIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5OdW1iZXJcbiAqICAgICAgICBOdW1iZXIgb2YgdGhlIGNvcnJlc3BvbmRpbmcgc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5CYW5kd2lkdGhcbiAqICAgICAgICBWYWx1ZSBvZiB0aGUgUmVwcmVzZW50YXRpb25AYmFuZHdpZHRoIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZXMuVGltZVxuICogICAgICAgIFRpbWVzdGFtcCB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBzZWdtZW50XG4gKiBAcmV0dXJuIHtyZXBsYWNlQ2FsbGJhY2t9XG4gKiAgICAgICAgIENhbGxiYWNrIHRvIGJlIHVzZWQgd2l0aCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UgdG8gcmVwbGFjZSBpZGVudGlmaWVyc1xuICovXG52YXIgaWRlbnRpZmllclJlcGxhY2VtZW50ID0gZnVuY3Rpb24gaWRlbnRpZmllclJlcGxhY2VtZW50KHZhbHVlcykge1xuICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoLCBpZGVudGlmaWVyLCBmb3JtYXQsIHdpZHRoKSB7XG4gICAgaWYgKG1hdGNoID09PSAnJCQnKSB7XG4gICAgICAvLyBlc2NhcGUgc2VxdWVuY2VcbiAgICAgIHJldHVybiAnJCc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZXNbaWRlbnRpZmllcl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gJycgKyB2YWx1ZXNbaWRlbnRpZmllcl07XG5cbiAgICBpZiAoaWRlbnRpZmllciA9PT0gJ1JlcHJlc2VudGF0aW9uSUQnKSB7XG4gICAgICAvLyBGb3JtYXQgdGFnIHNoYWxsIG5vdCBiZSBwcmVzZW50IHdpdGggUmVwcmVzZW50YXRpb25JRFxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICghZm9ybWF0KSB7XG4gICAgICB3aWR0aCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gcGFyc2VJbnQod2lkdGgsIDEwKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUubGVuZ3RoID49IHdpZHRoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnICsgbmV3IEFycmF5KHdpZHRoIC0gdmFsdWUubGVuZ3RoICsgMSkuam9pbignMCcpICsgdmFsdWU7XG4gIH07XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBzZWdtZW50IHVybCBmcm9tIGEgdGVtcGxhdGUgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogICAgICAgIFRlbXBsYXRlIHN0cmluZyB0byBjb25zdHJ1Y3QgdXJsIGZyb21cbiAqIEBwYXJhbSB7T2JlY3R9IHZhbHVlc1xuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIHZhbHVlcyB0aGF0IHNoYWxsIGJlIHVzZWQgdG8gcmVwbGFjZSBrbm93biBpZGVudGlmaWVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5SZXByZXNlbnRhdGlvbklEXG4gKiAgICAgICAgVmFsdWUgb2YgdGhlIFJlcHJlc2VudGF0aW9uQGlkIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5OdW1iZXJcbiAqICAgICAgICBOdW1iZXIgb2YgdGhlIGNvcnJlc3BvbmRpbmcgc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5CYW5kd2lkdGhcbiAqICAgICAgICBWYWx1ZSBvZiB0aGUgUmVwcmVzZW50YXRpb25AYmFuZHdpZHRoIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZXMuVGltZVxuICogICAgICAgIFRpbWVzdGFtcCB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBzZWdtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFNlZ21lbnQgdXJsIHdpdGggaWRlbnRpZmllcnMgcmVwbGFjZWRcbiAqL1xudmFyIGNvbnN0cnVjdFRlbXBsYXRlVXJsID0gZnVuY3Rpb24gY29uc3RydWN0VGVtcGxhdGVVcmwodXJsLCB2YWx1ZXMpIHtcbiAgcmV0dXJuIHVybC5yZXBsYWNlKGlkZW50aWZpZXJQYXR0ZXJuLCBpZGVudGlmaWVyUmVwbGFjZW1lbnQodmFsdWVzKSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGxpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRpbWluZyBhbmQgZHVyYXRpb24gaW5mb3JtYXRpb24gYWJvdXQgZWFjaFxuICogc2VnbWVudCBuZWVkZWQgdG8gZ2VuZXJhdGUgc2VnbWVudCB1cmlzIGFuZCB0aGUgY29tcGxldGUgc2VnbWVudCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIGFsbCBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBlbGVtZW50cyB3aXRoIGF0dHJpYnV0ZVxuICogICAgICAgIG5hbWVzIGFzIGtleXNcbiAqIEBwYXJhbSB7T2JqZWN0W118dW5kZWZpbmVkfSBzZWdtZW50VGltZWxpbmVcbiAqICAgICAgICBMaXN0IG9mIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBhdHRyaWJ1dGVzIG9mIGVhY2ggUyBlbGVtZW50IGNvbnRhaW5lZCB3aXRoaW5cbiAqICAgICAgICB0aGUgU2VnbWVudFRpbWVsaW5lIGVsZW1lbnRcbiAqIEByZXR1cm4ge3tudW1iZXI6IG51bWJlciwgZHVyYXRpb246IG51bWJlciwgdGltZTogbnVtYmVyLCB0aW1lbGluZTogbnVtYmVyfVtdfVxuICogICAgICAgICBMaXN0IG9mIE9iamVjdHMgd2l0aCBzZWdtZW50IHRpbWluZyBhbmQgZHVyYXRpb24gaW5mb1xuICovXG52YXIgcGFyc2VUZW1wbGF0ZUluZm8gPSBmdW5jdGlvbiBwYXJzZVRlbXBsYXRlSW5mbyhhdHRyaWJ1dGVzLCBzZWdtZW50VGltZWxpbmUpIHtcbiAgaWYgKCFhdHRyaWJ1dGVzLmR1cmF0aW9uICYmICFzZWdtZW50VGltZWxpbmUpIHtcbiAgICAvLyBpZiBuZWl0aGVyIEBkdXJhdGlvbiBvciBTZWdtZW50VGltZWxpbmUgYXJlIHByZXNlbnQsIHRoZW4gdGhlcmUgc2hhbGwgYmUgZXhhY3RseVxuICAgIC8vIG9uZSBtZWRpYSBzZWdtZW50XG4gICAgcmV0dXJuIFt7XG4gICAgICBudW1iZXI6IGF0dHJpYnV0ZXMuc3RhcnROdW1iZXIgfHwgMSxcbiAgICAgIGR1cmF0aW9uOiBhdHRyaWJ1dGVzLnNvdXJjZUR1cmF0aW9uLFxuICAgICAgdGltZTogMCxcbiAgICAgIHRpbWVsaW5lOiBhdHRyaWJ1dGVzLnBlcmlvZEluZGV4XG4gICAgfV07XG4gIH1cblxuICBpZiAoYXR0cmlidXRlcy5kdXJhdGlvbikge1xuICAgIHJldHVybiBwYXJzZUJ5RHVyYXRpb24oYXR0cmlidXRlcyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VCeVRpbWVsaW5lKGF0dHJpYnV0ZXMsIHNlZ21lbnRUaW1lbGluZSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGxpc3Qgb2Ygc2VnbWVudHMgdXNpbmcgaW5mb3JtYXRpb24gcHJvdmlkZWQgYnkgdGhlIFNlZ21lbnRUZW1wbGF0ZSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyBhbGwgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgd2l0aCBhdHRyaWJ1dGVcbiAqICAgICAgICBuYW1lcyBhcyBrZXlzXG4gKiBAcGFyYW0ge09iamVjdFtdfHVuZGVmaW5lZH0gc2VnbWVudFRpbWVsaW5lXG4gKiAgICAgICAgTGlzdCBvZiBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgYXR0cmlidXRlcyBvZiBlYWNoIFMgZWxlbWVudCBjb250YWluZWQgd2l0aGluXG4gKiAgICAgICAgdGhlIFNlZ21lbnRUaW1lbGluZSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAqICAgICAgICAgTGlzdCBvZiBzZWdtZW50IG9iamVjdHNcbiAqL1xudmFyIHNlZ21lbnRzRnJvbVRlbXBsYXRlID0gZnVuY3Rpb24gc2VnbWVudHNGcm9tVGVtcGxhdGUoYXR0cmlidXRlcywgc2VnbWVudFRpbWVsaW5lKSB7XG4gIHZhciB0ZW1wbGF0ZVZhbHVlcyA9IHtcbiAgICBSZXByZXNlbnRhdGlvbklEOiBhdHRyaWJ1dGVzLmlkLFxuICAgIEJhbmR3aWR0aDogYXR0cmlidXRlcy5iYW5kd2lkdGggfHwgMFxuICB9O1xuXG4gIHZhciBfYXR0cmlidXRlcyRpbml0aWFsaXogPSBhdHRyaWJ1dGVzLmluaXRpYWxpemF0aW9uLFxuICAgICAgaW5pdGlhbGl6YXRpb24gPSBfYXR0cmlidXRlcyRpbml0aWFsaXogPT09IHVuZGVmaW5lZCA/IHsgc291cmNlVVJMOiAnJywgcmFuZ2U6ICcnIH0gOiBfYXR0cmlidXRlcyRpbml0aWFsaXo7XG5cblxuICB2YXIgbWFwU2VnbWVudCA9IHVybFR5cGVUb1NlZ21lbnQoe1xuICAgIGJhc2VVcmw6IGF0dHJpYnV0ZXMuYmFzZVVybCxcbiAgICBzb3VyY2U6IGNvbnN0cnVjdFRlbXBsYXRlVXJsKGluaXRpYWxpemF0aW9uLnNvdXJjZVVSTCwgdGVtcGxhdGVWYWx1ZXMpLFxuICAgIHJhbmdlOiBpbml0aWFsaXphdGlvbi5yYW5nZVxuICB9KTtcblxuICB2YXIgc2VnbWVudHMgPSBwYXJzZVRlbXBsYXRlSW5mbyhhdHRyaWJ1dGVzLCBzZWdtZW50VGltZWxpbmUpO1xuXG4gIHJldHVybiBzZWdtZW50cy5tYXAoZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICB0ZW1wbGF0ZVZhbHVlcy5OdW1iZXIgPSBzZWdtZW50Lm51bWJlcjtcbiAgICB0ZW1wbGF0ZVZhbHVlcy5UaW1lID0gc2VnbWVudC50aW1lO1xuXG4gICAgdmFyIHVyaSA9IGNvbnN0cnVjdFRlbXBsYXRlVXJsKGF0dHJpYnV0ZXMubWVkaWEgfHwgJycsIHRlbXBsYXRlVmFsdWVzKTtcblxuICAgIHJldHVybiB7XG4gICAgICB1cmk6IHVyaSxcbiAgICAgIHRpbWVsaW5lOiBzZWdtZW50LnRpbWVsaW5lLFxuICAgICAgZHVyYXRpb246IHNlZ21lbnQuZHVyYXRpb24sXG4gICAgICByZXNvbHZlZFVyaTogcmVzb2x2ZVVybChhdHRyaWJ1dGVzLmJhc2VVcmwgfHwgJycsIHVyaSksXG4gICAgICBtYXA6IG1hcFNlZ21lbnQsXG4gICAgICBudW1iZXI6IHNlZ21lbnQubnVtYmVyXG4gICAgfTtcbiAgfSk7XG59O1xuXG52YXIgZXJyb3JzID0ge1xuICBJTlZBTElEX05VTUJFUl9PRl9QRVJJT0Q6ICdJTlZBTElEX05VTUJFUl9PRl9QRVJJT0QnLFxuICBEQVNIX0VNUFRZX01BTklGRVNUOiAnREFTSF9FTVBUWV9NQU5JRkVTVCcsXG4gIERBU0hfSU5WQUxJRF9YTUw6ICdEQVNIX0lOVkFMSURfWE1MJyxcbiAgTk9fQkFTRV9VUkw6ICdOT19CQVNFX1VSTCcsXG4gIE1JU1NJTkdfU0VHTUVOVF9JTkZPUk1BVElPTjogJ01JU1NJTkdfU0VHTUVOVF9JTkZPUk1BVElPTicsXG4gIFNFR01FTlRfVElNRV9VTlNQRUNJRklFRDogJ1NFR01FTlRfVElNRV9VTlNQRUNJRklFRCcsXG4gIFVOU1VQUE9SVEVEX1VUQ19USU1JTkdfU0NIRU1FOiAnVU5TVVBQT1JURURfVVRDX1RJTUlOR19TQ0hFTUUnXG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgPFNlZ21lbnRVcmw+IChvZiB0eXBlIFVSTFR5cGUgZnJvbSB0aGUgREFTSCBzcGVjIDUuMy45LjIgVGFibGUgMTQpXG4gKiB0byBhbiBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBvdXRwdXQgb2YgYSBzZWdtZW50IGluIHZpZGVvanMvbXBkLXBhcnNlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgIE9iamVjdCBjb250YWluaW5nIGFsbCBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBlbGVtZW50cyB3aXRoIGF0dHJpYnV0ZVxuICogICBuYW1lcyBhcyBrZXlzXG4gKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudFVybFxuICogICA8U2VnbWVudFVSTD4gbm9kZSB0byB0cmFuc2xhdGUgaW50byBhIHNlZ21lbnQgb2JqZWN0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHRyYW5zbGF0ZWQgc2VnbWVudCBvYmplY3RcbiAqL1xudmFyIFNlZ21lbnRVUkxUb1NlZ21lbnRPYmplY3QgPSBmdW5jdGlvbiBTZWdtZW50VVJMVG9TZWdtZW50T2JqZWN0KGF0dHJpYnV0ZXMsIHNlZ21lbnRVcmwpIHtcbiAgdmFyIGJhc2VVcmwgPSBhdHRyaWJ1dGVzLmJhc2VVcmwsXG4gICAgICBfYXR0cmlidXRlcyRpbml0aWFsaXogPSBhdHRyaWJ1dGVzLmluaXRpYWxpemF0aW9uLFxuICAgICAgaW5pdGlhbGl6YXRpb24gPSBfYXR0cmlidXRlcyRpbml0aWFsaXogPT09IHVuZGVmaW5lZCA/IHt9IDogX2F0dHJpYnV0ZXMkaW5pdGlhbGl6O1xuXG5cbiAgdmFyIGluaXRTZWdtZW50ID0gdXJsVHlwZVRvU2VnbWVudCh7XG4gICAgYmFzZVVybDogYmFzZVVybCxcbiAgICBzb3VyY2U6IGluaXRpYWxpemF0aW9uLnNvdXJjZVVSTCxcbiAgICByYW5nZTogaW5pdGlhbGl6YXRpb24ucmFuZ2VcbiAgfSk7XG5cbiAgdmFyIHNlZ21lbnQgPSB1cmxUeXBlVG9TZWdtZW50KHtcbiAgICBiYXNlVXJsOiBiYXNlVXJsLFxuICAgIHNvdXJjZTogc2VnbWVudFVybC5tZWRpYSxcbiAgICByYW5nZTogc2VnbWVudFVybC5tZWRpYVJhbmdlXG4gIH0pO1xuXG4gIHNlZ21lbnQubWFwID0gaW5pdFNlZ21lbnQ7XG5cbiAgcmV0dXJuIHNlZ21lbnQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGxpc3Qgb2Ygc2VnbWVudHMgdXNpbmcgaW5mb3JtYXRpb24gcHJvdmlkZWQgYnkgdGhlIFNlZ21lbnRMaXN0IGVsZW1lbnRcbiAqIFNlZ21lbnRMaXN0IChEQVNIIFNQRUMgU2VjdGlvbiA1LjMuOS4zLjIpIGNvbnRhaW5zIGEgc2V0IG9mIDxTZWdtZW50VVJMPiBub2Rlcy4gIEVhY2hcbiAqIG5vZGUgc2hvdWxkIGJlIHRyYW5zbGF0ZWQgaW50byBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgIE9iamVjdCBjb250YWluaW5nIGFsbCBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBlbGVtZW50cyB3aXRoIGF0dHJpYnV0ZVxuICogICBuYW1lcyBhcyBrZXlzXG4gKiBAcGFyYW0ge09iamVjdFtdfHVuZGVmaW5lZH0gc2VnbWVudFRpbWVsaW5lXG4gKiAgICAgICAgTGlzdCBvZiBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgYXR0cmlidXRlcyBvZiBlYWNoIFMgZWxlbWVudCBjb250YWluZWQgd2l0aGluXG4gKiAgICAgICAgdGhlIFNlZ21lbnRUaW1lbGluZSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3QuPEFycmF5Pn0gbGlzdCBvZiBzZWdtZW50c1xuICovXG52YXIgc2VnbWVudHNGcm9tTGlzdCA9IGZ1bmN0aW9uIHNlZ21lbnRzRnJvbUxpc3QoYXR0cmlidXRlcywgc2VnbWVudFRpbWVsaW5lKSB7XG4gIHZhciBkdXJhdGlvbiA9IGF0dHJpYnV0ZXMuZHVyYXRpb24sXG4gICAgICBfYXR0cmlidXRlcyRzZWdtZW50VXIgPSBhdHRyaWJ1dGVzLnNlZ21lbnRVcmxzLFxuICAgICAgc2VnbWVudFVybHMgPSBfYXR0cmlidXRlcyRzZWdtZW50VXIgPT09IHVuZGVmaW5lZCA/IFtdIDogX2F0dHJpYnV0ZXMkc2VnbWVudFVyO1xuXG4gIC8vIFBlciBzcGVjICg1LjMuOS4yLjEpIG5vIHdheSB0byBkZXRlcm1pbmUgc2VnbWVudCBkdXJhdGlvbiBPUlxuICAvLyBpZiBib3RoIFNlZ21lbnRUaW1lbGluZSBhbmQgQGR1cmF0aW9uIGFyZSBkZWZpbmVkLCBpdCBpcyBvdXRzaWRlIG9mIHNwZWMuXG5cbiAgaWYgKCFkdXJhdGlvbiAmJiAhc2VnbWVudFRpbWVsaW5lIHx8IGR1cmF0aW9uICYmIHNlZ21lbnRUaW1lbGluZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuU0VHTUVOVF9USU1FX1VOU1BFQ0lGSUVEKTtcbiAgfVxuXG4gIHZhciBzZWdtZW50VXJsTWFwID0gc2VnbWVudFVybHMubWFwKGZ1bmN0aW9uIChzZWdtZW50VXJsT2JqZWN0KSB7XG4gICAgcmV0dXJuIFNlZ21lbnRVUkxUb1NlZ21lbnRPYmplY3QoYXR0cmlidXRlcywgc2VnbWVudFVybE9iamVjdCk7XG4gIH0pO1xuICB2YXIgc2VnbWVudFRpbWVJbmZvID0gdm9pZCAwO1xuXG4gIGlmIChkdXJhdGlvbikge1xuICAgIHNlZ21lbnRUaW1lSW5mbyA9IHBhcnNlQnlEdXJhdGlvbihhdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIGlmIChzZWdtZW50VGltZWxpbmUpIHtcbiAgICBzZWdtZW50VGltZUluZm8gPSBwYXJzZUJ5VGltZWxpbmUoYXR0cmlidXRlcywgc2VnbWVudFRpbWVsaW5lKTtcbiAgfVxuXG4gIHZhciBzZWdtZW50cyA9IHNlZ21lbnRUaW1lSW5mby5tYXAoZnVuY3Rpb24gKHNlZ21lbnRUaW1lLCBpbmRleCkge1xuICAgIGlmIChzZWdtZW50VXJsTWFwW2luZGV4XSkge1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50VXJsTWFwW2luZGV4XTtcblxuICAgICAgc2VnbWVudC50aW1lbGluZSA9IHNlZ21lbnRUaW1lLnRpbWVsaW5lO1xuICAgICAgc2VnbWVudC5kdXJhdGlvbiA9IHNlZ21lbnRUaW1lLmR1cmF0aW9uO1xuICAgICAgc2VnbWVudC5udW1iZXIgPSBzZWdtZW50VGltZS5udW1iZXI7XG4gICAgICByZXR1cm4gc2VnbWVudDtcbiAgICB9XG4gICAgLy8gU2luY2Ugd2UncmUgbWFwcGluZyB3ZSBzaG91bGQgZ2V0IHJpZCBvZiBhbnkgYmxhbmsgc2VnbWVudHMgKGluIGNhc2VcbiAgICAvLyB0aGUgZ2l2ZW4gU2VnbWVudFRpbWVsaW5lIGlzIGhhbmRsaW5nIGZvciBtb3JlIGVsZW1lbnRzIHRoYW4gd2UgaGF2ZVxuICAgIC8vIFNlZ21lbnRVUkxzIGZvcikuXG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgIHJldHVybiBzZWdtZW50O1xuICB9KTtcblxuICByZXR1cm4gc2VnbWVudHM7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgU2VnbWVudEJhc2UgaW50byBhIHNldCBvZiBzZWdtZW50cy5cbiAqIChEQVNIIFNQRUMgU2VjdGlvbiA1LjMuOS4zLjIpIGNvbnRhaW5zIGEgc2V0IG9mIDxTZWdtZW50VVJMPiBub2Rlcy4gIEVhY2hcbiAqIG5vZGUgc2hvdWxkIGJlIHRyYW5zbGF0ZWQgaW50byBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgIE9iamVjdCBjb250YWluaW5nIGFsbCBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBlbGVtZW50cyB3aXRoIGF0dHJpYnV0ZVxuICogICBuYW1lcyBhcyBrZXlzXG4gKiBAcmV0dXJuIHtPYmplY3QuPEFycmF5Pn0gbGlzdCBvZiBzZWdtZW50c1xuICovXG52YXIgc2VnbWVudHNGcm9tQmFzZSA9IGZ1bmN0aW9uIHNlZ21lbnRzRnJvbUJhc2UoYXR0cmlidXRlcykge1xuICB2YXIgYmFzZVVybCA9IGF0dHJpYnV0ZXMuYmFzZVVybCxcbiAgICAgIF9hdHRyaWJ1dGVzJGluaXRpYWxpeiA9IGF0dHJpYnV0ZXMuaW5pdGlhbGl6YXRpb24sXG4gICAgICBpbml0aWFsaXphdGlvbiA9IF9hdHRyaWJ1dGVzJGluaXRpYWxpeiA9PT0gdW5kZWZpbmVkID8ge30gOiBfYXR0cmlidXRlcyRpbml0aWFsaXosXG4gICAgICBzb3VyY2VEdXJhdGlvbiA9IGF0dHJpYnV0ZXMuc291cmNlRHVyYXRpb24sXG4gICAgICBfYXR0cmlidXRlcyR0aW1lc2NhbGUgPSBhdHRyaWJ1dGVzLnRpbWVzY2FsZSxcbiAgICAgIHRpbWVzY2FsZSA9IF9hdHRyaWJ1dGVzJHRpbWVzY2FsZSA9PT0gdW5kZWZpbmVkID8gMSA6IF9hdHRyaWJ1dGVzJHRpbWVzY2FsZSxcbiAgICAgIF9hdHRyaWJ1dGVzJGluZGV4UmFuZyA9IGF0dHJpYnV0ZXMuaW5kZXhSYW5nZSxcbiAgICAgIGluZGV4UmFuZ2UgPSBfYXR0cmlidXRlcyRpbmRleFJhbmcgPT09IHVuZGVmaW5lZCA/ICcnIDogX2F0dHJpYnV0ZXMkaW5kZXhSYW5nLFxuICAgICAgZHVyYXRpb24gPSBhdHRyaWJ1dGVzLmR1cmF0aW9uO1xuXG4gIC8vIGJhc2UgdXJsIGlzIHJlcXVpcmVkIGZvciBTZWdtZW50QmFzZSB0byB3b3JrLCBwZXIgc3BlYyAoU2VjdGlvbiA1LjMuOS4yLjEpXG5cbiAgaWYgKCFiYXNlVXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5OT19CQVNFX1VSTCk7XG4gIH1cblxuICB2YXIgaW5pdFNlZ21lbnQgPSB1cmxUeXBlVG9TZWdtZW50KHtcbiAgICBiYXNlVXJsOiBiYXNlVXJsLFxuICAgIHNvdXJjZTogaW5pdGlhbGl6YXRpb24uc291cmNlVVJMLFxuICAgIHJhbmdlOiBpbml0aWFsaXphdGlvbi5yYW5nZVxuICB9KTtcbiAgdmFyIHNlZ21lbnQgPSB1cmxUeXBlVG9TZWdtZW50KHsgYmFzZVVybDogYmFzZVVybCwgc291cmNlOiBiYXNlVXJsLCByYW5nZTogaW5kZXhSYW5nZSB9KTtcblxuICBzZWdtZW50Lm1hcCA9IGluaXRTZWdtZW50O1xuXG4gIC8vIElmIHRoZXJlIGlzIGEgZHVyYXRpb24sIHVzZSBpdCwgb3RoZXJ3aXNlIHVzZSB0aGUgZ2l2ZW4gZHVyYXRpb24gb2YgdGhlIHNvdXJjZVxuICAvLyAoc2luY2UgU2VnbWVudEJhc2UgaXMgb25seSBmb3Igb25lIHRvdGFsIHNlZ21lbnQpXG4gIGlmIChkdXJhdGlvbikge1xuICAgIHZhciBzZWdtZW50VGltZUluZm8gPSBwYXJzZUJ5RHVyYXRpb24oYXR0cmlidXRlcyk7XG5cbiAgICBpZiAoc2VnbWVudFRpbWVJbmZvLmxlbmd0aCkge1xuICAgICAgc2VnbWVudC5kdXJhdGlvbiA9IHNlZ21lbnRUaW1lSW5mb1swXS5kdXJhdGlvbjtcbiAgICAgIHNlZ21lbnQudGltZWxpbmUgPSBzZWdtZW50VGltZUluZm9bMF0udGltZWxpbmU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNvdXJjZUR1cmF0aW9uKSB7XG4gICAgc2VnbWVudC5kdXJhdGlvbiA9IHNvdXJjZUR1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgIHNlZ21lbnQudGltZWxpbmUgPSAwO1xuICB9XG5cbiAgLy8gVGhpcyBpcyB1c2VkIGZvciBtZWRpYVNlcXVlbmNlXG4gIHNlZ21lbnQubnVtYmVyID0gMDtcblxuICByZXR1cm4gW3NlZ21lbnRdO1xufTtcblxudmFyIGdlbmVyYXRlU2VnbWVudHMgPSBmdW5jdGlvbiBnZW5lcmF0ZVNlZ21lbnRzKF9yZWYpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBfcmVmLmF0dHJpYnV0ZXMsXG4gICAgICBzZWdtZW50SW5mbyA9IF9yZWYuc2VnbWVudEluZm87XG5cbiAgdmFyIHNlZ21lbnRBdHRyaWJ1dGVzID0gdm9pZCAwO1xuICB2YXIgc2VnbWVudHNGbiA9IHZvaWQgMDtcblxuICBpZiAoc2VnbWVudEluZm8udGVtcGxhdGUpIHtcbiAgICBzZWdtZW50c0ZuID0gc2VnbWVudHNGcm9tVGVtcGxhdGU7XG4gICAgc2VnbWVudEF0dHJpYnV0ZXMgPSBtZXJnZShhdHRyaWJ1dGVzLCBzZWdtZW50SW5mby50ZW1wbGF0ZSk7XG4gIH0gZWxzZSBpZiAoc2VnbWVudEluZm8uYmFzZSkge1xuICAgIHNlZ21lbnRzRm4gPSBzZWdtZW50c0Zyb21CYXNlO1xuICAgIHNlZ21lbnRBdHRyaWJ1dGVzID0gbWVyZ2UoYXR0cmlidXRlcywgc2VnbWVudEluZm8uYmFzZSk7XG4gIH0gZWxzZSBpZiAoc2VnbWVudEluZm8ubGlzdCkge1xuICAgIHNlZ21lbnRzRm4gPSBzZWdtZW50c0Zyb21MaXN0O1xuICAgIHNlZ21lbnRBdHRyaWJ1dGVzID0gbWVyZ2UoYXR0cmlidXRlcywgc2VnbWVudEluZm8ubGlzdCk7XG4gIH1cblxuICBpZiAoIXNlZ21lbnRzRm4pIHtcbiAgICByZXR1cm4geyBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzIH07XG4gIH1cblxuICB2YXIgc2VnbWVudHMgPSBzZWdtZW50c0ZuKHNlZ21lbnRBdHRyaWJ1dGVzLCBzZWdtZW50SW5mby50aW1lbGluZSk7XG5cbiAgLy8gVGhlIEBkdXJhdGlvbiBhdHRyaWJ1dGUgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluIHRoZSBwbGF5bGlzdCdzIHRhcmdldER1cmF0aW9uIHdoaWNoXG4gIC8vIG11c3QgYmUgaW4gc2Vjb25kcy4gU2luY2Ugd2UndmUgZ2VuZXJhdGVkIHRoZSBzZWdtZW50IGxpc3QsIHdlIG5vIGxvbmdlciBuZWVkXG4gIC8vIEBkdXJhdGlvbiB0byBiZSBpbiBAdGltZXNjYWxlIHVuaXRzLCBzbyB3ZSBjYW4gY29udmVydCBpdCBoZXJlLlxuICBpZiAoc2VnbWVudEF0dHJpYnV0ZXMuZHVyYXRpb24pIHtcbiAgICB2YXIgX3NlZ21lbnRBdHRyaWJ1dGVzID0gc2VnbWVudEF0dHJpYnV0ZXMsXG4gICAgICAgIGR1cmF0aW9uID0gX3NlZ21lbnRBdHRyaWJ1dGVzLmR1cmF0aW9uLFxuICAgICAgICBfc2VnbWVudEF0dHJpYnV0ZXMkdGkgPSBfc2VnbWVudEF0dHJpYnV0ZXMudGltZXNjYWxlLFxuICAgICAgICB0aW1lc2NhbGUgPSBfc2VnbWVudEF0dHJpYnV0ZXMkdGkgPT09IHVuZGVmaW5lZCA/IDEgOiBfc2VnbWVudEF0dHJpYnV0ZXMkdGk7XG5cblxuICAgIHNlZ21lbnRBdHRyaWJ1dGVzLmR1cmF0aW9uID0gZHVyYXRpb24gLyB0aW1lc2NhbGU7XG4gIH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gQGR1cmF0aW9uIGF0dHJpYnV0ZSwgdXNlIHRoZSBsYXJnZXN0IHNlZ21lbnQgZHVyYXRpb24gYXNcbiAgICAvLyBhcyB0YXJnZXQgZHVyYXRpb25cbiAgICBzZWdtZW50QXR0cmlidXRlcy5kdXJhdGlvbiA9IHNlZ21lbnRzLnJlZHVjZShmdW5jdGlvbiAobWF4LCBzZWdtZW50KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobWF4LCBNYXRoLmNlaWwoc2VnbWVudC5kdXJhdGlvbikpO1xuICAgIH0sIDApO1xuICB9IGVsc2Uge1xuICAgIHNlZ21lbnRBdHRyaWJ1dGVzLmR1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYXR0cmlidXRlczogc2VnbWVudEF0dHJpYnV0ZXMsXG4gICAgc2VnbWVudHM6IHNlZ21lbnRzXG4gIH07XG59O1xuXG52YXIgdG9QbGF5bGlzdHMgPSBmdW5jdGlvbiB0b1BsYXlsaXN0cyhyZXByZXNlbnRhdGlvbnMpIHtcbiAgcmV0dXJuIHJlcHJlc2VudGF0aW9ucy5tYXAoZ2VuZXJhdGVTZWdtZW50cyk7XG59O1xuXG52YXIgZmluZENoaWxkcmVuID0gZnVuY3Rpb24gZmluZENoaWxkcmVuKGVsZW1lbnQsIG5hbWUpIHtcbiAgcmV0dXJuIGZyb20oZWxlbWVudC5jaGlsZE5vZGVzKS5maWx0ZXIoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgdGFnTmFtZSA9IF9yZWYudGFnTmFtZTtcbiAgICByZXR1cm4gdGFnTmFtZSA9PT0gbmFtZTtcbiAgfSk7XG59O1xuXG52YXIgZ2V0Q29udGVudCA9IGZ1bmN0aW9uIGdldENvbnRlbnQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC50ZXh0Q29udGVudC50cmltKCk7XG59O1xuXG52YXIgcGFyc2VEdXJhdGlvbiA9IGZ1bmN0aW9uIHBhcnNlRHVyYXRpb24oc3RyKSB7XG4gIHZhciBTRUNPTkRTX0lOX1lFQVIgPSAzNjUgKiAyNCAqIDYwICogNjA7XG4gIHZhciBTRUNPTkRTX0lOX01PTlRIID0gMzAgKiAyNCAqIDYwICogNjA7XG4gIHZhciBTRUNPTkRTX0lOX0RBWSA9IDI0ICogNjAgKiA2MDtcbiAgdmFyIFNFQ09ORFNfSU5fSE9VUiA9IDYwICogNjA7XG4gIHZhciBTRUNPTkRTX0lOX01JTiA9IDYwO1xuXG4gIC8vIFAxMFkxME0xMERUMTBIMTBNMTAuMVNcbiAgdmFyIGR1cmF0aW9uUmVnZXggPSAvUCg/OihcXGQqKVkpPyg/OihcXGQqKU0pPyg/OihcXGQqKUQpPyg/OlQoPzooXFxkKilIKT8oPzooXFxkKilNKT8oPzooW1xcZC5dKilTKT8pPy87XG4gIHZhciBtYXRjaCA9IGR1cmF0aW9uUmVnZXguZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBfbWF0Y2gkc2xpY2UgPSBtYXRjaC5zbGljZSgxKSxcbiAgICAgIHllYXIgPSBfbWF0Y2gkc2xpY2VbMF0sXG4gICAgICBtb250aCA9IF9tYXRjaCRzbGljZVsxXSxcbiAgICAgIGRheSA9IF9tYXRjaCRzbGljZVsyXSxcbiAgICAgIGhvdXIgPSBfbWF0Y2gkc2xpY2VbM10sXG4gICAgICBtaW51dGUgPSBfbWF0Y2gkc2xpY2VbNF0sXG4gICAgICBzZWNvbmQgPSBfbWF0Y2gkc2xpY2VbNV07XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQoeWVhciB8fCAwKSAqIFNFQ09ORFNfSU5fWUVBUiArIHBhcnNlRmxvYXQobW9udGggfHwgMCkgKiBTRUNPTkRTX0lOX01PTlRIICsgcGFyc2VGbG9hdChkYXkgfHwgMCkgKiBTRUNPTkRTX0lOX0RBWSArIHBhcnNlRmxvYXQoaG91ciB8fCAwKSAqIFNFQ09ORFNfSU5fSE9VUiArIHBhcnNlRmxvYXQobWludXRlIHx8IDApICogU0VDT05EU19JTl9NSU4gKyBwYXJzZUZsb2F0KHNlY29uZCB8fCAwKTtcbn07XG5cbnZhciBwYXJzZURhdGUgPSBmdW5jdGlvbiBwYXJzZURhdGUoc3RyKSB7XG4gIC8vIERhdGUgZm9ybWF0IHdpdGhvdXQgdGltZXpvbmUgYWNjb3JkaW5nIHRvIElTTyA4NjAxXG4gIC8vIFlZWS1NTS1ERFRoaDptbTpzcy5zc3Nzc3NcbiAgdmFyIGRhdGVSZWdleCA9IC9eXFxkKy1cXGQrLVxcZCtUXFxkKzpcXGQrOlxcZCsoXFwuXFxkKyk/JC87XG5cbiAgLy8gSWYgdGhlIGRhdGUgc3RyaW5nIGRvZXMgbm90IHNwZWNpZml5IGEgdGltZXpvbmUsIHdlIG11c3Qgc3BlY2lmaXkgVVRDLiBUaGlzIGlzXG4gIC8vIGV4cHJlc3NlZCBieSBlbmRpbmcgd2l0aCAnWidcbiAgaWYgKGRhdGVSZWdleC50ZXN0KHN0cikpIHtcbiAgICBzdHIgKz0gJ1onO1xuICB9XG5cbiAgcmV0dXJuIERhdGUucGFyc2Uoc3RyKTtcbn07XG5cbi8vIFRPRE86IG1heWJlIG9yZGVyIHRoZXNlIGluIHNvbWUgd2F5IHRoYXQgbWFrZXMgaXQgZWFzeSB0byBmaW5kIHNwZWNpZmljIGF0dHJpYnV0ZXNcbnZhciBwYXJzZXJzID0ge1xuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkdXJhdGlvbiBvZiB0aGUgZW50aXJlIE1lZGlhIFByZXNlbnRhdGlvbi4gRm9ybWF0IGlzIGEgZHVyYXRpb24gc3RyaW5nXG4gICAqIGFzIHNwZWNpZmllZCBpbiBJU08gODYwMVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICovXG4gIG1lZGlhUHJlc2VudGF0aW9uRHVyYXRpb246IGZ1bmN0aW9uIG1lZGlhUHJlc2VudGF0aW9uRHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBTZWdtZW50IGF2YWlsYWJpbGl0eSBzdGFydCB0aW1lIGZvciBhbGwgU2VnbWVudHMgcmVmZXJyZWQgdG8gaW4gdGhpc1xuICAgKiBNUEQuIEZvciBhIGR5bmFtaWMgbWFuaWZlc3QsIGl0IHNwZWNpZmllcyB0aGUgYW5jaG9yIGZvciB0aGUgZWFybGllc3QgYXZhaWxhYmlsaXR5XG4gICAqIHRpbWUuIEZvcm1hdCBpcyBhIGRhdGUgc3RyaW5nIGFzIHNwZWNpZmllZCBpbiBJU08gODYwMVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGRhdGUgYXMgc2Vjb25kcyBmcm9tIHVuaXggZXBvY2hcbiAgICovXG4gIGF2YWlsYWJpbGl0eVN0YXJ0VGltZTogZnVuY3Rpb24gYXZhaWxhYmlsaXR5U3RhcnRUaW1lKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlRGF0ZSh2YWx1ZSkgLyAxMDAwO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgc21hbGxlc3QgcGVyaW9kIGJldHdlZW4gcG90ZW50aWFsIGNoYW5nZXMgdG8gdGhlIE1QRC4gRm9ybWF0IGlzIGFcbiAgICogZHVyYXRpb24gc3RyaW5nIGFzIHNwZWNpZmllZCBpbiBJU08gODYwMVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICovXG4gIG1pbmltdW1VcGRhdGVQZXJpb2Q6IGZ1bmN0aW9uIG1pbmltdW1VcGRhdGVQZXJpb2QodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkdXJhdGlvbiBvZiB0aGUgc21hbGxlc3QgdGltZSBzaGlmdGluZyBidWZmZXIgZm9yIGFueSBSZXByZXNlbnRhdGlvblxuICAgKiBpbiB0aGUgTVBELiBGb3JtYXQgaXMgYSBkdXJhdGlvbiBzdHJpbmcgYXMgc3BlY2lmaWVkIGluIElTTyA4NjAxXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKi9cbiAgdGltZVNoaWZ0QnVmZmVyRGVwdGg6IGZ1bmN0aW9uIHRpbWVTaGlmdEJ1ZmZlckRlcHRoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlRHVyYXRpb24odmFsdWUpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgUGVyaW9kU3RhcnQgdGltZSBvZiB0aGUgUGVyaW9kIHJlbGF0aXZlIHRvIHRoZSBhdmFpbGFiaWxpdHlTdGFydHRpbWUuXG4gICAqIEZvcm1hdCBpcyBhIGR1cmF0aW9uIHN0cmluZyBhcyBzcGVjaWZpZWQgaW4gSVNPIDg2MDFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqL1xuICBzdGFydDogZnVuY3Rpb24gc3RhcnQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSB3aWR0aCBvZiB0aGUgdmlzdWFsIHByZXNlbnRhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCB3aWR0aFxuICAgKi9cbiAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBoZWlnaHQgb2YgdGhlIHZpc3VhbCBwcmVzZW50YXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgaGVpZ2h0XG4gICAqL1xuICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgYml0cmF0ZSBvZiB0aGUgcmVwcmVzZW50YXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgYmFuZHdpZHRoXG4gICAqL1xuICBiYW5kd2lkdGg6IGZ1bmN0aW9uIGJhbmR3aWR0aCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHRoZSBmaXJzdCBNZWRpYSBTZWdtZW50IGluIHRoaXMgUmVwcmVzZW50YXRpb24gaW4gdGhlIFBlcmlvZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBudW1iZXJcbiAgICovXG4gIHN0YXJ0TnVtYmVyOiBmdW5jdGlvbiBzdGFydE51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgdGltZXNjYWxlIGluIHVuaXRzIHBlciBzZWNvbmRzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgYXByc2VkIHRpbWVzY2FsZVxuICAgKi9cbiAgdGltZXNjYWxlOiBmdW5jdGlvbiB0aW1lc2NhbGUodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGNvbnN0YW50IGFwcHJveGltYXRlIFNlZ21lbnQgZHVyYXRpb25cbiAgICogTk9URTogVGhlIDxQZXJpb2Q+IGVsZW1lbnQgYWxzbyBjb250YWlucyBhbiBAZHVyYXRpb24gYXR0cmlidXRlLiBUaGlzIGR1cmF0aW9uXG4gICAqICAgICAgIHNwZWNpZmllcyB0aGUgZHVyYXRpb24gb2YgdGhlIFBlcmlvZC4gVGhpcyBhdHRyaWJ1dGUgaXMgY3VycmVudGx5IG5vdFxuICAgKiAgICAgICBzdXBwb3J0ZWQgYnkgdGhlIHJlc3Qgb2YgdGhlIHBhcnNlciwgaG93ZXZlciB3ZSBzdGlsbCBjaGVjayBmb3IgaXQgdG8gcHJldmVudFxuICAgKiAgICAgICBlcnJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIGR1cmF0aW9uXG4gICAqL1xuICBkdXJhdGlvbjogZnVuY3Rpb24gZHVyYXRpb24odmFsdWUpIHtcbiAgICB2YXIgcGFyc2VkVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuXG4gICAgaWYgKGlzTmFOKHBhcnNlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlRHVyYXRpb24odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWRWYWx1ZTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIFNlZ21lbnQgZHVyYXRpb24sIGluIHVuaXRzIG9mIHRoZSB2YWx1ZSBvZiB0aGUgQHRpbWVzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgZHVyYXRpb25cbiAgICovXG4gIGQ6IGZ1bmN0aW9uIGQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIE1QRCBzdGFydCB0aW1lLCBpbiBAdGltZXNjYWxlIHVuaXRzLCB0aGUgZmlyc3QgU2VnbWVudCBpbiB0aGUgc2VyaWVzXG4gICAqIHN0YXJ0cyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQZXJpb2RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgdGltZVxuICAgKi9cbiAgdDogZnVuY3Rpb24gdCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgcmVwZWF0IGNvdW50IG9mIHRoZSBudW1iZXIgb2YgZm9sbG93aW5nIGNvbnRpZ3VvdXMgU2VnbWVudHMgd2l0aCB0aGVcbiAgICogc2FtZSBkdXJhdGlvbiBleHByZXNzZWQgYnkgdGhlIHZhbHVlIG9mIEBkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIG51bWJlclxuICAgKi9cbiAgcjogZnVuY3Rpb24gcih2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcGFyc2VyIGZvciBhbGwgb3RoZXIgYXR0cmlidXRlcy4gQWN0cyBhcyBhIG5vLW9wIGFuZCBqdXN0IHJldHVybnMgdGhlIHZhbHVlXG4gICAqIGFzIGEgc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBVbnBhcnNlZCB2YWx1ZVxuICAgKi9cbiAgREVGQVVMVDogZnVuY3Rpb24gREVGQVVMVCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIGFsbCB0aGUgYXR0cmlidXRlcyBhbmQgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBub2RlLCBwYXJzZXMgYXR0cmlidXRlcyB3aXRoIGtub3duXG4gKiB0eXBlcywgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggYXR0cmlidXRlIG5hbWVzIG1hcHBlZCB0byB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBlbFxuICogICAgICAgIFRoZSBub2RlIHRvIHBhcnNlIGF0dHJpYnV0ZXMgZnJvbVxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBPYmplY3Qgd2l0aCBhbGwgYXR0cmlidXRlcyBvZiBlbCBwYXJzZWRcbiAqL1xudmFyIHBhcnNlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyhlbCkge1xuICBpZiAoIShlbCAmJiBlbC5hdHRyaWJ1dGVzKSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHJldHVybiBmcm9tKGVsLmF0dHJpYnV0ZXMpLnJlZHVjZShmdW5jdGlvbiAoYSwgZSkge1xuICAgIHZhciBwYXJzZUZuID0gcGFyc2Vyc1tlLm5hbWVdIHx8IHBhcnNlcnMuREVGQVVMVDtcblxuICAgIGFbZS5uYW1lXSA9IHBhcnNlRm4oZS52YWx1ZSk7XG5cbiAgICByZXR1cm4gYTtcbiAgfSwge30pO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQjY0VG9VaW50OEFycmF5KGI2NFRleHQpIHtcbiAgdmFyIGRlY29kZWRTdHJpbmcgPSB3aW5kb3cuYXRvYihiNjRUZXh0KTtcbiAgdmFyIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGVjb2RlZFN0cmluZy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVjb2RlZFN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gZGVjb2RlZFN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxudmFyIGtleVN5c3RlbXNNYXAgPSB7XG4gICd1cm46dXVpZDoxMDc3ZWZlYy1jMGIyLTRkMDItYWNlMy0zYzFlNTJlMmZiNGInOiAnb3JnLnczLmNsZWFya2V5JyxcbiAgJ3Vybjp1dWlkOmVkZWY4YmE5LTc5ZDYtNGFjZS1hM2M4LTI3ZGNkNTFkMjFlZCc6ICdjb20ud2lkZXZpbmUuYWxwaGEnLFxuICAndXJuOnV1aWQ6OWEwNGYwNzktOTg0MC00Mjg2LWFiOTItZTY1YmUwODg1Zjk1JzogJ2NvbS5taWNyb3NvZnQucGxheXJlYWR5JyxcbiAgJ3Vybjp1dWlkOmYyMzllNzY5LWVmYTMtNDg1MC05YzE2LWE5MDNjNjkzMmVmYic6ICdjb20uYWRvYmUucHJpbWV0aW1lJ1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBsaXN0IG9mIHVybHMgdGhhdCBpcyB0aGUgcHJvZHVjdCBvZiB0aGUgcmVmZXJlbmNlIHVybHMgYW5kIEJhc2VVUkwgdmFsdWVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcmVmZXJlbmNlVXJsc1xuICogICAgICAgIExpc3Qgb2YgcmVmZXJlbmNlIHVybHMgdG8gcmVzb2x2ZSB0b1xuICogQHBhcmFtIHtOb2RlW119IGJhc2VVcmxFbGVtZW50c1xuICogICAgICAgIExpc3Qgb2YgQmFzZVVSTCBub2RlcyBmcm9tIHRoZSBtcGRcbiAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICogICAgICAgICBMaXN0IG9mIHJlc29sdmVkIHVybHNcbiAqL1xudmFyIGJ1aWxkQmFzZVVybHMgPSBmdW5jdGlvbiBidWlsZEJhc2VVcmxzKHJlZmVyZW5jZVVybHMsIGJhc2VVcmxFbGVtZW50cykge1xuICBpZiAoIWJhc2VVcmxFbGVtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmVmZXJlbmNlVXJscztcbiAgfVxuXG4gIHJldHVybiBmbGF0dGVuKHJlZmVyZW5jZVVybHMubWFwKGZ1bmN0aW9uIChyZWZlcmVuY2UpIHtcbiAgICByZXR1cm4gYmFzZVVybEVsZW1lbnRzLm1hcChmdW5jdGlvbiAoYmFzZVVybEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiByZXNvbHZlVXJsKHJlZmVyZW5jZSwgZ2V0Q29udGVudChiYXNlVXJsRWxlbWVudCkpO1xuICAgIH0pO1xuICB9KSk7XG59O1xuXG4vKipcbiAqIENvbnRhaW5zIGFsbCBTZWdtZW50IGluZm9ybWF0aW9uIGZvciBpdHMgY29udGFpbmluZyBBZGFwdGF0aW9uU2V0XG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gU2VnbWVudEluZm9ybWF0aW9uXG4gKiBAcHJvcGVydHkge09iamVjdHx1bmRlZmluZWR9IHRlbXBsYXRlXG4gKiAgICAgICAgICAgQ29udGFpbnMgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBTZWdtZW50VGVtcGxhdGUgbm9kZVxuICogQHByb3BlcnR5IHtPYmplY3RbXXx1bmRlZmluZWR9IHRpbWVsaW5lXG4gKiAgICAgICAgICAgQ29udGFpbnMgYSBsaXN0IG9mIGF0cnJpYnV0ZXMgZm9yIGVhY2ggUyBub2RlIHdpdGhpbiB0aGUgU2VnbWVudFRpbWVsaW5lIG5vZGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fHVuZGVmaW5lZH0gbGlzdFxuICogICAgICAgICAgIENvbnRhaW5zIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgU2VnbWVudExpc3Qgbm9kZVxuICogQHByb3BlcnR5IHtPYmplY3R8dW5kZWZpbmVkfSBiYXNlXG4gKiAgICAgICAgICAgQ29udGFpbnMgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBTZWdtZW50QmFzZSBub2RlXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBhdmFpbGFibGUgU2VnbWVudCBpbmZvcm1hdGlvbiBjb250YWluZWQgd2l0aGluIHRoZSBBZGFwdGF0aW9uU2V0IG5vZGVcbiAqXG4gKiBAcGFyYW0ge05vZGV9IGFkYXB0YXRpb25TZXRcbiAqICAgICAgICBUaGUgQWRhcHRhdGlvblNldCBub2RlIHRvIGdldCBTZWdtZW50IGluZm9ybWF0aW9uIGZyb21cbiAqIEByZXR1cm4ge1NlZ21lbnRJbmZvcm1hdGlvbn1cbiAqICAgICAgICAgVGhlIFNlZ21lbnQgaW5mb3JtYXRpb24gY29udGFpbmVkIHdpdGhpbiB0aGUgcHJvdmlkZWQgQWRhcHRhdGlvblNldFxuICovXG52YXIgZ2V0U2VnbWVudEluZm9ybWF0aW9uID0gZnVuY3Rpb24gZ2V0U2VnbWVudEluZm9ybWF0aW9uKGFkYXB0YXRpb25TZXQpIHtcbiAgdmFyIHNlZ21lbnRUZW1wbGF0ZSA9IGZpbmRDaGlsZHJlbihhZGFwdGF0aW9uU2V0LCAnU2VnbWVudFRlbXBsYXRlJylbMF07XG4gIHZhciBzZWdtZW50TGlzdCA9IGZpbmRDaGlsZHJlbihhZGFwdGF0aW9uU2V0LCAnU2VnbWVudExpc3QnKVswXTtcbiAgdmFyIHNlZ21lbnRVcmxzID0gc2VnbWVudExpc3QgJiYgZmluZENoaWxkcmVuKHNlZ21lbnRMaXN0LCAnU2VnbWVudFVSTCcpLm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBtZXJnZSh7IHRhZzogJ1NlZ21lbnRVUkwnIH0sIHBhcnNlQXR0cmlidXRlcyhzKSk7XG4gIH0pO1xuICB2YXIgc2VnbWVudEJhc2UgPSBmaW5kQ2hpbGRyZW4oYWRhcHRhdGlvblNldCwgJ1NlZ21lbnRCYXNlJylbMF07XG4gIHZhciBzZWdtZW50VGltZWxpbmVQYXJlbnROb2RlID0gc2VnbWVudExpc3QgfHwgc2VnbWVudFRlbXBsYXRlO1xuICB2YXIgc2VnbWVudFRpbWVsaW5lID0gc2VnbWVudFRpbWVsaW5lUGFyZW50Tm9kZSAmJiBmaW5kQ2hpbGRyZW4oc2VnbWVudFRpbWVsaW5lUGFyZW50Tm9kZSwgJ1NlZ21lbnRUaW1lbGluZScpWzBdO1xuICB2YXIgc2VnbWVudEluaXRpYWxpemF0aW9uUGFyZW50Tm9kZSA9IHNlZ21lbnRMaXN0IHx8IHNlZ21lbnRCYXNlIHx8IHNlZ21lbnRUZW1wbGF0ZTtcbiAgdmFyIHNlZ21lbnRJbml0aWFsaXphdGlvbiA9IHNlZ21lbnRJbml0aWFsaXphdGlvblBhcmVudE5vZGUgJiYgZmluZENoaWxkcmVuKHNlZ21lbnRJbml0aWFsaXphdGlvblBhcmVudE5vZGUsICdJbml0aWFsaXphdGlvbicpWzBdO1xuXG4gIC8vIFNlZ21lbnRUZW1wbGF0ZSBpcyBoYW5kbGVkIHNsaWdodGx5IGRpZmZlcmVudGx5LCBzaW5jZSBpdCBjYW4gaGF2ZSBib3RoXG4gIC8vIEBpbml0aWFsaXphdGlvbiBhbmQgYW4gPEluaXRpYWxpemF0aW9uPiBub2RlLiAgQGluaXRpYWxpemF0aW9uIGNhbiBiZSB0ZW1wbGF0ZWQsXG4gIC8vIHdoaWxlIHRoZSBub2RlIGNhbiBoYXZlIGEgdXJsIGFuZCByYW5nZSBzcGVjaWZpZWQuICBJZiB0aGUgPFNlZ21lbnRUZW1wbGF0ZT4gaGFzXG4gIC8vIGJvdGggQGluaXRpYWxpemF0aW9uIGFuZCBhbiA8SW5pdGlhbGl6YXRpb24+IHN1YmVsZW1lbnQgd2Ugb3B0IHRvIG92ZXJyaWRlIHdpdGhcbiAgLy8gdGhlIG5vZGUsIGFzIHRoaXMgaW50ZXJhY3Rpb24gaXMgbm90IGRlZmluZWQgaW4gdGhlIHNwZWMuXG4gIHZhciB0ZW1wbGF0ZSA9IHNlZ21lbnRUZW1wbGF0ZSAmJiBwYXJzZUF0dHJpYnV0ZXMoc2VnbWVudFRlbXBsYXRlKTtcblxuICBpZiAodGVtcGxhdGUgJiYgc2VnbWVudEluaXRpYWxpemF0aW9uKSB7XG4gICAgdGVtcGxhdGUuaW5pdGlhbGl6YXRpb24gPSBzZWdtZW50SW5pdGlhbGl6YXRpb24gJiYgcGFyc2VBdHRyaWJ1dGVzKHNlZ21lbnRJbml0aWFsaXphdGlvbik7XG4gIH0gZWxzZSBpZiAodGVtcGxhdGUgJiYgdGVtcGxhdGUuaW5pdGlhbGl6YXRpb24pIHtcbiAgICAvLyBJZiBpdCBpcyBAaW5pdGlhbGl6YXRpb24gd2UgY29udmVydCBpdCB0byBhbiBvYmplY3Qgc2luY2UgdGhpcyBpcyB0aGUgZm9ybWF0IHRoYXRcbiAgICAvLyBsYXRlciBmdW5jdGlvbnMgd2lsbCByZWx5IG9uIGZvciB0aGUgaW5pdGlhbGl6YXRpb24gc2VnbWVudC4gIFRoaXMgaXMgb25seSB2YWxpZFxuICAgIC8vIGZvciA8U2VnbWVudFRlbXBsYXRlPlxuICAgIHRlbXBsYXRlLmluaXRpYWxpemF0aW9uID0geyBzb3VyY2VVUkw6IHRlbXBsYXRlLmluaXRpYWxpemF0aW9uIH07XG4gIH1cblxuICB2YXIgc2VnbWVudEluZm8gPSB7XG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgIHRpbWVsaW5lOiBzZWdtZW50VGltZWxpbmUgJiYgZmluZENoaWxkcmVuKHNlZ21lbnRUaW1lbGluZSwgJ1MnKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBwYXJzZUF0dHJpYnV0ZXMocyk7XG4gICAgfSksXG4gICAgbGlzdDogc2VnbWVudExpc3QgJiYgbWVyZ2UocGFyc2VBdHRyaWJ1dGVzKHNlZ21lbnRMaXN0KSwge1xuICAgICAgc2VnbWVudFVybHM6IHNlZ21lbnRVcmxzLFxuICAgICAgaW5pdGlhbGl6YXRpb246IHBhcnNlQXR0cmlidXRlcyhzZWdtZW50SW5pdGlhbGl6YXRpb24pXG4gICAgfSksXG4gICAgYmFzZTogc2VnbWVudEJhc2UgJiYgbWVyZ2UocGFyc2VBdHRyaWJ1dGVzKHNlZ21lbnRCYXNlKSwge1xuICAgICAgaW5pdGlhbGl6YXRpb246IHBhcnNlQXR0cmlidXRlcyhzZWdtZW50SW5pdGlhbGl6YXRpb24pXG4gICAgfSlcbiAgfTtcblxuICBPYmplY3Qua2V5cyhzZWdtZW50SW5mbykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFzZWdtZW50SW5mb1trZXldKSB7XG4gICAgICBkZWxldGUgc2VnbWVudEluZm9ba2V5XTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzZWdtZW50SW5mbztcbn07XG5cbi8qKlxuICogQ29udGFpbnMgU2VnbWVudCBpbmZvcm1hdGlvbiBhbmQgYXR0cmlidXRlcyBuZWVkZWQgdG8gY29uc3RydWN0IGEgUGxheWxpc3Qgb2JqZWN0XG4gKiBmcm9tIGEgUmVwcmVzZW50YXRpb25cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZXByZXNlbnRhdGlvbkluZm9ybWF0aW9uXG4gKiBAcHJvcGVydHkge1NlZ21lbnRJbmZvcm1hdGlvbn0gc2VnbWVudEluZm9cbiAqICAgICAgICAgICBTZWdtZW50IGluZm9ybWF0aW9uIGZvciB0aGlzIFJlcHJlc2VudGF0aW9uXG4gKiBAcHJvcGVydHkge09iamVjdH0gYXR0cmlidXRlc1xuICogICAgICAgICAgIEluaGVyaXRlZCBhdHRyaWJ1dGVzIGZvciB0aGlzIFJlcHJlc2VudGF0aW9uXG4gKi9cblxuLyoqXG4gKiBNYXBzIGEgUmVwcmVzZW50YXRpb24gbm9kZSB0byBhbiBvYmplY3QgY29udGFpbmluZyBTZWdtZW50IGluZm9ybWF0aW9uIGFuZCBhdHRyaWJ1dGVzXG4gKlxuICogQG5hbWUgaW5oZXJpdEJhc2VVcmxzQ2FsbGJhY2tcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtOb2RlfSByZXByZXNlbnRhdGlvblxuICogICAgICAgIFJlcHJlc2VudGF0aW9uIG5vZGUgZnJvbSB0aGUgbXBkXG4gKiBAcmV0dXJuIHtSZXByZXNlbnRhdGlvbkluZm9ybWF0aW9ufVxuICogICAgICAgICBSZXByZXNlbnRhdGlvbiBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gY29uc3RydWN0IGEgUGxheWxpc3Qgb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgY2FsbGJhY2sgZm9yIEFycmF5LnByb3RvdHlwZS5tYXAgZm9yIG1hcHBpbmcgUmVwcmVzZW50YXRpb24gbm9kZXMgdG9cbiAqIFNlZ21lbnQgaW5mb3JtYXRpb24gYW5kIGF0dHJpYnV0ZXMgdXNpbmcgaW5oZXJpdGVkIEJhc2VVUkwgbm9kZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFkYXB0YXRpb25TZXRBdHRyaWJ1dGVzXG4gKiAgICAgICAgQ29udGFpbnMgYXR0cmlidXRlcyBpbmhlcml0ZWQgYnkgdGhlIEFkYXB0YXRpb25TZXRcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFkYXB0YXRpb25TZXRCYXNlVXJsc1xuICogICAgICAgIENvbnRhaW5zIGxpc3Qgb2YgcmVzb2x2ZWQgYmFzZSB1cmxzIGluaGVyaXRlZCBieSB0aGUgQWRhcHRhdGlvblNldFxuICogQHBhcmFtIHtTZWdtZW50SW5mb3JtYXRpb259IGFkYXB0YXRpb25TZXRTZWdtZW50SW5mb1xuICogICAgICAgIENvbnRhaW5zIFNlZ21lbnQgaW5mb3JtYXRpb24gZm9yIHRoZSBBZGFwdGF0aW9uU2V0XG4gKiBAcmV0dXJuIHtpbmhlcml0QmFzZVVybHNDYWxsYmFja31cbiAqICAgICAgICAgQ2FsbGJhY2sgbWFwIGZ1bmN0aW9uXG4gKi9cbnZhciBpbmhlcml0QmFzZVVybHMgPSBmdW5jdGlvbiBpbmhlcml0QmFzZVVybHMoYWRhcHRhdGlvblNldEF0dHJpYnV0ZXMsIGFkYXB0YXRpb25TZXRCYXNlVXJscywgYWRhcHRhdGlvblNldFNlZ21lbnRJbmZvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVwcmVzZW50YXRpb24pIHtcbiAgICB2YXIgcmVwQmFzZVVybEVsZW1lbnRzID0gZmluZENoaWxkcmVuKHJlcHJlc2VudGF0aW9uLCAnQmFzZVVSTCcpO1xuICAgIHZhciByZXBCYXNlVXJscyA9IGJ1aWxkQmFzZVVybHMoYWRhcHRhdGlvblNldEJhc2VVcmxzLCByZXBCYXNlVXJsRWxlbWVudHMpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gbWVyZ2UoYWRhcHRhdGlvblNldEF0dHJpYnV0ZXMsIHBhcnNlQXR0cmlidXRlcyhyZXByZXNlbnRhdGlvbikpO1xuICAgIHZhciByZXByZXNlbnRhdGlvblNlZ21lbnRJbmZvID0gZ2V0U2VnbWVudEluZm9ybWF0aW9uKHJlcHJlc2VudGF0aW9uKTtcblxuICAgIHJldHVybiByZXBCYXNlVXJscy5tYXAoZnVuY3Rpb24gKGJhc2VVcmwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlZ21lbnRJbmZvOiBtZXJnZShhZGFwdGF0aW9uU2V0U2VnbWVudEluZm8sIHJlcHJlc2VudGF0aW9uU2VnbWVudEluZm8pLFxuICAgICAgICBhdHRyaWJ1dGVzOiBtZXJnZShhdHRyaWJ1dGVzLCB7IGJhc2VVcmw6IGJhc2VVcmwgfSlcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFRyYW5mb3JtcyBhIHNlcmllcyBvZiBjb250ZW50IHByb3RlY3Rpb24gbm9kZXMgdG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHBzc2ggZGF0YSBieSBrZXkgc3lzdGVtXG4gKlxuICogQHBhcmFtIHtOb2RlW119IGNvbnRlbnRQcm90ZWN0aW9uTm9kZXNcbiAqICAgICAgICBDb250ZW50IHByb3RlY3Rpb24gbm9kZXNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyBwc3NoIGRhdGEgYnkga2V5IHN5c3RlbVxuICovXG52YXIgZ2VuZXJhdGVLZXlTeXN0ZW1JbmZvcm1hdGlvbiA9IGZ1bmN0aW9uIGdlbmVyYXRlS2V5U3lzdGVtSW5mb3JtYXRpb24oY29udGVudFByb3RlY3Rpb25Ob2Rlcykge1xuICByZXR1cm4gY29udGVudFByb3RlY3Rpb25Ob2Rlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbm9kZSkge1xuICAgIHZhciBhdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKG5vZGUpO1xuICAgIHZhciBrZXlTeXN0ZW0gPSBrZXlTeXN0ZW1zTWFwW2F0dHJpYnV0ZXMuc2NoZW1lSWRVcmldO1xuXG4gICAgaWYgKGtleVN5c3RlbSkge1xuICAgICAgYWNjW2tleVN5c3RlbV0gPSB7IGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMgfTtcblxuICAgICAgdmFyIHBzc2hOb2RlID0gZmluZENoaWxkcmVuKG5vZGUsICdjZW5jOnBzc2gnKVswXTtcblxuICAgICAgaWYgKHBzc2hOb2RlKSB7XG4gICAgICAgIHZhciBwc3NoID0gZ2V0Q29udGVudChwc3NoTm9kZSk7XG4gICAgICAgIHZhciBwc3NoQnVmZmVyID0gcHNzaCAmJiBkZWNvZGVCNjRUb1VpbnQ4QXJyYXkocHNzaCk7XG5cbiAgICAgICAgYWNjW2tleVN5c3RlbV0ucHNzaCA9IHBzc2hCdWZmZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBNYXBzIGFuIEFkYXB0YXRpb25TZXQgbm9kZSB0byBhIGxpc3Qgb2YgUmVwcmVzZW50YXRpb24gaW5mb3JtYXRpb24gb2JqZWN0c1xuICpcbiAqIEBuYW1lIHRvUmVwcmVzZW50YXRpb25zQ2FsbGJhY2tcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtOb2RlfSBhZGFwdGF0aW9uU2V0XG4gKiAgICAgICAgQWRhcHRhdGlvblNldCBub2RlIGZyb20gdGhlIG1wZFxuICogQHJldHVybiB7UmVwcmVzZW50YXRpb25JbmZvcm1hdGlvbltdfVxuICogICAgICAgICBMaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBSZXByZXNlbnRhaW9uIGluZm9ybWF0aW9uXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgY2FsbGJhY2sgZm9yIEFycmF5LnByb3RvdHlwZS5tYXAgZm9yIG1hcHBpbmcgQWRhcHRhdGlvblNldCBub2RlcyB0byBhIGxpc3Qgb2ZcbiAqIFJlcHJlc2VudGF0aW9uIGluZm9ybWF0aW9uIG9iamVjdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGVyaW9kQXR0cmlidXRlc1xuICogICAgICAgIENvbnRhaW5zIGF0dHJpYnV0ZXMgaW5oZXJpdGVkIGJ5IHRoZSBQZXJpb2RcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBlcmlvZEJhc2VVcmxzXG4gKiAgICAgICAgQ29udGFpbnMgbGlzdCBvZiByZXNvbHZlZCBiYXNlIHVybHMgaW5oZXJpdGVkIGJ5IHRoZSBQZXJpb2RcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBlcmlvZFNlZ21lbnRJbmZvXG4gKiAgICAgICAgQ29udGFpbnMgU2VnbWVudCBJbmZvcm1hdGlvbiBhdCB0aGUgcGVyaW9kIGxldmVsXG4gKiBAcmV0dXJuIHt0b1JlcHJlc2VudGF0aW9uc0NhbGxiYWNrfVxuICogICAgICAgICBDYWxsYmFjayBtYXAgZnVuY3Rpb25cbiAqL1xudmFyIHRvUmVwcmVzZW50YXRpb25zID0gZnVuY3Rpb24gdG9SZXByZXNlbnRhdGlvbnMocGVyaW9kQXR0cmlidXRlcywgcGVyaW9kQmFzZVVybHMsIHBlcmlvZFNlZ21lbnRJbmZvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYWRhcHRhdGlvblNldCkge1xuICAgIHZhciBhZGFwdGF0aW9uU2V0QXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhhZGFwdGF0aW9uU2V0KTtcbiAgICB2YXIgYWRhcHRhdGlvblNldEJhc2VVcmxzID0gYnVpbGRCYXNlVXJscyhwZXJpb2RCYXNlVXJscywgZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdCYXNlVVJMJykpO1xuICAgIHZhciByb2xlID0gZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdSb2xlJylbMF07XG4gICAgdmFyIHJvbGVBdHRyaWJ1dGVzID0geyByb2xlOiBwYXJzZUF0dHJpYnV0ZXMocm9sZSkgfTtcblxuICAgIHZhciBhdHRycyA9IG1lcmdlKHBlcmlvZEF0dHJpYnV0ZXMsIGFkYXB0YXRpb25TZXRBdHRyaWJ1dGVzLCByb2xlQXR0cmlidXRlcyk7XG5cbiAgICB2YXIgY29udGVudFByb3RlY3Rpb24gPSBnZW5lcmF0ZUtleVN5c3RlbUluZm9ybWF0aW9uKGZpbmRDaGlsZHJlbihhZGFwdGF0aW9uU2V0LCAnQ29udGVudFByb3RlY3Rpb24nKSk7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoY29udGVudFByb3RlY3Rpb24pLmxlbmd0aCkge1xuICAgICAgYXR0cnMgPSBtZXJnZShhdHRycywgeyBjb250ZW50UHJvdGVjdGlvbjogY29udGVudFByb3RlY3Rpb24gfSk7XG4gICAgfVxuXG4gICAgdmFyIHNlZ21lbnRJbmZvID0gZ2V0U2VnbWVudEluZm9ybWF0aW9uKGFkYXB0YXRpb25TZXQpO1xuICAgIHZhciByZXByZXNlbnRhdGlvbnMgPSBmaW5kQ2hpbGRyZW4oYWRhcHRhdGlvblNldCwgJ1JlcHJlc2VudGF0aW9uJyk7XG4gICAgdmFyIGFkYXB0YXRpb25TZXRTZWdtZW50SW5mbyA9IG1lcmdlKHBlcmlvZFNlZ21lbnRJbmZvLCBzZWdtZW50SW5mbyk7XG5cbiAgICByZXR1cm4gZmxhdHRlbihyZXByZXNlbnRhdGlvbnMubWFwKGluaGVyaXRCYXNlVXJscyhhdHRycywgYWRhcHRhdGlvblNldEJhc2VVcmxzLCBhZGFwdGF0aW9uU2V0U2VnbWVudEluZm8pKSk7XG4gIH07XG59O1xuXG4vKipcbiAqIE1hcHMgYW4gUGVyaW9kIG5vZGUgdG8gYSBsaXN0IG9mIFJlcHJlc2VudGF0aW9uIGluZm9yYW10aW9uIG9iamVjdHMgZm9yIGFsbFxuICogQWRhcHRhdGlvblNldCBub2RlcyBjb250YWluZWQgd2l0aGluIHRoZSBQZXJpb2RcbiAqXG4gKiBAbmFtZSB0b0FkYXB0YXRpb25TZXRzQ2FsbGJhY2tcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtOb2RlfSBwZXJpb2RcbiAqICAgICAgICBQZXJpb2Qgbm9kZSBmcm9tIHRoZSBtcGRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwZXJpb2RJbmRleFxuICogICAgICAgIEluZGV4IG9mIHRoZSBQZXJpb2Qgd2l0aGluIHRoZSBtcGRcbiAqIEByZXR1cm4ge1JlcHJlc2VudGF0aW9uSW5mb3JtYXRpb25bXX1cbiAqICAgICAgICAgTGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgUmVwcmVzZW50YWlvbiBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIGNhbGxiYWNrIGZvciBBcnJheS5wcm90b3R5cGUubWFwIGZvciBtYXBwaW5nIFBlcmlvZCBub2RlcyB0byBhIGxpc3Qgb2ZcbiAqIFJlcHJlc2VudGF0aW9uIGluZm9ybWF0aW9uIG9iamVjdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbXBkQXR0cmlidXRlc1xuICogICAgICAgIENvbnRhaW5zIGF0dHJpYnV0ZXMgaW5oZXJpdGVkIGJ5IHRoZSBtcGRcbiAqIEBwYXJhbSB7c3RyaW5nW119IG1wZEJhc2VVcmxzXG4gKiAgICAgICAgQ29udGFpbnMgbGlzdCBvZiByZXNvbHZlZCBiYXNlIHVybHMgaW5oZXJpdGVkIGJ5IHRoZSBtcGRcbiAqIEByZXR1cm4ge3RvQWRhcHRhdGlvblNldHNDYWxsYmFja31cbiAqICAgICAgICAgQ2FsbGJhY2sgbWFwIGZ1bmN0aW9uXG4gKi9cbnZhciB0b0FkYXB0YXRpb25TZXRzID0gZnVuY3Rpb24gdG9BZGFwdGF0aW9uU2V0cyhtcGRBdHRyaWJ1dGVzLCBtcGRCYXNlVXJscykge1xuICByZXR1cm4gZnVuY3Rpb24gKHBlcmlvZCwgcGVyaW9kSW5kZXgpIHtcbiAgICB2YXIgcGVyaW9kQmFzZVVybHMgPSBidWlsZEJhc2VVcmxzKG1wZEJhc2VVcmxzLCBmaW5kQ2hpbGRyZW4ocGVyaW9kLCAnQmFzZVVSTCcpKTtcbiAgICB2YXIgcGVyaW9kQXR0ID0gcGFyc2VBdHRyaWJ1dGVzKHBlcmlvZCk7XG4gICAgdmFyIHBlcmlvZEF0dHJpYnV0ZXMgPSBtZXJnZShtcGRBdHRyaWJ1dGVzLCBwZXJpb2RBdHQsIHsgcGVyaW9kSW5kZXg6IHBlcmlvZEluZGV4IH0pO1xuICAgIHZhciBhZGFwdGF0aW9uU2V0cyA9IGZpbmRDaGlsZHJlbihwZXJpb2QsICdBZGFwdGF0aW9uU2V0Jyk7XG4gICAgdmFyIHBlcmlvZFNlZ21lbnRJbmZvID0gZ2V0U2VnbWVudEluZm9ybWF0aW9uKHBlcmlvZCk7XG5cbiAgICByZXR1cm4gZmxhdHRlbihhZGFwdGF0aW9uU2V0cy5tYXAodG9SZXByZXNlbnRhdGlvbnMocGVyaW9kQXR0cmlidXRlcywgcGVyaW9kQmFzZVVybHMsIHBlcmlvZFNlZ21lbnRJbmZvKSkpO1xuICB9O1xufTtcblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIG1wZCB4bWwgdHJlZSB0byBnZW5lcmF0ZSBhIGxpc3Qgb2YgUmVwcmVzZW50YXRpb24gaW5mb3JtYXRpb24gb2JqZWN0c1xuICogdGhhdCBoYXZlIGluaGVyaXRlZCBhdHRyaWJ1dGVzIGZyb20gcGFyZW50IG5vZGVzXG4gKlxuICogQHBhcmFtIHtOb2RlfSBtcGRcbiAqICAgICAgICBUaGUgcm9vdCBub2RlIG9mIHRoZSBtcGRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnMgZm9yIGluaGVyaXRBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5tYW5pZmVzdFVyaVxuICogICAgICAgIFRoZSB1cmkgc291cmNlIG9mIHRoZSBtcGRcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLk5PV1xuICogICAgICAgIEN1cnJlbnQgdGltZSBwZXIgREFTSCBJT1AuICBEZWZhdWx0IGlzIGN1cnJlbnQgdGltZSBpbiBtcyBzaW5jZSBlcG9jaFxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2xpZW50T2Zmc2V0XG4gKiAgICAgICAgQ2xpZW50IHRpbWUgZGlmZmVyZW5jZSBmcm9tIE5PVyAoaW4gbWlsbGlzZWNvbmRzKVxuICogQHJldHVybiB7UmVwcmVzZW50YXRpb25JbmZvcm1hdGlvbltdfVxuICogICAgICAgICBMaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBSZXByZXNlbnRhdGlvbiBpbmZvcm1hdGlvblxuICovXG52YXIgaW5oZXJpdEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBpbmhlcml0QXR0cmlidXRlcyhtcGQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgX29wdGlvbnMkbWFuaWZlc3RVcmkgPSBvcHRpb25zLm1hbmlmZXN0VXJpLFxuICAgICAgbWFuaWZlc3RVcmkgPSBfb3B0aW9ucyRtYW5pZmVzdFVyaSA9PT0gdW5kZWZpbmVkID8gJycgOiBfb3B0aW9ucyRtYW5pZmVzdFVyaSxcbiAgICAgIF9vcHRpb25zJE5PVyA9IG9wdGlvbnMuTk9XLFxuICAgICAgTk9XID0gX29wdGlvbnMkTk9XID09PSB1bmRlZmluZWQgPyBEYXRlLm5vdygpIDogX29wdGlvbnMkTk9XLFxuICAgICAgX29wdGlvbnMkY2xpZW50T2Zmc2V0ID0gb3B0aW9ucy5jbGllbnRPZmZzZXQsXG4gICAgICBjbGllbnRPZmZzZXQgPSBfb3B0aW9ucyRjbGllbnRPZmZzZXQgPT09IHVuZGVmaW5lZCA/IDAgOiBfb3B0aW9ucyRjbGllbnRPZmZzZXQ7XG5cbiAgdmFyIHBlcmlvZHMgPSBmaW5kQ2hpbGRyZW4obXBkLCAnUGVyaW9kJyk7XG5cbiAgaWYgKHBlcmlvZHMubGVuZ3RoICE9PSAxKSB7XG4gICAgLy8gVE9ETyBhZGQgc3VwcG9ydCBmb3IgbXVsdGlwZXJpb2RcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklOVkFMSURfTlVNQkVSX09GX1BFUklPRCk7XG4gIH1cblxuICB2YXIgbXBkQXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhtcGQpO1xuICB2YXIgbXBkQmFzZVVybHMgPSBidWlsZEJhc2VVcmxzKFttYW5pZmVzdFVyaV0sIGZpbmRDaGlsZHJlbihtcGQsICdCYXNlVVJMJykpO1xuXG4gIG1wZEF0dHJpYnV0ZXMuc291cmNlRHVyYXRpb24gPSBtcGRBdHRyaWJ1dGVzLm1lZGlhUHJlc2VudGF0aW9uRHVyYXRpb24gfHwgMDtcbiAgbXBkQXR0cmlidXRlcy5OT1cgPSBOT1c7XG4gIG1wZEF0dHJpYnV0ZXMuY2xpZW50T2Zmc2V0ID0gY2xpZW50T2Zmc2V0O1xuXG4gIHJldHVybiBmbGF0dGVuKHBlcmlvZHMubWFwKHRvQWRhcHRhdGlvblNldHMobXBkQXR0cmlidXRlcywgbXBkQmFzZVVybHMpKSk7XG59O1xuXG52YXIgc3RyaW5nVG9NcGRYbWwgPSBmdW5jdGlvbiBzdHJpbmdUb01wZFhtbChtYW5pZmVzdFN0cmluZykge1xuICBpZiAobWFuaWZlc3RTdHJpbmcgPT09ICcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5EQVNIX0VNUFRZX01BTklGRVNUKTtcbiAgfVxuXG4gIHZhciBwYXJzZXIgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpO1xuICB2YXIgeG1sID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhtYW5pZmVzdFN0cmluZywgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICB2YXIgbXBkID0geG1sICYmIHhtbC5kb2N1bWVudEVsZW1lbnQudGFnTmFtZSA9PT0gJ01QRCcgPyB4bWwuZG9jdW1lbnRFbGVtZW50IDogbnVsbDtcblxuICBpZiAoIW1wZCB8fCBtcGQgJiYgbXBkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLkRBU0hfSU5WQUxJRF9YTUwpO1xuICB9XG5cbiAgcmV0dXJuIG1wZDtcbn07XG5cbi8qKlxuICogUGFyc2VzIHRoZSBtYW5pZmVzdCBmb3IgYSBVVENUaW1pbmcgbm9kZSwgcmV0dXJuaW5nIHRoZSBub2RlcyBhdHRyaWJ1dGVzIGlmIGZvdW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1wZFxuICogICAgICAgIFhNTCBzdHJpbmcgb2YgdGhlIE1QRCBtYW5pZmVzdFxuICogQHJldHVybiB7T2JqZWN0fG51bGx9XG4gKiAgICAgICAgIEF0dHJpYnV0ZXMgb2YgVVRDVGltaW5nIG5vZGUgc3BlY2lmaWVkIGluIHRoZSBtYW5pZmVzdC4gTnVsbCBpZiBub25lIGZvdW5kXG4gKi9cbnZhciBwYXJzZVVUQ1RpbWluZ1NjaGVtZSA9IGZ1bmN0aW9uIHBhcnNlVVRDVGltaW5nU2NoZW1lKG1wZCkge1xuICB2YXIgVVRDVGltaW5nTm9kZSA9IGZpbmRDaGlsZHJlbihtcGQsICdVVENUaW1pbmcnKVswXTtcblxuICBpZiAoIVVUQ1RpbWluZ05vZGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKFVUQ1RpbWluZ05vZGUpO1xuXG4gIHN3aXRjaCAoYXR0cmlidXRlcy5zY2hlbWVJZFVyaSkge1xuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAtaGVhZDoyMDE0JzpcbiAgICBjYXNlICd1cm46bXBlZzpkYXNoOnV0YzpodHRwLWhlYWQ6MjAxMic6XG4gICAgICBhdHRyaWJ1dGVzLm1ldGhvZCA9ICdIRUFEJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAteHNkYXRlOjIwMTQnOlxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAtaXNvOjIwMTQnOlxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAteHNkYXRlOjIwMTInOlxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAtaXNvOjIwMTInOlxuICAgICAgYXR0cmlidXRlcy5tZXRob2QgPSAnR0VUJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmRpcmVjdDoyMDE0JzpcbiAgICBjYXNlICd1cm46bXBlZzpkYXNoOnV0YzpkaXJlY3Q6MjAxMic6XG4gICAgICBhdHRyaWJ1dGVzLm1ldGhvZCA9ICdESVJFQ1QnO1xuICAgICAgYXR0cmlidXRlcy52YWx1ZSA9IERhdGUucGFyc2UoYXR0cmlidXRlcy52YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1cm46bXBlZzpkYXNoOnV0YzpodHRwLW50cDoyMDE0JzpcbiAgICBjYXNlICd1cm46bXBlZzpkYXNoOnV0YzpudHA6MjAxNCc6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6c250cDoyMDE0JzpcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5VTlNVUFBPUlRFRF9VVENfVElNSU5HX1NDSEVNRSk7XG4gIH1cblxuICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cbnZhciBWRVJTSU9OID0gdmVyc2lvbjtcblxudmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2UobWFuaWZlc3RTdHJpbmcsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRvTTN1OCh0b1BsYXlsaXN0cyhpbmhlcml0QXR0cmlidXRlcyhzdHJpbmdUb01wZFhtbChtYW5pZmVzdFN0cmluZyksIG9wdGlvbnMpKSk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgbWFuaWZlc3QgZm9yIGEgVVRDVGltaW5nIG5vZGUsIHJldHVybmluZyB0aGUgbm9kZXMgYXR0cmlidXRlcyBpZiBmb3VuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYW5pZmVzdFN0cmluZ1xuICogICAgICAgIFhNTCBzdHJpbmcgb2YgdGhlIE1QRCBtYW5pZmVzdFxuICogQHJldHVybiB7T2JqZWN0fG51bGx9XG4gKiAgICAgICAgIEF0dHJpYnV0ZXMgb2YgVVRDVGltaW5nIG5vZGUgc3BlY2lmaWVkIGluIHRoZSBtYW5pZmVzdC4gTnVsbCBpZiBub25lIGZvdW5kXG4gKi9cbnZhciBwYXJzZVVUQ1RpbWluZyA9IGZ1bmN0aW9uIHBhcnNlVVRDVGltaW5nKG1hbmlmZXN0U3RyaW5nKSB7XG4gIHJldHVybiBwYXJzZVVUQ1RpbWluZ1NjaGVtZShzdHJpbmdUb01wZFhtbChtYW5pZmVzdFN0cmluZykpO1xufTtcblxuZXhwb3J0IHsgVkVSU0lPTiwgcGFyc2UsIHBhcnNlVVRDVGltaW5nIH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mpd-parser/dist/mpd-parser.es.js\n");

/***/ }),

/***/ "./node_modules/mux.js/lib/aac/probe.js":
/*!**********************************************!*\
  !*** ./node_modules/mux.js/lib/aac/probe.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Utilities to detect basic properties and metadata about Aac data.\n */\n\n\nvar ADTS_SAMPLING_FREQUENCIES = [\n  96000,\n  88200,\n  64000,\n  48000,\n  44100,\n  32000,\n  24000,\n  22050,\n  16000,\n  12000,\n  11025,\n  8000,\n  7350\n];\n\nvar parseSyncSafeInteger = function(data) {\n  return (data[0] << 21) |\n          (data[1] << 14) |\n          (data[2] << 7) |\n          (data[3]);\n};\n\n// return a percent-encoded representation of the specified byte range\n// @see http://en.wikipedia.org/wiki/Percent-encoding\nvar percentEncode = function(bytes, start, end) {\n  var i, result = '';\n  for (i = start; i < end; i++) {\n    result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n  }\n  return result;\n};\n\n// return the string representation of the specified byte range,\n// interpreted as ISO-8859-1.\nvar parseIso88591 = function(bytes, start, end) {\n  return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n};\n\nvar parseId3TagSize = function(header, byteIndex) {\n  var\n    returnSize = (header[byteIndex + 6] << 21) |\n                 (header[byteIndex + 7] << 14) |\n                 (header[byteIndex + 8] << 7) |\n                 (header[byteIndex + 9]),\n    flags = header[byteIndex + 5],\n    footerPresent = (flags & 16) >> 4;\n\n  if (footerPresent) {\n    return returnSize + 20;\n  }\n  return returnSize + 10;\n};\n\nvar parseAdtsSize = function(header, byteIndex) {\n  var\n    lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n    middle = header[byteIndex + 4] << 3,\n    highTwo = header[byteIndex + 3] & 0x3 << 11;\n\n  return (highTwo | middle) | lowThree;\n};\n\nvar parseType = function(header, byteIndex) {\n  if ((header[byteIndex] === 'I'.charCodeAt(0)) &&\n      (header[byteIndex + 1] === 'D'.charCodeAt(0)) &&\n      (header[byteIndex + 2] === '3'.charCodeAt(0))) {\n    return 'timed-metadata';\n  } else if ((header[byteIndex] & 0xff === 0xff) &&\n             ((header[byteIndex + 1] & 0xf0) === 0xf0)) {\n    return 'audio';\n  }\n  return null;\n};\n\nvar parseSampleRate = function(packet) {\n  var i = 0;\n\n  while (i + 5 < packet.length) {\n    if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {\n      // If a valid header was not found,  jump one forward and attempt to\n      // find a valid ADTS header starting at the next byte\n      i++;\n      continue;\n    }\n    return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 0x3c) >>> 2];\n  }\n\n  return null;\n};\n\nvar parseAacTimestamp = function(packet) {\n  var frameStart, frameSize, frame, frameHeader;\n\n  // find the start of the first frame and the end of the tag\n  frameStart = 10;\n  if (packet[5] & 0x40) {\n    // advance the frame start past the extended header\n    frameStart += 4; // header size field\n    frameStart += parseSyncSafeInteger(packet.subarray(10, 14));\n  }\n\n  // parse one or more ID3 frames\n  // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n  do {\n    // determine the number of bytes in this frame\n    frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));\n    if (frameSize < 1) {\n      return null;\n    }\n    frameHeader = String.fromCharCode(packet[frameStart],\n                                      packet[frameStart + 1],\n                                      packet[frameStart + 2],\n                                      packet[frameStart + 3]);\n\n    if (frameHeader === 'PRIV') {\n      frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);\n\n      for (var i = 0; i < frame.byteLength; i++) {\n        if (frame[i] === 0) {\n          var owner = parseIso88591(frame, 0, i);\n          if (owner === 'com.apple.streaming.transportStreamTimestamp') {\n            var d = frame.subarray(i + 1);\n            var size = ((d[3] & 0x01)  << 30) |\n                       (d[4]  << 22) |\n                       (d[5] << 14) |\n                       (d[6] << 6) |\n                       (d[7] >>> 2);\n            size *= 4;\n            size += d[7] & 0x03;\n\n            return size;\n          }\n          break;\n        }\n      }\n    }\n\n    frameStart += 10; // advance past the frame header\n    frameStart += frameSize; // advance past the frame body\n  } while (frameStart < packet.byteLength);\n  return null;\n};\n\nmodule.exports = {\n  parseId3TagSize: parseId3TagSize,\n  parseAdtsSize: parseAdtsSize,\n  parseType: parseType,\n  parseSampleRate: parseSampleRate,\n  parseAacTimestamp: parseAacTimestamp\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi9hYWMvcHJvYmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi9hYWMvcHJvYmUuanM/OTk0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG11eC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBCcmlnaHRjb3ZlXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFV0aWxpdGllcyB0byBkZXRlY3QgYmFzaWMgcHJvcGVydGllcyBhbmQgbWV0YWRhdGEgYWJvdXQgQWFjIGRhdGEuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFEVFNfU0FNUExJTkdfRlJFUVVFTkNJRVMgPSBbXG4gIDk2MDAwLFxuICA4ODIwMCxcbiAgNjQwMDAsXG4gIDQ4MDAwLFxuICA0NDEwMCxcbiAgMzIwMDAsXG4gIDI0MDAwLFxuICAyMjA1MCxcbiAgMTYwMDAsXG4gIDEyMDAwLFxuICAxMTAyNSxcbiAgODAwMCxcbiAgNzM1MFxuXTtcblxudmFyIHBhcnNlU3luY1NhZmVJbnRlZ2VyID0gZnVuY3Rpb24oZGF0YSkge1xuICByZXR1cm4gKGRhdGFbMF0gPDwgMjEpIHxcbiAgICAgICAgICAoZGF0YVsxXSA8PCAxNCkgfFxuICAgICAgICAgIChkYXRhWzJdIDw8IDcpIHxcbiAgICAgICAgICAoZGF0YVszXSk7XG59O1xuXG4vLyByZXR1cm4gYSBwZXJjZW50LWVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCBieXRlIHJhbmdlXG4vLyBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGVyY2VudC1lbmNvZGluZ1xudmFyIHBlcmNlbnRFbmNvZGUgPSBmdW5jdGlvbihieXRlcywgc3RhcnQsIGVuZCkge1xuICB2YXIgaSwgcmVzdWx0ID0gJyc7XG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXN1bHQgKz0gJyUnICsgKCcwMCcgKyBieXRlc1tpXS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gcmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCBieXRlIHJhbmdlLFxuLy8gaW50ZXJwcmV0ZWQgYXMgSVNPLTg4NTktMS5cbnZhciBwYXJzZUlzbzg4NTkxID0gZnVuY3Rpb24oYnl0ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHVuZXNjYXBlKHBlcmNlbnRFbmNvZGUoYnl0ZXMsIHN0YXJ0LCBlbmQpKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG59O1xuXG52YXIgcGFyc2VJZDNUYWdTaXplID0gZnVuY3Rpb24oaGVhZGVyLCBieXRlSW5kZXgpIHtcbiAgdmFyXG4gICAgcmV0dXJuU2l6ZSA9IChoZWFkZXJbYnl0ZUluZGV4ICsgNl0gPDwgMjEpIHxcbiAgICAgICAgICAgICAgICAgKGhlYWRlcltieXRlSW5kZXggKyA3XSA8PCAxNCkgfFxuICAgICAgICAgICAgICAgICAoaGVhZGVyW2J5dGVJbmRleCArIDhdIDw8IDcpIHxcbiAgICAgICAgICAgICAgICAgKGhlYWRlcltieXRlSW5kZXggKyA5XSksXG4gICAgZmxhZ3MgPSBoZWFkZXJbYnl0ZUluZGV4ICsgNV0sXG4gICAgZm9vdGVyUHJlc2VudCA9IChmbGFncyAmIDE2KSA+PiA0O1xuXG4gIGlmIChmb290ZXJQcmVzZW50KSB7XG4gICAgcmV0dXJuIHJldHVyblNpemUgKyAyMDtcbiAgfVxuICByZXR1cm4gcmV0dXJuU2l6ZSArIDEwO1xufTtcblxudmFyIHBhcnNlQWR0c1NpemUgPSBmdW5jdGlvbihoZWFkZXIsIGJ5dGVJbmRleCkge1xuICB2YXJcbiAgICBsb3dUaHJlZSA9IChoZWFkZXJbYnl0ZUluZGV4ICsgNV0gJiAweEUwKSA+PiA1LFxuICAgIG1pZGRsZSA9IGhlYWRlcltieXRlSW5kZXggKyA0XSA8PCAzLFxuICAgIGhpZ2hUd28gPSBoZWFkZXJbYnl0ZUluZGV4ICsgM10gJiAweDMgPDwgMTE7XG5cbiAgcmV0dXJuIChoaWdoVHdvIHwgbWlkZGxlKSB8IGxvd1RocmVlO1xufTtcblxudmFyIHBhcnNlVHlwZSA9IGZ1bmN0aW9uKGhlYWRlciwgYnl0ZUluZGV4KSB7XG4gIGlmICgoaGVhZGVyW2J5dGVJbmRleF0gPT09ICdJJy5jaGFyQ29kZUF0KDApKSAmJlxuICAgICAgKGhlYWRlcltieXRlSW5kZXggKyAxXSA9PT0gJ0QnLmNoYXJDb2RlQXQoMCkpICYmXG4gICAgICAoaGVhZGVyW2J5dGVJbmRleCArIDJdID09PSAnMycuY2hhckNvZGVBdCgwKSkpIHtcbiAgICByZXR1cm4gJ3RpbWVkLW1ldGFkYXRhJztcbiAgfSBlbHNlIGlmICgoaGVhZGVyW2J5dGVJbmRleF0gJiAweGZmID09PSAweGZmKSAmJlxuICAgICAgICAgICAgICgoaGVhZGVyW2J5dGVJbmRleCArIDFdICYgMHhmMCkgPT09IDB4ZjApKSB7XG4gICAgcmV0dXJuICdhdWRpbyc7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgcGFyc2VTYW1wbGVSYXRlID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSArIDUgPCBwYWNrZXQubGVuZ3RoKSB7XG4gICAgaWYgKHBhY2tldFtpXSAhPT0gMHhGRiB8fCAocGFja2V0W2kgKyAxXSAmIDB4RjYpICE9PSAweEYwKSB7XG4gICAgICAvLyBJZiBhIHZhbGlkIGhlYWRlciB3YXMgbm90IGZvdW5kLCAganVtcCBvbmUgZm9yd2FyZCBhbmQgYXR0ZW1wdCB0b1xuICAgICAgLy8gZmluZCBhIHZhbGlkIEFEVFMgaGVhZGVyIHN0YXJ0aW5nIGF0IHRoZSBuZXh0IGJ5dGVcbiAgICAgIGkrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gQURUU19TQU1QTElOR19GUkVRVUVOQ0lFU1socGFja2V0W2kgKyAyXSAmIDB4M2MpID4+PiAyXTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIHBhcnNlQWFjVGltZXN0YW1wID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBmcmFtZVN0YXJ0LCBmcmFtZVNpemUsIGZyYW1lLCBmcmFtZUhlYWRlcjtcblxuICAvLyBmaW5kIHRoZSBzdGFydCBvZiB0aGUgZmlyc3QgZnJhbWUgYW5kIHRoZSBlbmQgb2YgdGhlIHRhZ1xuICBmcmFtZVN0YXJ0ID0gMTA7XG4gIGlmIChwYWNrZXRbNV0gJiAweDQwKSB7XG4gICAgLy8gYWR2YW5jZSB0aGUgZnJhbWUgc3RhcnQgcGFzdCB0aGUgZXh0ZW5kZWQgaGVhZGVyXG4gICAgZnJhbWVTdGFydCArPSA0OyAvLyBoZWFkZXIgc2l6ZSBmaWVsZFxuICAgIGZyYW1lU3RhcnQgKz0gcGFyc2VTeW5jU2FmZUludGVnZXIocGFja2V0LnN1YmFycmF5KDEwLCAxNCkpO1xuICB9XG5cbiAgLy8gcGFyc2Ugb25lIG9yIG1vcmUgSUQzIGZyYW1lc1xuICAvLyBodHRwOi8vaWQzLm9yZy9pZDN2Mi4zLjAjSUQzdjJfZnJhbWVfb3ZlcnZpZXdcbiAgZG8ge1xuICAgIC8vIGRldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgZnJhbWVcbiAgICBmcmFtZVNpemUgPSBwYXJzZVN5bmNTYWZlSW50ZWdlcihwYWNrZXQuc3ViYXJyYXkoZnJhbWVTdGFydCArIDQsIGZyYW1lU3RhcnQgKyA4KSk7XG4gICAgaWYgKGZyYW1lU2l6ZSA8IDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmcmFtZUhlYWRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFja2V0W2ZyYW1lU3RhcnRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRbZnJhbWVTdGFydCArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRbZnJhbWVTdGFydCArIDJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRbZnJhbWVTdGFydCArIDNdKTtcblxuICAgIGlmIChmcmFtZUhlYWRlciA9PT0gJ1BSSVYnKSB7XG4gICAgICBmcmFtZSA9IHBhY2tldC5zdWJhcnJheShmcmFtZVN0YXJ0ICsgMTAsIGZyYW1lU3RhcnQgKyBmcmFtZVNpemUgKyAxMCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmcmFtZVtpXSA9PT0gMCkge1xuICAgICAgICAgIHZhciBvd25lciA9IHBhcnNlSXNvODg1OTEoZnJhbWUsIDAsIGkpO1xuICAgICAgICAgIGlmIChvd25lciA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJykge1xuICAgICAgICAgICAgdmFyIGQgPSBmcmFtZS5zdWJhcnJheShpICsgMSk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9ICgoZFszXSAmIDB4MDEpICA8PCAzMCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAoZFs0XSAgPDwgMjIpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgKGRbNV0gPDwgMTQpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgKGRbNl0gPDwgNikgfFxuICAgICAgICAgICAgICAgICAgICAgICAoZFs3XSA+Pj4gMik7XG4gICAgICAgICAgICBzaXplICo9IDQ7XG4gICAgICAgICAgICBzaXplICs9IGRbN10gJiAweDAzO1xuXG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmcmFtZVN0YXJ0ICs9IDEwOyAvLyBhZHZhbmNlIHBhc3QgdGhlIGZyYW1lIGhlYWRlclxuICAgIGZyYW1lU3RhcnQgKz0gZnJhbWVTaXplOyAvLyBhZHZhbmNlIHBhc3QgdGhlIGZyYW1lIGJvZHlcbiAgfSB3aGlsZSAoZnJhbWVTdGFydCA8IHBhY2tldC5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VJZDNUYWdTaXplOiBwYXJzZUlkM1RhZ1NpemUsXG4gIHBhcnNlQWR0c1NpemU6IHBhcnNlQWR0c1NpemUsXG4gIHBhcnNlVHlwZTogcGFyc2VUeXBlLFxuICBwYXJzZVNhbXBsZVJhdGU6IHBhcnNlU2FtcGxlUmF0ZSxcbiAgcGFyc2VBYWNUaW1lc3RhbXA6IHBhcnNlQWFjVGltZXN0YW1wXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mux.js/lib/aac/probe.js\n");

/***/ }),

/***/ "./node_modules/mux.js/lib/m2ts/probe.js":
/*!***********************************************!*\
  !*** ./node_modules/mux.js/lib/m2ts/probe.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Utilities to detect basic properties and metadata about TS Segments.\n */\n\n\nvar StreamTypes = __webpack_require__(/*! ./stream-types.js */ \"./node_modules/mux.js/lib/m2ts/stream-types.js\");\n\nvar parsePid = function(packet) {\n  var pid = packet[1] & 0x1f;\n  pid <<= 8;\n  pid |= packet[2];\n  return pid;\n};\n\nvar parsePayloadUnitStartIndicator = function(packet) {\n  return !!(packet[1] & 0x40);\n};\n\nvar parseAdaptionField = function(packet) {\n  var offset = 0;\n  // if an adaption field is present, its length is specified by the\n  // fifth byte of the TS packet header. The adaptation field is\n  // used to add stuffing to PES packets that don't fill a complete\n  // TS packet, and to specify some forms of timing and control data\n  // that we do not currently use.\n  if (((packet[3] & 0x30) >>> 4) > 0x01) {\n    offset += packet[4] + 1;\n  }\n  return offset;\n};\n\nvar parseType = function(packet, pmtPid) {\n  var pid = parsePid(packet);\n  if (pid === 0) {\n    return 'pat';\n  } else if (pid === pmtPid) {\n    return 'pmt';\n  } else if (pmtPid) {\n    return 'pes';\n  }\n  return null;\n};\n\nvar parsePat = function(packet) {\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  var offset = 4 + parseAdaptionField(packet);\n\n  if (pusi) {\n    offset += packet[offset] + 1;\n  }\n\n  return (packet[offset + 10] & 0x1f) << 8 | packet[offset + 11];\n};\n\nvar parsePmt = function(packet) {\n  var programMapTable = {};\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  var payloadOffset = 4 + parseAdaptionField(packet);\n\n  if (pusi) {\n    payloadOffset += packet[payloadOffset] + 1;\n  }\n\n  // PMTs can be sent ahead of the time when they should actually\n  // take effect. We don't believe this should ever be the case\n  // for HLS but we'll ignore \"forward\" PMT declarations if we see\n  // them. Future PMT declarations have the current_next_indicator\n  // set to zero.\n  if (!(packet[payloadOffset + 5] & 0x01)) {\n    return;\n  }\n\n  var sectionLength, tableEnd, programInfoLength;\n  // the mapping table ends at the end of the current section\n  sectionLength = (packet[payloadOffset + 1] & 0x0f) << 8 | packet[payloadOffset + 2];\n  tableEnd = 3 + sectionLength - 4;\n\n  // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n  programInfoLength = (packet[payloadOffset + 10] & 0x0f) << 8 | packet[payloadOffset + 11];\n\n  // advance the offset to the first entry in the mapping table\n  var offset = 12 + programInfoLength;\n  while (offset < tableEnd) {\n    var i = payloadOffset + offset;\n    // add an entry that maps the elementary_pid to the stream_type\n    programMapTable[(packet[i + 1] & 0x1F) << 8 | packet[i + 2]] = packet[i];\n\n    // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n    offset += ((packet[i + 3] & 0x0F) << 8 | packet[i + 4]) + 5;\n  }\n  return programMapTable;\n};\n\nvar parsePesType = function(packet, programMapTable) {\n  var pid = parsePid(packet);\n  var type = programMapTable[pid];\n  switch (type) {\n    case StreamTypes.H264_STREAM_TYPE:\n      return 'video';\n    case StreamTypes.ADTS_STREAM_TYPE:\n      return 'audio';\n    case StreamTypes.METADATA_STREAM_TYPE:\n      return 'timed-metadata';\n    default:\n      return null;\n  }\n};\n\nvar parsePesTime = function(packet) {\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  if (!pusi) {\n    return null;\n  }\n\n  var offset = 4 + parseAdaptionField(packet);\n\n  if (offset >= packet.byteLength) {\n    // From the H 222.0 MPEG-TS spec\n    // \"For transport stream packets carrying PES packets, stuffing is needed when there\n    //  is insufficient PES packet data to completely fill the transport stream packet\n    //  payload bytes. Stuffing is accomplished by defining an adaptation field longer than\n    //  the sum of the lengths of the data elements in it, so that the payload bytes\n    //  remaining after the adaptation field exactly accommodates the available PES packet\n    //  data.\"\n    //\n    // If the offset is >= the length of the packet, then the packet contains no data\n    // and instead is just adaption field stuffing bytes\n    return null;\n  }\n\n  var pes = null;\n  var ptsDtsFlags;\n\n  // PES packets may be annotated with a PTS value, or a PTS value\n  // and a DTS value. Determine what combination of values is\n  // available to work with.\n  ptsDtsFlags = packet[offset + 7];\n\n  // PTS and DTS are normally stored as a 33-bit number.  Javascript\n  // performs all bitwise operations on 32-bit integers but javascript\n  // supports a much greater range (52-bits) of integer using standard\n  // mathematical operations.\n  // We construct a 31-bit value using bitwise operators over the 31\n  // most significant bits and then multiply by 4 (equal to a left-shift\n  // of 2) before we add the final 2 least significant bits of the\n  // timestamp (equal to an OR.)\n  if (ptsDtsFlags & 0xC0) {\n    pes = {};\n    // the PTS and DTS are not written out directly. For information\n    // on how they are encoded, see\n    // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n    pes.pts = (packet[offset + 9] & 0x0E) << 27 |\n      (packet[offset + 10] & 0xFF) << 20 |\n      (packet[offset + 11] & 0xFE) << 12 |\n      (packet[offset + 12] & 0xFF) <<  5 |\n      (packet[offset + 13] & 0xFE) >>>  3;\n    pes.pts *= 4; // Left shift by 2\n    pes.pts += (packet[offset + 13] & 0x06) >>> 1; // OR by the two LSBs\n    pes.dts = pes.pts;\n    if (ptsDtsFlags & 0x40) {\n      pes.dts = (packet[offset + 14] & 0x0E) << 27 |\n        (packet[offset + 15] & 0xFF) << 20 |\n        (packet[offset + 16] & 0xFE) << 12 |\n        (packet[offset + 17] & 0xFF) << 5 |\n        (packet[offset + 18] & 0xFE) >>> 3;\n      pes.dts *= 4; // Left shift by 2\n      pes.dts += (packet[offset + 18] & 0x06) >>> 1; // OR by the two LSBs\n    }\n  }\n  return pes;\n};\n\nvar parseNalUnitType = function(type) {\n  switch (type) {\n    case 0x05:\n      return 'slice_layer_without_partitioning_rbsp_idr';\n    case 0x06:\n      return 'sei_rbsp';\n    case 0x07:\n      return 'seq_parameter_set_rbsp';\n    case 0x08:\n      return 'pic_parameter_set_rbsp';\n    case 0x09:\n      return 'access_unit_delimiter_rbsp';\n    default:\n      return null;\n  }\n};\n\nvar videoPacketContainsKeyFrame = function(packet) {\n  var offset = 4 + parseAdaptionField(packet);\n  var frameBuffer = packet.subarray(offset);\n  var frameI = 0;\n  var frameSyncPoint = 0;\n  var foundKeyFrame = false;\n  var nalType;\n\n  // advance the sync point to a NAL start, if necessary\n  for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {\n    if (frameBuffer[frameSyncPoint + 2] === 1) {\n      // the sync point is properly aligned\n      frameI = frameSyncPoint + 5;\n      break;\n    }\n  }\n\n  while (frameI < frameBuffer.byteLength) {\n    // look at the current byte to determine if we've hit the end of\n    // a NAL unit boundary\n    switch (frameBuffer[frameI]) {\n    case 0:\n      // skip past non-sync sequences\n      if (frameBuffer[frameI - 1] !== 0) {\n        frameI += 2;\n        break;\n      } else if (frameBuffer[frameI - 2] !== 0) {\n        frameI++;\n        break;\n      }\n\n      if (frameSyncPoint + 3 !== frameI - 2) {\n        nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n        if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n          foundKeyFrame = true;\n        }\n      }\n\n      // drop trailing zeroes\n      do {\n        frameI++;\n      } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);\n      frameSyncPoint = frameI - 2;\n      frameI += 3;\n      break;\n    case 1:\n      // skip past non-sync sequences\n      if (frameBuffer[frameI - 1] !== 0 ||\n          frameBuffer[frameI - 2] !== 0) {\n        frameI += 3;\n        break;\n      }\n\n      nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n      if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n        foundKeyFrame = true;\n      }\n      frameSyncPoint = frameI - 2;\n      frameI += 3;\n      break;\n    default:\n      // the current byte isn't a one or zero, so it cannot be part\n      // of a sync sequence\n      frameI += 3;\n      break;\n    }\n  }\n  frameBuffer = frameBuffer.subarray(frameSyncPoint);\n  frameI -= frameSyncPoint;\n  frameSyncPoint = 0;\n  // parse the final nal\n  if (frameBuffer && frameBuffer.byteLength > 3) {\n    nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n    if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n      foundKeyFrame = true;\n    }\n  }\n\n  return foundKeyFrame;\n};\n\n\nmodule.exports = {\n  parseType: parseType,\n  parsePat: parsePat,\n  parsePmt: parsePmt,\n  parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,\n  parsePesType: parsePesType,\n  parsePesTime: parsePesTime,\n  videoPacketContainsKeyFrame: videoPacketContainsKeyFrame\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi9tMnRzL3Byb2JlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL211eC5qcy9saWIvbTJ0cy9wcm9iZS5qcz80MjNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbXV4LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEJyaWdodGNvdmVcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVXRpbGl0aWVzIHRvIGRldGVjdCBiYXNpYyBwcm9wZXJ0aWVzIGFuZCBtZXRhZGF0YSBhYm91dCBUUyBTZWdtZW50cy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RyZWFtVHlwZXMgPSByZXF1aXJlKCcuL3N0cmVhbS10eXBlcy5qcycpO1xuXG52YXIgcGFyc2VQaWQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdmFyIHBpZCA9IHBhY2tldFsxXSAmIDB4MWY7XG4gIHBpZCA8PD0gODtcbiAgcGlkIHw9IHBhY2tldFsyXTtcbiAgcmV0dXJuIHBpZDtcbn07XG5cbnZhciBwYXJzZVBheWxvYWRVbml0U3RhcnRJbmRpY2F0b3IgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgcmV0dXJuICEhKHBhY2tldFsxXSAmIDB4NDApO1xufTtcblxudmFyIHBhcnNlQWRhcHRpb25GaWVsZCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgLy8gaWYgYW4gYWRhcHRpb24gZmllbGQgaXMgcHJlc2VudCwgaXRzIGxlbmd0aCBpcyBzcGVjaWZpZWQgYnkgdGhlXG4gIC8vIGZpZnRoIGJ5dGUgb2YgdGhlIFRTIHBhY2tldCBoZWFkZXIuIFRoZSBhZGFwdGF0aW9uIGZpZWxkIGlzXG4gIC8vIHVzZWQgdG8gYWRkIHN0dWZmaW5nIHRvIFBFUyBwYWNrZXRzIHRoYXQgZG9uJ3QgZmlsbCBhIGNvbXBsZXRlXG4gIC8vIFRTIHBhY2tldCwgYW5kIHRvIHNwZWNpZnkgc29tZSBmb3JtcyBvZiB0aW1pbmcgYW5kIGNvbnRyb2wgZGF0YVxuICAvLyB0aGF0IHdlIGRvIG5vdCBjdXJyZW50bHkgdXNlLlxuICBpZiAoKChwYWNrZXRbM10gJiAweDMwKSA+Pj4gNCkgPiAweDAxKSB7XG4gICAgb2Zmc2V0ICs9IHBhY2tldFs0XSArIDE7XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn07XG5cbnZhciBwYXJzZVR5cGUgPSBmdW5jdGlvbihwYWNrZXQsIHBtdFBpZCkge1xuICB2YXIgcGlkID0gcGFyc2VQaWQocGFja2V0KTtcbiAgaWYgKHBpZCA9PT0gMCkge1xuICAgIHJldHVybiAncGF0JztcbiAgfSBlbHNlIGlmIChwaWQgPT09IHBtdFBpZCkge1xuICAgIHJldHVybiAncG10JztcbiAgfSBlbHNlIGlmIChwbXRQaWQpIHtcbiAgICByZXR1cm4gJ3Blcyc7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgcGFyc2VQYXQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdmFyIHB1c2kgPSBwYXJzZVBheWxvYWRVbml0U3RhcnRJbmRpY2F0b3IocGFja2V0KTtcbiAgdmFyIG9mZnNldCA9IDQgKyBwYXJzZUFkYXB0aW9uRmllbGQocGFja2V0KTtcblxuICBpZiAocHVzaSkge1xuICAgIG9mZnNldCArPSBwYWNrZXRbb2Zmc2V0XSArIDE7XG4gIH1cblxuICByZXR1cm4gKHBhY2tldFtvZmZzZXQgKyAxMF0gJiAweDFmKSA8PCA4IHwgcGFja2V0W29mZnNldCArIDExXTtcbn07XG5cbnZhciBwYXJzZVBtdCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB2YXIgcHJvZ3JhbU1hcFRhYmxlID0ge307XG4gIHZhciBwdXNpID0gcGFyc2VQYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yKHBhY2tldCk7XG4gIHZhciBwYXlsb2FkT2Zmc2V0ID0gNCArIHBhcnNlQWRhcHRpb25GaWVsZChwYWNrZXQpO1xuXG4gIGlmIChwdXNpKSB7XG4gICAgcGF5bG9hZE9mZnNldCArPSBwYWNrZXRbcGF5bG9hZE9mZnNldF0gKyAxO1xuICB9XG5cbiAgLy8gUE1UcyBjYW4gYmUgc2VudCBhaGVhZCBvZiB0aGUgdGltZSB3aGVuIHRoZXkgc2hvdWxkIGFjdHVhbGx5XG4gIC8vIHRha2UgZWZmZWN0LiBXZSBkb24ndCBiZWxpZXZlIHRoaXMgc2hvdWxkIGV2ZXIgYmUgdGhlIGNhc2VcbiAgLy8gZm9yIEhMUyBidXQgd2UnbGwgaWdub3JlIFwiZm9yd2FyZFwiIFBNVCBkZWNsYXJhdGlvbnMgaWYgd2Ugc2VlXG4gIC8vIHRoZW0uIEZ1dHVyZSBQTVQgZGVjbGFyYXRpb25zIGhhdmUgdGhlIGN1cnJlbnRfbmV4dF9pbmRpY2F0b3JcbiAgLy8gc2V0IHRvIHplcm8uXG4gIGlmICghKHBhY2tldFtwYXlsb2FkT2Zmc2V0ICsgNV0gJiAweDAxKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWN0aW9uTGVuZ3RoLCB0YWJsZUVuZCwgcHJvZ3JhbUluZm9MZW5ndGg7XG4gIC8vIHRoZSBtYXBwaW5nIHRhYmxlIGVuZHMgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzZWN0aW9uXG4gIHNlY3Rpb25MZW5ndGggPSAocGFja2V0W3BheWxvYWRPZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDggfCBwYWNrZXRbcGF5bG9hZE9mZnNldCArIDJdO1xuICB0YWJsZUVuZCA9IDMgKyBzZWN0aW9uTGVuZ3RoIC0gNDtcblxuICAvLyB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIHRhYmxlIGlzLCB3ZSBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93XG4gIC8vIGxvbmcgdGhlIHByb2dyYW0gaW5mbyBkZXNjcmlwdG9ycyBhcmVcbiAgcHJvZ3JhbUluZm9MZW5ndGggPSAocGFja2V0W3BheWxvYWRPZmZzZXQgKyAxMF0gJiAweDBmKSA8PCA4IHwgcGFja2V0W3BheWxvYWRPZmZzZXQgKyAxMV07XG5cbiAgLy8gYWR2YW5jZSB0aGUgb2Zmc2V0IHRvIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgbWFwcGluZyB0YWJsZVxuICB2YXIgb2Zmc2V0ID0gMTIgKyBwcm9ncmFtSW5mb0xlbmd0aDtcbiAgd2hpbGUgKG9mZnNldCA8IHRhYmxlRW5kKSB7XG4gICAgdmFyIGkgPSBwYXlsb2FkT2Zmc2V0ICsgb2Zmc2V0O1xuICAgIC8vIGFkZCBhbiBlbnRyeSB0aGF0IG1hcHMgdGhlIGVsZW1lbnRhcnlfcGlkIHRvIHRoZSBzdHJlYW1fdHlwZVxuICAgIHByb2dyYW1NYXBUYWJsZVsocGFja2V0W2kgKyAxXSAmIDB4MUYpIDw8IDggfCBwYWNrZXRbaSArIDJdXSA9IHBhY2tldFtpXTtcblxuICAgIC8vIG1vdmUgdG8gdGhlIG5leHQgdGFibGUgZW50cnlcbiAgICAvLyBza2lwIHBhc3QgdGhlIGVsZW1lbnRhcnkgc3RyZWFtIGRlc2NyaXB0b3JzLCBpZiBwcmVzZW50XG4gICAgb2Zmc2V0ICs9ICgocGFja2V0W2kgKyAzXSAmIDB4MEYpIDw8IDggfCBwYWNrZXRbaSArIDRdKSArIDU7XG4gIH1cbiAgcmV0dXJuIHByb2dyYW1NYXBUYWJsZTtcbn07XG5cbnZhciBwYXJzZVBlc1R5cGUgPSBmdW5jdGlvbihwYWNrZXQsIHByb2dyYW1NYXBUYWJsZSkge1xuICB2YXIgcGlkID0gcGFyc2VQaWQocGFja2V0KTtcbiAgdmFyIHR5cGUgPSBwcm9ncmFtTWFwVGFibGVbcGlkXTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTdHJlYW1UeXBlcy5IMjY0X1NUUkVBTV9UWVBFOlxuICAgICAgcmV0dXJuICd2aWRlbyc7XG4gICAgY2FzZSBTdHJlYW1UeXBlcy5BRFRTX1NUUkVBTV9UWVBFOlxuICAgICAgcmV0dXJuICdhdWRpbyc7XG4gICAgY2FzZSBTdHJlYW1UeXBlcy5NRVRBREFUQV9TVFJFQU1fVFlQRTpcbiAgICAgIHJldHVybiAndGltZWQtbWV0YWRhdGEnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxudmFyIHBhcnNlUGVzVGltZSA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB2YXIgcHVzaSA9IHBhcnNlUGF5bG9hZFVuaXRTdGFydEluZGljYXRvcihwYWNrZXQpO1xuICBpZiAoIXB1c2kpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBvZmZzZXQgPSA0ICsgcGFyc2VBZGFwdGlvbkZpZWxkKHBhY2tldCk7XG5cbiAgaWYgKG9mZnNldCA+PSBwYWNrZXQuYnl0ZUxlbmd0aCkge1xuICAgIC8vIEZyb20gdGhlIEggMjIyLjAgTVBFRy1UUyBzcGVjXG4gICAgLy8gXCJGb3IgdHJhbnNwb3J0IHN0cmVhbSBwYWNrZXRzIGNhcnJ5aW5nIFBFUyBwYWNrZXRzLCBzdHVmZmluZyBpcyBuZWVkZWQgd2hlbiB0aGVyZVxuICAgIC8vICBpcyBpbnN1ZmZpY2llbnQgUEVTIHBhY2tldCBkYXRhIHRvIGNvbXBsZXRlbHkgZmlsbCB0aGUgdHJhbnNwb3J0IHN0cmVhbSBwYWNrZXRcbiAgICAvLyAgcGF5bG9hZCBieXRlcy4gU3R1ZmZpbmcgaXMgYWNjb21wbGlzaGVkIGJ5IGRlZmluaW5nIGFuIGFkYXB0YXRpb24gZmllbGQgbG9uZ2VyIHRoYW5cbiAgICAvLyAgdGhlIHN1bSBvZiB0aGUgbGVuZ3RocyBvZiB0aGUgZGF0YSBlbGVtZW50cyBpbiBpdCwgc28gdGhhdCB0aGUgcGF5bG9hZCBieXRlc1xuICAgIC8vICByZW1haW5pbmcgYWZ0ZXIgdGhlIGFkYXB0YXRpb24gZmllbGQgZXhhY3RseSBhY2NvbW1vZGF0ZXMgdGhlIGF2YWlsYWJsZSBQRVMgcGFja2V0XG4gICAgLy8gIGRhdGEuXCJcbiAgICAvL1xuICAgIC8vIElmIHRoZSBvZmZzZXQgaXMgPj0gdGhlIGxlbmd0aCBvZiB0aGUgcGFja2V0LCB0aGVuIHRoZSBwYWNrZXQgY29udGFpbnMgbm8gZGF0YVxuICAgIC8vIGFuZCBpbnN0ZWFkIGlzIGp1c3QgYWRhcHRpb24gZmllbGQgc3R1ZmZpbmcgYnl0ZXNcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwZXMgPSBudWxsO1xuICB2YXIgcHRzRHRzRmxhZ3M7XG5cbiAgLy8gUEVTIHBhY2tldHMgbWF5IGJlIGFubm90YXRlZCB3aXRoIGEgUFRTIHZhbHVlLCBvciBhIFBUUyB2YWx1ZVxuICAvLyBhbmQgYSBEVFMgdmFsdWUuIERldGVybWluZSB3aGF0IGNvbWJpbmF0aW9uIG9mIHZhbHVlcyBpc1xuICAvLyBhdmFpbGFibGUgdG8gd29yayB3aXRoLlxuICBwdHNEdHNGbGFncyA9IHBhY2tldFtvZmZzZXQgKyA3XTtcblxuICAvLyBQVFMgYW5kIERUUyBhcmUgbm9ybWFsbHkgc3RvcmVkIGFzIGEgMzMtYml0IG51bWJlci4gIEphdmFzY3JpcHRcbiAgLy8gcGVyZm9ybXMgYWxsIGJpdHdpc2Ugb3BlcmF0aW9ucyBvbiAzMi1iaXQgaW50ZWdlcnMgYnV0IGphdmFzY3JpcHRcbiAgLy8gc3VwcG9ydHMgYSBtdWNoIGdyZWF0ZXIgcmFuZ2UgKDUyLWJpdHMpIG9mIGludGVnZXIgdXNpbmcgc3RhbmRhcmRcbiAgLy8gbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnMuXG4gIC8vIFdlIGNvbnN0cnVjdCBhIDMxLWJpdCB2YWx1ZSB1c2luZyBiaXR3aXNlIG9wZXJhdG9ycyBvdmVyIHRoZSAzMVxuICAvLyBtb3N0IHNpZ25pZmljYW50IGJpdHMgYW5kIHRoZW4gbXVsdGlwbHkgYnkgNCAoZXF1YWwgdG8gYSBsZWZ0LXNoaWZ0XG4gIC8vIG9mIDIpIGJlZm9yZSB3ZSBhZGQgdGhlIGZpbmFsIDIgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyBvZiB0aGVcbiAgLy8gdGltZXN0YW1wIChlcXVhbCB0byBhbiBPUi4pXG4gIGlmIChwdHNEdHNGbGFncyAmIDB4QzApIHtcbiAgICBwZXMgPSB7fTtcbiAgICAvLyB0aGUgUFRTIGFuZCBEVFMgYXJlIG5vdCB3cml0dGVuIG91dCBkaXJlY3RseS4gRm9yIGluZm9ybWF0aW9uXG4gICAgLy8gb24gaG93IHRoZXkgYXJlIGVuY29kZWQsIHNlZVxuICAgIC8vIGh0dHA6Ly9kdmQuc291cmNlZm9yZ2UubmV0L2R2ZGluZm8vcGVzLWhkci5odG1sXG4gICAgcGVzLnB0cyA9IChwYWNrZXRbb2Zmc2V0ICsgOV0gJiAweDBFKSA8PCAyNyB8XG4gICAgICAocGFja2V0W29mZnNldCArIDEwXSAmIDB4RkYpIDw8IDIwIHxcbiAgICAgIChwYWNrZXRbb2Zmc2V0ICsgMTFdICYgMHhGRSkgPDwgMTIgfFxuICAgICAgKHBhY2tldFtvZmZzZXQgKyAxMl0gJiAweEZGKSA8PCAgNSB8XG4gICAgICAocGFja2V0W29mZnNldCArIDEzXSAmIDB4RkUpID4+PiAgMztcbiAgICBwZXMucHRzICo9IDQ7IC8vIExlZnQgc2hpZnQgYnkgMlxuICAgIHBlcy5wdHMgKz0gKHBhY2tldFtvZmZzZXQgKyAxM10gJiAweDA2KSA+Pj4gMTsgLy8gT1IgYnkgdGhlIHR3byBMU0JzXG4gICAgcGVzLmR0cyA9IHBlcy5wdHM7XG4gICAgaWYgKHB0c0R0c0ZsYWdzICYgMHg0MCkge1xuICAgICAgcGVzLmR0cyA9IChwYWNrZXRbb2Zmc2V0ICsgMTRdICYgMHgwRSkgPDwgMjcgfFxuICAgICAgICAocGFja2V0W29mZnNldCArIDE1XSAmIDB4RkYpIDw8IDIwIHxcbiAgICAgICAgKHBhY2tldFtvZmZzZXQgKyAxNl0gJiAweEZFKSA8PCAxMiB8XG4gICAgICAgIChwYWNrZXRbb2Zmc2V0ICsgMTddICYgMHhGRikgPDwgNSB8XG4gICAgICAgIChwYWNrZXRbb2Zmc2V0ICsgMThdICYgMHhGRSkgPj4+IDM7XG4gICAgICBwZXMuZHRzICo9IDQ7IC8vIExlZnQgc2hpZnQgYnkgMlxuICAgICAgcGVzLmR0cyArPSAocGFja2V0W29mZnNldCArIDE4XSAmIDB4MDYpID4+PiAxOyAvLyBPUiBieSB0aGUgdHdvIExTQnNcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBlcztcbn07XG5cbnZhciBwYXJzZU5hbFVuaXRUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIDB4MDU6XG4gICAgICByZXR1cm4gJ3NsaWNlX2xheWVyX3dpdGhvdXRfcGFydGl0aW9uaW5nX3Jic3BfaWRyJztcbiAgICBjYXNlIDB4MDY6XG4gICAgICByZXR1cm4gJ3NlaV9yYnNwJztcbiAgICBjYXNlIDB4MDc6XG4gICAgICByZXR1cm4gJ3NlcV9wYXJhbWV0ZXJfc2V0X3Jic3AnO1xuICAgIGNhc2UgMHgwODpcbiAgICAgIHJldHVybiAncGljX3BhcmFtZXRlcl9zZXRfcmJzcCc7XG4gICAgY2FzZSAweDA5OlxuICAgICAgcmV0dXJuICdhY2Nlc3NfdW5pdF9kZWxpbWl0ZXJfcmJzcCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG52YXIgdmlkZW9QYWNrZXRDb250YWluc0tleUZyYW1lID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBvZmZzZXQgPSA0ICsgcGFyc2VBZGFwdGlvbkZpZWxkKHBhY2tldCk7XG4gIHZhciBmcmFtZUJ1ZmZlciA9IHBhY2tldC5zdWJhcnJheShvZmZzZXQpO1xuICB2YXIgZnJhbWVJID0gMDtcbiAgdmFyIGZyYW1lU3luY1BvaW50ID0gMDtcbiAgdmFyIGZvdW5kS2V5RnJhbWUgPSBmYWxzZTtcbiAgdmFyIG5hbFR5cGU7XG5cbiAgLy8gYWR2YW5jZSB0aGUgc3luYyBwb2ludCB0byBhIE5BTCBzdGFydCwgaWYgbmVjZXNzYXJ5XG4gIGZvciAoOyBmcmFtZVN5bmNQb2ludCA8IGZyYW1lQnVmZmVyLmJ5dGVMZW5ndGggLSAzOyBmcmFtZVN5bmNQb2ludCsrKSB7XG4gICAgaWYgKGZyYW1lQnVmZmVyW2ZyYW1lU3luY1BvaW50ICsgMl0gPT09IDEpIHtcbiAgICAgIC8vIHRoZSBzeW5jIHBvaW50IGlzIHByb3Blcmx5IGFsaWduZWRcbiAgICAgIGZyYW1lSSA9IGZyYW1lU3luY1BvaW50ICsgNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChmcmFtZUkgPCBmcmFtZUJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgLy8gbG9vayBhdCB0aGUgY3VycmVudCBieXRlIHRvIGRldGVybWluZSBpZiB3ZSd2ZSBoaXQgdGhlIGVuZCBvZlxuICAgIC8vIGEgTkFMIHVuaXQgYm91bmRhcnlcbiAgICBzd2l0Y2ggKGZyYW1lQnVmZmVyW2ZyYW1lSV0pIHtcbiAgICBjYXNlIDA6XG4gICAgICAvLyBza2lwIHBhc3Qgbm9uLXN5bmMgc2VxdWVuY2VzXG4gICAgICBpZiAoZnJhbWVCdWZmZXJbZnJhbWVJIC0gMV0gIT09IDApIHtcbiAgICAgICAgZnJhbWVJICs9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChmcmFtZUJ1ZmZlcltmcmFtZUkgLSAyXSAhPT0gMCkge1xuICAgICAgICBmcmFtZUkrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChmcmFtZVN5bmNQb2ludCArIDMgIT09IGZyYW1lSSAtIDIpIHtcbiAgICAgICAgbmFsVHlwZSA9IHBhcnNlTmFsVW5pdFR5cGUoZnJhbWVCdWZmZXJbZnJhbWVTeW5jUG9pbnQgKyAzXSAmIDB4MWYpO1xuICAgICAgICBpZiAobmFsVHlwZSA9PT0gJ3NsaWNlX2xheWVyX3dpdGhvdXRfcGFydGl0aW9uaW5nX3Jic3BfaWRyJykge1xuICAgICAgICAgIGZvdW5kS2V5RnJhbWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGRyb3AgdHJhaWxpbmcgemVyb2VzXG4gICAgICBkbyB7XG4gICAgICAgIGZyYW1lSSsrO1xuICAgICAgfSB3aGlsZSAoZnJhbWVCdWZmZXJbZnJhbWVJXSAhPT0gMSAmJiBmcmFtZUkgPCBmcmFtZUJ1ZmZlci5sZW5ndGgpO1xuICAgICAgZnJhbWVTeW5jUG9pbnQgPSBmcmFtZUkgLSAyO1xuICAgICAgZnJhbWVJICs9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICAvLyBza2lwIHBhc3Qgbm9uLXN5bmMgc2VxdWVuY2VzXG4gICAgICBpZiAoZnJhbWVCdWZmZXJbZnJhbWVJIC0gMV0gIT09IDAgfHxcbiAgICAgICAgICBmcmFtZUJ1ZmZlcltmcmFtZUkgLSAyXSAhPT0gMCkge1xuICAgICAgICBmcmFtZUkgKz0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG5hbFR5cGUgPSBwYXJzZU5hbFVuaXRUeXBlKGZyYW1lQnVmZmVyW2ZyYW1lU3luY1BvaW50ICsgM10gJiAweDFmKTtcbiAgICAgIGlmIChuYWxUeXBlID09PSAnc2xpY2VfbGF5ZXJfd2l0aG91dF9wYXJ0aXRpb25pbmdfcmJzcF9pZHInKSB7XG4gICAgICAgIGZvdW5kS2V5RnJhbWUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZnJhbWVTeW5jUG9pbnQgPSBmcmFtZUkgLSAyO1xuICAgICAgZnJhbWVJICs9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gdGhlIGN1cnJlbnQgYnl0ZSBpc24ndCBhIG9uZSBvciB6ZXJvLCBzbyBpdCBjYW5ub3QgYmUgcGFydFxuICAgICAgLy8gb2YgYSBzeW5jIHNlcXVlbmNlXG4gICAgICBmcmFtZUkgKz0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmcmFtZUJ1ZmZlciA9IGZyYW1lQnVmZmVyLnN1YmFycmF5KGZyYW1lU3luY1BvaW50KTtcbiAgZnJhbWVJIC09IGZyYW1lU3luY1BvaW50O1xuICBmcmFtZVN5bmNQb2ludCA9IDA7XG4gIC8vIHBhcnNlIHRoZSBmaW5hbCBuYWxcbiAgaWYgKGZyYW1lQnVmZmVyICYmIGZyYW1lQnVmZmVyLmJ5dGVMZW5ndGggPiAzKSB7XG4gICAgbmFsVHlwZSA9IHBhcnNlTmFsVW5pdFR5cGUoZnJhbWVCdWZmZXJbZnJhbWVTeW5jUG9pbnQgKyAzXSAmIDB4MWYpO1xuICAgIGlmIChuYWxUeXBlID09PSAnc2xpY2VfbGF5ZXJfd2l0aG91dF9wYXJ0aXRpb25pbmdfcmJzcF9pZHInKSB7XG4gICAgICBmb3VuZEtleUZyYW1lID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm91bmRLZXlGcmFtZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlVHlwZTogcGFyc2VUeXBlLFxuICBwYXJzZVBhdDogcGFyc2VQYXQsXG4gIHBhcnNlUG10OiBwYXJzZVBtdCxcbiAgcGFyc2VQYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yOiBwYXJzZVBheWxvYWRVbml0U3RhcnRJbmRpY2F0b3IsXG4gIHBhcnNlUGVzVHlwZTogcGFyc2VQZXNUeXBlLFxuICBwYXJzZVBlc1RpbWU6IHBhcnNlUGVzVGltZSxcbiAgdmlkZW9QYWNrZXRDb250YWluc0tleUZyYW1lOiB2aWRlb1BhY2tldENvbnRhaW5zS2V5RnJhbWVcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mux.js/lib/m2ts/probe.js\n");

/***/ }),

/***/ "./node_modules/mux.js/lib/m2ts/stream-types.js":
/*!******************************************************!*\
  !*** ./node_modules/mux.js/lib/m2ts/stream-types.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  H264_STREAM_TYPE: 0x1B,\n  ADTS_STREAM_TYPE: 0x0F,\n  METADATA_STREAM_TYPE: 0x15\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi9tMnRzL3N0cmVhbS10eXBlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tdXguanMvbGliL20ydHMvc3RyZWFtLXR5cGVzLmpzP2FlNzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSDI2NF9TVFJFQU1fVFlQRTogMHgxQixcbiAgQURUU19TVFJFQU1fVFlQRTogMHgwRixcbiAgTUVUQURBVEFfU1RSRUFNX1RZUEU6IDB4MTVcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mux.js/lib/m2ts/stream-types.js\n");

/***/ }),

/***/ "./node_modules/mux.js/lib/m2ts/timestamp-rollover-stream.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mux.js/lib/m2ts/timestamp-rollover-stream.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Accepts program elementary stream (PES) data events and corrects\n * decode and presentation time stamps to account for a rollover\n * of the 33 bit value.\n */\n\n\n\nvar Stream = __webpack_require__(/*! ../utils/stream */ \"./node_modules/mux.js/lib/utils/stream.js\");\n\nvar MAX_TS = 8589934592;\n\nvar RO_THRESH = 4294967296;\n\nvar handleRollover = function(value, reference) {\n  var direction = 1;\n\n  if (value > reference) {\n    // If the current timestamp value is greater than our reference timestamp and we detect a\n    // timestamp rollover, this means the roll over is happening in the opposite direction.\n    // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n    // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n    // rollover point. In loading this segment, the timestamp values will be very large,\n    // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n    // the time stamp to be `value - 2^33`.\n    direction = -1;\n  }\n\n  // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n  // cause an incorrect adjustment.\n  while (Math.abs(reference - value) > RO_THRESH) {\n    value += (direction * MAX_TS);\n  }\n\n  return value;\n};\n\nvar TimestampRolloverStream = function(type) {\n  var lastDTS, referenceDTS;\n\n  TimestampRolloverStream.prototype.init.call(this);\n\n  this.type_ = type;\n\n  this.push = function(data) {\n    if (data.type !== this.type_) {\n      return;\n    }\n\n    if (referenceDTS === undefined) {\n      referenceDTS = data.dts;\n    }\n\n    data.dts = handleRollover(data.dts, referenceDTS);\n    data.pts = handleRollover(data.pts, referenceDTS);\n\n    lastDTS = data.dts;\n\n    this.trigger('data', data);\n  };\n\n  this.flush = function() {\n    referenceDTS = lastDTS;\n    this.trigger('done');\n  };\n\n  this.discontinuity = function() {\n    referenceDTS = void 0;\n    lastDTS = void 0;\n  };\n\n};\n\nTimestampRolloverStream.prototype = new Stream();\n\nmodule.exports = {\n  TimestampRolloverStream: TimestampRolloverStream,\n  handleRollover: handleRollover\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi9tMnRzL3RpbWVzdGFtcC1yb2xsb3Zlci1zdHJlYW0uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi9tMnRzL3RpbWVzdGFtcC1yb2xsb3Zlci1zdHJlYW0uanM/MjU2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG11eC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBCcmlnaHRjb3ZlXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIEFjY2VwdHMgcHJvZ3JhbSBlbGVtZW50YXJ5IHN0cmVhbSAoUEVTKSBkYXRhIGV2ZW50cyBhbmQgY29ycmVjdHNcbiAqIGRlY29kZSBhbmQgcHJlc2VudGF0aW9uIHRpbWUgc3RhbXBzIHRvIGFjY291bnQgZm9yIGEgcm9sbG92ZXJcbiAqIG9mIHRoZSAzMyBiaXQgdmFsdWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi4vdXRpbHMvc3RyZWFtJyk7XG5cbnZhciBNQVhfVFMgPSA4NTg5OTM0NTkyO1xuXG52YXIgUk9fVEhSRVNIID0gNDI5NDk2NzI5NjtcblxudmFyIGhhbmRsZVJvbGxvdmVyID0gZnVuY3Rpb24odmFsdWUsIHJlZmVyZW5jZSkge1xuICB2YXIgZGlyZWN0aW9uID0gMTtcblxuICBpZiAodmFsdWUgPiByZWZlcmVuY2UpIHtcbiAgICAvLyBJZiB0aGUgY3VycmVudCB0aW1lc3RhbXAgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG91ciByZWZlcmVuY2UgdGltZXN0YW1wIGFuZCB3ZSBkZXRlY3QgYVxuICAgIC8vIHRpbWVzdGFtcCByb2xsb3ZlciwgdGhpcyBtZWFucyB0aGUgcm9sbCBvdmVyIGlzIGhhcHBlbmluZyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLlxuICAgIC8vIEV4YW1wbGUgc2NlbmFyaW86IEVudGVyIGEgbG9uZyBzdHJlYW0vdmlkZW8ganVzdCBhZnRlciBhIHJvbGxvdmVyIG9jY3VycmVkLiBUaGUgcmVmZXJlbmNlXG4gICAgLy8gcG9pbnQgd2lsbCBiZSBzZXQgdG8gYSBzbWFsbCBudW1iZXIsIGUuZy4gMS4gVGhlIHVzZXIgdGhlbiBzZWVrcyBiYWNrd2FyZHMgb3ZlciB0aGVcbiAgICAvLyByb2xsb3ZlciBwb2ludC4gSW4gbG9hZGluZyB0aGlzIHNlZ21lbnQsIHRoZSB0aW1lc3RhbXAgdmFsdWVzIHdpbGwgYmUgdmVyeSBsYXJnZSxcbiAgICAvLyBlLmcuIDJeMzMgLSAxLiBTaW5jZSB0aGlzIGNvbWVzIGJlZm9yZSB0aGUgZGF0YSB3ZSBsb2FkZWQgcHJldmlvdXNseSwgd2Ugd2FudCB0byBhZGp1c3RcbiAgICAvLyB0aGUgdGltZSBzdGFtcCB0byBiZSBgdmFsdWUgLSAyXjMzYC5cbiAgICBkaXJlY3Rpb24gPSAtMTtcbiAgfVxuXG4gIC8vIE5vdGU6IEEgc2VlayBmb3J3YXJkcyBvciBiYWNrIHRoYXQgaXMgZ3JlYXRlciB0aGFuIHRoZSBST19USFJFU0ggKDJeMzIsIH4xMyBob3Vycykgd2lsbFxuICAvLyBjYXVzZSBhbiBpbmNvcnJlY3QgYWRqdXN0bWVudC5cbiAgd2hpbGUgKE1hdGguYWJzKHJlZmVyZW5jZSAtIHZhbHVlKSA+IFJPX1RIUkVTSCkge1xuICAgIHZhbHVlICs9IChkaXJlY3Rpb24gKiBNQVhfVFMpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIFRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgbGFzdERUUywgcmVmZXJlbmNlRFRTO1xuXG4gIFRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy50eXBlXyA9IHR5cGU7XG5cbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmIChkYXRhLnR5cGUgIT09IHRoaXMudHlwZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocmVmZXJlbmNlRFRTID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlZmVyZW5jZURUUyA9IGRhdGEuZHRzO1xuICAgIH1cblxuICAgIGRhdGEuZHRzID0gaGFuZGxlUm9sbG92ZXIoZGF0YS5kdHMsIHJlZmVyZW5jZURUUyk7XG4gICAgZGF0YS5wdHMgPSBoYW5kbGVSb2xsb3ZlcihkYXRhLnB0cywgcmVmZXJlbmNlRFRTKTtcblxuICAgIGxhc3REVFMgPSBkYXRhLmR0cztcblxuICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICByZWZlcmVuY2VEVFMgPSBsYXN0RFRTO1xuICAgIHRoaXMudHJpZ2dlcignZG9uZScpO1xuICB9O1xuXG4gIHRoaXMuZGlzY29udGludWl0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJlZmVyZW5jZURUUyA9IHZvaWQgMDtcbiAgICBsYXN0RFRTID0gdm9pZCAwO1xuICB9O1xuXG59O1xuXG5UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbS5wcm90b3R5cGUgPSBuZXcgU3RyZWFtKCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbTogVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0sXG4gIGhhbmRsZVJvbGxvdmVyOiBoYW5kbGVSb2xsb3ZlclxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mux.js/lib/m2ts/timestamp-rollover-stream.js\n");

/***/ }),

/***/ "./node_modules/mux.js/lib/mp4/probe.js":
/*!**********************************************!*\
  !*** ./node_modules/mux.js/lib/mp4/probe.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Utilities to detect basic properties and metadata about MP4s.\n */\n\n\nvar toUnsigned = __webpack_require__(/*! ../utils/bin */ \"./node_modules/mux.js/lib/utils/bin.js\").toUnsigned;\nvar findBox, parseType, timescale, startTime;\n\n// Find the data for a box specified by its path\nfindBox = function(data, path) {\n  var results = [],\n      i, size, type, end, subresults;\n\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return null;\n  }\n\n  for (i = 0; i < data.byteLength;) {\n    size  = toUnsigned(data[i]     << 24 |\n                       data[i + 1] << 16 |\n                       data[i + 2] <<  8 |\n                       data[i + 3]);\n\n    type = parseType(data.subarray(i + 4, i + 8));\n\n    end = size > 1 ? i + size : data.byteLength;\n\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, end));\n      } else {\n        // recursively search for the next box along the path\n        subresults = findBox(data.subarray(i + 8, end), path.slice(1));\n        if (subresults.length) {\n          results = results.concat(subresults);\n        }\n      }\n    }\n    i = end;\n  }\n\n  // we've finished searching all of data\n  return results;\n};\n\n/**\n * Returns the string representation of an ASCII encoded four byte buffer.\n * @param buffer {Uint8Array} a four-byte buffer to translate\n * @return {string} the corresponding string\n */\nparseType = function(buffer) {\n  var result = '';\n  result += String.fromCharCode(buffer[0]);\n  result += String.fromCharCode(buffer[1]);\n  result += String.fromCharCode(buffer[2]);\n  result += String.fromCharCode(buffer[3]);\n  return result;\n};\n\n/**\n * Parses an MP4 initialization segment and extracts the timescale\n * values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * ```\n * @param init {Uint8Array} the bytes of the init segment\n * @return {object} a hash of track ids to timescale values or null if\n * the init segment is malformed.\n */\ntimescale = function(init) {\n  var\n    result = {},\n    traks = findBox(init, ['moov', 'trak']);\n\n  // mdhd timescale\n  return traks.reduce(function(result, trak) {\n    var tkhd, version, index, id, mdhd;\n\n    tkhd = findBox(trak, ['tkhd'])[0];\n    if (!tkhd) {\n      return null;\n    }\n    version = tkhd[0];\n    index = version === 0 ? 12 : 20;\n    id = toUnsigned(tkhd[index]     << 24 |\n                    tkhd[index + 1] << 16 |\n                    tkhd[index + 2] <<  8 |\n                    tkhd[index + 3]);\n\n    mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n    if (!mdhd) {\n      return null;\n    }\n    version = mdhd[0];\n    index = version === 0 ? 12 : 20;\n    result[id] = toUnsigned(mdhd[index]     << 24 |\n                            mdhd[index + 1] << 16 |\n                            mdhd[index + 2] <<  8 |\n                            mdhd[index + 3]);\n    return result;\n  }, result);\n};\n\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param timescale {object} a hash of track ids to timescale values.\n * @return {number} the earliest base media decode start time for the\n * fragment, in seconds\n */\nstartTime = function(timescale, fragment) {\n  var trafs, baseTimes, result;\n\n  // we need info from two childrend of each track fragment box\n  trafs = findBox(fragment, ['moof', 'traf']);\n\n  // determine the start times for each track\n  baseTimes = [].concat.apply([], trafs.map(function(traf) {\n    return findBox(traf, ['tfhd']).map(function(tfhd) {\n      var id, scale, baseTime;\n\n      // get the track id from the tfhd\n      id = toUnsigned(tfhd[4] << 24 |\n                      tfhd[5] << 16 |\n                      tfhd[6] <<  8 |\n                      tfhd[7]);\n      // assume a 90kHz clock if no timescale was specified\n      scale = timescale[id] || 90e3;\n\n      // get the base media decode time from the tfdt\n      baseTime = findBox(traf, ['tfdt']).map(function(tfdt) {\n        var version, result;\n\n        version = tfdt[0];\n        result = toUnsigned(tfdt[4] << 24 |\n                            tfdt[5] << 16 |\n                            tfdt[6] <<  8 |\n                            tfdt[7]);\n        if (version ===  1) {\n          result *= Math.pow(2, 32);\n          result += toUnsigned(tfdt[8]  << 24 |\n                               tfdt[9]  << 16 |\n                               tfdt[10] <<  8 |\n                               tfdt[11]);\n        }\n        return result;\n      })[0];\n      baseTime = baseTime || Infinity;\n\n      // convert base time to seconds\n      return baseTime / scale;\n    });\n  }));\n\n  // return the minimum\n  result = Math.min.apply(null, baseTimes);\n  return isFinite(result) ? result : 0;\n};\n\nmodule.exports = {\n  parseType: parseType,\n  timescale: timescale,\n  startTime: startTime\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi9tcDQvcHJvYmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi9tcDQvcHJvYmUuanM/MjgwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG11eC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBCcmlnaHRjb3ZlXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFV0aWxpdGllcyB0byBkZXRlY3QgYmFzaWMgcHJvcGVydGllcyBhbmQgbWV0YWRhdGEgYWJvdXQgTVA0cy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9VbnNpZ25lZCA9IHJlcXVpcmUoJy4uL3V0aWxzL2JpbicpLnRvVW5zaWduZWQ7XG52YXIgZmluZEJveCwgcGFyc2VUeXBlLCB0aW1lc2NhbGUsIHN0YXJ0VGltZTtcblxuLy8gRmluZCB0aGUgZGF0YSBmb3IgYSBib3ggc3BlY2lmaWVkIGJ5IGl0cyBwYXRoXG5maW5kQm94ID0gZnVuY3Rpb24oZGF0YSwgcGF0aCkge1xuICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgaSwgc2l6ZSwgdHlwZSwgZW5kLCBzdWJyZXN1bHRzO1xuXG4gIGlmICghcGF0aC5sZW5ndGgpIHtcbiAgICAvLyBzaG9ydC1jaXJjdWl0IHRoZSBzZWFyY2ggZm9yIGVtcHR5IHBhdGhzXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5ieXRlTGVuZ3RoOykge1xuICAgIHNpemUgID0gdG9VbnNpZ25lZChkYXRhW2ldICAgICA8PCAyNCB8XG4gICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSArIDFdIDw8IDE2IHxcbiAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpICsgMl0gPDwgIDggfFxuICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2kgKyAzXSk7XG5cbiAgICB0eXBlID0gcGFyc2VUeXBlKGRhdGEuc3ViYXJyYXkoaSArIDQsIGkgKyA4KSk7XG5cbiAgICBlbmQgPSBzaXplID4gMSA/IGkgKyBzaXplIDogZGF0YS5ieXRlTGVuZ3RoO1xuXG4gICAgaWYgKHR5cGUgPT09IHBhdGhbMF0pIHtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGggYW5kIHdlJ3ZlIGZvdW5kIHRoZSBib3ggd2Ugd2VyZVxuICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICByZXN1bHRzLnB1c2goZGF0YS5zdWJhcnJheShpICsgOCwgZW5kKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHRoZSBuZXh0IGJveCBhbG9uZyB0aGUgcGF0aFxuICAgICAgICBzdWJyZXN1bHRzID0gZmluZEJveChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmQpLCBwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgaWYgKHN1YnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHN1YnJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGkgPSBlbmQ7XG4gIH1cblxuICAvLyB3ZSd2ZSBmaW5pc2hlZCBzZWFyY2hpbmcgYWxsIG9mIGRhdGFcbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBBU0NJSSBlbmNvZGVkIGZvdXIgYnl0ZSBidWZmZXIuXG4gKiBAcGFyYW0gYnVmZmVyIHtVaW50OEFycmF5fSBhIGZvdXItYnl0ZSBidWZmZXIgdG8gdHJhbnNsYXRlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBjb3JyZXNwb25kaW5nIHN0cmluZ1xuICovXG5wYXJzZVR5cGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXJbMF0pO1xuICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXJbMV0pO1xuICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXJbMl0pO1xuICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXJbM10pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYW4gTVA0IGluaXRpYWxpemF0aW9uIHNlZ21lbnQgYW5kIGV4dHJhY3RzIHRoZSB0aW1lc2NhbGVcbiAqIHZhbHVlcyBmb3IgYW55IGRlY2xhcmVkIHRyYWNrcy4gVGltZXNjYWxlIHZhbHVlcyBpbmRpY2F0ZSB0aGVcbiAqIG51bWJlciBvZiBjbG9jayB0aWNrcyBwZXIgc2Vjb25kIHRvIGFzc3VtZSBmb3IgdGltZS1iYXNlZCB2YWx1ZXNcbiAqIGVsc2V3aGVyZSBpbiB0aGUgTVA0LlxuICpcbiAqIFRvIGRldGVybWluZSB0aGUgc3RhcnQgdGltZSBvZiBhbiBNUDQsIHlvdSBuZWVkIHR3byBwaWVjZXMgb2ZcbiAqIGluZm9ybWF0aW9uOiB0aGUgdGltZXNjYWxlIHVuaXQgYW5kIHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZVxuICogdGltZS4gTXVsdGlwbGUgdGltZXNjYWxlcyBjYW4gYmUgc3BlY2lmaWVkIHdpdGhpbiBhbiBNUDQgYnV0IHRoZVxuICogYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBpcyBhbHdheXMgZXhwcmVzc2VkIGluIHRoZSB0aW1lc2NhbGUgZnJvbVxuICogdGhlIG1lZGlhIGhlYWRlciBib3ggZm9yIHRoZSB0cmFjazpcbiAqIGBgYFxuICogbW9vdiA+IHRyYWsgPiBtZGlhID4gbWRoZC50aW1lc2NhbGVcbiAqIGBgYFxuICogQHBhcmFtIGluaXQge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiB0aGUgaW5pdCBzZWdtZW50XG4gKiBAcmV0dXJuIHtvYmplY3R9IGEgaGFzaCBvZiB0cmFjayBpZHMgdG8gdGltZXNjYWxlIHZhbHVlcyBvciBudWxsIGlmXG4gKiB0aGUgaW5pdCBzZWdtZW50IGlzIG1hbGZvcm1lZC5cbiAqL1xudGltZXNjYWxlID0gZnVuY3Rpb24oaW5pdCkge1xuICB2YXJcbiAgICByZXN1bHQgPSB7fSxcbiAgICB0cmFrcyA9IGZpbmRCb3goaW5pdCwgWydtb292JywgJ3RyYWsnXSk7XG5cbiAgLy8gbWRoZCB0aW1lc2NhbGVcbiAgcmV0dXJuIHRyYWtzLnJlZHVjZShmdW5jdGlvbihyZXN1bHQsIHRyYWspIHtcbiAgICB2YXIgdGtoZCwgdmVyc2lvbiwgaW5kZXgsIGlkLCBtZGhkO1xuXG4gICAgdGtoZCA9IGZpbmRCb3godHJhaywgWyd0a2hkJ10pWzBdO1xuICAgIGlmICghdGtoZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZlcnNpb24gPSB0a2hkWzBdO1xuICAgIGluZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDEyIDogMjA7XG4gICAgaWQgPSB0b1Vuc2lnbmVkKHRraGRbaW5kZXhdICAgICA8PCAyNCB8XG4gICAgICAgICAgICAgICAgICAgIHRraGRbaW5kZXggKyAxXSA8PCAxNiB8XG4gICAgICAgICAgICAgICAgICAgIHRraGRbaW5kZXggKyAyXSA8PCAgOCB8XG4gICAgICAgICAgICAgICAgICAgIHRraGRbaW5kZXggKyAzXSk7XG5cbiAgICBtZGhkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWRoZCddKVswXTtcbiAgICBpZiAoIW1kaGQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2ZXJzaW9uID0gbWRoZFswXTtcbiAgICBpbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgIHJlc3VsdFtpZF0gPSB0b1Vuc2lnbmVkKG1kaGRbaW5kZXhdICAgICA8PCAyNCB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWRoZFtpbmRleCArIDFdIDw8IDE2IHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZGhkW2luZGV4ICsgMl0gPDwgIDggfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1kaGRbaW5kZXggKyAzXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lLCBpbiBzZWNvbmRzLCBmb3IgYW4gTVA0XG4gKiBmcmFnbWVudC4gSWYgbXVsdGlwbGUgZnJhZ21lbnRzIGFyZSBzcGVjaWZpZWQsIHRoZSBlYXJsaWVzdCB0aW1lIGlzXG4gKiByZXR1cm5lZC5cbiAqXG4gKiBUaGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBjYW4gYmUgcGFyc2VkIGZyb20gdHJhY2sgZnJhZ21lbnRcbiAqIG1ldGFkYXRhOlxuICogYGBgXG4gKiBtb29mID4gdHJhZiA+IHRmZHQuYmFzZU1lZGlhRGVjb2RlVGltZVxuICogYGBgXG4gKiBJdCByZXF1aXJlcyB0aGUgdGltZXNjYWxlIHZhbHVlIGZyb20gdGhlIG1kaGQgdG8gaW50ZXJwcmV0LlxuICpcbiAqIEBwYXJhbSB0aW1lc2NhbGUge29iamVjdH0gYSBoYXNoIG9mIHRyYWNrIGlkcyB0byB0aW1lc2NhbGUgdmFsdWVzLlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSBmb3IgdGhlXG4gKiBmcmFnbWVudCwgaW4gc2Vjb25kc1xuICovXG5zdGFydFRpbWUgPSBmdW5jdGlvbih0aW1lc2NhbGUsIGZyYWdtZW50KSB7XG4gIHZhciB0cmFmcywgYmFzZVRpbWVzLCByZXN1bHQ7XG5cbiAgLy8gd2UgbmVlZCBpbmZvIGZyb20gdHdvIGNoaWxkcmVuZCBvZiBlYWNoIHRyYWNrIGZyYWdtZW50IGJveFxuICB0cmFmcyA9IGZpbmRCb3goZnJhZ21lbnQsIFsnbW9vZicsICd0cmFmJ10pO1xuXG4gIC8vIGRldGVybWluZSB0aGUgc3RhcnQgdGltZXMgZm9yIGVhY2ggdHJhY2tcbiAgYmFzZVRpbWVzID0gW10uY29uY2F0LmFwcGx5KFtdLCB0cmFmcy5tYXAoZnVuY3Rpb24odHJhZikge1xuICAgIHJldHVybiBmaW5kQm94KHRyYWYsIFsndGZoZCddKS5tYXAoZnVuY3Rpb24odGZoZCkge1xuICAgICAgdmFyIGlkLCBzY2FsZSwgYmFzZVRpbWU7XG5cbiAgICAgIC8vIGdldCB0aGUgdHJhY2sgaWQgZnJvbSB0aGUgdGZoZFxuICAgICAgaWQgPSB0b1Vuc2lnbmVkKHRmaGRbNF0gPDwgMjQgfFxuICAgICAgICAgICAgICAgICAgICAgIHRmaGRbNV0gPDwgMTYgfFxuICAgICAgICAgICAgICAgICAgICAgIHRmaGRbNl0gPDwgIDggfFxuICAgICAgICAgICAgICAgICAgICAgIHRmaGRbN10pO1xuICAgICAgLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcbiAgICAgIHNjYWxlID0gdGltZXNjYWxlW2lkXSB8fCA5MGUzO1xuXG4gICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgYmFzZVRpbWUgPSBmaW5kQm94KHRyYWYsIFsndGZkdCddKS5tYXAoZnVuY3Rpb24odGZkdCkge1xuICAgICAgICB2YXIgdmVyc2lvbiwgcmVzdWx0O1xuXG4gICAgICAgIHZlcnNpb24gPSB0ZmR0WzBdO1xuICAgICAgICByZXN1bHQgPSB0b1Vuc2lnbmVkKHRmZHRbNF0gPDwgMjQgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmZHRbNV0gPDwgMTYgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmZHRbNl0gPDwgIDggfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmZHRbN10pO1xuICAgICAgICBpZiAodmVyc2lvbiA9PT0gIDEpIHtcbiAgICAgICAgICByZXN1bHQgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgIHJlc3VsdCArPSB0b1Vuc2lnbmVkKHRmZHRbOF0gIDw8IDI0IHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZmR0WzldICA8PCAxNiB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGZkdFsxMF0gPDwgIDggfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmZHRbMTFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSlbMF07XG4gICAgICBiYXNlVGltZSA9IGJhc2VUaW1lIHx8IEluZmluaXR5O1xuXG4gICAgICAvLyBjb252ZXJ0IGJhc2UgdGltZSB0byBzZWNvbmRzXG4gICAgICByZXR1cm4gYmFzZVRpbWUgLyBzY2FsZTtcbiAgICB9KTtcbiAgfSkpO1xuXG4gIC8vIHJldHVybiB0aGUgbWluaW11bVxuICByZXN1bHQgPSBNYXRoLm1pbi5hcHBseShudWxsLCBiYXNlVGltZXMpO1xuICByZXR1cm4gaXNGaW5pdGUocmVzdWx0KSA/IHJlc3VsdCA6IDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VUeXBlOiBwYXJzZVR5cGUsXG4gIHRpbWVzY2FsZTogdGltZXNjYWxlLFxuICBzdGFydFRpbWU6IHN0YXJ0VGltZVxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mux.js/lib/mp4/probe.js\n");

/***/ }),

/***/ "./node_modules/mux.js/lib/tools/ts-inspector.js":
/*!*******************************************************!*\
  !*** ./node_modules/mux.js/lib/tools/ts-inspector.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Parse mpeg2 transport stream packets to extract basic timing information\n */\n\n\nvar StreamTypes = __webpack_require__(/*! ../m2ts/stream-types.js */ \"./node_modules/mux.js/lib/m2ts/stream-types.js\");\nvar handleRollover = __webpack_require__(/*! ../m2ts/timestamp-rollover-stream.js */ \"./node_modules/mux.js/lib/m2ts/timestamp-rollover-stream.js\").handleRollover;\nvar probe = {};\nprobe.ts = __webpack_require__(/*! ../m2ts/probe.js */ \"./node_modules/mux.js/lib/m2ts/probe.js\");\nprobe.aac = __webpack_require__(/*! ../aac/probe.js */ \"./node_modules/mux.js/lib/aac/probe.js\");\n\n\nvar\n  PES_TIMESCALE = 90000,\n  MP2T_PACKET_LENGTH = 188, // bytes\n  SYNC_BYTE = 0x47;\n\nvar isLikelyAacData = function(data) {\n  if ((data[0] === 'I'.charCodeAt(0)) &&\n      (data[1] === 'D'.charCodeAt(0)) &&\n      (data[2] === '3'.charCodeAt(0))) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * walks through segment data looking for pat and pmt packets to parse out\n * program map table information\n */\nvar parsePsi_ = function(bytes, pmt) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type;\n\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pat':\n          if (!pmt.pid) {\n            pmt.pid = probe.ts.parsePat(packet);\n          }\n          break;\n        case 'pmt':\n          if (!pmt.table) {\n            pmt.table = probe.ts.parsePmt(packet);\n          }\n          break;\n        default:\n          break;\n      }\n\n      // Found the pat and pmt, we can stop walking the segment\n      if (pmt.pid && pmt.table) {\n        return;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n};\n\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last audio pes packets\n */\nvar parseAudioPes_ = function(bytes, pmt, result) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type, pesType, pusi, parsed;\n\n  var endLoop = false;\n\n  // Start walking from start of segment to get first audio packet\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n\n  // Start walking from end of segment to get last audio packet\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex--;\n    endIndex--;\n  }\n};\n\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last video pes packets as well as timing information for the first\n * key frame.\n */\nvar parseVideoPes_ = function(bytes, pmt, result) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type, pesType, pusi, parsed, frame, i, pes;\n\n  var endLoop = false;\n\n  var currentFrame = {\n    data: [],\n    size: 0\n  };\n\n  // Start walking from start of segment to get first video packet\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'video') {\n            if (pusi && !endLoop) {\n              parsed = probe.ts.parsePesTime(packet);\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n            }\n            if (!result.firstKeyFrame) {\n              if (pusi) {\n                if (currentFrame.size !== 0) {\n                  frame = new Uint8Array(currentFrame.size);\n                  i = 0;\n                  while (currentFrame.data.length) {\n                    pes = currentFrame.data.shift();\n                    frame.set(pes, i);\n                    i += pes.byteLength;\n                  }\n                  if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                    result.firstKeyFrame = probe.ts.parsePesTime(frame);\n                    result.firstKeyFrame.type = 'video';\n                  }\n                  currentFrame.size = 0;\n                }\n              }\n              currentFrame.data.push(packet);\n              currentFrame.size += packet.byteLength;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop && result.firstKeyFrame) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n\n  // Start walking from end of segment to get last video packet\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'video' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex--;\n    endIndex--;\n  }\n};\n\n/**\n * Adjusts the timestamp information for the segment to account for\n * rollover and convert to seconds based on pes packet timescale (90khz clock)\n */\nvar adjustTimestamp_ = function(segmentInfo, baseTimestamp) {\n  if (segmentInfo.audio && segmentInfo.audio.length) {\n    var audioBaseTimestamp = baseTimestamp;\n    if (typeof audioBaseTimestamp === 'undefined') {\n      audioBaseTimestamp = segmentInfo.audio[0].dts;\n    }\n    segmentInfo.audio.forEach(function(info) {\n      info.dts = handleRollover(info.dts, audioBaseTimestamp);\n      info.pts = handleRollover(info.pts, audioBaseTimestamp);\n      // time in seconds\n      info.dtsTime = info.dts / PES_TIMESCALE;\n      info.ptsTime = info.pts / PES_TIMESCALE;\n    });\n  }\n\n  if (segmentInfo.video && segmentInfo.video.length) {\n    var videoBaseTimestamp = baseTimestamp;\n    if (typeof videoBaseTimestamp === 'undefined') {\n      videoBaseTimestamp = segmentInfo.video[0].dts;\n    }\n    segmentInfo.video.forEach(function(info) {\n      info.dts = handleRollover(info.dts, videoBaseTimestamp);\n      info.pts = handleRollover(info.pts, videoBaseTimestamp);\n      // time in seconds\n      info.dtsTime = info.dts / PES_TIMESCALE;\n      info.ptsTime = info.pts / PES_TIMESCALE;\n    });\n    if (segmentInfo.firstKeyFrame) {\n      var frame = segmentInfo.firstKeyFrame;\n      frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n      frame.pts = handleRollover(frame.pts, videoBaseTimestamp);\n      // time in seconds\n      frame.dtsTime = frame.dts / PES_TIMESCALE;\n      frame.ptsTime = frame.dts / PES_TIMESCALE;\n    }\n  }\n};\n\n/**\n * inspects the aac data stream for start and end time information\n */\nvar inspectAac_ = function(bytes) {\n  var\n    endLoop = false,\n    audioCount = 0,\n    sampleRate = null,\n    timestamp = null,\n    frameSize = 0,\n    byteIndex = 0,\n    packet;\n\n  while (bytes.length - byteIndex >= 3) {\n    var type = probe.aac.parseType(bytes, byteIndex);\n    switch (type) {\n      case 'timed-metadata':\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (bytes.length - byteIndex < 10) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n        if (timestamp === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          timestamp = probe.aac.parseAacTimestamp(packet);\n        }\n        byteIndex += frameSize;\n        break;\n      case 'audio':\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (bytes.length - byteIndex < 7) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n        if (sampleRate === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          sampleRate = probe.aac.parseSampleRate(packet);\n        }\n        audioCount++;\n        byteIndex += frameSize;\n        break;\n      default:\n        byteIndex++;\n        break;\n    }\n    if (endLoop) {\n      return null;\n    }\n  }\n  if (sampleRate === null || timestamp === null) {\n    return null;\n  }\n\n  var audioTimescale = PES_TIMESCALE / sampleRate;\n\n  var result = {\n    audio: [\n      {\n        type: 'audio',\n        dts: timestamp,\n        pts: timestamp\n      },\n      {\n        type: 'audio',\n        dts: timestamp + (audioCount * 1024 * audioTimescale),\n        pts: timestamp + (audioCount * 1024 * audioTimescale)\n      }\n    ]\n  };\n\n  return result;\n};\n\n/**\n * inspects the transport stream segment data for start and end time information\n * of the audio and video tracks (when present) as well as the first key frame's\n * start time.\n */\nvar inspectTs_ = function(bytes) {\n  var pmt = {\n    pid: null,\n    table: null\n  };\n\n  var result = {};\n\n  parsePsi_(bytes, pmt);\n\n  for (var pid in pmt.table) {\n    if (pmt.table.hasOwnProperty(pid)) {\n      var type = pmt.table[pid];\n      switch (type) {\n        case StreamTypes.H264_STREAM_TYPE:\n          result.video = [];\n          parseVideoPes_(bytes, pmt, result);\n          if (result.video.length === 0) {\n            delete result.video;\n          }\n          break;\n        case StreamTypes.ADTS_STREAM_TYPE:\n          result.audio = [];\n          parseAudioPes_(bytes, pmt, result);\n          if (result.audio.length === 0) {\n            delete result.audio;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Inspects segment byte data and returns an object with start and end timing information\n *\n * @param {Uint8Array} bytes The segment byte data\n * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\n *  timestamps for rollover. This value must be in 90khz clock.\n * @return {Object} Object containing start and end frame timing info of segment.\n */\nvar inspect = function(bytes, baseTimestamp) {\n  var isAacData = isLikelyAacData(bytes);\n\n  var result;\n\n  if (isAacData) {\n    result = inspectAac_(bytes);\n  } else {\n    result = inspectTs_(bytes);\n  }\n\n  if (!result || (!result.audio && !result.video)) {\n    return null;\n  }\n\n  adjustTimestamp_(result, baseTimestamp);\n\n  return result;\n};\n\nmodule.exports = {\n  inspect: inspect\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi90b29scy90cy1pbnNwZWN0b3IuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi90b29scy90cy1pbnNwZWN0b3IuanM/ZGMzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG11eC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBCcmlnaHRjb3ZlXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFBhcnNlIG1wZWcyIHRyYW5zcG9ydCBzdHJlYW0gcGFja2V0cyB0byBleHRyYWN0IGJhc2ljIHRpbWluZyBpbmZvcm1hdGlvblxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTdHJlYW1UeXBlcyA9IHJlcXVpcmUoJy4uL20ydHMvc3RyZWFtLXR5cGVzLmpzJyk7XG52YXIgaGFuZGxlUm9sbG92ZXIgPSByZXF1aXJlKCcuLi9tMnRzL3RpbWVzdGFtcC1yb2xsb3Zlci1zdHJlYW0uanMnKS5oYW5kbGVSb2xsb3ZlcjtcbnZhciBwcm9iZSA9IHt9O1xucHJvYmUudHMgPSByZXF1aXJlKCcuLi9tMnRzL3Byb2JlLmpzJyk7XG5wcm9iZS5hYWMgPSByZXF1aXJlKCcuLi9hYWMvcHJvYmUuanMnKTtcblxuXG52YXJcbiAgUEVTX1RJTUVTQ0FMRSA9IDkwMDAwLFxuICBNUDJUX1BBQ0tFVF9MRU5HVEggPSAxODgsIC8vIGJ5dGVzXG4gIFNZTkNfQllURSA9IDB4NDc7XG5cbnZhciBpc0xpa2VseUFhY0RhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGlmICgoZGF0YVswXSA9PT0gJ0knLmNoYXJDb2RlQXQoMCkpICYmXG4gICAgICAoZGF0YVsxXSA9PT0gJ0QnLmNoYXJDb2RlQXQoMCkpICYmXG4gICAgICAoZGF0YVsyXSA9PT0gJzMnLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiB3YWxrcyB0aHJvdWdoIHNlZ21lbnQgZGF0YSBsb29raW5nIGZvciBwYXQgYW5kIHBtdCBwYWNrZXRzIHRvIHBhcnNlIG91dFxuICogcHJvZ3JhbSBtYXAgdGFibGUgaW5mb3JtYXRpb25cbiAqL1xudmFyIHBhcnNlUHNpXyA9IGZ1bmN0aW9uKGJ5dGVzLCBwbXQpIHtcbiAgdmFyXG4gICAgc3RhcnRJbmRleCA9IDAsXG4gICAgZW5kSW5kZXggPSBNUDJUX1BBQ0tFVF9MRU5HVEgsXG4gICAgcGFja2V0LCB0eXBlO1xuXG4gIHdoaWxlIChlbmRJbmRleCA8IGJ5dGVzLmJ5dGVMZW5ndGgpIHtcbiAgICAvLyBMb29rIGZvciBhIHBhaXIgb2Ygc3RhcnQgYW5kIGVuZCBzeW5jIGJ5dGVzIGluIHRoZSBkYXRhLi5cbiAgICBpZiAoYnl0ZXNbc3RhcnRJbmRleF0gPT09IFNZTkNfQllURSAmJiBieXRlc1tlbmRJbmRleF0gPT09IFNZTkNfQllURSkge1xuICAgICAgLy8gV2UgZm91bmQgYSBwYWNrZXRcbiAgICAgIHBhY2tldCA9IGJ5dGVzLnN1YmFycmF5KHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICAgIHR5cGUgPSBwcm9iZS50cy5wYXJzZVR5cGUocGFja2V0LCBwbXQucGlkKTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3BhdCc6XG4gICAgICAgICAgaWYgKCFwbXQucGlkKSB7XG4gICAgICAgICAgICBwbXQucGlkID0gcHJvYmUudHMucGFyc2VQYXQocGFja2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3BtdCc6XG4gICAgICAgICAgaWYgKCFwbXQudGFibGUpIHtcbiAgICAgICAgICAgIHBtdC50YWJsZSA9IHByb2JlLnRzLnBhcnNlUG10KHBhY2tldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3VuZCB0aGUgcGF0IGFuZCBwbXQsIHdlIGNhbiBzdG9wIHdhbGtpbmcgdGhlIHNlZ21lbnRcbiAgICAgIGlmIChwbXQucGlkICYmIHBtdC50YWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0SW5kZXggKz0gTVAyVF9QQUNLRVRfTEVOR1RIO1xuICAgICAgZW5kSW5kZXggKz0gTVAyVF9QQUNLRVRfTEVOR1RIO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHdlIGhhdmUgc29tZWhvdyBiZWNvbWUgZGUtc3luY2hyb25pemVkIGFuZCB3ZSBuZWVkIHRvIHN0ZXBcbiAgICAvLyBmb3J3YXJkIG9uZSBieXRlIGF0IGEgdGltZSB1bnRpbCB3ZSBmaW5kIGEgcGFpciBvZiBzeW5jIGJ5dGVzIHRoYXQgZGVub3RlXG4gICAgLy8gYSBwYWNrZXRcbiAgICBzdGFydEluZGV4Kys7XG4gICAgZW5kSW5kZXgrKztcbiAgfVxufTtcblxuLyoqXG4gKiB3YWxrcyB0aHJvdWdoIHRoZSBzZWdtZW50IGRhdGEgZnJvbSB0aGUgc3RhcnQgYW5kIGVuZCB0byBnZXQgdGltaW5nIGluZm9ybWF0aW9uXG4gKiBmb3IgdGhlIGZpcnN0IGFuZCBsYXN0IGF1ZGlvIHBlcyBwYWNrZXRzXG4gKi9cbnZhciBwYXJzZUF1ZGlvUGVzXyA9IGZ1bmN0aW9uKGJ5dGVzLCBwbXQsIHJlc3VsdCkge1xuICB2YXJcbiAgICBzdGFydEluZGV4ID0gMCxcbiAgICBlbmRJbmRleCA9IE1QMlRfUEFDS0VUX0xFTkdUSCxcbiAgICBwYWNrZXQsIHR5cGUsIHBlc1R5cGUsIHB1c2ksIHBhcnNlZDtcblxuICB2YXIgZW5kTG9vcCA9IGZhbHNlO1xuXG4gIC8vIFN0YXJ0IHdhbGtpbmcgZnJvbSBzdGFydCBvZiBzZWdtZW50IHRvIGdldCBmaXJzdCBhdWRpbyBwYWNrZXRcbiAgd2hpbGUgKGVuZEluZGV4IDwgYnl0ZXMuYnl0ZUxlbmd0aCkge1xuICAgIC8vIExvb2sgZm9yIGEgcGFpciBvZiBzdGFydCBhbmQgZW5kIHN5bmMgYnl0ZXMgaW4gdGhlIGRhdGEuLlxuICAgIGlmIChieXRlc1tzdGFydEluZGV4XSA9PT0gU1lOQ19CWVRFICYmIGJ5dGVzW2VuZEluZGV4XSA9PT0gU1lOQ19CWVRFKSB7XG4gICAgICAvLyBXZSBmb3VuZCBhIHBhY2tldFxuICAgICAgcGFja2V0ID0gYnl0ZXMuc3ViYXJyYXkoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgdHlwZSA9IHByb2JlLnRzLnBhcnNlVHlwZShwYWNrZXQsIHBtdC5waWQpO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncGVzJzpcbiAgICAgICAgICBwZXNUeXBlID0gcHJvYmUudHMucGFyc2VQZXNUeXBlKHBhY2tldCwgcG10LnRhYmxlKTtcbiAgICAgICAgICBwdXNpID0gcHJvYmUudHMucGFyc2VQYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yKHBhY2tldCk7XG4gICAgICAgICAgaWYgKHBlc1R5cGUgPT09ICdhdWRpbycgJiYgcHVzaSkge1xuICAgICAgICAgICAgcGFyc2VkID0gcHJvYmUudHMucGFyc2VQZXNUaW1lKHBhY2tldCk7XG4gICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgIHBhcnNlZC50eXBlID0gJ2F1ZGlvJztcbiAgICAgICAgICAgICAgcmVzdWx0LmF1ZGlvLnB1c2gocGFyc2VkKTtcbiAgICAgICAgICAgICAgZW5kTG9vcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kTG9vcCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc3RhcnRJbmRleCArPSBNUDJUX1BBQ0tFVF9MRU5HVEg7XG4gICAgICBlbmRJbmRleCArPSBNUDJUX1BBQ0tFVF9MRU5HVEg7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgd2UgaGF2ZSBzb21laG93IGJlY29tZSBkZS1zeW5jaHJvbml6ZWQgYW5kIHdlIG5lZWQgdG8gc3RlcFxuICAgIC8vIGZvcndhcmQgb25lIGJ5dGUgYXQgYSB0aW1lIHVudGlsIHdlIGZpbmQgYSBwYWlyIG9mIHN5bmMgYnl0ZXMgdGhhdCBkZW5vdGVcbiAgICAvLyBhIHBhY2tldFxuICAgIHN0YXJ0SW5kZXgrKztcbiAgICBlbmRJbmRleCsrO1xuICB9XG5cbiAgLy8gU3RhcnQgd2Fsa2luZyBmcm9tIGVuZCBvZiBzZWdtZW50IHRvIGdldCBsYXN0IGF1ZGlvIHBhY2tldFxuICBlbmRJbmRleCA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gIHN0YXJ0SW5kZXggPSBlbmRJbmRleCAtIE1QMlRfUEFDS0VUX0xFTkdUSDtcbiAgZW5kTG9vcCA9IGZhbHNlO1xuICB3aGlsZSAoc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgLy8gTG9vayBmb3IgYSBwYWlyIG9mIHN0YXJ0IGFuZCBlbmQgc3luYyBieXRlcyBpbiB0aGUgZGF0YS4uXG4gICAgaWYgKGJ5dGVzW3N0YXJ0SW5kZXhdID09PSBTWU5DX0JZVEUgJiYgYnl0ZXNbZW5kSW5kZXhdID09PSBTWU5DX0JZVEUpIHtcbiAgICAgIC8vIFdlIGZvdW5kIGEgcGFja2V0XG4gICAgICBwYWNrZXQgPSBieXRlcy5zdWJhcnJheShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICB0eXBlID0gcHJvYmUudHMucGFyc2VUeXBlKHBhY2tldCwgcG10LnBpZCk7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdwZXMnOlxuICAgICAgICAgIHBlc1R5cGUgPSBwcm9iZS50cy5wYXJzZVBlc1R5cGUocGFja2V0LCBwbXQudGFibGUpO1xuICAgICAgICAgIHB1c2kgPSBwcm9iZS50cy5wYXJzZVBheWxvYWRVbml0U3RhcnRJbmRpY2F0b3IocGFja2V0KTtcbiAgICAgICAgICBpZiAocGVzVHlwZSA9PT0gJ2F1ZGlvJyAmJiBwdXNpKSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBwcm9iZS50cy5wYXJzZVBlc1RpbWUocGFja2V0KTtcbiAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgcGFyc2VkLnR5cGUgPSAnYXVkaW8nO1xuICAgICAgICAgICAgICByZXN1bHQuYXVkaW8ucHVzaChwYXJzZWQpO1xuICAgICAgICAgICAgICBlbmRMb29wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRMb29wKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdGFydEluZGV4IC09IE1QMlRfUEFDS0VUX0xFTkdUSDtcbiAgICAgIGVuZEluZGV4IC09IE1QMlRfUEFDS0VUX0xFTkdUSDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIHNvbWVob3cgYmVjb21lIGRlLXN5bmNocm9uaXplZCBhbmQgd2UgbmVlZCB0byBzdGVwXG4gICAgLy8gZm9yd2FyZCBvbmUgYnl0ZSBhdCBhIHRpbWUgdW50aWwgd2UgZmluZCBhIHBhaXIgb2Ygc3luYyBieXRlcyB0aGF0IGRlbm90ZVxuICAgIC8vIGEgcGFja2V0XG4gICAgc3RhcnRJbmRleC0tO1xuICAgIGVuZEluZGV4LS07XG4gIH1cbn07XG5cbi8qKlxuICogd2Fsa3MgdGhyb3VnaCB0aGUgc2VnbWVudCBkYXRhIGZyb20gdGhlIHN0YXJ0IGFuZCBlbmQgdG8gZ2V0IHRpbWluZyBpbmZvcm1hdGlvblxuICogZm9yIHRoZSBmaXJzdCBhbmQgbGFzdCB2aWRlbyBwZXMgcGFja2V0cyBhcyB3ZWxsIGFzIHRpbWluZyBpbmZvcm1hdGlvbiBmb3IgdGhlIGZpcnN0XG4gKiBrZXkgZnJhbWUuXG4gKi9cbnZhciBwYXJzZVZpZGVvUGVzXyA9IGZ1bmN0aW9uKGJ5dGVzLCBwbXQsIHJlc3VsdCkge1xuICB2YXJcbiAgICBzdGFydEluZGV4ID0gMCxcbiAgICBlbmRJbmRleCA9IE1QMlRfUEFDS0VUX0xFTkdUSCxcbiAgICBwYWNrZXQsIHR5cGUsIHBlc1R5cGUsIHB1c2ksIHBhcnNlZCwgZnJhbWUsIGksIHBlcztcblxuICB2YXIgZW5kTG9vcCA9IGZhbHNlO1xuXG4gIHZhciBjdXJyZW50RnJhbWUgPSB7XG4gICAgZGF0YTogW10sXG4gICAgc2l6ZTogMFxuICB9O1xuXG4gIC8vIFN0YXJ0IHdhbGtpbmcgZnJvbSBzdGFydCBvZiBzZWdtZW50IHRvIGdldCBmaXJzdCB2aWRlbyBwYWNrZXRcbiAgd2hpbGUgKGVuZEluZGV4IDwgYnl0ZXMuYnl0ZUxlbmd0aCkge1xuICAgIC8vIExvb2sgZm9yIGEgcGFpciBvZiBzdGFydCBhbmQgZW5kIHN5bmMgYnl0ZXMgaW4gdGhlIGRhdGEuLlxuICAgIGlmIChieXRlc1tzdGFydEluZGV4XSA9PT0gU1lOQ19CWVRFICYmIGJ5dGVzW2VuZEluZGV4XSA9PT0gU1lOQ19CWVRFKSB7XG4gICAgICAvLyBXZSBmb3VuZCBhIHBhY2tldFxuICAgICAgcGFja2V0ID0gYnl0ZXMuc3ViYXJyYXkoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgdHlwZSA9IHByb2JlLnRzLnBhcnNlVHlwZShwYWNrZXQsIHBtdC5waWQpO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncGVzJzpcbiAgICAgICAgICBwZXNUeXBlID0gcHJvYmUudHMucGFyc2VQZXNUeXBlKHBhY2tldCwgcG10LnRhYmxlKTtcbiAgICAgICAgICBwdXNpID0gcHJvYmUudHMucGFyc2VQYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yKHBhY2tldCk7XG4gICAgICAgICAgaWYgKHBlc1R5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIGlmIChwdXNpICYmICFlbmRMb29wKSB7XG4gICAgICAgICAgICAgIHBhcnNlZCA9IHByb2JlLnRzLnBhcnNlUGVzVGltZShwYWNrZXQpO1xuICAgICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnR5cGUgPSAndmlkZW8nO1xuICAgICAgICAgICAgICAgIHJlc3VsdC52aWRlby5wdXNoKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgZW5kTG9vcCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0LmZpcnN0S2V5RnJhbWUpIHtcbiAgICAgICAgICAgICAgaWYgKHB1c2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lLnNpemUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGZyYW1lID0gbmV3IFVpbnQ4QXJyYXkoY3VycmVudEZyYW1lLnNpemUpO1xuICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudEZyYW1lLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcyA9IGN1cnJlbnRGcmFtZS5kYXRhLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLnNldChwZXMsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IHBlcy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHByb2JlLnRzLnZpZGVvUGFja2V0Q29udGFpbnNLZXlGcmFtZShmcmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZpcnN0S2V5RnJhbWUgPSBwcm9iZS50cy5wYXJzZVBlc1RpbWUoZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZmlyc3RLZXlGcmFtZS50eXBlID0gJ3ZpZGVvJztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZS5zaXplID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudEZyYW1lLmRhdGEucHVzaChwYWNrZXQpO1xuICAgICAgICAgICAgICBjdXJyZW50RnJhbWUuc2l6ZSArPSBwYWNrZXQuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRMb29wICYmIHJlc3VsdC5maXJzdEtleUZyYW1lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdGFydEluZGV4ICs9IE1QMlRfUEFDS0VUX0xFTkdUSDtcbiAgICAgIGVuZEluZGV4ICs9IE1QMlRfUEFDS0VUX0xFTkdUSDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIHNvbWVob3cgYmVjb21lIGRlLXN5bmNocm9uaXplZCBhbmQgd2UgbmVlZCB0byBzdGVwXG4gICAgLy8gZm9yd2FyZCBvbmUgYnl0ZSBhdCBhIHRpbWUgdW50aWwgd2UgZmluZCBhIHBhaXIgb2Ygc3luYyBieXRlcyB0aGF0IGRlbm90ZVxuICAgIC8vIGEgcGFja2V0XG4gICAgc3RhcnRJbmRleCsrO1xuICAgIGVuZEluZGV4Kys7XG4gIH1cblxuICAvLyBTdGFydCB3YWxraW5nIGZyb20gZW5kIG9mIHNlZ21lbnQgdG8gZ2V0IGxhc3QgdmlkZW8gcGFja2V0XG4gIGVuZEluZGV4ID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgc3RhcnRJbmRleCA9IGVuZEluZGV4IC0gTVAyVF9QQUNLRVRfTEVOR1RIO1xuICBlbmRMb29wID0gZmFsc2U7XG4gIHdoaWxlIChzdGFydEluZGV4ID49IDApIHtcbiAgICAvLyBMb29rIGZvciBhIHBhaXIgb2Ygc3RhcnQgYW5kIGVuZCBzeW5jIGJ5dGVzIGluIHRoZSBkYXRhLi5cbiAgICBpZiAoYnl0ZXNbc3RhcnRJbmRleF0gPT09IFNZTkNfQllURSAmJiBieXRlc1tlbmRJbmRleF0gPT09IFNZTkNfQllURSkge1xuICAgICAgLy8gV2UgZm91bmQgYSBwYWNrZXRcbiAgICAgIHBhY2tldCA9IGJ5dGVzLnN1YmFycmF5KHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICAgIHR5cGUgPSBwcm9iZS50cy5wYXJzZVR5cGUocGFja2V0LCBwbXQucGlkKTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3Blcyc6XG4gICAgICAgICAgcGVzVHlwZSA9IHByb2JlLnRzLnBhcnNlUGVzVHlwZShwYWNrZXQsIHBtdC50YWJsZSk7XG4gICAgICAgICAgcHVzaSA9IHByb2JlLnRzLnBhcnNlUGF5bG9hZFVuaXRTdGFydEluZGljYXRvcihwYWNrZXQpO1xuICAgICAgICAgIGlmIChwZXNUeXBlID09PSAndmlkZW8nICYmIHB1c2kpIHtcbiAgICAgICAgICAgICAgcGFyc2VkID0gcHJvYmUudHMucGFyc2VQZXNUaW1lKHBhY2tldCk7XG4gICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQudHlwZSA9ICd2aWRlbyc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpZGVvLnB1c2gocGFyc2VkKTtcbiAgICAgICAgICAgICAgICBlbmRMb29wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZExvb3ApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0SW5kZXggLT0gTVAyVF9QQUNLRVRfTEVOR1RIO1xuICAgICAgZW5kSW5kZXggLT0gTVAyVF9QQUNLRVRfTEVOR1RIO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHdlIGhhdmUgc29tZWhvdyBiZWNvbWUgZGUtc3luY2hyb25pemVkIGFuZCB3ZSBuZWVkIHRvIHN0ZXBcbiAgICAvLyBmb3J3YXJkIG9uZSBieXRlIGF0IGEgdGltZSB1bnRpbCB3ZSBmaW5kIGEgcGFpciBvZiBzeW5jIGJ5dGVzIHRoYXQgZGVub3RlXG4gICAgLy8gYSBwYWNrZXRcbiAgICBzdGFydEluZGV4LS07XG4gICAgZW5kSW5kZXgtLTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGp1c3RzIHRoZSB0aW1lc3RhbXAgaW5mb3JtYXRpb24gZm9yIHRoZSBzZWdtZW50IHRvIGFjY291bnQgZm9yXG4gKiByb2xsb3ZlciBhbmQgY29udmVydCB0byBzZWNvbmRzIGJhc2VkIG9uIHBlcyBwYWNrZXQgdGltZXNjYWxlICg5MGtoeiBjbG9jaylcbiAqL1xudmFyIGFkanVzdFRpbWVzdGFtcF8gPSBmdW5jdGlvbihzZWdtZW50SW5mbywgYmFzZVRpbWVzdGFtcCkge1xuICBpZiAoc2VnbWVudEluZm8uYXVkaW8gJiYgc2VnbWVudEluZm8uYXVkaW8ubGVuZ3RoKSB7XG4gICAgdmFyIGF1ZGlvQmFzZVRpbWVzdGFtcCA9IGJhc2VUaW1lc3RhbXA7XG4gICAgaWYgKHR5cGVvZiBhdWRpb0Jhc2VUaW1lc3RhbXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhdWRpb0Jhc2VUaW1lc3RhbXAgPSBzZWdtZW50SW5mby5hdWRpb1swXS5kdHM7XG4gICAgfVxuICAgIHNlZ21lbnRJbmZvLmF1ZGlvLmZvckVhY2goZnVuY3Rpb24oaW5mbykge1xuICAgICAgaW5mby5kdHMgPSBoYW5kbGVSb2xsb3ZlcihpbmZvLmR0cywgYXVkaW9CYXNlVGltZXN0YW1wKTtcbiAgICAgIGluZm8ucHRzID0gaGFuZGxlUm9sbG92ZXIoaW5mby5wdHMsIGF1ZGlvQmFzZVRpbWVzdGFtcCk7XG4gICAgICAvLyB0aW1lIGluIHNlY29uZHNcbiAgICAgIGluZm8uZHRzVGltZSA9IGluZm8uZHRzIC8gUEVTX1RJTUVTQ0FMRTtcbiAgICAgIGluZm8ucHRzVGltZSA9IGluZm8ucHRzIC8gUEVTX1RJTUVTQ0FMRTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzZWdtZW50SW5mby52aWRlbyAmJiBzZWdtZW50SW5mby52aWRlby5sZW5ndGgpIHtcbiAgICB2YXIgdmlkZW9CYXNlVGltZXN0YW1wID0gYmFzZVRpbWVzdGFtcDtcbiAgICBpZiAodHlwZW9mIHZpZGVvQmFzZVRpbWVzdGFtcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZpZGVvQmFzZVRpbWVzdGFtcCA9IHNlZ21lbnRJbmZvLnZpZGVvWzBdLmR0cztcbiAgICB9XG4gICAgc2VnbWVudEluZm8udmlkZW8uZm9yRWFjaChmdW5jdGlvbihpbmZvKSB7XG4gICAgICBpbmZvLmR0cyA9IGhhbmRsZVJvbGxvdmVyKGluZm8uZHRzLCB2aWRlb0Jhc2VUaW1lc3RhbXApO1xuICAgICAgaW5mby5wdHMgPSBoYW5kbGVSb2xsb3ZlcihpbmZvLnB0cywgdmlkZW9CYXNlVGltZXN0YW1wKTtcbiAgICAgIC8vIHRpbWUgaW4gc2Vjb25kc1xuICAgICAgaW5mby5kdHNUaW1lID0gaW5mby5kdHMgLyBQRVNfVElNRVNDQUxFO1xuICAgICAgaW5mby5wdHNUaW1lID0gaW5mby5wdHMgLyBQRVNfVElNRVNDQUxFO1xuICAgIH0pO1xuICAgIGlmIChzZWdtZW50SW5mby5maXJzdEtleUZyYW1lKSB7XG4gICAgICB2YXIgZnJhbWUgPSBzZWdtZW50SW5mby5maXJzdEtleUZyYW1lO1xuICAgICAgZnJhbWUuZHRzID0gaGFuZGxlUm9sbG92ZXIoZnJhbWUuZHRzLCB2aWRlb0Jhc2VUaW1lc3RhbXApO1xuICAgICAgZnJhbWUucHRzID0gaGFuZGxlUm9sbG92ZXIoZnJhbWUucHRzLCB2aWRlb0Jhc2VUaW1lc3RhbXApO1xuICAgICAgLy8gdGltZSBpbiBzZWNvbmRzXG4gICAgICBmcmFtZS5kdHNUaW1lID0gZnJhbWUuZHRzIC8gUEVTX1RJTUVTQ0FMRTtcbiAgICAgIGZyYW1lLnB0c1RpbWUgPSBmcmFtZS5kdHMgLyBQRVNfVElNRVNDQUxFO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBpbnNwZWN0cyB0aGUgYWFjIGRhdGEgc3RyZWFtIGZvciBzdGFydCBhbmQgZW5kIHRpbWUgaW5mb3JtYXRpb25cbiAqL1xudmFyIGluc3BlY3RBYWNfID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgdmFyXG4gICAgZW5kTG9vcCA9IGZhbHNlLFxuICAgIGF1ZGlvQ291bnQgPSAwLFxuICAgIHNhbXBsZVJhdGUgPSBudWxsLFxuICAgIHRpbWVzdGFtcCA9IG51bGwsXG4gICAgZnJhbWVTaXplID0gMCxcbiAgICBieXRlSW5kZXggPSAwLFxuICAgIHBhY2tldDtcblxuICB3aGlsZSAoYnl0ZXMubGVuZ3RoIC0gYnl0ZUluZGV4ID49IDMpIHtcbiAgICB2YXIgdHlwZSA9IHByb2JlLmFhYy5wYXJzZVR5cGUoYnl0ZXMsIGJ5dGVJbmRleCk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICd0aW1lZC1tZXRhZGF0YSc6XG4gICAgICAgIC8vIEV4aXQgZWFybHkgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGVub3VnaCB0byBwYXJzZVxuICAgICAgICAvLyB0aGUgSUQzIHRhZyBoZWFkZXJcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAtIGJ5dGVJbmRleCA8IDEwKSB7XG4gICAgICAgICAgZW5kTG9vcCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFtZVNpemUgPSBwcm9iZS5hYWMucGFyc2VJZDNUYWdTaXplKGJ5dGVzLCBieXRlSW5kZXgpO1xuXG4gICAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggaW4gdGhlIGJ1ZmZlclxuICAgICAgICAvLyB0byBlbWl0IGEgZnVsbCBwYWNrZXRcbiAgICAgICAgaWYgKGZyYW1lU2l6ZSA+IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgIGVuZExvb3AgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICAgICAgICBwYWNrZXQgPSBieXRlcy5zdWJhcnJheShieXRlSW5kZXgsIGJ5dGVJbmRleCArIGZyYW1lU2l6ZSk7XG4gICAgICAgICAgdGltZXN0YW1wID0gcHJvYmUuYWFjLnBhcnNlQWFjVGltZXN0YW1wKHBhY2tldCk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZUluZGV4ICs9IGZyYW1lU2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgIC8vIEV4aXQgZWFybHkgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGVub3VnaCB0byBwYXJzZVxuICAgICAgICAvLyB0aGUgQURUUyBmcmFtZSBoZWFkZXJcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAtIGJ5dGVJbmRleCA8IDcpIHtcbiAgICAgICAgICBlbmRMb29wID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1lU2l6ZSA9IHByb2JlLmFhYy5wYXJzZUFkdHNTaXplKGJ5dGVzLCBieXRlSW5kZXgpO1xuXG4gICAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggaW4gdGhlIGJ1ZmZlclxuICAgICAgICAvLyB0byBlbWl0IGEgZnVsbCBwYWNrZXRcbiAgICAgICAgaWYgKGZyYW1lU2l6ZSA+IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgIGVuZExvb3AgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYW1wbGVSYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgcGFja2V0ID0gYnl0ZXMuc3ViYXJyYXkoYnl0ZUluZGV4LCBieXRlSW5kZXggKyBmcmFtZVNpemUpO1xuICAgICAgICAgIHNhbXBsZVJhdGUgPSBwcm9iZS5hYWMucGFyc2VTYW1wbGVSYXRlKHBhY2tldCk7XG4gICAgICAgIH1cbiAgICAgICAgYXVkaW9Db3VudCsrO1xuICAgICAgICBieXRlSW5kZXggKz0gZnJhbWVTaXplO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJ5dGVJbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGVuZExvb3ApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoc2FtcGxlUmF0ZSA9PT0gbnVsbCB8fCB0aW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhdWRpb1RpbWVzY2FsZSA9IFBFU19USU1FU0NBTEUgLyBzYW1wbGVSYXRlO1xuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgYXVkaW86IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgZHRzOiB0aW1lc3RhbXAsXG4gICAgICAgIHB0czogdGltZXN0YW1wXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICBkdHM6IHRpbWVzdGFtcCArIChhdWRpb0NvdW50ICogMTAyNCAqIGF1ZGlvVGltZXNjYWxlKSxcbiAgICAgICAgcHRzOiB0aW1lc3RhbXAgKyAoYXVkaW9Db3VudCAqIDEwMjQgKiBhdWRpb1RpbWVzY2FsZSlcbiAgICAgIH1cbiAgICBdXG4gIH07XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogaW5zcGVjdHMgdGhlIHRyYW5zcG9ydCBzdHJlYW0gc2VnbWVudCBkYXRhIGZvciBzdGFydCBhbmQgZW5kIHRpbWUgaW5mb3JtYXRpb25cbiAqIG9mIHRoZSBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzICh3aGVuIHByZXNlbnQpIGFzIHdlbGwgYXMgdGhlIGZpcnN0IGtleSBmcmFtZSdzXG4gKiBzdGFydCB0aW1lLlxuICovXG52YXIgaW5zcGVjdFRzXyA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHZhciBwbXQgPSB7XG4gICAgcGlkOiBudWxsLFxuICAgIHRhYmxlOiBudWxsXG4gIH07XG5cbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIHBhcnNlUHNpXyhieXRlcywgcG10KTtcblxuICBmb3IgKHZhciBwaWQgaW4gcG10LnRhYmxlKSB7XG4gICAgaWYgKHBtdC50YWJsZS5oYXNPd25Qcm9wZXJ0eShwaWQpKSB7XG4gICAgICB2YXIgdHlwZSA9IHBtdC50YWJsZVtwaWRdO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgU3RyZWFtVHlwZXMuSDI2NF9TVFJFQU1fVFlQRTpcbiAgICAgICAgICByZXN1bHQudmlkZW8gPSBbXTtcbiAgICAgICAgICBwYXJzZVZpZGVvUGVzXyhieXRlcywgcG10LCByZXN1bHQpO1xuICAgICAgICAgIGlmIChyZXN1bHQudmlkZW8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVzdWx0LnZpZGVvO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTdHJlYW1UeXBlcy5BRFRTX1NUUkVBTV9UWVBFOlxuICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IFtdO1xuICAgICAgICAgIHBhcnNlQXVkaW9QZXNfKGJ5dGVzLCBwbXQsIHJlc3VsdCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5hdWRpby5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQuYXVkaW87XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBJbnNwZWN0cyBzZWdtZW50IGJ5dGUgZGF0YSBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBzdGFydCBhbmQgZW5kIHRpbWluZyBpbmZvcm1hdGlvblxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXMgVGhlIHNlZ21lbnQgYnl0ZSBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gYmFzZVRpbWVzdGFtcCBSZWxhdGl2ZSByZWZlcmVuY2UgdGltZXN0YW1wIHVzZWQgd2hlbiBhZGp1c3RpbmcgZnJhbWVcbiAqICB0aW1lc3RhbXBzIGZvciByb2xsb3Zlci4gVGhpcyB2YWx1ZSBtdXN0IGJlIGluIDkwa2h6IGNsb2NrLlxuICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyBzdGFydCBhbmQgZW5kIGZyYW1lIHRpbWluZyBpbmZvIG9mIHNlZ21lbnQuXG4gKi9cbnZhciBpbnNwZWN0ID0gZnVuY3Rpb24oYnl0ZXMsIGJhc2VUaW1lc3RhbXApIHtcbiAgdmFyIGlzQWFjRGF0YSA9IGlzTGlrZWx5QWFjRGF0YShieXRlcyk7XG5cbiAgdmFyIHJlc3VsdDtcblxuICBpZiAoaXNBYWNEYXRhKSB7XG4gICAgcmVzdWx0ID0gaW5zcGVjdEFhY18oYnl0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGluc3BlY3RUc18oYnl0ZXMpO1xuICB9XG5cbiAgaWYgKCFyZXN1bHQgfHwgKCFyZXN1bHQuYXVkaW8gJiYgIXJlc3VsdC52aWRlbykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGFkanVzdFRpbWVzdGFtcF8ocmVzdWx0LCBiYXNlVGltZXN0YW1wKTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluc3BlY3Q6IGluc3BlY3Rcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mux.js/lib/tools/ts-inspector.js\n");

/***/ }),

/***/ "./node_modules/mux.js/lib/utils/bin.js":
/*!**********************************************!*\
  !*** ./node_modules/mux.js/lib/utils/bin.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toUnsigned = function(value) {\n  return value >>> 0;\n};\n\nmodule.exports = {\n  toUnsigned: toUnsigned\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi91dGlscy9iaW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi91dGlscy9iaW4uanM/N2ZlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9VbnNpZ25lZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA+Pj4gMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0b1Vuc2lnbmVkOiB0b1Vuc2lnbmVkXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mux.js/lib/utils/bin.js\n");

/***/ }),

/***/ "./node_modules/mux.js/lib/utils/stream.js":
/*!*************************************************!*\
  !*** ./node_modules/mux.js/lib/utils/stream.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * mux.js\n *\n * Copyright (c) 2014 Brightcove\n * All rights reserved.\n *\n * A lightweight readable stream implemention that handles event dispatching.\n * Objects that inherit from streams should call init in their constructors.\n */\n\n\nvar Stream = function() {\n  this.init = function() {\n    var listeners = {};\n    /**\n     * Add a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} the callback to be invoked when an event of\n     * the specified type occurs\n     */\n    this.on = function(type, listener) {\n      if (!listeners[type]) {\n        listeners[type] = [];\n      }\n      listeners[type] = listeners[type].concat(listener);\n    };\n    /**\n     * Remove a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} a function previously registered for this\n     * type of event through `on`\n     */\n    this.off = function(type, listener) {\n      var index;\n      if (!listeners[type]) {\n        return false;\n      }\n      index = listeners[type].indexOf(listener);\n      listeners[type] = listeners[type].slice();\n      listeners[type].splice(index, 1);\n      return index > -1;\n    };\n    /**\n     * Trigger an event of the specified type on this stream. Any additional\n     * arguments to this function are passed as parameters to event listeners.\n     * @param type {string} the event name\n     */\n    this.trigger = function(type) {\n      var callbacks, i, length, args;\n      callbacks = listeners[type];\n      if (!callbacks) {\n        return;\n      }\n      // Slicing the arguments on every invocation of this method\n      // can add a significant amount of overhead. Avoid the\n      // intermediate object creation for the common case of a\n      // single callback argument\n      if (arguments.length === 2) {\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].call(this, arguments[1]);\n        }\n      } else {\n        args = [];\n        i = arguments.length;\n        for (i = 1; i < arguments.length; ++i) {\n          args.push(arguments[i]);\n        }\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].apply(this, args);\n        }\n      }\n    };\n    /**\n     * Destroys the stream and cleans up.\n     */\n    this.dispose = function() {\n      listeners = {};\n    };\n  };\n};\n\n/**\n * Forwards all `data` events on this stream to the destination stream. The\n * destination stream should provide a method `push` to receive the data\n * events as they arrive.\n * @param destination {stream} the stream that will receive all `data` events\n * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n *                            when the current stream emits a 'done' event\n * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n */\nStream.prototype.pipe = function(destination) {\n  this.on('data', function(data) {\n    destination.push(data);\n  });\n\n  this.on('done', function(flushSource) {\n    destination.flush(flushSource);\n  });\n\n  return destination;\n};\n\n// Default stream functions that are expected to be overridden to perform\n// actual work. These are provided by the prototype as a sort of no-op\n// implementation so that we don't have to check for their existence in the\n// `pipe` function above.\nStream.prototype.push = function(data) {\n  this.trigger('data', data);\n};\n\nStream.prototype.flush = function(flushSource) {\n  this.trigger('done', flushSource);\n};\n\nmodule.exports = Stream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi91dGlscy9zdHJlYW0uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi91dGlscy9zdHJlYW0uanM/NDMyOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG11eC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcmlnaHRjb3ZlXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIEEgbGlnaHR3ZWlnaHQgcmVhZGFibGUgc3RyZWFtIGltcGxlbWVudGlvbiB0aGF0IGhhbmRsZXMgZXZlbnQgZGlzcGF0Y2hpbmcuXG4gKiBPYmplY3RzIHRoYXQgaW5oZXJpdCBmcm9tIHN0cmVhbXMgc2hvdWxkIGNhbGwgaW5pdCBpbiB0aGVpciBjb25zdHJ1Y3RvcnMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0ge307XG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHR5cGUge3N0cmluZ30gdGhlIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIge2Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGFuIGV2ZW50IG9mXG4gICAgICogdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vyc1xuICAgICAqL1xuICAgIHRoaXMub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKCFsaXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgbGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcnNbdHlwZV0uY29uY2F0KGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIGZvciBhIHNwZWNpZmllZCBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSB0eXBlIHtzdHJpbmd9IHRoZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIHtmdW5jdGlvbn0gYSBmdW5jdGlvbiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgZm9yIHRoaXNcbiAgICAgKiB0eXBlIG9mIGV2ZW50IHRocm91Z2ggYG9uYFxuICAgICAqL1xuICAgIHRoaXMub2ZmID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBpbmRleDtcbiAgICAgIGlmICghbGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGluZGV4ID0gbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXJzW3R5cGVdLnNsaWNlKCk7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHJldHVybiBpbmRleCA+IC0xO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb24gdGhpcyBzdHJlYW0uIEFueSBhZGRpdGlvbmFsXG4gICAgICogYXJndW1lbnRzIHRvIHRoaXMgZnVuY3Rpb24gYXJlIHBhc3NlZCBhcyBwYXJhbWV0ZXJzIHRvIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfSB0aGUgZXZlbnQgbmFtZVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBjYWxsYmFja3MsIGksIGxlbmd0aCwgYXJncztcbiAgICAgIGNhbGxiYWNrcyA9IGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFNsaWNpbmcgdGhlIGFyZ3VtZW50cyBvbiBldmVyeSBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kXG4gICAgICAvLyBjYW4gYWRkIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mIG92ZXJoZWFkLiBBdm9pZCB0aGVcbiAgICAgIC8vIGludGVybWVkaWF0ZSBvYmplY3QgY3JlYXRpb24gZm9yIHRoZSBjb21tb24gY2FzZSBvZiBhXG4gICAgICAvLyBzaW5nbGUgY2FsbGJhY2sgYXJndW1lbnRcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGxlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBzdHJlYW0gYW5kIGNsZWFucyB1cC5cbiAgICAgKi9cbiAgICB0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGxpc3RlbmVycyA9IHt9O1xuICAgIH07XG4gIH07XG59O1xuXG4vKipcbiAqIEZvcndhcmRzIGFsbCBgZGF0YWAgZXZlbnRzIG9uIHRoaXMgc3RyZWFtIHRvIHRoZSBkZXN0aW5hdGlvbiBzdHJlYW0uIFRoZVxuICogZGVzdGluYXRpb24gc3RyZWFtIHNob3VsZCBwcm92aWRlIGEgbWV0aG9kIGBwdXNoYCB0byByZWNlaXZlIHRoZSBkYXRhXG4gKiBldmVudHMgYXMgdGhleSBhcnJpdmUuXG4gKiBAcGFyYW0gZGVzdGluYXRpb24ge3N0cmVhbX0gdGhlIHN0cmVhbSB0aGF0IHdpbGwgcmVjZWl2ZSBhbGwgYGRhdGFgIGV2ZW50c1xuICogQHBhcmFtIGF1dG9GbHVzaCB7Ym9vbGVhbn0gaWYgZmFsc2UsIHdlIHdpbGwgbm90IGNhbGwgYGZsdXNoYCBvbiB0aGUgZGVzdGluYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIGN1cnJlbnQgc3RyZWFtIGVtaXRzIGEgJ2RvbmUnIGV2ZW50XG4gKiBAc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fcmVhZGFibGVfcGlwZV9kZXN0aW5hdGlvbl9vcHRpb25zXG4gKi9cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3RpbmF0aW9uKSB7XG4gIHRoaXMub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgZGVzdGluYXRpb24ucHVzaChkYXRhKTtcbiAgfSk7XG5cbiAgdGhpcy5vbignZG9uZScsIGZ1bmN0aW9uKGZsdXNoU291cmNlKSB7XG4gICAgZGVzdGluYXRpb24uZmx1c2goZmx1c2hTb3VyY2UpO1xuICB9KTtcblxuICByZXR1cm4gZGVzdGluYXRpb247XG59O1xuXG4vLyBEZWZhdWx0IHN0cmVhbSBmdW5jdGlvbnMgdGhhdCBhcmUgZXhwZWN0ZWQgdG8gYmUgb3ZlcnJpZGRlbiB0byBwZXJmb3JtXG4vLyBhY3R1YWwgd29yay4gVGhlc2UgYXJlIHByb3ZpZGVkIGJ5IHRoZSBwcm90b3R5cGUgYXMgYSBzb3J0IG9mIG5vLW9wXG4vLyBpbXBsZW1lbnRhdGlvbiBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hlY2sgZm9yIHRoZWlyIGV4aXN0ZW5jZSBpbiB0aGVcbi8vIGBwaXBlYCBmdW5jdGlvbiBhYm92ZS5cblN0cmVhbS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZGF0YSk7XG59O1xuXG5TdHJlYW0ucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oZmx1c2hTb3VyY2UpIHtcbiAgdGhpcy50cmlnZ2VyKCdkb25lJywgZmx1c2hTb3VyY2UpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mux.js/lib/utils/stream.js\n");

/***/ }),

/***/ "./node_modules/parse-headers/parse-headers.js":
/*!*****************************************************!*\
  !*** ./node_modules/parse-headers/parse-headers.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var trim = __webpack_require__(/*! trim */ \"./node_modules/trim/index.js\")\n  , forEach = __webpack_require__(/*! for-each */ \"./node_modules/for-each/index.js\")\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  forEach(\n      trim(headers).split('\\n')\n    , function (row) {\n        var index = row.indexOf(':')\n          , key = trim(row.slice(0, index)).toLowerCase()\n          , value = trim(row.slice(index + 1))\n\n        if (typeof(result[key]) === 'undefined') {\n          result[key] = value\n        } else if (isArray(result[key])) {\n          result[key].push(value)\n        } else {\n          result[key] = [ result[key], value ]\n        }\n      }\n  )\n\n  return result\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9wYXJzZS1oZWFkZXJzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qcz82NDQ0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB0cmltID0gcmVxdWlyZSgndHJpbScpXG4gICwgZm9yRWFjaCA9IHJlcXVpcmUoJ2Zvci1lYWNoJylcbiAgLCBpc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gIGlmICghaGVhZGVycylcbiAgICByZXR1cm4ge31cblxuICB2YXIgcmVzdWx0ID0ge31cblxuICBmb3JFYWNoKFxuICAgICAgdHJpbShoZWFkZXJzKS5zcGxpdCgnXFxuJylcbiAgICAsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcm93LmluZGV4T2YoJzonKVxuICAgICAgICAgICwga2V5ID0gdHJpbShyb3cuc2xpY2UoMCwgaW5kZXgpKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgLCB2YWx1ZSA9IHRyaW0ocm93LnNsaWNlKGluZGV4ICsgMSkpXG5cbiAgICAgICAgaWYgKHR5cGVvZihyZXN1bHRba2V5XSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IFsgcmVzdWx0W2tleV0sIHZhbHVlIF1cbiAgICAgICAgfVxuICAgICAgfVxuICApXG5cbiAgcmV0dXJuIHJlc3VsdFxufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/parse-headers/parse-headers.js\n");

/***/ }),

/***/ "./node_modules/pkcs7/dist/pkcs7.es.js":
/*!*********************************************!*\
  !*** ./node_modules/pkcs7/dist/pkcs7.es.js ***!
  \*********************************************/
/*! exports provided: pad, unpad, VERSION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pad\", function() { return pad; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unpad\", function() { return unpad; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return version; });\n/*\n * pkcs7.pad\n * https://github.com/brightcove/pkcs7\n *\n * Copyright (c) 2014 Brightcove\n * Licensed under the apache2 license.\n */\n\nvar PADDING = void 0;\n\n/**\n * Returns a new Uint8Array that is padded with PKCS#7 padding.\n * @param plaintext {Uint8Array} the input bytes before encryption\n * @return {Uint8Array} the padded bytes\n * @see http://tools.ietf.org/html/rfc5652\n */\nfunction pad(plaintext) {\n  var padding = PADDING[plaintext.byteLength % 16 || 0];\n  var result = new Uint8Array(plaintext.byteLength + padding.length);\n\n  result.set(plaintext);\n  result.set(padding, plaintext.byteLength);\n\n  return result;\n}\n\n// pre-define the padding values\nPADDING = [[16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16], [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15], [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14], [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13], [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12], [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11], [10, 10, 10, 10, 10, 10, 10, 10, 10, 10], [9, 9, 9, 9, 9, 9, 9, 9, 9], [8, 8, 8, 8, 8, 8, 8, 8], [7, 7, 7, 7, 7, 7, 7], [6, 6, 6, 6, 6, 6], [5, 5, 5, 5, 5], [4, 4, 4, 4], [3, 3, 3], [2, 2], [1]];\n\n/**\n * Returns the subarray of a Uint8Array without PKCS#7 padding.\n * @param padded {Uint8Array} unencrypted bytes that have been padded\n * @return {Uint8Array} the unpadded bytes\n * @see http://tools.ietf.org/html/rfc5652\n */\nfunction unpad(padded) {\n  return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);\n}\n\nvar version = \"1.0.2\";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGtjczcvZGlzdC9wa2NzNy5lcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wa2NzNy9kaXN0L3BrY3M3LmVzLmpzPzE1NmYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIHBrY3M3LnBhZFxuICogaHR0cHM6Ly9naXRodWIuY29tL2JyaWdodGNvdmUvcGtjczdcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJpZ2h0Y292ZVxuICogTGljZW5zZWQgdW5kZXIgdGhlIGFwYWNoZTIgbGljZW5zZS5cbiAqL1xuXG52YXIgUEFERElORyA9IHZvaWQgMDtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IFVpbnQ4QXJyYXkgdGhhdCBpcyBwYWRkZWQgd2l0aCBQS0NTIzcgcGFkZGluZy5cbiAqIEBwYXJhbSBwbGFpbnRleHQge1VpbnQ4QXJyYXl9IHRoZSBpbnB1dCBieXRlcyBiZWZvcmUgZW5jcnlwdGlvblxuICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIHBhZGRlZCBieXRlc1xuICogQHNlZSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1NjUyXG4gKi9cbmZ1bmN0aW9uIHBhZChwbGFpbnRleHQpIHtcbiAgdmFyIHBhZGRpbmcgPSBQQURESU5HW3BsYWludGV4dC5ieXRlTGVuZ3RoICUgMTYgfHwgMF07XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShwbGFpbnRleHQuYnl0ZUxlbmd0aCArIHBhZGRpbmcubGVuZ3RoKTtcblxuICByZXN1bHQuc2V0KHBsYWludGV4dCk7XG4gIHJlc3VsdC5zZXQocGFkZGluZywgcGxhaW50ZXh0LmJ5dGVMZW5ndGgpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHByZS1kZWZpbmUgdGhlIHBhZGRpbmcgdmFsdWVzXG5QQURESU5HID0gW1sxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNl0sIFsxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1XSwgWzE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNF0sIFsxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxM10sIFsxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyXSwgWzExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMV0sIFsxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMF0sIFs5LCA5LCA5LCA5LCA5LCA5LCA5LCA5LCA5XSwgWzgsIDgsIDgsIDgsIDgsIDgsIDgsIDhdLCBbNywgNywgNywgNywgNywgNywgN10sIFs2LCA2LCA2LCA2LCA2LCA2XSwgWzUsIDUsIDUsIDUsIDVdLCBbNCwgNCwgNCwgNF0sIFszLCAzLCAzXSwgWzIsIDJdLCBbMV1dO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN1YmFycmF5IG9mIGEgVWludDhBcnJheSB3aXRob3V0IFBLQ1MjNyBwYWRkaW5nLlxuICogQHBhcmFtIHBhZGRlZCB7VWludDhBcnJheX0gdW5lbmNyeXB0ZWQgYnl0ZXMgdGhhdCBoYXZlIGJlZW4gcGFkZGVkXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fSB0aGUgdW5wYWRkZWQgYnl0ZXNcbiAqIEBzZWUgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTY1MlxuICovXG5mdW5jdGlvbiB1bnBhZChwYWRkZWQpIHtcbiAgcmV0dXJuIHBhZGRlZC5zdWJhcnJheSgwLCBwYWRkZWQuYnl0ZUxlbmd0aCAtIHBhZGRlZFtwYWRkZWQuYnl0ZUxlbmd0aCAtIDFdKTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjEuMC4yXCI7XG5cbmV4cG9ydCB7IHBhZCwgdW5wYWQsIHZlcnNpb24gYXMgVkVSU0lPTiB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pkcs7/dist/pkcs7.es.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9mMjhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/safe-json-parse/tuple.js":
/*!***********************************************!*\
  !*** ./node_modules/safe-json-parse/tuple.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = SafeParseTuple\n\nfunction SafeParseTuple(obj, reviver) {\n    var json\n    var error = null\n\n    try {\n        json = JSON.parse(obj, reviver)\n    } catch (err) {\n        error = err\n    }\n\n    return [error, json]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2FmZS1qc29uLXBhcnNlL3R1cGxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NhZmUtanNvbi1wYXJzZS90dXBsZS5qcz84YzEwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gU2FmZVBhcnNlVHVwbGVcblxuZnVuY3Rpb24gU2FmZVBhcnNlVHVwbGUob2JqLCByZXZpdmVyKSB7XG4gICAgdmFyIGpzb25cbiAgICB2YXIgZXJyb3IgPSBudWxsXG5cbiAgICB0cnkge1xuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShvYmosIHJldml2ZXIpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9yID0gZXJyXG4gICAgfVxuXG4gICAgcmV0dXJuIFtlcnJvciwganNvbl1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/safe-json-parse/tuple.js\n");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzPzYwMTciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/setimmediate/setImmediate.js\n");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzPzUxMTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/timers-browserify/main.js\n");

/***/ }),

/***/ "./node_modules/trim/index.js":
/*!************************************!*\
  !*** ./node_modules/trim/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nexports = module.exports = trim;\n\nfunction trim(str){\n  return str.replace(/^\\s*|\\s*$/g, '');\n}\n\nexports.left = function(str){\n  return str.replace(/^\\s*/, '');\n};\n\nexports.right = function(str){\n  return str.replace(/\\s*$/, '');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHJpbS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90cmltL2luZGV4LmpzPzQ2YzEiXSwic291cmNlc0NvbnRlbnQiOlsiXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0cmltO1xuXG5mdW5jdGlvbiB0cmltKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuXG5leHBvcnRzLmxlZnQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpO1xufTtcblxuZXhwb3J0cy5yaWdodCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/trim/index.js\n");

/***/ }),

/***/ "./node_modules/tsml/tsml.js":
/*!***********************************!*\
  !*** ./node_modules/tsml/tsml.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function clean (s) {\n  return s.replace(/\\n\\r?\\s*/g, '')\n}\n\n\nmodule.exports = function tsml (sa) {\n  var s = ''\n    , i = 0\n\n  for (; i < arguments.length; i++)\n    s += clean(sa[i]) + (arguments[i + 1] || '')\n\n  return s\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHNtbC90c21sLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RzbWwvdHNtbC5qcz8xYjhkIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGNsZWFuIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcblxccj9cXHMqL2csICcnKVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHNtbCAoc2EpIHtcbiAgdmFyIHMgPSAnJ1xuICAgICwgaSA9IDBcblxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICBzICs9IGNsZWFuKHNhW2ldKSArIChhcmd1bWVudHNbaSArIDFdIHx8ICcnKVxuXG4gIHJldHVybiBzXG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tsml/tsml.js\n");

/***/ }),

/***/ "./node_modules/url-toolkit/src/url-toolkit.js":
/*!*****************************************************!*\
  !*** ./node_modules/url-toolkit/src/url-toolkit.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// see https://tools.ietf.org/html/rfc1808\r\n\r\n/* jshint ignore:start */\r\n(function(root) { \r\n/* jshint ignore:end */\r\n\r\n  var URL_REGEX = /^((?:[a-zA-Z0-9+\\-.]+:)?)(\\/\\/[^\\/\\;?#]*)?(.*?)??(;.*?)?(\\?.*?)?(#.*?)?$/;\r\n  var FIRST_SEGMENT_REGEX = /^([^\\/;?#]*)(.*)$/;\r\n  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\r\n  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/).*?(?=\\/)/g;\r\n\r\n  var URLToolkit = { // jshint ignore:line\r\n    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\r\n    // E.g\r\n    // With opts.alwaysNormalize = false (default, spec compliant)\r\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\r\n    // With opts.alwaysNormalize = true (not spec compliant)\r\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\r\n    buildAbsoluteURL: function(baseURL, relativeURL, opts) {\r\n      opts = opts || {};\r\n      // remove any remaining space and CRLF\r\n      baseURL = baseURL.trim();\r\n      relativeURL = relativeURL.trim();\r\n      if (!relativeURL) {\r\n        // 2a) If the embedded URL is entirely empty, it inherits the\r\n        // entire base URL (i.e., is set equal to the base URL)\r\n        // and we are done.\r\n        if (!opts.alwaysNormalize) {\r\n          return baseURL;\r\n        }\r\n        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\r\n        if (!basePartsForNormalise) {\r\n          throw new Error('Error trying to parse base URL.');\r\n        }\r\n        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);\r\n        return URLToolkit.buildURLFromParts(basePartsForNormalise);\r\n      }\r\n      var relativeParts = URLToolkit.parseURL(relativeURL);\r\n      if (!relativeParts) {\r\n        throw new Error('Error trying to parse relative URL.');\r\n      }\r\n      if (relativeParts.scheme) {\r\n        // 2b) If the embedded URL starts with a scheme name, it is\r\n        // interpreted as an absolute URL and we are done.\r\n        if (!opts.alwaysNormalize) {\r\n          return relativeURL;\r\n        }\r\n        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\r\n        return URLToolkit.buildURLFromParts(relativeParts);\r\n      }\r\n      var baseParts = URLToolkit.parseURL(baseURL);\r\n      if (!baseParts) {\r\n        throw new Error('Error trying to parse base URL.');\r\n      }\r\n      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\r\n        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\r\n        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\r\n        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\r\n        baseParts.netLoc = pathParts[1];\r\n        baseParts.path = pathParts[2];\r\n      }\r\n      if (baseParts.netLoc && !baseParts.path) {\r\n        baseParts.path = '/';\r\n      }\r\n      var builtParts = {\r\n        // 2c) Otherwise, the embedded URL inherits the scheme of\r\n        // the base URL.\r\n        scheme: baseParts.scheme,\r\n        netLoc: relativeParts.netLoc,\r\n        path: null,\r\n        params: relativeParts.params,\r\n        query: relativeParts.query,\r\n        fragment: relativeParts.fragment\r\n      };\r\n      if (!relativeParts.netLoc) {\r\n        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\r\n        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\r\n        // (if any) of the base URL.\r\n        builtParts.netLoc = baseParts.netLoc;\r\n        // 4) If the embedded URL path is preceded by a slash \"/\", the\r\n        // path is not relative and we skip to Step 7.\r\n        if (relativeParts.path[0] !== '/') {\r\n          if (!relativeParts.path) {\r\n            // 5) If the embedded URL path is empty (and not preceded by a\r\n            // slash), then the embedded URL inherits the base URL path\r\n            builtParts.path = baseParts.path;\r\n            // 5a) if the embedded URL's <params> is non-empty, we skip to\r\n            // step 7; otherwise, it inherits the <params> of the base\r\n            // URL (if any) and\r\n            if (!relativeParts.params) {\r\n              builtParts.params = baseParts.params;\r\n              // 5b) if the embedded URL's <query> is non-empty, we skip to\r\n              // step 7; otherwise, it inherits the <query> of the base\r\n              // URL (if any) and we skip to step 7.\r\n              if (!relativeParts.query) {\r\n                builtParts.query = baseParts.query;\r\n              }\r\n            }\r\n          } else {\r\n            // 6) The last segment of the base URL's path (anything\r\n            // following the rightmost slash \"/\", or the entire path if no\r\n            // slash is present) is removed and the embedded URL's path is\r\n            // appended in its place.\r\n            var baseURLPath = baseParts.path;\r\n            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;\r\n            builtParts.path = URLToolkit.normalizePath(newPath);\r\n          }\r\n        }\r\n      }\r\n      if (builtParts.path === null) {\r\n        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;\r\n      }\r\n      return URLToolkit.buildURLFromParts(builtParts);\r\n    },\r\n    parseURL: function(url) {\r\n      var parts = URL_REGEX.exec(url);\r\n      if (!parts) {\r\n        return null;\r\n      }\r\n      return {\r\n        scheme: parts[1] || '',\r\n        netLoc: parts[2] || '',\r\n        path: parts[3] || '',\r\n        params: parts[4] || '',\r\n        query: parts[5] || '',\r\n        fragment: parts[6] || ''\r\n      };\r\n    },\r\n    normalizePath: function(path) {\r\n      // The following operations are\r\n      // then applied, in order, to the new path:\r\n      // 6a) All occurrences of \"./\", where \".\" is a complete path\r\n      // segment, are removed.\r\n      // 6b) If the path ends with \".\" as a complete path segment,\r\n      // that \".\" is removed.\r\n      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\r\n      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\r\n      // complete path segment not equal to \"..\", are removed.\r\n      // Removal of these path segments is performed iteratively,\r\n      // removing the leftmost matching pattern on each iteration,\r\n      // until no matching pattern remains.\r\n      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\r\n      // complete path segment not equal to \"..\", that\r\n      // \"<segment>/..\" is removed.\r\n      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line\r\n      return path.split('').reverse().join('');\r\n    },\r\n    buildURLFromParts: function(parts) {\r\n      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;\r\n    }\r\n  };\r\n\r\n/* jshint ignore:start */\r\n  if(true)\r\n    module.exports = URLToolkit;\r\n  else {}\r\n})(this);\r\n/* jshint ignore:end */\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXJsLXRvb2xraXQvc3JjL3VybC10b29sa2l0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qcz9kMTM2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTgwOFxyXG5cclxuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xyXG4oZnVuY3Rpb24ocm9vdCkgeyBcclxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cclxuXHJcbiAgdmFyIFVSTF9SRUdFWCA9IC9eKCg/OlthLXpBLVowLTkrXFwtLl0rOik/KShcXC9cXC9bXlxcL1xcOz8jXSopPyguKj8pPz8oOy4qPyk/KFxcPy4qPyk/KCMuKj8pPyQvO1xyXG4gIHZhciBGSVJTVF9TRUdNRU5UX1JFR0VYID0gL14oW15cXC87PyNdKikoLiopJC87XHJcbiAgdmFyIFNMQVNIX0RPVF9SRUdFWCA9IC8oPzpcXC98XilcXC4oPz1cXC8pL2c7XHJcbiAgdmFyIFNMQVNIX0RPVF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuXFwuXFwvKD8hXFwuXFwuXFwvKS4qPyg/PVxcLykvZztcclxuXHJcbiAgdmFyIFVSTFRvb2xraXQgPSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgLy8gSWYgb3B0cy5hbHdheXNOb3JtYWxpemUgaXMgdHJ1ZSB0aGVuIHRoZSBwYXRoIHdpbGwgYWx3YXlzIGJlIG5vcm1hbGl6ZWQgZXZlbiB3aGVuIGl0IHN0YXJ0cyB3aXRoIC8gb3IgLy9cclxuICAgIC8vIEUuZ1xyXG4gICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IGZhbHNlIChkZWZhdWx0LCBzcGVjIGNvbXBsaWFudClcclxuICAgIC8vIGh0dHA6Ly9hLmNvbS9iL2NkICsgL2UvZi8uLi9nID0+IGh0dHA6Ly9hLmNvbS9lL2YvLi4vZ1xyXG4gICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IHRydWUgKG5vdCBzcGVjIGNvbXBsaWFudClcclxuICAgIC8vIGh0dHA6Ly9hLmNvbS9iL2NkICsgL2UvZi8uLi9nID0+IGh0dHA6Ly9hLmNvbS9lL2dcclxuICAgIGJ1aWxkQWJzb2x1dGVVUkw6IGZ1bmN0aW9uKGJhc2VVUkwsIHJlbGF0aXZlVVJMLCBvcHRzKSB7XHJcbiAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gICAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxyXG4gICAgICBiYXNlVVJMID0gYmFzZVVSTC50cmltKCk7XHJcbiAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xyXG4gICAgICBpZiAoIXJlbGF0aXZlVVJMKSB7XHJcbiAgICAgICAgLy8gMmEpIElmIHRoZSBlbWJlZGRlZCBVUkwgaXMgZW50aXJlbHkgZW1wdHksIGl0IGluaGVyaXRzIHRoZVxyXG4gICAgICAgIC8vIGVudGlyZSBiYXNlIFVSTCAoaS5lLiwgaXMgc2V0IGVxdWFsIHRvIHRoZSBiYXNlIFVSTClcclxuICAgICAgICAvLyBhbmQgd2UgYXJlIGRvbmUuXHJcbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGJhc2VVUkw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiYXNlUGFydHNGb3JOb3JtYWxpc2UgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xyXG4gICAgICAgIGlmICghYmFzZVBhcnRzRm9yTm9ybWFsaXNlKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgoYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGgpO1xyXG4gICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJhc2VQYXJ0c0Zvck5vcm1hbGlzZSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlbGF0aXZlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKHJlbGF0aXZlVVJMKTtcclxuICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgcmVsYXRpdmUgVVJMLicpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnNjaGVtZSkge1xyXG4gICAgICAgIC8vIDJiKSBJZiB0aGUgZW1iZWRkZWQgVVJMIHN0YXJ0cyB3aXRoIGEgc2NoZW1lIG5hbWUsIGl0IGlzXHJcbiAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYXMgYW4gYWJzb2x1dGUgVVJMIGFuZCB3ZSBhcmUgZG9uZS5cclxuICAgICAgICBpZiAoIW9wdHMuYWx3YXlzTm9ybWFsaXplKSB7XHJcbiAgICAgICAgICByZXR1cm4gcmVsYXRpdmVVUkw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbGF0aXZlUGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpO1xyXG4gICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKHJlbGF0aXZlUGFydHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBiYXNlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xyXG4gICAgICBpZiAoIWJhc2VQYXJ0cykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghYmFzZVBhcnRzLm5ldExvYyAmJiBiYXNlUGFydHMucGF0aCAmJiBiYXNlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XHJcbiAgICAgICAgLy8gSWYgbmV0TG9jIG1pc3NpbmcgYW5kIHBhdGggZG9lc24ndCBzdGFydCB3aXRoICcvJywgYXNzdW1lIGV2ZXJ0aGluZyBiZWZvcmUgdGhlIGZpcnN0ICcvJyBpcyB0aGUgbmV0TG9jXHJcbiAgICAgICAgLy8gVGhpcyBjYXVzZXMgJ2V4YW1wbGUuY29tL2EnIHRvIGJlIGhhbmRsZWQgYXMgJy8vZXhhbXBsZS5jb20vYScgaW5zdGVhZCBvZiAnL2V4YW1wbGUuY29tL2EnXHJcbiAgICAgICAgdmFyIHBhdGhQYXJ0cyA9IEZJUlNUX1NFR01FTlRfUkVHRVguZXhlYyhiYXNlUGFydHMucGF0aCk7XHJcbiAgICAgICAgYmFzZVBhcnRzLm5ldExvYyA9IHBhdGhQYXJ0c1sxXTtcclxuICAgICAgICBiYXNlUGFydHMucGF0aCA9IHBhdGhQYXJ0c1syXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYmFzZVBhcnRzLm5ldExvYyAmJiAhYmFzZVBhcnRzLnBhdGgpIHtcclxuICAgICAgICBiYXNlUGFydHMucGF0aCA9ICcvJztcclxuICAgICAgfVxyXG4gICAgICB2YXIgYnVpbHRQYXJ0cyA9IHtcclxuICAgICAgICAvLyAyYykgT3RoZXJ3aXNlLCB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSBzY2hlbWUgb2ZcclxuICAgICAgICAvLyB0aGUgYmFzZSBVUkwuXHJcbiAgICAgICAgc2NoZW1lOiBiYXNlUGFydHMuc2NoZW1lLFxyXG4gICAgICAgIG5ldExvYzogcmVsYXRpdmVQYXJ0cy5uZXRMb2MsXHJcbiAgICAgICAgcGF0aDogbnVsbCxcclxuICAgICAgICBwYXJhbXM6IHJlbGF0aXZlUGFydHMucGFyYW1zLFxyXG4gICAgICAgIHF1ZXJ5OiByZWxhdGl2ZVBhcnRzLnF1ZXJ5LFxyXG4gICAgICAgIGZyYWdtZW50OiByZWxhdGl2ZVBhcnRzLmZyYWdtZW50XHJcbiAgICAgIH07XHJcbiAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5uZXRMb2MpIHtcclxuICAgICAgICAvLyAzKSBJZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPG5ldF9sb2M+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xyXG4gICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XHJcbiAgICAgICAgLy8gKGlmIGFueSkgb2YgdGhlIGJhc2UgVVJMLlxyXG4gICAgICAgIGJ1aWx0UGFydHMubmV0TG9jID0gYmFzZVBhcnRzLm5ldExvYztcclxuICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXHJcbiAgICAgICAgLy8gcGF0aCBpcyBub3QgcmVsYXRpdmUgYW5kIHdlIHNraXAgdG8gU3RlcCA3LlxyXG4gICAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xyXG4gICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcclxuICAgICAgICAgICAgLy8gNSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIGVtcHR5IChhbmQgbm90IHByZWNlZGVkIGJ5IGFcclxuICAgICAgICAgICAgLy8gc2xhc2gpLCB0aGVuIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIGJhc2UgVVJMIHBhdGhcclxuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XHJcbiAgICAgICAgICAgIC8vIDVhKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHBhcmFtcz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXHJcbiAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHBhcmFtcz4gb2YgdGhlIGJhc2VcclxuICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxyXG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXJhbXMgPSBiYXNlUGFydHMucGFyYW1zO1xyXG4gICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cclxuICAgICAgICAgICAgICAvLyBzdGVwIDc7IG90aGVyd2lzZSwgaXQgaW5oZXJpdHMgdGhlIDxxdWVyeT4gb2YgdGhlIGJhc2VcclxuICAgICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kIHdlIHNraXAgdG8gc3RlcCA3LlxyXG4gICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5xdWVyeSA9IGJhc2VQYXJ0cy5xdWVyeTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIDYpIFRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGJhc2UgVVJMJ3MgcGF0aCAoYW55dGhpbmdcclxuICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xyXG4gICAgICAgICAgICAvLyBzbGFzaCBpcyBwcmVzZW50KSBpcyByZW1vdmVkIGFuZCB0aGUgZW1iZWRkZWQgVVJMJ3MgcGF0aCBpc1xyXG4gICAgICAgICAgICAvLyBhcHBlbmRlZCBpbiBpdHMgcGxhY2UuXHJcbiAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xyXG4gICAgICAgICAgICB2YXIgbmV3UGF0aCA9IGJhc2VVUkxQYXRoLnN1YnN0cmluZygwLCBiYXNlVVJMUGF0aC5sYXN0SW5kZXhPZignLycpICsgMSkgKyByZWxhdGl2ZVBhcnRzLnBhdGg7XHJcbiAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChuZXdQYXRoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGJ1aWx0UGFydHMucGF0aCA9PT0gbnVsbCkge1xyXG4gICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IG9wdHMuYWx3YXlzTm9ybWFsaXplID8gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aCkgOiByZWxhdGl2ZVBhcnRzLnBhdGg7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYnVpbHRQYXJ0cyk7XHJcbiAgICB9LFxyXG4gICAgcGFyc2VVUkw6IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgICB2YXIgcGFydHMgPSBVUkxfUkVHRVguZXhlYyh1cmwpO1xyXG4gICAgICBpZiAoIXBhcnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzY2hlbWU6IHBhcnRzWzFdIHx8ICcnLFxyXG4gICAgICAgIG5ldExvYzogcGFydHNbMl0gfHwgJycsXHJcbiAgICAgICAgcGF0aDogcGFydHNbM10gfHwgJycsXHJcbiAgICAgICAgcGFyYW1zOiBwYXJ0c1s0XSB8fCAnJyxcclxuICAgICAgICBxdWVyeTogcGFydHNbNV0gfHwgJycsXHJcbiAgICAgICAgZnJhZ21lbnQ6IHBhcnRzWzZdIHx8ICcnXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgbm9ybWFsaXplUGF0aDogZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgYXJlXHJcbiAgICAgIC8vIHRoZW4gYXBwbGllZCwgaW4gb3JkZXIsIHRvIHRoZSBuZXcgcGF0aDpcclxuICAgICAgLy8gNmEpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIi4vXCIsIHdoZXJlIFwiLlwiIGlzIGEgY29tcGxldGUgcGF0aFxyXG4gICAgICAvLyBzZWdtZW50LCBhcmUgcmVtb3ZlZC5cclxuICAgICAgLy8gNmIpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIi5cIiBhcyBhIGNvbXBsZXRlIHBhdGggc2VnbWVudCxcclxuICAgICAgLy8gdGhhdCBcIi5cIiBpcyByZW1vdmVkLlxyXG4gICAgICBwYXRoID0gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpLnJlcGxhY2UoU0xBU0hfRE9UX1JFR0VYLCAnJyk7XHJcbiAgICAgIC8vIDZjKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCI8c2VnbWVudD4vLi4vXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXHJcbiAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCBhcmUgcmVtb3ZlZC5cclxuICAgICAgLy8gUmVtb3ZhbCBvZiB0aGVzZSBwYXRoIHNlZ21lbnRzIGlzIHBlcmZvcm1lZCBpdGVyYXRpdmVseSxcclxuICAgICAgLy8gcmVtb3ZpbmcgdGhlIGxlZnRtb3N0IG1hdGNoaW5nIHBhdHRlcm4gb24gZWFjaCBpdGVyYXRpb24sXHJcbiAgICAgIC8vIHVudGlsIG5vIG1hdGNoaW5nIHBhdHRlcm4gcmVtYWlucy5cclxuICAgICAgLy8gNmQpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIjxzZWdtZW50Pi8uLlwiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxyXG4gICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgdGhhdFxyXG4gICAgICAvLyBcIjxzZWdtZW50Pi8uLlwiIGlzIHJlbW92ZWQuXHJcbiAgICAgIHdoaWxlIChwYXRoLmxlbmd0aCAhPT0gKHBhdGggPSBwYXRoLnJlcGxhY2UoU0xBU0hfRE9UX0RPVF9SRUdFWCwgJycpKS5sZW5ndGgpIHt9IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xyXG4gICAgfSxcclxuICAgIGJ1aWxkVVJMRnJvbVBhcnRzOiBmdW5jdGlvbihwYXJ0cykge1xyXG4gICAgICByZXR1cm4gcGFydHMuc2NoZW1lICsgcGFydHMubmV0TG9jICsgcGFydHMucGF0aCArIHBhcnRzLnBhcmFtcyArIHBhcnRzLnF1ZXJ5ICsgcGFydHMuZnJhZ21lbnQ7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cclxuICBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFVSTFRvb2xraXQ7XHJcbiAgZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXHJcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gVVJMVG9vbGtpdDsgfSk7XHJcbiAgZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcbiAgICBleHBvcnRzW1wiVVJMVG9vbGtpdFwiXSA9IFVSTFRvb2xraXQ7XHJcbiAgZWxzZVxyXG4gICAgcm9vdFtcIlVSTFRvb2xraXRcIl0gPSBVUkxUb29sa2l0O1xyXG59KSh0aGlzKTtcclxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FLQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/url-toolkit/src/url-toolkit.js\n");

/***/ }),

/***/ "./node_modules/video.js/dist/video.es.js":
/*!************************************************!*\
  !*** ./node_modules/video.js/dist/video.es.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! global/window */ \"./node_modules/global/window.js\");\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(global_window__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var global_document__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! global/document */ \"./node_modules/global/document.js\");\n/* harmony import */ var global_document__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(global_document__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var tsml__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tsml */ \"./node_modules/tsml/tsml.js\");\n/* harmony import */ var tsml__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(tsml__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var xhr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! xhr */ \"./node_modules/xhr/index.js\");\n/* harmony import */ var xhr__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(xhr__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var videojs_vtt_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! videojs-vtt.js */ \"./node_modules/videojs-vtt.js/lib/browser-index.js\");\n/* harmony import */ var videojs_vtt_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(videojs_vtt_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var safe_json_parse_tuple__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! safe-json-parse/tuple */ \"./node_modules/safe-json-parse/tuple.js\");\n/* harmony import */ var safe_json_parse_tuple__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(safe_json_parse_tuple__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var m3u8_parser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! m3u8-parser */ \"./node_modules/m3u8-parser/dist/m3u8-parser.es.js\");\n/* harmony import */ var mpd_parser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! mpd-parser */ \"./node_modules/mpd-parser/dist/mpd-parser.es.js\");\n/* harmony import */ var mux_js_lib_mp4_probe__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! mux.js/lib/mp4/probe */ \"./node_modules/mux.js/lib/mp4/probe.js\");\n/* harmony import */ var mux_js_lib_mp4_probe__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(mux_js_lib_mp4_probe__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var mux_js_lib_tools_ts_inspector_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! mux.js/lib/tools/ts-inspector.js */ \"./node_modules/mux.js/lib/tools/ts-inspector.js\");\n/* harmony import */ var mux_js_lib_tools_ts_inspector_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(mux_js_lib_tools_ts_inspector_js__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var aes_decrypter__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! aes-decrypter */ \"./node_modules/aes-decrypter/dist/aes-decrypter.es.js\");\n/**\n * @license\n * Video.js 7.1.0 <http://videojs.com/>\n * Copyright Brightcove, Inc. <https://www.brightcove.com/>\n * Available under Apache License Version 2.0\n * <https://github.com/videojs/video.js/blob/master/LICENSE>\n *\n * Includes vtt.js <https://github.com/mozilla/vtt.js>\n * Available under Apache License Version 2.0\n * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar version = \"7.1.0\";\n\n/**\n * @file log.js\n * @module log\n */\n\nvar log = void 0;\n\n// This is the private tracking variable for logging level.\nvar level = 'info';\n\n// This is the private tracking variable for the logging history.\nvar history = [];\n\n/**\n * Log messages to the console and history based on the type of message\n *\n * @private\n * @param  {string} type\n *         The name of the console method to use.\n *\n * @param  {Array} args\n *         The arguments to be passed to the matching console method.\n */\nvar logByType = function logByType(type, args) {\n  var lvl = log.levels[level];\n  var lvlRegExp = new RegExp('^(' + lvl + ')$');\n\n  if (type !== 'log') {\n\n    // Add the type to the front of the message when it's not \"log\".\n    args.unshift(type.toUpperCase() + ':');\n  }\n\n  // Add a clone of the args at this point to history.\n  if (history) {\n    history.push([].concat(args));\n  }\n\n  // Add console prefix after adding to history.\n  args.unshift('VIDEOJS:');\n\n  // If there's no console then don't try to output messages, but they will\n  // still be stored in history.\n  if (!global_window__WEBPACK_IMPORTED_MODULE_0___default.a.console) {\n    return;\n  }\n\n  // Was setting these once outside of this function, but containing them\n  // in the function makes it easier to test cases where console doesn't exist\n  // when the module is executed.\n  var fn = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.console[type];\n\n  if (!fn && type === 'debug') {\n    // Certain browsers don't have support for console.debug. For those, we\n    // should default to the closest comparable log.\n    fn = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.console.info || global_window__WEBPACK_IMPORTED_MODULE_0___default.a.console.log;\n  }\n\n  // Bail out if there's no console or if this type is not allowed by the\n  // current logging level.\n  if (!fn || !lvl || !lvlRegExp.test(type)) {\n    return;\n  }\n\n  fn[Array.isArray(args) ? 'apply' : 'call'](global_window__WEBPACK_IMPORTED_MODULE_0___default.a.console, args);\n};\n\n/**\n * Logs plain debug messages. Similar to `console.log`.\n *\n * @class\n * @param    {Mixed[]} args\n *           One or more messages or objects that should be logged.\n */\nlog = function log() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  logByType('log', args);\n};\n\n/**\n * Enumeration of available logging levels, where the keys are the level names\n * and the values are `|`-separated strings containing logging methods allowed\n * in that logging level. These strings are used to create a regular expression\n * matching the function name being called.\n *\n * Levels provided by video.js are:\n *\n * - `off`: Matches no calls. Any value that can be cast to `false` will have\n *   this effect. The most restrictive.\n * - `all`: Matches only Video.js-provided functions (`debug`, `log`,\n *   `log.warn`, and `log.error`).\n * - `debug`: Matches `log.debug`, `log`, `log.warn`, and `log.error` calls.\n * - `info` (default): Matches `log`, `log.warn`, and `log.error` calls.\n * - `warn`: Matches `log.warn` and `log.error` calls.\n * - `error`: Matches only `log.error` calls.\n *\n * @type {Object}\n */\nlog.levels = {\n  all: 'debug|log|warn|error',\n  off: '',\n  debug: 'debug|log|warn|error',\n  info: 'log|warn|error',\n  warn: 'warn|error',\n  error: 'error',\n  DEFAULT: level\n};\n\n/**\n * Get or set the current logging level. If a string matching a key from\n * {@link log.levels} is provided, acts as a setter. Regardless of argument,\n * returns the current logging level.\n *\n * @param  {string} [lvl]\n *         Pass to set a new logging level.\n *\n * @return {string}\n *         The current logging level.\n */\nlog.level = function (lvl) {\n  if (typeof lvl === 'string') {\n    if (!log.levels.hasOwnProperty(lvl)) {\n      throw new Error('\"' + lvl + '\" in not a valid log level');\n    }\n    level = lvl;\n  }\n  return level;\n};\n\n/**\n * Returns an array containing everything that has been logged to the history.\n *\n * This array is a shallow clone of the internal history record. However, its\n * contents are _not_ cloned; so, mutating objects inside this array will\n * mutate them in history.\n *\n * @return {Array}\n */\nlog.history = function () {\n  return history ? [].concat(history) : [];\n};\n\n/**\n * Clears the internal history tracking, but does not prevent further history\n * tracking.\n */\nlog.history.clear = function () {\n  if (history) {\n    history.length = 0;\n  }\n};\n\n/**\n * Disable history tracking if it is currently enabled.\n */\nlog.history.disable = function () {\n  if (history !== null) {\n    history.length = 0;\n    history = null;\n  }\n};\n\n/**\n * Enable history tracking if it is currently disabled.\n */\nlog.history.enable = function () {\n  if (history === null) {\n    history = [];\n  }\n};\n\n/**\n * Logs error messages. Similar to `console.error`.\n *\n * @param {Mixed[]} args\n *        One or more messages or objects that should be logged as an error\n */\nlog.error = function () {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return logByType('error', args);\n};\n\n/**\n * Logs warning messages. Similar to `console.warn`.\n *\n * @param {Mixed[]} args\n *        One or more messages or objects that should be logged as a warning.\n */\nlog.warn = function () {\n  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return logByType('warn', args);\n};\n\n/**\n * Logs debug messages. Similar to `console.debug`, but may also act as a comparable\n * log if `console.debug` is not available\n *\n * @param {Mixed[]} args\n *        One or more messages or objects that should be logged as debug.\n */\nlog.debug = function () {\n  for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    args[_key4] = arguments[_key4];\n  }\n\n  return logByType('debug', args);\n};\n\nvar log$1 = log;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar taggedTemplateLiteralLoose = function (strings, raw) {\n  strings.raw = raw;\n  return strings;\n};\n\n/**\n * @file obj.js\n * @module obj\n */\n\n/**\n * @callback obj:EachCallback\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n */\n\n/**\n * @callback obj:ReduceCallback\n *\n * @param {Mixed} accum\n *        The value that is accumulating over the reduce loop.\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n *\n * @return {Mixed}\n *         The new accumulated value.\n */\nvar toString = Object.prototype.toString;\n\n/**\n * Get the keys of an Object\n *\n * @param {Object}\n *        The Object to get the keys from\n *\n * @return {string[]}\n *         An array of the keys from the object. Returns an empty array if the\n *         object passed in was invalid or had no keys.\n *\n * @private\n */\nvar keys = function keys(object) {\n  return isObject(object) ? Object.keys(object) : [];\n};\n\n/**\n * Array-like iteration for objects.\n *\n * @param {Object} object\n *        The object to iterate over\n *\n * @param {obj:EachCallback} fn\n *        The callback function which is called for each key in the object.\n */\nfunction each(object, fn) {\n  keys(object).forEach(function (key) {\n    return fn(object[key], key);\n  });\n}\n\n/**\n * Array-like reduce for objects.\n *\n * @param {Object} object\n *        The Object that you want to reduce.\n *\n * @param {Function} fn\n *         A callback function which is called for each key in the object. It\n *         receives the accumulated value and the per-iteration value and key\n *         as arguments.\n *\n * @param {Mixed} [initial = 0]\n *        Starting value\n *\n * @return {Mixed}\n *         The final accumulated value.\n */\nfunction reduce(object, fn) {\n  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  return keys(object).reduce(function (accum, key) {\n    return fn(accum, object[key], key);\n  }, initial);\n}\n\n/**\n * Object.assign-style object shallow merge/extend.\n *\n * @param  {Object} target\n * @param  {Object} ...sources\n * @return {Object}\n */\nfunction assign(target) {\n  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  if (Object.assign) {\n    return Object.assign.apply(Object, [target].concat(sources));\n  }\n\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n\n    each(source, function (value, key) {\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\n/**\n * Returns whether a value is an object of any kind - including DOM nodes,\n * arrays, regular expressions, etc. Not functions, though.\n *\n * This avoids the gotcha where using `typeof` on a `null` value\n * results in `'object'`.\n *\n * @param  {Object} value\n * @return {Boolean}\n */\nfunction isObject(value) {\n  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';\n}\n\n/**\n * Returns whether an object appears to be a \"plain\" object - that is, a\n * direct instance of `Object`.\n *\n * @param  {Object} value\n * @return {Boolean}\n */\nfunction isPlain(value) {\n  return isObject(value) && toString.call(value) === '[object Object]' && value.constructor === Object;\n}\n\n/**\n * @file computed-style.js\n * @module computed-style\n */\n\n/**\n * A safe getComputedStyle.\n *\n * This is needed because in Firefox, if the player is loaded in an iframe with\n * `display:none`, then `getComputedStyle` returns `null`, so, we do a null-check to\n * make sure  that the player doesn't break in these cases.\n *\n * @param {Element} el\n *        The element you want the computed style of\n *\n * @param {string} prop\n *        The property name you want\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n *\n * @static\n * @const\n */\nfunction computedStyle(el, prop) {\n  if (!el || !prop) {\n    return '';\n  }\n\n  if (typeof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.getComputedStyle === 'function') {\n    var cs = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.getComputedStyle(el);\n\n    return cs ? cs[prop] : '';\n  }\n\n  return '';\n}\n\nvar _templateObject = taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);\n\n/**\n * Detect if a value is a string with any non-whitespace characters.\n *\n * @param {string} str\n *        The string to check\n *\n * @return {boolean}\n *         - True if the string is non-blank\n *         - False otherwise\n *\n */\nfunction isNonBlankString(str) {\n  return typeof str === 'string' && /\\S/.test(str);\n}\n\n/**\n * Throws an error if the passed string has whitespace. This is used by\n * class methods to be relatively consistent with the classList API.\n *\n * @param {string} str\n *         The string to check for whitespace.\n *\n * @throws {Error}\n *         Throws an error if there is whitespace in the string.\n *\n */\nfunction throwIfWhitespace(str) {\n  if (/\\s/.test(str)) {\n    throw new Error('class has illegal whitespace characters');\n  }\n}\n\n/**\n * Produce a regular expression for matching a className within an elements className.\n *\n * @param {string} className\n *         The className to generate the RegExp for.\n *\n * @return {RegExp}\n *         The RegExp that will check for a specific `className` in an elements\n *         className.\n */\nfunction classRegExp(className) {\n  return new RegExp('(^|\\\\s)' + className + '($|\\\\s)');\n}\n\n/**\n * Whether the current DOM interface appears to be real.\n *\n * @return {Boolean}\n */\nfunction isReal() {\n  // Both document and window will never be undefined thanks to `global`.\n  return global_document__WEBPACK_IMPORTED_MODULE_1___default.a === global_window__WEBPACK_IMPORTED_MODULE_0___default.a.document;\n}\n\n/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @param {Mixed} value\n *        The thing to check\n *\n * @return {boolean}\n *         - True if it is a DOM element\n *         - False otherwise\n */\nfunction isEl(value) {\n  return isObject(value) && value.nodeType === 1;\n}\n\n/**\n * Determines if the current DOM is embedded in an iframe.\n *\n * @return {boolean}\n *\n */\nfunction isInFrame() {\n\n  // We need a try/catch here because Safari will throw errors when attempting\n  // to get either `parent` or `self`\n  try {\n    return global_window__WEBPACK_IMPORTED_MODULE_0___default.a.parent !== global_window__WEBPACK_IMPORTED_MODULE_0___default.a.self;\n  } catch (x) {\n    return true;\n  }\n}\n\n/**\n * Creates functions to query the DOM using a given method.\n *\n * @param {string} method\n *         The method to create the query with.\n *\n * @return {Function}\n *         The query method\n */\nfunction createQuerier(method) {\n  return function (selector, context) {\n    if (!isNonBlankString(selector)) {\n      return global_document__WEBPACK_IMPORTED_MODULE_1___default.a[method](null);\n    }\n    if (isNonBlankString(context)) {\n      context = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.querySelector(context);\n    }\n\n    var ctx = isEl(context) ? context : global_document__WEBPACK_IMPORTED_MODULE_1___default.a;\n\n    return ctx[method] && ctx[method](selector);\n  };\n}\n\n/**\n * Creates an element and applies properties.\n *\n * @param {string} [tagName='div']\n *         Name of tag to be created.\n *\n * @param {Object} [properties={}]\n *         Element properties to be applied.\n *\n * @param {Object} [attributes={}]\n *         Element attributes to be applied.\n *\n * @param {String|Element|TextNode|Array|Function} [content]\n *         Contents for the element (see: {@link dom:normalizeContent})\n *\n * @return {Element}\n *         The element that was created.\n */\nfunction createEl() {\n  var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';\n  var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var content = arguments[3];\n\n  var el = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(tagName);\n\n  Object.getOwnPropertyNames(properties).forEach(function (propName) {\n    var val = properties[propName];\n\n    // See #2176\n    // We originally were accepting both properties and attributes in the\n    // same object, but that doesn't work so well.\n    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {\n      log$1.warn(tsml__WEBPACK_IMPORTED_MODULE_2___default()(_templateObject, propName, val));\n      el.setAttribute(propName, val);\n\n      // Handle textContent since it's not supported everywhere and we have a\n      // method for it.\n    } else if (propName === 'textContent') {\n      textContent(el, val);\n    } else {\n      el[propName] = val;\n    }\n  });\n\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    el.setAttribute(attrName, attributes[attrName]);\n  });\n\n  if (content) {\n    appendContent(el, content);\n  }\n\n  return el;\n}\n\n/**\n * Injects text into an element, replacing any existing contents entirely.\n *\n * @param {Element} el\n *        The element to add text content into\n *\n * @param {string} text\n *        The text content to add.\n *\n * @return {Element}\n *         The element with added text content.\n */\nfunction textContent(el, text) {\n  if (typeof el.textContent === 'undefined') {\n    el.innerText = text;\n  } else {\n    el.textContent = text;\n  }\n  return el;\n}\n\n/**\n * Insert an element as the first child node of another\n *\n * @param {Element} child\n *        Element to insert\n *\n * @param {Element} parent\n *        Element to insert child into\n */\nfunction prependTo(child, parent) {\n  if (parent.firstChild) {\n    parent.insertBefore(child, parent.firstChild);\n  } else {\n    parent.appendChild(child);\n  }\n}\n\n/**\n * Check if an element has a CSS class\n *\n * @param {Element} element\n *        Element to check\n *\n * @param {string} classToCheck\n *        Class name to check for\n *\n * @return {boolean}\n *         - True if the element had the class\n *         - False otherwise.\n *\n * @throws {Error}\n *         Throws an error if `classToCheck` has white space.\n */\nfunction hasClass(element, classToCheck) {\n  throwIfWhitespace(classToCheck);\n  if (element.classList) {\n    return element.classList.contains(classToCheck);\n  }\n  return classRegExp(classToCheck).test(element.className);\n}\n\n/**\n * Add a CSS class name to an element\n *\n * @param {Element} element\n *        Element to add class name to.\n *\n * @param {string} classToAdd\n *        Class name to add.\n *\n * @return {Element}\n *         The dom element with the added class name.\n */\nfunction addClass(element, classToAdd) {\n  if (element.classList) {\n    element.classList.add(classToAdd);\n\n    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it\n    // in the case of classList not being supported.\n  } else if (!hasClass(element, classToAdd)) {\n    element.className = (element.className + ' ' + classToAdd).trim();\n  }\n\n  return element;\n}\n\n/**\n * Remove a CSS class name from an element\n *\n * @param {Element} element\n *        Element to remove a class name from.\n *\n * @param {string} classToRemove\n *        Class name to remove\n *\n * @return {Element}\n *         The dom element with class name removed.\n */\nfunction removeClass(element, classToRemove) {\n  if (element.classList) {\n    element.classList.remove(classToRemove);\n  } else {\n    throwIfWhitespace(classToRemove);\n    element.className = element.className.split(/\\s+/).filter(function (c) {\n      return c !== classToRemove;\n    }).join(' ');\n  }\n\n  return element;\n}\n\n/**\n * The callback definition for toggleElClass.\n *\n * @callback Dom~PredicateCallback\n * @param {Element} element\n *        The DOM element of the Component.\n *\n * @param {string} classToToggle\n *        The `className` that wants to be toggled\n *\n * @return {boolean|undefined}\n *         - If true the `classToToggle` will get added to `element`.\n *         - If false the `classToToggle` will get removed from `element`.\n *         - If undefined this callback will be ignored\n */\n\n/**\n * Adds or removes a CSS class name on an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @param {Element} element\n *        The element to toggle a class name on.\n *\n * @param {string} classToToggle\n *        The class that should be toggled\n *\n * @param {boolean|PredicateCallback} [predicate]\n *        See the return value for {@link Dom~PredicateCallback}\n *\n * @return {Element}\n *         The element with a class that has been toggled.\n */\nfunction toggleClass(element, classToToggle, predicate) {\n\n  // This CANNOT use `classList` internally because IE11 does not support the\n  // second parameter to the `classList.toggle()` method! Which is fine because\n  // `classList` will be used by the add/remove functions.\n  var has = hasClass(element, classToToggle);\n\n  if (typeof predicate === 'function') {\n    predicate = predicate(element, classToToggle);\n  }\n\n  if (typeof predicate !== 'boolean') {\n    predicate = !has;\n  }\n\n  // If the necessary class operation matches the current state of the\n  // element, no action is required.\n  if (predicate === has) {\n    return;\n  }\n\n  if (predicate) {\n    addClass(element, classToToggle);\n  } else {\n    removeClass(element, classToToggle);\n  }\n\n  return element;\n}\n\n/**\n * Apply attributes to an HTML element.\n *\n * @param {Element} el\n *        Element to add attributes to.\n *\n * @param {Object} [attributes]\n *        Attributes to be applied.\n */\nfunction setAttributes(el, attributes) {\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    var attrValue = attributes[attrName];\n\n    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\n      el.removeAttribute(attrName);\n    } else {\n      el.setAttribute(attrName, attrValue === true ? '' : attrValue);\n    }\n  });\n}\n\n/**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n *\n * @param {Element} tag\n *        Element from which to get tag attributes.\n *\n * @return {Object}\n *         All attributes of the element.\n */\nfunction getAttributes(tag) {\n  var obj = {};\n\n  // known boolean attributes\n  // we can check for matching boolean properties, but not all browsers\n  // and not all tags know about these attributes, so, we still want to check them manually\n  var knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';\n\n  if (tag && tag.attributes && tag.attributes.length > 0) {\n    var attrs = tag.attributes;\n\n    for (var i = attrs.length - 1; i >= 0; i--) {\n      var attrName = attrs[i].name;\n      var attrVal = attrs[i].value;\n\n      // check for known booleans\n      // the matching element property will return a value for typeof\n      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {\n        // the value of an included boolean attribute is typically an empty\n        // string ('') which would equal false if we just check for a false value.\n        // we also don't want support bad code like autoplay='false'\n        attrVal = attrVal !== null ? true : false;\n      }\n\n      obj[attrName] = attrVal;\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Get the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to get the value of\n *\n * @return {string}\n *         value of the attribute\n */\nfunction getAttribute(el, attribute) {\n  return el.getAttribute(attribute);\n}\n\n/**\n * Set the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to set\n *\n * @param {string} value\n *        Value to set the attribute to\n */\nfunction setAttribute(el, attribute, value) {\n  el.setAttribute(attribute, value);\n}\n\n/**\n * Remove an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to remove\n */\nfunction removeAttribute(el, attribute) {\n  el.removeAttribute(attribute);\n}\n\n/**\n * Attempt to block the ability to select text while dragging controls\n */\nfunction blockTextSelection() {\n  global_document__WEBPACK_IMPORTED_MODULE_1___default.a.body.focus();\n  global_document__WEBPACK_IMPORTED_MODULE_1___default.a.onselectstart = function () {\n    return false;\n  };\n}\n\n/**\n * Turn off text selection blocking\n */\nfunction unblockTextSelection() {\n  global_document__WEBPACK_IMPORTED_MODULE_1___default.a.onselectstart = function () {\n    return true;\n  };\n}\n\n/**\n * Identical to the native `getBoundingClientRect` function, but ensures that\n * the method is supported at all (it is in all browsers we claim to support)\n * and that the element is in the DOM before continuing.\n *\n * This wrapper function also shims properties which are not provided by some\n * older browsers (namely, IE8).\n *\n * Additionally, some browsers do not support adding properties to a\n * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard\n * properties (except `x` and `y` which are not widely supported). This helps\n * avoid implementations where keys are non-enumerable.\n *\n * @param  {Element} el\n *         Element whose `ClientRect` we want to calculate.\n *\n * @return {Object|undefined}\n *         Always returns a plain\n */\nfunction getBoundingClientRect(el) {\n  if (el && el.getBoundingClientRect && el.parentNode) {\n    var rect = el.getBoundingClientRect();\n    var result = {};\n\n    ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(function (k) {\n      if (rect[k] !== undefined) {\n        result[k] = rect[k];\n      }\n    });\n\n    if (!result.height) {\n      result.height = parseFloat(computedStyle(el, 'height'));\n    }\n\n    if (!result.width) {\n      result.width = parseFloat(computedStyle(el, 'width'));\n    }\n\n    return result;\n  }\n}\n\n/**\n * The postion of a DOM element on the page.\n *\n * @typedef {Object} module:dom~Position\n *\n * @property {number} left\n *           Pixels to the left\n *\n * @property {number} top\n *           Pixels on top\n */\n\n/**\n * Offset Left.\n * getBoundingClientRect technique from\n * John Resig\n *\n * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/\n *\n * @param {Element} el\n *        Element from which to get offset\n *\n * @return {module:dom~Position}\n *         The position of the element that was passed in.\n */\nfunction findPosition(el) {\n  var box = void 0;\n\n  if (el.getBoundingClientRect && el.parentNode) {\n    box = el.getBoundingClientRect();\n  }\n\n  if (!box) {\n    return {\n      left: 0,\n      top: 0\n    };\n  }\n\n  var docEl = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.documentElement;\n  var body = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.body;\n\n  var clientLeft = docEl.clientLeft || body.clientLeft || 0;\n  var scrollLeft = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.pageXOffset || body.scrollLeft;\n  var left = box.left + scrollLeft - clientLeft;\n\n  var clientTop = docEl.clientTop || body.clientTop || 0;\n  var scrollTop = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.pageYOffset || body.scrollTop;\n  var top = box.top + scrollTop - clientTop;\n\n  // Android sometimes returns slightly off decimal values, so need to round\n  return {\n    left: Math.round(left),\n    top: Math.round(top)\n  };\n}\n\n/**\n * x and y coordinates for a dom element or mouse pointer\n *\n * @typedef {Object} Dom~Coordinates\n *\n * @property {number} x\n *           x coordinate in pixels\n *\n * @property {number} y\n *           y coordinate in pixels\n */\n\n/**\n * Get pointer position in element\n * Returns an object with x and y coordinates.\n * The base on the coordinates are the bottom left of the element.\n *\n * @param {Element} el\n *        Element on which to get the pointer position on\n *\n * @param {EventTarget~Event} event\n *        Event object\n *\n * @return {Dom~Coordinates}\n *         A Coordinates object corresponding to the mouse position.\n *\n */\nfunction getPointerPosition(el, event) {\n  var position = {};\n  var box = findPosition(el);\n  var boxW = el.offsetWidth;\n  var boxH = el.offsetHeight;\n\n  var boxY = box.top;\n  var boxX = box.left;\n  var pageY = event.pageY;\n  var pageX = event.pageX;\n\n  if (event.changedTouches) {\n    pageX = event.changedTouches[0].pageX;\n    pageY = event.changedTouches[0].pageY;\n  }\n\n  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));\n  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));\n\n  return position;\n}\n\n/**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @param {Mixed} value\n *        Check if this value is a text node.\n *\n * @return {boolean}\n *         - True if it is a text node\n *         - False otherwise\n */\nfunction isTextNode(value) {\n  return isObject(value) && value.nodeType === 3;\n}\n\n/**\n * Empties the contents of an element.\n *\n * @param {Element} el\n *        The element to empty children from\n *\n * @return {Element}\n *         The element with no children\n */\nfunction emptyEl(el) {\n  while (el.firstChild) {\n    el.removeChild(el.firstChild);\n  }\n  return el;\n}\n\n/**\n * Normalizes content for eventual insertion into the DOM.\n *\n * This allows a wide range of content definition methods, but protects\n * from falling into the trap of simply writing to `innerHTML`, which is\n * an XSS concern.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        - String: Normalized into a text node.\n *        - Element/TextNode: Passed through.\n *        - Array: A one-dimensional array of strings, elements, nodes, or functions\n *          (which return single strings, elements, or nodes).\n *        - Function: If the sole argument, is expected to produce a string, element,\n *          node, or array as defined above.\n *\n * @return {Array}\n *         All of the content that was passed in normalized.\n */\nfunction normalizeContent(content) {\n\n  // First, invoke content if it is a function. If it produces an array,\n  // that needs to happen before normalization.\n  if (typeof content === 'function') {\n    content = content();\n  }\n\n  // Next up, normalize to an array, so one or many items can be normalized,\n  // filtered, and returned.\n  return (Array.isArray(content) ? content : [content]).map(function (value) {\n\n    // First, invoke value if it is a function to produce a new value,\n    // which will be subsequently normalized to a Node of some kind.\n    if (typeof value === 'function') {\n      value = value();\n    }\n\n    if (isEl(value) || isTextNode(value)) {\n      return value;\n    }\n\n    if (typeof value === 'string' && /\\S/.test(value)) {\n      return global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createTextNode(value);\n    }\n  }).filter(function (value) {\n    return value;\n  });\n}\n\n/**\n * Normalizes and appends content to an element.\n *\n * @param {Element} el\n *        Element to append normalized content to.\n *\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with appended normalized content.\n */\nfunction appendContent(el, content) {\n  normalizeContent(content).forEach(function (node) {\n    return el.appendChild(node);\n  });\n  return el;\n}\n\n/**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * @param {Element} el\n *        Element to insert normalized content into.\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with inserted normalized content.\n *\n */\nfunction insertContent(el, content) {\n  return appendContent(emptyEl(el), content);\n}\n\n/**\n * Check if event was a single left click\n *\n * @param {EventTarget~Event} event\n *        Event object\n *\n * @return {boolean}\n *         - True if a left click\n *         - False if not a left click\n */\nfunction isSingleLeftClick(event) {\n  // Note: if you create something draggable, be sure to\n  // call it on both `mousedown` and `mousemove` event,\n  // otherwise `mousedown` should be enough for a button\n\n  if (event.button === undefined && event.buttons === undefined) {\n    // Why do we need `buttons` ?\n    // Because, middle mouse sometimes have this:\n    // e.button === 0 and e.buttons === 4\n    // Furthermore, we want to prevent combination click, something like\n    // HOLD middlemouse then left click, that would be\n    // e.button === 0, e.buttons === 5\n    // just `button` is not gonna work\n\n    // Alright, then what this block does ?\n    // this is for chrome `simulate mobile devices`\n    // I want to support this as well\n\n    return true;\n  }\n\n  if (event.button === 0 && event.buttons === undefined) {\n    // Touch screen, sometimes on some specific device, `buttons`\n    // doesn't have anything (safari on ios, blackberry...)\n\n    return true;\n  }\n\n  if (event.button !== 0 || event.buttons !== 1) {\n    // This is the reason we have those if else block above\n    // if any special case we can catch and let it slide\n    // we do it above, when get to here, this definitely\n    // is-not-left-click\n\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Finds a single DOM element matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *        A valid CSS selector, which will be passed to `querySelector`.\n *\n * @param {Element|String} [context=document]\n *        A DOM element within which to query. Can also be a selector\n *        string in which case the first matching element will be used\n *        as context. If missing (or no element matches selector), falls\n *        back to `document`.\n *\n * @return {Element|null}\n *         The element that was found or null.\n */\nvar $ = createQuerier('querySelector');\n\n/**\n * Finds a all DOM elements matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *           A valid CSS selector, which will be passed to `querySelectorAll`.\n *\n * @param {Element|String} [context=document]\n *           A DOM element within which to query. Can also be a selector\n *           string in which case the first matching element will be used\n *           as context. If missing (or no element matches selector), falls\n *           back to `document`.\n *\n * @return {NodeList}\n *         A element list of elements that were found. Will be empty if none were found.\n *\n */\nvar $$ = createQuerier('querySelectorAll');\n\nvar Dom = /*#__PURE__*/Object.freeze({\n  isReal: isReal,\n  isEl: isEl,\n  isInFrame: isInFrame,\n  createEl: createEl,\n  textContent: textContent,\n  prependTo: prependTo,\n  hasClass: hasClass,\n  addClass: addClass,\n  removeClass: removeClass,\n  toggleClass: toggleClass,\n  setAttributes: setAttributes,\n  getAttributes: getAttributes,\n  getAttribute: getAttribute,\n  setAttribute: setAttribute,\n  removeAttribute: removeAttribute,\n  blockTextSelection: blockTextSelection,\n  unblockTextSelection: unblockTextSelection,\n  getBoundingClientRect: getBoundingClientRect,\n  findPosition: findPosition,\n  getPointerPosition: getPointerPosition,\n  isTextNode: isTextNode,\n  emptyEl: emptyEl,\n  normalizeContent: normalizeContent,\n  appendContent: appendContent,\n  insertContent: insertContent,\n  isSingleLeftClick: isSingleLeftClick,\n  $: $,\n  $$: $$\n});\n\n/**\n * @file guid.js\n * @module guid\n */\n\n/**\n * Unique ID for an element or function\n * @type {Number}\n */\nvar _guid = 1;\n\n/**\n * Get a unique auto-incrementing ID by number that has not been returned before.\n *\n * @return {number}\n *         A new unique ID.\n */\nfunction newGUID() {\n  return _guid++;\n}\n\n/**\n * @file dom-data.js\n * @module dom-data\n */\n\n/**\n * Element Data Store.\n *\n * Allows for binding data to an element without putting it directly on the\n * element. Ex. Event listeners are stored here.\n * (also from jsninja.com, slightly modified and updated for closure compiler)\n *\n * @type {Object}\n * @private\n */\nvar elData = {};\n\n/*\n * Unique attribute name to store an element's guid in\n *\n * @type {String}\n * @constant\n * @private\n */\nvar elIdAttr = 'vdata' + new Date().getTime();\n\n/**\n * Returns the cache object where data for an element is stored\n *\n * @param {Element} el\n *        Element to store data for.\n *\n * @return {Object}\n *         The cache object for that el that was passed in.\n */\nfunction getData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    id = el[elIdAttr] = newGUID();\n  }\n\n  if (!elData[id]) {\n    elData[id] = {};\n  }\n\n  return elData[id];\n}\n\n/**\n * Returns whether or not an element has cached data\n *\n * @param {Element} el\n *        Check if this element has cached data.\n *\n * @return {boolean}\n *         - True if the DOM element has cached data.\n *         - False otherwise.\n */\nfunction hasData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return false;\n  }\n\n  return !!Object.getOwnPropertyNames(elData[id]).length;\n}\n\n/**\n * Delete data for the element from the cache and the guid attr from getElementById\n *\n * @param {Element} el\n *        Remove cached data for this element.\n */\nfunction removeData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return;\n  }\n\n  // Remove all stored data\n  delete elData[id];\n\n  // Remove the elIdAttr property from the DOM node\n  try {\n    delete el[elIdAttr];\n  } catch (e) {\n    if (el.removeAttribute) {\n      el.removeAttribute(elIdAttr);\n    } else {\n      // IE doesn't appear to support removeAttribute on the document element\n      el[elIdAttr] = null;\n    }\n  }\n}\n\n/**\n * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\n * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\n * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\n * robust as jquery's, so there's probably some differences.\n *\n * @module events\n */\n\n/**\n * Clean up the listener cache and dispatchers\n *\n * @param {Element|Object} elem\n *        Element to clean up\n *\n * @param {string} type\n *        Type of event to clean up\n */\nfunction _cleanUpEvents(elem, type) {\n  var data = getData(elem);\n\n  // Remove the events of a particular type if there are none left\n  if (data.handlers[type].length === 0) {\n    delete data.handlers[type];\n    // data.handlers[type] = null;\n    // Setting to null was causing an error with data.handlers\n\n    // Remove the meta-handler from the element\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, data.dispatcher, false);\n    } else if (elem.detachEvent) {\n      elem.detachEvent('on' + type, data.dispatcher);\n    }\n  }\n\n  // Remove the events object if there are no types left\n  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {\n    delete data.handlers;\n    delete data.dispatcher;\n    delete data.disabled;\n  }\n\n  // Finally remove the element data if there is no data left\n  if (Object.getOwnPropertyNames(data).length === 0) {\n    removeData(elem);\n  }\n}\n\n/**\n * Loops through an array of event types and calls the requested method for each type.\n *\n * @param {Function} fn\n *        The event method we want to use.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} callback\n *        Event listener.\n */\nfunction _handleMultipleEvents(fn, elem, types, callback) {\n  types.forEach(function (type) {\n    // Call the event method for each one of the types\n    fn(elem, type, callback);\n  });\n}\n\n/**\n * Fix a native event to have standard property values\n *\n * @param {Object} event\n *        Event object to fix.\n *\n * @return {Object}\n *         Fixed event object.\n */\nfunction fixEvent(event) {\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  }\n\n  // Test if fixing up is needed\n  // Used to check if !event.stopPropagation instead of isPropagationStopped\n  // But native events return true for stopPropagation, but don't have\n  // other expected methods like isPropagationStopped. Seems to be a problem\n  // with the Javascript Ninja code. So we're just overriding all events now.\n  if (!event || !event.isPropagationStopped) {\n    var old = event || global_window__WEBPACK_IMPORTED_MODULE_0___default.a.event;\n\n    event = {};\n    // Clone the old object so that we can modify the values event = {};\n    // IE8 Doesn't like when you mess with native event properties\n    // Firefox returns false for event.hasOwnProperty('type') and other props\n    //  which makes copying more difficult.\n    // TODO: Probably best to create a whitelist of event props\n    for (var key in old) {\n      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\n      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\n      // and webkitMovementX/Y\n      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {\n        // Chrome 32+ warns if you try to copy deprecated returnValue, but\n        // we still want to if preventDefault isn't supported (IE8).\n        if (!(key === 'returnValue' && old.preventDefault)) {\n          event[key] = old[key];\n        }\n      }\n    }\n\n    // The event occurred on this element\n    if (!event.target) {\n      event.target = event.srcElement || global_document__WEBPACK_IMPORTED_MODULE_1___default.a;\n    }\n\n    // Handle which other element the event is related to\n    if (!event.relatedTarget) {\n      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\n    }\n\n    // Stop the default browser action\n    event.preventDefault = function () {\n      if (old.preventDefault) {\n        old.preventDefault();\n      }\n      event.returnValue = false;\n      old.returnValue = false;\n      event.defaultPrevented = true;\n    };\n\n    event.defaultPrevented = false;\n\n    // Stop the event from bubbling\n    event.stopPropagation = function () {\n      if (old.stopPropagation) {\n        old.stopPropagation();\n      }\n      event.cancelBubble = true;\n      old.cancelBubble = true;\n      event.isPropagationStopped = returnTrue;\n    };\n\n    event.isPropagationStopped = returnFalse;\n\n    // Stop the event from bubbling and executing other handlers\n    event.stopImmediatePropagation = function () {\n      if (old.stopImmediatePropagation) {\n        old.stopImmediatePropagation();\n      }\n      event.isImmediatePropagationStopped = returnTrue;\n      event.stopPropagation();\n    };\n\n    event.isImmediatePropagationStopped = returnFalse;\n\n    // Handle mouse position\n    if (event.clientX !== null && event.clientX !== undefined) {\n      var doc = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.documentElement;\n      var body = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.body;\n\n      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n    }\n\n    // Handle key presses\n    event.which = event.charCode || event.keyCode;\n\n    // Fix button for mouse clicks:\n    // 0 == left; 1 == middle; 2 == right\n    if (event.button !== null && event.button !== undefined) {\n\n      // The following is disabled because it does not pass videojs-standard\n      // and... yikes.\n      /* eslint-disable */\n      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;\n      /* eslint-enable */\n    }\n  }\n\n  // Returns fixed-up instance\n  return event;\n}\n\n/**\n * Whether passive event listeners are supported\n */\nvar _supportsPassive = false;\n\n(function () {\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        _supportsPassive = true;\n      }\n    });\n\n    global_window__WEBPACK_IMPORTED_MODULE_0___default.a.addEventListener('test', null, opts);\n    global_window__WEBPACK_IMPORTED_MODULE_0___default.a.removeEventListener('test', null, opts);\n  } catch (e) {\n    // disregard\n  }\n})();\n\n/**\n * Touch events Chrome expects to be passive\n */\nvar passiveEvents = ['touchstart', 'touchmove'];\n\n/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string|string[]} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} fn\n *        Event listener.\n */\nfunction on(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(on, elem, type, fn);\n  }\n\n  var data = getData(elem);\n\n  // We need a place to store all our handler data\n  if (!data.handlers) {\n    data.handlers = {};\n  }\n\n  if (!data.handlers[type]) {\n    data.handlers[type] = [];\n  }\n\n  if (!fn.guid) {\n    fn.guid = newGUID();\n  }\n\n  data.handlers[type].push(fn);\n\n  if (!data.dispatcher) {\n    data.disabled = false;\n\n    data.dispatcher = function (event, hash) {\n\n      if (data.disabled) {\n        return;\n      }\n\n      event = fixEvent(event);\n\n      var handlers = data.handlers[event.type];\n\n      if (handlers) {\n        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\n        var handlersCopy = handlers.slice(0);\n\n        for (var m = 0, n = handlersCopy.length; m < n; m++) {\n          if (event.isImmediatePropagationStopped()) {\n            break;\n          } else {\n            try {\n              handlersCopy[m].call(elem, event, hash);\n            } catch (e) {\n              log$1.error(e);\n            }\n          }\n        }\n      }\n    };\n  }\n\n  if (data.handlers[type].length === 1) {\n    if (elem.addEventListener) {\n      var options = false;\n\n      if (_supportsPassive && passiveEvents.indexOf(type) > -1) {\n        options = { passive: true };\n      }\n      elem.addEventListener(type, data.dispatcher, options);\n    } else if (elem.attachEvent) {\n      elem.attachEvent('on' + type, data.dispatcher);\n    }\n  }\n}\n\n/**\n * Removes event listeners from an element\n *\n * @param {Element|Object} elem\n *        Object to remove listeners from.\n *\n * @param {string|string[]} [type]\n *        Type of listener to remove. Don't include to remove all events from element.\n *\n * @param {EventTarget~EventListener} [fn]\n *        Specific listener to remove. Don't include to remove listeners for an event\n *        type.\n */\nfunction off(elem, type, fn) {\n  // Don't want to add a cache object through getElData if not needed\n  if (!hasData(elem)) {\n    return;\n  }\n\n  var data = getData(elem);\n\n  // If no events exist, nothing to unbind\n  if (!data.handlers) {\n    return;\n  }\n\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(off, elem, type, fn);\n  }\n\n  // Utility function\n  var removeType = function removeType(el, t) {\n    data.handlers[t] = [];\n    _cleanUpEvents(el, t);\n  };\n\n  // Are we removing all bound events?\n  if (type === undefined) {\n    for (var t in data.handlers) {\n      if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {\n        removeType(elem, t);\n      }\n    }\n    return;\n  }\n\n  var handlers = data.handlers[type];\n\n  // If no handlers exist, nothing to unbind\n  if (!handlers) {\n    return;\n  }\n\n  // If no listener was provided, remove all listeners for type\n  if (!fn) {\n    removeType(elem, type);\n    return;\n  }\n\n  // We're only removing a single handler\n  if (fn.guid) {\n    for (var n = 0; n < handlers.length; n++) {\n      if (handlers[n].guid === fn.guid) {\n        handlers.splice(n--, 1);\n      }\n    }\n  }\n\n  _cleanUpEvents(elem, type);\n}\n\n/**\n * Trigger an event for an element\n *\n * @param {Element|Object} elem\n *        Element to trigger an event on\n *\n * @param {EventTarget~Event|string} event\n *        A string (the type) or an event object with a type attribute\n *\n * @param {Object} [hash]\n *        data hash to pass along with the event\n *\n * @return {boolean|undefined}\n *         - Returns the opposite of `defaultPrevented` if default was prevented\n *         - Otherwise returns undefined\n */\nfunction trigger(elem, event, hash) {\n  // Fetches element data and a reference to the parent (for bubbling).\n  // Don't want to add a data object to cache for every parent,\n  // so checking hasElData first.\n  var elemData = hasData(elem) ? getData(elem) : {};\n  var parent = elem.parentNode || elem.ownerDocument;\n  // type = event.type || event,\n  // handler;\n\n  // If an event name was passed as a string, creates an event out of it\n  if (typeof event === 'string') {\n    event = { type: event, target: elem };\n  } else if (!event.target) {\n    event.target = elem;\n  }\n\n  // Normalizes the event properties.\n  event = fixEvent(event);\n\n  // If the passed element has a dispatcher, executes the established handlers.\n  if (elemData.dispatcher) {\n    elemData.dispatcher.call(elem, event, hash);\n  }\n\n  // Unless explicitly stopped or the event does not bubble (e.g. media events)\n  // recursively calls this function to bubble the event up the DOM.\n  if (parent && !event.isPropagationStopped() && event.bubbles === true) {\n    trigger.call(null, parent, event, hash);\n\n    // If at the top of the DOM, triggers the default action unless disabled.\n  } else if (!parent && !event.defaultPrevented) {\n    var targetData = getData(event.target);\n\n    // Checks if the target has a default action for this event.\n    if (event.target[event.type]) {\n      // Temporarily disables event dispatching on the target as we have already executed the handler.\n      targetData.disabled = true;\n      // Executes the default action.\n      if (typeof event.target[event.type] === 'function') {\n        event.target[event.type]();\n      }\n      // Re-enables event dispatching.\n      targetData.disabled = false;\n    }\n  }\n\n  // Inform the triggerer if the default was prevented by returning false\n  return !event.defaultPrevented;\n}\n\n/**\n * Trigger a listener only once for an event\n *\n * @param {Element|Object} elem\n *        Element or object to bind to.\n *\n * @param {string|string[]} type\n *        Name/type of event\n *\n * @param {Event~EventListener} fn\n *        Event Listener function\n */\nfunction one(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(one, elem, type, fn);\n  }\n  var func = function func() {\n    off(elem, type, func);\n    fn.apply(this, arguments);\n  };\n\n  // copy the guid to the new function so it can removed using the original function's ID\n  func.guid = fn.guid = fn.guid || newGUID();\n  on(elem, type, func);\n}\n\nvar Events = /*#__PURE__*/Object.freeze({\n  fixEvent: fixEvent,\n  on: on,\n  off: off,\n  trigger: trigger,\n  one: one\n});\n\n/**\n * @file setup.js - Functions for setting up a player without\n * user interaction based on the data-setup `attribute` of the video tag.\n *\n * @module setup\n */\n\nvar _windowLoaded = false;\nvar videojs = void 0;\n\n/**\n * Set up any tags that have a data-setup `attribute` when the player is started.\n */\nvar autoSetup = function autoSetup() {\n\n  // Protect against breakage in non-browser environments and check global autoSetup option.\n  if (!isReal() || videojs.options.autoSetup === false) {\n    return;\n  }\n\n  var vids = Array.prototype.slice.call(global_document__WEBPACK_IMPORTED_MODULE_1___default.a.getElementsByTagName('video'));\n  var audios = Array.prototype.slice.call(global_document__WEBPACK_IMPORTED_MODULE_1___default.a.getElementsByTagName('audio'));\n  var divs = Array.prototype.slice.call(global_document__WEBPACK_IMPORTED_MODULE_1___default.a.getElementsByTagName('video-js'));\n  var mediaEls = vids.concat(audios, divs);\n\n  // Check if any media elements exist\n  if (mediaEls && mediaEls.length > 0) {\n\n    for (var i = 0, e = mediaEls.length; i < e; i++) {\n      var mediaEl = mediaEls[i];\n\n      // Check if element exists, has getAttribute func.\n      if (mediaEl && mediaEl.getAttribute) {\n\n        // Make sure this player hasn't already been set up.\n        if (mediaEl.player === undefined) {\n          var options = mediaEl.getAttribute('data-setup');\n\n          // Check if data-setup attr exists.\n          // We only auto-setup if they've added the data-setup attr.\n          if (options !== null) {\n            // Create new video.js instance.\n            videojs(mediaEl);\n          }\n        }\n\n        // If getAttribute isn't defined, we need to wait for the DOM.\n      } else {\n        autoSetupTimeout(1);\n        break;\n      }\n    }\n\n    // No videos were found, so keep looping unless page is finished loading.\n  } else if (!_windowLoaded) {\n    autoSetupTimeout(1);\n  }\n};\n\n/**\n * Wait until the page is loaded before running autoSetup. This will be called in\n * autoSetup if `hasLoaded` returns false.\n *\n * @param {number} wait\n *        How long to wait in ms\n *\n * @param {module:videojs} [vjs]\n *        The videojs library function\n */\nfunction autoSetupTimeout(wait, vjs) {\n  if (vjs) {\n    videojs = vjs;\n  }\n\n  global_window__WEBPACK_IMPORTED_MODULE_0___default.a.setTimeout(autoSetup, wait);\n}\n\nif (isReal() && global_document__WEBPACK_IMPORTED_MODULE_1___default.a.readyState === 'complete') {\n  _windowLoaded = true;\n} else {\n  /**\n   * Listen for the load event on window, and set _windowLoaded to true.\n   *\n   * @listens load\n   */\n  one(global_window__WEBPACK_IMPORTED_MODULE_0___default.a, 'load', function () {\n    _windowLoaded = true;\n  });\n}\n\n/**\n * @file stylesheet.js\n * @module stylesheet\n */\n\n/**\n * Create a DOM syle element given a className for it.\n *\n * @param {string} className\n *        The className to add to the created style element.\n *\n * @return {Element}\n *         The element that was created.\n */\nvar createStyleElement = function createStyleElement(className) {\n  var style = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('style');\n\n  style.className = className;\n\n  return style;\n};\n\n/**\n * Add text to a DOM element.\n *\n * @param {Element} el\n *        The Element to add text content to.\n *\n * @param {string} content\n *        The text to add to the element.\n */\nvar setTextContent = function setTextContent(el, content) {\n  if (el.styleSheet) {\n    el.styleSheet.cssText = content;\n  } else {\n    el.textContent = content;\n  }\n};\n\n/**\n * @file fn.js\n * @module fn\n */\n\n/**\n * Bind (a.k.a proxy or Context). A simple method for changing the context of a function\n * It also stores a unique id on the function so it can be easily removed from events.\n *\n * @param {Mixed} context\n *        The object to bind as scope.\n *\n * @param {Function} fn\n *        The function to be bound to a scope.\n *\n * @param {number} [uid]\n *        An optional unique ID for the function to be set\n *\n * @return {Function}\n *         The new function that will be bound into the context given\n */\nvar bind = function bind(context, fn, uid) {\n  // Make sure the function has a unique ID\n  if (!fn.guid) {\n    fn.guid = newGUID();\n  }\n\n  // Create the new function that changes the context\n  var bound = function bound() {\n    return fn.apply(context, arguments);\n  };\n\n  // Allow for the ability to individualize this function\n  // Needed in the case where multiple objects might share the same prototype\n  // IF both items add an event listener with the same function, then you try to remove just one\n  // it will remove both because they both have the same guid.\n  // when using this, you need to use the bind method when you remove the listener as well.\n  // currently used in text tracks\n  bound.guid = uid ? uid + '_' + fn.guid : fn.guid;\n\n  return bound;\n};\n\n/**\n * Wraps the given function, `fn`, with a new function that only invokes `fn`\n * at most once per every `wait` milliseconds.\n *\n * @param  {Function} fn\n *         The function to be throttled.\n *\n * @param  {Number}   wait\n *         The number of milliseconds by which to throttle.\n *\n * @return {Function}\n */\nvar throttle = function throttle(fn, wait) {\n  var last = Date.now();\n\n  var throttled = function throttled() {\n    var now = Date.now();\n\n    if (now - last >= wait) {\n      fn.apply(undefined, arguments);\n      last = now;\n    }\n  };\n\n  return throttled;\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked.\n *\n * Inspired by lodash and underscore implementations.\n *\n * @param  {Function} func\n *         The function to wrap with debounce behavior.\n *\n * @param  {number} wait\n *         The number of milliseconds to wait after the last invocation.\n *\n * @param  {boolean} [immediate]\n *         Whether or not to invoke the function immediately upon creation.\n *\n * @param  {Object} [context=window]\n *         The \"context\" in which the debounced function should debounce. For\n *         example, if this function should be tied to a Video.js player,\n *         the player can be passed here. Alternatively, defaults to the\n *         global `window` object.\n *\n * @return {Function}\n *         A debounced function.\n */\nvar debounce = function debounce(func, wait, immediate) {\n  var context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : global_window__WEBPACK_IMPORTED_MODULE_0___default.a;\n\n  var timeout = void 0;\n\n  /* eslint-disable consistent-this */\n  return function () {\n    var self = this;\n    var args = arguments;\n\n    var _later = function later() {\n      timeout = null;\n      _later = null;\n      if (!immediate) {\n        func.apply(self, args);\n      }\n    };\n\n    if (!timeout && immediate) {\n      func.apply(self, args);\n    }\n\n    context.clearTimeout(timeout);\n    timeout = context.setTimeout(_later, wait);\n  };\n  /* eslint-enable consistent-this */\n};\n\n/**\n * @file src/js/event-target.js\n */\n\n/**\n * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It\n * adds shorthand functions that wrap around lengthy functions. For example:\n * the `on` function is a wrapper around `addEventListener`.\n *\n * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}\n * @class EventTarget\n */\nvar EventTarget = function EventTarget() {};\n\n/**\n * A Custom DOM event.\n *\n * @typedef {Object} EventTarget~Event\n * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}\n */\n\n/**\n * All event listeners should follow the following format.\n *\n * @callback EventTarget~EventListener\n * @this {EventTarget}\n *\n * @param {EventTarget~Event} event\n *        the event that triggered this function\n *\n * @param {Object} [hash]\n *        hash of data sent during the event\n */\n\n/**\n * An object containing event names as keys and booleans as values.\n *\n * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}\n *         will have extra functionality. See that function for more information.\n *\n * @property EventTarget.prototype.allowedEvents_\n * @private\n */\nEventTarget.prototype.allowedEvents_ = {};\n\n/**\n * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a\n * function that will get called when an event with a certain name gets triggered.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to call with `EventTarget`s\n */\nEventTarget.prototype.on = function (type, fn) {\n  // Remove the addEventListener alias before calling Events.on\n  // so we don't get into an infinite type loop\n  var ael = this.addEventListener;\n\n  this.addEventListener = function () {};\n  on(this, type, fn);\n  this.addEventListener = ael;\n};\n\n/**\n * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#on}\n */\nEventTarget.prototype.addEventListener = EventTarget.prototype.on;\n\n/**\n * Removes an `event listener` for a specific event from an instance of `EventTarget`.\n * This makes it so that the `event listener` will no longer get called when the\n * named event happens.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to remove.\n */\nEventTarget.prototype.off = function (type, fn) {\n  off(this, type, fn);\n};\n\n/**\n * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#off}\n */\nEventTarget.prototype.removeEventListener = EventTarget.prototype.off;\n\n/**\n * This function will add an `event listener` that gets triggered only once. After the\n * first trigger it will get removed. This is like adding an `event listener`\n * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to be called once for each event name.\n */\nEventTarget.prototype.one = function (type, fn) {\n  // Remove the addEventListener alialing Events.on\n  // so we don't get into an infinite type loop\n  var ael = this.addEventListener;\n\n  this.addEventListener = function () {};\n  one(this, type, fn);\n  this.addEventListener = ael;\n};\n\n/**\n * This function causes an event to happen. This will then cause any `event listeners`\n * that are waiting for that event, to get called. If there are no `event listeners`\n * for an event then nothing will happen.\n *\n * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.\n * Trigger will also call the `on` + `uppercaseEventName` function.\n *\n * Example:\n * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call\n * `onClick` if it exists.\n *\n * @param {string|EventTarget~Event|Object} event\n *        The name of the event, an `Event`, or an object with a key of type set to\n *        an event name.\n */\nEventTarget.prototype.trigger = function (event) {\n  var type = event.type || event;\n\n  if (typeof event === 'string') {\n    event = { type: type };\n  }\n  event = fixEvent(event);\n\n  if (this.allowedEvents_[type] && this['on' + type]) {\n    this['on' + type](event);\n  }\n\n  trigger(this, event);\n};\n\n/**\n * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#trigger}\n */\nEventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;\n\n/**\n * @file mixins/evented.js\n * @module evented\n */\n\n/**\n * Returns whether or not an object has had the evented mixin applied.\n *\n * @param  {Object} object\n *         An object to test.\n *\n * @return {boolean}\n *         Whether or not the object appears to be evented.\n */\nvar isEvented = function isEvented(object) {\n  return object instanceof EventTarget || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(function (k) {\n    return typeof object[k] === 'function';\n  });\n};\n\n/**\n * Whether a value is a valid event type - non-empty string or array.\n *\n * @private\n * @param  {string|Array} type\n *         The type value to test.\n *\n * @return {boolean}\n *         Whether or not the type is a valid event type.\n */\nvar isValidEventType = function isValidEventType(type) {\n  return (\n    // The regex here verifies that the `type` contains at least one non-\n    // whitespace character.\n    typeof type === 'string' && /\\S/.test(type) || Array.isArray(type) && !!type.length\n  );\n};\n\n/**\n * Validates a value to determine if it is a valid event target. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the target does not appear to be a valid event target.\n *\n * @param  {Object} target\n *         The object to test.\n */\nvar validateTarget = function validateTarget(target) {\n  if (!target.nodeName && !isEvented(target)) {\n    throw new Error('Invalid target; must be a DOM node or evented object.');\n  }\n};\n\n/**\n * Validates a value to determine if it is a valid event target. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the type does not appear to be a valid event type.\n *\n * @param  {string|Array} type\n *         The type to test.\n */\nvar validateEventType = function validateEventType(type) {\n  if (!isValidEventType(type)) {\n    throw new Error('Invalid event type; must be a non-empty string or array.');\n  }\n};\n\n/**\n * Validates a value to determine if it is a valid listener. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the listener is not a function.\n *\n * @param  {Function} listener\n *         The listener to test.\n */\nvar validateListener = function validateListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new Error('Invalid listener; must be a function.');\n  }\n};\n\n/**\n * Takes an array of arguments given to `on()` or `one()`, validates them, and\n * normalizes them into an object.\n *\n * @private\n * @param  {Object} self\n *         The evented object on which `on()` or `one()` was called. This\n *         object will be bound as the `this` value for the listener.\n *\n * @param  {Array} args\n *         An array of arguments passed to `on()` or `one()`.\n *\n * @return {Object}\n *         An object containing useful values for `on()` or `one()` calls.\n */\nvar normalizeListenArgs = function normalizeListenArgs(self, args) {\n\n  // If the number of arguments is less than 3, the target is always the\n  // evented object itself.\n  var isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;\n  var target = void 0;\n  var type = void 0;\n  var listener = void 0;\n\n  if (isTargetingSelf) {\n    target = self.eventBusEl_;\n\n    // Deal with cases where we got 3 arguments, but we are still listening to\n    // the evented object itself.\n    if (args.length >= 3) {\n      args.shift();\n    }\n\n    type = args[0];\n    listener = args[1];\n  } else {\n    target = args[0];\n    type = args[1];\n    listener = args[2];\n  }\n\n  validateTarget(target);\n  validateEventType(type);\n  validateListener(listener);\n\n  listener = bind(self, listener);\n\n  return { isTargetingSelf: isTargetingSelf, target: target, type: type, listener: listener };\n};\n\n/**\n * Adds the listener to the event type(s) on the target, normalizing for\n * the type of target.\n *\n * @private\n * @param  {Element|Object} target\n *         A DOM node or evented object.\n *\n * @param  {string} method\n *         The event binding method to use (\"on\" or \"one\").\n *\n * @param  {string|Array} type\n *         One or more event type(s).\n *\n * @param  {Function} listener\n *         A listener function.\n */\nvar listen = function listen(target, method, type, listener) {\n  validateTarget(target);\n\n  if (target.nodeName) {\n    Events[method](target, type, listener);\n  } else {\n    target[method](type, listener);\n  }\n};\n\n/**\n * Contains methods that provide event capabilities to an object which is passed\n * to {@link module:evented|evented}.\n *\n * @mixin EventedMixin\n */\nvar EventedMixin = {\n\n  /**\n   * Add a listener to an event (or events) on this object or another evented\n   * object.\n   *\n   * @param  {string|Array|Element|Object} targetOrType\n   *         If this is a string or array, it represents the event type(s)\n   *         that will trigger the listener.\n   *\n   *         Another evented object can be passed here instead, which will\n   *         cause the listener to listen for events on _that_ object.\n   *\n   *         In either case, the listener's `this` value will be bound to\n   *         this object.\n   *\n   * @param  {string|Array|Function} typeOrListener\n   *         If the first argument was a string or array, this should be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function.\n   */\n  on: function on$$1() {\n    var _this = this;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _normalizeListenArgs = normalizeListenArgs(this, args),\n        isTargetingSelf = _normalizeListenArgs.isTargetingSelf,\n        target = _normalizeListenArgs.target,\n        type = _normalizeListenArgs.type,\n        listener = _normalizeListenArgs.listener;\n\n    listen(target, 'on', type, listener);\n\n    // If this object is listening to another evented object.\n    if (!isTargetingSelf) {\n\n      // If this object is disposed, remove the listener.\n      var removeListenerOnDispose = function removeListenerOnDispose() {\n        return _this.off(target, type, listener);\n      };\n\n      // Use the same function ID as the listener so we can remove it later it\n      // using the ID of the original listener.\n      removeListenerOnDispose.guid = listener.guid;\n\n      // Add a listener to the target's dispose event as well. This ensures\n      // that if the target is disposed BEFORE this object, we remove the\n      // removal listener that was just added. Otherwise, we create a memory leak.\n      var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose() {\n        return _this.off('dispose', removeListenerOnDispose);\n      };\n\n      // Use the same function ID as the listener so we can remove it later\n      // it using the ID of the original listener.\n      removeRemoverOnTargetDispose.guid = listener.guid;\n\n      listen(this, 'on', 'dispose', removeListenerOnDispose);\n      listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);\n    }\n  },\n\n\n  /**\n   * Add a listener to an event (or events) on this object or another evented\n   * object. The listener will only be called once and then removed.\n   *\n   * @param  {string|Array|Element|Object} targetOrType\n   *         If this is a string or array, it represents the event type(s)\n   *         that will trigger the listener.\n   *\n   *         Another evented object can be passed here instead, which will\n   *         cause the listener to listen for events on _that_ object.\n   *\n   *         In either case, the listener's `this` value will be bound to\n   *         this object.\n   *\n   * @param  {string|Array|Function} typeOrListener\n   *         If the first argument was a string or array, this should be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function.\n   */\n  one: function one$$1() {\n    var _this2 = this;\n\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    var _normalizeListenArgs2 = normalizeListenArgs(this, args),\n        isTargetingSelf = _normalizeListenArgs2.isTargetingSelf,\n        target = _normalizeListenArgs2.target,\n        type = _normalizeListenArgs2.type,\n        listener = _normalizeListenArgs2.listener;\n\n    // Targeting this evented object.\n\n\n    if (isTargetingSelf) {\n      listen(target, 'one', type, listener);\n\n      // Targeting another evented object.\n    } else {\n      var wrapper = function wrapper() {\n        for (var _len3 = arguments.length, largs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          largs[_key3] = arguments[_key3];\n        }\n\n        _this2.off(target, type, wrapper);\n        listener.apply(null, largs);\n      };\n\n      // Use the same function ID as the listener so we can remove it later\n      // it using the ID of the original listener.\n      wrapper.guid = listener.guid;\n      listen(target, 'one', type, wrapper);\n    }\n  },\n\n\n  /**\n   * Removes listener(s) from event(s) on an evented object.\n   *\n   * @param  {string|Array|Element|Object} [targetOrType]\n   *         If this is a string or array, it represents the event type(s).\n   *\n   *         Another evented object can be passed here instead, in which case\n   *         ALL 3 arguments are _required_.\n   *\n   * @param  {string|Array|Function} [typeOrListener]\n   *         If the first argument was a string or array, this may be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function; otherwise, _all_ listeners bound to the\n   *         event type(s) will be removed.\n   */\n  off: function off$$1(targetOrType, typeOrListener, listener) {\n\n    // Targeting this evented object.\n    if (!targetOrType || isValidEventType(targetOrType)) {\n      off(this.eventBusEl_, targetOrType, typeOrListener);\n\n      // Targeting another evented object.\n    } else {\n      var target = targetOrType;\n      var type = typeOrListener;\n\n      // Fail fast and in a meaningful way!\n      validateTarget(target);\n      validateEventType(type);\n      validateListener(listener);\n\n      // Ensure there's at least a guid, even if the function hasn't been used\n      listener = bind(this, listener);\n\n      // Remove the dispose listener on this evented object, which was given\n      // the same guid as the event listener in on().\n      this.off('dispose', listener);\n\n      if (target.nodeName) {\n        off(target, type, listener);\n        off(target, 'dispose', listener);\n      } else if (isEvented(target)) {\n        target.off(type, listener);\n        target.off('dispose', listener);\n      }\n    }\n  },\n\n\n  /**\n   * Fire an event on this evented object, causing its listeners to be called.\n   *\n   * @param   {string|Object} event\n   *          An event type or an object with a type property.\n   *\n   * @param   {Object} [hash]\n   *          An additional object to pass along to listeners.\n   *\n   * @returns {boolean}\n   *          Whether or not the default behavior was prevented.\n   */\n  trigger: function trigger$$1(event, hash) {\n    return trigger(this.eventBusEl_, event, hash);\n  }\n};\n\n/**\n * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.\n *\n * @param  {Object} target\n *         The object to which to add event methods.\n *\n * @param  {Object} [options={}]\n *         Options for customizing the mixin behavior.\n *\n * @param  {String} [options.eventBusKey]\n *         By default, adds a `eventBusEl_` DOM element to the target object,\n *         which is used as an event bus. If the target object already has a\n *         DOM element that should be used, pass its key here.\n *\n * @return {Object}\n *         The target object.\n */\nfunction evented(target) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var eventBusKey = options.eventBusKey;\n\n  // Set or create the eventBusEl_.\n\n  if (eventBusKey) {\n    if (!target[eventBusKey].nodeName) {\n      throw new Error('The eventBusKey \"' + eventBusKey + '\" does not refer to an element.');\n    }\n    target.eventBusEl_ = target[eventBusKey];\n  } else {\n    target.eventBusEl_ = createEl('span', { className: 'vjs-event-bus' });\n  }\n\n  assign(target, EventedMixin);\n\n  // When any evented object is disposed, it removes all its listeners.\n  target.on('dispose', function () {\n    target.off();\n    global_window__WEBPACK_IMPORTED_MODULE_0___default.a.setTimeout(function () {\n      target.eventBusEl_ = null;\n    }, 0);\n  });\n\n  return target;\n}\n\n/**\n * @file mixins/stateful.js\n * @module stateful\n */\n\n/**\n * Contains methods that provide statefulness to an object which is passed\n * to {@link module:stateful}.\n *\n * @mixin StatefulMixin\n */\nvar StatefulMixin = {\n\n  /**\n   * A hash containing arbitrary keys and values representing the state of\n   * the object.\n   *\n   * @type {Object}\n   */\n  state: {},\n\n  /**\n   * Set the state of an object by mutating its\n   * {@link module:stateful~StatefulMixin.state|state} object in place.\n   *\n   * @fires   module:stateful~StatefulMixin#statechanged\n   * @param   {Object|Function} stateUpdates\n   *          A new set of properties to shallow-merge into the plugin state.\n   *          Can be a plain object or a function returning a plain object.\n   *\n   * @returns {Object|undefined}\n   *          An object containing changes that occurred. If no changes\n   *          occurred, returns `undefined`.\n   */\n  setState: function setState(stateUpdates) {\n    var _this = this;\n\n    // Support providing the `stateUpdates` state as a function.\n    if (typeof stateUpdates === 'function') {\n      stateUpdates = stateUpdates();\n    }\n\n    var changes = void 0;\n\n    each(stateUpdates, function (value, key) {\n\n      // Record the change if the value is different from what's in the\n      // current state.\n      if (_this.state[key] !== value) {\n        changes = changes || {};\n        changes[key] = {\n          from: _this.state[key],\n          to: value\n        };\n      }\n\n      _this.state[key] = value;\n    });\n\n    // Only trigger \"statechange\" if there were changes AND we have a trigger\n    // function. This allows us to not require that the target object be an\n    // evented object.\n    if (changes && isEvented(this)) {\n\n      /**\n       * An event triggered on an object that is both\n       * {@link module:stateful|stateful} and {@link module:evented|evented}\n       * indicating that its state has changed.\n       *\n       * @event    module:stateful~StatefulMixin#statechanged\n       * @type     {Object}\n       * @property {Object} changes\n       *           A hash containing the properties that were changed and\n       *           the values they were changed `from` and `to`.\n       */\n      this.trigger({\n        changes: changes,\n        type: 'statechanged'\n      });\n    }\n\n    return changes;\n  }\n};\n\n/**\n * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target\n * object.\n *\n * If the target object is {@link module:evented|evented} and has a\n * `handleStateChanged` method, that method will be automatically bound to the\n * `statechanged` event on itself.\n *\n * @param   {Object} target\n *          The object to be made stateful.\n *\n * @param   {Object} [defaultState]\n *          A default set of properties to populate the newly-stateful object's\n *          `state` property.\n *\n * @returns {Object}\n *          Returns the `target`.\n */\nfunction stateful(target, defaultState) {\n  assign(target, StatefulMixin);\n\n  // This happens after the mixing-in because we need to replace the `state`\n  // added in that step.\n  target.state = assign({}, target.state, defaultState);\n\n  // Auto-bind the `handleStateChanged` method of the target object if it exists.\n  if (typeof target.handleStateChanged === 'function' && isEvented(target)) {\n    target.on('statechanged', target.handleStateChanged);\n  }\n\n  return target;\n}\n\n/**\n * @file to-title-case.js\n * @module to-title-case\n */\n\n/**\n * Uppercase the first letter of a string.\n *\n * @param {string} string\n *        String to be uppercased\n *\n * @return {string}\n *         The string with an uppercased first letter\n */\nfunction toTitleCase(string) {\n  if (typeof string !== 'string') {\n    return string;\n  }\n\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\n/**\n * Compares the TitleCase versions of the two strings for equality.\n *\n * @param {string} str1\n *        The first string to compare\n *\n * @param {string} str2\n *        The second string to compare\n *\n * @return {boolean}\n *         Whether the TitleCase versions of the strings are equal\n */\nfunction titleCaseEquals(str1, str2) {\n  return toTitleCase(str1) === toTitleCase(str2);\n}\n\n/**\n * @file merge-options.js\n * @module merge-options\n */\n\n/**\n * Deep-merge one or more options objects, recursively merging **only** plain\n * object properties.\n *\n * @param   {Object[]} sources\n *          One or more objects to merge into a new object.\n *\n * @returns {Object}\n *          A new object that is the merged result of all sources.\n */\nfunction mergeOptions() {\n  var result = {};\n\n  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n\n    each(source, function (value, key) {\n      if (!isPlain(value)) {\n        result[key] = value;\n        return;\n      }\n\n      if (!isPlain(result[key])) {\n        result[key] = {};\n      }\n\n      result[key] = mergeOptions(result[key], value);\n    });\n  });\n\n  return result;\n}\n\n/**\n * Player Component - Base class for all UI objects\n *\n * @file component.js\n */\n\n/**\n * Base class for all UI Components.\n * Components are UI objects which represent both a javascript object and an element\n * in the DOM. They can be children of other components, and can have\n * children themselves.\n *\n * Components can also use methods from {@link EventTarget}\n */\n\nvar Component = function () {\n\n  /**\n   * A callback that is called when a component is ready. Does not have any\n   * paramters and any callback value will be ignored.\n   *\n   * @callback Component~ReadyCallback\n   * @this Component\n   */\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Object[]} [options.children]\n   *        An array of children objects to intialize this component with. Children objects have\n   *        a name property that will be used if more than one component of the same type needs to be\n   *        added.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        Function that gets called when the `Component` is ready.\n   */\n  function Component(player, options, ready) {\n    classCallCheck(this, Component);\n\n\n    // The component might be the player itself and we can't pass `this` to super\n    if (!player && this.play) {\n      this.player_ = player = this; // eslint-disable-line\n    } else {\n      this.player_ = player;\n    }\n\n    // Make a copy of prototype.options_ to protect against overriding defaults\n    this.options_ = mergeOptions({}, this.options_);\n\n    // Updated options with supplied options\n    options = this.options_ = mergeOptions(this.options_, options);\n\n    // Get ID from options or options element if one is supplied\n    this.id_ = options.id || options.el && options.el.id;\n\n    // If there was no ID from the options, generate one\n    if (!this.id_) {\n      // Don't require the player ID function in the case of mock players\n      var id = player && player.id && player.id() || 'no_player';\n\n      this.id_ = id + '_component_' + newGUID();\n    }\n\n    this.name_ = options.name || null;\n\n    // Create element if one wasn't provided in options\n    if (options.el) {\n      this.el_ = options.el;\n    } else if (options.createEl !== false) {\n      this.el_ = this.createEl();\n    }\n\n    // if evented is anything except false, we want to mixin in evented\n    if (options.evented !== false) {\n      // Make this an evented object and use `el_`, if available, as its event bus\n      evented(this, { eventBusKey: this.el_ ? 'el_' : null });\n    }\n    stateful(this, this.constructor.defaultState);\n\n    this.children_ = [];\n    this.childIndex_ = {};\n    this.childNameIndex_ = {};\n\n    // Add any child components in options\n    if (options.initChildren !== false) {\n      this.initChildren();\n    }\n\n    this.ready(ready);\n    // Don't want to trigger ready here or it will before init is actually\n    // finished for all children that run this constructor\n\n    if (options.reportTouchActivity !== false) {\n      this.enableTouchActivity();\n    }\n  }\n\n  /**\n   * Dispose of the `Component` and all child components.\n   *\n   * @fires Component#dispose\n   */\n\n\n  Component.prototype.dispose = function dispose() {\n\n    /**\n     * Triggered when a `Component` is disposed.\n     *\n     * @event Component#dispose\n     * @type {EventTarget~Event}\n     *\n     * @property {boolean} [bubbles=false]\n     *           set to false so that the close event does not\n     *           bubble up\n     */\n    this.trigger({ type: 'dispose', bubbles: false });\n\n    // Dispose all children.\n    if (this.children_) {\n      for (var i = this.children_.length - 1; i >= 0; i--) {\n        if (this.children_[i].dispose) {\n          this.children_[i].dispose();\n        }\n      }\n    }\n\n    // Delete child references\n    this.children_ = null;\n    this.childIndex_ = null;\n    this.childNameIndex_ = null;\n\n    if (this.el_) {\n      // Remove element from DOM\n      if (this.el_.parentNode) {\n        this.el_.parentNode.removeChild(this.el_);\n      }\n\n      removeData(this.el_);\n      this.el_ = null;\n    }\n\n    // remove reference to the player after disposing of the element\n    this.player_ = null;\n  };\n\n  /**\n   * Return the {@link Player} that the `Component` has attached to.\n   *\n   * @return {Player}\n   *         The player that this `Component` has attached to.\n   */\n\n\n  Component.prototype.player = function player() {\n    return this.player_;\n  };\n\n  /**\n   * Deep merge of options objects with new options.\n   * > Note: When both `obj` and `options` contain properties whose values are objects.\n   *         The two properties get merged using {@link module:mergeOptions}\n   *\n   * @param {Object} obj\n   *        The object that contains new options.\n   *\n   * @return {Object}\n   *         A new object of `this.options_` and `obj` merged together.\n   *\n   * @deprecated since version 5\n   */\n\n\n  Component.prototype.options = function options(obj) {\n    log$1.warn('this.options() has been deprecated and will be moved to the constructor in 6.0');\n\n    if (!obj) {\n      return this.options_;\n    }\n\n    this.options_ = mergeOptions(this.options_, obj);\n    return this.options_;\n  };\n\n  /**\n   * Get the `Component`s DOM element\n   *\n   * @return {Element}\n   *         The DOM element for this `Component`.\n   */\n\n\n  Component.prototype.el = function el() {\n    return this.el_;\n  };\n\n  /**\n   * Create the `Component`s DOM element.\n   *\n   * @param {string} [tagName]\n   *        Element's DOM node type. e.g. 'div'\n   *\n   * @param {Object} [properties]\n   *        An object of properties that should be set.\n   *\n   * @param {Object} [attributes]\n   *        An object of attributes that should be set.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  Component.prototype.createEl = function createEl$$1(tagName, properties, attributes) {\n    return createEl(tagName, properties, attributes);\n  };\n\n  /**\n   * Localize a string given the string in english.\n   *\n   * If tokens are provided, it'll try and run a simple token replacement on the provided string.\n   * The tokens it looks for look like `{1}` with the index being 1-indexed into the tokens array.\n   *\n   * If a `defaultValue` is provided, it'll use that over `string`,\n   * if a value isn't found in provided language files.\n   * This is useful if you want to have a descriptive key for token replacement\n   * but have a succinct localized string and not require `en.json` to be included.\n   *\n   * Currently, it is used for the progress bar timing.\n   * ```js\n   * {\n   *   \"progress bar timing: currentTime={1} duration={2}\": \"{1} of {2}\"\n   * }\n   * ```\n   * It is then used like so:\n   * ```js\n   * this.localize('progress bar timing: currentTime={1} duration{2}',\n   *               [this.player_.currentTime(), this.player_.duration()],\n   *               '{1} of {2}');\n   * ```\n   *\n   * Which outputs something like: `01:23 of 24:56`.\n   *\n   *\n   * @param {string} string\n   *        The string to localize and the key to lookup in the language files.\n   * @param {string[]} [tokens]\n   *        If the current item has token replacements, provide the tokens here.\n   * @param {string} [defaultValue]\n   *        Defaults to `string`. Can be a default value to use for token replacement\n   *        if the lookup key is needed to be separate.\n   *\n   * @return {string}\n   *         The localized string or if no localization exists the english string.\n   */\n\n\n  Component.prototype.localize = function localize(string, tokens) {\n    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : string;\n\n    var code = this.player_.language && this.player_.language();\n    var languages = this.player_.languages && this.player_.languages();\n    var language = languages && languages[code];\n    var primaryCode = code && code.split('-')[0];\n    var primaryLang = languages && languages[primaryCode];\n\n    var localizedString = defaultValue;\n\n    if (language && language[string]) {\n      localizedString = language[string];\n    } else if (primaryLang && primaryLang[string]) {\n      localizedString = primaryLang[string];\n    }\n\n    if (tokens) {\n      localizedString = localizedString.replace(/\\{(\\d+)\\}/g, function (match, index) {\n        var value = tokens[index - 1];\n        var ret = value;\n\n        if (typeof value === 'undefined') {\n          ret = match;\n        }\n\n        return ret;\n      });\n    }\n\n    return localizedString;\n  };\n\n  /**\n   * Return the `Component`s DOM element. This is where children get inserted.\n   * This will usually be the the same as the element returned in {@link Component#el}.\n   *\n   * @return {Element}\n   *         The content element for this `Component`.\n   */\n\n\n  Component.prototype.contentEl = function contentEl() {\n    return this.contentEl_ || this.el_;\n  };\n\n  /**\n   * Get this `Component`s ID\n   *\n   * @return {string}\n   *         The id of this `Component`\n   */\n\n\n  Component.prototype.id = function id() {\n    return this.id_;\n  };\n\n  /**\n   * Get the `Component`s name. The name gets used to reference the `Component`\n   * and is set during registration.\n   *\n   * @return {string}\n   *         The name of this `Component`.\n   */\n\n\n  Component.prototype.name = function name() {\n    return this.name_;\n  };\n\n  /**\n   * Get an array of all child components\n   *\n   * @return {Array}\n   *         The children\n   */\n\n\n  Component.prototype.children = function children() {\n    return this.children_;\n  };\n\n  /**\n   * Returns the child `Component` with the given `id`.\n   *\n   * @param {string} id\n   *        The id of the child `Component` to get.\n   *\n   * @return {Component|undefined}\n   *         The child `Component` with the given `id` or undefined.\n   */\n\n\n  Component.prototype.getChildById = function getChildById(id) {\n    return this.childIndex_[id];\n  };\n\n  /**\n   * Returns the child `Component` with the given `name`.\n   *\n   * @param {string} name\n   *        The name of the child `Component` to get.\n   *\n   * @return {Component|undefined}\n   *         The child `Component` with the given `name` or undefined.\n   */\n\n\n  Component.prototype.getChild = function getChild(name) {\n    if (!name) {\n      return;\n    }\n\n    name = toTitleCase(name);\n\n    return this.childNameIndex_[name];\n  };\n\n  /**\n   * Add a child `Component` inside the current `Component`.\n   *\n   *\n   * @param {string|Component} child\n   *        The name or instance of a child to add.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of options that will get passed to children of\n   *        the child.\n   *\n   * @param {number} [index=this.children_.length]\n   *        The index to attempt to add a child into.\n   *\n   * @return {Component}\n   *         The `Component` that gets added as a child. When using a string the\n   *         `Component` will get created by this process.\n   */\n\n\n  Component.prototype.addChild = function addChild(child) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.children_.length;\n\n    var component = void 0;\n    var componentName = void 0;\n\n    // If child is a string, create component with options\n    if (typeof child === 'string') {\n      componentName = toTitleCase(child);\n\n      var componentClassName = options.componentClass || componentName;\n\n      // Set name through options\n      options.name = componentName;\n\n      // Create a new object & element for this controls set\n      // If there's no .player_, this is a player\n      var ComponentClass = Component.getComponent(componentClassName);\n\n      if (!ComponentClass) {\n        throw new Error('Component ' + componentClassName + ' does not exist');\n      }\n\n      // data stored directly on the videojs object may be\n      // misidentified as a component to retain\n      // backwards-compatibility with 4.x. check to make sure the\n      // component class can be instantiated.\n      if (typeof ComponentClass !== 'function') {\n        return null;\n      }\n\n      component = new ComponentClass(this.player_ || this, options);\n\n      // child is a component instance\n    } else {\n      component = child;\n    }\n\n    this.children_.splice(index, 0, component);\n\n    if (typeof component.id === 'function') {\n      this.childIndex_[component.id()] = component;\n    }\n\n    // If a name wasn't used to create the component, check if we can use the\n    // name function of the component\n    componentName = componentName || component.name && toTitleCase(component.name());\n\n    if (componentName) {\n      this.childNameIndex_[componentName] = component;\n    }\n\n    // Add the UI object's element to the container div (box)\n    // Having an element is not required\n    if (typeof component.el === 'function' && component.el()) {\n      var childNodes = this.contentEl().children;\n      var refNode = childNodes[index] || null;\n\n      this.contentEl().insertBefore(component.el(), refNode);\n    }\n\n    // Return so it can stored on parent object if desired.\n    return component;\n  };\n\n  /**\n   * Remove a child `Component` from this `Component`s list of children. Also removes\n   * the child `Component`s element from this `Component`s element.\n   *\n   * @param {Component} component\n   *        The child `Component` to remove.\n   */\n\n\n  Component.prototype.removeChild = function removeChild(component) {\n    if (typeof component === 'string') {\n      component = this.getChild(component);\n    }\n\n    if (!component || !this.children_) {\n      return;\n    }\n\n    var childFound = false;\n\n    for (var i = this.children_.length - 1; i >= 0; i--) {\n      if (this.children_[i] === component) {\n        childFound = true;\n        this.children_.splice(i, 1);\n        break;\n      }\n    }\n\n    if (!childFound) {\n      return;\n    }\n\n    this.childIndex_[component.id()] = null;\n    this.childNameIndex_[component.name()] = null;\n\n    var compEl = component.el();\n\n    if (compEl && compEl.parentNode === this.contentEl()) {\n      this.contentEl().removeChild(component.el());\n    }\n  };\n\n  /**\n   * Add and initialize default child `Component`s based upon options.\n   */\n\n\n  Component.prototype.initChildren = function initChildren() {\n    var _this = this;\n\n    var children = this.options_.children;\n\n    if (children) {\n      // `this` is `parent`\n      var parentOptions = this.options_;\n\n      var handleAdd = function handleAdd(child) {\n        var name = child.name;\n        var opts = child.opts;\n\n        // Allow options for children to be set at the parent options\n        // e.g. videojs(id, { controlBar: false });\n        // instead of videojs(id, { children: { controlBar: false });\n        if (parentOptions[name] !== undefined) {\n          opts = parentOptions[name];\n        }\n\n        // Allow for disabling default components\n        // e.g. options['children']['posterImage'] = false\n        if (opts === false) {\n          return;\n        }\n\n        // Allow options to be passed as a simple boolean if no configuration\n        // is necessary.\n        if (opts === true) {\n          opts = {};\n        }\n\n        // We also want to pass the original player options\n        // to each component as well so they don't need to\n        // reach back into the player for options later.\n        opts.playerOptions = _this.options_.playerOptions;\n\n        // Create and add the child component.\n        // Add a direct reference to the child by name on the parent instance.\n        // If two of the same component are used, different names should be supplied\n        // for each\n        var newChild = _this.addChild(name, opts);\n\n        if (newChild) {\n          _this[name] = newChild;\n        }\n      };\n\n      // Allow for an array of children details to passed in the options\n      var workingChildren = void 0;\n      var Tech = Component.getComponent('Tech');\n\n      if (Array.isArray(children)) {\n        workingChildren = children;\n      } else {\n        workingChildren = Object.keys(children);\n      }\n\n      workingChildren\n      // children that are in this.options_ but also in workingChildren  would\n      // give us extra children we do not want. So, we want to filter them out.\n      .concat(Object.keys(this.options_).filter(function (child) {\n        return !workingChildren.some(function (wchild) {\n          if (typeof wchild === 'string') {\n            return child === wchild;\n          }\n          return child === wchild.name;\n        });\n      })).map(function (child) {\n        var name = void 0;\n        var opts = void 0;\n\n        if (typeof child === 'string') {\n          name = child;\n          opts = children[name] || _this.options_[name] || {};\n        } else {\n          name = child.name;\n          opts = child;\n        }\n\n        return { name: name, opts: opts };\n      }).filter(function (child) {\n        // we have to make sure that child.name isn't in the techOrder since\n        // techs are registerd as Components but can't aren't compatible\n        // See https://github.com/videojs/video.js/issues/2772\n        var c = Component.getComponent(child.opts.componentClass || toTitleCase(child.name));\n\n        return c && !Tech.isTech(c);\n      }).forEach(handleAdd);\n    }\n  };\n\n  /**\n   * Builds the default DOM class name. Should be overriden by sub-components.\n   *\n   * @return {string}\n   *         The DOM class name for this object.\n   *\n   * @abstract\n   */\n\n\n  Component.prototype.buildCSSClass = function buildCSSClass() {\n    // Child classes can include a function that does:\n    // return 'CLASS NAME' + this._super();\n    return '';\n  };\n\n  /**\n   * Bind a listener to the component's ready state.\n   * Different from event listeners in that if the ready event has already happened\n   * it will trigger the function immediately.\n   *\n   * @return {Component}\n   *         Returns itself; method can be chained.\n   */\n\n\n  Component.prototype.ready = function ready(fn) {\n    var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!fn) {\n      return;\n    }\n\n    if (!this.isReady_) {\n      this.readyQueue_ = this.readyQueue_ || [];\n      this.readyQueue_.push(fn);\n      return;\n    }\n\n    if (sync) {\n      fn.call(this);\n    } else {\n      // Call the function asynchronously by default for consistency\n      this.setTimeout(fn, 1);\n    }\n  };\n\n  /**\n   * Trigger all the ready listeners for this `Component`.\n   *\n   * @fires Component#ready\n   */\n\n\n  Component.prototype.triggerReady = function triggerReady() {\n    this.isReady_ = true;\n\n    // Ensure ready is triggered asynchronously\n    this.setTimeout(function () {\n      var readyQueue = this.readyQueue_;\n\n      // Reset Ready Queue\n      this.readyQueue_ = [];\n\n      if (readyQueue && readyQueue.length > 0) {\n        readyQueue.forEach(function (fn) {\n          fn.call(this);\n        }, this);\n      }\n\n      // Allow for using event listeners also\n      /**\n       * Triggered when a `Component` is ready.\n       *\n       * @event Component#ready\n       * @type {EventTarget~Event}\n       */\n      this.trigger('ready');\n    }, 1);\n  };\n\n  /**\n   * Find a single DOM element matching a `selector`. This can be within the `Component`s\n   * `contentEl()` or another custom context.\n   *\n   * @param {string} selector\n   *        A valid CSS selector, which will be passed to `querySelector`.\n   *\n   * @param {Element|string} [context=this.contentEl()]\n   *        A DOM element within which to query. Can also be a selector string in\n   *        which case the first matching element will get used as context. If\n   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n   *        nothing it falls back to `document`.\n   *\n   * @return {Element|null}\n   *         the dom element that was found, or null\n   *\n   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n   */\n\n\n  Component.prototype.$ = function $$$1(selector, context) {\n    return $(selector, context || this.contentEl());\n  };\n\n  /**\n   * Finds all DOM element matching a `selector`. This can be within the `Component`s\n   * `contentEl()` or another custom context.\n   *\n   * @param {string} selector\n   *        A valid CSS selector, which will be passed to `querySelectorAll`.\n   *\n   * @param {Element|string} [context=this.contentEl()]\n   *        A DOM element within which to query. Can also be a selector string in\n   *        which case the first matching element will get used as context. If\n   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n   *        nothing it falls back to `document`.\n   *\n   * @return {NodeList}\n   *         a list of dom elements that were found\n   *\n   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n   */\n\n\n  Component.prototype.$$ = function $$$$1(selector, context) {\n    return $$(selector, context || this.contentEl());\n  };\n\n  /**\n   * Check if a component's element has a CSS class name.\n   *\n   * @param {string} classToCheck\n   *        CSS class name to check.\n   *\n   * @return {boolean}\n   *         - True if the `Component` has the class.\n   *         - False if the `Component` does not have the class`\n   */\n\n\n  Component.prototype.hasClass = function hasClass$$1(classToCheck) {\n    return hasClass(this.el_, classToCheck);\n  };\n\n  /**\n   * Add a CSS class name to the `Component`s element.\n   *\n   * @param {string} classToAdd\n   *        CSS class name to add\n   */\n\n\n  Component.prototype.addClass = function addClass$$1(classToAdd) {\n    addClass(this.el_, classToAdd);\n  };\n\n  /**\n   * Remove a CSS class name from the `Component`s element.\n   *\n   * @param {string} classToRemove\n   *        CSS class name to remove\n   */\n\n\n  Component.prototype.removeClass = function removeClass$$1(classToRemove) {\n    removeClass(this.el_, classToRemove);\n  };\n\n  /**\n   * Add or remove a CSS class name from the component's element.\n   * - `classToToggle` gets added when {@link Component#hasClass} would return false.\n   * - `classToToggle` gets removed when {@link Component#hasClass} would return true.\n   *\n   * @param  {string} classToToggle\n   *         The class to add or remove based on (@link Component#hasClass}\n   *\n   * @param  {boolean|Dom~predicate} [predicate]\n   *         An {@link Dom~predicate} function or a boolean\n   */\n\n\n  Component.prototype.toggleClass = function toggleClass$$1(classToToggle, predicate) {\n    toggleClass(this.el_, classToToggle, predicate);\n  };\n\n  /**\n   * Show the `Component`s element if it is hidden by removing the\n   * 'vjs-hidden' class name from it.\n   */\n\n\n  Component.prototype.show = function show() {\n    this.removeClass('vjs-hidden');\n  };\n\n  /**\n   * Hide the `Component`s element if it is currently showing by adding the\n   * 'vjs-hidden` class name to it.\n   */\n\n\n  Component.prototype.hide = function hide() {\n    this.addClass('vjs-hidden');\n  };\n\n  /**\n   * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'\n   * class name to it. Used during fadeIn/fadeOut.\n   *\n   * @private\n   */\n\n\n  Component.prototype.lockShowing = function lockShowing() {\n    this.addClass('vjs-lock-showing');\n  };\n\n  /**\n   * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'\n   * class name from it. Used during fadeIn/fadeOut.\n   *\n   * @private\n   */\n\n\n  Component.prototype.unlockShowing = function unlockShowing() {\n    this.removeClass('vjs-lock-showing');\n  };\n\n  /**\n   * Get the value of an attribute on the `Component`s element.\n   *\n   * @param {string} attribute\n   *        Name of the attribute to get the value from.\n   *\n   * @return {string|null}\n   *         - The value of the attribute that was asked for.\n   *         - Can be an empty string on some browsers if the attribute does not exist\n   *           or has no value\n   *         - Most browsers will return null if the attibute does not exist or has\n   *           no value.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}\n   */\n\n\n  Component.prototype.getAttribute = function getAttribute$$1(attribute) {\n    return getAttribute(this.el_, attribute);\n  };\n\n  /**\n   * Set the value of an attribute on the `Component`'s element\n   *\n   * @param {string} attribute\n   *        Name of the attribute to set.\n   *\n   * @param {string} value\n   *        Value to set the attribute to.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}\n   */\n\n\n  Component.prototype.setAttribute = function setAttribute$$1(attribute, value) {\n    setAttribute(this.el_, attribute, value);\n  };\n\n  /**\n   * Remove an attribute from the `Component`s element.\n   *\n   * @param {string} attribute\n   *        Name of the attribute to remove.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}\n   */\n\n\n  Component.prototype.removeAttribute = function removeAttribute$$1(attribute) {\n    removeAttribute(this.el_, attribute);\n  };\n\n  /**\n   * Get or set the width of the component based upon the CSS styles.\n   * See {@link Component#dimension} for more detailed information.\n   *\n   * @param {number|string} [num]\n   *        The width that you want to set postfixed with '%', 'px' or nothing.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the componentresize event trigger\n   *\n   * @return {number|string}\n   *         The width when getting, zero if there is no width. Can be a string\n   *           postpixed with '%' or 'px'.\n   */\n\n\n  Component.prototype.width = function width(num, skipListeners) {\n    return this.dimension('width', num, skipListeners);\n  };\n\n  /**\n   * Get or set the height of the component based upon the CSS styles.\n   * See {@link Component#dimension} for more detailed information.\n   *\n   * @param {number|string} [num]\n   *        The height that you want to set postfixed with '%', 'px' or nothing.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the componentresize event trigger\n   *\n   * @return {number|string}\n   *         The width when getting, zero if there is no width. Can be a string\n   *         postpixed with '%' or 'px'.\n   */\n\n\n  Component.prototype.height = function height(num, skipListeners) {\n    return this.dimension('height', num, skipListeners);\n  };\n\n  /**\n   * Set both the width and height of the `Component` element at the same time.\n   *\n   * @param  {number|string} width\n   *         Width to set the `Component`s element to.\n   *\n   * @param  {number|string} height\n   *         Height to set the `Component`s element to.\n   */\n\n\n  Component.prototype.dimensions = function dimensions(width, height) {\n    // Skip componentresize listeners on width for optimization\n    this.width(width, true);\n    this.height(height);\n  };\n\n  /**\n   * Get or set width or height of the `Component` element. This is the shared code\n   * for the {@link Component#width} and {@link Component#height}.\n   *\n   * Things to know:\n   * - If the width or height in an number this will return the number postfixed with 'px'.\n   * - If the width/height is a percent this will return the percent postfixed with '%'\n   * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function\n   *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.\n   *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}\n   *   for more information\n   * - If you want the computed style of the component, use {@link Component#currentWidth}\n   *   and {@link {Component#currentHeight}\n   *\n   * @fires Component#componentresize\n   *\n   * @param {string} widthOrHeight\n   8        'width' or 'height'\n   *\n   * @param  {number|string} [num]\n   8         New dimension\n   *\n   * @param  {boolean} [skipListeners]\n   *         Skip componentresize event trigger\n   *\n   * @return {number}\n   *         The dimension when getting or 0 if unset\n   */\n\n\n  Component.prototype.dimension = function dimension(widthOrHeight, num, skipListeners) {\n    if (num !== undefined) {\n      // Set to zero if null or literally NaN (NaN !== NaN)\n      if (num === null || num !== num) {\n        num = 0;\n      }\n\n      // Check if using css width/height (% or px) and adjust\n      if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {\n        this.el_.style[widthOrHeight] = num;\n      } else if (num === 'auto') {\n        this.el_.style[widthOrHeight] = '';\n      } else {\n        this.el_.style[widthOrHeight] = num + 'px';\n      }\n\n      // skipListeners allows us to avoid triggering the resize event when setting both width and height\n      if (!skipListeners) {\n        /**\n         * Triggered when a component is resized.\n         *\n         * @event Component#componentresize\n         * @type {EventTarget~Event}\n         */\n        this.trigger('componentresize');\n      }\n\n      return;\n    }\n\n    // Not setting a value, so getting it\n    // Make sure element exists\n    if (!this.el_) {\n      return 0;\n    }\n\n    // Get dimension value from style\n    var val = this.el_.style[widthOrHeight];\n    var pxIndex = val.indexOf('px');\n\n    if (pxIndex !== -1) {\n      // Return the pixel value with no 'px'\n      return parseInt(val.slice(0, pxIndex), 10);\n    }\n\n    // No px so using % or no style was set, so falling back to offsetWidth/height\n    // If component has display:none, offset will return 0\n    // TODO: handle display:none and no dimension style using px\n    return parseInt(this.el_['offset' + toTitleCase(widthOrHeight)], 10);\n  };\n\n  /**\n   * Get the width or the height of the `Component` elements computed style. Uses\n   * `window.getComputedStyle`.\n   *\n   * @param {string} widthOrHeight\n   *        A string containing 'width' or 'height'. Whichever one you want to get.\n   *\n   * @return {number}\n   *         The dimension that gets asked for or 0 if nothing was set\n   *         for that dimension.\n   */\n\n\n  Component.prototype.currentDimension = function currentDimension(widthOrHeight) {\n    var computedWidthOrHeight = 0;\n\n    if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {\n      throw new Error('currentDimension only accepts width or height value');\n    }\n\n    if (typeof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.getComputedStyle === 'function') {\n      var computedStyle = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.getComputedStyle(this.el_);\n\n      computedWidthOrHeight = computedStyle.getPropertyValue(widthOrHeight) || computedStyle[widthOrHeight];\n    }\n\n    // remove 'px' from variable and parse as integer\n    computedWidthOrHeight = parseFloat(computedWidthOrHeight);\n\n    // if the computed value is still 0, it's possible that the browser is lying\n    // and we want to check the offset values.\n    // This code also runs wherever getComputedStyle doesn't exist.\n    if (computedWidthOrHeight === 0) {\n      var rule = 'offset' + toTitleCase(widthOrHeight);\n\n      computedWidthOrHeight = this.el_[rule];\n    }\n\n    return computedWidthOrHeight;\n  };\n\n  /**\n   * An object that contains width and height values of the `Component`s\n   * computed style. Uses `window.getComputedStyle`.\n   *\n   * @typedef {Object} Component~DimensionObject\n   *\n   * @property {number} width\n   *           The width of the `Component`s computed style.\n   *\n   * @property {number} height\n   *           The height of the `Component`s computed style.\n   */\n\n  /**\n   * Get an object that contains width and height values of the `Component`s\n   * computed style.\n   *\n   * @return {Component~DimensionObject}\n   *         The dimensions of the components element\n   */\n\n\n  Component.prototype.currentDimensions = function currentDimensions() {\n    return {\n      width: this.currentDimension('width'),\n      height: this.currentDimension('height')\n    };\n  };\n\n  /**\n   * Get the width of the `Component`s computed style. Uses `window.getComputedStyle`.\n   *\n   * @return {number} width\n   *           The width of the `Component`s computed style.\n   */\n\n\n  Component.prototype.currentWidth = function currentWidth() {\n    return this.currentDimension('width');\n  };\n\n  /**\n   * Get the height of the `Component`s computed style. Uses `window.getComputedStyle`.\n   *\n   * @return {number} height\n   *           The height of the `Component`s computed style.\n   */\n\n\n  Component.prototype.currentHeight = function currentHeight() {\n    return this.currentDimension('height');\n  };\n\n  /**\n   * Set the focus to this component\n   */\n\n\n  Component.prototype.focus = function focus() {\n    this.el_.focus();\n  };\n\n  /**\n   * Remove the focus from this component\n   */\n\n\n  Component.prototype.blur = function blur() {\n    this.el_.blur();\n  };\n\n  /**\n   * Emit a 'tap' events when touch event support gets detected. This gets used to\n   * support toggling the controls through a tap on the video. They get enabled\n   * because every sub-component would have extra overhead otherwise.\n   *\n   * @private\n   * @fires Component#tap\n   * @listens Component#touchstart\n   * @listens Component#touchmove\n   * @listens Component#touchleave\n   * @listens Component#touchcancel\n   * @listens Component#touchend\n    */\n\n\n  Component.prototype.emitTapEvents = function emitTapEvents() {\n    // Track the start time so we can determine how long the touch lasted\n    var touchStart = 0;\n    var firstTouch = null;\n\n    // Maximum movement allowed during a touch event to still be considered a tap\n    // Other popular libs use anywhere from 2 (hammer.js) to 15,\n    // so 10 seems like a nice, round number.\n    var tapMovementThreshold = 10;\n\n    // The maximum length a touch can be while still being considered a tap\n    var touchTimeThreshold = 200;\n\n    var couldBeTap = void 0;\n\n    this.on('touchstart', function (event) {\n      // If more than one finger, don't consider treating this as a click\n      if (event.touches.length === 1) {\n        // Copy pageX/pageY from the object\n        firstTouch = {\n          pageX: event.touches[0].pageX,\n          pageY: event.touches[0].pageY\n        };\n        // Record start time so we can detect a tap vs. \"touch and hold\"\n        touchStart = new Date().getTime();\n        // Reset couldBeTap tracking\n        couldBeTap = true;\n      }\n    });\n\n    this.on('touchmove', function (event) {\n      // If more than one finger, don't consider treating this as a click\n      if (event.touches.length > 1) {\n        couldBeTap = false;\n      } else if (firstTouch) {\n        // Some devices will throw touchmoves for all but the slightest of taps.\n        // So, if we moved only a small distance, this could still be a tap\n        var xdiff = event.touches[0].pageX - firstTouch.pageX;\n        var ydiff = event.touches[0].pageY - firstTouch.pageY;\n        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n\n        if (touchDistance > tapMovementThreshold) {\n          couldBeTap = false;\n        }\n      }\n    });\n\n    var noTap = function noTap() {\n      couldBeTap = false;\n    };\n\n    // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s\n    this.on('touchleave', noTap);\n    this.on('touchcancel', noTap);\n\n    // When the touch ends, measure how long it took and trigger the appropriate\n    // event\n    this.on('touchend', function (event) {\n      firstTouch = null;\n      // Proceed only if the touchmove/leave/cancel event didn't happen\n      if (couldBeTap === true) {\n        // Measure how long the touch lasted\n        var touchTime = new Date().getTime() - touchStart;\n\n        // Make sure the touch was less than the threshold to be considered a tap\n        if (touchTime < touchTimeThreshold) {\n          // Don't let browser turn this into a click\n          event.preventDefault();\n          /**\n           * Triggered when a `Component` is tapped.\n           *\n           * @event Component#tap\n           * @type {EventTarget~Event}\n           */\n          this.trigger('tap');\n          // It may be good to copy the touchend event object and change the\n          // type to tap, if the other event properties aren't exact after\n          // Events.fixEvent runs (e.g. event.target)\n        }\n      }\n    });\n  };\n\n  /**\n   * This function reports user activity whenever touch events happen. This can get\n   * turned off by any sub-components that wants touch events to act another way.\n   *\n   * Report user touch activity when touch events occur. User activity gets used to\n   * determine when controls should show/hide. It is simple when it comes to mouse\n   * events, because any mouse event should show the controls. So we capture mouse\n   * events that bubble up to the player and report activity when that happens.\n   * With touch events it isn't as easy as `touchstart` and `touchend` toggle player\n   * controls. So touch events can't help us at the player level either.\n   *\n   * User activity gets checked asynchronously. So what could happen is a tap event\n   * on the video turns the controls off. Then the `touchend` event bubbles up to\n   * the player. Which, if it reported user activity, would turn the controls right\n   * back on. We also don't want to completely block touch events from bubbling up.\n   * Furthermore a `touchmove` event and anything other than a tap, should not turn\n   * controls back on.\n   *\n   * @listens Component#touchstart\n   * @listens Component#touchmove\n   * @listens Component#touchend\n   * @listens Component#touchcancel\n   */\n\n\n  Component.prototype.enableTouchActivity = function enableTouchActivity() {\n    // Don't continue if the root player doesn't support reporting user activity\n    if (!this.player() || !this.player().reportUserActivity) {\n      return;\n    }\n\n    // listener for reporting that the user is active\n    var report = bind(this.player(), this.player().reportUserActivity);\n\n    var touchHolding = void 0;\n\n    this.on('touchstart', function () {\n      report();\n      // For as long as the they are touching the device or have their mouse down,\n      // we consider them active even if they're not moving their finger or mouse.\n      // So we want to continue to update that they are active\n      this.clearInterval(touchHolding);\n      // report at the same interval as activityCheck\n      touchHolding = this.setInterval(report, 250);\n    });\n\n    var touchEnd = function touchEnd(event) {\n      report();\n      // stop the interval that maintains activity if the touch is holding\n      this.clearInterval(touchHolding);\n    };\n\n    this.on('touchmove', report);\n    this.on('touchend', touchEnd);\n    this.on('touchcancel', touchEnd);\n  };\n\n  /**\n   * A callback that has no parameters and is bound into `Component`s context.\n   *\n   * @callback Component~GenericCallback\n   * @this Component\n   */\n\n  /**\n   * Creates a function that runs after an `x` millisecond timeout. This function is a\n   * wrapper around `window.setTimeout`. There are a few reasons to use this one\n   * instead though:\n   * 1. It gets cleared via  {@link Component#clearTimeout} when\n   *    {@link Component#dispose} gets called.\n   * 2. The function callback will gets turned into a {@link Component~GenericCallback}\n   *\n   * > Note: You can't use `window.clearTimeout` on the id returned by this function. This\n   *         will cause its dispose listener not to get cleaned up! Please use\n   *         {@link Component#clearTimeout} or {@link Component#dispose} instead.\n   *\n   * @param {Component~GenericCallback} fn\n   *        The function that will be run after `timeout`.\n   *\n   * @param {number} timeout\n   *        Timeout in milliseconds to delay before executing the specified function.\n   *\n   * @return {number}\n   *         Returns a timeout ID that gets used to identify the timeout. It can also\n   *         get used in {@link Component#clearTimeout} to clear the timeout that\n   *         was set.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}\n   */\n\n\n  Component.prototype.setTimeout = function setTimeout(fn, timeout) {\n    var _this2 = this;\n\n    // declare as variables so they are properly available in timeout function\n    // eslint-disable-next-line\n    var timeoutId, disposeFn;\n\n    fn = bind(this, fn);\n\n    timeoutId = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.setTimeout(function () {\n      _this2.off('dispose', disposeFn);\n      fn();\n    }, timeout);\n\n    disposeFn = function disposeFn() {\n      return _this2.clearTimeout(timeoutId);\n    };\n\n    disposeFn.guid = 'vjs-timeout-' + timeoutId;\n\n    this.on('dispose', disposeFn);\n\n    return timeoutId;\n  };\n\n  /**\n   * Clears a timeout that gets created via `window.setTimeout` or\n   * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}\n   * use this function instead of `window.clearTimout`. If you don't your dispose\n   * listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} timeoutId\n   *        The id of the timeout to clear. The return value of\n   *        {@link Component#setTimeout} or `window.setTimeout`.\n   *\n   * @return {number}\n   *         Returns the timeout id that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}\n   */\n\n\n  Component.prototype.clearTimeout = function clearTimeout(timeoutId) {\n    global_window__WEBPACK_IMPORTED_MODULE_0___default.a.clearTimeout(timeoutId);\n\n    var disposeFn = function disposeFn() {};\n\n    disposeFn.guid = 'vjs-timeout-' + timeoutId;\n\n    this.off('dispose', disposeFn);\n\n    return timeoutId;\n  };\n\n  /**\n   * Creates a function that gets run every `x` milliseconds. This function is a wrapper\n   * around `window.setInterval`. There are a few reasons to use this one instead though.\n   * 1. It gets cleared via  {@link Component#clearInterval} when\n   *    {@link Component#dispose} gets called.\n   * 2. The function callback will be a {@link Component~GenericCallback}\n   *\n   * @param {Component~GenericCallback} fn\n   *        The function to run every `x` seconds.\n   *\n   * @param {number} interval\n   *        Execute the specified function every `x` milliseconds.\n   *\n   * @return {number}\n   *         Returns an id that can be used to identify the interval. It can also be be used in\n   *         {@link Component#clearInterval} to clear the interval.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}\n   */\n\n\n  Component.prototype.setInterval = function setInterval(fn, interval) {\n    var _this3 = this;\n\n    fn = bind(this, fn);\n\n    var intervalId = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.setInterval(fn, interval);\n\n    var disposeFn = function disposeFn() {\n      return _this3.clearInterval(intervalId);\n    };\n\n    disposeFn.guid = 'vjs-interval-' + intervalId;\n\n    this.on('dispose', disposeFn);\n\n    return intervalId;\n  };\n\n  /**\n   * Clears an interval that gets created via `window.setInterval` or\n   * {@link Component#setInterval}. If you set an inteval via {@link Component#setInterval}\n   * use this function instead of `window.clearInterval`. If you don't your dispose\n   * listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} intervalId\n   *        The id of the interval to clear. The return value of\n   *        {@link Component#setInterval} or `window.setInterval`.\n   *\n   * @return {number}\n   *         Returns the interval id that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}\n   */\n\n\n  Component.prototype.clearInterval = function clearInterval(intervalId) {\n    global_window__WEBPACK_IMPORTED_MODULE_0___default.a.clearInterval(intervalId);\n\n    var disposeFn = function disposeFn() {};\n\n    disposeFn.guid = 'vjs-interval-' + intervalId;\n\n    this.off('dispose', disposeFn);\n\n    return intervalId;\n  };\n\n  /**\n   * Queues up a callback to be passed to requestAnimationFrame (rAF), but\n   * with a few extra bonuses:\n   *\n   * - Supports browsers that do not support rAF by falling back to\n   *   {@link Component#setTimeout}.\n   *\n   * - The callback is turned into a {@link Component~GenericCallback} (i.e.\n   *   bound to the component).\n   *\n   * - Automatic cancellation of the rAF callback is handled if the component\n   *   is disposed before it is called.\n   *\n   * @param  {Component~GenericCallback} fn\n   *         A function that will be bound to this component and executed just\n   *         before the browser's next repaint.\n   *\n   * @return {number}\n   *         Returns an rAF ID that gets used to identify the timeout. It can\n   *         also be used in {@link Component#cancelAnimationFrame} to cancel\n   *         the animation frame callback.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}\n   */\n\n\n  Component.prototype.requestAnimationFrame = function requestAnimationFrame(fn) {\n    var _this4 = this;\n\n    // declare as variables so they are properly available in rAF function\n    // eslint-disable-next-line\n    var id, disposeFn;\n\n    if (this.supportsRaf_) {\n      fn = bind(this, fn);\n\n      id = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.requestAnimationFrame(function () {\n        _this4.off('dispose', disposeFn);\n        fn();\n      });\n\n      disposeFn = function disposeFn() {\n        return _this4.cancelAnimationFrame(id);\n      };\n\n      disposeFn.guid = 'vjs-raf-' + id;\n      this.on('dispose', disposeFn);\n\n      return id;\n    }\n\n    // Fall back to using a timer.\n    return this.setTimeout(fn, 1000 / 60);\n  };\n\n  /**\n   * Cancels a queued callback passed to {@link Component#requestAnimationFrame}\n   * (rAF).\n   *\n   * If you queue an rAF callback via {@link Component#requestAnimationFrame},\n   * use this function instead of `window.cancelAnimationFrame`. If you don't,\n   * your dispose listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} id\n   *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.\n   *\n   * @return {number}\n   *         Returns the rAF ID that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}\n   */\n\n\n  Component.prototype.cancelAnimationFrame = function cancelAnimationFrame(id) {\n    if (this.supportsRaf_) {\n      global_window__WEBPACK_IMPORTED_MODULE_0___default.a.cancelAnimationFrame(id);\n\n      var disposeFn = function disposeFn() {};\n\n      disposeFn.guid = 'vjs-raf-' + id;\n\n      this.off('dispose', disposeFn);\n\n      return id;\n    }\n\n    // Fall back to using a timer.\n    return this.clearTimeout(id);\n  };\n\n  /**\n   * Register a `Component` with `videojs` given the name and the component.\n   *\n   * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s\n   *         should be registered using {@link Tech.registerTech} or\n   *         {@link videojs:videojs.registerTech}.\n   *\n   * > NOTE: This function can also be seen on videojs as\n   *         {@link videojs:videojs.registerComponent}.\n   *\n   * @param {string} name\n   *        The name of the `Component` to register.\n   *\n   * @param {Component} ComponentToRegister\n   *        The `Component` class to register.\n   *\n   * @return {Component}\n   *         The `Component` that was registered.\n   */\n\n\n  Component.registerComponent = function registerComponent(name, ComponentToRegister) {\n    if (typeof name !== 'string' || !name) {\n      throw new Error('Illegal component name, \"' + name + '\"; must be a non-empty string.');\n    }\n\n    var Tech = Component.getComponent('Tech');\n\n    // We need to make sure this check is only done if Tech has been registered.\n    var isTech = Tech && Tech.isTech(ComponentToRegister);\n    var isComp = Component === ComponentToRegister || Component.prototype.isPrototypeOf(ComponentToRegister.prototype);\n\n    if (isTech || !isComp) {\n      var reason = void 0;\n\n      if (isTech) {\n        reason = 'techs must be registered using Tech.registerTech()';\n      } else {\n        reason = 'must be a Component subclass';\n      }\n\n      throw new Error('Illegal component, \"' + name + '\"; ' + reason + '.');\n    }\n\n    name = toTitleCase(name);\n\n    if (!Component.components_) {\n      Component.components_ = {};\n    }\n\n    var Player = Component.getComponent('Player');\n\n    if (name === 'Player' && Player && Player.players) {\n      var players = Player.players;\n      var playerNames = Object.keys(players);\n\n      // If we have players that were disposed, then their name will still be\n      // in Players.players. So, we must loop through and verify that the value\n      // for each item is not null. This allows registration of the Player component\n      // after all players have been disposed or before any were created.\n      if (players && playerNames.length > 0 && playerNames.map(function (pname) {\n        return players[pname];\n      }).every(Boolean)) {\n        throw new Error('Can not register Player component after player has been created.');\n      }\n    }\n\n    Component.components_[name] = ComponentToRegister;\n\n    return ComponentToRegister;\n  };\n\n  /**\n   * Get a `Component` based on the name it was registered with.\n   *\n   * @param {string} name\n   *        The Name of the component to get.\n   *\n   * @return {Component}\n   *         The `Component` that got registered under the given name.\n   *\n   * @deprecated In `videojs` 6 this will not return `Component`s that were not\n   *             registered using {@link Component.registerComponent}. Currently we\n   *             check the global `videojs` object for a `Component` name and\n   *             return that if it exists.\n   */\n\n\n  Component.getComponent = function getComponent(name) {\n    if (!name) {\n      return;\n    }\n\n    name = toTitleCase(name);\n\n    if (Component.components_ && Component.components_[name]) {\n      return Component.components_[name];\n    }\n  };\n\n  return Component;\n}();\n\n/**\n * Whether or not this component supports `requestAnimationFrame`.\n *\n * This is exposed primarily for testing purposes.\n *\n * @private\n * @type {Boolean}\n */\n\n\nComponent.prototype.supportsRaf_ = typeof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.requestAnimationFrame === 'function' && typeof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.cancelAnimationFrame === 'function';\n\nComponent.registerComponent('Component', Component);\n\n/**\n * @file browser.js\n * @module browser\n */\n\nvar USER_AGENT = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.navigator && global_window__WEBPACK_IMPORTED_MODULE_0___default.a.navigator.userAgent || '';\nvar webkitVersionMap = /AppleWebKit\\/([\\d.]+)/i.exec(USER_AGENT);\nvar appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;\n\n/*\n * Device is an iPhone\n *\n * @type {Boolean}\n * @constant\n * @private\n */\nvar IS_IPAD = /iPad/i.test(USER_AGENT);\n\n// The Facebook app's UIWebView identifies as both an iPhone and iPad, so\n// to identify iPhones, we need to exclude iPads.\n// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/\nvar IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;\nvar IS_IPOD = /iPod/i.test(USER_AGENT);\nvar IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;\n\nvar IOS_VERSION = function () {\n  var match = USER_AGENT.match(/OS (\\d+)_/i);\n\n  if (match && match[1]) {\n    return match[1];\n  }\n  return null;\n}();\n\nvar IS_ANDROID = /Android/i.test(USER_AGENT);\nvar ANDROID_VERSION = function () {\n  // This matches Android Major.Minor.Patch versions\n  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned\n  var match = USER_AGENT.match(/Android (\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))*/i);\n\n  if (!match) {\n    return null;\n  }\n\n  var major = match[1] && parseFloat(match[1]);\n  var minor = match[2] && parseFloat(match[2]);\n\n  if (major && minor) {\n    return parseFloat(match[1] + '.' + match[2]);\n  } else if (major) {\n    return major;\n  }\n  return null;\n}();\n\nvar IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;\n\nvar IS_FIREFOX = /Firefox/i.test(USER_AGENT);\nvar IS_EDGE = /Edge/i.test(USER_AGENT);\nvar IS_CHROME = !IS_EDGE && (/Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT));\nvar CHROME_VERSION = function () {\n  var match = USER_AGENT.match(/(Chrome|CriOS)\\/(\\d+)/);\n\n  if (match && match[2]) {\n    return parseFloat(match[2]);\n  }\n  return null;\n}();\nvar IE_VERSION = function () {\n  var result = /MSIE\\s(\\d+)\\.\\d/.exec(USER_AGENT);\n  var version = result && parseFloat(result[1]);\n\n  if (!version && /Trident\\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {\n    // IE 11 has a different user agent string than other IE versions\n    version = 11.0;\n  }\n\n  return version;\n}();\n\nvar IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;\nvar IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;\n\nvar TOUCH_ENABLED = isReal() && ('ontouchstart' in global_window__WEBPACK_IMPORTED_MODULE_0___default.a || global_window__WEBPACK_IMPORTED_MODULE_0___default.a.navigator.maxTouchPoints || global_window__WEBPACK_IMPORTED_MODULE_0___default.a.DocumentTouch && global_window__WEBPACK_IMPORTED_MODULE_0___default.a.document instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.DocumentTouch);\n\nvar browser = /*#__PURE__*/Object.freeze({\n  IS_IPAD: IS_IPAD,\n  IS_IPHONE: IS_IPHONE,\n  IS_IPOD: IS_IPOD,\n  IS_IOS: IS_IOS,\n  IOS_VERSION: IOS_VERSION,\n  IS_ANDROID: IS_ANDROID,\n  ANDROID_VERSION: ANDROID_VERSION,\n  IS_NATIVE_ANDROID: IS_NATIVE_ANDROID,\n  IS_FIREFOX: IS_FIREFOX,\n  IS_EDGE: IS_EDGE,\n  IS_CHROME: IS_CHROME,\n  CHROME_VERSION: CHROME_VERSION,\n  IE_VERSION: IE_VERSION,\n  IS_SAFARI: IS_SAFARI,\n  IS_ANY_SAFARI: IS_ANY_SAFARI,\n  TOUCH_ENABLED: TOUCH_ENABLED\n});\n\n/**\n * @file time-ranges.js\n * @module time-ranges\n */\n\n/**\n * Returns the time for the specified index at the start or end\n * of a TimeRange object.\n *\n * @function time-ranges:indexFunction\n *\n * @param {number} [index=0]\n *        The range number to return the time for.\n *\n * @return {number}\n *         The time that offset at the specified index.\n *\n * @depricated index must be set to a value, in the future this will throw an error.\n */\n\n/**\n * An object that contains ranges of time for various reasons.\n *\n * @typedef {Object} TimeRange\n *\n * @property {number} length\n *           The number of time ranges represented by this Object\n *\n * @property {time-ranges:indexFunction} start\n *           Returns the time offset at which a specified time range begins.\n *\n * @property {time-ranges:indexFunction} end\n *           Returns the time offset at which a specified time range ends.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges\n */\n\n/**\n * Check if any of the time ranges are over the maximum index.\n *\n * @param {string} fnName\n *        The function name to use for logging\n *\n * @param {number} index\n *        The index to check\n *\n * @param {number} maxIndex\n *        The maximum possible index\n *\n * @throws {Error} if the timeRanges provided are over the maxIndex\n */\nfunction rangeCheck(fnName, index, maxIndex) {\n  if (typeof index !== 'number' || index < 0 || index > maxIndex) {\n    throw new Error('Failed to execute \\'' + fnName + '\\' on \\'TimeRanges\\': The index provided (' + index + ') is non-numeric or out of bounds (0-' + maxIndex + ').');\n  }\n}\n\n/**\n * Get the time for the specified index at the start or end\n * of a TimeRange object.\n *\n * @param {string} fnName\n *        The function name to use for logging\n *\n * @param {string} valueIndex\n *        The property that should be used to get the time. should be 'start' or 'end'\n *\n * @param {Array} ranges\n *        An array of time ranges\n *\n * @param {Array} [rangeIndex=0]\n *        The index to start the search at\n *\n * @return {number}\n *         The time that offset at the specified index.\n *\n *\n * @depricated rangeIndex must be set to a value, in the future this will throw an error.\n * @throws {Error} if rangeIndex is more than the length of ranges\n */\nfunction getRange(fnName, valueIndex, ranges, rangeIndex) {\n  rangeCheck(fnName, rangeIndex, ranges.length - 1);\n  return ranges[rangeIndex][valueIndex];\n}\n\n/**\n * Create a time range object given ranges of time.\n *\n * @param {Array} [ranges]\n *        An array of time ranges.\n */\nfunction createTimeRangesObj(ranges) {\n  if (ranges === undefined || ranges.length === 0) {\n    return {\n      length: 0,\n      start: function start() {\n        throw new Error('This TimeRanges object is empty');\n      },\n      end: function end() {\n        throw new Error('This TimeRanges object is empty');\n      }\n    };\n  }\n  return {\n    length: ranges.length,\n    start: getRange.bind(null, 'start', 0, ranges),\n    end: getRange.bind(null, 'end', 1, ranges)\n  };\n}\n\n/**\n * Should create a fake `TimeRange` object which mimics an HTML5 time range instance.\n *\n * @param {number|Array} start\n *        The start of a single range or an array of ranges\n *\n * @param {number} end\n *        The end of a single range.\n *\n * @private\n */\nfunction createTimeRanges(start, end) {\n  if (Array.isArray(start)) {\n    return createTimeRangesObj(start);\n  } else if (start === undefined || end === undefined) {\n    return createTimeRangesObj();\n  }\n  return createTimeRangesObj([[start, end]]);\n}\n\n/**\n * @file buffer.js\n * @module buffer\n */\n\n/**\n * Compute the percentage of the media that has been buffered.\n *\n * @param {TimeRange} buffered\n *        The current `TimeRange` object representing buffered time ranges\n *\n * @param {number} duration\n *        Total duration of the media\n *\n * @return {number}\n *         Percent buffered of the total duration in decimal form.\n */\nfunction bufferedPercent(buffered, duration) {\n  var bufferedDuration = 0;\n  var start = void 0;\n  var end = void 0;\n\n  if (!duration) {\n    return 0;\n  }\n\n  if (!buffered || !buffered.length) {\n    buffered = createTimeRanges(0, 0);\n  }\n\n  for (var i = 0; i < buffered.length; i++) {\n    start = buffered.start(i);\n    end = buffered.end(i);\n\n    // buffered end can be bigger than duration by a very small fraction\n    if (end > duration) {\n      end = duration;\n    }\n\n    bufferedDuration += end - start;\n  }\n\n  return bufferedDuration / duration;\n}\n\n/**\n * @file fullscreen-api.js\n * @module fullscreen-api\n * @private\n */\n\n/**\n * Store the browser-specific methods for the fullscreen API.\n *\n * @type {Object}\n * @see [Specification]{@link https://fullscreen.spec.whatwg.org}\n * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}\n */\nvar FullscreenApi = {};\n\n// browser API methods\nvar apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'],\n// WebKit\n['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],\n// Old WebKit (Safari 5.1)\n['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'],\n// Mozilla\n['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'],\n// Microsoft\n['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];\n\nvar specApi = apiMap[0];\nvar browserApi = void 0;\n\n// determine the supported set of functions\nfor (var i = 0; i < apiMap.length; i++) {\n  // check for exitFullscreen function\n  if (apiMap[i][1] in global_document__WEBPACK_IMPORTED_MODULE_1___default.a) {\n    browserApi = apiMap[i];\n    break;\n  }\n}\n\n// map the browser API names to the spec API names\nif (browserApi) {\n  for (var _i = 0; _i < browserApi.length; _i++) {\n    FullscreenApi[specApi[_i]] = browserApi[_i];\n  }\n}\n\n/**\n * @file media-error.js\n */\n\n/**\n * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.\n *\n * @param {number|string|Object|MediaError} value\n *        This can be of multiple types:\n *        - number: should be a standard error code\n *        - string: an error message (the code will be 0)\n *        - Object: arbitrary properties\n *        - `MediaError` (native): used to populate a video.js `MediaError` object\n *        - `MediaError` (video.js): will return itself if it's already a\n *          video.js `MediaError` object.\n *\n * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}\n * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}\n *\n * @class MediaError\n */\nfunction MediaError(value) {\n\n  // Allow redundant calls to this constructor to avoid having `instanceof`\n  // checks peppered around the code.\n  if (value instanceof MediaError) {\n    return value;\n  }\n\n  if (typeof value === 'number') {\n    this.code = value;\n  } else if (typeof value === 'string') {\n    // default code is zero, so this is a custom error\n    this.message = value;\n  } else if (isObject(value)) {\n\n    // We assign the `code` property manually because native `MediaError` objects\n    // do not expose it as an own/enumerable property of the object.\n    if (typeof value.code === 'number') {\n      this.code = value.code;\n    }\n\n    assign(this, value);\n  }\n\n  if (!this.message) {\n    this.message = MediaError.defaultMessages[this.code] || '';\n  }\n}\n\n/**\n * The error code that refers two one of the defined `MediaError` types\n *\n * @type {Number}\n */\nMediaError.prototype.code = 0;\n\n/**\n * An optional message that to show with the error. Message is not part of the HTML5\n * video spec but allows for more informative custom errors.\n *\n * @type {String}\n */\nMediaError.prototype.message = '';\n\n/**\n * An optional status code that can be set by plugins to allow even more detail about\n * the error. For example a plugin might provide a specific HTTP status code and an\n * error message for that code. Then when the plugin gets that error this class will\n * know how to display an error message for it. This allows a custom message to show\n * up on the `Player` error overlay.\n *\n * @type {Array}\n */\nMediaError.prototype.status = null;\n\n/**\n * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the\n * specification listed under {@link MediaError} for more information.\n *\n * @enum {array}\n * @readonly\n * @property {string} 0 - MEDIA_ERR_CUSTOM\n * @property {string} 1 - MEDIA_ERR_CUSTOM\n * @property {string} 2 - MEDIA_ERR_ABORTED\n * @property {string} 3 - MEDIA_ERR_NETWORK\n * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED\n * @property {string} 5 - MEDIA_ERR_ENCRYPTED\n */\nMediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];\n\n/**\n * The default `MediaError` messages based on the {@link MediaError.errorTypes}.\n *\n * @type {Array}\n * @constant\n */\nMediaError.defaultMessages = {\n  1: 'You aborted the media playback',\n  2: 'A network error caused the media download to fail part-way.',\n  3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',\n  4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',\n  5: 'The media is encrypted and we do not have the keys to decrypt it.'\n};\n\n// Add types as properties on MediaError\n// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;\nfor (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {\n  MediaError[MediaError.errorTypes[errNum]] = errNum;\n  // values should be accessible on both the class and instance\n  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;\n}\n\n/**\n * Returns whether an object is `Promise`-like (i.e. has a `then` method).\n *\n * @param  {Object}  value\n *         An object that may or may not be `Promise`-like.\n *\n * @return {Boolean}\n *         Whether or not the object is `Promise`-like.\n */\nfunction isPromise(value) {\n  return value !== undefined && value !== null && typeof value.then === 'function';\n}\n\n/**\n * Silence a Promise-like object.\n *\n * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\n * play promise\" rejection error messages.\n *\n * @param  {Object} value\n *         An object that may or may not be `Promise`-like.\n */\nfunction silencePromise(value) {\n  if (isPromise(value)) {\n    value.then(null, function (e) {});\n  }\n}\n\n/**\n * @file text-track-list-converter.js Utilities for capturing text track state and\n * re-creating tracks based on a capture.\n *\n * @module text-track-list-converter\n */\n\n/**\n * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that\n * represents the {@link TextTrack}'s state.\n *\n * @param {TextTrack} track\n *        The text track to query.\n *\n * @return {Object}\n *         A serializable javascript representation of the TextTrack.\n * @private\n */\nvar trackToJson_ = function trackToJson_(track) {\n  var ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce(function (acc, prop, i) {\n\n    if (track[prop]) {\n      acc[prop] = track[prop];\n    }\n\n    return acc;\n  }, {\n    cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {\n      return {\n        startTime: cue.startTime,\n        endTime: cue.endTime,\n        text: cue.text,\n        id: cue.id\n      };\n    })\n  });\n\n  return ret;\n};\n\n/**\n * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the\n * state of all {@link TextTrack}s currently configured. The return array is compatible with\n * {@link text-track-list-converter:jsonToTextTracks}.\n *\n * @param {Tech} tech\n *        The tech object to query\n *\n * @return {Array}\n *         A serializable javascript representation of the {@link Tech}s\n *         {@link TextTrackList}.\n */\nvar textTracksToJson = function textTracksToJson(tech) {\n\n  var trackEls = tech.$$('track');\n\n  var trackObjs = Array.prototype.map.call(trackEls, function (t) {\n    return t.track;\n  });\n  var tracks = Array.prototype.map.call(trackEls, function (trackEl) {\n    var json = trackToJson_(trackEl.track);\n\n    if (trackEl.src) {\n      json.src = trackEl.src;\n    }\n    return json;\n  });\n\n  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {\n    return trackObjs.indexOf(track) === -1;\n  }).map(trackToJson_));\n};\n\n/**\n * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript\n * object {@link TextTrack} representations.\n *\n * @param {Array} json\n *        An array of `TextTrack` representation objects, like those that would be\n *        produced by `textTracksToJson`.\n *\n * @param {Tech} tech\n *        The `Tech` to create the `TextTrack`s on.\n */\nvar jsonToTextTracks = function jsonToTextTracks(json, tech) {\n  json.forEach(function (track) {\n    var addedTrack = tech.addRemoteTextTrack(track).track;\n\n    if (!track.src && track.cues) {\n      track.cues.forEach(function (cue) {\n        return addedTrack.addCue(cue);\n      });\n    }\n  });\n\n  return tech.textTracks();\n};\n\nvar textTrackConverter = { textTracksToJson: textTracksToJson, jsonToTextTracks: jsonToTextTracks, trackToJson_: trackToJson_ };\n\n/**\n * @file modal-dialog.js\n */\n\nvar MODAL_CLASS_NAME = 'vjs-modal-dialog';\nvar ESC = 27;\n\n/**\n * The `ModalDialog` displays over the video and its controls, which blocks\n * interaction with the player until it is closed.\n *\n * Modal dialogs include a \"Close\" button and will close when that button\n * is activated - or when ESC is pressed anywhere.\n *\n * @extends Component\n */\n\nvar ModalDialog = function (_Component) {\n  inherits(ModalDialog, _Component);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Mixed} [options.content=undefined]\n   *        Provide customized content for this modal.\n   *\n   * @param {string} [options.description]\n   *        A text description for the modal, primarily for accessibility.\n   *\n   * @param {boolean} [options.fillAlways=false]\n   *        Normally, modals are automatically filled only the first time\n   *        they open. This tells the modal to refresh its content\n   *        every time it opens.\n   *\n   * @param {string} [options.label]\n   *        A text label for the modal, primarily for accessibility.\n   *\n   * @param {boolean} [options.temporary=true]\n   *        If `true`, the modal can only be opened once; it will be\n   *        disposed as soon as it's closed.\n   *\n   * @param {boolean} [options.uncloseable=false]\n   *        If `true`, the user will not be able to close the modal\n   *        through the UI in the normal ways. Programmatic closing is\n   *        still possible.\n   */\n  function ModalDialog(player, options) {\n    classCallCheck(this, ModalDialog);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;\n\n    _this.closeable(!_this.options_.uncloseable);\n    _this.content(_this.options_.content);\n\n    // Make sure the contentEl is defined AFTER any children are initialized\n    // because we only want the contents of the modal in the contentEl\n    // (not the UI elements like the close button).\n    _this.contentEl_ = createEl('div', {\n      className: MODAL_CLASS_NAME + '-content'\n    }, {\n      role: 'document'\n    });\n\n    _this.descEl_ = createEl('p', {\n      className: MODAL_CLASS_NAME + '-description vjs-control-text',\n      id: _this.el().getAttribute('aria-describedby')\n    });\n\n    textContent(_this.descEl_, _this.description());\n    _this.el_.appendChild(_this.descEl_);\n    _this.el_.appendChild(_this.contentEl_);\n    return _this;\n  }\n\n  /**\n   * Create the `ModalDialog`'s DOM element\n   *\n   * @return {Element}\n   *         The DOM element that gets created.\n   */\n\n\n  ModalDialog.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: this.buildCSSClass(),\n      tabIndex: -1\n    }, {\n      'aria-describedby': this.id() + '_description',\n      'aria-hidden': 'true',\n      'aria-label': this.label(),\n      'role': 'dialog'\n    });\n  };\n\n  ModalDialog.prototype.dispose = function dispose() {\n    this.contentEl_ = null;\n    this.descEl_ = null;\n    this.previouslyActiveEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  ModalDialog.prototype.buildCSSClass = function buildCSSClass() {\n    return MODAL_CLASS_NAME + ' vjs-hidden ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Handles `keydown` events on the document, looking for ESC, which closes\n   * the modal.\n   *\n   * @param {EventTarget~Event} e\n   *        The keypress that triggered this event.\n   *\n   * @listens keydown\n   */\n\n\n  ModalDialog.prototype.handleKeyPress = function handleKeyPress(e) {\n    if (e.which === ESC && this.closeable()) {\n      this.close();\n    }\n  };\n\n  /**\n   * Returns the label string for this modal. Primarily used for accessibility.\n   *\n   * @return {string}\n   *         the localized or raw label of this modal.\n   */\n\n\n  ModalDialog.prototype.label = function label() {\n    return this.localize(this.options_.label || 'Modal Window');\n  };\n\n  /**\n   * Returns the description string for this modal. Primarily used for\n   * accessibility.\n   *\n   * @return {string}\n   *         The localized or raw description of this modal.\n   */\n\n\n  ModalDialog.prototype.description = function description() {\n    var desc = this.options_.description || this.localize('This is a modal window.');\n\n    // Append a universal closeability message if the modal is closeable.\n    if (this.closeable()) {\n      desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');\n    }\n\n    return desc;\n  };\n\n  /**\n   * Opens the modal.\n   *\n   * @fires ModalDialog#beforemodalopen\n   * @fires ModalDialog#modalopen\n   */\n\n\n  ModalDialog.prototype.open = function open() {\n    if (!this.opened_) {\n      var player = this.player();\n\n      /**\n        * Fired just before a `ModalDialog` is opened.\n        *\n        * @event ModalDialog#beforemodalopen\n        * @type {EventTarget~Event}\n        */\n      this.trigger('beforemodalopen');\n      this.opened_ = true;\n\n      // Fill content if the modal has never opened before and\n      // never been filled.\n      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {\n        this.fill();\n      }\n\n      // If the player was playing, pause it and take note of its previously\n      // playing state.\n      this.wasPlaying_ = !player.paused();\n\n      if (this.options_.pauseOnOpen && this.wasPlaying_) {\n        player.pause();\n      }\n\n      if (this.closeable()) {\n        this.on(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));\n      }\n\n      // Hide controls and note if they were enabled.\n      this.hadControls_ = player.controls();\n      player.controls(false);\n\n      this.show();\n      this.conditionalFocus_();\n      this.el().setAttribute('aria-hidden', 'false');\n\n      /**\n        * Fired just after a `ModalDialog` is opened.\n        *\n        * @event ModalDialog#modalopen\n        * @type {EventTarget~Event}\n        */\n      this.trigger('modalopen');\n      this.hasBeenOpened_ = true;\n    }\n  };\n\n  /**\n   * If the `ModalDialog` is currently open or closed.\n   *\n   * @param  {boolean} [value]\n   *         If given, it will open (`true`) or close (`false`) the modal.\n   *\n   * @return {boolean}\n   *         the current open state of the modaldialog\n   */\n\n\n  ModalDialog.prototype.opened = function opened(value) {\n    if (typeof value === 'boolean') {\n      this[value ? 'open' : 'close']();\n    }\n    return this.opened_;\n  };\n\n  /**\n   * Closes the modal, does nothing if the `ModalDialog` is\n   * not open.\n   *\n   * @fires ModalDialog#beforemodalclose\n   * @fires ModalDialog#modalclose\n   */\n\n\n  ModalDialog.prototype.close = function close() {\n    if (!this.opened_) {\n      return;\n    }\n    var player = this.player();\n\n    /**\n      * Fired just before a `ModalDialog` is closed.\n      *\n      * @event ModalDialog#beforemodalclose\n      * @type {EventTarget~Event}\n      */\n    this.trigger('beforemodalclose');\n    this.opened_ = false;\n\n    if (this.wasPlaying_ && this.options_.pauseOnOpen) {\n      player.play();\n    }\n\n    if (this.closeable()) {\n      this.off(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));\n    }\n\n    if (this.hadControls_) {\n      player.controls(true);\n    }\n\n    this.hide();\n    this.el().setAttribute('aria-hidden', 'true');\n\n    /**\n      * Fired just after a `ModalDialog` is closed.\n      *\n      * @event ModalDialog#modalclose\n      * @type {EventTarget~Event}\n      */\n    this.trigger('modalclose');\n    this.conditionalBlur_();\n\n    if (this.options_.temporary) {\n      this.dispose();\n    }\n  };\n\n  /**\n   * Check to see if the `ModalDialog` is closeable via the UI.\n   *\n   * @param  {boolean} [value]\n   *         If given as a boolean, it will set the `closeable` option.\n   *\n   * @return {boolean}\n   *         Returns the final value of the closable option.\n   */\n\n\n  ModalDialog.prototype.closeable = function closeable(value) {\n    if (typeof value === 'boolean') {\n      var closeable = this.closeable_ = !!value;\n      var close = this.getChild('closeButton');\n\n      // If this is being made closeable and has no close button, add one.\n      if (closeable && !close) {\n\n        // The close button should be a child of the modal - not its\n        // content element, so temporarily change the content element.\n        var temp = this.contentEl_;\n\n        this.contentEl_ = this.el_;\n        close = this.addChild('closeButton', { controlText: 'Close Modal Dialog' });\n        this.contentEl_ = temp;\n        this.on(close, 'close', this.close);\n      }\n\n      // If this is being made uncloseable and has a close button, remove it.\n      if (!closeable && close) {\n        this.off(close, 'close', this.close);\n        this.removeChild(close);\n        close.dispose();\n      }\n    }\n    return this.closeable_;\n  };\n\n  /**\n   * Fill the modal's content element with the modal's \"content\" option.\n   * The content element will be emptied before this change takes place.\n   */\n\n\n  ModalDialog.prototype.fill = function fill() {\n    this.fillWith(this.content());\n  };\n\n  /**\n   * Fill the modal's content element with arbitrary content.\n   * The content element will be emptied before this change takes place.\n   *\n   * @fires ModalDialog#beforemodalfill\n   * @fires ModalDialog#modalfill\n   *\n   * @param {Mixed} [content]\n   *        The same rules apply to this as apply to the `content` option.\n   */\n\n\n  ModalDialog.prototype.fillWith = function fillWith(content) {\n    var contentEl = this.contentEl();\n    var parentEl = contentEl.parentNode;\n    var nextSiblingEl = contentEl.nextSibling;\n\n    /**\n     * Fired just before a `ModalDialog` is filled with content.\n     *\n     * @event ModalDialog#beforemodalfill\n     * @type {EventTarget~Event}\n     */\n    this.trigger('beforemodalfill');\n    this.hasBeenFilled_ = true;\n\n    // Detach the content element from the DOM before performing\n    // manipulation to avoid modifying the live DOM multiple times.\n    parentEl.removeChild(contentEl);\n    this.empty();\n    insertContent(contentEl, content);\n    /**\n     * Fired just after a `ModalDialog` is filled with content.\n     *\n     * @event ModalDialog#modalfill\n     * @type {EventTarget~Event}\n     */\n    this.trigger('modalfill');\n\n    // Re-inject the re-filled content element.\n    if (nextSiblingEl) {\n      parentEl.insertBefore(contentEl, nextSiblingEl);\n    } else {\n      parentEl.appendChild(contentEl);\n    }\n\n    // make sure that the close button is last in the dialog DOM\n    var closeButton = this.getChild('closeButton');\n\n    if (closeButton) {\n      parentEl.appendChild(closeButton.el_);\n    }\n  };\n\n  /**\n   * Empties the content element. This happens anytime the modal is filled.\n   *\n   * @fires ModalDialog#beforemodalempty\n   * @fires ModalDialog#modalempty\n   */\n\n\n  ModalDialog.prototype.empty = function empty() {\n    /**\n     * Fired just before a `ModalDialog` is emptied.\n     *\n     * @event ModalDialog#beforemodalempty\n     * @type {EventTarget~Event}\n     */\n    this.trigger('beforemodalempty');\n    emptyEl(this.contentEl());\n\n    /**\n     * Fired just after a `ModalDialog` is emptied.\n     *\n     * @event ModalDialog#modalempty\n     * @type {EventTarget~Event}\n     */\n    this.trigger('modalempty');\n  };\n\n  /**\n   * Gets or sets the modal content, which gets normalized before being\n   * rendered into the DOM.\n   *\n   * This does not update the DOM or fill the modal, but it is called during\n   * that process.\n   *\n   * @param  {Mixed} [value]\n   *         If defined, sets the internal content value to be used on the\n   *         next call(s) to `fill`. This value is normalized before being\n   *         inserted. To \"clear\" the internal content value, pass `null`.\n   *\n   * @return {Mixed}\n   *         The current content of the modal dialog\n   */\n\n\n  ModalDialog.prototype.content = function content(value) {\n    if (typeof value !== 'undefined') {\n      this.content_ = value;\n    }\n    return this.content_;\n  };\n\n  /**\n   * conditionally focus the modal dialog if focus was previously on the player.\n   *\n   * @private\n   */\n\n\n  ModalDialog.prototype.conditionalFocus_ = function conditionalFocus_() {\n    var activeEl = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.activeElement;\n    var playerEl = this.player_.el_;\n\n    this.previouslyActiveEl_ = null;\n\n    if (playerEl.contains(activeEl) || playerEl === activeEl) {\n      this.previouslyActiveEl_ = activeEl;\n\n      this.focus();\n\n      this.on(global_document__WEBPACK_IMPORTED_MODULE_1___default.a, 'keydown', this.handleKeyDown);\n    }\n  };\n\n  /**\n   * conditionally blur the element and refocus the last focused element\n   *\n   * @private\n   */\n\n\n  ModalDialog.prototype.conditionalBlur_ = function conditionalBlur_() {\n    if (this.previouslyActiveEl_) {\n      this.previouslyActiveEl_.focus();\n      this.previouslyActiveEl_ = null;\n    }\n\n    this.off(global_document__WEBPACK_IMPORTED_MODULE_1___default.a, 'keydown', this.handleKeyDown);\n  };\n\n  /**\n   * Keydown handler. Attached when modal is focused.\n   *\n   * @listens keydown\n   */\n\n\n  ModalDialog.prototype.handleKeyDown = function handleKeyDown(event) {\n    // exit early if it isn't a tab key\n    if (event.which !== 9) {\n      return;\n    }\n\n    var focusableEls = this.focusableEls_();\n    var activeEl = this.el_.querySelector(':focus');\n    var focusIndex = void 0;\n\n    for (var i = 0; i < focusableEls.length; i++) {\n      if (activeEl === focusableEls[i]) {\n        focusIndex = i;\n        break;\n      }\n    }\n\n    if (global_document__WEBPACK_IMPORTED_MODULE_1___default.a.activeElement === this.el_) {\n      focusIndex = 0;\n    }\n\n    if (event.shiftKey && focusIndex === 0) {\n      focusableEls[focusableEls.length - 1].focus();\n      event.preventDefault();\n    } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {\n      focusableEls[0].focus();\n      event.preventDefault();\n    }\n  };\n\n  /**\n   * get all focusable elements\n   *\n   * @private\n   */\n\n\n  ModalDialog.prototype.focusableEls_ = function focusableEls_() {\n    var allChildren = this.el_.querySelectorAll('*');\n\n    return Array.prototype.filter.call(allChildren, function (child) {\n      return (child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.HTMLAnchorElement || child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.HTMLInputElement || child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.HTMLSelectElement || child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.HTMLTextAreaElement || child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.HTMLIFrameElement || child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.HTMLObjectElement || child instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');\n    });\n  };\n\n  return ModalDialog;\n}(Component);\n\n/**\n * Default options for `ModalDialog` default options.\n *\n * @type {Object}\n * @private\n */\n\n\nModalDialog.prototype.options_ = {\n  pauseOnOpen: true,\n  temporary: true\n};\n\nComponent.registerComponent('ModalDialog', ModalDialog);\n\n/**\n * @file track-list.js\n */\n\n/**\n * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and\n * {@link VideoTrackList}\n *\n * @extends EventTarget\n */\n\nvar TrackList = function (_EventTarget) {\n  inherits(TrackList, _EventTarget);\n\n  /**\n   * Create an instance of this class\n   *\n   * @param {Track[]} tracks\n   *        A list of tracks to initialize the list with.\n   *\n   * @abstract\n   */\n  function TrackList() {\n    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, TrackList);\n\n    var _this = possibleConstructorReturn(this, _EventTarget.call(this));\n\n    _this.tracks_ = [];\n\n    /**\n     * @memberof TrackList\n     * @member {number} length\n     *         The current number of `Track`s in the this Trackist.\n     * @instance\n     */\n    Object.defineProperty(_this, 'length', {\n      get: function get$$1() {\n        return this.tracks_.length;\n      }\n    });\n\n    for (var i = 0; i < tracks.length; i++) {\n      _this.addTrack(tracks[i]);\n    }\n    return _this;\n  }\n\n  /**\n   * Add a {@link Track} to the `TrackList`\n   *\n   * @param {Track} track\n   *        The audio, video, or text track to add to the list.\n   *\n   * @fires TrackList#addtrack\n   */\n\n\n  TrackList.prototype.addTrack = function addTrack(track) {\n    var index = this.tracks_.length;\n\n    if (!('' + index in this)) {\n      Object.defineProperty(this, index, {\n        get: function get$$1() {\n          return this.tracks_[index];\n        }\n      });\n    }\n\n    // Do not add duplicate tracks\n    if (this.tracks_.indexOf(track) === -1) {\n      this.tracks_.push(track);\n      /**\n       * Triggered when a track is added to a track list.\n       *\n       * @event TrackList#addtrack\n       * @type {EventTarget~Event}\n       * @property {Track} track\n       *           A reference to track that was added.\n       */\n      this.trigger({\n        track: track,\n        type: 'addtrack'\n      });\n    }\n  };\n\n  /**\n   * Remove a {@link Track} from the `TrackList`\n   *\n   * @param {Track} rtrack\n   *        The audio, video, or text track to remove from the list.\n   *\n   * @fires TrackList#removetrack\n   */\n\n\n  TrackList.prototype.removeTrack = function removeTrack(rtrack) {\n    var track = void 0;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      if (this[i] === rtrack) {\n        track = this[i];\n        if (track.off) {\n          track.off();\n        }\n\n        this.tracks_.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!track) {\n      return;\n    }\n\n    /**\n     * Triggered when a track is removed from track list.\n     *\n     * @event TrackList#removetrack\n     * @type {EventTarget~Event}\n     * @property {Track} track\n     *           A reference to track that was removed.\n     */\n    this.trigger({\n      track: track,\n      type: 'removetrack'\n    });\n  };\n\n  /**\n   * Get a Track from the TrackList by a tracks id\n   *\n   * @param {String} id - the id of the track to get\n   * @method getTrackById\n   * @return {Track}\n   * @private\n   */\n\n\n  TrackList.prototype.getTrackById = function getTrackById(id) {\n    var result = null;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      var track = this[i];\n\n      if (track.id === id) {\n        result = track;\n        break;\n      }\n    }\n\n    return result;\n  };\n\n  return TrackList;\n}(EventTarget);\n\n/**\n * Triggered when a different track is selected/enabled.\n *\n * @event TrackList#change\n * @type {EventTarget~Event}\n */\n\n/**\n * Events that can be called with on + eventName. See {@link EventHandler}.\n *\n * @property {Object} TrackList#allowedEvents_\n * @private\n */\n\n\nTrackList.prototype.allowedEvents_ = {\n  change: 'change',\n  addtrack: 'addtrack',\n  removetrack: 'removetrack'\n};\n\n// emulate attribute EventHandler support to allow for feature detection\nfor (var event in TrackList.prototype.allowedEvents_) {\n  TrackList.prototype['on' + event] = null;\n}\n\n/**\n * @file audio-track-list.js\n */\n\n/**\n * Anywhere we call this function we diverge from the spec\n * as we only support one enabled audiotrack at a time\n *\n * @param {AudioTrackList} list\n *        list to work on\n *\n * @param {AudioTrack} track\n *        The track to skip\n *\n * @private\n */\nvar disableOthers = function disableOthers(list, track) {\n  for (var i = 0; i < list.length; i++) {\n    if (!Object.keys(list[i]).length || track.id === list[i].id) {\n      continue;\n    }\n    // another audio track is enabled, disable it\n    list[i].enabled = false;\n  }\n};\n\n/**\n * The current list of {@link AudioTrack} for a media file.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}\n * @extends TrackList\n */\n\nvar AudioTrackList = function (_TrackList) {\n  inherits(AudioTrackList, _TrackList);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {AudioTrack[]} [tracks=[]]\n   *        A list of `AudioTrack` to instantiate the list with.\n   */\n  function AudioTrackList() {\n    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, AudioTrackList);\n\n    // make sure only 1 track is enabled\n    // sorted from last index to first index\n    for (var i = tracks.length - 1; i >= 0; i--) {\n      if (tracks[i].enabled) {\n        disableOthers(tracks, tracks[i]);\n        break;\n      }\n    }\n\n    var _this = possibleConstructorReturn(this, _TrackList.call(this, tracks));\n\n    _this.changing_ = false;\n    return _this;\n  }\n\n  /**\n   * Add an {@link AudioTrack} to the `AudioTrackList`.\n   *\n   * @param {AudioTrack} track\n   *        The AudioTrack to add to the list\n   *\n   * @fires TrackList#addtrack\n   */\n\n\n  AudioTrackList.prototype.addTrack = function addTrack(track) {\n    var _this2 = this;\n\n    if (track.enabled) {\n      disableOthers(this, track);\n    }\n\n    _TrackList.prototype.addTrack.call(this, track);\n    // native tracks don't have this\n    if (!track.addEventListener) {\n      return;\n    }\n\n    /**\n     * @listens AudioTrack#enabledchange\n     * @fires TrackList#change\n     */\n    track.addEventListener('enabledchange', function () {\n      // when we are disabling other tracks (since we don't support\n      // more than one track at a time) we will set changing_\n      // to true so that we don't trigger additional change events\n      if (_this2.changing_) {\n        return;\n      }\n      _this2.changing_ = true;\n      disableOthers(_this2, track);\n      _this2.changing_ = false;\n      _this2.trigger('change');\n    });\n  };\n\n  return AudioTrackList;\n}(TrackList);\n\n/**\n * @file video-track-list.js\n */\n\n/**\n * Un-select all other {@link VideoTrack}s that are selected.\n *\n * @param {VideoTrackList} list\n *        list to work on\n *\n * @param {VideoTrack} track\n *        The track to skip\n *\n * @private\n */\nvar disableOthers$1 = function disableOthers(list, track) {\n  for (var i = 0; i < list.length; i++) {\n    if (!Object.keys(list[i]).length || track.id === list[i].id) {\n      continue;\n    }\n    // another video track is enabled, disable it\n    list[i].selected = false;\n  }\n};\n\n/**\n * The current list of {@link VideoTrack} for a video.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}\n * @extends TrackList\n */\n\nvar VideoTrackList = function (_TrackList) {\n  inherits(VideoTrackList, _TrackList);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {VideoTrack[]} [tracks=[]]\n   *        A list of `VideoTrack` to instantiate the list with.\n   */\n  function VideoTrackList() {\n    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, VideoTrackList);\n\n    // make sure only 1 track is enabled\n    // sorted from last index to first index\n    for (var i = tracks.length - 1; i >= 0; i--) {\n      if (tracks[i].selected) {\n        disableOthers$1(tracks, tracks[i]);\n        break;\n      }\n    }\n\n    var _this = possibleConstructorReturn(this, _TrackList.call(this, tracks));\n\n    _this.changing_ = false;\n\n    /**\n     * @member {number} VideoTrackList#selectedIndex\n     *         The current index of the selected {@link VideoTrack`}.\n     */\n    Object.defineProperty(_this, 'selectedIndex', {\n      get: function get$$1() {\n        for (var _i = 0; _i < this.length; _i++) {\n          if (this[_i].selected) {\n            return _i;\n          }\n        }\n        return -1;\n      },\n      set: function set$$1() {}\n    });\n    return _this;\n  }\n\n  /**\n   * Add a {@link VideoTrack} to the `VideoTrackList`.\n   *\n   * @param {VideoTrack} track\n   *        The VideoTrack to add to the list\n   *\n   * @fires TrackList#addtrack\n   */\n\n\n  VideoTrackList.prototype.addTrack = function addTrack(track) {\n    var _this2 = this;\n\n    if (track.selected) {\n      disableOthers$1(this, track);\n    }\n\n    _TrackList.prototype.addTrack.call(this, track);\n    // native tracks don't have this\n    if (!track.addEventListener) {\n      return;\n    }\n\n    /**\n     * @listens VideoTrack#selectedchange\n     * @fires TrackList#change\n     */\n    track.addEventListener('selectedchange', function () {\n      if (_this2.changing_) {\n        return;\n      }\n      _this2.changing_ = true;\n      disableOthers$1(_this2, track);\n      _this2.changing_ = false;\n      _this2.trigger('change');\n    });\n  };\n\n  return VideoTrackList;\n}(TrackList);\n\n/**\n * @file text-track-list.js\n */\n\n/**\n * The current list of {@link TextTrack} for a media file.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}\n * @extends TrackList\n */\n\nvar TextTrackList = function (_TrackList) {\n  inherits(TextTrackList, _TrackList);\n\n  function TextTrackList() {\n    classCallCheck(this, TextTrackList);\n    return possibleConstructorReturn(this, _TrackList.apply(this, arguments));\n  }\n\n  /**\n   * Add a {@link TextTrack} to the `TextTrackList`\n   *\n   * @param {TextTrack} track\n   *        The text track to add to the list.\n   *\n   * @fires TrackList#addtrack\n   */\n  TextTrackList.prototype.addTrack = function addTrack(track) {\n    _TrackList.prototype.addTrack.call(this, track);\n\n    /**\n     * @listens TextTrack#modechange\n     * @fires TrackList#change\n     */\n    track.addEventListener('modechange', bind(this, function () {\n      this.trigger('change');\n    }));\n\n    var nonLanguageTextTrackKind = ['metadata', 'chapters'];\n\n    if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {\n      track.addEventListener('modechange', bind(this, function () {\n        this.trigger('selectedlanguagechange');\n      }));\n    }\n  };\n\n  return TextTrackList;\n}(TrackList);\n\n/**\n * @file html-track-element-list.js\n */\n\n/**\n * The current list of {@link HtmlTrackElement}s.\n */\nvar HtmlTrackElementList = function () {\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {HtmlTrackElement[]} [tracks=[]]\n   *        A list of `HtmlTrackElement` to instantiate the list with.\n   */\n  function HtmlTrackElementList() {\n    var trackElements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, HtmlTrackElementList);\n\n    this.trackElements_ = [];\n\n    /**\n     * @memberof HtmlTrackElementList\n     * @member {number} length\n     *         The current number of `Track`s in the this Trackist.\n     * @instance\n     */\n    Object.defineProperty(this, 'length', {\n      get: function get$$1() {\n        return this.trackElements_.length;\n      }\n    });\n\n    for (var i = 0, length = trackElements.length; i < length; i++) {\n      this.addTrackElement_(trackElements[i]);\n    }\n  }\n\n  /**\n   * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`\n   *\n   * @param {HtmlTrackElement} trackElement\n   *        The track element to add to the list.\n   *\n   * @private\n   */\n\n\n  HtmlTrackElementList.prototype.addTrackElement_ = function addTrackElement_(trackElement) {\n    var index = this.trackElements_.length;\n\n    if (!('' + index in this)) {\n      Object.defineProperty(this, index, {\n        get: function get$$1() {\n          return this.trackElements_[index];\n        }\n      });\n    }\n\n    // Do not add duplicate elements\n    if (this.trackElements_.indexOf(trackElement) === -1) {\n      this.trackElements_.push(trackElement);\n    }\n  };\n\n  /**\n   * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an\n   * {@link TextTrack}.\n   *\n   * @param {TextTrack} track\n   *        The track associated with a track element.\n   *\n   * @return {HtmlTrackElement|undefined}\n   *         The track element that was found or undefined.\n   *\n   * @private\n   */\n\n\n  HtmlTrackElementList.prototype.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {\n    var trackElement_ = void 0;\n\n    for (var i = 0, length = this.trackElements_.length; i < length; i++) {\n      if (track === this.trackElements_[i].track) {\n        trackElement_ = this.trackElements_[i];\n\n        break;\n      }\n    }\n\n    return trackElement_;\n  };\n\n  /**\n   * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`\n   *\n   * @param {HtmlTrackElement} trackElement\n   *        The track element to remove from the list.\n   *\n   * @private\n   */\n\n\n  HtmlTrackElementList.prototype.removeTrackElement_ = function removeTrackElement_(trackElement) {\n    for (var i = 0, length = this.trackElements_.length; i < length; i++) {\n      if (trackElement === this.trackElements_[i]) {\n        this.trackElements_.splice(i, 1);\n\n        break;\n      }\n    }\n  };\n\n  return HtmlTrackElementList;\n}();\n\n/**\n * @file text-track-cue-list.js\n */\n\n/**\n * @typedef {Object} TextTrackCueList~TextTrackCue\n *\n * @property {string} id\n *           The unique id for this text track cue\n *\n * @property {number} startTime\n *           The start time for this text track cue\n *\n * @property {number} endTime\n *           The end time for this text track cue\n *\n * @property {boolean} pauseOnExit\n *           Pause when the end time is reached if true.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}\n */\n\n/**\n * A List of TextTrackCues.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}\n */\nvar TextTrackCueList = function () {\n\n  /**\n   * Create an instance of this class..\n   *\n   * @param {Array} cues\n   *        A list of cues to be initialized with\n   */\n  function TextTrackCueList(cues) {\n    classCallCheck(this, TextTrackCueList);\n\n    TextTrackCueList.prototype.setCues_.call(this, cues);\n\n    /**\n     * @memberof TextTrackCueList\n     * @member {number} length\n     *         The current number of `TextTrackCue`s in the TextTrackCueList.\n     * @instance\n     */\n    Object.defineProperty(this, 'length', {\n      get: function get$$1() {\n        return this.length_;\n      }\n    });\n  }\n\n  /**\n   * A setter for cues in this list. Creates getters\n   * an an index for the cues.\n   *\n   * @param {Array} cues\n   *        An array of cues to set\n   *\n   * @private\n   */\n\n\n  TextTrackCueList.prototype.setCues_ = function setCues_(cues) {\n    var oldLength = this.length || 0;\n    var i = 0;\n    var l = cues.length;\n\n    this.cues_ = cues;\n    this.length_ = cues.length;\n\n    var defineProp = function defineProp(index) {\n      if (!('' + index in this)) {\n        Object.defineProperty(this, '' + index, {\n          get: function get$$1() {\n            return this.cues_[index];\n          }\n        });\n      }\n    };\n\n    if (oldLength < l) {\n      i = oldLength;\n\n      for (; i < l; i++) {\n        defineProp.call(this, i);\n      }\n    }\n  };\n\n  /**\n   * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.\n   *\n   * @param {string} id\n   *        The id of the cue that should be searched for.\n   *\n   * @return {TextTrackCueList~TextTrackCue|null}\n   *         A single cue or null if none was found.\n   */\n\n\n  TextTrackCueList.prototype.getCueById = function getCueById(id) {\n    var result = null;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      var cue = this[i];\n\n      if (cue.id === id) {\n        result = cue;\n        break;\n      }\n    }\n\n    return result;\n  };\n\n  return TextTrackCueList;\n}();\n\n/**\n * @file track-kinds.js\n */\n\n/**\n * All possible `VideoTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind\n * @typedef VideoTrack~Kind\n * @enum\n */\nvar VideoTrackKind = {\n  alternative: 'alternative',\n  captions: 'captions',\n  main: 'main',\n  sign: 'sign',\n  subtitles: 'subtitles',\n  commentary: 'commentary'\n};\n\n/**\n * All possible `AudioTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind\n * @typedef AudioTrack~Kind\n * @enum\n */\nvar AudioTrackKind = {\n  'alternative': 'alternative',\n  'descriptions': 'descriptions',\n  'main': 'main',\n  'main-desc': 'main-desc',\n  'translation': 'translation',\n  'commentary': 'commentary'\n};\n\n/**\n * All possible `TextTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind\n * @typedef TextTrack~Kind\n * @enum\n */\nvar TextTrackKind = {\n  subtitles: 'subtitles',\n  captions: 'captions',\n  descriptions: 'descriptions',\n  chapters: 'chapters',\n  metadata: 'metadata'\n};\n\n/**\n * All possible `TextTrackMode`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode\n * @typedef TextTrack~Mode\n * @enum\n */\nvar TextTrackMode = {\n  disabled: 'disabled',\n  hidden: 'hidden',\n  showing: 'showing'\n};\n\n/**\n * @file track.js\n */\n\n/**\n * A Track class that contains all of the common functionality for {@link AudioTrack},\n * {@link VideoTrack}, and {@link TextTrack}.\n *\n * > Note: This class should not be used directly\n *\n * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}\n * @extends EventTarget\n * @abstract\n */\n\nvar Track = function (_EventTarget) {\n  inherits(Track, _EventTarget);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {string} [options.kind='']\n   *        A valid kind for the track type you are creating.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @abstract\n   */\n  function Track() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, Track);\n\n    var _this = possibleConstructorReturn(this, _EventTarget.call(this));\n\n    var trackProps = {\n      id: options.id || 'vjs_track_' + newGUID(),\n      kind: options.kind || '',\n      label: options.label || '',\n      language: options.language || ''\n    };\n\n    /**\n     * @memberof Track\n     * @member {string} id\n     *         The id of this track. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    /**\n     * @memberof Track\n     * @member {string} kind\n     *         The kind of track that this is. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    /**\n     * @memberof Track\n     * @member {string} label\n     *         The label of this track. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    /**\n     * @memberof Track\n     * @member {string} language\n     *         The two letter language code for this track. Cannot be changed after\n     *         creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    var _loop = function _loop(key) {\n      Object.defineProperty(_this, key, {\n        get: function get$$1() {\n          return trackProps[key];\n        },\n        set: function set$$1() {}\n      });\n    };\n\n    for (var key in trackProps) {\n      _loop(key);\n    }\n    return _this;\n  }\n\n  return Track;\n}(EventTarget);\n\n/**\n * @file url.js\n * @module url\n */\n\n/**\n * @typedef {Object} url:URLObject\n *\n * @property {string} protocol\n *           The protocol of the url that was parsed.\n *\n * @property {string} hostname\n *           The hostname of the url that was parsed.\n *\n * @property {string} port\n *           The port of the url that was parsed.\n *\n * @property {string} pathname\n *           The pathname of the url that was parsed.\n *\n * @property {string} search\n *           The search query of the url that was parsed.\n *\n * @property {string} hash\n *           The hash of the url that was parsed.\n *\n * @property {string} host\n *           The host of the url that was parsed.\n */\n\n/**\n * Resolve and parse the elements of a URL.\n *\n * @param  {String} url\n *         The url to parse\n *\n * @return {url:URLObject}\n *         An object of url details\n */\nvar parseUrl = function parseUrl(url) {\n  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];\n\n  // add the url to an anchor and let the browser parse the URL\n  var a = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('a');\n\n  a.href = url;\n\n  // IE8 (and 9?) Fix\n  // ie8 doesn't parse the URL correctly until the anchor is actually\n  // added to the body, and an innerHTML is needed to trigger the parsing\n  var addToBody = a.host === '' && a.protocol !== 'file:';\n  var div = void 0;\n\n  if (addToBody) {\n    div = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('div');\n    div.innerHTML = '<a href=\"' + url + '\"></a>';\n    a = div.firstChild;\n    // prevent the div from affecting layout\n    div.setAttribute('style', 'display:none; position:absolute;');\n    global_document__WEBPACK_IMPORTED_MODULE_1___default.a.body.appendChild(div);\n  }\n\n  // Copy the specific URL properties to a new object\n  // This is also needed for IE8 because the anchor loses its\n  // properties when it's removed from the dom\n  var details = {};\n\n  for (var i = 0; i < props.length; i++) {\n    details[props[i]] = a[props[i]];\n  }\n\n  // IE9 adds the port to the host property unlike everyone else. If\n  // a port identifier is added for standard ports, strip it.\n  if (details.protocol === 'http:') {\n    details.host = details.host.replace(/:80$/, '');\n  }\n\n  if (details.protocol === 'https:') {\n    details.host = details.host.replace(/:443$/, '');\n  }\n\n  if (!details.protocol) {\n    details.protocol = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.location.protocol;\n  }\n\n  if (addToBody) {\n    global_document__WEBPACK_IMPORTED_MODULE_1___default.a.body.removeChild(div);\n  }\n\n  return details;\n};\n\n/**\n * Get absolute version of relative URL. Used to tell flash correct URL.\n *\n *\n * @param  {string} url\n *         URL to make absolute\n *\n * @return {string}\n *         Absolute URL\n *\n * @see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n */\nvar getAbsoluteURL = function getAbsoluteURL(url) {\n  // Check if absolute URL\n  if (!url.match(/^https?:\\/\\//)) {\n    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.\n    var div = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('div');\n\n    div.innerHTML = '<a href=\"' + url + '\">x</a>';\n    url = div.firstChild.href;\n  }\n\n  return url;\n};\n\n/**\n * Returns the extension of the passed file name. It will return an empty string\n * if passed an invalid path.\n *\n * @param {string} path\n *        The fileName path like '/path/to/file.mp4'\n *\n * @returns {string}\n *          The extension in lower case or an empty string if no\n *          extension could be found.\n */\nvar getFileExtension = function getFileExtension(path) {\n  if (typeof path === 'string') {\n    var splitPathRe = /^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/i;\n    var pathParts = splitPathRe.exec(path);\n\n    if (pathParts) {\n      return pathParts.pop().toLowerCase();\n    }\n  }\n\n  return '';\n};\n\n/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @param {string} url\n *        The url to check.\n *\n * @return {boolean}\n *         Whether it is a cross domain request or not.\n */\nvar isCrossOrigin = function isCrossOrigin(url) {\n  var winLoc = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.location;\n  var urlInfo = parseUrl(url);\n\n  // IE8 protocol relative urls will return ':' for protocol\n  var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;\n\n  // Check if url is for another domain/origin\n  // IE8 doesn't know location.origin, so we won't rely on it here\n  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;\n\n  return crossOrigin;\n};\n\nvar Url = /*#__PURE__*/Object.freeze({\n  parseUrl: parseUrl,\n  getAbsoluteURL: getAbsoluteURL,\n  getFileExtension: getFileExtension,\n  isCrossOrigin: isCrossOrigin\n});\n\n/**\n * @file text-track.js\n */\n\n/**\n * Takes a webvtt file contents and parses it into cues\n *\n * @param {string} srcContent\n *        webVTT file contents\n *\n * @param {TextTrack} track\n *        TextTrack to add cues to. Cues come from the srcContent.\n *\n * @private\n */\nvar parseCues = function parseCues(srcContent, track) {\n  var parser = new global_window__WEBPACK_IMPORTED_MODULE_0___default.a.WebVTT.Parser(global_window__WEBPACK_IMPORTED_MODULE_0___default.a, global_window__WEBPACK_IMPORTED_MODULE_0___default.a.vttjs, global_window__WEBPACK_IMPORTED_MODULE_0___default.a.WebVTT.StringDecoder());\n  var errors = [];\n\n  parser.oncue = function (cue) {\n    track.addCue(cue);\n  };\n\n  parser.onparsingerror = function (error) {\n    errors.push(error);\n  };\n\n  parser.onflush = function () {\n    track.trigger({\n      type: 'loadeddata',\n      target: track\n    });\n  };\n\n  parser.parse(srcContent);\n  if (errors.length > 0) {\n    if (global_window__WEBPACK_IMPORTED_MODULE_0___default.a.console && global_window__WEBPACK_IMPORTED_MODULE_0___default.a.console.groupCollapsed) {\n      global_window__WEBPACK_IMPORTED_MODULE_0___default.a.console.groupCollapsed('Text Track parsing errors for ' + track.src);\n    }\n    errors.forEach(function (error) {\n      return log$1.error(error);\n    });\n    if (global_window__WEBPACK_IMPORTED_MODULE_0___default.a.console && global_window__WEBPACK_IMPORTED_MODULE_0___default.a.console.groupEnd) {\n      global_window__WEBPACK_IMPORTED_MODULE_0___default.a.console.groupEnd();\n    }\n  }\n\n  parser.flush();\n};\n\n/**\n * Load a `TextTrack` from a specified url.\n *\n * @param {string} src\n *        Url to load track from.\n *\n * @param {TextTrack} track\n *        Track to add cues to. Comes from the content at the end of `url`.\n *\n * @private\n */\nvar loadTrack = function loadTrack(src, track) {\n  var opts = {\n    uri: src\n  };\n  var crossOrigin = isCrossOrigin(src);\n\n  if (crossOrigin) {\n    opts.cors = crossOrigin;\n  }\n\n  xhr__WEBPACK_IMPORTED_MODULE_3___default()(opts, bind(this, function (err, response, responseBody) {\n    if (err) {\n      return log$1.error(err, response);\n    }\n\n    track.loaded_ = true;\n\n    // Make sure that vttjs has loaded, otherwise, wait till it finished loading\n    // NOTE: this is only used for the alt/video.novtt.js build\n    if (typeof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.WebVTT !== 'function') {\n      if (track.tech_) {\n        var loadHandler = function loadHandler() {\n          return parseCues(responseBody, track);\n        };\n\n        track.tech_.on('vttjsloaded', loadHandler);\n        track.tech_.on('vttjserror', function () {\n          log$1.error('vttjs failed to load, stopping trying to process ' + track.src);\n          track.tech_.off('vttjsloaded', loadHandler);\n        });\n      }\n    } else {\n      parseCues(responseBody, track);\n    }\n  }));\n};\n\n/**\n * A representation of a single `TextTrack`.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}\n * @extends Track\n */\n\nvar TextTrack = function (_Track) {\n  inherits(TextTrack, _Track);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} options={}\n   *        Object of option names and values\n   *\n   * @param {Tech} options.tech\n   *        A reference to the tech that owns this TextTrack.\n   *\n   * @param {TextTrack~Kind} [options.kind='subtitles']\n   *        A valid text track kind.\n   *\n   * @param {TextTrack~Mode} [options.mode='disabled']\n   *        A valid text track mode.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this TextTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {string} [options.srclang='']\n   *        A valid two character language code. An alternative, but deprioritized\n   *        version of `options.language`\n   *\n   * @param {string} [options.src]\n   *        A url to TextTrack cues.\n   *\n   * @param {boolean} [options.default]\n   *        If this track should default to on or off.\n   */\n  function TextTrack() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, TextTrack);\n\n    if (!options.tech) {\n      throw new Error('A tech was not provided.');\n    }\n\n    var settings = mergeOptions(options, {\n      kind: TextTrackKind[options.kind] || 'subtitles',\n      language: options.language || options.srclang || ''\n    });\n    var mode = TextTrackMode[settings.mode] || 'disabled';\n    var default_ = settings.default;\n\n    if (settings.kind === 'metadata' || settings.kind === 'chapters') {\n      mode = 'hidden';\n    }\n\n    var _this = possibleConstructorReturn(this, _Track.call(this, settings));\n\n    _this.tech_ = settings.tech;\n\n    _this.cues_ = [];\n    _this.activeCues_ = [];\n\n    var cues = new TextTrackCueList(_this.cues_);\n    var activeCues = new TextTrackCueList(_this.activeCues_);\n    var changed = false;\n    var timeupdateHandler = bind(_this, function () {\n\n      // Accessing this.activeCues for the side-effects of updating itself\n      // due to it's nature as a getter function. Do not remove or cues will\n      // stop updating!\n      /* eslint-disable no-unused-expressions */\n      this.activeCues;\n      /* eslint-enable no-unused-expressions */\n      if (changed) {\n        this.trigger('cuechange');\n        changed = false;\n      }\n    });\n\n    if (mode !== 'disabled') {\n      _this.tech_.ready(function () {\n        _this.tech_.on('timeupdate', timeupdateHandler);\n      }, true);\n    }\n\n    Object.defineProperties(_this, {\n      /**\n       * @memberof TextTrack\n       * @member {boolean} default\n       *         If this track was set to be on or off by default. Cannot be changed after\n       *         creation.\n       * @instance\n       *\n       * @readonly\n       */\n      default: {\n        get: function get$$1() {\n          return default_;\n        },\n        set: function set$$1() {}\n      },\n\n      /**\n       * @memberof TextTrack\n       * @member {string} mode\n       *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will\n       *         not be set if setting to an invalid mode.\n       * @instance\n       *\n       * @fires TextTrack#modechange\n       */\n      mode: {\n        get: function get$$1() {\n          return mode;\n        },\n        set: function set$$1(newMode) {\n          var _this2 = this;\n\n          if (!TextTrackMode[newMode]) {\n            return;\n          }\n          mode = newMode;\n          if (mode === 'showing') {\n\n            this.tech_.ready(function () {\n              _this2.tech_.on('timeupdate', timeupdateHandler);\n            }, true);\n          }\n          /**\n           * An event that fires when mode changes on this track. This allows\n           * the TextTrackList that holds this track to act accordingly.\n           *\n           * > Note: This is not part of the spec!\n           *\n           * @event TextTrack#modechange\n           * @type {EventTarget~Event}\n           */\n          this.trigger('modechange');\n        }\n      },\n\n      /**\n       * @memberof TextTrack\n       * @member {TextTrackCueList} cues\n       *         The text track cue list for this TextTrack.\n       * @instance\n       */\n      cues: {\n        get: function get$$1() {\n          if (!this.loaded_) {\n            return null;\n          }\n\n          return cues;\n        },\n        set: function set$$1() {}\n      },\n\n      /**\n       * @memberof TextTrack\n       * @member {TextTrackCueList} activeCues\n       *         The list text track cues that are currently active for this TextTrack.\n       * @instance\n       */\n      activeCues: {\n        get: function get$$1() {\n          if (!this.loaded_) {\n            return null;\n          }\n\n          // nothing to do\n          if (this.cues.length === 0) {\n            return activeCues;\n          }\n\n          var ct = this.tech_.currentTime();\n          var active = [];\n\n          for (var i = 0, l = this.cues.length; i < l; i++) {\n            var cue = this.cues[i];\n\n            if (cue.startTime <= ct && cue.endTime >= ct) {\n              active.push(cue);\n            } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {\n              active.push(cue);\n            }\n          }\n\n          changed = false;\n\n          if (active.length !== this.activeCues_.length) {\n            changed = true;\n          } else {\n            for (var _i = 0; _i < active.length; _i++) {\n              if (this.activeCues_.indexOf(active[_i]) === -1) {\n                changed = true;\n              }\n            }\n          }\n\n          this.activeCues_ = active;\n          activeCues.setCues_(this.activeCues_);\n\n          return activeCues;\n        },\n        set: function set$$1() {}\n      }\n    });\n\n    if (settings.src) {\n      _this.src = settings.src;\n      loadTrack(settings.src, _this);\n    } else {\n      _this.loaded_ = true;\n    }\n    return _this;\n  }\n\n  /**\n   * Add a cue to the internal list of cues.\n   *\n   * @param {TextTrack~Cue} cue\n   *        The cue to add to our internal list\n   */\n\n\n  TextTrack.prototype.addCue = function addCue(originalCue) {\n    var cue = originalCue;\n\n    if (global_window__WEBPACK_IMPORTED_MODULE_0___default.a.vttjs && !(originalCue instanceof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.vttjs.VTTCue)) {\n      cue = new global_window__WEBPACK_IMPORTED_MODULE_0___default.a.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);\n\n      for (var prop in originalCue) {\n        if (!(prop in cue)) {\n          cue[prop] = originalCue[prop];\n        }\n      }\n\n      // make sure that `id` is copied over\n      cue.id = originalCue.id;\n      cue.originalCue_ = originalCue;\n    }\n\n    var tracks = this.tech_.textTracks();\n\n    for (var i = 0; i < tracks.length; i++) {\n      if (tracks[i] !== this) {\n        tracks[i].removeCue(cue);\n      }\n    }\n\n    this.cues_.push(cue);\n    this.cues.setCues_(this.cues_);\n  };\n\n  /**\n   * Remove a cue from our internal list\n   *\n   * @param {TextTrack~Cue} removeCue\n   *        The cue to remove from our internal list\n   */\n\n\n  TextTrack.prototype.removeCue = function removeCue(_removeCue) {\n    var i = this.cues_.length;\n\n    while (i--) {\n      var cue = this.cues_[i];\n\n      if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {\n        this.cues_.splice(i, 1);\n        this.cues.setCues_(this.cues_);\n        break;\n      }\n    }\n  };\n\n  return TextTrack;\n}(Track);\n\n/**\n * cuechange - One or more cues in the track have become active or stopped being active.\n */\n\n\nTextTrack.prototype.allowedEvents_ = {\n  cuechange: 'cuechange'\n};\n\n/**\n * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}\n * only one `AudioTrack` in the list will be enabled at a time.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}\n * @extends Track\n */\n\nvar AudioTrack = function (_Track) {\n  inherits(AudioTrack, _Track);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {AudioTrack~Kind} [options.kind='']\n   *        A valid audio track kind\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {boolean} [options.enabled]\n   *        If this track is the one that is currently playing. If this track is part of\n   *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.\n   */\n  function AudioTrack() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, AudioTrack);\n\n    var settings = mergeOptions(options, {\n      kind: AudioTrackKind[options.kind] || ''\n    });\n\n    var _this = possibleConstructorReturn(this, _Track.call(this, settings));\n\n    var enabled = false;\n\n    /**\n     * @memberof AudioTrack\n     * @member {boolean} enabled\n     *         If this `AudioTrack` is enabled or not. When setting this will\n     *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.\n     * @instance\n     *\n     * @fires VideoTrack#selectedchange\n     */\n    Object.defineProperty(_this, 'enabled', {\n      get: function get$$1() {\n        return enabled;\n      },\n      set: function set$$1(newEnabled) {\n        // an invalid or unchanged value\n        if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {\n          return;\n        }\n        enabled = newEnabled;\n\n        /**\n         * An event that fires when enabled changes on this track. This allows\n         * the AudioTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec! Native tracks will do\n         *         this internally without an event.\n         *\n         * @event AudioTrack#enabledchange\n         * @type {EventTarget~Event}\n         */\n        this.trigger('enabledchange');\n      }\n    });\n\n    // if the user sets this track to selected then\n    // set selected to that true value otherwise\n    // we keep it false\n    if (settings.enabled) {\n      _this.enabled = settings.enabled;\n    }\n    _this.loaded_ = true;\n    return _this;\n  }\n\n  return AudioTrack;\n}(Track);\n\n/**\n * A representation of a single `VideoTrack`.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}\n * @extends Track\n */\n\nvar VideoTrack = function (_Track) {\n  inherits(VideoTrack, _Track);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {string} [options.kind='']\n   *        A valid {@link VideoTrack~Kind}\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {boolean} [options.selected]\n   *        If this track is the one that is currently playing.\n   */\n  function VideoTrack() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, VideoTrack);\n\n    var settings = mergeOptions(options, {\n      kind: VideoTrackKind[options.kind] || ''\n    });\n\n    var _this = possibleConstructorReturn(this, _Track.call(this, settings));\n\n    var selected = false;\n\n    /**\n     * @memberof VideoTrack\n     * @member {boolean} selected\n     *         If this `VideoTrack` is selected or not. When setting this will\n     *         fire {@link VideoTrack#selectedchange} if the state of selected changed.\n     * @instance\n     *\n     * @fires VideoTrack#selectedchange\n     */\n    Object.defineProperty(_this, 'selected', {\n      get: function get$$1() {\n        return selected;\n      },\n      set: function set$$1(newSelected) {\n        // an invalid or unchanged value\n        if (typeof newSelected !== 'boolean' || newSelected === selected) {\n          return;\n        }\n        selected = newSelected;\n\n        /**\n         * An event that fires when selected changes on this track. This allows\n         * the VideoTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec! Native tracks will do\n         *         this internally without an event.\n         *\n         * @event VideoTrack#selectedchange\n         * @type {EventTarget~Event}\n         */\n        this.trigger('selectedchange');\n      }\n    });\n\n    // if the user sets this track to selected then\n    // set selected to that true value otherwise\n    // we keep it false\n    if (settings.selected) {\n      _this.selected = settings.selected;\n    }\n    return _this;\n  }\n\n  return VideoTrack;\n}(Track);\n\n/**\n * @file html-track-element.js\n */\n\n/**\n * @memberof HTMLTrackElement\n * @typedef {HTMLTrackElement~ReadyState}\n * @enum {number}\n */\nvar NONE = 0;\nvar LOADING = 1;\nvar LOADED = 2;\nvar ERROR = 3;\n\n/**\n * A single track represented in the DOM.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}\n * @extends EventTarget\n */\n\nvar HTMLTrackElement = function (_EventTarget) {\n  inherits(HTMLTrackElement, _EventTarget);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} options={}\n   *        Object of option names and values\n   *\n   * @param {Tech} options.tech\n   *        A reference to the tech that owns this HTMLTrackElement.\n   *\n   * @param {TextTrack~Kind} [options.kind='subtitles']\n   *        A valid text track kind.\n   *\n   * @param {TextTrack~Mode} [options.mode='disabled']\n   *        A valid text track mode.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this TextTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {string} [options.srclang='']\n   *        A valid two character language code. An alternative, but deprioritized\n   *        vesion of `options.language`\n   *\n   * @param {string} [options.src]\n   *        A url to TextTrack cues.\n   *\n   * @param {boolean} [options.default]\n   *        If this track should default to on or off.\n   */\n  function HTMLTrackElement() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, HTMLTrackElement);\n\n    var _this = possibleConstructorReturn(this, _EventTarget.call(this));\n\n    var readyState = void 0;\n\n    var track = new TextTrack(options);\n\n    _this.kind = track.kind;\n    _this.src = track.src;\n    _this.srclang = track.language;\n    _this.label = track.label;\n    _this.default = track.default;\n\n    Object.defineProperties(_this, {\n\n      /**\n       * @memberof HTMLTrackElement\n       * @member {HTMLTrackElement~ReadyState} readyState\n       *         The current ready state of the track element.\n       * @instance\n       */\n      readyState: {\n        get: function get$$1() {\n          return readyState;\n        }\n      },\n\n      /**\n       * @memberof HTMLTrackElement\n       * @member {TextTrack} track\n       *         The underlying TextTrack object.\n       * @instance\n       *\n       */\n      track: {\n        get: function get$$1() {\n          return track;\n        }\n      }\n    });\n\n    readyState = NONE;\n\n    /**\n     * @listens TextTrack#loadeddata\n     * @fires HTMLTrackElement#load\n     */\n    track.addEventListener('loadeddata', function () {\n      readyState = LOADED;\n\n      _this.trigger({\n        type: 'load',\n        target: _this\n      });\n    });\n    return _this;\n  }\n\n  return HTMLTrackElement;\n}(EventTarget);\n\nHTMLTrackElement.prototype.allowedEvents_ = {\n  load: 'load'\n};\n\nHTMLTrackElement.NONE = NONE;\nHTMLTrackElement.LOADING = LOADING;\nHTMLTrackElement.LOADED = LOADED;\nHTMLTrackElement.ERROR = ERROR;\n\n/*\n * This file contains all track properties that are used in\n * player.js, tech.js, html5.js and possibly other techs in the future.\n */\n\nvar NORMAL = {\n  audio: {\n    ListClass: AudioTrackList,\n    TrackClass: AudioTrack,\n    capitalName: 'Audio'\n  },\n  video: {\n    ListClass: VideoTrackList,\n    TrackClass: VideoTrack,\n    capitalName: 'Video'\n  },\n  text: {\n    ListClass: TextTrackList,\n    TrackClass: TextTrack,\n    capitalName: 'Text'\n  }\n};\n\nObject.keys(NORMAL).forEach(function (type) {\n  NORMAL[type].getterName = type + 'Tracks';\n  NORMAL[type].privateName = type + 'Tracks_';\n});\n\nvar REMOTE = {\n  remoteText: {\n    ListClass: TextTrackList,\n    TrackClass: TextTrack,\n    capitalName: 'RemoteText',\n    getterName: 'remoteTextTracks',\n    privateName: 'remoteTextTracks_'\n  },\n  remoteTextEl: {\n    ListClass: HtmlTrackElementList,\n    TrackClass: HTMLTrackElement,\n    capitalName: 'RemoteTextTrackEls',\n    getterName: 'remoteTextTrackEls',\n    privateName: 'remoteTextTrackEls_'\n  }\n};\n\nvar ALL = mergeOptions(NORMAL, REMOTE);\n\nREMOTE.names = Object.keys(REMOTE);\nNORMAL.names = Object.keys(NORMAL);\nALL.names = [].concat(REMOTE.names).concat(NORMAL.names);\n\n/**\n * @file tech.js\n */\n\n/**\n * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string\n * that just contains the src url alone.\n * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`\n   * `var SourceString = 'http://example.com/some-video.mp4';`\n *\n * @typedef {Object|string} Tech~SourceObject\n *\n * @property {string} src\n *           The url to the source\n *\n * @property {string} type\n *           The mime type of the source\n */\n\n/**\n * A function used by {@link Tech} to create a new {@link TextTrack}.\n *\n * @private\n *\n * @param {Tech} self\n *        An instance of the Tech class.\n *\n * @param {string} kind\n *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n *\n * @param {string} [label]\n *        Label to identify the text track\n *\n * @param {string} [language]\n *        Two letter language abbreviation\n *\n * @param {Object} [options={}]\n *        An object with additional text track options\n *\n * @return {TextTrack}\n *          The text track that was created.\n */\nfunction createTrackHelper(self, kind, label, language) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  var tracks = self.textTracks();\n\n  options.kind = kind;\n\n  if (label) {\n    options.label = label;\n  }\n  if (language) {\n    options.language = language;\n  }\n  options.tech = self;\n\n  var track = new ALL.text.TrackClass(options);\n\n  tracks.addTrack(track);\n\n  return track;\n}\n\n/**\n * This is the base class for media playback technology controllers, such as\n * {@link Flash} and {@link HTML5}\n *\n * @extends Component\n */\n\nvar Tech = function (_Component) {\n  inherits(Tech, _Component);\n\n  /**\n   * Create an instance of this Tech.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} ready\n   *        Callback function to call when the `HTML5` Tech is ready.\n   */\n  function Tech() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var ready = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n    classCallCheck(this, Tech);\n\n    // we don't want the tech to report user activity automatically.\n    // This is done manually in addControlsListeners\n    options.reportTouchActivity = false;\n\n    // keep track of whether the current source has played at all to\n    // implement a very limited played()\n    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));\n\n    _this.hasStarted_ = false;\n    _this.on('playing', function () {\n      this.hasStarted_ = true;\n    });\n    _this.on('loadstart', function () {\n      this.hasStarted_ = false;\n    });\n\n    ALL.names.forEach(function (name) {\n      var props = ALL[name];\n\n      if (options && options[props.getterName]) {\n        _this[props.privateName] = options[props.getterName];\n      }\n    });\n\n    // Manually track progress in cases where the browser/flash player doesn't report it.\n    if (!_this.featuresProgressEvents) {\n      _this.manualProgressOn();\n    }\n\n    // Manually track timeupdates in cases where the browser/flash player doesn't report it.\n    if (!_this.featuresTimeupdateEvents) {\n      _this.manualTimeUpdatesOn();\n    }\n\n    ['Text', 'Audio', 'Video'].forEach(function (track) {\n      if (options['native' + track + 'Tracks'] === false) {\n        _this['featuresNative' + track + 'Tracks'] = false;\n      }\n    });\n\n    if (options.nativeCaptions === false || options.nativeTextTracks === false) {\n      _this.featuresNativeTextTracks = false;\n    } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {\n      _this.featuresNativeTextTracks = true;\n    }\n\n    if (!_this.featuresNativeTextTracks) {\n      _this.emulateTextTracks();\n    }\n\n    _this.autoRemoteTextTracks_ = new ALL.text.ListClass();\n\n    _this.initTrackListeners();\n\n    // Turn on component tap events only if not using native controls\n    if (!options.nativeControlsForTouch) {\n      _this.emitTapEvents();\n    }\n\n    if (_this.constructor) {\n      _this.name_ = _this.constructor.name || 'Unknown Tech';\n    }\n    return _this;\n  }\n\n  /**\n   * A special function to trigger source set in a way that will allow player\n   * to re-trigger if the player or tech are not ready yet.\n   *\n   * @fires Tech#sourceset\n   * @param {string} src The source string at the time of the source changing.\n   */\n\n\n  Tech.prototype.triggerSourceset = function triggerSourceset(src) {\n    var _this2 = this;\n\n    if (!this.isReady_) {\n      // on initial ready we have to trigger source set\n      // 1ms after ready so that player can watch for it.\n      this.one('ready', function () {\n        return _this2.setTimeout(function () {\n          return _this2.triggerSourceset(src);\n        }, 1);\n      });\n    }\n\n    /**\n     * Fired when the source is set on the tech causing the media element\n     * to reload.\n     *\n     * @see {@link Player#event:sourceset}\n     * @event Tech#sourceset\n     * @type {EventTarget~Event}\n     */\n    this.trigger({\n      src: src,\n      type: 'sourceset'\n    });\n  };\n\n  /* Fallbacks for unsupported event types\n  ================================================================================ */\n\n  /**\n   * Polyfill the `progress` event for browsers that don't support it natively.\n   *\n   * @see {@link Tech#trackProgress}\n   */\n\n\n  Tech.prototype.manualProgressOn = function manualProgressOn() {\n    this.on('durationchange', this.onDurationChange);\n\n    this.manualProgress = true;\n\n    // Trigger progress watching when a source begins loading\n    this.one('ready', this.trackProgress);\n  };\n\n  /**\n   * Turn off the polyfill for `progress` events that was created in\n   * {@link Tech#manualProgressOn}\n   */\n\n\n  Tech.prototype.manualProgressOff = function manualProgressOff() {\n    this.manualProgress = false;\n    this.stopTrackingProgress();\n\n    this.off('durationchange', this.onDurationChange);\n  };\n\n  /**\n   * This is used to trigger a `progress` event when the buffered percent changes. It\n   * sets an interval function that will be called every 500 milliseconds to check if the\n   * buffer end percent has changed.\n   *\n   * > This function is called by {@link Tech#manualProgressOn}\n   *\n   * @param {EventTarget~Event} event\n   *        The `ready` event that caused this to run.\n   *\n   * @listens Tech#ready\n   * @fires Tech#progress\n   */\n\n\n  Tech.prototype.trackProgress = function trackProgress(event) {\n    this.stopTrackingProgress();\n    this.progressInterval = this.setInterval(bind(this, function () {\n      // Don't trigger unless buffered amount is greater than last time\n\n      var numBufferedPercent = this.bufferedPercent();\n\n      if (this.bufferedPercent_ !== numBufferedPercent) {\n        /**\n         * See {@link Player#progress}\n         *\n         * @event Tech#progress\n         * @type {EventTarget~Event}\n         */\n        this.trigger('progress');\n      }\n\n      this.bufferedPercent_ = numBufferedPercent;\n\n      if (numBufferedPercent === 1) {\n        this.stopTrackingProgress();\n      }\n    }), 500);\n  };\n\n  /**\n   * Update our internal duration on a `durationchange` event by calling\n   * {@link Tech#duration}.\n   *\n   * @param {EventTarget~Event} event\n   *        The `durationchange` event that caused this to run.\n   *\n   * @listens Tech#durationchange\n   */\n\n\n  Tech.prototype.onDurationChange = function onDurationChange(event) {\n    this.duration_ = this.duration();\n  };\n\n  /**\n   * Get and create a `TimeRange` object for buffering.\n   *\n   * @return {TimeRange}\n   *         The time range object that was created.\n   */\n\n\n  Tech.prototype.buffered = function buffered() {\n    return createTimeRanges(0, 0);\n  };\n\n  /**\n   * Get the percentage of the current video that is currently buffered.\n   *\n   * @return {number}\n   *         A number from 0 to 1 that represents the decimal percentage of the\n   *         video that is buffered.\n   *\n   */\n\n\n  Tech.prototype.bufferedPercent = function bufferedPercent$$1() {\n    return bufferedPercent(this.buffered(), this.duration_);\n  };\n\n  /**\n   * Turn off the polyfill for `progress` events that was created in\n   * {@link Tech#manualProgressOn}\n   * Stop manually tracking progress events by clearing the interval that was set in\n   * {@link Tech#trackProgress}.\n   */\n\n\n  Tech.prototype.stopTrackingProgress = function stopTrackingProgress() {\n    this.clearInterval(this.progressInterval);\n  };\n\n  /**\n   * Polyfill the `timeupdate` event for browsers that don't support it.\n   *\n   * @see {@link Tech#trackCurrentTime}\n   */\n\n\n  Tech.prototype.manualTimeUpdatesOn = function manualTimeUpdatesOn() {\n    this.manualTimeUpdates = true;\n\n    this.on('play', this.trackCurrentTime);\n    this.on('pause', this.stopTrackingCurrentTime);\n  };\n\n  /**\n   * Turn off the polyfill for `timeupdate` events that was created in\n   * {@link Tech#manualTimeUpdatesOn}\n   */\n\n\n  Tech.prototype.manualTimeUpdatesOff = function manualTimeUpdatesOff() {\n    this.manualTimeUpdates = false;\n    this.stopTrackingCurrentTime();\n    this.off('play', this.trackCurrentTime);\n    this.off('pause', this.stopTrackingCurrentTime);\n  };\n\n  /**\n   * Sets up an interval function to track current time and trigger `timeupdate` every\n   * 250 milliseconds.\n   *\n   * @listens Tech#play\n   * @triggers Tech#timeupdate\n   */\n\n\n  Tech.prototype.trackCurrentTime = function trackCurrentTime() {\n    if (this.currentTimeInterval) {\n      this.stopTrackingCurrentTime();\n    }\n    this.currentTimeInterval = this.setInterval(function () {\n      /**\n       * Triggered at an interval of 250ms to indicated that time is passing in the video.\n       *\n       * @event Tech#timeupdate\n       * @type {EventTarget~Event}\n       */\n      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\n\n      // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n    }, 250);\n  };\n\n  /**\n   * Stop the interval function created in {@link Tech#trackCurrentTime} so that the\n   * `timeupdate` event is no longer triggered.\n   *\n   * @listens {Tech#pause}\n   */\n\n\n  Tech.prototype.stopTrackingCurrentTime = function stopTrackingCurrentTime() {\n    this.clearInterval(this.currentTimeInterval);\n\n    // #1002 - if the video ends right before the next timeupdate would happen,\n    // the progress bar won't make it all the way to the end\n    this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\n  };\n\n  /**\n   * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},\n   * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.\n   *\n   * @fires Component#dispose\n   */\n\n\n  Tech.prototype.dispose = function dispose() {\n\n    // clear out all tracks because we can't reuse them between techs\n    this.clearTracks(NORMAL.names);\n\n    // Turn off any manual progress or timeupdate tracking\n    if (this.manualProgress) {\n      this.manualProgressOff();\n    }\n\n    if (this.manualTimeUpdates) {\n      this.manualTimeUpdatesOff();\n    }\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Clear out a single `TrackList` or an array of `TrackLists` given their names.\n   *\n   * > Note: Techs without source handlers should call this between sources for `video`\n   *         & `audio` tracks. You don't want to use them between tracks!\n   *\n   * @param {string[]|string} types\n   *        TrackList names to clear, valid names are `video`, `audio`, and\n   *        `text`.\n   */\n\n\n  Tech.prototype.clearTracks = function clearTracks(types) {\n    var _this3 = this;\n\n    types = [].concat(types);\n    // clear out all tracks because we can't reuse them between techs\n    types.forEach(function (type) {\n      var list = _this3[type + 'Tracks']() || [];\n      var i = list.length;\n\n      while (i--) {\n        var track = list[i];\n\n        if (type === 'text') {\n          _this3.removeRemoteTextTrack(track);\n        }\n        list.removeTrack(track);\n      }\n    });\n  };\n\n  /**\n   * Remove any TextTracks added via addRemoteTextTrack that are\n   * flagged for automatic garbage collection\n   */\n\n\n  Tech.prototype.cleanupAutoTextTracks = function cleanupAutoTextTracks() {\n    var list = this.autoRemoteTextTracks_ || [];\n    var i = list.length;\n\n    while (i--) {\n      var track = list[i];\n\n      this.removeRemoteTextTrack(track);\n    }\n  };\n\n  /**\n   * Reset the tech, which will removes all sources and reset the internal readyState.\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.reset = function reset() {};\n\n  /**\n   * Get or set an error on the Tech.\n   *\n   * @param {MediaError} [err]\n   *        Error to set on the Tech\n   *\n   * @return {MediaError|null}\n   *         The current error object on the tech, or null if there isn't one.\n   */\n\n\n  Tech.prototype.error = function error(err) {\n    if (err !== undefined) {\n      this.error_ = new MediaError(err);\n      this.trigger('error');\n    }\n    return this.error_;\n  };\n\n  /**\n   * Returns the `TimeRange`s that have been played through for the current source.\n   *\n   * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.\n   *         It only checks whether the source has played at all or not.\n   *\n   * @return {TimeRange}\n   *         - A single time range if this video has played\n   *         - An empty set of ranges if not.\n   */\n\n\n  Tech.prototype.played = function played() {\n    if (this.hasStarted_) {\n      return createTimeRanges(0, 0);\n    }\n    return createTimeRanges();\n  };\n\n  /**\n   * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was\n   * previously called.\n   *\n   * @fires Tech#timeupdate\n   */\n\n\n  Tech.prototype.setCurrentTime = function setCurrentTime() {\n    // improve the accuracy of manual timeupdates\n    if (this.manualTimeUpdates) {\n      /**\n       * A manual `timeupdate` event.\n       *\n       * @event Tech#timeupdate\n       * @type {EventTarget~Event}\n       */\n      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\n    }\n  };\n\n  /**\n   * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and\n   * {@link TextTrackList} events.\n   *\n   * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.\n   *\n   * @fires Tech#audiotrackchange\n   * @fires Tech#videotrackchange\n   * @fires Tech#texttrackchange\n   */\n\n\n  Tech.prototype.initTrackListeners = function initTrackListeners() {\n    var _this4 = this;\n\n    /**\n     * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}\n     *\n     * @event Tech#audiotrackchange\n     * @type {EventTarget~Event}\n     */\n\n    /**\n     * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}\n     *\n     * @event Tech#videotrackchange\n     * @type {EventTarget~Event}\n     */\n\n    /**\n     * Triggered when tracks are added or removed on the Tech {@link TextTrackList}\n     *\n     * @event Tech#texttrackchange\n     * @type {EventTarget~Event}\n     */\n    NORMAL.names.forEach(function (name) {\n      var props = NORMAL[name];\n      var trackListChanges = function trackListChanges() {\n        _this4.trigger(name + 'trackchange');\n      };\n\n      var tracks = _this4[props.getterName]();\n\n      tracks.addEventListener('removetrack', trackListChanges);\n      tracks.addEventListener('addtrack', trackListChanges);\n\n      _this4.on('dispose', function () {\n        tracks.removeEventListener('removetrack', trackListChanges);\n        tracks.removeEventListener('addtrack', trackListChanges);\n      });\n    });\n  };\n\n  /**\n   * Emulate TextTracks using vtt.js if necessary\n   *\n   * @fires Tech#vttjsloaded\n   * @fires Tech#vttjserror\n   */\n\n\n  Tech.prototype.addWebVttScript_ = function addWebVttScript_() {\n    var _this5 = this;\n\n    if (global_window__WEBPACK_IMPORTED_MODULE_0___default.a.WebVTT) {\n      return;\n    }\n\n    // Initially, Tech.el_ is a child of a dummy-div wait until the Component system\n    // signals that the Tech is ready at which point Tech.el_ is part of the DOM\n    // before inserting the WebVTT script\n    if (global_document__WEBPACK_IMPORTED_MODULE_1___default.a.body.contains(this.el())) {\n\n      // load via require if available and vtt.js script location was not passed in\n      // as an option. novtt builds will turn the above require call into an empty object\n      // which will cause this if check to always fail.\n      if (!this.options_['vtt.js'] && isPlain(videojs_vtt_js__WEBPACK_IMPORTED_MODULE_4___default.a) && Object.keys(videojs_vtt_js__WEBPACK_IMPORTED_MODULE_4___default.a).length > 0) {\n        this.trigger('vttjsloaded');\n        return;\n      }\n\n      // load vtt.js via the script location option or the cdn of no location was\n      // passed in\n      var script = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('script');\n\n      script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js';\n      script.onload = function () {\n        /**\n         * Fired when vtt.js is loaded.\n         *\n         * @event Tech#vttjsloaded\n         * @type {EventTarget~Event}\n         */\n        _this5.trigger('vttjsloaded');\n      };\n      script.onerror = function () {\n        /**\n         * Fired when vtt.js was not loaded due to an error\n         *\n         * @event Tech#vttjsloaded\n         * @type {EventTarget~Event}\n         */\n        _this5.trigger('vttjserror');\n      };\n      this.on('dispose', function () {\n        script.onload = null;\n        script.onerror = null;\n      });\n      // but have not loaded yet and we set it to true before the inject so that\n      // we don't overwrite the injected window.WebVTT if it loads right away\n      global_window__WEBPACK_IMPORTED_MODULE_0___default.a.WebVTT = true;\n      this.el().parentNode.appendChild(script);\n    } else {\n      this.ready(this.addWebVttScript_);\n    }\n  };\n\n  /**\n   * Emulate texttracks\n   *\n   */\n\n\n  Tech.prototype.emulateTextTracks = function emulateTextTracks() {\n    var _this6 = this;\n\n    var tracks = this.textTracks();\n    var remoteTracks = this.remoteTextTracks();\n    var handleAddTrack = function handleAddTrack(e) {\n      return tracks.addTrack(e.track);\n    };\n    var handleRemoveTrack = function handleRemoveTrack(e) {\n      return tracks.removeTrack(e.track);\n    };\n\n    remoteTracks.on('addtrack', handleAddTrack);\n    remoteTracks.on('removetrack', handleRemoveTrack);\n\n    this.addWebVttScript_();\n\n    var updateDisplay = function updateDisplay() {\n      return _this6.trigger('texttrackchange');\n    };\n\n    var textTracksChanges = function textTracksChanges() {\n      updateDisplay();\n\n      for (var i = 0; i < tracks.length; i++) {\n        var track = tracks[i];\n\n        track.removeEventListener('cuechange', updateDisplay);\n        if (track.mode === 'showing') {\n          track.addEventListener('cuechange', updateDisplay);\n        }\n      }\n    };\n\n    textTracksChanges();\n    tracks.addEventListener('change', textTracksChanges);\n    tracks.addEventListener('addtrack', textTracksChanges);\n    tracks.addEventListener('removetrack', textTracksChanges);\n\n    this.on('dispose', function () {\n      remoteTracks.off('addtrack', handleAddTrack);\n      remoteTracks.off('removetrack', handleRemoveTrack);\n      tracks.removeEventListener('change', textTracksChanges);\n      tracks.removeEventListener('addtrack', textTracksChanges);\n      tracks.removeEventListener('removetrack', textTracksChanges);\n\n      for (var i = 0; i < tracks.length; i++) {\n        var track = tracks[i];\n\n        track.removeEventListener('cuechange', updateDisplay);\n      }\n    });\n  };\n\n  /**\n   * Create and returns a remote {@link TextTrack} object.\n   *\n   * @param {string} kind\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n   *\n   * @param {string} [label]\n   *        Label to identify the text track\n   *\n   * @param {string} [language]\n   *        Two letter language abbreviation\n   *\n   * @return {TextTrack}\n   *         The TextTrack that gets created.\n   */\n\n\n  Tech.prototype.addTextTrack = function addTextTrack(kind, label, language) {\n    if (!kind) {\n      throw new Error('TextTrack kind is required but was not provided');\n    }\n\n    return createTrackHelper(this, kind, label, language);\n  };\n\n  /**\n   * Create an emulated TextTrack for use by addRemoteTextTrack\n   *\n   * This is intended to be overridden by classes that inherit from\n   * Tech in order to create native or custom TextTracks.\n   *\n   * @param {Object} options\n   *        The object should contain the options to initialize the TextTrack with.\n   *\n   * @param {string} [options.kind]\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n   *\n   * @param {string} [options.label].\n   *        Label to identify the text track\n   *\n   * @param {string} [options.language]\n   *        Two letter language abbreviation.\n   *\n   * @return {HTMLTrackElement}\n   *         The track element that gets created.\n   */\n\n\n  Tech.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {\n    var track = mergeOptions(options, {\n      tech: this\n    });\n\n    return new REMOTE.remoteTextEl.TrackClass(track);\n  };\n\n  /**\n   * Creates a remote text track object and returns an html track element.\n   *\n   * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.\n   *\n   * @param {Object} options\n   *        See {@link Tech#createRemoteTextTrack} for more detailed properties.\n   *\n   * @param {boolean} [manualCleanup=true]\n   *        - When false: the TextTrack will be automatically removed from the video\n   *          element whenever the source changes\n   *        - When True: The TextTrack will have to be cleaned up manually\n   *\n   * @return {HTMLTrackElement}\n   *         An Html Track Element.\n   *\n   * @deprecated The default functionality for this function will be equivalent\n   *             to \"manualCleanup=false\" in the future. The manualCleanup parameter will\n   *             also be removed.\n   */\n\n\n  Tech.prototype.addRemoteTextTrack = function addRemoteTextTrack() {\n    var _this7 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var manualCleanup = arguments[1];\n\n    var htmlTrackElement = this.createRemoteTextTrack(options);\n\n    if (manualCleanup !== true && manualCleanup !== false) {\n      // deprecation warning\n      log$1.warn('Calling addRemoteTextTrack without explicitly setting the \"manualCleanup\" parameter to `true` is deprecated and default to `false` in future version of video.js');\n      manualCleanup = true;\n    }\n\n    // store HTMLTrackElement and TextTrack to remote list\n    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);\n    this.remoteTextTracks().addTrack(htmlTrackElement.track);\n\n    if (manualCleanup !== true) {\n      // create the TextTrackList if it doesn't exist\n      this.ready(function () {\n        return _this7.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);\n      });\n    }\n\n    return htmlTrackElement;\n  };\n\n  /**\n   * Remove a remote text track from the remote `TextTrackList`.\n   *\n   * @param {TextTrack} track\n   *        `TextTrack` to remove from the `TextTrackList`\n   */\n\n\n  Tech.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {\n    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);\n\n    // remove HTMLTrackElement and TextTrack from remote list\n    this.remoteTextTrackEls().removeTrackElement_(trackElement);\n    this.remoteTextTracks().removeTrack(track);\n    this.autoRemoteTextTracks_.removeTrack(track);\n  };\n\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    return {};\n  };\n\n  /**\n   * A method to set a poster from a `Tech`.\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.setPoster = function setPoster() {};\n\n  /**\n   * A method to check for the presence of the 'playsinline' <video> attribute.\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.playsinline = function playsinline() {};\n\n  /**\n   * A method to set or unset the 'playsinline' <video> attribute.\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.setPlaysinline = function setPlaysinline() {};\n\n  /**\n   * Attempt to force override of native audio tracks.\n   *\n   * @param {Boolean} override - If set to true native audio will be overridden,\n   * otherwise native audio will potentially be used.\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.overrideNativeAudioTracks = function overrideNativeAudioTracks() {};\n\n  /**\n   * Attempt to force override of native video tracks.\n   *\n   * @param {Boolean} override - If set to true native video will be overridden,\n   * otherwise native video will potentially be used.\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.overrideNativeVideoTracks = function overrideNativeVideoTracks() {};\n\n  /*\n   * Check if the tech can support the given mime-type.\n   *\n   * The base tech does not support any type, but source handlers might\n   * overwrite this.\n   *\n   * @param  {string} type\n   *         The mimetype to check for support\n   *\n   * @return {string}\n   *         'probably', 'maybe', or empty string\n   *\n   * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.canPlayType = function canPlayType() {\n    return '';\n  };\n\n  /**\n   * Check if the type is supported by this tech.\n   *\n   * The base tech does not support any type, but source handlers might\n   * overwrite this.\n   *\n   * @param {string} type\n   *        The media type to check\n   * @return {string} Returns the native video element's response\n   */\n\n\n  Tech.canPlayType = function canPlayType() {\n    return '';\n  };\n\n  /**\n   * Check if the tech can support the given source\n   * @param {Object} srcObj\n   *        The source object\n   * @param {Object} options\n   *        The options passed to the tech\n   * @return {string} 'probably', 'maybe', or '' (empty string)\n   */\n\n\n  Tech.canPlaySource = function canPlaySource(srcObj, options) {\n    return Tech.canPlayType(srcObj.type);\n  };\n\n  /*\n   * Return whether the argument is a Tech or not.\n   * Can be passed either a Class like `Html5` or a instance like `player.tech_`\n   *\n   * @param {Object} component\n   *        The item to check\n   *\n   * @return {boolean}\n   *         Whether it is a tech or not\n   *         - True if it is a tech\n   *         - False if it is not\n   */\n\n\n  Tech.isTech = function isTech(component) {\n    return component.prototype instanceof Tech || component instanceof Tech || component === Tech;\n  };\n\n  /**\n   * Registers a `Tech` into a shared list for videojs.\n   *\n   * @param {string} name\n   *        Name of the `Tech` to register.\n   *\n   * @param {Object} tech\n   *        The `Tech` class to register.\n   */\n\n\n  Tech.registerTech = function registerTech(name, tech) {\n    if (!Tech.techs_) {\n      Tech.techs_ = {};\n    }\n\n    if (!Tech.isTech(tech)) {\n      throw new Error('Tech ' + name + ' must be a Tech');\n    }\n\n    if (!Tech.canPlayType) {\n      throw new Error('Techs must have a static canPlayType method on them');\n    }\n    if (!Tech.canPlaySource) {\n      throw new Error('Techs must have a static canPlaySource method on them');\n    }\n\n    name = toTitleCase(name);\n\n    Tech.techs_[name] = tech;\n    if (name !== 'Tech') {\n      // camel case the techName for use in techOrder\n      Tech.defaultTechOrder_.push(name);\n    }\n    return tech;\n  };\n\n  /**\n   * Get a `Tech` from the shared list by name.\n   *\n   * @param {string} name\n   *        `camelCase` or `TitleCase` name of the Tech to get\n   *\n   * @return {Tech|undefined}\n   *         The `Tech` or undefined if there was no tech with the name requested.\n   */\n\n\n  Tech.getTech = function getTech(name) {\n    if (!name) {\n      return;\n    }\n\n    name = toTitleCase(name);\n\n    if (Tech.techs_ && Tech.techs_[name]) {\n      return Tech.techs_[name];\n    }\n\n    if (global_window__WEBPACK_IMPORTED_MODULE_0___default.a && global_window__WEBPACK_IMPORTED_MODULE_0___default.a.videojs && global_window__WEBPACK_IMPORTED_MODULE_0___default.a.videojs[name]) {\n      log$1.warn('The ' + name + ' tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)');\n      return global_window__WEBPACK_IMPORTED_MODULE_0___default.a.videojs[name];\n    }\n  };\n\n  return Tech;\n}(Component);\n\n/**\n * Get the {@link VideoTrackList}\n *\n * @returns {VideoTrackList}\n * @method Tech.prototype.videoTracks\n */\n\n/**\n * Get the {@link AudioTrackList}\n *\n * @returns {AudioTrackList}\n * @method Tech.prototype.audioTracks\n */\n\n/**\n * Get the {@link TextTrackList}\n *\n * @returns {TextTrackList}\n * @method Tech.prototype.textTracks\n */\n\n/**\n * Get the remote element {@link TextTrackList}\n *\n * @returns {TextTrackList}\n * @method Tech.prototype.remoteTextTracks\n */\n\n/**\n * Get the remote element {@link HtmlTrackElementList}\n *\n * @returns {HtmlTrackElementList}\n * @method Tech.prototype.remoteTextTrackEls\n */\n\nALL.names.forEach(function (name) {\n  var props = ALL[name];\n\n  Tech.prototype[props.getterName] = function () {\n    this[props.privateName] = this[props.privateName] || new props.ListClass();\n    return this[props.privateName];\n  };\n});\n\n/**\n * List of associated text tracks\n *\n * @type {TextTrackList}\n * @private\n * @property Tech#textTracks_\n */\n\n/**\n * List of associated audio tracks.\n *\n * @type {AudioTrackList}\n * @private\n * @property Tech#audioTracks_\n */\n\n/**\n * List of associated video tracks.\n *\n * @type {VideoTrackList}\n * @private\n * @property Tech#videoTracks_\n */\n\n/**\n * Boolean indicating whether the `Tech` supports volume control.\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresVolumeControl = true;\n\n/**\n * Boolean indicating whether the `Tech` supports muting volume.\n *\n * @type {bolean}\n * @default\n */\nTech.prototype.featuresMuteControl = true;\n\n/**\n * Boolean indicating whether the `Tech` supports fullscreen resize control.\n * Resizing plugins using request fullscreen reloads the plugin\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresFullscreenResize = false;\n\n/**\n * Boolean indicating whether the `Tech` supports changing the speed at which the video\n * plays. Examples:\n *   - Set player to play 2x (twice) as fast\n *   - Set player to play 0.5x (half) as fast\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresPlaybackRate = false;\n\n/**\n * Boolean indicating whether the `Tech` supports the `progress` event. This is currently\n * not triggered by video-js-swf. This will be used to determine if\n * {@link Tech#manualProgressOn} should be called.\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresProgressEvents = false;\n\n/**\n * Boolean indicating whether the `Tech` supports the `sourceset` event.\n *\n * A tech should set this to `true` and then use {@link Tech#triggerSourceset}\n * to trigger a {@link Tech#event:sourceset} at the earliest time after getting\n * a new source.\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresSourceset = false;\n\n/**\n * Boolean indicating whether the `Tech` supports the `timeupdate` event. This is currently\n * not triggered by video-js-swf. This will be used to determine if\n * {@link Tech#manualTimeUpdates} should be called.\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresTimeupdateEvents = false;\n\n/**\n * Boolean indicating whether the `Tech` supports the native `TextTrack`s.\n * This will help us integrate with native `TextTrack`s if the browser supports them.\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresNativeTextTracks = false;\n\n/**\n * A functional mixin for techs that want to use the Source Handler pattern.\n * Source handlers are scripts for handling specific formats.\n * The source handler pattern is used for adaptive formats (HLS, DASH) that\n * manually load video data and feed it into a Source Buffer (Media Source Extensions)\n * Example: `Tech.withSourceHandlers.call(MyTech);`\n *\n * @param {Tech} _Tech\n *        The tech to add source handler functions to.\n *\n * @mixes Tech~SourceHandlerAdditions\n */\nTech.withSourceHandlers = function (_Tech) {\n\n  /**\n   * Register a source handler\n   *\n   * @param {Function} handler\n   *        The source handler class\n   *\n   * @param {number} [index]\n   *        Register it at the following index\n   */\n  _Tech.registerSourceHandler = function (handler, index) {\n    var handlers = _Tech.sourceHandlers;\n\n    if (!handlers) {\n      handlers = _Tech.sourceHandlers = [];\n    }\n\n    if (index === undefined) {\n      // add to the end of the list\n      index = handlers.length;\n    }\n\n    handlers.splice(index, 0, handler);\n  };\n\n  /**\n   * Check if the tech can support the given type. Also checks the\n   * Techs sourceHandlers.\n   *\n   * @param {string} type\n   *         The mimetype to check.\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */\n  _Tech.canPlayType = function (type) {\n    var handlers = _Tech.sourceHandlers || [];\n    var can = void 0;\n\n    for (var i = 0; i < handlers.length; i++) {\n      can = handlers[i].canPlayType(type);\n\n      if (can) {\n        return can;\n      }\n    }\n\n    return '';\n  };\n\n  /**\n   * Returns the first source handler that supports the source.\n   *\n   * TODO: Answer question: should 'probably' be prioritized over 'maybe'\n   *\n   * @param {Tech~SourceObject} source\n   *        The source object\n   *\n   * @param {Object} options\n   *        The options passed to the tech\n   *\n   * @return {SourceHandler|null}\n   *          The first source handler that supports the source or null if\n   *          no SourceHandler supports the source\n   */\n  _Tech.selectSourceHandler = function (source, options) {\n    var handlers = _Tech.sourceHandlers || [];\n    var can = void 0;\n\n    for (var i = 0; i < handlers.length; i++) {\n      can = handlers[i].canHandleSource(source, options);\n\n      if (can) {\n        return handlers[i];\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Check if the tech can support the given source.\n   *\n   * @param {Tech~SourceObject} srcObj\n   *        The source object\n   *\n   * @param {Object} options\n   *        The options passed to the tech\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */\n  _Tech.canPlaySource = function (srcObj, options) {\n    var sh = _Tech.selectSourceHandler(srcObj, options);\n\n    if (sh) {\n      return sh.canHandleSource(srcObj, options);\n    }\n\n    return '';\n  };\n\n  /**\n   * When using a source handler, prefer its implementation of\n   * any function normally provided by the tech.\n   */\n  var deferrable = ['seekable', 'seeking', 'duration'];\n\n  /**\n   * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable\n   * function if it exists, with a fallback to the Techs seekable function.\n   *\n   * @method _Tech.seekable\n   */\n\n  /**\n   * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration\n   * function if it exists, otherwise it will fallback to the techs duration function.\n   *\n   * @method _Tech.duration\n   */\n\n  deferrable.forEach(function (fnName) {\n    var originalFn = this[fnName];\n\n    if (typeof originalFn !== 'function') {\n      return;\n    }\n\n    this[fnName] = function () {\n      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {\n        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);\n      }\n      return originalFn.apply(this, arguments);\n    };\n  }, _Tech.prototype);\n\n  /**\n   * Create a function for setting the source using a source object\n   * and source handlers.\n   * Should never be called unless a source handler was found.\n   *\n   * @param {Tech~SourceObject} source\n   *        A source object with src and type keys\n   */\n  _Tech.prototype.setSource = function (source) {\n    var sh = _Tech.selectSourceHandler(source, this.options_);\n\n    if (!sh) {\n      // Fall back to a native source hander when unsupported sources are\n      // deliberately set\n      if (_Tech.nativeSourceHandler) {\n        sh = _Tech.nativeSourceHandler;\n      } else {\n        log$1.error('No source handler found for the current source.');\n      }\n    }\n\n    // Dispose any existing source handler\n    this.disposeSourceHandler();\n    this.off('dispose', this.disposeSourceHandler);\n\n    if (sh !== _Tech.nativeSourceHandler) {\n      this.currentSource_ = source;\n    }\n\n    this.sourceHandler_ = sh.handleSource(source, this, this.options_);\n    this.on('dispose', this.disposeSourceHandler);\n  };\n\n  /**\n   * Clean up any existing SourceHandlers and listeners when the Tech is disposed.\n   *\n   * @listens Tech#dispose\n   */\n  _Tech.prototype.disposeSourceHandler = function () {\n    // if we have a source and get another one\n    // then we are loading something new\n    // than clear all of our current tracks\n    if (this.currentSource_) {\n      this.clearTracks(['audio', 'video']);\n      this.currentSource_ = null;\n    }\n\n    // always clean up auto-text tracks\n    this.cleanupAutoTextTracks();\n\n    if (this.sourceHandler_) {\n\n      if (this.sourceHandler_.dispose) {\n        this.sourceHandler_.dispose();\n      }\n\n      this.sourceHandler_ = null;\n    }\n  };\n};\n\n// The base Tech class needs to be registered as a Component. It is the only\n// Tech that can be registered as a Component.\nComponent.registerComponent('Tech', Tech);\nTech.registerTech('Tech', Tech);\n\n/**\n * A list of techs that should be added to techOrder on Players\n *\n * @private\n */\nTech.defaultTechOrder_ = [];\n\nvar middlewares = {};\nvar middlewareInstances = {};\n\nvar TERMINATOR = {};\n\nfunction use(type, middleware) {\n  middlewares[type] = middlewares[type] || [];\n  middlewares[type].push(middleware);\n}\n\nfunction setSource(player, src, next) {\n  player.setTimeout(function () {\n    return setSourceHelper(src, middlewares[src.type], next, player);\n  }, 1);\n}\n\nfunction setTech(middleware, tech) {\n  middleware.forEach(function (mw) {\n    return mw.setTech && mw.setTech(tech);\n  });\n}\n\n/**\n * Calls a getter on the tech first, through each middleware\n * from right to left to the player.\n */\nfunction get$1(middleware, tech, method) {\n  return middleware.reduceRight(middlewareIterator(method), tech[method]());\n}\n\n/**\n * Takes the argument given to the player and calls the setter method on each\n * middleware from left to right to the tech.\n */\nfunction set$1(middleware, tech, method, arg) {\n  return tech[method](middleware.reduce(middlewareIterator(method), arg));\n}\n\n/**\n * Takes the argument given to the player and calls the `call` version of the method\n * on each middleware from left to right.\n * Then, call the passed in method on the tech and return the result unchanged\n * back to the player, through middleware, this time from right to left.\n */\nfunction mediate(middleware, tech, method) {\n  var arg = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var callMethod = 'call' + toTitleCase(method);\n  var middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);\n  var terminated = middlewareValue === TERMINATOR;\n  var returnValue = terminated ? null : tech[method](middlewareValue);\n\n  executeRight(middleware, method, returnValue, terminated);\n\n  return returnValue;\n}\n\nvar allowedGetters = {\n  buffered: 1,\n  currentTime: 1,\n  duration: 1,\n  seekable: 1,\n  played: 1,\n  paused: 1\n};\n\nvar allowedSetters = {\n  setCurrentTime: 1\n};\n\nvar allowedMediators = {\n  play: 1,\n  pause: 1\n};\n\nfunction middlewareIterator(method) {\n  return function (value, mw) {\n    // if the previous middleware terminated, pass along the termination\n    if (value === TERMINATOR) {\n      return TERMINATOR;\n    }\n\n    if (mw[method]) {\n      return mw[method](value);\n    }\n\n    return value;\n  };\n}\n\nfunction executeRight(mws, method, value, terminated) {\n  for (var i = mws.length - 1; i >= 0; i--) {\n    var mw = mws[i];\n\n    if (mw[method]) {\n      mw[method](terminated, value);\n    }\n  }\n}\n\nfunction clearCacheForPlayer(player) {\n  middlewareInstances[player.id()] = null;\n}\n\n/**\n * {\n *  [playerId]: [[mwFactory, mwInstance], ...]\n * }\n */\nfunction getOrCreateFactory(player, mwFactory) {\n  var mws = middlewareInstances[player.id()];\n  var mw = null;\n\n  if (mws === undefined || mws === null) {\n    mw = mwFactory(player);\n    middlewareInstances[player.id()] = [[mwFactory, mw]];\n    return mw;\n  }\n\n  for (var i = 0; i < mws.length; i++) {\n    var _mws$i = mws[i],\n        mwf = _mws$i[0],\n        mwi = _mws$i[1];\n\n\n    if (mwf !== mwFactory) {\n      continue;\n    }\n\n    mw = mwi;\n  }\n\n  if (mw === null) {\n    mw = mwFactory(player);\n    mws.push([mwFactory, mw]);\n  }\n\n  return mw;\n}\n\nfunction setSourceHelper() {\n  var src = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var middleware = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var next = arguments[2];\n  var player = arguments[3];\n  var acc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var lastRun = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var mwFactory = middleware[0],\n      mwrest = middleware.slice(1);\n\n  // if mwFactory is a string, then we're at a fork in the road\n\n  if (typeof mwFactory === 'string') {\n    setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);\n\n    // if we have an mwFactory, call it with the player to get the mw,\n    // then call the mw's setSource method\n  } else if (mwFactory) {\n    var mw = getOrCreateFactory(player, mwFactory);\n\n    // if setSource isn't present, implicitly select this middleware\n    if (!mw.setSource) {\n      acc.push(mw);\n      return setSourceHelper(src, mwrest, next, player, acc, lastRun);\n    }\n\n    mw.setSource(assign({}, src), function (err, _src) {\n\n      // something happened, try the next middleware on the current level\n      // make sure to use the old src\n      if (err) {\n        return setSourceHelper(src, mwrest, next, player, acc, lastRun);\n      }\n\n      // we've succeeded, now we need to go deeper\n      acc.push(mw);\n\n      // if it's the same type, continue down the current chain\n      // otherwise, we want to go down the new chain\n      setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);\n    });\n  } else if (mwrest.length) {\n    setSourceHelper(src, mwrest, next, player, acc, lastRun);\n  } else if (lastRun) {\n    next(src, acc);\n  } else {\n    setSourceHelper(src, middlewares['*'], next, player, acc, true);\n  }\n}\n\n/**\n * Mimetypes\n *\n * @see http://hul.harvard.edu/ois/////systems/wax/wax-public-help/mimetypes.htm\n * @typedef Mimetypes~Kind\n * @enum\n */\nvar MimetypesKind = {\n  opus: 'video/ogg',\n  ogv: 'video/ogg',\n  mp4: 'video/mp4',\n  mov: 'video/mp4',\n  m4v: 'video/mp4',\n  mkv: 'video/x-matroska',\n  mp3: 'audio/mpeg',\n  aac: 'audio/aac',\n  oga: 'audio/ogg',\n  m3u8: 'application/x-mpegURL'\n};\n\n/**\n * Get the mimetype of a given src url if possible\n *\n * @param {string} src\n *        The url to the src\n *\n * @return {string}\n *         return the mimetype if it was known or empty string otherwise\n */\nvar getMimetype = function getMimetype() {\n  var src = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n  var ext = getFileExtension(src);\n  var mimetype = MimetypesKind[ext.toLowerCase()];\n\n  return mimetype || '';\n};\n\n/**\n * Find the mime type of a given source string if possible. Uses the player\n * source cache.\n *\n * @param {Player} player\n *        The player object\n *\n * @param {string} src\n *        The source string\n *\n * @return {string}\n *         The type that was found\n */\nvar findMimetype = function findMimetype(player, src) {\n  if (!src) {\n    return '';\n  }\n\n  // 1. check for the type in the `source` cache\n  if (player.cache_.source.src === src && player.cache_.source.type) {\n    return player.cache_.source.type;\n  }\n\n  // 2. see if we have this source in our `currentSources` cache\n  var matchingSources = player.cache_.sources.filter(function (s) {\n    return s.src === src;\n  });\n\n  if (matchingSources.length) {\n    return matchingSources[0].type;\n  }\n\n  // 3. look for the src url in source elements and use the type there\n  var sources = player.$$('source');\n\n  for (var i = 0; i < sources.length; i++) {\n    var s = sources[i];\n\n    if (s.type && s.src && s.src === src) {\n      return s.type;\n    }\n  }\n\n  // 4. finally fallback to our list of mime types based on src url extension\n  return getMimetype(src);\n};\n\n/**\n * @module filter-source\n */\n\n/**\n * Filter out single bad source objects or multiple source objects in an\n * array. Also flattens nested source object arrays into a 1 dimensional\n * array of source objects.\n *\n * @param {Tech~SourceObject|Tech~SourceObject[]} src\n *        The src object to filter\n *\n * @return {Tech~SourceObject[]}\n *         An array of sourceobjects containing only valid sources\n *\n * @private\n */\nvar filterSource = function filterSource(src) {\n  // traverse array\n  if (Array.isArray(src)) {\n    var newsrc = [];\n\n    src.forEach(function (srcobj) {\n      srcobj = filterSource(srcobj);\n\n      if (Array.isArray(srcobj)) {\n        newsrc = newsrc.concat(srcobj);\n      } else if (isObject(srcobj)) {\n        newsrc.push(srcobj);\n      }\n    });\n\n    src = newsrc;\n  } else if (typeof src === 'string' && src.trim()) {\n    // convert string into object\n    src = [fixSource({ src: src })];\n  } else if (isObject(src) && typeof src.src === 'string' && src.src && src.src.trim()) {\n    // src is already valid\n    src = [fixSource(src)];\n  } else {\n    // invalid source, turn it into an empty array\n    src = [];\n  }\n\n  return src;\n};\n\n/**\n * Checks src mimetype, adding it when possible\n *\n * @param {Tech~SourceObject} src\n *        The src object to check\n * @return {Tech~SourceObject}\n *        src Object with known type\n */\nfunction fixSource(src) {\n  var mimetype = getMimetype(src.src);\n\n  if (!src.type && mimetype) {\n    src.type = mimetype;\n  }\n\n  return src;\n}\n\n/**\n * @file loader.js\n */\n\n/**\n * The `MediaLoader` is the `Component` that decides which playback technology to load\n * when a player is initialized.\n *\n * @extends Component\n */\n\nvar MediaLoader = function (_Component) {\n  inherits(MediaLoader, _Component);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should attach to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function that is run when this component is ready.\n   */\n  function MediaLoader(player, options, ready) {\n    classCallCheck(this, MediaLoader);\n\n    // MediaLoader has no element\n    var options_ = mergeOptions({ createEl: false }, options);\n\n    // If there are no sources when the player is initialized,\n    // load the first supported playback technology.\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options_, ready));\n\n    if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {\n      for (var i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {\n        var techName = toTitleCase(j[i]);\n        var tech = Tech.getTech(techName);\n\n        // Support old behavior of techs being registered as components.\n        // Remove once that deprecated behavior is removed.\n        if (!techName) {\n          tech = Component.getComponent(techName);\n        }\n\n        // Check if the browser supports this technology\n        if (tech && tech.isSupported()) {\n          player.loadTech_(techName);\n          break;\n        }\n      }\n    } else {\n      // Loop through playback technologies (HTML5, Flash) and check for support.\n      // Then load the best source.\n      // A few assumptions here:\n      //   All playback technologies respect preload false.\n      player.src(options.playerOptions.sources);\n    }\n    return _this;\n  }\n\n  return MediaLoader;\n}(Component);\n\nComponent.registerComponent('MediaLoader', MediaLoader);\n\n/**\n * @file clickable-component.js\n */\n\n/**\n * Clickable Component which is clickable or keyboard actionable,\n * but is not a native HTML button.\n *\n * @extends Component\n */\n\nvar ClickableComponent = function (_Component) {\n  inherits(ClickableComponent, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */\n  function ClickableComponent(player, options) {\n    classCallCheck(this, ClickableComponent);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.emitTapEvents();\n\n    _this.enable();\n    return _this;\n  }\n\n  /**\n   * Create the `Component`s DOM element.\n   *\n   * @param {string} [tag=div]\n   *        The element's node type.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element.\n   *\n   * @param {Object} [attributes={}]\n   *        An object of attributes that should be set on the element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  ClickableComponent.prototype.createEl = function createEl$$1() {\n    var tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    props = assign({\n      innerHTML: '<span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>',\n      className: this.buildCSSClass(),\n      tabIndex: 0\n    }, props);\n\n    if (tag === 'button') {\n      log$1.error('Creating a ClickableComponent with an HTML element of ' + tag + ' is not supported; use a Button instead.');\n    }\n\n    // Add ARIA attributes for clickable element which is not a native HTML button\n    attributes = assign({\n      role: 'button'\n    }, attributes);\n\n    this.tabIndex_ = props.tabIndex;\n\n    var el = _Component.prototype.createEl.call(this, tag, props, attributes);\n\n    this.createControlTextEl(el);\n\n    return el;\n  };\n\n  ClickableComponent.prototype.dispose = function dispose() {\n    // remove controlTextEl_ on dispose\n    this.controlTextEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Create a control text element on this `Component`\n   *\n   * @param {Element} [el]\n   *        Parent element for the control text.\n   *\n   * @return {Element}\n   *         The control text element that gets created.\n   */\n\n\n  ClickableComponent.prototype.createControlTextEl = function createControlTextEl(el) {\n    this.controlTextEl_ = createEl('span', {\n      className: 'vjs-control-text'\n    }, {\n      // let the screen reader user know that the text of the element may change\n      'aria-live': 'polite'\n    });\n\n    if (el) {\n      el.appendChild(this.controlTextEl_);\n    }\n\n    this.controlText(this.controlText_, el);\n\n    return this.controlTextEl_;\n  };\n\n  /**\n   * Get or set the localize text to use for the controls on the `Component`.\n   *\n   * @param {string} [text]\n   *        Control text for element.\n   *\n   * @param {Element} [el=this.el()]\n   *        Element to set the title on.\n   *\n   * @return {string}\n   *         - The control text when getting\n   */\n\n\n  ClickableComponent.prototype.controlText = function controlText(text) {\n    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.el();\n\n    if (text === undefined) {\n      return this.controlText_ || 'Need Text';\n    }\n\n    var localizedText = this.localize(text);\n\n    this.controlText_ = text;\n    textContent(this.controlTextEl_, localizedText);\n    if (!this.nonIconControl) {\n      // Set title attribute if only an icon is shown\n      el.setAttribute('title', localizedText);\n    }\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  ClickableComponent.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-control vjs-button ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Enable this `Component`s element.\n   */\n\n\n  ClickableComponent.prototype.enable = function enable() {\n    if (!this.enabled_) {\n      this.enabled_ = true;\n      this.removeClass('vjs-disabled');\n      this.el_.setAttribute('aria-disabled', 'false');\n      if (typeof this.tabIndex_ !== 'undefined') {\n        this.el_.setAttribute('tabIndex', this.tabIndex_);\n      }\n      this.on(['tap', 'click'], this.handleClick);\n      this.on('focus', this.handleFocus);\n      this.on('blur', this.handleBlur);\n    }\n  };\n\n  /**\n   * Disable this `Component`s element.\n   */\n\n\n  ClickableComponent.prototype.disable = function disable() {\n    this.enabled_ = false;\n    this.addClass('vjs-disabled');\n    this.el_.setAttribute('aria-disabled', 'true');\n    if (typeof this.tabIndex_ !== 'undefined') {\n      this.el_.removeAttribute('tabIndex');\n    }\n    this.off(['tap', 'click'], this.handleClick);\n    this.off('focus', this.handleFocus);\n    this.off('blur', this.handleBlur);\n  };\n\n  /**\n   * This gets called when a `ClickableComponent` gets:\n   * - Clicked (via the `click` event, listening starts in the constructor)\n   * - Tapped (via the `tap` event, listening starts in the constructor)\n   * - The following things happen in order:\n   *   1. {@link ClickableComponent#handleFocus} is called via a `focus` event on the\n   *      `ClickableComponent`.\n   *   2. {@link ClickableComponent#handleFocus} adds a listener for `keydown` on using\n   *      {@link ClickableComponent#handleKeyPress}.\n   *   3. `ClickableComponent` has not had a `blur` event (`blur` means that focus was lost). The user presses\n   *      the space or enter key.\n   *   4. {@link ClickableComponent#handleKeyPress} calls this function with the `keydown`\n   *      event as a parameter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   * @abstract\n   */\n\n\n  ClickableComponent.prototype.handleClick = function handleClick(event) {};\n\n  /**\n   * This gets called when a `ClickableComponent` gains focus via a `focus` event.\n   * Turns on listening for `keydown` events. When they happen it\n   * calls `this.handleKeyPress`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to be called.\n   *\n   * @listens focus\n   */\n\n\n  ClickableComponent.prototype.handleFocus = function handleFocus(event) {\n    on(global_document__WEBPACK_IMPORTED_MODULE_1___default.a, 'keydown', bind(this, this.handleKeyPress));\n  };\n\n  /**\n   * Called when this ClickableComponent has focus and a key gets pressed down. By\n   * default it will call `this.handleClick` when the key is space or enter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n\n\n  ClickableComponent.prototype.handleKeyPress = function handleKeyPress(event) {\n\n    // Support Space (32) or Enter (13) key operation to fire a click event\n    if (event.which === 32 || event.which === 13) {\n      event.preventDefault();\n      this.trigger('click');\n    } else if (_Component.prototype.handleKeyPress) {\n\n      // Pass keypress handling up for unsupported keys\n      _Component.prototype.handleKeyPress.call(this, event);\n    }\n  };\n\n  /**\n   * Called when a `ClickableComponent` loses focus. Turns off the listener for\n   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to be called.\n   *\n   * @listens blur\n   */\n\n\n  ClickableComponent.prototype.handleBlur = function handleBlur(event) {\n    off(global_document__WEBPACK_IMPORTED_MODULE_1___default.a, 'keydown', bind(this, this.handleKeyPress));\n  };\n\n  return ClickableComponent;\n}(Component);\n\nComponent.registerComponent('ClickableComponent', ClickableComponent);\n\n/**\n * @file poster-image.js\n */\n\n/**\n * A `ClickableComponent` that handles showing the poster image for the player.\n *\n * @extends ClickableComponent\n */\n\nvar PosterImage = function (_ClickableComponent) {\n  inherits(PosterImage, _ClickableComponent);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should attach to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function PosterImage(player, options) {\n    classCallCheck(this, PosterImage);\n\n    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));\n\n    _this.update();\n    player.on('posterchange', bind(_this, _this.update));\n    return _this;\n  }\n\n  /**\n   * Clean up and dispose of the `PosterImage`.\n   */\n\n\n  PosterImage.prototype.dispose = function dispose() {\n    this.player().off('posterchange', this.update);\n    _ClickableComponent.prototype.dispose.call(this);\n  };\n\n  /**\n   * Create the `PosterImage`s DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  PosterImage.prototype.createEl = function createEl$$1() {\n    var el = createEl('div', {\n      className: 'vjs-poster',\n\n      // Don't want poster to be tabbable.\n      tabIndex: -1\n    });\n\n    return el;\n  };\n\n  /**\n   * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.\n   *\n   * @listens Player#posterchange\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `Player#posterchange` event that triggered this function.\n   */\n\n\n  PosterImage.prototype.update = function update(event) {\n    var url = this.player().poster();\n\n    this.setSrc(url);\n\n    // If there's no poster source we should display:none on this component\n    // so it's not still clickable or right-clickable\n    if (url) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  };\n\n  /**\n   * Set the source of the `PosterImage` depending on the display method.\n   *\n   * @param {string} url\n   *        The URL to the source for the `PosterImage`.\n   */\n\n\n  PosterImage.prototype.setSrc = function setSrc(url) {\n    var backgroundImage = '';\n\n    // Any falsy value should stay as an empty string, otherwise\n    // this will throw an extra error\n    if (url) {\n      backgroundImage = 'url(\"' + url + '\")';\n    }\n\n    this.el_.style.backgroundImage = backgroundImage;\n  };\n\n  /**\n   * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See\n   * {@link ClickableComponent#handleClick} for instances where this will be triggered.\n   *\n   * @listens tap\n   * @listens click\n   * @listens keydown\n   *\n   * @param {EventTarget~Event} event\n   +        The `click`, `tap` or `keydown` event that caused this function to be called.\n   */\n\n\n  PosterImage.prototype.handleClick = function handleClick(event) {\n    // We don't want a click to trigger playback when controls are disabled\n    if (!this.player_.controls()) {\n      return;\n    }\n\n    if (this.player_.paused()) {\n      silencePromise(this.player_.play());\n    } else {\n      this.player_.pause();\n    }\n  };\n\n  return PosterImage;\n}(ClickableComponent);\n\nComponent.registerComponent('PosterImage', PosterImage);\n\n/**\n * @file text-track-display.js\n */\n\nvar darkGray = '#222';\nvar lightGray = '#ccc';\nvar fontMap = {\n  monospace: 'monospace',\n  sansSerif: 'sans-serif',\n  serif: 'serif',\n  monospaceSansSerif: '\"Andale Mono\", \"Lucida Console\", monospace',\n  monospaceSerif: '\"Courier New\", monospace',\n  proportionalSansSerif: 'sans-serif',\n  proportionalSerif: 'serif',\n  casual: '\"Comic Sans MS\", Impact, fantasy',\n  script: '\"Monotype Corsiva\", cursive',\n  smallcaps: '\"Andale Mono\", \"Lucida Console\", monospace, sans-serif'\n};\n\n/**\n * Construct an rgba color from a given hex color code.\n *\n * @param {number} color\n *        Hex number for color, like #f0e or #f604e2.\n *\n * @param {number} opacity\n *        Value for opacity, 0.0 - 1.0.\n *\n * @return {string}\n *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.\n */\nfunction constructColor(color, opacity) {\n  var hex = void 0;\n\n  if (color.length === 4) {\n    // color looks like \"#f0e\"\n    hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];\n  } else if (color.length === 7) {\n    // color looks like \"#f604e2\"\n    hex = color.slice(1);\n  } else {\n    throw new Error('Invalid color code provided, ' + color + '; must be formatted as e.g. #f0e or #f604e2.');\n  }\n  return 'rgba(' + parseInt(hex.slice(0, 2), 16) + ',' + parseInt(hex.slice(2, 4), 16) + ',' + parseInt(hex.slice(4, 6), 16) + ',' + opacity + ')';\n}\n\n/**\n * Try to update the style of a DOM element. Some style changes will throw an error,\n * particularly in IE8. Those should be noops.\n *\n * @param {Element} el\n *        The DOM element to be styled.\n *\n * @param {string} style\n *        The CSS property on the element that should be styled.\n *\n * @param {string} rule\n *        The style rule that should be applied to the property.\n *\n * @private\n */\nfunction tryUpdateStyle(el, style, rule) {\n  try {\n    el.style[style] = rule;\n  } catch (e) {\n\n    // Satisfies linter.\n    return;\n  }\n}\n\n/**\n * The component for displaying text track cues.\n *\n * @extends Component\n */\n\nvar TextTrackDisplay = function (_Component) {\n  inherits(TextTrackDisplay, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when `TextTrackDisplay` is ready.\n   */\n  function TextTrackDisplay(player, options, ready) {\n    classCallCheck(this, TextTrackDisplay);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options, ready));\n\n    player.on('loadstart', bind(_this, _this.toggleDisplay));\n    player.on('texttrackchange', bind(_this, _this.updateDisplay));\n    player.on('loadstart', bind(_this, _this.preselectTrack));\n\n    // This used to be called during player init, but was causing an error\n    // if a track should show by default and the display hadn't loaded yet.\n    // Should probably be moved to an external track loader when we support\n    // tracks that don't need a display.\n    player.ready(bind(_this, function () {\n      if (player.tech_ && player.tech_.featuresNativeTextTracks) {\n        this.hide();\n        return;\n      }\n\n      player.on('fullscreenchange', bind(this, this.updateDisplay));\n\n      var tracks = this.options_.playerOptions.tracks || [];\n\n      for (var i = 0; i < tracks.length; i++) {\n        this.player_.addRemoteTextTrack(tracks[i], true);\n      }\n\n      this.preselectTrack();\n    }));\n    return _this;\n  }\n\n  /**\n  * Preselect a track following this precedence:\n  * - matches the previously selected {@link TextTrack}'s language and kind\n  * - matches the previously selected {@link TextTrack}'s language only\n  * - is the first default captions track\n  * - is the first default descriptions track\n  *\n  * @listens Player#loadstart\n  */\n\n\n  TextTrackDisplay.prototype.preselectTrack = function preselectTrack() {\n    var modes = { captions: 1, subtitles: 1 };\n    var trackList = this.player_.textTracks();\n    var userPref = this.player_.cache_.selectedLanguage;\n    var firstDesc = void 0;\n    var firstCaptions = void 0;\n    var preferredTrack = void 0;\n\n    for (var i = 0; i < trackList.length; i++) {\n      var track = trackList[i];\n\n      if (userPref && userPref.enabled && userPref.language === track.language) {\n        // Always choose the track that matches both language and kind\n        if (track.kind === userPref.kind) {\n          preferredTrack = track;\n          // or choose the first track that matches language\n        } else if (!preferredTrack) {\n          preferredTrack = track;\n        }\n\n        // clear everything if offTextTrackMenuItem was clicked\n      } else if (userPref && !userPref.enabled) {\n        preferredTrack = null;\n        firstDesc = null;\n        firstCaptions = null;\n      } else if (track.default) {\n        if (track.kind === 'descriptions' && !firstDesc) {\n          firstDesc = track;\n        } else if (track.kind in modes && !firstCaptions) {\n          firstCaptions = track;\n        }\n      }\n    }\n\n    // The preferredTrack matches the user preference and takes\n    // precedence over all the other tracks.\n    // So, display the preferredTrack before the first default track\n    // and the subtitles/captions track before the descriptions track\n    if (preferredTrack) {\n      preferredTrack.mode = 'showing';\n    } else if (firstCaptions) {\n      firstCaptions.mode = 'showing';\n    } else if (firstDesc) {\n      firstDesc.mode = 'showing';\n    }\n  };\n\n  /**\n   * Turn display of {@link TextTrack}'s from the current state into the other state.\n   * There are only two states:\n   * - 'shown'\n   * - 'hidden'\n   *\n   * @listens Player#loadstart\n   */\n\n\n  TextTrackDisplay.prototype.toggleDisplay = function toggleDisplay() {\n    if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  };\n\n  /**\n   * Create the {@link Component}'s DOM element.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  TextTrackDisplay.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-text-track-display'\n    }, {\n      'aria-live': 'off',\n      'aria-atomic': 'true'\n    });\n  };\n\n  /**\n   * Clear all displayed {@link TextTrack}s.\n   */\n\n\n  TextTrackDisplay.prototype.clearDisplay = function clearDisplay() {\n    if (typeof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.WebVTT === 'function') {\n      global_window__WEBPACK_IMPORTED_MODULE_0___default.a.WebVTT.processCues(global_window__WEBPACK_IMPORTED_MODULE_0___default.a, [], this.el_);\n    }\n  };\n\n  /**\n   * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or\n   * a {@link Player#fullscreenchange} is fired.\n   *\n   * @listens Player#texttrackchange\n   * @listens Player#fullscreenchange\n   */\n\n\n  TextTrackDisplay.prototype.updateDisplay = function updateDisplay() {\n    var tracks = this.player_.textTracks();\n\n    this.clearDisplay();\n\n    // Track display prioritization model: if multiple tracks are 'showing',\n    //  display the first 'subtitles' or 'captions' track which is 'showing',\n    //  otherwise display the first 'descriptions' track which is 'showing'\n\n    var descriptionsTrack = null;\n    var captionsSubtitlesTrack = null;\n    var i = tracks.length;\n\n    while (i--) {\n      var track = tracks[i];\n\n      if (track.mode === 'showing') {\n        if (track.kind === 'descriptions') {\n          descriptionsTrack = track;\n        } else {\n          captionsSubtitlesTrack = track;\n        }\n      }\n    }\n\n    if (captionsSubtitlesTrack) {\n      if (this.getAttribute('aria-live') !== 'off') {\n        this.setAttribute('aria-live', 'off');\n      }\n      this.updateForTrack(captionsSubtitlesTrack);\n    } else if (descriptionsTrack) {\n      if (this.getAttribute('aria-live') !== 'assertive') {\n        this.setAttribute('aria-live', 'assertive');\n      }\n      this.updateForTrack(descriptionsTrack);\n    }\n  };\n\n  /**\n   * Add an {@link TextTrack} to to the {@link Tech}s {@link TextTrackList}.\n   *\n   * @param {TextTrack} track\n   *        Text track object to be added to the list.\n   */\n\n\n  TextTrackDisplay.prototype.updateForTrack = function updateForTrack(track) {\n    if (typeof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.WebVTT !== 'function' || !track.activeCues) {\n      return;\n    }\n\n    var cues = [];\n\n    for (var _i = 0; _i < track.activeCues.length; _i++) {\n      cues.push(track.activeCues[_i]);\n    }\n\n    global_window__WEBPACK_IMPORTED_MODULE_0___default.a.WebVTT.processCues(global_window__WEBPACK_IMPORTED_MODULE_0___default.a, cues, this.el_);\n\n    if (!this.player_.textTrackSettings) {\n      return;\n    }\n\n    var overrides = this.player_.textTrackSettings.getValues();\n\n    var i = cues.length;\n\n    while (i--) {\n      var cue = cues[i];\n\n      if (!cue) {\n        continue;\n      }\n\n      var cueDiv = cue.displayState;\n\n      if (overrides.color) {\n        cueDiv.firstChild.style.color = overrides.color;\n      }\n      if (overrides.textOpacity) {\n        tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));\n      }\n      if (overrides.backgroundColor) {\n        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;\n      }\n      if (overrides.backgroundOpacity) {\n        tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));\n      }\n      if (overrides.windowColor) {\n        if (overrides.windowOpacity) {\n          tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));\n        } else {\n          cueDiv.style.backgroundColor = overrides.windowColor;\n        }\n      }\n      if (overrides.edgeStyle) {\n        if (overrides.edgeStyle === 'dropshadow') {\n          cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;\n        } else if (overrides.edgeStyle === 'raised') {\n          cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;\n        } else if (overrides.edgeStyle === 'depressed') {\n          cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;\n        } else if (overrides.edgeStyle === 'uniform') {\n          cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;\n        }\n      }\n      if (overrides.fontPercent && overrides.fontPercent !== 1) {\n        var fontSize = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.parseFloat(cueDiv.style.fontSize);\n\n        cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';\n        cueDiv.style.height = 'auto';\n        cueDiv.style.top = 'auto';\n        cueDiv.style.bottom = '2px';\n      }\n      if (overrides.fontFamily && overrides.fontFamily !== 'default') {\n        if (overrides.fontFamily === 'small-caps') {\n          cueDiv.firstChild.style.fontVariant = 'small-caps';\n        } else {\n          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];\n        }\n      }\n    }\n  };\n\n  return TextTrackDisplay;\n}(Component);\n\nComponent.registerComponent('TextTrackDisplay', TextTrackDisplay);\n\n/**\n * @file loading-spinner.js\n */\n\n/**\n * A loading spinner for use during waiting/loading events.\n *\n * @extends Component\n */\n\nvar LoadingSpinner = function (_Component) {\n  inherits(LoadingSpinner, _Component);\n\n  function LoadingSpinner() {\n    classCallCheck(this, LoadingSpinner);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the `LoadingSpinner`s DOM element.\n   *\n   * @return {Element}\n   *         The dom element that gets created.\n   */\n  LoadingSpinner.prototype.createEl = function createEl$$1() {\n    var isAudio = this.player_.isAudio();\n    var playerType = this.localize(isAudio ? 'Audio Player' : 'Video Player');\n    var controlText = createEl('span', {\n      className: 'vjs-control-text',\n      innerHTML: this.localize('{1} is loading.', [playerType])\n    });\n\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-loading-spinner',\n      dir: 'ltr'\n    });\n\n    el.appendChild(controlText);\n\n    return el;\n  };\n\n  return LoadingSpinner;\n}(Component);\n\nComponent.registerComponent('LoadingSpinner', LoadingSpinner);\n\n/**\n * @file button.js\n */\n\n/**\n * Base class for all buttons.\n *\n * @extends ClickableComponent\n */\n\nvar Button = function (_ClickableComponent) {\n  inherits(Button, _ClickableComponent);\n\n  function Button() {\n    classCallCheck(this, Button);\n    return possibleConstructorReturn(this, _ClickableComponent.apply(this, arguments));\n  }\n\n  /**\n   * Create the `Button`s DOM element.\n   *\n   * @param {string} [tag=\"button\"]\n   *        The element's node type. This argument is IGNORED: no matter what\n   *        is passed, it will always create a `button` element.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element.\n   *\n   * @param {Object} [attributes={}]\n   *        An object of attributes that should be set on the element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n  Button.prototype.createEl = function createEl(tag) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    tag = 'button';\n\n    props = assign({\n      innerHTML: '<span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>',\n      className: this.buildCSSClass()\n    }, props);\n\n    // Add attributes for button element\n    attributes = assign({\n\n      // Necessary since the default button type is \"submit\"\n      type: 'button'\n    }, attributes);\n\n    var el = Component.prototype.createEl.call(this, tag, props, attributes);\n\n    this.createControlTextEl(el);\n\n    return el;\n  };\n\n  /**\n   * Add a child `Component` inside of this `Button`.\n   *\n   * @param {string|Component} child\n   *        The name or instance of a child to add.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of options that will get passed to children of\n   *        the child.\n   *\n   * @return {Component}\n   *         The `Component` that gets added as a child. When using a string the\n   *         `Component` will get created by this process.\n   *\n   * @deprecated since version 5\n   */\n\n\n  Button.prototype.addChild = function addChild(child) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var className = this.constructor.name;\n\n    log$1.warn('Adding an actionable (user controllable) child to a Button (' + className + ') is not supported; use a ClickableComponent instead.');\n\n    // Avoid the error message generated by ClickableComponent's addChild method\n    return Component.prototype.addChild.call(this, child, options);\n  };\n\n  /**\n   * Enable the `Button` element so that it can be activated or clicked. Use this with\n   * {@link Button#disable}.\n   */\n\n\n  Button.prototype.enable = function enable() {\n    _ClickableComponent.prototype.enable.call(this);\n    this.el_.removeAttribute('disabled');\n  };\n\n  /**\n   * Disable the `Button` element so that it cannot be activated or clicked. Use this with\n   * {@link Button#enable}.\n   */\n\n\n  Button.prototype.disable = function disable() {\n    _ClickableComponent.prototype.disable.call(this);\n    this.el_.setAttribute('disabled', 'disabled');\n  };\n\n  /**\n   * This gets called when a `Button` has focus and `keydown` is triggered via a key\n   * press.\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to get called.\n   *\n   * @listens keydown\n   */\n\n\n  Button.prototype.handleKeyPress = function handleKeyPress(event) {\n\n    // Ignore Space (32) or Enter (13) key operation, which is handled by the browser for a button.\n    if (event.which === 32 || event.which === 13) {\n      return;\n    }\n\n    // Pass keypress handling up for unsupported keys\n    _ClickableComponent.prototype.handleKeyPress.call(this, event);\n  };\n\n  return Button;\n}(ClickableComponent);\n\nComponent.registerComponent('Button', Button);\n\n/**\n * @file big-play-button.js\n */\n\n/**\n * The initial play button that shows before the video has played. The hiding of the\n * `BigPlayButton` get done via CSS and `Player` states.\n *\n * @extends Button\n */\n\nvar BigPlayButton = function (_Button) {\n  inherits(BigPlayButton, _Button);\n\n  function BigPlayButton(player, options) {\n    classCallCheck(this, BigPlayButton);\n\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    _this.mouseused_ = false;\n\n    _this.on('mousedown', _this.handleMouseDown);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.\n   */\n\n\n  BigPlayButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-big-play-button';\n  };\n\n  /**\n   * This gets called when a `BigPlayButton` \"clicked\". See {@link ClickableComponent}\n   * for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  BigPlayButton.prototype.handleClick = function handleClick(event) {\n    var playPromise = this.player_.play();\n\n    // exit early if clicked via the mouse\n    if (this.mouseused_ && event.clientX && event.clientY) {\n      silencePromise(playPromise);\n      return;\n    }\n\n    var cb = this.player_.getChild('controlBar');\n    var playToggle = cb && cb.getChild('playToggle');\n\n    if (!playToggle) {\n      this.player_.focus();\n      return;\n    }\n\n    var playFocus = function playFocus() {\n      return playToggle.focus();\n    };\n\n    if (isPromise(playPromise)) {\n      playPromise.then(playFocus, function () {});\n    } else {\n      this.setTimeout(playFocus, 1);\n    }\n  };\n\n  BigPlayButton.prototype.handleKeyPress = function handleKeyPress(event) {\n    this.mouseused_ = false;\n\n    _Button.prototype.handleKeyPress.call(this, event);\n  };\n\n  BigPlayButton.prototype.handleMouseDown = function handleMouseDown(event) {\n    this.mouseused_ = true;\n  };\n\n  return BigPlayButton;\n}(Button);\n\n/**\n * The text that should display over the `BigPlayButton`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */\n\n\nBigPlayButton.prototype.controlText_ = 'Play Video';\n\nComponent.registerComponent('BigPlayButton', BigPlayButton);\n\n/**\n * @file close-button.js\n */\n\n/**\n * The `CloseButton` is a `{@link Button}` that fires a `close` event when\n * it gets clicked.\n *\n * @extends Button\n */\n\nvar CloseButton = function (_Button) {\n  inherits(CloseButton, _Button);\n\n  /**\n   * Creates an instance of the this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */\n  function CloseButton(player, options) {\n    classCallCheck(this, CloseButton);\n\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    _this.controlText(options && options.controlText || _this.localize('Close'));\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  CloseButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-close-button ' + _Button.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * This gets called when a `CloseButton` gets clicked. See\n   * {@link ClickableComponent#handleClick} for more information on when this will be\n   * triggered\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   * @fires CloseButton#close\n   */\n\n\n  CloseButton.prototype.handleClick = function handleClick(event) {\n\n    /**\n     * Triggered when the a `CloseButton` is clicked.\n     *\n     * @event CloseButton#close\n     * @type {EventTarget~Event}\n     *\n     * @property {boolean} [bubbles=false]\n     *           set to false so that the close event does not\n     *           bubble up to parents if there is no listener\n     */\n    this.trigger({ type: 'close', bubbles: false });\n  };\n\n  return CloseButton;\n}(Button);\n\nComponent.registerComponent('CloseButton', CloseButton);\n\n/**\n * @file play-toggle.js\n */\n\n/**\n * Button to toggle between play and pause.\n *\n * @extends Button\n */\n\nvar PlayToggle = function (_Button) {\n  inherits(PlayToggle, _Button);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function PlayToggle(player, options) {\n    classCallCheck(this, PlayToggle);\n\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    _this.on(player, 'play', _this.handlePlay);\n    _this.on(player, 'pause', _this.handlePause);\n    _this.on(player, 'ended', _this.handleEnded);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  PlayToggle.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-play-control ' + _Button.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * This gets called when an `PlayToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  PlayToggle.prototype.handleClick = function handleClick(event) {\n    if (this.player_.paused()) {\n      this.player_.play();\n    } else {\n      this.player_.pause();\n    }\n  };\n\n  /**\n   * This gets called once after the video has ended and the user seeks so that\n   * we can change the replay button back to a play button.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#seeked\n   */\n\n\n  PlayToggle.prototype.handleSeeked = function handleSeeked(event) {\n    this.removeClass('vjs-ended');\n\n    if (this.player_.paused()) {\n      this.handlePause(event);\n    } else {\n      this.handlePlay(event);\n    }\n  };\n\n  /**\n   * Add the vjs-playing class to the element so it can change appearance.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#play\n   */\n\n\n  PlayToggle.prototype.handlePlay = function handlePlay(event) {\n    this.removeClass('vjs-ended');\n    this.removeClass('vjs-paused');\n    this.addClass('vjs-playing');\n    // change the button text to \"Pause\"\n    this.controlText('Pause');\n  };\n\n  /**\n   * Add the vjs-paused class to the element so it can change appearance.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#pause\n   */\n\n\n  PlayToggle.prototype.handlePause = function handlePause(event) {\n    this.removeClass('vjs-playing');\n    this.addClass('vjs-paused');\n    // change the button text to \"Play\"\n    this.controlText('Play');\n  };\n\n  /**\n   * Add the vjs-ended class to the element so it can change appearance\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#ended\n   */\n\n\n  PlayToggle.prototype.handleEnded = function handleEnded(event) {\n    this.removeClass('vjs-playing');\n    this.addClass('vjs-ended');\n    // change the button text to \"Replay\"\n    this.controlText('Replay');\n\n    // on the next seek remove the replay button\n    this.one(this.player_, 'seeked', this.handleSeeked);\n  };\n\n  return PlayToggle;\n}(Button);\n\n/**\n * The text that should display over the `PlayToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nPlayToggle.prototype.controlText_ = 'Play';\n\nComponent.registerComponent('PlayToggle', PlayToggle);\n\n/**\n * @file format-time.js\n * @module format-time\n */\n\n/**\n* Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in seconds)\n* will force a number of leading zeros to cover the length of the guide.\n*\n* @param {number} seconds\n*        Number of seconds to be turned into a string\n*\n* @param {number} guide\n*        Number (in seconds) to model the string after\n*\n* @return {string}\n*         Time formatted as H:MM:SS or M:SS\n*/\nvar defaultImplementation = function defaultImplementation(seconds, guide) {\n  seconds = seconds < 0 ? 0 : seconds;\n  var s = Math.floor(seconds % 60);\n  var m = Math.floor(seconds / 60 % 60);\n  var h = Math.floor(seconds / 3600);\n  var gm = Math.floor(guide / 60 % 60);\n  var gh = Math.floor(guide / 3600);\n\n  // handle invalid times\n  if (isNaN(seconds) || seconds === Infinity) {\n    // '-' is false for all relational operators (e.g. <, >=) so this setting\n    // will add the minimum number of fields specified by the guide\n    h = m = s = '-';\n  }\n\n  // Check if we need to show hours\n  h = h > 0 || gh > 0 ? h + ':' : '';\n\n  // If hours are showing, we may need to add a leading zero.\n  // Always show at least one digit of minutes.\n  m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';\n\n  // Check if leading zero is need for seconds\n  s = s < 10 ? '0' + s : s;\n\n  return h + m + s;\n};\n\nvar implementation = defaultImplementation;\n\n/**\n * Replaces the default formatTime implementation with a custom implementation.\n *\n * @param {Function} customImplementation\n *        A function which will be used in place of the default formatTime implementation.\n *        Will receive the current time in seconds and the guide (in seconds) as arguments.\n */\nfunction setFormatTime(customImplementation) {\n  implementation = customImplementation;\n}\n\n/**\n * Resets formatTime to the default implementation.\n */\nfunction resetFormatTime() {\n  implementation = defaultImplementation;\n}\n\nfunction formatTime (seconds) {\n  var guide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : seconds;\n\n  return implementation(seconds, guide);\n}\n\n/**\n * @file time-display.js\n */\n\n/**\n * Displays the time left in the video\n *\n * @extends Component\n */\n\nvar TimeDisplay = function (_Component) {\n  inherits(TimeDisplay, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function TimeDisplay(player, options) {\n    classCallCheck(this, TimeDisplay);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);\n    _this.on(player, 'timeupdate', _this.throttledUpdateContent);\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  TimeDisplay.prototype.createEl = function createEl$$1(plainName) {\n    var className = this.buildCSSClass();\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      className: className + ' vjs-time-control vjs-control',\n      innerHTML: '<span class=\"vjs-control-text\">' + this.localize(this.labelText_) + '\\xA0</span>'\n    });\n\n    this.contentEl_ = createEl('span', {\n      className: className + '-display'\n    }, {\n      // tell screen readers not to automatically read the time as it changes\n      'aria-live': 'off'\n    });\n\n    this.updateTextNode_();\n    el.appendChild(this.contentEl_);\n    return el;\n  };\n\n  TimeDisplay.prototype.dispose = function dispose() {\n    this.contentEl_ = null;\n    this.textNode_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Updates the \"remaining time\" text node with new content using the\n   * contents of the `formattedTime_` property.\n   *\n   * @private\n   */\n\n\n  TimeDisplay.prototype.updateTextNode_ = function updateTextNode_() {\n    if (!this.contentEl_) {\n      return;\n    }\n\n    while (this.contentEl_.firstChild) {\n      this.contentEl_.removeChild(this.contentEl_.firstChild);\n    }\n\n    this.textNode_ = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createTextNode(this.formattedTime_ || this.formatTime_(0));\n    this.contentEl_.appendChild(this.textNode_);\n  };\n\n  /**\n   * Generates a formatted time for this component to use in display.\n   *\n   * @param  {number} time\n   *         A numeric time, in seconds.\n   *\n   * @return {string}\n   *         A formatted time\n   *\n   * @private\n   */\n\n\n  TimeDisplay.prototype.formatTime_ = function formatTime_(time) {\n    return formatTime(time);\n  };\n\n  /**\n   * Updates the time display text node if it has what was passed in changed\n   * the formatted time.\n   *\n   * @param {number} time\n   *        The time to update to\n   *\n   * @private\n   */\n\n\n  TimeDisplay.prototype.updateFormattedTime_ = function updateFormattedTime_(time) {\n    var formattedTime = this.formatTime_(time);\n\n    if (formattedTime === this.formattedTime_) {\n      return;\n    }\n\n    this.formattedTime_ = formattedTime;\n    this.requestAnimationFrame(this.updateTextNode_);\n  };\n\n  /**\n   * To be filled out in the child class, should update the displayed time\n   * in accordance with the fact that the current time has changed.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate`  event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   */\n\n\n  TimeDisplay.prototype.updateContent = function updateContent(event) {};\n\n  return TimeDisplay;\n}(Component);\n\n/**\n * The text that is added to the `TimeDisplay` for screen reader users.\n *\n * @type {string}\n * @private\n */\n\n\nTimeDisplay.prototype.labelText_ = 'Time';\n\n/**\n * The text that should display over the `TimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n *\n * @deprecated in v7; controlText_ is not used in non-active display Components\n */\nTimeDisplay.prototype.controlText_ = 'Time';\n\nComponent.registerComponent('TimeDisplay', TimeDisplay);\n\n/**\n * @file current-time-display.js\n */\n\n/**\n * Displays the current time\n *\n * @extends Component\n */\n\nvar CurrentTimeDisplay = function (_TimeDisplay) {\n  inherits(CurrentTimeDisplay, _TimeDisplay);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function CurrentTimeDisplay(player, options) {\n    classCallCheck(this, CurrentTimeDisplay);\n\n    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));\n\n    _this.on(player, 'ended', _this.handleEnded);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  CurrentTimeDisplay.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-current-time';\n  };\n\n  /**\n   * Update current time display\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` event that caused this function to run.\n   *\n   * @listens Player#timeupdate\n   */\n\n\n  CurrentTimeDisplay.prototype.updateContent = function updateContent(event) {\n    // Allows for smooth scrubbing, when player can't keep up.\n    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n\n    this.updateFormattedTime_(time);\n  };\n\n  /**\n   * When the player fires ended there should be no time left. Sadly\n   * this is not always the case, lets make it seem like that is the case\n   * for users.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */\n\n\n  CurrentTimeDisplay.prototype.handleEnded = function handleEnded(event) {\n    if (!this.player_.duration()) {\n      return;\n    }\n    this.updateFormattedTime_(this.player_.duration());\n  };\n\n  return CurrentTimeDisplay;\n}(TimeDisplay);\n\n/**\n * The text that is added to the `CurrentTimeDisplay` for screen reader users.\n *\n * @type {string}\n * @private\n */\n\n\nCurrentTimeDisplay.prototype.labelText_ = 'Current Time';\n\n/**\n * The text that should display over the `CurrentTimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n *\n * @deprecated in v7; controlText_ is not used in non-active display Components\n */\nCurrentTimeDisplay.prototype.controlText_ = 'Current Time';\n\nComponent.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);\n\n/**\n * @file duration-display.js\n */\n\n/**\n * Displays the duration\n *\n * @extends Component\n */\n\nvar DurationDisplay = function (_TimeDisplay) {\n  inherits(DurationDisplay, _TimeDisplay);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function DurationDisplay(player, options) {\n    classCallCheck(this, DurationDisplay);\n\n    // we do not want to/need to throttle duration changes,\n    // as they should always display the changed duration as\n    // it has changed\n    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));\n\n    _this.on(player, 'durationchange', _this.updateContent);\n\n    // Also listen for timeupdate (in the parent) and loadedmetadata because removing those\n    // listeners could have broken dependent applications/libraries. These\n    // can likely be removed for 7.0.\n    _this.on(player, 'loadedmetadata', _this.throttledUpdateContent);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  DurationDisplay.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-duration';\n  };\n\n  /**\n   * Update duration time display.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused\n   *        this function to be called.\n   *\n   * @listens Player#durationchange\n   * @listens Player#timeupdate\n   * @listens Player#loadedmetadata\n   */\n\n\n  DurationDisplay.prototype.updateContent = function updateContent(event) {\n    var duration = this.player_.duration();\n\n    if (duration && this.duration_ !== duration) {\n      this.duration_ = duration;\n      this.updateFormattedTime_(duration);\n    }\n  };\n\n  return DurationDisplay;\n}(TimeDisplay);\n\n/**\n * The text that is added to the `DurationDisplay` for screen reader users.\n *\n * @type {string}\n * @private\n */\n\n\nDurationDisplay.prototype.labelText_ = 'Duration';\n\n/**\n * The text that should display over the `DurationDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n *\n * @deprecated in v7; controlText_ is not used in non-active display Components\n */\nDurationDisplay.prototype.controlText_ = 'Duration';\n\nComponent.registerComponent('DurationDisplay', DurationDisplay);\n\n/**\n * @file time-divider.js\n */\n\n/**\n * The separator between the current time and duration.\n * Can be hidden if it's not needed in the design.\n *\n * @extends Component\n */\n\nvar TimeDivider = function (_Component) {\n  inherits(TimeDivider, _Component);\n\n  function TimeDivider() {\n    classCallCheck(this, TimeDivider);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the component's DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  TimeDivider.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-time-control vjs-time-divider',\n      innerHTML: '<div><span>/</span></div>'\n    });\n  };\n\n  return TimeDivider;\n}(Component);\n\nComponent.registerComponent('TimeDivider', TimeDivider);\n\n/**\n * @file remaining-time-display.js\n */\n/**\n * Displays the time left in the video\n *\n * @extends Component\n */\n\nvar RemainingTimeDisplay = function (_TimeDisplay) {\n  inherits(RemainingTimeDisplay, _TimeDisplay);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function RemainingTimeDisplay(player, options) {\n    classCallCheck(this, RemainingTimeDisplay);\n\n    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));\n\n    _this.on(player, 'durationchange', _this.throttledUpdateContent);\n    _this.on(player, 'ended', _this.handleEnded);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  RemainingTimeDisplay.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-remaining-time';\n  };\n\n  /**\n   * The remaining time display prefixes numbers with a \"minus\" character.\n   *\n   * @param  {number} time\n   *         A numeric time, in seconds.\n   *\n   * @return {string}\n   *         A formatted time\n   *\n   * @private\n   */\n\n\n  RemainingTimeDisplay.prototype.formatTime_ = function formatTime_(time) {\n    // TODO: The \"-\" should be decorative, and not announced by a screen reader\n    return '-' + _TimeDisplay.prototype.formatTime_.call(this, time);\n  };\n\n  /**\n   * Update remaining time display.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `durationchange` event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   * @listens Player#durationchange\n   */\n\n\n  RemainingTimeDisplay.prototype.updateContent = function updateContent(event) {\n    if (!this.player_.duration()) {\n      return;\n    }\n\n    // @deprecated We should only use remainingTimeDisplay\n    // as of video.js 7\n    if (this.player_.remainingTimeDisplay) {\n      this.updateFormattedTime_(this.player_.remainingTimeDisplay());\n    } else {\n      this.updateFormattedTime_(this.player_.remainingTime());\n    }\n  };\n\n  /**\n   * When the player fires ended there should be no time left. Sadly\n   * this is not always the case, lets make it seem like that is the case\n   * for users.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */\n\n\n  RemainingTimeDisplay.prototype.handleEnded = function handleEnded(event) {\n    if (!this.player_.duration()) {\n      return;\n    }\n    this.updateFormattedTime_(0);\n  };\n\n  return RemainingTimeDisplay;\n}(TimeDisplay);\n\n/**\n * The text that is added to the `RemainingTimeDisplay` for screen reader users.\n *\n * @type {string}\n * @private\n */\n\n\nRemainingTimeDisplay.prototype.labelText_ = 'Remaining Time';\n\n/**\n * The text that should display over the `RemainingTimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n *\n * @deprecated in v7; controlText_ is not used in non-active display Components\n */\nRemainingTimeDisplay.prototype.controlText_ = 'Remaining Time';\n\nComponent.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);\n\n/**\n * @file live-display.js\n */\n\n// TODO - Future make it click to snap to live\n\n/**\n * Displays the live indicator when duration is Infinity.\n *\n * @extends Component\n */\n\nvar LiveDisplay = function (_Component) {\n  inherits(LiveDisplay, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function LiveDisplay(player, options) {\n    classCallCheck(this, LiveDisplay);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.updateShowing();\n    _this.on(_this.player(), 'durationchange', _this.updateShowing);\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  LiveDisplay.prototype.createEl = function createEl$$1() {\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-live-control vjs-control'\n    });\n\n    this.contentEl_ = createEl('div', {\n      className: 'vjs-live-display',\n      innerHTML: '<span class=\"vjs-control-text\">' + this.localize('Stream Type') + '\\xA0</span>' + this.localize('LIVE')\n    }, {\n      'aria-live': 'off'\n    });\n\n    el.appendChild(this.contentEl_);\n    return el;\n  };\n\n  LiveDisplay.prototype.dispose = function dispose() {\n    this.contentEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide\n   * it accordingly\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#durationchange} event that caused this function to run.\n   *\n   * @listens Player#durationchange\n   */\n\n\n  LiveDisplay.prototype.updateShowing = function updateShowing(event) {\n    if (this.player().duration() === Infinity) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  };\n\n  return LiveDisplay;\n}(Component);\n\nComponent.registerComponent('LiveDisplay', LiveDisplay);\n\n/**\n * @file slider.js\n */\n\n/**\n * The base functionality for a slider. Can be vertical or horizontal.\n * For instance the volume bar or the seek bar on a video is a slider.\n *\n * @extends Component\n */\n\nvar Slider = function (_Component) {\n  inherits(Slider, _Component);\n\n  /**\n   * Create an instance of this class\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function Slider(player, options) {\n    classCallCheck(this, Slider);\n\n    // Set property names to bar to match with the child Slider class is looking for\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.bar = _this.getChild(_this.options_.barName);\n\n    // Set a horizontal or vertical class on the slider depending on the slider type\n    _this.vertical(!!_this.options_.vertical);\n\n    _this.enable();\n    return _this;\n  }\n\n  /**\n   * Are controls are currently enabled for this slider or not.\n   *\n   * @return {boolean}\n   *         true if controls are enabled, false otherwise\n   */\n\n\n  Slider.prototype.enabled = function enabled() {\n    return this.enabled_;\n  };\n\n  /**\n   * Enable controls for this slider if they are disabled\n   */\n\n\n  Slider.prototype.enable = function enable() {\n    if (this.enabled()) {\n      return;\n    }\n\n    this.on('mousedown', this.handleMouseDown);\n    this.on('touchstart', this.handleMouseDown);\n    this.on('focus', this.handleFocus);\n    this.on('blur', this.handleBlur);\n    this.on('click', this.handleClick);\n\n    this.on(this.player_, 'controlsvisible', this.update);\n\n    if (this.playerEvent) {\n      this.on(this.player_, this.playerEvent, this.update);\n    }\n\n    this.removeClass('disabled');\n    this.setAttribute('tabindex', 0);\n\n    this.enabled_ = true;\n  };\n\n  /**\n   * Disable controls for this slider if they are enabled\n   */\n\n\n  Slider.prototype.disable = function disable() {\n    if (!this.enabled()) {\n      return;\n    }\n    var doc = this.bar.el_.ownerDocument;\n\n    this.off('mousedown', this.handleMouseDown);\n    this.off('touchstart', this.handleMouseDown);\n    this.off('focus', this.handleFocus);\n    this.off('blur', this.handleBlur);\n    this.off('click', this.handleClick);\n    this.off(this.player_, 'controlsvisible', this.update);\n    this.off(doc, 'mousemove', this.handleMouseMove);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchmove', this.handleMouseMove);\n    this.off(doc, 'touchend', this.handleMouseUp);\n    this.removeAttribute('tabindex');\n\n    this.addClass('disabled');\n\n    if (this.playerEvent) {\n      this.off(this.player_, this.playerEvent, this.update);\n    }\n    this.enabled_ = false;\n  };\n\n  /**\n   * Create the `Slider`s DOM element.\n   *\n   * @param {string} type\n   *        Type of element to create.\n   *\n   * @param {Object} [props={}]\n   *        List of properties in Object form.\n   *\n   * @param {Object} [attributes={}]\n   *        list of attributes in Object form.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  Slider.prototype.createEl = function createEl$$1(type) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    // Add the slider element class to all sub classes\n    props.className = props.className + ' vjs-slider';\n    props = assign({\n      tabIndex: 0\n    }, props);\n\n    attributes = assign({\n      'role': 'slider',\n      'aria-valuenow': 0,\n      'aria-valuemin': 0,\n      'aria-valuemax': 100,\n      'tabIndex': 0\n    }, attributes);\n\n    return _Component.prototype.createEl.call(this, type, props, attributes);\n  };\n\n  /**\n   * Handle `mousedown` or `touchstart` events on the `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   * @fires Slider#slideractive\n   */\n\n\n  Slider.prototype.handleMouseDown = function handleMouseDown(event) {\n    var doc = this.bar.el_.ownerDocument;\n\n    if (event.type === 'mousedown') {\n      event.preventDefault();\n    }\n    // Do not call preventDefault() on touchstart in Chrome\n    // to avoid console warnings. Use a 'touch-action: none' style\n    // instead to prevent unintented scrolling.\n    // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n    if (event.type === 'touchstart' && !IS_CHROME) {\n      event.preventDefault();\n    }\n    blockTextSelection();\n\n    this.addClass('vjs-sliding');\n    /**\n     * Triggered when the slider is in an active state\n     *\n     * @event Slider#slideractive\n     * @type {EventTarget~Event}\n     */\n    this.trigger('slideractive');\n\n    this.on(doc, 'mousemove', this.handleMouseMove);\n    this.on(doc, 'mouseup', this.handleMouseUp);\n    this.on(doc, 'touchmove', this.handleMouseMove);\n    this.on(doc, 'touchend', this.handleMouseUp);\n\n    this.handleMouseMove(event);\n  };\n\n  /**\n   * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.\n   * The `mousemove` and `touchmove` events will only only trigger this function during\n   * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and\n   * {@link Slider#handleMouseUp}.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered\n   *        this function\n   *\n   * @listens mousemove\n   * @listens touchmove\n   */\n\n\n  Slider.prototype.handleMouseMove = function handleMouseMove(event) {};\n\n  /**\n   * Handle `mouseup` or `touchend` events on the `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   * @fires Slider#sliderinactive\n   */\n\n\n  Slider.prototype.handleMouseUp = function handleMouseUp() {\n    var doc = this.bar.el_.ownerDocument;\n\n    unblockTextSelection();\n\n    this.removeClass('vjs-sliding');\n    /**\n     * Triggered when the slider is no longer in an active state.\n     *\n     * @event Slider#sliderinactive\n     * @type {EventTarget~Event}\n     */\n    this.trigger('sliderinactive');\n\n    this.off(doc, 'mousemove', this.handleMouseMove);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchmove', this.handleMouseMove);\n    this.off(doc, 'touchend', this.handleMouseUp);\n\n    this.update();\n  };\n\n  /**\n   * Update the progress bar of the `Slider`.\n   *\n   * @returns {number}\n   *          The percentage of progress the progress bar represents as a\n   *          number from 0 to 1.\n   */\n\n\n  Slider.prototype.update = function update() {\n\n    // In VolumeBar init we have a setTimeout for update that pops and update\n    // to the end of the execution stack. The player is destroyed before then\n    // update will cause an error\n    if (!this.el_) {\n      return;\n    }\n\n    // If scrubbing, we could use a cached value to make the handle keep up\n    // with the user's mouse. On HTML5 browsers scrubbing is really smooth, but\n    // some flash players are slow, so we might want to utilize this later.\n    // var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();\n    var progress = this.getPercent();\n    var bar = this.bar;\n\n    // If there's no bar...\n    if (!bar) {\n      return;\n    }\n\n    // Protect against no duration and other division issues\n    if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {\n      progress = 0;\n    }\n\n    // Convert to a percentage for setting\n    var percentage = (progress * 100).toFixed(2) + '%';\n    var style = bar.el().style;\n\n    // Set the new bar width or height\n    if (this.vertical()) {\n      style.height = percentage;\n    } else {\n      style.width = percentage;\n    }\n\n    return progress;\n  };\n\n  /**\n   * Calculate distance for slider\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run.\n   *\n   * @return {number}\n   *         The current position of the Slider.\n   *         - position.x for vertical `Slider`s\n   *         - position.y for horizontal `Slider`s\n   */\n\n\n  Slider.prototype.calculateDistance = function calculateDistance(event) {\n    var position = getPointerPosition(this.el_, event);\n\n    if (this.vertical()) {\n      return position.y;\n    }\n    return position.x;\n  };\n\n  /**\n   * Handle a `focus` event on this `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to run.\n   *\n   * @listens focus\n   */\n\n\n  Slider.prototype.handleFocus = function handleFocus() {\n    this.on(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);\n  };\n\n  /**\n   * Handle a `keydown` event on the `Slider`. Watches for left, rigth, up, and down\n   * arrow keys. This function will only be called when the slider has focus. See\n   * {@link Slider#handleFocus} and {@link Slider#handleBlur}.\n   *\n   * @param {EventTarget~Event} event\n   *        the `keydown` event that caused this function to run.\n   *\n   * @listens keydown\n   */\n\n\n  Slider.prototype.handleKeyPress = function handleKeyPress(event) {\n    // Left and Down Arrows\n    if (event.which === 37 || event.which === 40) {\n      event.preventDefault();\n      this.stepBack();\n\n      // Up and Right Arrows\n    } else if (event.which === 38 || event.which === 39) {\n      event.preventDefault();\n      this.stepForward();\n    }\n  };\n\n  /**\n   * Handle a `blur` event on this `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to run.\n   *\n   * @listens blur\n   */\n\n  Slider.prototype.handleBlur = function handleBlur() {\n    this.off(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);\n  };\n\n  /**\n   * Listener for click events on slider, used to prevent clicks\n   *   from bubbling up to parent elements like button menus.\n   *\n   * @param {Object} event\n   *        Event that caused this object to run\n   */\n\n\n  Slider.prototype.handleClick = function handleClick(event) {\n    event.stopImmediatePropagation();\n    event.preventDefault();\n  };\n\n  /**\n   * Get/set if slider is horizontal for vertical\n   *\n   * @param {boolean} [bool]\n   *        - true if slider is vertical,\n   *        - false is horizontal\n   *\n   * @return {boolean}\n   *         - true if slider is vertical, and getting\n   *         - false if the slider is horizontal, and getting\n   */\n\n\n  Slider.prototype.vertical = function vertical(bool) {\n    if (bool === undefined) {\n      return this.vertical_ || false;\n    }\n\n    this.vertical_ = !!bool;\n\n    if (this.vertical_) {\n      this.addClass('vjs-slider-vertical');\n    } else {\n      this.addClass('vjs-slider-horizontal');\n    }\n  };\n\n  return Slider;\n}(Component);\n\nComponent.registerComponent('Slider', Slider);\n\n/**\n * @file load-progress-bar.js\n */\n\n/**\n * Shows loading progress\n *\n * @extends Component\n */\n\nvar LoadProgressBar = function (_Component) {\n  inherits(LoadProgressBar, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function LoadProgressBar(player, options) {\n    classCallCheck(this, LoadProgressBar);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.partEls_ = [];\n    _this.on(player, 'progress', _this.update);\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  LoadProgressBar.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-load-progress',\n      innerHTML: '<span class=\"vjs-control-text\"><span>' + this.localize('Loaded') + '</span>: 0%</span>'\n    });\n  };\n\n  LoadProgressBar.prototype.dispose = function dispose() {\n    this.partEls_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Update progress bar\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `progress` event that caused this function to run.\n   *\n   * @listens Player#progress\n   */\n\n\n  LoadProgressBar.prototype.update = function update(event) {\n    var buffered = this.player_.buffered();\n    var duration = this.player_.duration();\n    var bufferedEnd = this.player_.bufferedEnd();\n    var children = this.partEls_;\n\n    // get the percent width of a time compared to the total end\n    var percentify = function percentify(time, end) {\n      // no NaN\n      var percent = time / end || 0;\n\n      return (percent >= 1 ? 1 : percent) * 100 + '%';\n    };\n\n    // update the width of the progress bar\n    this.el_.style.width = percentify(bufferedEnd, duration);\n\n    // add child elements to represent the individual buffered time ranges\n    for (var i = 0; i < buffered.length; i++) {\n      var start = buffered.start(i);\n      var end = buffered.end(i);\n      var part = children[i];\n\n      if (!part) {\n        part = this.el_.appendChild(createEl());\n        children[i] = part;\n      }\n\n      // set the percent based on the width of the progress bar (bufferedEnd)\n      part.style.left = percentify(start, bufferedEnd);\n      part.style.width = percentify(end - start, bufferedEnd);\n    }\n\n    // remove unused buffered range elements\n    for (var _i = children.length; _i > buffered.length; _i--) {\n      this.el_.removeChild(children[_i - 1]);\n    }\n    children.length = buffered.length;\n  };\n\n  return LoadProgressBar;\n}(Component);\n\nComponent.registerComponent('LoadProgressBar', LoadProgressBar);\n\n/**\n * @file time-tooltip.js\n */\n\n/**\n * Time tooltips display a time above the progress bar.\n *\n * @extends Component\n */\n\nvar TimeTooltip = function (_Component) {\n  inherits(TimeTooltip, _Component);\n\n  function TimeTooltip() {\n    classCallCheck(this, TimeTooltip);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the time tooltip DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  TimeTooltip.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-time-tooltip'\n    });\n  };\n\n  /**\n   * Updates the position of the time tooltip relative to the `SeekBar`.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */\n\n\n  TimeTooltip.prototype.update = function update(seekBarRect, seekBarPoint, content) {\n    var tooltipRect = getBoundingClientRect(this.el_);\n    var playerRect = getBoundingClientRect(this.player_.el());\n    var seekBarPointPx = seekBarRect.width * seekBarPoint;\n\n    // do nothing if either rect isn't available\n    // for example, if the player isn't in the DOM for testing\n    if (!playerRect || !tooltipRect) {\n      return;\n    }\n\n    // This is the space left of the `seekBarPoint` available within the bounds\n    // of the player. We calculate any gap between the left edge of the player\n    // and the left edge of the `SeekBar` and add the number of pixels in the\n    // `SeekBar` before hitting the `seekBarPoint`\n    var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;\n\n    // This is the space right of the `seekBarPoint` available within the bounds\n    // of the player. We calculate the number of pixels from the `seekBarPoint`\n    // to the right edge of the `SeekBar` and add to that any gap between the\n    // right edge of the `SeekBar` and the player.\n    var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);\n\n    // This is the number of pixels by which the tooltip will need to be pulled\n    // further to the right to center it over the `seekBarPoint`.\n    var pullTooltipBy = tooltipRect.width / 2;\n\n    // Adjust the `pullTooltipBy` distance to the left or right depending on\n    // the results of the space calculations above.\n    if (spaceLeftOfPoint < pullTooltipBy) {\n      pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;\n    } else if (spaceRightOfPoint < pullTooltipBy) {\n      pullTooltipBy = spaceRightOfPoint;\n    }\n\n    // Due to the imprecision of decimal/ratio based calculations and varying\n    // rounding behaviors, there are cases where the spacing adjustment is off\n    // by a pixel or two. This adds insurance to these calculations.\n    if (pullTooltipBy < 0) {\n      pullTooltipBy = 0;\n    } else if (pullTooltipBy > tooltipRect.width) {\n      pullTooltipBy = tooltipRect.width;\n    }\n\n    this.el_.style.right = '-' + pullTooltipBy + 'px';\n    textContent(this.el_, content);\n  };\n\n  return TimeTooltip;\n}(Component);\n\nComponent.registerComponent('TimeTooltip', TimeTooltip);\n\n/**\n * @file play-progress-bar.js\n */\n\n/**\n * Used by {@link SeekBar} to display media playback progress as part of the\n * {@link ProgressControl}.\n *\n * @extends Component\n */\n\nvar PlayProgressBar = function (_Component) {\n  inherits(PlayProgressBar, _Component);\n\n  function PlayProgressBar() {\n    classCallCheck(this, PlayProgressBar);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the the DOM element for this class.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  PlayProgressBar.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-play-progress vjs-slider-bar',\n      innerHTML: '<span class=\"vjs-control-text\"><span>' + this.localize('Progress') + '</span>: 0%</span>'\n    });\n  };\n\n  /**\n   * Enqueues updates to its own DOM as well as the DOM of its\n   * {@link TimeTooltip} child.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */\n\n\n  PlayProgressBar.prototype.update = function update(seekBarRect, seekBarPoint) {\n    var _this2 = this;\n\n    // If there is an existing rAF ID, cancel it so we don't over-queue.\n    if (this.rafId_) {\n      this.cancelAnimationFrame(this.rafId_);\n    }\n\n    this.rafId_ = this.requestAnimationFrame(function () {\n      var time = _this2.player_.scrubbing() ? _this2.player_.getCache().currentTime : _this2.player_.currentTime();\n\n      var content = formatTime(time, _this2.player_.duration());\n      var timeTooltip = _this2.getChild('timeTooltip');\n\n      if (timeTooltip) {\n        timeTooltip.update(seekBarRect, seekBarPoint, content);\n      }\n    });\n  };\n\n  return PlayProgressBar;\n}(Component);\n\n/**\n * Default options for {@link PlayProgressBar}.\n *\n * @type {Object}\n * @private\n */\n\n\nPlayProgressBar.prototype.options_ = {\n  children: []\n};\n\n// Time tooltips should not be added to a player on mobile devices\nif (!IS_IOS && !IS_ANDROID) {\n  PlayProgressBar.prototype.options_.children.push('timeTooltip');\n}\n\nComponent.registerComponent('PlayProgressBar', PlayProgressBar);\n\n/**\n * @file mouse-time-display.js\n */\n\n/**\n * The {@link MouseTimeDisplay} component tracks mouse movement over the\n * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}\n * indicating the time which is represented by a given point in the\n * {@link ProgressControl}.\n *\n * @extends Component\n */\n\nvar MouseTimeDisplay = function (_Component) {\n  inherits(MouseTimeDisplay, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The {@link Player} that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function MouseTimeDisplay(player, options) {\n    classCallCheck(this, MouseTimeDisplay);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.update = throttle(bind(_this, _this.update), 25);\n    return _this;\n  }\n\n  /**\n   * Create the DOM element for this class.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  MouseTimeDisplay.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-mouse-display'\n    });\n  };\n\n  /**\n   * Enqueues updates to its own DOM as well as the DOM of its\n   * {@link TimeTooltip} child.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */\n\n\n  MouseTimeDisplay.prototype.update = function update(seekBarRect, seekBarPoint) {\n    var _this2 = this;\n\n    // If there is an existing rAF ID, cancel it so we don't over-queue.\n    if (this.rafId_) {\n      this.cancelAnimationFrame(this.rafId_);\n    }\n\n    this.rafId_ = this.requestAnimationFrame(function () {\n      var duration = _this2.player_.duration();\n      var content = formatTime(seekBarPoint * duration, duration);\n\n      _this2.el_.style.left = seekBarRect.width * seekBarPoint + 'px';\n      _this2.getChild('timeTooltip').update(seekBarRect, seekBarPoint, content);\n    });\n  };\n\n  return MouseTimeDisplay;\n}(Component);\n\n/**\n * Default options for `MouseTimeDisplay`\n *\n * @type {Object}\n * @private\n */\n\n\nMouseTimeDisplay.prototype.options_ = {\n  children: ['timeTooltip']\n};\n\nComponent.registerComponent('MouseTimeDisplay', MouseTimeDisplay);\n\n/**\n * @file seek-bar.js\n */\n\n// The number of seconds the `step*` functions move the timeline.\nvar STEP_SECONDS = 5;\n\n// The interval at which the bar should update as it progresses.\nvar UPDATE_REFRESH_INTERVAL = 30;\n\n/**\n * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}\n * as its `bar`.\n *\n * @extends Slider\n */\n\nvar SeekBar = function (_Slider) {\n  inherits(SeekBar, _Slider);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function SeekBar(player, options) {\n    classCallCheck(this, SeekBar);\n\n    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));\n\n    _this.setEventHandlers_();\n    return _this;\n  }\n\n  /**\n   * Sets the event handlers\n   *\n   * @private\n   */\n\n\n  SeekBar.prototype.setEventHandlers_ = function setEventHandlers_() {\n    var _this2 = this;\n\n    this.update = throttle(bind(this, this.update), UPDATE_REFRESH_INTERVAL);\n\n    this.on(this.player_, 'timeupdate', this.update);\n    this.on(this.player_, 'ended', this.handleEnded);\n\n    // when playing, let's ensure we smoothly update the play progress bar\n    // via an interval\n    this.updateInterval = null;\n\n    this.on(this.player_, ['playing'], function () {\n      _this2.clearInterval(_this2.updateInterval);\n\n      _this2.updateInterval = _this2.setInterval(function () {\n        _this2.requestAnimationFrame(function () {\n          _this2.update();\n        });\n      }, UPDATE_REFRESH_INTERVAL);\n    });\n\n    this.on(this.player_, ['ended', 'pause', 'waiting'], function () {\n      _this2.clearInterval(_this2.updateInterval);\n    });\n\n    this.on(this.player_, ['timeupdate', 'ended'], this.update);\n  };\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  SeekBar.prototype.createEl = function createEl$$1() {\n    return _Slider.prototype.createEl.call(this, 'div', {\n      className: 'vjs-progress-holder'\n    }, {\n      'aria-label': this.localize('Progress Bar')\n    });\n  };\n\n  /**\n   * This function updates the play progress bar and accessibility\n   * attributes to whatever is passed in.\n   *\n   * @param {number} currentTime\n   *        The currentTime value that should be used for accessibility\n   *\n   * @param {number} percent\n   *        The percentage as a decimal that the bar should be filled from 0-1.\n   *\n   * @private\n   */\n\n\n  SeekBar.prototype.update_ = function update_(currentTime, percent) {\n    var duration = this.player_.duration();\n\n    // machine readable value of progress bar (percentage complete)\n    this.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));\n\n    // human readable value of progress bar (time complete)\n    this.el_.setAttribute('aria-valuetext', this.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(currentTime, duration), formatTime(duration, duration)], '{1} of {2}'));\n\n    // Update the `PlayProgressBar`.\n    this.bar.update(getBoundingClientRect(this.el_), percent);\n  };\n\n  /**\n   * Update the seek bar's UI.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `ended` event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   *\n   * @returns {number}\n   *          The current percent at a number from 0-1\n   */\n\n\n  SeekBar.prototype.update = function update(event) {\n    var percent = _Slider.prototype.update.call(this);\n\n    this.update_(this.getCurrentTime_(), percent);\n    return percent;\n  };\n\n  /**\n   * Get the value of current time but allows for smooth scrubbing,\n   * when player can't keep up.\n   *\n   * @return {number}\n   *         The current time value to display\n   *\n   * @private\n   */\n\n\n  SeekBar.prototype.getCurrentTime_ = function getCurrentTime_() {\n    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n  };\n\n  /**\n   * We want the seek bar to be full on ended\n   * no matter what the actual internal values are. so we force it.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */\n\n\n  SeekBar.prototype.handleEnded = function handleEnded(event) {\n    this.update_(this.player_.duration(), 1);\n  };\n\n  /**\n   * Get the percentage of media played so far.\n   *\n   * @return {number}\n   *         The percentage of media played so far (0 to 1).\n   */\n\n\n  SeekBar.prototype.getPercent = function getPercent() {\n    var percent = this.getCurrentTime_() / this.player_.duration();\n\n    return percent >= 1 ? 1 : percent || 0;\n  };\n\n  /**\n   * Handle mouse down on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousedown` event that caused this to run.\n   *\n   * @listens mousedown\n   */\n\n\n  SeekBar.prototype.handleMouseDown = function handleMouseDown(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    // Stop event propagation to prevent double fire in progress-control.js\n    event.stopPropagation();\n    this.player_.scrubbing(true);\n\n    this.videoWasPlaying = !this.player_.paused();\n    this.player_.pause();\n\n    _Slider.prototype.handleMouseDown.call(this, event);\n  };\n\n  /**\n   * Handle mouse move on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this to run.\n   *\n   * @listens mousemove\n   */\n\n\n  SeekBar.prototype.handleMouseMove = function handleMouseMove(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    var newTime = this.calculateDistance(event) * this.player_.duration();\n\n    // Don't let video end while scrubbing.\n    if (newTime === this.player_.duration()) {\n      newTime = newTime - 0.1;\n    }\n\n    // Set new time (tell player to seek to new time)\n    this.player_.currentTime(newTime);\n  };\n\n  SeekBar.prototype.enable = function enable() {\n    _Slider.prototype.enable.call(this);\n    var mouseTimeDisplay = this.getChild('mouseTimeDisplay');\n\n    if (!mouseTimeDisplay) {\n      return;\n    }\n\n    mouseTimeDisplay.show();\n  };\n\n  SeekBar.prototype.disable = function disable() {\n    _Slider.prototype.disable.call(this);\n    var mouseTimeDisplay = this.getChild('mouseTimeDisplay');\n\n    if (!mouseTimeDisplay) {\n      return;\n    }\n\n    mouseTimeDisplay.hide();\n  };\n\n  /**\n   * Handle mouse up on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mouseup` event that caused this to run.\n   *\n   * @listens mouseup\n   */\n\n\n  SeekBar.prototype.handleMouseUp = function handleMouseUp(event) {\n    _Slider.prototype.handleMouseUp.call(this, event);\n\n    // Stop event propagation to prevent double fire in progress-control.js\n    if (event) {\n      event.stopPropagation();\n    }\n    this.player_.scrubbing(false);\n\n    /**\n     * Trigger timeupdate because we're done seeking and the time has changed.\n     * This is particularly useful for if the player is paused to time the time displays.\n     *\n     * @event Tech#timeupdate\n     * @type {EventTarget~Event}\n     */\n    this.player_.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\n    if (this.videoWasPlaying) {\n      silencePromise(this.player_.play());\n    }\n  };\n\n  /**\n   * Move more quickly fast forward for keyboard-only users\n   */\n\n\n  SeekBar.prototype.stepForward = function stepForward() {\n    this.player_.currentTime(this.player_.currentTime() + STEP_SECONDS);\n  };\n\n  /**\n   * Move more quickly rewind for keyboard-only users\n   */\n\n\n  SeekBar.prototype.stepBack = function stepBack() {\n    this.player_.currentTime(this.player_.currentTime() - STEP_SECONDS);\n  };\n\n  /**\n   * Toggles the playback state of the player\n   * This gets called when enter or space is used on the seekbar\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called\n   *\n   */\n\n\n  SeekBar.prototype.handleAction = function handleAction(event) {\n    if (this.player_.paused()) {\n      this.player_.play();\n    } else {\n      this.player_.pause();\n    }\n  };\n\n  /**\n   * Called when this SeekBar has focus and a key gets pressed down. By\n   * default it will call `this.handleAction` when the key is space or enter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n\n\n  SeekBar.prototype.handleKeyPress = function handleKeyPress(event) {\n\n    // Support Space (32) or Enter (13) key operation to fire a click event\n    if (event.which === 32 || event.which === 13) {\n      event.preventDefault();\n      this.handleAction(event);\n    } else if (_Slider.prototype.handleKeyPress) {\n\n      // Pass keypress handling up for unsupported keys\n      _Slider.prototype.handleKeyPress.call(this, event);\n    }\n  };\n\n  return SeekBar;\n}(Slider);\n\n/**\n * Default options for the `SeekBar`\n *\n * @type {Object}\n * @private\n */\n\n\nSeekBar.prototype.options_ = {\n  children: ['loadProgressBar', 'playProgressBar'],\n  barName: 'playProgressBar'\n};\n\n// MouseTimeDisplay tooltips should not be added to a player on mobile devices\nif (!IS_IOS && !IS_ANDROID) {\n  SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');\n}\n\n/**\n * Call the update event for this Slider when this event happens on the player.\n *\n * @type {string}\n */\nSeekBar.prototype.playerEvent = 'timeupdate';\n\nComponent.registerComponent('SeekBar', SeekBar);\n\n/**\n * @file progress-control.js\n */\n\n/**\n * The Progress Control component contains the seek bar, load progress,\n * and play progress.\n *\n * @extends Component\n */\n\nvar ProgressControl = function (_Component) {\n  inherits(ProgressControl, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function ProgressControl(player, options) {\n    classCallCheck(this, ProgressControl);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.handleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);\n    _this.throttledHandleMouseSeek = throttle(bind(_this, _this.handleMouseSeek), 25);\n\n    _this.enable();\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  ProgressControl.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-progress-control vjs-control'\n    });\n  };\n\n  /**\n   * When the mouse moves over the `ProgressControl`, the pointer position\n   * gets passed down to the `MouseTimeDisplay` component.\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this function to run.\n   *\n   * @listen mousemove\n   */\n\n\n  ProgressControl.prototype.handleMouseMove = function handleMouseMove(event) {\n    var seekBar = this.getChild('seekBar');\n\n    if (seekBar) {\n      var mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');\n      var seekBarEl = seekBar.el();\n      var seekBarRect = getBoundingClientRect(seekBarEl);\n      var seekBarPoint = getPointerPosition(seekBarEl, event).x;\n\n      // The default skin has a gap on either side of the `SeekBar`. This means\n      // that it's possible to trigger this behavior outside the boundaries of\n      // the `SeekBar`. This ensures we stay within it at all times.\n      if (seekBarPoint > 1) {\n        seekBarPoint = 1;\n      } else if (seekBarPoint < 0) {\n        seekBarPoint = 0;\n      }\n\n      if (mouseTimeDisplay) {\n        mouseTimeDisplay.update(seekBarRect, seekBarPoint);\n      }\n    }\n  };\n\n  /**\n   * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.\n   *\n   * @method ProgressControl#throttledHandleMouseSeek\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this function to run.\n   *\n   * @listen mousemove\n   * @listen touchmove\n   */\n\n  /**\n   * Handle `mousemove` or `touchmove` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousemove\n   * @listens touchmove\n   */\n\n\n  ProgressControl.prototype.handleMouseSeek = function handleMouseSeek(event) {\n    var seekBar = this.getChild('seekBar');\n\n    if (seekBar) {\n      seekBar.handleMouseMove(event);\n    }\n  };\n\n  /**\n   * Are controls are currently enabled for this progress control.\n   *\n   * @return {boolean}\n   *         true if controls are enabled, false otherwise\n   */\n\n\n  ProgressControl.prototype.enabled = function enabled() {\n    return this.enabled_;\n  };\n\n  /**\n   * Disable all controls on the progress control and its children\n   */\n\n\n  ProgressControl.prototype.disable = function disable() {\n    this.children().forEach(function (child) {\n      return child.disable && child.disable();\n    });\n\n    if (!this.enabled()) {\n      return;\n    }\n\n    this.off(['mousedown', 'touchstart'], this.handleMouseDown);\n    this.off(this.el_, 'mousemove', this.handleMouseMove);\n    this.handleMouseUp();\n\n    this.addClass('disabled');\n\n    this.enabled_ = false;\n  };\n\n  /**\n   * Enable all controls on the progress control and its children\n   */\n\n\n  ProgressControl.prototype.enable = function enable() {\n    this.children().forEach(function (child) {\n      return child.enable && child.enable();\n    });\n\n    if (this.enabled()) {\n      return;\n    }\n\n    this.on(['mousedown', 'touchstart'], this.handleMouseDown);\n    this.on(this.el_, 'mousemove', this.handleMouseMove);\n    this.removeClass('disabled');\n\n    this.enabled_ = true;\n  };\n\n  /**\n   * Handle `mousedown` or `touchstart` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */\n\n\n  ProgressControl.prototype.handleMouseDown = function handleMouseDown(event) {\n    var doc = this.el_.ownerDocument;\n    var seekBar = this.getChild('seekBar');\n\n    if (seekBar) {\n      seekBar.handleMouseDown(event);\n    }\n\n    this.on(doc, 'mousemove', this.throttledHandleMouseSeek);\n    this.on(doc, 'touchmove', this.throttledHandleMouseSeek);\n    this.on(doc, 'mouseup', this.handleMouseUp);\n    this.on(doc, 'touchend', this.handleMouseUp);\n  };\n\n  /**\n   * Handle `mouseup` or `touchend` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   */\n\n\n  ProgressControl.prototype.handleMouseUp = function handleMouseUp(event) {\n    var doc = this.el_.ownerDocument;\n    var seekBar = this.getChild('seekBar');\n\n    if (seekBar) {\n      seekBar.handleMouseUp(event);\n    }\n\n    this.off(doc, 'mousemove', this.throttledHandleMouseSeek);\n    this.off(doc, 'touchmove', this.throttledHandleMouseSeek);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchend', this.handleMouseUp);\n  };\n\n  return ProgressControl;\n}(Component);\n\n/**\n * Default options for `ProgressControl`\n *\n * @type {Object}\n * @private\n */\n\n\nProgressControl.prototype.options_ = {\n  children: ['seekBar']\n};\n\nComponent.registerComponent('ProgressControl', ProgressControl);\n\n/**\n * @file fullscreen-toggle.js\n */\n\n/**\n * Toggle fullscreen video\n *\n * @extends Button\n */\n\nvar FullscreenToggle = function (_Button) {\n  inherits(FullscreenToggle, _Button);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function FullscreenToggle(player, options) {\n    classCallCheck(this, FullscreenToggle);\n\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    _this.on(player, 'fullscreenchange', _this.handleFullscreenChange);\n\n    if (global_document__WEBPACK_IMPORTED_MODULE_1___default.a[FullscreenApi.fullscreenEnabled] === false) {\n      _this.disable();\n    }\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  FullscreenToggle.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-fullscreen-control ' + _Button.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Handles fullscreenchange on the player and change control text accordingly.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#fullscreenchange} event that caused this function to be\n   *        called.\n   *\n   * @listens Player#fullscreenchange\n   */\n\n\n  FullscreenToggle.prototype.handleFullscreenChange = function handleFullscreenChange(event) {\n    if (this.player_.isFullscreen()) {\n      this.controlText('Non-Fullscreen');\n    } else {\n      this.controlText('Fullscreen');\n    }\n  };\n\n  /**\n   * This gets called when an `FullscreenToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  FullscreenToggle.prototype.handleClick = function handleClick(event) {\n    if (!this.player_.isFullscreen()) {\n      this.player_.requestFullscreen();\n    } else {\n      this.player_.exitFullscreen();\n    }\n  };\n\n  return FullscreenToggle;\n}(Button);\n\n/**\n * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nFullscreenToggle.prototype.controlText_ = 'Fullscreen';\n\nComponent.registerComponent('FullscreenToggle', FullscreenToggle);\n\n/**\n * Check if volume control is supported and if it isn't hide the\n * `Component` that was passed  using the `vjs-hidden` class.\n *\n * @param {Component} self\n *        The component that should be hidden if volume is unsupported\n *\n * @param {Player} player\n *        A reference to the player\n *\n * @private\n */\nvar checkVolumeSupport = function checkVolumeSupport(self, player) {\n  // hide volume controls when they're not supported by the current tech\n  if (player.tech_ && !player.tech_.featuresVolumeControl) {\n    self.addClass('vjs-hidden');\n  }\n\n  self.on(player, 'loadstart', function () {\n    if (!player.tech_.featuresVolumeControl) {\n      self.addClass('vjs-hidden');\n    } else {\n      self.removeClass('vjs-hidden');\n    }\n  });\n};\n\n/**\n * @file volume-level.js\n */\n\n/**\n * Shows volume level\n *\n * @extends Component\n */\n\nvar VolumeLevel = function (_Component) {\n  inherits(VolumeLevel, _Component);\n\n  function VolumeLevel() {\n    classCallCheck(this, VolumeLevel);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  VolumeLevel.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-volume-level',\n      innerHTML: '<span class=\"vjs-control-text\"></span>'\n    });\n  };\n\n  return VolumeLevel;\n}(Component);\n\nComponent.registerComponent('VolumeLevel', VolumeLevel);\n\n/**\n * @file volume-bar.js\n */\n\n/**\n * The bar that contains the volume level and can be clicked on to adjust the level\n *\n * @extends Slider\n */\n\nvar VolumeBar = function (_Slider) {\n  inherits(VolumeBar, _Slider);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function VolumeBar(player, options) {\n    classCallCheck(this, VolumeBar);\n\n    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));\n\n    _this.on('slideractive', _this.updateLastVolume_);\n    _this.on(player, 'volumechange', _this.updateARIAAttributes);\n    player.ready(function () {\n      return _this.updateARIAAttributes();\n    });\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  VolumeBar.prototype.createEl = function createEl$$1() {\n    return _Slider.prototype.createEl.call(this, 'div', {\n      className: 'vjs-volume-bar vjs-slider-bar'\n    }, {\n      'aria-label': this.localize('Volume Level'),\n      'aria-live': 'polite'\n    });\n  };\n\n  /**\n   * Handle mouse down on volume bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousedown` event that caused this to run.\n   *\n   * @listens mousedown\n   */\n\n\n  VolumeBar.prototype.handleMouseDown = function handleMouseDown(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    _Slider.prototype.handleMouseDown.call(this, event);\n  };\n\n  /**\n   * Handle movement events on the {@link VolumeMenuButton}.\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run.\n   *\n   * @listens mousemove\n   */\n\n\n  VolumeBar.prototype.handleMouseMove = function handleMouseMove(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    this.checkMuted();\n    this.player_.volume(this.calculateDistance(event));\n  };\n\n  /**\n   * If the player is muted unmute it.\n   */\n\n\n  VolumeBar.prototype.checkMuted = function checkMuted() {\n    if (this.player_.muted()) {\n      this.player_.muted(false);\n    }\n  };\n\n  /**\n   * Get percent of volume level\n   *\n   * @return {number}\n   *         Volume level percent as a decimal number.\n   */\n\n\n  VolumeBar.prototype.getPercent = function getPercent() {\n    if (this.player_.muted()) {\n      return 0;\n    }\n    return this.player_.volume();\n  };\n\n  /**\n   * Increase volume level for keyboard users\n   */\n\n\n  VolumeBar.prototype.stepForward = function stepForward() {\n    this.checkMuted();\n    this.player_.volume(this.player_.volume() + 0.1);\n  };\n\n  /**\n   * Decrease volume level for keyboard users\n   */\n\n\n  VolumeBar.prototype.stepBack = function stepBack() {\n    this.checkMuted();\n    this.player_.volume(this.player_.volume() - 0.1);\n  };\n\n  /**\n   * Update ARIA accessibility attributes\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `volumechange` event that caused this function to run.\n   *\n   * @listens Player#volumechange\n   */\n\n\n  VolumeBar.prototype.updateARIAAttributes = function updateARIAAttributes(event) {\n    var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();\n\n    this.el_.setAttribute('aria-valuenow', ariaValue);\n    this.el_.setAttribute('aria-valuetext', ariaValue + '%');\n  };\n\n  /**\n   * Returns the current value of the player volume as a percentage\n   *\n   * @private\n   */\n\n\n  VolumeBar.prototype.volumeAsPercentage_ = function volumeAsPercentage_() {\n    return Math.round(this.player_.volume() * 100);\n  };\n\n  /**\n   * When user starts dragging the VolumeBar, store the volume and listen for\n   * the end of the drag. When the drag ends, if the volume was set to zero,\n   * set lastVolume to the stored volume.\n   *\n   * @listens slideractive\n   * @private\n   */\n\n\n  VolumeBar.prototype.updateLastVolume_ = function updateLastVolume_() {\n    var _this2 = this;\n\n    var volumeBeforeDrag = this.player_.volume();\n\n    this.one('sliderinactive', function () {\n      if (_this2.player_.volume() === 0) {\n        _this2.player_.lastVolume_(volumeBeforeDrag);\n      }\n    });\n  };\n\n  return VolumeBar;\n}(Slider);\n\n/**\n * Default options for the `VolumeBar`\n *\n * @type {Object}\n * @private\n */\n\n\nVolumeBar.prototype.options_ = {\n  children: ['volumeLevel'],\n  barName: 'volumeLevel'\n};\n\n/**\n * Call the update event for this Slider when this event happens on the player.\n *\n * @type {string}\n */\nVolumeBar.prototype.playerEvent = 'volumechange';\n\nComponent.registerComponent('VolumeBar', VolumeBar);\n\n/**\n * @file volume-control.js\n */\n\n/**\n * The component for controlling the volume level\n *\n * @extends Component\n */\n\nvar VolumeControl = function (_Component) {\n  inherits(VolumeControl, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function VolumeControl(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, VolumeControl);\n\n    options.vertical = options.vertical || false;\n\n    // Pass the vertical option down to the VolumeBar if\n    // the VolumeBar is turned on.\n    if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {\n      options.volumeBar = options.volumeBar || {};\n      options.volumeBar.vertical = options.vertical;\n    }\n\n    // hide this control if volume support is missing\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    checkVolumeSupport(_this, player);\n\n    _this.throttledHandleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);\n\n    _this.on('mousedown', _this.handleMouseDown);\n    _this.on('touchstart', _this.handleMouseDown);\n\n    // while the slider is active (the mouse has been pressed down and\n    // is dragging) or in focus we do not want to hide the VolumeBar\n    _this.on(_this.volumeBar, ['focus', 'slideractive'], function () {\n      _this.volumeBar.addClass('vjs-slider-active');\n      _this.addClass('vjs-slider-active');\n      _this.trigger('slideractive');\n    });\n\n    _this.on(_this.volumeBar, ['blur', 'sliderinactive'], function () {\n      _this.volumeBar.removeClass('vjs-slider-active');\n      _this.removeClass('vjs-slider-active');\n      _this.trigger('sliderinactive');\n    });\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  VolumeControl.prototype.createEl = function createEl() {\n    var orientationClass = 'vjs-volume-horizontal';\n\n    if (this.options_.vertical) {\n      orientationClass = 'vjs-volume-vertical';\n    }\n\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-volume-control vjs-control ' + orientationClass\n    });\n  };\n\n  /**\n   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */\n\n\n  VolumeControl.prototype.handleMouseDown = function handleMouseDown(event) {\n    var doc = this.el_.ownerDocument;\n\n    this.on(doc, 'mousemove', this.throttledHandleMouseMove);\n    this.on(doc, 'touchmove', this.throttledHandleMouseMove);\n    this.on(doc, 'mouseup', this.handleMouseUp);\n    this.on(doc, 'touchend', this.handleMouseUp);\n  };\n\n  /**\n   * Handle `mouseup` or `touchend` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   */\n\n\n  VolumeControl.prototype.handleMouseUp = function handleMouseUp(event) {\n    var doc = this.el_.ownerDocument;\n\n    this.off(doc, 'mousemove', this.throttledHandleMouseMove);\n    this.off(doc, 'touchmove', this.throttledHandleMouseMove);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchend', this.handleMouseUp);\n  };\n\n  /**\n   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */\n\n\n  VolumeControl.prototype.handleMouseMove = function handleMouseMove(event) {\n    this.volumeBar.handleMouseMove(event);\n  };\n\n  return VolumeControl;\n}(Component);\n\n/**\n * Default options for the `VolumeControl`\n *\n * @type {Object}\n * @private\n */\n\n\nVolumeControl.prototype.options_ = {\n  children: ['volumeBar']\n};\n\nComponent.registerComponent('VolumeControl', VolumeControl);\n\n/**\n * Check if muting volume is supported and if it isn't hide the mute toggle\n * button.\n *\n * @param {Component} self\n *        A reference to the mute toggle button\n *\n * @param {Player} player\n *        A reference to the player\n *\n * @private\n */\nvar checkMuteSupport = function checkMuteSupport(self, player) {\n  // hide mute toggle button if it's not supported by the current tech\n  if (player.tech_ && !player.tech_.featuresMuteControl) {\n    self.addClass('vjs-hidden');\n  }\n\n  self.on(player, 'loadstart', function () {\n    if (!player.tech_.featuresMuteControl) {\n      self.addClass('vjs-hidden');\n    } else {\n      self.removeClass('vjs-hidden');\n    }\n  });\n};\n\n/**\n * @file mute-toggle.js\n */\n\n/**\n * A button component for muting the audio.\n *\n * @extends Button\n */\n\nvar MuteToggle = function (_Button) {\n  inherits(MuteToggle, _Button);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function MuteToggle(player, options) {\n    classCallCheck(this, MuteToggle);\n\n    // hide this control if volume support is missing\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    checkMuteSupport(_this, player);\n\n    _this.on(player, ['loadstart', 'volumechange'], _this.update);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  MuteToggle.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-mute-control ' + _Button.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * This gets called when an `MuteToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  MuteToggle.prototype.handleClick = function handleClick(event) {\n    var vol = this.player_.volume();\n    var lastVolume = this.player_.lastVolume_();\n\n    if (vol === 0) {\n      var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;\n\n      this.player_.volume(volumeToSet);\n      this.player_.muted(false);\n    } else {\n      this.player_.muted(this.player_.muted() ? false : true);\n    }\n  };\n\n  /**\n   * Update the `MuteToggle` button based on the state of `volume` and `muted`\n   * on the player.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#loadstart} event if this function was called\n   *        through an event.\n   *\n   * @listens Player#loadstart\n   * @listens Player#volumechange\n   */\n\n\n  MuteToggle.prototype.update = function update(event) {\n    this.updateIcon_();\n    this.updateControlText_();\n  };\n\n  /**\n   * Update the appearance of the `MuteToggle` icon.\n   *\n   * Possible states (given `level` variable below):\n   * - 0: crossed out\n   * - 1: zero bars of volume\n   * - 2: one bar of volume\n   * - 3: two bars of volume\n   *\n   * @private\n   */\n\n\n  MuteToggle.prototype.updateIcon_ = function updateIcon_() {\n    var vol = this.player_.volume();\n    var level = 3;\n\n    // in iOS when a player is loaded with muted attribute\n    // and volume is changed with a native mute button\n    // we want to make sure muted state is updated\n    if (IS_IOS) {\n      this.player_.muted(this.player_.tech_.el_.muted);\n    }\n\n    if (vol === 0 || this.player_.muted()) {\n      level = 0;\n    } else if (vol < 0.33) {\n      level = 1;\n    } else if (vol < 0.67) {\n      level = 2;\n    }\n\n    // TODO improve muted icon classes\n    for (var i = 0; i < 4; i++) {\n      removeClass(this.el_, 'vjs-vol-' + i);\n    }\n    addClass(this.el_, 'vjs-vol-' + level);\n  };\n\n  /**\n   * If `muted` has changed on the player, update the control text\n   * (`title` attribute on `vjs-mute-control` element and content of\n   * `vjs-control-text` element).\n   *\n   * @private\n   */\n\n\n  MuteToggle.prototype.updateControlText_ = function updateControlText_() {\n    var soundOff = this.player_.muted() || this.player_.volume() === 0;\n    var text = soundOff ? 'Unmute' : 'Mute';\n\n    if (this.controlText() !== text) {\n      this.controlText(text);\n    }\n  };\n\n  return MuteToggle;\n}(Button);\n\n/**\n * The text that should display over the `MuteToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nMuteToggle.prototype.controlText_ = 'Mute';\n\nComponent.registerComponent('MuteToggle', MuteToggle);\n\n/**\n * @file volume-control.js\n */\n\n/**\n * A Component to contain the MuteToggle and VolumeControl so that\n * they can work together.\n *\n * @extends Component\n */\n\nvar VolumePanel = function (_Component) {\n  inherits(VolumePanel, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function VolumePanel(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, VolumePanel);\n\n    if (typeof options.inline !== 'undefined') {\n      options.inline = options.inline;\n    } else {\n      options.inline = true;\n    }\n\n    // pass the inline option down to the VolumeControl as vertical if\n    // the VolumeControl is on.\n    if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {\n      options.volumeControl = options.volumeControl || {};\n      options.volumeControl.vertical = !options.inline;\n    }\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.on(player, ['loadstart'], _this.volumePanelState_);\n\n    // while the slider is active (the mouse has been pressed down and\n    // is dragging) we do not want to hide the VolumeBar\n    _this.on(_this.volumeControl, ['slideractive'], _this.sliderActive_);\n\n    _this.on(_this.volumeControl, ['sliderinactive'], _this.sliderInactive_);\n    return _this;\n  }\n\n  /**\n   * Add vjs-slider-active class to the VolumePanel\n   *\n   * @listens VolumeControl#slideractive\n   * @private\n   */\n\n\n  VolumePanel.prototype.sliderActive_ = function sliderActive_() {\n    this.addClass('vjs-slider-active');\n  };\n\n  /**\n   * Removes vjs-slider-active class to the VolumePanel\n   *\n   * @listens VolumeControl#sliderinactive\n   * @private\n   */\n\n\n  VolumePanel.prototype.sliderInactive_ = function sliderInactive_() {\n    this.removeClass('vjs-slider-active');\n  };\n\n  /**\n   * Adds vjs-hidden or vjs-mute-toggle-only to the VolumePanel\n   * depending on MuteToggle and VolumeControl state\n   *\n   * @listens Player#loadstart\n   * @private\n   */\n\n\n  VolumePanel.prototype.volumePanelState_ = function volumePanelState_() {\n    // hide volume panel if neither volume control or mute toggle\n    // are displayed\n    if (this.volumeControl.hasClass('vjs-hidden') && this.muteToggle.hasClass('vjs-hidden')) {\n      this.addClass('vjs-hidden');\n    }\n\n    // if only mute toggle is visible we don't want\n    // volume panel expanding when hovered or active\n    if (this.volumeControl.hasClass('vjs-hidden') && !this.muteToggle.hasClass('vjs-hidden')) {\n      this.addClass('vjs-mute-toggle-only');\n    }\n  };\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  VolumePanel.prototype.createEl = function createEl() {\n    var orientationClass = 'vjs-volume-panel-horizontal';\n\n    if (!this.options_.inline) {\n      orientationClass = 'vjs-volume-panel-vertical';\n    }\n\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-volume-panel vjs-control ' + orientationClass\n    });\n  };\n\n  return VolumePanel;\n}(Component);\n\n/**\n * Default options for the `VolumeControl`\n *\n * @type {Object}\n * @private\n */\n\n\nVolumePanel.prototype.options_ = {\n  children: ['muteToggle', 'volumeControl']\n};\n\nComponent.registerComponent('VolumePanel', VolumePanel);\n\n/**\n * @file menu.js\n */\n\n/**\n * The Menu component is used to build popup menus, including subtitle and\n * captions selection menus.\n *\n * @extends Component\n */\n\nvar Menu = function (_Component) {\n  inherits(Menu, _Component);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        the player that this component should attach to\n   *\n   * @param {Object} [options]\n   *        Object of option names and values\n   *\n   */\n  function Menu(player, options) {\n    classCallCheck(this, Menu);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    if (options) {\n      _this.menuButton_ = options.menuButton;\n    }\n\n    _this.focusedChild_ = -1;\n\n    _this.on('keydown', _this.handleKeyPress);\n    return _this;\n  }\n\n  /**\n   * Add a {@link MenuItem} to the menu.\n   *\n   * @param {Object|string} component\n   *        The name or instance of the `MenuItem` to add.\n   *\n   */\n\n\n  Menu.prototype.addItem = function addItem(component) {\n    this.addChild(component);\n    component.on('click', bind(this, function (event) {\n      // Unpress the associated MenuButton, and move focus back to it\n      if (this.menuButton_) {\n        this.menuButton_.unpressButton();\n\n        // don't focus menu button if item is a caption settings item\n        // because focus will move elsewhere\n        if (component.name() !== 'CaptionSettingsMenuItem') {\n          this.menuButton_.focus();\n        }\n      }\n    }));\n  };\n\n  /**\n   * Create the `Menu`s DOM element.\n   *\n   * @return {Element}\n   *         the element that was created\n   */\n\n\n  Menu.prototype.createEl = function createEl$$1() {\n    var contentElType = this.options_.contentElType || 'ul';\n\n    this.contentEl_ = createEl(contentElType, {\n      className: 'vjs-menu-content'\n    });\n\n    this.contentEl_.setAttribute('role', 'menu');\n\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      append: this.contentEl_,\n      className: 'vjs-menu'\n    });\n\n    el.appendChild(this.contentEl_);\n\n    // Prevent clicks from bubbling up. Needed for Menu Buttons,\n    // where a click on the parent is significant\n    on(el, 'click', function (event) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    });\n\n    return el;\n  };\n\n  Menu.prototype.dispose = function dispose() {\n    this.contentEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Handle a `keydown` event on this menu. This listener is added in the constructor.\n   *\n   * @param {EventTarget~Event} event\n   *        A `keydown` event that happened on the menu.\n   *\n   * @listens keydown\n   */\n\n\n  Menu.prototype.handleKeyPress = function handleKeyPress(event) {\n    // Left and Down Arrows\n    if (event.which === 37 || event.which === 40) {\n      event.preventDefault();\n      this.stepForward();\n\n      // Up and Right Arrows\n    } else if (event.which === 38 || event.which === 39) {\n      event.preventDefault();\n      this.stepBack();\n    }\n  };\n\n  /**\n   * Move to next (lower) menu item for keyboard users.\n   */\n\n\n  Menu.prototype.stepForward = function stepForward() {\n    var stepChild = 0;\n\n    if (this.focusedChild_ !== undefined) {\n      stepChild = this.focusedChild_ + 1;\n    }\n    this.focus(stepChild);\n  };\n\n  /**\n   * Move to previous (higher) menu item for keyboard users.\n   */\n\n\n  Menu.prototype.stepBack = function stepBack() {\n    var stepChild = 0;\n\n    if (this.focusedChild_ !== undefined) {\n      stepChild = this.focusedChild_ - 1;\n    }\n    this.focus(stepChild);\n  };\n\n  /**\n   * Set focus on a {@link MenuItem} in the `Menu`.\n   *\n   * @param {Object|string} [item=0]\n   *        Index of child item set focus on.\n   */\n\n\n  Menu.prototype.focus = function focus() {\n    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    var children = this.children().slice();\n    var haveTitle = children.length && children[0].className && /vjs-menu-title/.test(children[0].className);\n\n    if (haveTitle) {\n      children.shift();\n    }\n\n    if (children.length > 0) {\n      if (item < 0) {\n        item = 0;\n      } else if (item >= children.length) {\n        item = children.length - 1;\n      }\n\n      this.focusedChild_ = item;\n\n      children[item].el_.focus();\n    }\n  };\n\n  return Menu;\n}(Component);\n\nComponent.registerComponent('Menu', Menu);\n\n/**\n * @file menu-button.js\n */\n\n/**\n * A `MenuButton` class for any popup {@link Menu}.\n *\n * @extends Component\n */\n\nvar MenuButton = function (_Component) {\n  inherits(MenuButton, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function MenuButton(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, MenuButton);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.menuButton_ = new Button(player, options);\n\n    _this.menuButton_.controlText(_this.controlText_);\n    _this.menuButton_.el_.setAttribute('aria-haspopup', 'true');\n\n    // Add buildCSSClass values to the button, not the wrapper\n    var buttonClass = Button.prototype.buildCSSClass();\n\n    _this.menuButton_.el_.className = _this.buildCSSClass() + ' ' + buttonClass;\n    _this.menuButton_.removeClass('vjs-control');\n\n    _this.addChild(_this.menuButton_);\n\n    _this.update();\n\n    _this.enabled_ = true;\n\n    _this.on(_this.menuButton_, 'tap', _this.handleClick);\n    _this.on(_this.menuButton_, 'click', _this.handleClick);\n    _this.on(_this.menuButton_, 'focus', _this.handleFocus);\n    _this.on(_this.menuButton_, 'blur', _this.handleBlur);\n\n    _this.on('keydown', _this.handleSubmenuKeyPress);\n    return _this;\n  }\n\n  /**\n   * Update the menu based on the current state of its items.\n   */\n\n\n  MenuButton.prototype.update = function update() {\n    var menu = this.createMenu();\n\n    if (this.menu) {\n      this.menu.dispose();\n      this.removeChild(this.menu);\n    }\n\n    this.menu = menu;\n    this.addChild(menu);\n\n    /**\n     * Track the state of the menu button\n     *\n     * @type {Boolean}\n     * @private\n     */\n    this.buttonPressed_ = false;\n    this.menuButton_.el_.setAttribute('aria-expanded', 'false');\n\n    if (this.items && this.items.length <= this.hideThreshold_) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  };\n\n  /**\n   * Create the menu and add all items to it.\n   *\n   * @return {Menu}\n   *         The constructed menu\n   */\n\n\n  MenuButton.prototype.createMenu = function createMenu() {\n    var menu = new Menu(this.player_, { menuButton: this });\n\n    /**\n     * Hide the menu if the number of items is less than or equal to this threshold. This defaults\n     * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list\n     * it here because every time we run `createMenu` we need to reset the value.\n     *\n     * @protected\n     * @type {Number}\n     */\n    this.hideThreshold_ = 0;\n\n    // Add a title list item to the top\n    if (this.options_.title) {\n      var title = createEl('li', {\n        className: 'vjs-menu-title',\n        innerHTML: toTitleCase(this.options_.title),\n        tabIndex: -1\n      });\n\n      this.hideThreshold_ += 1;\n\n      menu.children_.unshift(title);\n      prependTo(title, menu.contentEl());\n    }\n\n    this.items = this.createItems();\n\n    if (this.items) {\n      // Add menu items to the menu\n      for (var i = 0; i < this.items.length; i++) {\n        menu.addItem(this.items[i]);\n      }\n    }\n\n    return menu;\n  };\n\n  /**\n   * Create the list of menu items. Specific to each subclass.\n   *\n   * @abstract\n   */\n\n\n  MenuButton.prototype.createItems = function createItems() {};\n\n  /**\n   * Create the `MenuButtons`s DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  MenuButton.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: this.buildWrapperCSSClass()\n    }, {});\n  };\n\n  /**\n   * Allow sub components to stack CSS class names for the wrapper element\n   *\n   * @return {string}\n   *         The constructed wrapper DOM `className`\n   */\n\n\n  MenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    var menuButtonClass = 'vjs-menu-button';\n\n    // If the inline option is passed, we want to use different styles altogether.\n    if (this.options_.inline === true) {\n      menuButtonClass += '-inline';\n    } else {\n      menuButtonClass += '-popup';\n    }\n\n    // TODO: Fix the CSS so that this isn't necessary\n    var buttonClass = Button.prototype.buildCSSClass();\n\n    return 'vjs-menu-button ' + menuButtonClass + ' ' + buttonClass + ' ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  MenuButton.prototype.buildCSSClass = function buildCSSClass() {\n    var menuButtonClass = 'vjs-menu-button';\n\n    // If the inline option is passed, we want to use different styles altogether.\n    if (this.options_.inline === true) {\n      menuButtonClass += '-inline';\n    } else {\n      menuButtonClass += '-popup';\n    }\n\n    return 'vjs-menu-button ' + menuButtonClass + ' ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Get or set the localized control text that will be used for accessibility.\n   *\n   * > NOTE: This will come from the internal `menuButton_` element.\n   *\n   * @param {string} [text]\n   *        Control text for element.\n   *\n   * @param {Element} [el=this.menuButton_.el()]\n   *        Element to set the title on.\n   *\n   * @return {string}\n   *         - The control text when getting\n   */\n\n\n  MenuButton.prototype.controlText = function controlText(text) {\n    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.menuButton_.el();\n\n    return this.menuButton_.controlText(text, el);\n  };\n\n  /**\n   * Handle a click on a `MenuButton`.\n   * See {@link ClickableComponent#handleClick} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  MenuButton.prototype.handleClick = function handleClick(event) {\n    // When you click the button it adds focus, which will show the menu.\n    // So we'll remove focus when the mouse leaves the button. Focus is needed\n    // for tab navigation.\n\n    this.one(this.menu.contentEl(), 'mouseleave', bind(this, function (e) {\n      this.unpressButton();\n      this.el_.blur();\n    }));\n    if (this.buttonPressed_) {\n      this.unpressButton();\n    } else {\n      this.pressButton();\n    }\n  };\n\n  /**\n   * Set the focus to the actual button, not to this element\n   */\n\n\n  MenuButton.prototype.focus = function focus() {\n    this.menuButton_.focus();\n  };\n\n  /**\n   * Remove the focus from the actual button, not this element\n   */\n\n\n  MenuButton.prototype.blur = function blur() {\n    this.menuButton_.blur();\n  };\n\n  /**\n   * This gets called when a `MenuButton` gains focus via a `focus` event.\n   * Turns on listening for `keydown` events. When they happen it\n   * calls `this.handleKeyPress`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to be called.\n   *\n   * @listens focus\n   */\n\n\n  MenuButton.prototype.handleFocus = function handleFocus() {\n    on(global_document__WEBPACK_IMPORTED_MODULE_1___default.a, 'keydown', bind(this, this.handleKeyPress));\n  };\n\n  /**\n   * Called when a `MenuButton` loses focus. Turns off the listener for\n   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to be called.\n   *\n   * @listens blur\n   */\n\n\n  MenuButton.prototype.handleBlur = function handleBlur() {\n    off(global_document__WEBPACK_IMPORTED_MODULE_1___default.a, 'keydown', bind(this, this.handleKeyPress));\n  };\n\n  /**\n   * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See\n   * {@link ClickableComponent#handleKeyPress} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n\n\n  MenuButton.prototype.handleKeyPress = function handleKeyPress(event) {\n\n    // Escape (27) key or Tab (9) key unpress the 'button'\n    if (event.which === 27 || event.which === 9) {\n      if (this.buttonPressed_) {\n        this.unpressButton();\n      }\n      // Don't preventDefault for Tab key - we still want to lose focus\n      if (event.which !== 9) {\n        event.preventDefault();\n        // Set focus back to the menu button's button\n        this.menuButton_.el_.focus();\n      }\n      // Up (38) key or Down (40) key press the 'button'\n    } else if (event.which === 38 || event.which === 40) {\n      if (!this.buttonPressed_) {\n        this.pressButton();\n        event.preventDefault();\n      }\n    }\n  };\n\n  /**\n   * Handle a `keydown` event on a sub-menu. The listener for this is added in\n   * the constructor.\n   *\n   * @param {EventTarget~Event} event\n   *        Key press event\n   *\n   * @listens keydown\n   */\n\n\n  MenuButton.prototype.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {\n\n    // Escape (27) key or Tab (9) key unpress the 'button'\n    if (event.which === 27 || event.which === 9) {\n      if (this.buttonPressed_) {\n        this.unpressButton();\n      }\n      // Don't preventDefault for Tab key - we still want to lose focus\n      if (event.which !== 9) {\n        event.preventDefault();\n        // Set focus back to the menu button's button\n        this.menuButton_.el_.focus();\n      }\n    }\n  };\n\n  /**\n   * Put the current `MenuButton` into a pressed state.\n   */\n\n\n  MenuButton.prototype.pressButton = function pressButton() {\n    if (this.enabled_) {\n      this.buttonPressed_ = true;\n      this.menu.lockShowing();\n      this.menuButton_.el_.setAttribute('aria-expanded', 'true');\n\n      // set the focus into the submenu, except on iOS where it is resulting in\n      // undesired scrolling behavior when the player is in an iframe\n      if (IS_IOS && isInFrame()) {\n        // Return early so that the menu isn't focused\n        return;\n      }\n\n      this.menu.focus();\n    }\n  };\n\n  /**\n   * Take the current `MenuButton` out of a pressed state.\n   */\n\n\n  MenuButton.prototype.unpressButton = function unpressButton() {\n    if (this.enabled_) {\n      this.buttonPressed_ = false;\n      this.menu.unlockShowing();\n      this.menuButton_.el_.setAttribute('aria-expanded', 'false');\n    }\n  };\n\n  /**\n   * Disable the `MenuButton`. Don't allow it to be clicked.\n   */\n\n\n  MenuButton.prototype.disable = function disable() {\n    this.unpressButton();\n\n    this.enabled_ = false;\n    this.addClass('vjs-disabled');\n\n    this.menuButton_.disable();\n  };\n\n  /**\n   * Enable the `MenuButton`. Allow it to be clicked.\n   */\n\n\n  MenuButton.prototype.enable = function enable() {\n    this.enabled_ = true;\n    this.removeClass('vjs-disabled');\n\n    this.menuButton_.enable();\n  };\n\n  return MenuButton;\n}(Component);\n\nComponent.registerComponent('MenuButton', MenuButton);\n\n/**\n * @file track-button.js\n */\n\n/**\n * The base class for buttons that toggle specific  track types (e.g. subtitles).\n *\n * @extends MenuButton\n */\n\nvar TrackButton = function (_MenuButton) {\n  inherits(TrackButton, _MenuButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function TrackButton(player, options) {\n    classCallCheck(this, TrackButton);\n\n    var tracks = options.tracks;\n\n    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));\n\n    if (_this.items.length <= 1) {\n      _this.hide();\n    }\n\n    if (!tracks) {\n      return possibleConstructorReturn(_this);\n    }\n\n    var updateHandler = bind(_this, _this.update);\n\n    tracks.addEventListener('removetrack', updateHandler);\n    tracks.addEventListener('addtrack', updateHandler);\n    _this.player_.on('ready', updateHandler);\n\n    _this.player_.on('dispose', function () {\n      tracks.removeEventListener('removetrack', updateHandler);\n      tracks.removeEventListener('addtrack', updateHandler);\n    });\n    return _this;\n  }\n\n  return TrackButton;\n}(MenuButton);\n\nComponent.registerComponent('TrackButton', TrackButton);\n\n/**\n * @file menu-item.js\n */\n\n/**\n * The component for a menu item. `<li>`\n *\n * @extends ClickableComponent\n */\n\nvar MenuItem = function (_ClickableComponent) {\n  inherits(MenuItem, _ClickableComponent);\n\n  /**\n   * Creates an instance of the this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   *\n   */\n  function MenuItem(player, options) {\n    classCallCheck(this, MenuItem);\n\n    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));\n\n    _this.selectable = options.selectable;\n    _this.isSelected_ = options.selected || false;\n    _this.multiSelectable = options.multiSelectable;\n\n    _this.selected(_this.isSelected_);\n\n    if (_this.selectable) {\n      if (_this.multiSelectable) {\n        _this.el_.setAttribute('role', 'menuitemcheckbox');\n      } else {\n        _this.el_.setAttribute('role', 'menuitemradio');\n      }\n    } else {\n      _this.el_.setAttribute('role', 'menuitem');\n    }\n    return _this;\n  }\n\n  /**\n   * Create the `MenuItem's DOM element\n   *\n   * @param {string} [type=li]\n   *        Element's node type, not actually used, always set to `li`.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element\n   *\n   * @param {Object} [attrs={}]\n   *        An object of attributes that should be set on the element\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  MenuItem.prototype.createEl = function createEl(type, props, attrs) {\n    // The control is textual, not just an icon\n    this.nonIconControl = true;\n\n    return _ClickableComponent.prototype.createEl.call(this, 'li', assign({\n      className: 'vjs-menu-item',\n      innerHTML: '<span class=\"vjs-menu-item-text\">' + this.localize(this.options_.label) + '</span>',\n      tabIndex: -1\n    }, props), attrs);\n  };\n\n  /**\n   * Any click on a `MenuItem` puts it into the selected state.\n   * See {@link ClickableComponent#handleClick} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  MenuItem.prototype.handleClick = function handleClick(event) {\n    this.selected(true);\n  };\n\n  /**\n   * Set the state for this menu item as selected or not.\n   *\n   * @param {boolean} selected\n   *        if the menu item is selected or not\n   */\n\n\n  MenuItem.prototype.selected = function selected(_selected) {\n    if (this.selectable) {\n      if (_selected) {\n        this.addClass('vjs-selected');\n        this.el_.setAttribute('aria-checked', 'true');\n        // aria-checked isn't fully supported by browsers/screen readers,\n        // so indicate selected state to screen reader in the control text.\n        this.controlText(', selected');\n        this.isSelected_ = true;\n      } else {\n        this.removeClass('vjs-selected');\n        this.el_.setAttribute('aria-checked', 'false');\n        // Indicate un-selected state to screen reader\n        this.controlText('');\n        this.isSelected_ = false;\n      }\n    }\n  };\n\n  return MenuItem;\n}(ClickableComponent);\n\nComponent.registerComponent('MenuItem', MenuItem);\n\n/**\n * @file text-track-menu-item.js\n */\n\n/**\n * The specific menu item type for selecting a language within a text track kind\n *\n * @extends MenuItem\n */\n\nvar TextTrackMenuItem = function (_MenuItem) {\n  inherits(TextTrackMenuItem, _MenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function TextTrackMenuItem(player, options) {\n    classCallCheck(this, TextTrackMenuItem);\n\n    var track = options.track;\n    var tracks = player.textTracks();\n\n    // Modify options for parent MenuItem class's init.\n    options.label = track.label || track.language || 'Unknown';\n    options.selected = track.mode === 'showing';\n\n    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));\n\n    _this.track = track;\n    var changeHandler = function changeHandler() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this.handleTracksChange.apply(_this, args);\n    };\n    var selectedLanguageChangeHandler = function selectedLanguageChangeHandler() {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.handleSelectedLanguageChange.apply(_this, args);\n    };\n\n    player.on(['loadstart', 'texttrackchange'], changeHandler);\n    tracks.addEventListener('change', changeHandler);\n    tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\n    _this.on('dispose', function () {\n      player.off(['loadstart', 'texttrackchange'], changeHandler);\n      tracks.removeEventListener('change', changeHandler);\n      tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\n    });\n\n    // iOS7 doesn't dispatch change events to TextTrackLists when an\n    // associated track's mode changes. Without something like\n    // Object.observe() (also not present on iOS7), it's not\n    // possible to detect changes to the mode attribute and polyfill\n    // the change event. As a poor substitute, we manually dispatch\n    // change events whenever the controls modify the mode.\n    if (tracks.onchange === undefined) {\n      var event = void 0;\n\n      _this.on(['tap', 'click'], function () {\n        if (_typeof(global_window__WEBPACK_IMPORTED_MODULE_0___default.a.Event) !== 'object') {\n          // Android 2.3 throws an Illegal Constructor error for window.Event\n          try {\n            event = new global_window__WEBPACK_IMPORTED_MODULE_0___default.a.Event('change');\n          } catch (err) {\n            // continue regardless of error\n          }\n        }\n\n        if (!event) {\n          event = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createEvent('Event');\n          event.initEvent('change', true, true);\n        }\n\n        tracks.dispatchEvent(event);\n      });\n    }\n\n    // set the default state based on current tracks\n    _this.handleTracksChange();\n    return _this;\n  }\n\n  /**\n   * This gets called when an `TextTrackMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  TextTrackMenuItem.prototype.handleClick = function handleClick(event) {\n    var kind = this.track.kind;\n    var kinds = this.track.kinds;\n    var tracks = this.player_.textTracks();\n\n    if (!kinds) {\n      kinds = [kind];\n    }\n\n    _MenuItem.prototype.handleClick.call(this, event);\n\n    if (!tracks) {\n      return;\n    }\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      if (track === this.track && kinds.indexOf(track.kind) > -1) {\n        if (track.mode !== 'showing') {\n          track.mode = 'showing';\n        }\n      } else if (track.mode !== 'disabled') {\n        track.mode = 'disabled';\n      }\n    }\n  };\n\n  /**\n   * Handle text track list change\n   *\n   * @param {EventTarget~Event} event\n   *        The `change` event that caused this function to be called.\n   *\n   * @listens TextTrackList#change\n   */\n\n\n  TextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\n    var shouldBeSelected = this.track.mode === 'showing';\n\n    // Prevent redundant selected() calls because they may cause\n    // screen readers to read the appended control text unnecessarily\n    if (shouldBeSelected !== this.isSelected_) {\n      this.selected(shouldBeSelected);\n    }\n  };\n\n  TextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {\n    if (this.track.mode === 'showing') {\n      var selectedLanguage = this.player_.cache_.selectedLanguage;\n\n      // Don't replace the kind of track across the same language\n      if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {\n        return;\n      }\n\n      this.player_.cache_.selectedLanguage = {\n        enabled: true,\n        language: this.track.language,\n        kind: this.track.kind\n      };\n    }\n  };\n\n  TextTrackMenuItem.prototype.dispose = function dispose() {\n    // remove reference to track object on dispose\n    this.track = null;\n\n    _MenuItem.prototype.dispose.call(this);\n  };\n\n  return TextTrackMenuItem;\n}(MenuItem);\n\nComponent.registerComponent('TextTrackMenuItem', TextTrackMenuItem);\n\n/**\n * @file off-text-track-menu-item.js\n */\n\n/**\n * A special menu item for turning of a specific type of text track\n *\n * @extends TextTrackMenuItem\n */\n\nvar OffTextTrackMenuItem = function (_TextTrackMenuItem) {\n  inherits(OffTextTrackMenuItem, _TextTrackMenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function OffTextTrackMenuItem(player, options) {\n    classCallCheck(this, OffTextTrackMenuItem);\n\n    // Create pseudo track info\n    // Requires options['kind']\n    options.track = {\n      player: player,\n      kind: options.kind,\n      kinds: options.kinds,\n      default: false,\n      mode: 'disabled'\n    };\n\n    if (!options.kinds) {\n      options.kinds = [options.kind];\n    }\n\n    if (options.label) {\n      options.track.label = options.label;\n    } else {\n      options.track.label = options.kinds.join(' and ') + ' off';\n    }\n\n    // MenuItem is selectable\n    options.selectable = true;\n    // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n    options.multiSelectable = false;\n\n    return possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));\n  }\n\n  /**\n   * Handle text track change\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run\n   */\n\n\n  OffTextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\n    var tracks = this.player().textTracks();\n    var shouldBeSelected = true;\n\n    for (var i = 0, l = tracks.length; i < l; i++) {\n      var track = tracks[i];\n\n      if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {\n        shouldBeSelected = false;\n        break;\n      }\n    }\n\n    // Prevent redundant selected() calls because they may cause\n    // screen readers to read the appended control text unnecessarily\n    if (shouldBeSelected !== this.isSelected_) {\n      this.selected(shouldBeSelected);\n    }\n  };\n\n  OffTextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {\n    var tracks = this.player().textTracks();\n    var allHidden = true;\n\n    for (var i = 0, l = tracks.length; i < l; i++) {\n      var track = tracks[i];\n\n      if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {\n        allHidden = false;\n        break;\n      }\n    }\n\n    if (allHidden) {\n      this.player_.cache_.selectedLanguage = {\n        enabled: false\n      };\n    }\n  };\n\n  return OffTextTrackMenuItem;\n}(TextTrackMenuItem);\n\nComponent.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);\n\n/**\n * @file text-track-button.js\n */\n\n/**\n * The base class for buttons that toggle specific text track types (e.g. subtitles)\n *\n * @extends MenuButton\n */\n\nvar TextTrackButton = function (_TrackButton) {\n  inherits(TextTrackButton, _TrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function TextTrackButton(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, TextTrackButton);\n\n    options.tracks = player.textTracks();\n\n    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));\n  }\n\n  /**\n   * Create a menu item for each text track\n   *\n   * @param {TextTrackMenuItem[]} [items=[]]\n   *        Existing array of items to use during creation\n   *\n   * @return {TextTrackMenuItem[]}\n   *         Array of menu items that were created\n   */\n\n\n  TextTrackButton.prototype.createItems = function createItems() {\n    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var TrackMenuItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TextTrackMenuItem;\n\n\n    // Label is an override for the [track] off label\n    // USed to localise captions/subtitles\n    var label = void 0;\n\n    if (this.label_) {\n      label = this.label_ + ' off';\n    }\n    // Add an OFF menu item to turn all tracks off\n    items.push(new OffTextTrackMenuItem(this.player_, {\n      kinds: this.kinds_,\n      kind: this.kind_,\n      label: label\n    }));\n\n    this.hideThreshold_ += 1;\n\n    var tracks = this.player_.textTracks();\n\n    if (!Array.isArray(this.kinds_)) {\n      this.kinds_ = [this.kind_];\n    }\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      // only add tracks that are of an appropriate kind and have a label\n      if (this.kinds_.indexOf(track.kind) > -1) {\n\n        var item = new TrackMenuItem(this.player_, {\n          track: track,\n          // MenuItem is selectable\n          selectable: true,\n          // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n          multiSelectable: false\n        });\n\n        item.addClass('vjs-' + track.kind + '-menu-item');\n        items.push(item);\n      }\n    }\n\n    return items;\n  };\n\n  return TextTrackButton;\n}(TrackButton);\n\nComponent.registerComponent('TextTrackButton', TextTrackButton);\n\n/**\n * @file chapters-track-menu-item.js\n */\n\n/**\n * The chapter track menu item\n *\n * @extends MenuItem\n */\n\nvar ChaptersTrackMenuItem = function (_MenuItem) {\n  inherits(ChaptersTrackMenuItem, _MenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function ChaptersTrackMenuItem(player, options) {\n    classCallCheck(this, ChaptersTrackMenuItem);\n\n    var track = options.track;\n    var cue = options.cue;\n    var currentTime = player.currentTime();\n\n    // Modify options for parent MenuItem class's init.\n    options.selectable = true;\n    options.multiSelectable = false;\n    options.label = cue.text;\n    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;\n\n    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));\n\n    _this.track = track;\n    _this.cue = cue;\n    track.addEventListener('cuechange', bind(_this, _this.update));\n    return _this;\n  }\n\n  /**\n   * This gets called when an `ChaptersTrackMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  ChaptersTrackMenuItem.prototype.handleClick = function handleClick(event) {\n    _MenuItem.prototype.handleClick.call(this);\n    this.player_.currentTime(this.cue.startTime);\n    this.update(this.cue.startTime);\n  };\n\n  /**\n   * Update chapter menu item\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `cuechange` event that caused this function to run.\n   *\n   * @listens TextTrack#cuechange\n   */\n\n\n  ChaptersTrackMenuItem.prototype.update = function update(event) {\n    var cue = this.cue;\n    var currentTime = this.player_.currentTime();\n\n    // vjs.log(currentTime, cue.startTime);\n    this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);\n  };\n\n  return ChaptersTrackMenuItem;\n}(MenuItem);\n\nComponent.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);\n\n/**\n * @file chapters-button.js\n */\n\n/**\n * The button component for toggling and selecting chapters\n * Chapters act much differently than other text tracks\n * Cues are navigation vs. other tracks of alternative languages\n *\n * @extends TextTrackButton\n */\n\nvar ChaptersButton = function (_TextTrackButton) {\n  inherits(ChaptersButton, _TextTrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this function is ready.\n   */\n  function ChaptersButton(player, options, ready) {\n    classCallCheck(this, ChaptersButton);\n    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  ChaptersButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  ChaptersButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Update the menu based on the current state of its items.\n   *\n   * @param {EventTarget~Event} [event]\n   *        An event that triggered this function to run.\n   *\n   * @listens TextTrackList#addtrack\n   * @listens TextTrackList#removetrack\n   * @listens TextTrackList#change\n   */\n\n\n  ChaptersButton.prototype.update = function update(event) {\n    if (!this.track_ || event && (event.type === 'addtrack' || event.type === 'removetrack')) {\n      this.setTrack(this.findChaptersTrack());\n    }\n    _TextTrackButton.prototype.update.call(this);\n  };\n\n  /**\n   * Set the currently selected track for the chapters button.\n   *\n   * @param {TextTrack} track\n   *        The new track to select. Nothing will change if this is the currently selected\n   *        track.\n   */\n\n\n  ChaptersButton.prototype.setTrack = function setTrack(track) {\n    if (this.track_ === track) {\n      return;\n    }\n\n    if (!this.updateHandler_) {\n      this.updateHandler_ = this.update.bind(this);\n    }\n\n    // here this.track_ refers to the old track instance\n    if (this.track_) {\n      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\n\n      if (remoteTextTrackEl) {\n        remoteTextTrackEl.removeEventListener('load', this.updateHandler_);\n      }\n\n      this.track_ = null;\n    }\n\n    this.track_ = track;\n\n    // here this.track_ refers to the new track instance\n    if (this.track_) {\n      this.track_.mode = 'hidden';\n\n      var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\n\n      if (_remoteTextTrackEl) {\n        _remoteTextTrackEl.addEventListener('load', this.updateHandler_);\n      }\n    }\n  };\n\n  /**\n   * Find the track object that is currently in use by this ChaptersButton\n   *\n   * @return {TextTrack|undefined}\n   *         The current track or undefined if none was found.\n   */\n\n\n  ChaptersButton.prototype.findChaptersTrack = function findChaptersTrack() {\n    var tracks = this.player_.textTracks() || [];\n\n    for (var i = tracks.length - 1; i >= 0; i--) {\n      // We will always choose the last track as our chaptersTrack\n      var track = tracks[i];\n\n      if (track.kind === this.kind_) {\n        return track;\n      }\n    }\n  };\n\n  /**\n   * Get the caption for the ChaptersButton based on the track label. This will also\n   * use the current tracks localized kind as a fallback if a label does not exist.\n   *\n   * @return {string}\n   *         The tracks current label or the localized track kind.\n   */\n\n\n  ChaptersButton.prototype.getMenuCaption = function getMenuCaption() {\n    if (this.track_ && this.track_.label) {\n      return this.track_.label;\n    }\n    return this.localize(toTitleCase(this.kind_));\n  };\n\n  /**\n   * Create menu from chapter track\n   *\n   * @return {Menu}\n   *         New menu for the chapter buttons\n   */\n\n\n  ChaptersButton.prototype.createMenu = function createMenu() {\n    this.options_.title = this.getMenuCaption();\n    return _TextTrackButton.prototype.createMenu.call(this);\n  };\n\n  /**\n   * Create a menu item for each text track\n   *\n   * @return {TextTrackMenuItem[]}\n   *         Array of menu items\n   */\n\n\n  ChaptersButton.prototype.createItems = function createItems() {\n    var items = [];\n\n    if (!this.track_) {\n      return items;\n    }\n\n    var cues = this.track_.cues;\n\n    if (!cues) {\n      return items;\n    }\n\n    for (var i = 0, l = cues.length; i < l; i++) {\n      var cue = cues[i];\n      var mi = new ChaptersTrackMenuItem(this.player_, { track: this.track_, cue: cue });\n\n      items.push(mi);\n    }\n\n    return items;\n  };\n\n  return ChaptersButton;\n}(TextTrackButton);\n\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nChaptersButton.prototype.kind_ = 'chapters';\n\n/**\n * The text that should display over the `ChaptersButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nChaptersButton.prototype.controlText_ = 'Chapters';\n\nComponent.registerComponent('ChaptersButton', ChaptersButton);\n\n/**\n * @file descriptions-button.js\n */\n\n/**\n * The button component for toggling and selecting descriptions\n *\n * @extends TextTrackButton\n */\n\nvar DescriptionsButton = function (_TextTrackButton) {\n  inherits(DescriptionsButton, _TextTrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */\n  function DescriptionsButton(player, options, ready) {\n    classCallCheck(this, DescriptionsButton);\n\n    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));\n\n    var tracks = player.textTracks();\n    var changeHandler = bind(_this, _this.handleTracksChange);\n\n    tracks.addEventListener('change', changeHandler);\n    _this.on('dispose', function () {\n      tracks.removeEventListener('change', changeHandler);\n    });\n    return _this;\n  }\n\n  /**\n   * Handle text track change\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run\n   *\n   * @listens TextTrackList#change\n   */\n\n\n  DescriptionsButton.prototype.handleTracksChange = function handleTracksChange(event) {\n    var tracks = this.player().textTracks();\n    var disabled = false;\n\n    // Check whether a track of a different kind is showing\n    for (var i = 0, l = tracks.length; i < l; i++) {\n      var track = tracks[i];\n\n      if (track.kind !== this.kind_ && track.mode === 'showing') {\n        disabled = true;\n        break;\n      }\n    }\n\n    // If another track is showing, disable this menu button\n    if (disabled) {\n      this.disable();\n    } else {\n      this.enable();\n    }\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  DescriptionsButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  DescriptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  return DescriptionsButton;\n}(TextTrackButton);\n\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nDescriptionsButton.prototype.kind_ = 'descriptions';\n\n/**\n * The text that should display over the `DescriptionsButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nDescriptionsButton.prototype.controlText_ = 'Descriptions';\n\nComponent.registerComponent('DescriptionsButton', DescriptionsButton);\n\n/**\n * @file subtitles-button.js\n */\n\n/**\n * The button component for toggling and selecting subtitles\n *\n * @extends TextTrackButton\n */\n\nvar SubtitlesButton = function (_TextTrackButton) {\n  inherits(SubtitlesButton, _TextTrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */\n  function SubtitlesButton(player, options, ready) {\n    classCallCheck(this, SubtitlesButton);\n    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  SubtitlesButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  SubtitlesButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  return SubtitlesButton;\n}(TextTrackButton);\n\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nSubtitlesButton.prototype.kind_ = 'subtitles';\n\n/**\n * The text that should display over the `SubtitlesButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nSubtitlesButton.prototype.controlText_ = 'Subtitles';\n\nComponent.registerComponent('SubtitlesButton', SubtitlesButton);\n\n/**\n * @file caption-settings-menu-item.js\n */\n\n/**\n * The menu item for caption track settings menu\n *\n * @extends TextTrackMenuItem\n */\n\nvar CaptionSettingsMenuItem = function (_TextTrackMenuItem) {\n  inherits(CaptionSettingsMenuItem, _TextTrackMenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function CaptionSettingsMenuItem(player, options) {\n    classCallCheck(this, CaptionSettingsMenuItem);\n\n    options.track = {\n      player: player,\n      kind: options.kind,\n      label: options.kind + ' settings',\n      selectable: false,\n      default: false,\n      mode: 'disabled'\n    };\n\n    // CaptionSettingsMenuItem has no concept of 'selected'\n    options.selectable = false;\n\n    options.name = 'CaptionSettingsMenuItem';\n\n    var _this = possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));\n\n    _this.addClass('vjs-texttrack-settings');\n    _this.controlText(', opens ' + options.kind + ' settings dialog');\n    return _this;\n  }\n\n  /**\n   * This gets called when an `CaptionSettingsMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  CaptionSettingsMenuItem.prototype.handleClick = function handleClick(event) {\n    this.player().getChild('textTrackSettings').open();\n  };\n\n  return CaptionSettingsMenuItem;\n}(TextTrackMenuItem);\n\nComponent.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);\n\n/**\n * @file captions-button.js\n */\n\n/**\n * The button component for toggling and selecting captions\n *\n * @extends TextTrackButton\n */\n\nvar CaptionsButton = function (_TextTrackButton) {\n  inherits(CaptionsButton, _TextTrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */\n  function CaptionsButton(player, options, ready) {\n    classCallCheck(this, CaptionsButton);\n    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  CaptionsButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  CaptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Create caption menu items\n   *\n   * @return {CaptionSettingsMenuItem[]}\n   *         The array of current menu items.\n   */\n\n\n  CaptionsButton.prototype.createItems = function createItems() {\n    var items = [];\n\n    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {\n      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.kind_ }));\n\n      this.hideThreshold_ += 1;\n    }\n\n    return _TextTrackButton.prototype.createItems.call(this, items);\n  };\n\n  return CaptionsButton;\n}(TextTrackButton);\n\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nCaptionsButton.prototype.kind_ = 'captions';\n\n/**\n * The text that should display over the `CaptionsButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nCaptionsButton.prototype.controlText_ = 'Captions';\n\nComponent.registerComponent('CaptionsButton', CaptionsButton);\n\n/**\n * @file subs-caps-menu-item.js\n */\n\n/**\n * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles\n * in the SubsCapsMenu.\n *\n * @extends TextTrackMenuItem\n */\n\nvar SubsCapsMenuItem = function (_TextTrackMenuItem) {\n  inherits(SubsCapsMenuItem, _TextTrackMenuItem);\n\n  function SubsCapsMenuItem() {\n    classCallCheck(this, SubsCapsMenuItem);\n    return possibleConstructorReturn(this, _TextTrackMenuItem.apply(this, arguments));\n  }\n\n  SubsCapsMenuItem.prototype.createEl = function createEl(type, props, attrs) {\n    var innerHTML = '<span class=\"vjs-menu-item-text\">' + this.localize(this.options_.label);\n\n    if (this.options_.track.kind === 'captions') {\n      innerHTML += '\\n        <span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>\\n        <span class=\"vjs-control-text\"> ' + this.localize('Captions') + '</span>\\n      ';\n    }\n\n    innerHTML += '</span>';\n\n    var el = _TextTrackMenuItem.prototype.createEl.call(this, type, assign({\n      innerHTML: innerHTML\n    }, props), attrs);\n\n    return el;\n  };\n\n  return SubsCapsMenuItem;\n}(TextTrackMenuItem);\n\nComponent.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);\n\n/**\n * @file sub-caps-button.js\n */\n/**\n * The button component for toggling and selecting captions and/or subtitles\n *\n * @extends TextTrackButton\n */\n\nvar SubsCapsButton = function (_TextTrackButton) {\n  inherits(SubsCapsButton, _TextTrackButton);\n\n  function SubsCapsButton(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, SubsCapsButton);\n\n    // Although North America uses \"captions\" in most cases for\n    // \"captions and subtitles\" other locales use \"subtitles\"\n    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options));\n\n    _this.label_ = 'subtitles';\n    if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(_this.player_.language_) > -1) {\n      _this.label_ = 'captions';\n    }\n    _this.menuButton_.controlText(toTitleCase(_this.label_));\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  SubsCapsButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  SubsCapsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Create caption/subtitles menu items\n   *\n   * @return {CaptionSettingsMenuItem[]}\n   *         The array of current menu items.\n   */\n\n\n  SubsCapsButton.prototype.createItems = function createItems() {\n    var items = [];\n\n    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {\n      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.label_ }));\n\n      this.hideThreshold_ += 1;\n    }\n\n    items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);\n    return items;\n  };\n\n  return SubsCapsButton;\n}(TextTrackButton);\n\n/**\n * `kind`s of TextTrack to look for to associate it with this menu.\n *\n * @type {array}\n * @private\n */\n\n\nSubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];\n\n/**\n * The text that should display over the `SubsCapsButton`s controls.\n *\n *\n * @type {string}\n * @private\n */\nSubsCapsButton.prototype.controlText_ = 'Subtitles';\n\nComponent.registerComponent('SubsCapsButton', SubsCapsButton);\n\n/**\n * @file audio-track-menu-item.js\n */\n\n/**\n * An {@link AudioTrack} {@link MenuItem}\n *\n * @extends MenuItem\n */\n\nvar AudioTrackMenuItem = function (_MenuItem) {\n  inherits(AudioTrackMenuItem, _MenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function AudioTrackMenuItem(player, options) {\n    classCallCheck(this, AudioTrackMenuItem);\n\n    var track = options.track;\n    var tracks = player.audioTracks();\n\n    // Modify options for parent MenuItem class's init.\n    options.label = track.label || track.language || 'Unknown';\n    options.selected = track.enabled;\n\n    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));\n\n    _this.track = track;\n\n    _this.addClass('vjs-' + track.kind + '-menu-item');\n\n    var changeHandler = function changeHandler() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this.handleTracksChange.apply(_this, args);\n    };\n\n    tracks.addEventListener('change', changeHandler);\n    _this.on('dispose', function () {\n      tracks.removeEventListener('change', changeHandler);\n    });\n    return _this;\n  }\n\n  AudioTrackMenuItem.prototype.createEl = function createEl(type, props, attrs) {\n    var innerHTML = '<span class=\"vjs-menu-item-text\">' + this.localize(this.options_.label);\n\n    if (this.options_.track.kind === 'main-desc') {\n      innerHTML += '\\n        <span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>\\n        <span class=\"vjs-control-text\"> ' + this.localize('Descriptions') + '</span>\\n      ';\n    }\n\n    innerHTML += '</span>';\n\n    var el = _MenuItem.prototype.createEl.call(this, type, assign({\n      innerHTML: innerHTML\n    }, props), attrs);\n\n    return el;\n  };\n\n  /**\n   * This gets called when an `AudioTrackMenuItem is \"clicked\". See {@link ClickableComponent}\n   * for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  AudioTrackMenuItem.prototype.handleClick = function handleClick(event) {\n    var tracks = this.player_.audioTracks();\n\n    _MenuItem.prototype.handleClick.call(this, event);\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      track.enabled = track === this.track;\n    }\n  };\n\n  /**\n   * Handle any {@link AudioTrack} change.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link AudioTrackList#change} event that caused this to run.\n   *\n   * @listens AudioTrackList#change\n   */\n\n\n  AudioTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\n    this.selected(this.track.enabled);\n  };\n\n  return AudioTrackMenuItem;\n}(MenuItem);\n\nComponent.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);\n\n/**\n * @file audio-track-button.js\n */\n\n/**\n * The base class for buttons that toggle specific {@link AudioTrack} types.\n *\n * @extends TrackButton\n */\n\nvar AudioTrackButton = function (_TrackButton) {\n  inherits(AudioTrackButton, _TrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function AudioTrackButton(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, AudioTrackButton);\n\n    options.tracks = player.audioTracks();\n\n    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  AudioTrackButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-audio-button ' + _TrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  AudioTrackButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-audio-button ' + _TrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Create a menu item for each audio track\n   *\n   * @param {AudioTrackMenuItem[]} [items=[]]\n   *        An array of existing menu items to use.\n   *\n   * @return {AudioTrackMenuItem[]}\n   *         An array of menu items\n   */\n\n\n  AudioTrackButton.prototype.createItems = function createItems() {\n    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    // if there's only one audio track, there no point in showing it\n    this.hideThreshold_ = 1;\n\n    var tracks = this.player_.audioTracks();\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      items.push(new AudioTrackMenuItem(this.player_, {\n        track: track,\n        // MenuItem is selectable\n        selectable: true,\n        // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n        multiSelectable: false\n      }));\n    }\n\n    return items;\n  };\n\n  return AudioTrackButton;\n}(TrackButton);\n\n/**\n * The text that should display over the `AudioTrackButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nAudioTrackButton.prototype.controlText_ = 'Audio Track';\nComponent.registerComponent('AudioTrackButton', AudioTrackButton);\n\n/**\n * @file playback-rate-menu-item.js\n */\n\n/**\n * The specific menu item type for selecting a playback rate.\n *\n * @extends MenuItem\n */\n\nvar PlaybackRateMenuItem = function (_MenuItem) {\n  inherits(PlaybackRateMenuItem, _MenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function PlaybackRateMenuItem(player, options) {\n    classCallCheck(this, PlaybackRateMenuItem);\n\n    var label = options.rate;\n    var rate = parseFloat(label, 10);\n\n    // Modify options for parent MenuItem class's init.\n    options.label = label;\n    options.selected = rate === 1;\n    options.selectable = true;\n    options.multiSelectable = false;\n\n    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));\n\n    _this.label = label;\n    _this.rate = rate;\n\n    _this.on(player, 'ratechange', _this.update);\n    return _this;\n  }\n\n  /**\n   * This gets called when an `PlaybackRateMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  PlaybackRateMenuItem.prototype.handleClick = function handleClick(event) {\n    _MenuItem.prototype.handleClick.call(this);\n    this.player().playbackRate(this.rate);\n  };\n\n  /**\n   * Update the PlaybackRateMenuItem when the playbackrate changes.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ratechange` event that caused this function to run.\n   *\n   * @listens Player#ratechange\n   */\n\n\n  PlaybackRateMenuItem.prototype.update = function update(event) {\n    this.selected(this.player().playbackRate() === this.rate);\n  };\n\n  return PlaybackRateMenuItem;\n}(MenuItem);\n\n/**\n * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nPlaybackRateMenuItem.prototype.contentElType = 'button';\n\nComponent.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);\n\n/**\n * @file playback-rate-menu-button.js\n */\n\n/**\n * The component for controlling the playback rate.\n *\n * @extends MenuButton\n */\n\nvar PlaybackRateMenuButton = function (_MenuButton) {\n  inherits(PlaybackRateMenuButton, _MenuButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function PlaybackRateMenuButton(player, options) {\n    classCallCheck(this, PlaybackRateMenuButton);\n\n    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));\n\n    _this.updateVisibility();\n    _this.updateLabel();\n\n    _this.on(player, 'loadstart', _this.updateVisibility);\n    _this.on(player, 'ratechange', _this.updateLabel);\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  PlaybackRateMenuButton.prototype.createEl = function createEl$$1() {\n    var el = _MenuButton.prototype.createEl.call(this);\n\n    this.labelEl_ = createEl('div', {\n      className: 'vjs-playback-rate-value',\n      innerHTML: '1x'\n    });\n\n    el.appendChild(this.labelEl_);\n\n    return el;\n  };\n\n  PlaybackRateMenuButton.prototype.dispose = function dispose() {\n    this.labelEl_ = null;\n\n    _MenuButton.prototype.dispose.call(this);\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  PlaybackRateMenuButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-playback-rate ' + _MenuButton.prototype.buildCSSClass.call(this);\n  };\n\n  PlaybackRateMenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-playback-rate ' + _MenuButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Create the playback rate menu\n   *\n   * @return {Menu}\n   *         Menu object populated with {@link PlaybackRateMenuItem}s\n   */\n\n\n  PlaybackRateMenuButton.prototype.createMenu = function createMenu() {\n    var menu = new Menu(this.player());\n    var rates = this.playbackRates();\n\n    if (rates) {\n      for (var i = rates.length - 1; i >= 0; i--) {\n        menu.addChild(new PlaybackRateMenuItem(this.player(), { rate: rates[i] + 'x' }));\n      }\n    }\n\n    return menu;\n  };\n\n  /**\n   * Updates ARIA accessibility attributes\n   */\n\n\n  PlaybackRateMenuButton.prototype.updateARIAAttributes = function updateARIAAttributes() {\n    // Current playback rate\n    this.el().setAttribute('aria-valuenow', this.player().playbackRate());\n  };\n\n  /**\n   * This gets called when an `PlaybackRateMenuButton` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  PlaybackRateMenuButton.prototype.handleClick = function handleClick(event) {\n    // select next rate option\n    var currentRate = this.player().playbackRate();\n    var rates = this.playbackRates();\n\n    // this will select first one if the last one currently selected\n    var newRate = rates[0];\n\n    for (var i = 0; i < rates.length; i++) {\n      if (rates[i] > currentRate) {\n        newRate = rates[i];\n        break;\n      }\n    }\n    this.player().playbackRate(newRate);\n  };\n\n  /**\n   * Get possible playback rates\n   *\n   * @return {Array}\n   *         All possible playback rates\n   */\n\n\n  PlaybackRateMenuButton.prototype.playbackRates = function playbackRates() {\n    return this.options_.playbackRates || this.options_.playerOptions && this.options_.playerOptions.playbackRates;\n  };\n\n  /**\n   * Get whether playback rates is supported by the tech\n   * and an array of playback rates exists\n   *\n   * @return {boolean}\n   *         Whether changing playback rate is supported\n   */\n\n\n  PlaybackRateMenuButton.prototype.playbackRateSupported = function playbackRateSupported() {\n    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;\n  };\n\n  /**\n   * Hide playback rate controls when they're no playback rate options to select\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#loadstart\n   */\n\n\n  PlaybackRateMenuButton.prototype.updateVisibility = function updateVisibility(event) {\n    if (this.playbackRateSupported()) {\n      this.removeClass('vjs-hidden');\n    } else {\n      this.addClass('vjs-hidden');\n    }\n  };\n\n  /**\n   * Update button label when rate changed\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#ratechange\n   */\n\n\n  PlaybackRateMenuButton.prototype.updateLabel = function updateLabel(event) {\n    if (this.playbackRateSupported()) {\n      this.labelEl_.innerHTML = this.player().playbackRate() + 'x';\n    }\n  };\n\n  return PlaybackRateMenuButton;\n}(MenuButton);\n\n/**\n * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nPlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';\n\nComponent.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);\n\n/**\n * @file spacer.js\n */\n\n/**\n * Just an empty spacer element that can be used as an append point for plugins, etc.\n * Also can be used to create space between elements when necessary.\n *\n * @extends Component\n */\n\nvar Spacer = function (_Component) {\n  inherits(Spacer, _Component);\n\n  function Spacer() {\n    classCallCheck(this, Spacer);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n  Spacer.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-spacer ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  Spacer.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: this.buildCSSClass()\n    });\n  };\n\n  return Spacer;\n}(Component);\n\nComponent.registerComponent('Spacer', Spacer);\n\n/**\n * @file custom-control-spacer.js\n */\n\n/**\n * Spacer specifically meant to be used as an insertion point for new plugins, etc.\n *\n * @extends Spacer\n */\n\nvar CustomControlSpacer = function (_Spacer) {\n  inherits(CustomControlSpacer, _Spacer);\n\n  function CustomControlSpacer() {\n    classCallCheck(this, CustomControlSpacer);\n    return possibleConstructorReturn(this, _Spacer.apply(this, arguments));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n  CustomControlSpacer.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-custom-control-spacer ' + _Spacer.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  CustomControlSpacer.prototype.createEl = function createEl() {\n    var el = _Spacer.prototype.createEl.call(this, {\n      className: this.buildCSSClass()\n    });\n\n    // No-flex/table-cell mode requires there be some content\n    // in the cell to fill the remaining space of the table.\n    el.innerHTML = '\\xA0';\n    return el;\n  };\n\n  return CustomControlSpacer;\n}(Spacer);\n\nComponent.registerComponent('CustomControlSpacer', CustomControlSpacer);\n\n/**\n * @file control-bar.js\n */\n\n/**\n * Container of main controls.\n *\n * @extends Component\n */\n\nvar ControlBar = function (_Component) {\n  inherits(ControlBar, _Component);\n\n  function ControlBar() {\n    classCallCheck(this, ControlBar);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  ControlBar.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-control-bar',\n      dir: 'ltr'\n    });\n  };\n\n  return ControlBar;\n}(Component);\n\n/**\n * Default options for `ControlBar`\n *\n * @type {Object}\n * @private\n */\n\n\nControlBar.prototype.options_ = {\n  children: ['playToggle', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'fullscreenToggle']\n};\n\nComponent.registerComponent('ControlBar', ControlBar);\n\n/**\n * @file error-display.js\n */\n\n/**\n * A display that indicates an error has occurred. This means that the video\n * is unplayable.\n *\n * @extends ModalDialog\n */\n\nvar ErrorDisplay = function (_ModalDialog) {\n  inherits(ErrorDisplay, _ModalDialog);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */\n  function ErrorDisplay(player, options) {\n    classCallCheck(this, ErrorDisplay);\n\n    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));\n\n    _this.on(player, 'error', _this.open);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   *\n   * @deprecated Since version 5.\n   */\n\n\n  ErrorDisplay.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-error-display ' + _ModalDialog.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Gets the localized error message based on the `Player`s error.\n   *\n   * @return {string}\n   *         The `Player`s error message localized or an empty string.\n   */\n\n\n  ErrorDisplay.prototype.content = function content() {\n    var error = this.player().error();\n\n    return error ? this.localize(error.message) : '';\n  };\n\n  return ErrorDisplay;\n}(ModalDialog);\n\n/**\n * The default options for an `ErrorDisplay`.\n *\n * @private\n */\n\n\nErrorDisplay.prototype.options_ = mergeOptions(ModalDialog.prototype.options_, {\n  pauseOnOpen: false,\n  fillAlways: true,\n  temporary: false,\n  uncloseable: true\n});\n\nComponent.registerComponent('ErrorDisplay', ErrorDisplay);\n\n/**\n * @file text-track-settings.js\n */\n\nvar LOCAL_STORAGE_KEY = 'vjs-text-track-settings';\n\nvar COLOR_BLACK = ['#000', 'Black'];\nvar COLOR_BLUE = ['#00F', 'Blue'];\nvar COLOR_CYAN = ['#0FF', 'Cyan'];\nvar COLOR_GREEN = ['#0F0', 'Green'];\nvar COLOR_MAGENTA = ['#F0F', 'Magenta'];\nvar COLOR_RED = ['#F00', 'Red'];\nvar COLOR_WHITE = ['#FFF', 'White'];\nvar COLOR_YELLOW = ['#FF0', 'Yellow'];\n\nvar OPACITY_OPAQUE = ['1', 'Opaque'];\nvar OPACITY_SEMI = ['0.5', 'Semi-Transparent'];\nvar OPACITY_TRANS = ['0', 'Transparent'];\n\n// Configuration for the various <select> elements in the DOM of this component.\n//\n// Possible keys include:\n//\n// `default`:\n//   The default option index. Only needs to be provided if not zero.\n// `parser`:\n//   A function which is used to parse the value from the selected option in\n//   a customized way.\n// `selector`:\n//   The selector used to find the associated <select> element.\nvar selectConfigs = {\n  backgroundColor: {\n    selector: '.vjs-bg-color > select',\n    id: 'captions-background-color-%s',\n    label: 'Color',\n    options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\n  },\n\n  backgroundOpacity: {\n    selector: '.vjs-bg-opacity > select',\n    id: 'captions-background-opacity-%s',\n    label: 'Transparency',\n    options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]\n  },\n\n  color: {\n    selector: '.vjs-fg-color > select',\n    id: 'captions-foreground-color-%s',\n    label: 'Color',\n    options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\n  },\n\n  edgeStyle: {\n    selector: '.vjs-edge-style > select',\n    id: '%s',\n    label: 'Text Edge Style',\n    options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Dropshadow']]\n  },\n\n  fontFamily: {\n    selector: '.vjs-font-family > select',\n    id: 'captions-font-family-%s',\n    label: 'Font Family',\n    options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]\n  },\n\n  fontPercent: {\n    selector: '.vjs-font-percent > select',\n    id: 'captions-font-size-%s',\n    label: 'Font Size',\n    options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],\n    default: 2,\n    parser: function parser(v) {\n      return v === '1.00' ? null : Number(v);\n    }\n  },\n\n  textOpacity: {\n    selector: '.vjs-text-opacity > select',\n    id: 'captions-foreground-opacity-%s',\n    label: 'Transparency',\n    options: [OPACITY_OPAQUE, OPACITY_SEMI]\n  },\n\n  // Options for this object are defined below.\n  windowColor: {\n    selector: '.vjs-window-color > select',\n    id: 'captions-window-color-%s',\n    label: 'Color'\n  },\n\n  // Options for this object are defined below.\n  windowOpacity: {\n    selector: '.vjs-window-opacity > select',\n    id: 'captions-window-opacity-%s',\n    label: 'Transparency',\n    options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]\n  }\n};\n\nselectConfigs.windowColor.options = selectConfigs.backgroundColor.options;\n\n/**\n * Get the actual value of an option.\n *\n * @param  {string} value\n *         The value to get\n *\n * @param  {Function} [parser]\n *         Optional function to adjust the value.\n *\n * @return {Mixed}\n *         - Will be `undefined` if no value exists\n *         - Will be `undefined` if the given value is \"none\".\n *         - Will be the actual value otherwise.\n *\n * @private\n */\nfunction parseOptionValue(value, parser) {\n  if (parser) {\n    value = parser(value);\n  }\n\n  if (value && value !== 'none') {\n    return value;\n  }\n}\n\n/**\n * Gets the value of the selected <option> element within a <select> element.\n *\n * @param  {Element} el\n *         the element to look in\n *\n * @param  {Function} [parser]\n *         Optional function to adjust the value.\n *\n * @return {Mixed}\n *         - Will be `undefined` if no value exists\n *         - Will be `undefined` if the given value is \"none\".\n *         - Will be the actual value otherwise.\n *\n * @private\n */\nfunction getSelectedOptionValue(el, parser) {\n  var value = el.options[el.options.selectedIndex].value;\n\n  return parseOptionValue(value, parser);\n}\n\n/**\n * Sets the selected <option> element within a <select> element based on a\n * given value.\n *\n * @param {Element} el\n *        The element to look in.\n *\n * @param {string} value\n *        the property to look on.\n *\n * @param {Function} [parser]\n *        Optional function to adjust the value before comparing.\n *\n * @private\n */\nfunction setSelectedOption(el, value, parser) {\n  if (!value) {\n    return;\n  }\n\n  for (var i = 0; i < el.options.length; i++) {\n    if (parseOptionValue(el.options[i].value, parser) === value) {\n      el.selectedIndex = i;\n      break;\n    }\n  }\n}\n\n/**\n * Manipulate Text Tracks settings.\n *\n * @extends ModalDialog\n */\n\nvar TextTrackSettings = function (_ModalDialog) {\n  inherits(TextTrackSettings, _ModalDialog);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *         The key/value store of player options.\n   */\n  function TextTrackSettings(player, options) {\n    classCallCheck(this, TextTrackSettings);\n\n    options.temporary = false;\n\n    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));\n\n    _this.updateDisplay = bind(_this, _this.updateDisplay);\n\n    // fill the modal and pretend we have opened it\n    _this.fill();\n    _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;\n\n    _this.endDialog = createEl('p', {\n      className: 'vjs-control-text',\n      textContent: _this.localize('End of dialog window.')\n    });\n    _this.el().appendChild(_this.endDialog);\n\n    _this.setDefaults();\n\n    // Grab `persistTextTrackSettings` from the player options if not passed in child options\n    if (options.persistTextTrackSettings === undefined) {\n      _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;\n    }\n\n    _this.on(_this.$('.vjs-done-button'), 'click', function () {\n      _this.saveSettings();\n      _this.close();\n    });\n\n    _this.on(_this.$('.vjs-default-button'), 'click', function () {\n      _this.setDefaults();\n      _this.updateDisplay();\n    });\n\n    each(selectConfigs, function (config) {\n      _this.on(_this.$(config.selector), 'change', _this.updateDisplay);\n    });\n\n    if (_this.options_.persistTextTrackSettings) {\n      _this.restoreSettings();\n    }\n    return _this;\n  }\n\n  TextTrackSettings.prototype.dispose = function dispose() {\n    this.endDialog = null;\n\n    _ModalDialog.prototype.dispose.call(this);\n  };\n\n  /**\n   * Create a <select> element with configured options.\n   *\n   * @param {string} key\n   *        Configuration key to use during creation.\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElSelect_ = function createElSelect_(key) {\n    var _this2 = this;\n\n    var legendId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'label';\n\n    var config = selectConfigs[key];\n    var id = config.id.replace('%s', this.id_);\n    var selectLabelledbyIds = [legendId, id].join(' ').trim();\n\n    return ['<' + type + ' id=\"' + id + '\" class=\"' + (type === 'label' ? 'vjs-label' : '') + '\">', this.localize(config.label), '</' + type + '>', '<select aria-labelledby=\"' + selectLabelledbyIds + '\">'].concat(config.options.map(function (o) {\n      var optionId = id + '-' + o[1].replace(/\\W+/g, '');\n\n      return ['<option id=\"' + optionId + '\" value=\"' + o[0] + '\" ', 'aria-labelledby=\"' + selectLabelledbyIds + ' ' + optionId + '\">', _this2.localize(o[1]), '</option>'].join('');\n    })).concat('</select>').join('');\n  };\n\n  /**\n   * Create foreground color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElFgColor_ = function createElFgColor_() {\n    var legendId = 'captions-text-legend-' + this.id_;\n\n    return ['<fieldset class=\"vjs-fg-color vjs-track-setting\">', '<legend id=\"' + legendId + '\">', this.localize('Text'), '</legend>', this.createElSelect_('color', legendId), '<span class=\"vjs-text-opacity vjs-opacity\">', this.createElSelect_('textOpacity', legendId), '</span>', '</fieldset>'].join('');\n  };\n\n  /**\n   * Create background color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElBgColor_ = function createElBgColor_() {\n    var legendId = 'captions-background-' + this.id_;\n\n    return ['<fieldset class=\"vjs-bg-color vjs-track-setting\">', '<legend id=\"' + legendId + '\">', this.localize('Background'), '</legend>', this.createElSelect_('backgroundColor', legendId), '<span class=\"vjs-bg-opacity vjs-opacity\">', this.createElSelect_('backgroundOpacity', legendId), '</span>', '</fieldset>'].join('');\n  };\n\n  /**\n   * Create window color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElWinColor_ = function createElWinColor_() {\n    var legendId = 'captions-window-' + this.id_;\n\n    return ['<fieldset class=\"vjs-window-color vjs-track-setting\">', '<legend id=\"' + legendId + '\">', this.localize('Window'), '</legend>', this.createElSelect_('windowColor', legendId), '<span class=\"vjs-window-opacity vjs-opacity\">', this.createElSelect_('windowOpacity', legendId), '</span>', '</fieldset>'].join('');\n  };\n\n  /**\n   * Create color elements for the component\n   *\n   * @return {Element}\n   *         The element that was created\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElColors_ = function createElColors_() {\n    return createEl('div', {\n      className: 'vjs-track-settings-colors',\n      innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join('')\n    });\n  };\n\n  /**\n   * Create font elements for the component\n   *\n   * @return {Element}\n   *         The element that was created.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElFont_ = function createElFont_() {\n    return createEl('div', {\n      className: 'vjs-track-settings-font',\n      innerHTML: ['<fieldset class=\"vjs-font-percent vjs-track-setting\">', this.createElSelect_('fontPercent', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-edge-style vjs-track-setting\">', this.createElSelect_('edgeStyle', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-font-family vjs-track-setting\">', this.createElSelect_('fontFamily', '', 'legend'), '</fieldset>'].join('')\n    });\n  };\n\n  /**\n   * Create controls for the component\n   *\n   * @return {Element}\n   *         The element that was created.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElControls_ = function createElControls_() {\n    var defaultsDescription = this.localize('restore all settings to the default values');\n\n    return createEl('div', {\n      className: 'vjs-track-settings-controls',\n      innerHTML: ['<button class=\"vjs-default-button\" title=\"' + defaultsDescription + '\">', this.localize('Reset'), '<span class=\"vjs-control-text\"> ' + defaultsDescription + '</span>', '</button>', '<button class=\"vjs-done-button\">' + this.localize('Done') + '</button>'].join('')\n    });\n  };\n\n  TextTrackSettings.prototype.content = function content() {\n    return [this.createElColors_(), this.createElFont_(), this.createElControls_()];\n  };\n\n  TextTrackSettings.prototype.label = function label() {\n    return this.localize('Caption Settings Dialog');\n  };\n\n  TextTrackSettings.prototype.description = function description() {\n    return this.localize('Beginning of dialog window. Escape will cancel and close the window.');\n  };\n\n  TextTrackSettings.prototype.buildCSSClass = function buildCSSClass() {\n    return _ModalDialog.prototype.buildCSSClass.call(this) + ' vjs-text-track-settings';\n  };\n\n  /**\n   * Gets an object of text track settings (or null).\n   *\n   * @return {Object}\n   *         An object with config values parsed from the DOM or localStorage.\n   */\n\n\n  TextTrackSettings.prototype.getValues = function getValues() {\n    var _this3 = this;\n\n    return reduce(selectConfigs, function (accum, config, key) {\n      var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);\n\n      if (value !== undefined) {\n        accum[key] = value;\n      }\n\n      return accum;\n    }, {});\n  };\n\n  /**\n   * Sets text track settings from an object of values.\n   *\n   * @param {Object} values\n   *        An object with config values parsed from the DOM or localStorage.\n   */\n\n\n  TextTrackSettings.prototype.setValues = function setValues(values) {\n    var _this4 = this;\n\n    each(selectConfigs, function (config, key) {\n      setSelectedOption(_this4.$(config.selector), values[key], config.parser);\n    });\n  };\n\n  /**\n   * Sets all `<select>` elements to their default values.\n   */\n\n\n  TextTrackSettings.prototype.setDefaults = function setDefaults() {\n    var _this5 = this;\n\n    each(selectConfigs, function (config) {\n      var index = config.hasOwnProperty('default') ? config.default : 0;\n\n      _this5.$(config.selector).selectedIndex = index;\n    });\n  };\n\n  /**\n   * Restore texttrack settings from localStorage\n   */\n\n\n  TextTrackSettings.prototype.restoreSettings = function restoreSettings() {\n    var values = void 0;\n\n    try {\n      values = JSON.parse(global_window__WEBPACK_IMPORTED_MODULE_0___default.a.localStorage.getItem(LOCAL_STORAGE_KEY));\n    } catch (err) {\n      log$1.warn(err);\n    }\n\n    if (values) {\n      this.setValues(values);\n    }\n  };\n\n  /**\n   * Save text track settings to localStorage\n   */\n\n\n  TextTrackSettings.prototype.saveSettings = function saveSettings() {\n    if (!this.options_.persistTextTrackSettings) {\n      return;\n    }\n\n    var values = this.getValues();\n\n    try {\n      if (Object.keys(values).length) {\n        global_window__WEBPACK_IMPORTED_MODULE_0___default.a.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(values));\n      } else {\n        global_window__WEBPACK_IMPORTED_MODULE_0___default.a.localStorage.removeItem(LOCAL_STORAGE_KEY);\n      }\n    } catch (err) {\n      log$1.warn(err);\n    }\n  };\n\n  /**\n   * Update display of text track settings\n   */\n\n\n  TextTrackSettings.prototype.updateDisplay = function updateDisplay() {\n    var ttDisplay = this.player_.getChild('textTrackDisplay');\n\n    if (ttDisplay) {\n      ttDisplay.updateDisplay();\n    }\n  };\n\n  /**\n   * conditionally blur the element and refocus the captions button\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.conditionalBlur_ = function conditionalBlur_() {\n    this.previouslyActiveEl_ = null;\n    this.off(global_document__WEBPACK_IMPORTED_MODULE_1___default.a, 'keydown', this.handleKeyDown);\n\n    var cb = this.player_.controlBar;\n    var subsCapsBtn = cb && cb.subsCapsButton;\n    var ccBtn = cb && cb.captionsButton;\n\n    if (subsCapsBtn) {\n      subsCapsBtn.focus();\n    } else if (ccBtn) {\n      ccBtn.focus();\n    }\n  };\n\n  return TextTrackSettings;\n}(ModalDialog);\n\nComponent.registerComponent('TextTrackSettings', TextTrackSettings);\n\n/**\n * @file resize-manager.js\n */\n\n/**\n * A Resize Manager. It is in charge of triggering `playerresize` on the player in the right conditions.\n *\n * It'll either create an iframe and use a debounced resize handler on it or use the new {@link https://wicg.github.io/ResizeObserver/|ResizeObserver}.\n *\n * If the ResizeObserver is available natively, it will be used. A polyfill can be passed in as an option.\n * If a `playerresize` event is not needed, the ResizeManager component can be removed from the player, see the example below.\n * @example <caption>How to disable the resize manager</caption>\n * const player = videojs('#vid', {\n *   resizeManager: false\n * });\n *\n * @see {@link https://wicg.github.io/ResizeObserver/|ResizeObserver specification}\n *\n * @extends Component\n */\n\nvar ResizeManager = function (_Component) {\n  inherits(ResizeManager, _Component);\n\n  /**\n   * Create the ResizeManager.\n   *\n   * @param {Object} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of ResizeManager options.\n   *\n   * @param {Object} [options.ResizeObserver]\n   *        A polyfill for ResizeObserver can be passed in here.\n   *        If this is set to null it will ignore the native ResizeObserver and fall back to the iframe fallback.\n   */\n  function ResizeManager(player, options) {\n    classCallCheck(this, ResizeManager);\n\n    var RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || global_window__WEBPACK_IMPORTED_MODULE_0___default.a.ResizeObserver;\n\n    // if `null` was passed, we want to disable the ResizeObserver\n    if (options.ResizeObserver === null) {\n      RESIZE_OBSERVER_AVAILABLE = false;\n    }\n\n    // Only create an element when ResizeObserver isn't available\n    var options_ = mergeOptions({ createEl: !RESIZE_OBSERVER_AVAILABLE }, options);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options_));\n\n    _this.ResizeObserver = options.ResizeObserver || global_window__WEBPACK_IMPORTED_MODULE_0___default.a.ResizeObserver;\n    _this.loadListener_ = null;\n    _this.resizeObserver_ = null;\n    _this.debouncedHandler_ = debounce(function () {\n      _this.resizeHandler();\n    }, 100, false, player);\n\n    if (RESIZE_OBSERVER_AVAILABLE) {\n      _this.resizeObserver_ = new _this.ResizeObserver(_this.debouncedHandler_);\n      _this.resizeObserver_.observe(player.el());\n    } else {\n      _this.loadListener_ = function () {\n        if (_this.el_.contentWindow) {\n          on(_this.el_.contentWindow, 'resize', _this.debouncedHandler_);\n        }\n        _this.off('load', _this.loadListener_);\n      };\n\n      _this.on('load', _this.loadListener_);\n    }\n    return _this;\n  }\n\n  ResizeManager.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'iframe', {\n      className: 'vjs-resize-manager'\n    });\n  };\n\n  /**\n   * Called when a resize is triggered on the iframe or a resize is observed via the ResizeObserver\n   *\n   * @fires Player#playerresize\n   */\n\n\n  ResizeManager.prototype.resizeHandler = function resizeHandler() {\n    /**\n     * Called when the player size has changed\n     *\n     * @event Player#playerresize\n     * @type {EventTarget~Event}\n     */\n    this.player_.trigger('playerresize');\n  };\n\n  ResizeManager.prototype.dispose = function dispose() {\n    if (this.resizeObserver_) {\n      if (this.player_.el()) {\n        this.resizeObserver_.unobserve(this.player_.el());\n      }\n      this.resizeObserver_.disconnect();\n    }\n\n    if (this.el_ && this.el_.contentWindow) {\n      off(this.el_.contentWindow, 'resize', this.debouncedHandler_);\n    }\n\n    if (this.loadListener_) {\n      this.off('load', this.loadListener_);\n    }\n\n    this.ResizeObserver = null;\n    this.resizeObserver = null;\n    this.debouncedHandler_ = null;\n    this.loadListener_ = null;\n  };\n\n  return ResizeManager;\n}(Component);\n\nComponent.registerComponent('ResizeManager', ResizeManager);\n\n/**\n * This function is used to fire a sourceset when there is something\n * similar to `mediaEl.load()` being called. It will try to find the source via\n * the `src` attribute and then the `<source>` elements. It will then fire `sourceset`\n * with the source that was found or empty string if we cannot know. If it cannot\n * find a source then `sourceset` will not be fired.\n *\n * @param {Html5} tech\n *        The tech object that sourceset was setup on\n *\n * @return {boolean}\n *         returns false if the sourceset was not fired and true otherwise.\n */\nvar sourcesetLoad = function sourcesetLoad(tech) {\n  var el = tech.el();\n\n  // if `el.src` is set, that source will be loaded.\n  if (el.hasAttribute('src')) {\n    tech.triggerSourceset(el.src);\n    return true;\n  }\n\n  /**\n   * Since there isn't a src property on the media element, source elements will be used for\n   * implementing the source selection algorithm. This happens asynchronously and\n   * for most cases were there is more than one source we cannot tell what source will\n   * be loaded, without re-implementing the source selection algorithm. At this time we are not\n   * going to do that. There are three special cases that we do handle here though:\n   *\n   * 1. If there are no sources, do not fire `sourceset`.\n   * 2. If there is only one `<source>` with a `src` property/attribute that is our `src`\n   * 3. If there is more than one `<source>` but all of them have the same `src` url.\n   *    That will be our src.\n   */\n  var sources = tech.$$('source');\n  var srcUrls = [];\n  var src = '';\n\n  // if there are no sources, do not fire sourceset\n  if (!sources.length) {\n    return false;\n  }\n\n  // only count valid/non-duplicate source elements\n  for (var i = 0; i < sources.length; i++) {\n    var url = sources[i].src;\n\n    if (url && srcUrls.indexOf(url) === -1) {\n      srcUrls.push(url);\n    }\n  }\n\n  // there were no valid sources\n  if (!srcUrls.length) {\n    return false;\n  }\n\n  // there is only one valid source element url\n  // use that\n  if (srcUrls.length === 1) {\n    src = srcUrls[0];\n  }\n\n  tech.triggerSourceset(src);\n  return true;\n};\n\n/**\n * our implementation of an `innerHTML` descriptor for browsers\n * that do not have one.\n */\nvar innerHTMLDescriptorPolyfill = Object.defineProperty({}, 'innerHTML', {\n  get: function get() {\n    return this.cloneNode(true).innerHTML;\n  },\n  set: function set(v) {\n    // make a dummy node to use innerHTML on\n    var dummy = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(this.nodeName.toLowerCase());\n\n    // set innerHTML to the value provided\n    dummy.innerHTML = v;\n\n    // make a document fragment to hold the nodes from dummy\n    var docFrag = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createDocumentFragment();\n\n    // copy all of the nodes created by the innerHTML on dummy\n    // to the document fragment\n    while (dummy.childNodes.length) {\n      docFrag.appendChild(dummy.childNodes[0]);\n    }\n\n    // remove content\n    this.innerText = '';\n\n    // now we add all of that html in one by appending the\n    // document fragment. This is how innerHTML does it.\n    global_window__WEBPACK_IMPORTED_MODULE_0___default.a.Element.prototype.appendChild.call(this, docFrag);\n\n    // then return the result that innerHTML's setter would\n    return this.innerHTML;\n  }\n});\n\n/**\n * Get a property descriptor given a list of priorities and the\n * property to get.\n */\nvar getDescriptor = function getDescriptor(priority, prop) {\n  var descriptor = {};\n\n  for (var i = 0; i < priority.length; i++) {\n    descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);\n\n    if (descriptor && descriptor.set && descriptor.get) {\n      break;\n    }\n  }\n\n  descriptor.enumerable = true;\n  descriptor.configurable = true;\n\n  return descriptor;\n};\n\nvar getInnerHTMLDescriptor = function getInnerHTMLDescriptor(tech) {\n  return getDescriptor([tech.el(), global_window__WEBPACK_IMPORTED_MODULE_0___default.a.HTMLMediaElement.prototype, global_window__WEBPACK_IMPORTED_MODULE_0___default.a.Element.prototype, innerHTMLDescriptorPolyfill], 'innerHTML');\n};\n\n/**\n * Patches browser internal functions so that we can tell synchronously\n * if a `<source>` was appended to the media element. For some reason this\n * causes a `sourceset` if the the media element is ready and has no source.\n * This happens when:\n * - The page has just loaded and the media element does not have a source.\n * - The media element was emptied of all sources, then `load()` was called.\n *\n * It does this by patching the following functions/properties when they are supported:\n *\n * - `append()` - can be used to add a `<source>` element to the media element\n * - `appendChild()` - can be used to add a `<source>` element to the media element\n * - `insertAdjacentHTML()` -  can be used to add a `<source>` element to the media element\n * - `innerHTML` -  can be used to add a `<source>` element to the media element\n *\n * @param {Html5} tech\n *        The tech object that sourceset is being setup on.\n */\nvar firstSourceWatch = function firstSourceWatch(tech) {\n  var el = tech.el();\n\n  // make sure firstSourceWatch isn't setup twice.\n  if (el.resetSourceWatch_) {\n    return;\n  }\n\n  var old = {};\n  var innerDescriptor = getInnerHTMLDescriptor(tech);\n  var appendWrapper = function appendWrapper(appendFn) {\n    return function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var retval = appendFn.apply(el, args);\n\n      sourcesetLoad(tech);\n\n      return retval;\n    };\n  };\n\n  ['append', 'appendChild', 'insertAdjacentHTML'].forEach(function (k) {\n    if (!el[k]) {\n      return;\n    }\n\n    // store the old function\n    old[k] = el[k];\n\n    // call the old function with a sourceset if a source\n    // was loaded\n    el[k] = appendWrapper(old[k]);\n  });\n\n  Object.defineProperty(el, 'innerHTML', mergeOptions(innerDescriptor, {\n    set: appendWrapper(innerDescriptor.set)\n  }));\n\n  el.resetSourceWatch_ = function () {\n    el.resetSourceWatch_ = null;\n    Object.keys(old).forEach(function (k) {\n      el[k] = old[k];\n    });\n\n    Object.defineProperty(el, 'innerHTML', innerDescriptor);\n  };\n\n  // on the first sourceset, we need to revert our changes\n  tech.one('sourceset', el.resetSourceWatch_);\n};\n\n/**\n * our implementation of a `src` descriptor for browsers\n * that do not have one.\n */\nvar srcDescriptorPolyfill = Object.defineProperty({}, 'src', {\n  get: function get() {\n    if (this.hasAttribute('src')) {\n      return getAbsoluteURL(global_window__WEBPACK_IMPORTED_MODULE_0___default.a.Element.prototype.getAttribute.call(this, 'src'));\n    }\n\n    return '';\n  },\n  set: function set(v) {\n    global_window__WEBPACK_IMPORTED_MODULE_0___default.a.Element.prototype.setAttribute.call(this, 'src', v);\n\n    return v;\n  }\n});\n\nvar getSrcDescriptor = function getSrcDescriptor(tech) {\n  return getDescriptor([tech.el(), global_window__WEBPACK_IMPORTED_MODULE_0___default.a.HTMLMediaElement.prototype, srcDescriptorPolyfill], 'src');\n};\n\n/**\n * setup `sourceset` handling on the `Html5` tech. This function\n * patches the following element properties/functions:\n *\n * - `src` - to determine when `src` is set\n * - `setAttribute()` - to determine when `src` is set\n * - `load()` - this re-triggers the source selection algorithm, and can\n *              cause a sourceset.\n *\n * If there is no source when we are adding `sourceset` support or during a `load()`\n * we also patch the functions listed in `firstSourceWatch`.\n *\n * @param {Html5} tech\n *        The tech to patch\n */\nvar setupSourceset = function setupSourceset(tech) {\n  if (!tech.featuresSourceset) {\n    return;\n  }\n\n  var el = tech.el();\n\n  // make sure sourceset isn't setup twice.\n  if (el.resetSourceset_) {\n    return;\n  }\n\n  var srcDescriptor = getSrcDescriptor(tech);\n  var oldSetAttribute = el.setAttribute;\n  var oldLoad = el.load;\n\n  Object.defineProperty(el, 'src', mergeOptions(srcDescriptor, {\n    set: function set(v) {\n      var retval = srcDescriptor.set.call(el, v);\n\n      // we use the getter here to get the actual value set on src\n      tech.triggerSourceset(el.src);\n\n      return retval;\n    }\n  }));\n\n  el.setAttribute = function (n, v) {\n    var retval = oldSetAttribute.call(el, n, v);\n\n    if (/src/i.test(n)) {\n      tech.triggerSourceset(el.src);\n    }\n\n    return retval;\n  };\n\n  el.load = function () {\n    var retval = oldLoad.call(el);\n\n    // if load was called, but there was no source to fire\n    // sourceset on. We have to watch for a source append\n    // as that can trigger a `sourceset` when the media element\n    // has no source\n    if (!sourcesetLoad(tech)) {\n      tech.triggerSourceset('');\n      firstSourceWatch(tech);\n    }\n\n    return retval;\n  };\n\n  if (el.currentSrc) {\n    tech.triggerSourceset(el.currentSrc);\n  } else if (!sourcesetLoad(tech)) {\n    firstSourceWatch(tech);\n  }\n\n  el.resetSourceset_ = function () {\n    el.resetSourceset_ = null;\n    el.load = oldLoad;\n    el.setAttribute = oldSetAttribute;\n    Object.defineProperty(el, 'src', srcDescriptor);\n    if (el.resetSourceWatch_) {\n      el.resetSourceWatch_();\n    }\n  };\n};\n\nvar _templateObject$1 = taggedTemplateLiteralLoose(['Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n            This may prevent text tracks from loading.'], ['Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n            This may prevent text tracks from loading.']);\n\n/**\n * HTML5 Media Controller - Wrapper for HTML5 Media API\n *\n * @mixes Tech~SourceHandlerAdditions\n * @extends Tech\n */\n\nvar Html5 = function (_Tech) {\n  inherits(Html5, _Tech);\n\n  /**\n   * Create an instance of this Tech.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} ready\n   *        Callback function to call when the `HTML5` Tech is ready.\n   */\n  function Html5(options, ready) {\n    classCallCheck(this, Html5);\n\n    var _this = possibleConstructorReturn(this, _Tech.call(this, options, ready));\n\n    var source = options.source;\n    var crossoriginTracks = false;\n\n    // Set the source if one is provided\n    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)\n    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source\n    // anyway so the error gets fired.\n    if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {\n      _this.setSource(source);\n    } else {\n      _this.handleLateInit_(_this.el_);\n    }\n\n    // setup sourceset after late sourceset/init\n    if (options.enableSourceset) {\n      _this.setupSourcesetHandling_();\n    }\n\n    if (_this.el_.hasChildNodes()) {\n\n      var nodes = _this.el_.childNodes;\n      var nodesLength = nodes.length;\n      var removeNodes = [];\n\n      while (nodesLength--) {\n        var node = nodes[nodesLength];\n        var nodeName = node.nodeName.toLowerCase();\n\n        if (nodeName === 'track') {\n          if (!_this.featuresNativeTextTracks) {\n            // Empty video tag tracks so the built-in player doesn't use them also.\n            // This may not be fast enough to stop HTML5 browsers from reading the tags\n            // so we'll need to turn off any default tracks if we're manually doing\n            // captions and subtitles. videoElement.textTracks\n            removeNodes.push(node);\n          } else {\n            // store HTMLTrackElement and TextTrack to remote list\n            _this.remoteTextTrackEls().addTrackElement_(node);\n            _this.remoteTextTracks().addTrack(node.track);\n            _this.textTracks().addTrack(node.track);\n            if (!crossoriginTracks && !_this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {\n              crossoriginTracks = true;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < removeNodes.length; i++) {\n        _this.el_.removeChild(removeNodes[i]);\n      }\n    }\n\n    _this.proxyNativeTracks_();\n    if (_this.featuresNativeTextTracks && crossoriginTracks) {\n      log$1.warn(tsml__WEBPACK_IMPORTED_MODULE_2___default()(_templateObject$1));\n    }\n\n    // prevent iOS Safari from disabling metadata text tracks during native playback\n    _this.restoreMetadataTracksInIOSNativePlayer_();\n\n    // Determine if native controls should be used\n    // Our goal should be to get the custom controls on mobile solid everywhere\n    // so we can remove this all together. Right now this will block custom\n    // controls on touch enabled laptops like the Chrome Pixel\n    if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {\n      _this.setControls(true);\n    }\n\n    // on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`\n    // into a `fullscreenchange` event\n    _this.proxyWebkitFullscreen_();\n\n    _this.triggerReady();\n    return _this;\n  }\n\n  /**\n   * Dispose of `HTML5` media element and remove all tracks.\n   */\n\n\n  Html5.prototype.dispose = function dispose() {\n    if (this.el_ && this.el_.resetSourceset_) {\n      this.el_.resetSourceset_();\n    }\n    Html5.disposeMediaElement(this.el_);\n    this.options_ = null;\n\n    // tech will handle clearing of the emulated track list\n    _Tech.prototype.dispose.call(this);\n  };\n\n  /**\n   * Modify the media element so that we can detect when\n   * the source is changed. Fires `sourceset` just after the source has changed\n   */\n\n\n  Html5.prototype.setupSourcesetHandling_ = function setupSourcesetHandling_() {\n    setupSourceset(this);\n  };\n\n  /**\n   * When a captions track is enabled in the iOS Safari native player, all other\n   * tracks are disabled (including metadata tracks), which nulls all of their\n   * associated cue points. This will restore metadata tracks to their pre-fullscreen\n   * state in those cases so that cue points are not needlessly lost.\n   *\n   * @private\n   */\n\n\n  Html5.prototype.restoreMetadataTracksInIOSNativePlayer_ = function restoreMetadataTracksInIOSNativePlayer_() {\n    var textTracks = this.textTracks();\n    var metadataTracksPreFullscreenState = void 0;\n\n    // captures a snapshot of every metadata track's current state\n    var takeMetadataTrackSnapshot = function takeMetadataTrackSnapshot() {\n      metadataTracksPreFullscreenState = [];\n\n      for (var i = 0; i < textTracks.length; i++) {\n        var track = textTracks[i];\n\n        if (track.kind === 'metadata') {\n          metadataTracksPreFullscreenState.push({\n            track: track,\n            storedMode: track.mode\n          });\n        }\n      }\n    };\n\n    // snapshot each metadata track's initial state, and update the snapshot\n    // each time there is a track 'change' event\n    takeMetadataTrackSnapshot();\n    textTracks.addEventListener('change', takeMetadataTrackSnapshot);\n\n    this.on('dispose', function () {\n      return textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n    });\n\n    var restoreTrackMode = function restoreTrackMode() {\n      for (var i = 0; i < metadataTracksPreFullscreenState.length; i++) {\n        var storedTrack = metadataTracksPreFullscreenState[i];\n\n        if (storedTrack.track.mode === 'disabled' && storedTrack.track.mode !== storedTrack.storedMode) {\n          storedTrack.track.mode = storedTrack.storedMode;\n        }\n      }\n      // we only want this handler to be executed on the first 'change' event\n      textTracks.removeEventListener('change', restoreTrackMode);\n    };\n\n    // when we enter fullscreen playback, stop updating the snapshot and\n    // restore all track modes to their pre-fullscreen state\n    this.on('webkitbeginfullscreen', function () {\n      textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n\n      // remove the listener before adding it just in case it wasn't previously removed\n      textTracks.removeEventListener('change', restoreTrackMode);\n      textTracks.addEventListener('change', restoreTrackMode);\n    });\n\n    // start updating the snapshot again after leaving fullscreen\n    this.on('webkitendfullscreen', function () {\n      // remove the listener before adding it just in case it wasn't previously removed\n      textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n      textTracks.addEventListener('change', takeMetadataTrackSnapshot);\n\n      // remove the restoreTrackMode handler in case it wasn't triggered during fullscreen playback\n      textTracks.removeEventListener('change', restoreTrackMode);\n    });\n  };\n\n  /**\n   * Attempt to force override of tracks for the given type\n   *\n   * @param {String} type - Track type to override, possible values include 'Audio',\n   * 'Video', and 'Text'.\n   * @param {Boolean} override - If set to true native audio/video will be overridden,\n   * otherwise native audio/video will potentially be used.\n   * @private\n   */\n\n\n  Html5.prototype.overrideNative_ = function overrideNative_(type, override) {\n    var _this2 = this;\n\n    // If there is no behavioral change don't add/remove listeners\n    if (override !== this['featuresNative' + type + 'Tracks']) {\n      return;\n    }\n\n    var lowerCaseType = type.toLowerCase();\n\n    if (this[lowerCaseType + 'TracksListeners_']) {\n      Object.keys(this[lowerCaseType + 'TracksListeners_']).forEach(function (eventName) {\n        var elTracks = _this2.el()[lowerCaseType + 'Tracks'];\n\n        elTracks.removeEventListener(eventName, _this2[lowerCaseType + 'TracksListeners_'][eventName]);\n      });\n    }\n\n    this['featuresNative' + type + 'Tracks'] = !override;\n    this[lowerCaseType + 'TracksListeners_'] = null;\n\n    this.proxyNativeTracksForType_(lowerCaseType);\n  };\n\n  /**\n   * Attempt to force override of native audio tracks.\n   *\n   * @param {Boolean} override - If set to true native audio will be overridden,\n   * otherwise native audio will potentially be used.\n   */\n\n\n  Html5.prototype.overrideNativeAudioTracks = function overrideNativeAudioTracks(override) {\n    this.overrideNative_('Audio', override);\n  };\n\n  /**\n   * Attempt to force override of native video tracks.\n   *\n   * @param {Boolean} override - If set to true native video will be overridden,\n   * otherwise native video will potentially be used.\n   */\n\n\n  Html5.prototype.overrideNativeVideoTracks = function overrideNativeVideoTracks(override) {\n    this.overrideNative_('Video', override);\n  };\n\n  /**\n    * Proxy native track list events for the given type to our track\n    * lists if the browser we are playing in supports that type of track list.\n    *\n    * @param {string} name - Track type; values include 'audio', 'video', and 'text'\n    * @private\n    */\n\n\n  Html5.prototype.proxyNativeTracksForType_ = function proxyNativeTracksForType_(name) {\n    var _this3 = this;\n\n    var props = NORMAL[name];\n    var elTracks = this.el()[props.getterName];\n    var techTracks = this[props.getterName]();\n\n    if (!this['featuresNative' + props.capitalName + 'Tracks'] || !elTracks || !elTracks.addEventListener) {\n      return;\n    }\n    var listeners = {\n      change: function change(e) {\n        techTracks.trigger({\n          type: 'change',\n          target: techTracks,\n          currentTarget: techTracks,\n          srcElement: techTracks\n        });\n      },\n      addtrack: function addtrack(e) {\n        techTracks.addTrack(e.track);\n      },\n      removetrack: function removetrack(e) {\n        techTracks.removeTrack(e.track);\n      }\n    };\n    var removeOldTracks = function removeOldTracks() {\n      var removeTracks = [];\n\n      for (var i = 0; i < techTracks.length; i++) {\n        var found = false;\n\n        for (var j = 0; j < elTracks.length; j++) {\n          if (elTracks[j] === techTracks[i]) {\n            found = true;\n            break;\n          }\n        }\n\n        if (!found) {\n          removeTracks.push(techTracks[i]);\n        }\n      }\n\n      while (removeTracks.length) {\n        techTracks.removeTrack(removeTracks.shift());\n      }\n    };\n\n    this[props.getterName + 'Listeners_'] = listeners;\n\n    Object.keys(listeners).forEach(function (eventName) {\n      var listener = listeners[eventName];\n\n      elTracks.addEventListener(eventName, listener);\n      _this3.on('dispose', function (e) {\n        return elTracks.removeEventListener(eventName, listener);\n      });\n    });\n\n    // Remove (native) tracks that are not used anymore\n    this.on('loadstart', removeOldTracks);\n    this.on('dispose', function (e) {\n      return _this3.off('loadstart', removeOldTracks);\n    });\n  };\n\n  /**\n   * Proxy all native track list events to our track lists if the browser we are playing\n   * in supports that type of track list.\n   *\n   * @private\n   */\n\n\n  Html5.prototype.proxyNativeTracks_ = function proxyNativeTracks_() {\n    var _this4 = this;\n\n    NORMAL.names.forEach(function (name) {\n      _this4.proxyNativeTracksForType_(name);\n    });\n  };\n\n  /**\n   * Create the `Html5` Tech's DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  Html5.prototype.createEl = function createEl$$1() {\n    var el = this.options_.tag;\n\n    // Check if this browser supports moving the element into the box.\n    // On the iPhone video will break if you move the element,\n    // So we have to create a brand new element.\n    // If we ingested the player div, we do not need to move the media element.\n    if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {\n\n      // If the original tag is still there, clone and remove it.\n      if (el) {\n        var clone = el.cloneNode(true);\n\n        if (el.parentNode) {\n          el.parentNode.insertBefore(clone, el);\n        }\n        Html5.disposeMediaElement(el);\n        el = clone;\n      } else {\n        el = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('video');\n\n        // determine if native controls should be used\n        var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);\n        var attributes = mergeOptions({}, tagAttributes);\n\n        if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {\n          delete attributes.controls;\n        }\n\n        setAttributes(el, assign(attributes, {\n          id: this.options_.techId,\n          class: 'vjs-tech'\n        }));\n      }\n\n      el.playerId = this.options_.playerId;\n    }\n\n    if (typeof this.options_.preload !== 'undefined') {\n      setAttribute(el, 'preload', this.options_.preload);\n    }\n\n    // Update specific tag settings, in case they were overridden\n    // `autoplay` has to be *last* so that `muted` and `playsinline` are present\n    // when iOS/Safari or other browsers attempt to autoplay.\n    var settingsAttrs = ['loop', 'muted', 'playsinline', 'autoplay'];\n\n    for (var i = 0; i < settingsAttrs.length; i++) {\n      var attr = settingsAttrs[i];\n      var value = this.options_[attr];\n\n      if (typeof value !== 'undefined') {\n        if (value) {\n          setAttribute(el, attr, attr);\n        } else {\n          removeAttribute(el, attr);\n        }\n        el[attr] = value;\n      }\n    }\n\n    return el;\n  };\n\n  /**\n   * This will be triggered if the loadstart event has already fired, before videojs was\n   * ready. Two known examples of when this can happen are:\n   * 1. If we're loading the playback object after it has started loading\n   * 2. The media is already playing the (often with autoplay on) then\n   *\n   * This function will fire another loadstart so that videojs can catchup.\n   *\n   * @fires Tech#loadstart\n   *\n   * @return {undefined}\n   *         returns nothing.\n   */\n\n\n  Html5.prototype.handleLateInit_ = function handleLateInit_(el) {\n    if (el.networkState === 0 || el.networkState === 3) {\n      // The video element hasn't started loading the source yet\n      // or didn't find a source\n      return;\n    }\n\n    if (el.readyState === 0) {\n      // NetworkState is set synchronously BUT loadstart is fired at the\n      // end of the current stack, usually before setInterval(fn, 0).\n      // So at this point we know loadstart may have already fired or is\n      // about to fire, and either way the player hasn't seen it yet.\n      // We don't want to fire loadstart prematurely here and cause a\n      // double loadstart so we'll wait and see if it happens between now\n      // and the next loop, and fire it if not.\n      // HOWEVER, we also want to make sure it fires before loadedmetadata\n      // which could also happen between now and the next loop, so we'll\n      // watch for that also.\n      var loadstartFired = false;\n      var setLoadstartFired = function setLoadstartFired() {\n        loadstartFired = true;\n      };\n\n      this.on('loadstart', setLoadstartFired);\n\n      var triggerLoadstart = function triggerLoadstart() {\n        // We did miss the original loadstart. Make sure the player\n        // sees loadstart before loadedmetadata\n        if (!loadstartFired) {\n          this.trigger('loadstart');\n        }\n      };\n\n      this.on('loadedmetadata', triggerLoadstart);\n\n      this.ready(function () {\n        this.off('loadstart', setLoadstartFired);\n        this.off('loadedmetadata', triggerLoadstart);\n\n        if (!loadstartFired) {\n          // We did miss the original native loadstart. Fire it now.\n          this.trigger('loadstart');\n        }\n      });\n\n      return;\n    }\n\n    // From here on we know that loadstart already fired and we missed it.\n    // The other readyState events aren't as much of a problem if we double\n    // them, so not going to go to as much trouble as loadstart to prevent\n    // that unless we find reason to.\n    var eventsToTrigger = ['loadstart'];\n\n    // loadedmetadata: newly equal to HAVE_METADATA (1) or greater\n    eventsToTrigger.push('loadedmetadata');\n\n    // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater\n    if (el.readyState >= 2) {\n      eventsToTrigger.push('loadeddata');\n    }\n\n    // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater\n    if (el.readyState >= 3) {\n      eventsToTrigger.push('canplay');\n    }\n\n    // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)\n    if (el.readyState >= 4) {\n      eventsToTrigger.push('canplaythrough');\n    }\n\n    // We still need to give the player time to add event listeners\n    this.ready(function () {\n      eventsToTrigger.forEach(function (type) {\n        this.trigger(type);\n      }, this);\n    });\n  };\n\n  /**\n   * Set current time for the `HTML5` tech.\n   *\n   * @param {number} seconds\n   *        Set the current time of the media to this.\n   */\n\n\n  Html5.prototype.setCurrentTime = function setCurrentTime(seconds) {\n    try {\n      this.el_.currentTime = seconds;\n    } catch (e) {\n      log$1(e, 'Video is not ready. (Video.js)');\n      // this.warning(VideoJS.warnings.videoNotReady);\n    }\n  };\n\n  /**\n   * Get the current duration of the HTML5 media element.\n   *\n   * @return {number}\n   *         The duration of the media or 0 if there is no duration.\n   */\n\n\n  Html5.prototype.duration = function duration() {\n    var _this5 = this;\n\n    // Android Chrome will report duration as Infinity for VOD HLS until after\n    // playback has started, which triggers the live display erroneously.\n    // Return NaN if playback has not started and trigger a durationupdate once\n    // the duration can be reliably known.\n    if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {\n      // Wait for the first `timeupdate` with currentTime > 0 - there may be\n      // several with 0\n      var checkProgress = function checkProgress() {\n        if (_this5.el_.currentTime > 0) {\n          // Trigger durationchange for genuinely live video\n          if (_this5.el_.duration === Infinity) {\n            _this5.trigger('durationchange');\n          }\n          _this5.off('timeupdate', checkProgress);\n        }\n      };\n\n      this.on('timeupdate', checkProgress);\n      return NaN;\n    }\n    return this.el_.duration || NaN;\n  };\n\n  /**\n   * Get the current width of the HTML5 media element.\n   *\n   * @return {number}\n   *         The width of the HTML5 media element.\n   */\n\n\n  Html5.prototype.width = function width() {\n    return this.el_.offsetWidth;\n  };\n\n  /**\n   * Get the current height of the HTML5 media element.\n   *\n   * @return {number}\n   *         The height of the HTML5 media element.\n   */\n\n\n  Html5.prototype.height = function height() {\n    return this.el_.offsetHeight;\n  };\n\n  /**\n   * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into\n   * `fullscreenchange` event.\n   *\n   * @private\n   * @fires fullscreenchange\n   * @listens webkitendfullscreen\n   * @listens webkitbeginfullscreen\n   * @listens webkitbeginfullscreen\n   */\n\n\n  Html5.prototype.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {\n    var _this6 = this;\n\n    if (!('webkitDisplayingFullscreen' in this.el_)) {\n      return;\n    }\n\n    var endFn = function endFn() {\n      this.trigger('fullscreenchange', { isFullscreen: false });\n    };\n\n    var beginFn = function beginFn() {\n      if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {\n        this.one('webkitendfullscreen', endFn);\n\n        this.trigger('fullscreenchange', { isFullscreen: true });\n      }\n    };\n\n    this.on('webkitbeginfullscreen', beginFn);\n    this.on('dispose', function () {\n      _this6.off('webkitbeginfullscreen', beginFn);\n      _this6.off('webkitendfullscreen', endFn);\n    });\n  };\n\n  /**\n   * Check if fullscreen is supported on the current playback device.\n   *\n   * @return {boolean}\n   *         - True if fullscreen is supported.\n   *         - False if fullscreen is not supported.\n   */\n\n\n  Html5.prototype.supportsFullScreen = function supportsFullScreen() {\n    if (typeof this.el_.webkitEnterFullScreen === 'function') {\n      var userAgent = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.navigator && global_window__WEBPACK_IMPORTED_MODULE_0___default.a.navigator.userAgent || '';\n\n      // Seems to be broken in Chromium/Chrome && Safari in Leopard\n      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Request that the `HTML5` Tech enter fullscreen.\n   */\n\n\n  Html5.prototype.enterFullScreen = function enterFullScreen() {\n    var video = this.el_;\n\n    if (video.paused && video.networkState <= video.HAVE_METADATA) {\n      // attempt to prime the video element for programmatic access\n      // this isn't necessary on the desktop but shouldn't hurt\n      this.el_.play();\n\n      // playing and pausing synchronously during the transition to fullscreen\n      // can get iOS ~6.1 devices into a play/pause loop\n      this.setTimeout(function () {\n        video.pause();\n        video.webkitEnterFullScreen();\n      }, 0);\n    } else {\n      video.webkitEnterFullScreen();\n    }\n  };\n\n  /**\n   * Request that the `HTML5` Tech exit fullscreen.\n   */\n\n\n  Html5.prototype.exitFullScreen = function exitFullScreen() {\n    this.el_.webkitExitFullScreen();\n  };\n\n  /**\n   * A getter/setter for the `Html5` Tech's source object.\n   * > Note: Please use {@link Html5#setSource}\n   *\n   * @param {Tech~SourceObject} [src]\n   *        The source object you want to set on the `HTML5` techs element.\n   *\n   * @return {Tech~SourceObject|undefined}\n   *         - The current source object when a source is not passed in.\n   *         - undefined when setting\n   *\n   * @deprecated Since version 5.\n   */\n\n\n  Html5.prototype.src = function src(_src) {\n    if (_src === undefined) {\n      return this.el_.src;\n    }\n\n    // Setting src through `src` instead of `setSrc` will be deprecated\n    this.setSrc(_src);\n  };\n\n  /**\n   * Reset the tech by removing all sources and then calling\n   * {@link Html5.resetMediaElement}.\n   */\n\n\n  Html5.prototype.reset = function reset() {\n    Html5.resetMediaElement(this.el_);\n  };\n\n  /**\n   * Get the current source on the `HTML5` Tech. Falls back to returning the source from\n   * the HTML5 media element.\n   *\n   * @return {Tech~SourceObject}\n   *         The current source object from the HTML5 tech. With a fallback to the\n   *         elements source.\n   */\n\n\n  Html5.prototype.currentSrc = function currentSrc() {\n    if (this.currentSource_) {\n      return this.currentSource_.src;\n    }\n    return this.el_.currentSrc;\n  };\n\n  /**\n   * Set controls attribute for the HTML5 media Element.\n   *\n   * @param {string} val\n   *        Value to set the controls attribute to\n   */\n\n\n  Html5.prototype.setControls = function setControls(val) {\n    this.el_.controls = !!val;\n  };\n\n  /**\n   * Create and returns a remote {@link TextTrack} object.\n   *\n   * @param {string} kind\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n   *\n   * @param {string} [label]\n   *        Label to identify the text track\n   *\n   * @param {string} [language]\n   *        Two letter language abbreviation\n   *\n   * @return {TextTrack}\n   *         The TextTrack that gets created.\n   */\n\n\n  Html5.prototype.addTextTrack = function addTextTrack(kind, label, language) {\n    if (!this.featuresNativeTextTracks) {\n      return _Tech.prototype.addTextTrack.call(this, kind, label, language);\n    }\n\n    return this.el_.addTextTrack(kind, label, language);\n  };\n\n  /**\n   * Creates either native TextTrack or an emulated TextTrack depending\n   * on the value of `featuresNativeTextTracks`\n   *\n   * @param {Object} options\n   *        The object should contain the options to initialize the TextTrack with.\n   *\n   * @param {string} [options.kind]\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n   *\n   * @param {string} [options.label]\n   *        Label to identify the text track\n   *\n   * @param {string} [options.language]\n   *        Two letter language abbreviation.\n   *\n   * @param {boolean} [options.default]\n   *        Default this track to on.\n   *\n   * @param {string} [options.id]\n   *        The internal id to assign this track.\n   *\n   * @param {string} [options.src]\n   *        A source url for the track.\n   *\n   * @return {HTMLTrackElement}\n   *         The track element that gets created.\n   */\n\n\n  Html5.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {\n    if (!this.featuresNativeTextTracks) {\n      return _Tech.prototype.createRemoteTextTrack.call(this, options);\n    }\n    var htmlTrackElement = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('track');\n\n    if (options.kind) {\n      htmlTrackElement.kind = options.kind;\n    }\n    if (options.label) {\n      htmlTrackElement.label = options.label;\n    }\n    if (options.language || options.srclang) {\n      htmlTrackElement.srclang = options.language || options.srclang;\n    }\n    if (options.default) {\n      htmlTrackElement.default = options.default;\n    }\n    if (options.id) {\n      htmlTrackElement.id = options.id;\n    }\n    if (options.src) {\n      htmlTrackElement.src = options.src;\n    }\n\n    return htmlTrackElement;\n  };\n\n  /**\n   * Creates a remote text track object and returns an html track element.\n   *\n   * @param {Object} options The object should contain values for\n   * kind, language, label, and src (location of the WebVTT file)\n   * @param {Boolean} [manualCleanup=true] if set to false, the TextTrack will be\n   * automatically removed from the video element whenever the source changes\n   * @return {HTMLTrackElement} An Html Track Element.\n   * This can be an emulated {@link HTMLTrackElement} or a native one.\n   * @deprecated The default value of the \"manualCleanup\" parameter will default\n   * to \"false\" in upcoming versions of Video.js\n   */\n\n\n  Html5.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {\n    var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);\n\n    if (this.featuresNativeTextTracks) {\n      this.el().appendChild(htmlTrackElement);\n    }\n\n    return htmlTrackElement;\n  };\n\n  /**\n   * Remove remote `TextTrack` from `TextTrackList` object\n   *\n   * @param {TextTrack} track\n   *        `TextTrack` object to remove\n   */\n\n\n  Html5.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {\n    _Tech.prototype.removeRemoteTextTrack.call(this, track);\n\n    if (this.featuresNativeTextTracks) {\n      var tracks = this.$$('track');\n\n      var i = tracks.length;\n\n      while (i--) {\n        if (track === tracks[i] || track === tracks[i].track) {\n          this.el().removeChild(tracks[i]);\n        }\n      }\n    }\n  };\n\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   */\n\n\n  Html5.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    if (typeof this.el().getVideoPlaybackQuality === 'function') {\n      return this.el().getVideoPlaybackQuality();\n    }\n\n    var videoPlaybackQuality = {};\n\n    if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {\n      videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;\n      videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;\n    }\n\n    if (global_window__WEBPACK_IMPORTED_MODULE_0___default.a.performance && typeof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.performance.now === 'function') {\n      videoPlaybackQuality.creationTime = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.performance.now();\n    } else if (global_window__WEBPACK_IMPORTED_MODULE_0___default.a.performance && global_window__WEBPACK_IMPORTED_MODULE_0___default.a.performance.timing && typeof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.performance.timing.navigationStart === 'number') {\n      videoPlaybackQuality.creationTime = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.Date.now() - global_window__WEBPACK_IMPORTED_MODULE_0___default.a.performance.timing.navigationStart;\n    }\n\n    return videoPlaybackQuality;\n  };\n\n  return Html5;\n}(Tech);\n\n/* HTML5 Support Testing ---------------------------------------------------- */\n\nif (isReal()) {\n\n  /**\n   * Element for testing browser HTML5 media capabilities\n   *\n   * @type {Element}\n   * @constant\n   * @private\n   */\n  Html5.TEST_VID = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('video');\n  var track = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('track');\n\n  track.kind = 'captions';\n  track.srclang = 'en';\n  track.label = 'English';\n  Html5.TEST_VID.appendChild(track);\n}\n\n/**\n * Check if HTML5 media is supported by this browser/device.\n *\n * @return {boolean}\n *         - True if HTML5 media is supported.\n *         - False if HTML5 media is not supported.\n */\nHtml5.isSupported = function () {\n  // IE with no Media Player is a LIAR! (#984)\n  try {\n    Html5.TEST_VID.volume = 0.5;\n  } catch (e) {\n    return false;\n  }\n\n  return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);\n};\n\n/**\n * Check if the tech can support the given type\n *\n * @param {string} type\n *        The mimetype to check\n * @return {string} 'probably', 'maybe', or '' (empty string)\n */\nHtml5.canPlayType = function (type) {\n  return Html5.TEST_VID.canPlayType(type);\n};\n\n/**\n * Check if the tech can support the given source\n * @param {Object} srcObj\n *        The source object\n * @param {Object} options\n *        The options passed to the tech\n * @return {string} 'probably', 'maybe', or '' (empty string)\n */\nHtml5.canPlaySource = function (srcObj, options) {\n  return Html5.canPlayType(srcObj.type);\n};\n\n/**\n * Check if the volume can be changed in this browser/device.\n * Volume cannot be changed in a lot of mobile devices.\n * Specifically, it can't be changed from 1 on iOS.\n *\n * @return {boolean}\n *         - True if volume can be controlled\n *         - False otherwise\n */\nHtml5.canControlVolume = function () {\n  // IE will error if Windows Media Player not installed #3315\n  try {\n    var volume = Html5.TEST_VID.volume;\n\n    Html5.TEST_VID.volume = volume / 2 + 0.1;\n    return volume !== Html5.TEST_VID.volume;\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Check if the volume can be muted in this browser/device.\n * Some devices, e.g. iOS, don't allow changing volume\n * but permits muting/unmuting.\n *\n * @return {bolean}\n *      - True if volume can be muted\n *      - False otherwise\n */\nHtml5.canMuteVolume = function () {\n  try {\n    var muted = Html5.TEST_VID.muted;\n\n    // in some versions of iOS muted property doesn't always\n    // work, so we want to set both property and attribute\n    Html5.TEST_VID.muted = !muted;\n    if (Html5.TEST_VID.muted) {\n      setAttribute(Html5.TEST_VID, 'muted', 'muted');\n    } else {\n      removeAttribute(Html5.TEST_VID, 'muted', 'muted');\n    }\n    return muted !== Html5.TEST_VID.muted;\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Check if the playback rate can be changed in this browser/device.\n *\n * @return {boolean}\n *         - True if playback rate can be controlled\n *         - False otherwise\n */\nHtml5.canControlPlaybackRate = function () {\n  // Playback rate API is implemented in Android Chrome, but doesn't do anything\n  // https://github.com/videojs/video.js/issues/3180\n  if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {\n    return false;\n  }\n  // IE will error if Windows Media Player not installed #3315\n  try {\n    var playbackRate = Html5.TEST_VID.playbackRate;\n\n    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;\n    return playbackRate !== Html5.TEST_VID.playbackRate;\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Check if we can override a video/audio elements attributes, with\n * Object.defineProperty.\n *\n * @return {boolean}\n *         - True if builtin attributes can be overridden\n *         - False otherwise\n */\nHtml5.canOverrideAttributes = function () {\n  // if we cannot overwrite the src/innerHTML property, there is no support\n  // iOS 7 safari for instance cannot do this.\n  try {\n    var noop = function noop() {};\n\n    Object.defineProperty(global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('video'), 'src', { get: noop, set: noop });\n    Object.defineProperty(global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('audio'), 'src', { get: noop, set: noop });\n    Object.defineProperty(global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('video'), 'innerHTML', { get: noop, set: noop });\n    Object.defineProperty(global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('audio'), 'innerHTML', { get: noop, set: noop });\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Check to see if native `TextTrack`s are supported by this browser/device.\n *\n * @return {boolean}\n *         - True if native `TextTrack`s are supported.\n *         - False otherwise\n */\nHtml5.supportsNativeTextTracks = function () {\n  return IS_ANY_SAFARI || IS_IOS && IS_CHROME;\n};\n\n/**\n * Check to see if native `VideoTrack`s are supported by this browser/device\n *\n * @return {boolean}\n *        - True if native `VideoTrack`s are supported.\n *        - False otherwise\n */\nHtml5.supportsNativeVideoTracks = function () {\n  return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);\n};\n\n/**\n * Check to see if native `AudioTrack`s are supported by this browser/device\n *\n * @return {boolean}\n *        - True if native `AudioTrack`s are supported.\n *        - False otherwise\n */\nHtml5.supportsNativeAudioTracks = function () {\n  return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);\n};\n\n/**\n * An array of events available on the Html5 tech.\n *\n * @private\n * @type {Array}\n */\nHtml5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];\n\n/**\n * Boolean indicating whether the `Tech` supports volume control.\n *\n * @type {boolean}\n * @default {@link Html5.canControlVolume}\n */\nHtml5.prototype.featuresVolumeControl = Html5.canControlVolume();\n\n/**\n * Boolean indicating whether the `Tech` supports muting volume.\n *\n * @type {bolean}\n * @default {@link Html5.canMuteVolume}\n */\nHtml5.prototype.featuresMuteControl = Html5.canMuteVolume();\n\n/**\n * Boolean indicating whether the `Tech` supports changing the speed at which the media\n * plays. Examples:\n *   - Set player to play 2x (twice) as fast\n *   - Set player to play 0.5x (half) as fast\n *\n * @type {boolean}\n * @default {@link Html5.canControlPlaybackRate}\n */\nHtml5.prototype.featuresPlaybackRate = Html5.canControlPlaybackRate();\n\n/**\n * Boolean indicating whether the `Tech` supports the `sourceset` event.\n *\n * @type {boolean}\n * @default\n */\nHtml5.prototype.featuresSourceset = Html5.canOverrideAttributes();\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports the media element\n * moving in the DOM. iOS breaks if you move the media element, so this is set this to\n * false there. Everywhere else this should be true.\n *\n * @type {boolean}\n * @default\n */\nHtml5.prototype.movingMediaElementInDOM = !IS_IOS;\n\n// TODO: Previous comment: No longer appears to be used. Can probably be removed.\n//       Is this true?\n/**\n * Boolean indicating whether the `HTML5` tech currently supports automatic media resize\n * when going into fullscreen.\n *\n * @type {boolean}\n * @default\n */\nHtml5.prototype.featuresFullscreenResize = true;\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports the progress event.\n * If this is false, manual `progress` events will be triggered instead.\n *\n * @type {boolean}\n * @default\n */\nHtml5.prototype.featuresProgressEvents = true;\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.\n * If this is false, manual `timeupdate` events will be triggered instead.\n *\n * @default\n */\nHtml5.prototype.featuresTimeupdateEvents = true;\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeTextTracks}\n */\nHtml5.prototype.featuresNativeTextTracks = Html5.supportsNativeTextTracks();\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeVideoTracks}\n */\nHtml5.prototype.featuresNativeVideoTracks = Html5.supportsNativeVideoTracks();\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeAudioTracks}\n */\nHtml5.prototype.featuresNativeAudioTracks = Html5.supportsNativeAudioTracks();\n\n// HTML5 Feature detection and Device Fixes --------------------------------- //\nvar canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;\nvar mpegurlRE = /^application\\/(?:x-|vnd\\.apple\\.)mpegurl/i;\n\nHtml5.patchCanPlayType = function () {\n\n  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so\n  // Firefox and Chrome report correctly\n  if (ANDROID_VERSION >= 4.0 && !IS_FIREFOX && !IS_CHROME) {\n    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {\n      if (type && mpegurlRE.test(type)) {\n        return 'maybe';\n      }\n      return canPlayType.call(this, type);\n    };\n  }\n};\n\nHtml5.unpatchCanPlayType = function () {\n  var r = Html5.TEST_VID.constructor.prototype.canPlayType;\n\n  Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;\n  return r;\n};\n\n// by default, patch the media element\nHtml5.patchCanPlayType();\n\nHtml5.disposeMediaElement = function (el) {\n  if (!el) {\n    return;\n  }\n\n  if (el.parentNode) {\n    el.parentNode.removeChild(el);\n  }\n\n  // remove any child track or source nodes to prevent their loading\n  while (el.hasChildNodes()) {\n    el.removeChild(el.firstChild);\n  }\n\n  // remove any src reference. not setting `src=''` because that causes a warning\n  // in firefox\n  el.removeAttribute('src');\n\n  // force the media element to update its loading state by calling load()\n  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)\n  if (typeof el.load === 'function') {\n    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n    (function () {\n      try {\n        el.load();\n      } catch (e) {\n        // not supported\n      }\n    })();\n  }\n};\n\nHtml5.resetMediaElement = function (el) {\n  if (!el) {\n    return;\n  }\n\n  var sources = el.querySelectorAll('source');\n  var i = sources.length;\n\n  while (i--) {\n    el.removeChild(sources[i]);\n  }\n\n  // remove any src reference.\n  // not setting `src=''` because that throws an error\n  el.removeAttribute('src');\n\n  if (typeof el.load === 'function') {\n    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n    (function () {\n      try {\n        el.load();\n      } catch (e) {\n        // satisfy linter\n      }\n    })();\n  }\n};\n\n/* Native HTML5 element property wrapping ----------------------------------- */\n// Wrap native boolean attributes with getters that check both property and attribute\n// The list is as followed:\n// muted, defaultMuted, autoplay, controls, loop, playsinline\n[\n/**\n * Get the value of `muted` from the media element. `muted` indicates\n * that the volume for the media should be set to silent. This does not actually change\n * the `volume` attribute.\n *\n * @method Html5#muted\n * @return {boolean}\n *         - True if the value of `volume` should be ignored and the audio set to silent.\n *         - False if the value of `volume` should be used.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n */\n'muted',\n\n/**\n * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates\n * whether the media should start muted or not. Only changes the default state of the\n * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the\n * current state.\n *\n * @method Html5#defaultMuted\n * @return {boolean}\n *         - The value of `defaultMuted` from the media element.\n *         - True indicates that the media should start muted.\n *         - False indicates that the media should not start muted\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n */\n'defaultMuted',\n\n/**\n * Get the value of `autoplay` from the media element. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Html5#autoplay\n * @return {boolean}\n *         - The value of `autoplay` from the media element.\n *         - True indicates that the media should start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n */\n'autoplay',\n\n/**\n * Get the value of `controls` from the media element. `controls` indicates\n * whether the native media controls should be shown or hidden.\n *\n * @method Html5#controls\n * @return {boolean}\n *         - The value of `controls` from the media element.\n *         - True indicates that native controls should be showing.\n *         - False indicates that native controls should be hidden.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}\n */\n'controls',\n\n/**\n * Get the value of `loop` from the media element. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Html5#loop\n * @return {boolean}\n *         - The value of `loop` from the media element.\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n */\n'loop',\n\n/**\n * Get the value of `playsinline` from the media element. `playsinline` indicates\n * to the browser that non-fullscreen playback is preferred when fullscreen\n * playback is the native default, such as in iOS Safari.\n *\n * @method Html5#playsinline\n * @return {boolean}\n *         - The value of `playsinline` from the media element.\n *         - True indicates that the media should play inline.\n *         - False indicates that the media should not play inline.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n */\n'playsinline'].forEach(function (prop) {\n  Html5.prototype[prop] = function () {\n    return this.el_[prop] || this.el_.hasAttribute(prop);\n  };\n});\n\n// Wrap native boolean attributes with setters that set both property and attribute\n// The list is as followed:\n// setMuted, setDefaultMuted, setAutoplay, setLoop, setPlaysinline\n// setControls is special-cased above\n[\n/**\n * Set the value of `muted` on the media element. `muted` indicates that the current\n * audio level should be silent.\n *\n * @method Html5#setMuted\n * @param {boolean} muted\n *        - True if the audio should be set to silent\n *        - False otherwise\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n */\n'muted',\n\n/**\n * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current\n * audio level should be silent, but will only effect the muted level on intial playback..\n *\n * @method Html5.prototype.setDefaultMuted\n * @param {boolean} defaultMuted\n *        - True if the audio should be set to silent\n *        - False otherwise\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n */\n'defaultMuted',\n\n/**\n * Set the value of `autoplay` on the media element. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Html5#setAutoplay\n * @param {boolean} autoplay\n *         - True indicates that the media should start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n */\n'autoplay',\n\n/**\n * Set the value of `loop` on the media element. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Html5#setLoop\n * @param {boolean} loop\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n */\n'loop',\n\n/**\n * Set the value of `playsinline` from the media element. `playsinline` indicates\n * to the browser that non-fullscreen playback is preferred when fullscreen\n * playback is the native default, such as in iOS Safari.\n *\n * @method Html5#setPlaysinline\n * @param {boolean} playsinline\n *         - True indicates that the media should play inline.\n *         - False indicates that the media should not play inline.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n */\n'playsinline'].forEach(function (prop) {\n  Html5.prototype['set' + toTitleCase(prop)] = function (v) {\n    this.el_[prop] = v;\n\n    if (v) {\n      this.el_.setAttribute(prop, prop);\n    } else {\n      this.el_.removeAttribute(prop);\n    }\n  };\n});\n\n// Wrap native properties with a getter\n// The list is as followed\n// paused, currentTime, buffered, volume, poster, preload, error, seeking\n// seekable, ended, playbackRate, defaultPlaybackRate, played, networkState\n// readyState, videoWidth, videoHeight\n[\n/**\n * Get the value of `paused` from the media element. `paused` indicates whether the media element\n * is currently paused or not.\n *\n * @method Html5#paused\n * @return {boolean}\n *         The value of `paused` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}\n */\n'paused',\n\n/**\n * Get the value of `currentTime` from the media element. `currentTime` indicates\n * the current second that the media is at in playback.\n *\n * @method Html5#currentTime\n * @return {number}\n *         The value of `currentTime` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}\n */\n'currentTime',\n\n/**\n * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`\n * object that represents the parts of the media that are already downloaded and\n * available for playback.\n *\n * @method Html5#buffered\n * @return {TimeRange}\n *         The value of `buffered` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}\n */\n'buffered',\n\n/**\n * Get the value of `volume` from the media element. `volume` indicates\n * the current playback volume of audio for a media. `volume` will be a value from 0\n * (silent) to 1 (loudest and default).\n *\n * @method Html5#volume\n * @return {number}\n *         The value of `volume` from the media element. Value will be between 0-1.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n */\n'volume',\n\n/**\n * Get the value of `poster` from the media element. `poster` indicates\n * that the url of an image file that can/will be shown when no media data is available.\n *\n * @method Html5#poster\n * @return {string}\n *         The value of `poster` from the media element. Value will be a url to an\n *         image.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}\n */\n'poster',\n\n/**\n * Get the value of `preload` from the media element. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Html5#preload\n * @return {string}\n *         The value of `preload` from the media element. Will be 'none', 'metadata',\n *         or 'auto'.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n */\n'preload',\n\n/**\n * Get the value of the `error` from the media element. `error` indicates any\n * MediaError that may have occurred during playback. If error returns null there is no\n * current error.\n *\n * @method Html5#error\n * @return {MediaError|null}\n *         The value of `error` from the media element. Will be `MediaError` if there\n *         is a current error and null otherwise.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}\n */\n'error',\n\n/**\n * Get the value of `seeking` from the media element. `seeking` indicates whether the\n * media is currently seeking to a new position or not.\n *\n * @method Html5#seeking\n * @return {boolean}\n *         - The value of `seeking` from the media element.\n *         - True indicates that the media is currently seeking to a new position.\n *         - False indicates that the media is not seeking to a new position at this time.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}\n */\n'seeking',\n\n/**\n * Get the value of `seekable` from the media element. `seekable` returns a\n * `TimeRange` object indicating ranges of time that can currently be `seeked` to.\n *\n * @method Html5#seekable\n * @return {TimeRange}\n *         The value of `seekable` from the media element. A `TimeRange` object\n *         indicating the current ranges of time that can be seeked to.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}\n */\n'seekable',\n\n/**\n * Get the value of `ended` from the media element. `ended` indicates whether\n * the media has reached the end or not.\n *\n * @method Html5#ended\n * @return {boolean}\n *         - The value of `ended` from the media element.\n *         - True indicates that the media has ended.\n *         - False indicates that the media has not ended.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}\n */\n'ended',\n\n/**\n * Get the value of `playbackRate` from the media element. `playbackRate` indicates\n * the rate at which the media is currently playing back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5#playbackRate\n * @return {number}\n *         The value of `playbackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */\n'playbackRate',\n\n/**\n * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates\n * the rate at which the media is currently playing back. This value will not indicate the current\n * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.\n *\n * Examples:\n *   - if defaultPlaybackRate is set to 2, media will play twice as fast.\n *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5.prototype.defaultPlaybackRate\n * @return {number}\n *         The value of `defaultPlaybackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */\n'defaultPlaybackRate',\n\n/**\n * Get the value of `played` from the media element. `played` returns a `TimeRange`\n * object representing points in the media timeline that have been played.\n *\n * @method Html5#played\n * @return {TimeRange}\n *         The value of `played` from the media element. A `TimeRange` object indicating\n *         the ranges of time that have been played.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}\n */\n'played',\n\n/**\n * Get the value of `networkState` from the media element. `networkState` indicates\n * the current network state. It returns an enumeration from the following list:\n * - 0: NETWORK_EMPTY\n * - 1: NETWORK_IDLE\n * - 2: NETWORK_LOADING\n * - 3: NETWORK_NO_SOURCE\n *\n * @method Html5#networkState\n * @return {number}\n *         The value of `networkState` from the media element. This will be a number\n *         from the list in the description.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}\n */\n'networkState',\n\n/**\n * Get the value of `readyState` from the media element. `readyState` indicates\n * the current state of the media element. It returns an enumeration from the\n * following list:\n * - 0: HAVE_NOTHING\n * - 1: HAVE_METADATA\n * - 2: HAVE_CURRENT_DATA\n * - 3: HAVE_FUTURE_DATA\n * - 4: HAVE_ENOUGH_DATA\n *\n * @method Html5#readyState\n * @return {number}\n *         The value of `readyState` from the media element. This will be a number\n *         from the list in the description.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}\n */\n'readyState',\n\n/**\n * Get the value of `videoWidth` from the video element. `videoWidth` indicates\n * the current width of the video in css pixels.\n *\n * @method Html5#videoWidth\n * @return {number}\n *         The value of `videoWidth` from the video element. This will be a number\n *         in css pixels.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n */\n'videoWidth',\n\n/**\n * Get the value of `videoHeight` from the video element. `videoHeight` indicates\n * the current height of the video in css pixels.\n *\n * @method Html5#videoHeight\n * @return {number}\n *         The value of `videoHeight` from the video element. This will be a number\n *         in css pixels.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n */\n'videoHeight'].forEach(function (prop) {\n  Html5.prototype[prop] = function () {\n    return this.el_[prop];\n  };\n});\n\n// Wrap native properties with a setter in this format:\n// set + toTitleCase(name)\n// The list is as follows:\n// setVolume, setSrc, setPoster, setPreload, setPlaybackRate, setDefaultPlaybackRate\n[\n/**\n * Set the value of `volume` on the media element. `volume` indicates the current\n * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n * so on.\n *\n * @method Html5#setVolume\n * @param {number} percentAsDecimal\n *        The volume percent as a decimal. Valid range is from 0-1.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n */\n'volume',\n\n/**\n * Set the value of `src` on the media element. `src` indicates the current\n * {@link Tech~SourceObject} for the media.\n *\n * @method Html5#setSrc\n * @param {Tech~SourceObject} src\n *        The source object to set as the current source.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}\n */\n'src',\n\n/**\n * Set the value of `poster` on the media element. `poster` is the url to\n * an image file that can/will be shown when no media data is available.\n *\n * @method Html5#setPoster\n * @param {string} poster\n *        The url to an image that should be used as the `poster` for the media\n *        element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}\n */\n'poster',\n\n/**\n * Set the value of `preload` on the media element. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Html5#setPreload\n * @param {string} preload\n *         The value of `preload` to set on the media element. Must be 'none', 'metadata',\n *         or 'auto'.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n */\n'preload',\n\n/**\n * Set the value of `playbackRate` on the media element. `playbackRate` indicates\n * the rate at which the media should play back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5#setPlaybackRate\n * @return {number}\n *         The value of `playbackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */\n'playbackRate',\n\n/**\n * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates\n * the rate at which the media should play back upon initial startup. Changing this value\n * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.\n *\n * Example Values:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5.prototype.setDefaultPlaybackRate\n * @return {number}\n *         The value of `defaultPlaybackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}\n */\n'defaultPlaybackRate'].forEach(function (prop) {\n  Html5.prototype['set' + toTitleCase(prop)] = function (v) {\n    this.el_[prop] = v;\n  };\n});\n\n// wrap native functions with a function\n// The list is as follows:\n// pause, load, play\n[\n/**\n * A wrapper around the media elements `pause` function. This will call the `HTML5`\n * media elements `pause` function.\n *\n * @method Html5#pause\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}\n */\n'pause',\n\n/**\n * A wrapper around the media elements `load` function. This will call the `HTML5`s\n * media element `load` function.\n *\n * @method Html5#load\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}\n */\n'load',\n\n/**\n * A wrapper around the media elements `play` function. This will call the `HTML5`s\n * media element `play` function.\n *\n * @method Html5#play\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}\n */\n'play'].forEach(function (prop) {\n  Html5.prototype[prop] = function () {\n    return this.el_[prop]();\n  };\n});\n\nTech.withSourceHandlers(Html5);\n\n/**\n * Native source handler for Html5, simply passes the source to the media element.\n *\n * @property {Tech~SourceObject} source\n *        The source object\n *\n * @property {Html5} tech\n *        The instance of the HTML5 tech.\n */\nHtml5.nativeSourceHandler = {};\n\n/**\n * Check if the media element can play the given mime type.\n *\n * @param {string} type\n *        The mimetype to check\n *\n * @return {string}\n *         'probably', 'maybe', or '' (empty string)\n */\nHtml5.nativeSourceHandler.canPlayType = function (type) {\n  // IE without MediaPlayer throws an error (#519)\n  try {\n    return Html5.TEST_VID.canPlayType(type);\n  } catch (e) {\n    return '';\n  }\n};\n\n/**\n * Check if the media element can handle a source natively.\n *\n * @param {Tech~SourceObject} source\n *         The source object\n *\n * @param {Object} [options]\n *         Options to be passed to the tech.\n *\n * @return {string}\n *         'probably', 'maybe', or '' (empty string).\n */\nHtml5.nativeSourceHandler.canHandleSource = function (source, options) {\n\n  // If a type was provided we should rely on that\n  if (source.type) {\n    return Html5.nativeSourceHandler.canPlayType(source.type);\n\n    // If no type, fall back to checking 'video/[EXTENSION]'\n  } else if (source.src) {\n    var ext = getFileExtension(source.src);\n\n    return Html5.nativeSourceHandler.canPlayType('video/' + ext);\n  }\n\n  return '';\n};\n\n/**\n * Pass the source to the native media element.\n *\n * @param {Tech~SourceObject} source\n *        The source object\n *\n * @param {Html5} tech\n *        The instance of the Html5 tech\n *\n * @param {Object} [options]\n *        The options to pass to the source\n */\nHtml5.nativeSourceHandler.handleSource = function (source, tech, options) {\n  tech.setSrc(source.src);\n};\n\n/**\n * A noop for the native dispose function, as cleanup is not needed.\n */\nHtml5.nativeSourceHandler.dispose = function () {};\n\n// Register the native source handler\nHtml5.registerSourceHandler(Html5.nativeSourceHandler);\n\nTech.registerTech('Html5', Html5);\n\nvar _templateObject$2 = taggedTemplateLiteralLoose(['\\n        Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n        See https://github.com/videojs/video.js/issues/2617 for more info.\\n      '], ['\\n        Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n        See https://github.com/videojs/video.js/issues/2617 for more info.\\n      ']);\n\n// The following tech events are simply re-triggered\n// on the player when they happen\nvar TECH_EVENTS_RETRIGGER = [\n/**\n * Fired while the user agent is downloading media data.\n *\n * @event Player#progress\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `progress` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechProgress_\n * @fires Player#progress\n * @listens Tech#progress\n */\n'progress',\n\n/**\n * Fires when the loading of an audio/video is aborted.\n *\n * @event Player#abort\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `abort` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechAbort_\n * @fires Player#abort\n * @listens Tech#abort\n */\n'abort',\n\n/**\n * Fires when the browser is intentionally not getting media data.\n *\n * @event Player#suspend\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `suspend` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechSuspend_\n * @fires Player#suspend\n * @listens Tech#suspend\n */\n'suspend',\n\n/**\n * Fires when the current playlist is empty.\n *\n * @event Player#emptied\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `emptied` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechEmptied_\n * @fires Player#emptied\n * @listens Tech#emptied\n */\n'emptied',\n/**\n * Fires when the browser is trying to get media data, but data is not available.\n *\n * @event Player#stalled\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechStalled_\n * @fires Player#stalled\n * @listens Tech#stalled\n */\n'stalled',\n\n/**\n * Fires when the browser has loaded meta data for the audio/video.\n *\n * @event Player#loadedmetadata\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechLoadedmetadata_\n * @fires Player#loadedmetadata\n * @listens Tech#loadedmetadata\n */\n'loadedmetadata',\n\n/**\n * Fires when the browser has loaded the current frame of the audio/video.\n *\n * @event Player#loadeddata\n * @type {event}\n */\n/**\n * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechLoaddeddata_\n * @fires Player#loadeddata\n * @listens Tech#loadeddata\n */\n'loadeddata',\n\n/**\n * Fires when the current playback position has changed.\n *\n * @event Player#timeupdate\n * @type {event}\n */\n/**\n * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechTimeUpdate_\n * @fires Player#timeupdate\n * @listens Tech#timeupdate\n */\n'timeupdate',\n\n/**\n * Fires when the video's intrinsic dimensions change\n *\n * @event Player#resize\n * @type {event}\n */\n/**\n * Retrigger the `resize` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechResize_\n * @fires Player#resize\n * @listens Tech#resize\n */\n'resize',\n\n/**\n * Fires when the volume has been changed\n *\n * @event Player#volumechange\n * @type {event}\n */\n/**\n * Retrigger the `volumechange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechVolumechange_\n * @fires Player#volumechange\n * @listens Tech#volumechange\n */\n'volumechange',\n\n/**\n * Fires when the text track has been changed\n *\n * @event Player#texttrackchange\n * @type {event}\n */\n/**\n * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechTexttrackchange_\n * @fires Player#texttrackchange\n * @listens Tech#texttrackchange\n */\n'texttrackchange'];\n\n// events to queue when playback rate is zero\n// this is a hash for the sole purpose of mapping non-camel-cased event names\n// to camel-cased function names\nvar TECH_EVENTS_QUEUE = {\n  canplay: 'CanPlay',\n  canplaythrough: 'CanPlayThrough',\n  playing: 'Playing',\n  seeked: 'Seeked'\n};\n\n/**\n * An instance of the `Player` class is created when any of the Video.js setup methods\n * are used to initialize a video.\n *\n * After an instance has been created it can be accessed globally in two ways:\n * 1. By calling `videojs('example_video_1');`\n * 2. By using it directly via  `videojs.players.example_video_1;`\n *\n * @extends Component\n */\n\nvar Player = function (_Component) {\n  inherits(Player, _Component);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Element} tag\n   *        The original video DOM element used for configuring options.\n   *\n   * @param {Object} [options]\n   *        Object of option names and values.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        Ready callback function.\n   */\n  function Player(tag, options, ready) {\n    classCallCheck(this, Player);\n\n    // Make sure tag ID exists\n    tag.id = tag.id || options.id || 'vjs_video_' + newGUID();\n\n    // Set Options\n    // The options argument overrides options set in the video tag\n    // which overrides globally set options.\n    // This latter part coincides with the load order\n    // (tag must exist before Player)\n    options = assign(Player.getTagSettings(tag), options);\n\n    // Delay the initialization of children because we need to set up\n    // player properties first, and can't use `this` before `super()`\n    options.initChildren = false;\n\n    // Same with creating the element\n    options.createEl = false;\n\n    // don't auto mixin the evented mixin\n    options.evented = false;\n\n    // we don't want the player to report touch activity on itself\n    // see enableTouchActivity in Component\n    options.reportTouchActivity = false;\n\n    // If language is not set, get the closest lang attribute\n    if (!options.language) {\n      if (typeof tag.closest === 'function') {\n        var closest = tag.closest('[lang]');\n\n        if (closest && closest.getAttribute) {\n          options.language = closest.getAttribute('lang');\n        }\n      } else {\n        var element = tag;\n\n        while (element && element.nodeType === 1) {\n          if (getAttributes(element).hasOwnProperty('lang')) {\n            options.language = element.getAttribute('lang');\n            break;\n          }\n          element = element.parentNode;\n        }\n      }\n    }\n\n    // Run base component initializing with new options\n\n    // Tracks when a tech changes the poster\n    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));\n\n    _this.isPosterFromTech_ = false;\n\n    // Holds callback info that gets queued when playback rate is zero\n    // and a seek is happening\n    _this.queuedCallbacks_ = [];\n\n    // Turn off API access because we're loading a new tech that might load asynchronously\n    _this.isReady_ = false;\n\n    // Init state hasStarted_\n    _this.hasStarted_ = false;\n\n    // Init state userActive_\n    _this.userActive_ = false;\n\n    // if the global option object was accidentally blown away by\n    // someone, bail early with an informative error\n    if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {\n      throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');\n    }\n\n    // Store the original tag used to set options\n    _this.tag = tag;\n\n    // Store the tag attributes used to restore html5 element\n    _this.tagAttributes = tag && getAttributes(tag);\n\n    // Update current language\n    _this.language(_this.options_.language);\n\n    // Update Supported Languages\n    if (options.languages) {\n      // Normalise player option languages to lowercase\n      var languagesToLower = {};\n\n      Object.getOwnPropertyNames(options.languages).forEach(function (name$$1) {\n        languagesToLower[name$$1.toLowerCase()] = options.languages[name$$1];\n      });\n      _this.languages_ = languagesToLower;\n    } else {\n      _this.languages_ = Player.prototype.options_.languages;\n    }\n\n    // Cache for video property values.\n    _this.cache_ = {};\n\n    // Set poster\n    _this.poster_ = options.poster || '';\n\n    // Set controls\n    _this.controls_ = !!options.controls;\n\n    // Set default values for lastVolume\n    _this.cache_.lastVolume = 1;\n\n    // Original tag settings stored in options\n    // now remove immediately so native controls don't flash.\n    // May be turned back on by HTML5 tech if nativeControlsForTouch is true\n    tag.controls = false;\n    tag.removeAttribute('controls');\n\n    // the attribute overrides the option\n    if (tag.hasAttribute('autoplay')) {\n      _this.options_.autoplay = true;\n    } else {\n      // otherwise use the setter to validate and\n      // set the correct value.\n      _this.autoplay(_this.options_.autoplay);\n    }\n\n    /*\n     * Store the internal state of scrubbing\n     *\n     * @private\n     * @return {Boolean} True if the user is scrubbing\n     */\n    _this.scrubbing_ = false;\n\n    _this.el_ = _this.createEl();\n\n    // Set default value for lastPlaybackRate\n    _this.cache_.lastPlaybackRate = _this.defaultPlaybackRate();\n\n    // Make this an evented object and use `el_` as its event bus.\n    evented(_this, { eventBusKey: 'el_' });\n\n    // We also want to pass the original player options to each component and plugin\n    // as well so they don't need to reach back into the player for options later.\n    // We also need to do another copy of this.options_ so we don't end up with\n    // an infinite loop.\n    var playerOptionsCopy = mergeOptions(_this.options_);\n\n    // Load plugins\n    if (options.plugins) {\n      var plugins = options.plugins;\n\n      Object.keys(plugins).forEach(function (name$$1) {\n        if (typeof this[name$$1] === 'function') {\n          this[name$$1](plugins[name$$1]);\n        } else {\n          throw new Error('plugin \"' + name$$1 + '\" does not exist');\n        }\n      }, _this);\n    }\n\n    _this.options_.playerOptions = playerOptionsCopy;\n\n    _this.middleware_ = [];\n\n    _this.initChildren();\n\n    // Set isAudio based on whether or not an audio tag was used\n    _this.isAudio(tag.nodeName.toLowerCase() === 'audio');\n\n    // Update controls className. Can't do this when the controls are initially\n    // set because the element doesn't exist yet.\n    if (_this.controls()) {\n      _this.addClass('vjs-controls-enabled');\n    } else {\n      _this.addClass('vjs-controls-disabled');\n    }\n\n    // Set ARIA label and region role depending on player type\n    _this.el_.setAttribute('role', 'region');\n    if (_this.isAudio()) {\n      _this.el_.setAttribute('aria-label', _this.localize('Audio Player'));\n    } else {\n      _this.el_.setAttribute('aria-label', _this.localize('Video Player'));\n    }\n\n    if (_this.isAudio()) {\n      _this.addClass('vjs-audio');\n    }\n\n    if (_this.flexNotSupported_()) {\n      _this.addClass('vjs-no-flex');\n    }\n\n    // TODO: Make this smarter. Toggle user state between touching/mousing\n    // using events, since devices can have both touch and mouse events.\n    // if (browser.TOUCH_ENABLED) {\n    //   this.addClass('vjs-touch-enabled');\n    // }\n\n    // iOS Safari has broken hover handling\n    if (!IS_IOS) {\n      _this.addClass('vjs-workinghover');\n    }\n\n    // Make player easily findable by ID\n    Player.players[_this.id_] = _this;\n\n    // Add a major version class to aid css in plugins\n    var majorVersion = version.split('.')[0];\n\n    _this.addClass('vjs-v' + majorVersion);\n\n    // When the player is first initialized, trigger activity so components\n    // like the control bar show themselves if needed\n    _this.userActive(true);\n    _this.reportUserActivity();\n\n    _this.one('play', _this.listenForUserActivity_);\n    _this.on('fullscreenchange', _this.handleFullscreenChange_);\n    _this.on('stageclick', _this.handleStageClick_);\n\n    _this.changingSrc_ = false;\n    _this.playWaitingForReady_ = false;\n    _this.playOnLoadstart_ = null;\n    return _this;\n  }\n\n  /**\n   * Destroys the video player and does any necessary cleanup.\n   *\n   * This is especially helpful if you are dynamically adding and removing videos\n   * to/from the DOM.\n   *\n   * @fires Player#dispose\n   */\n\n\n  Player.prototype.dispose = function dispose() {\n    /**\n     * Called when the player is being disposed of.\n     *\n     * @event Player#dispose\n     * @type {EventTarget~Event}\n     */\n    this.trigger('dispose');\n    // prevent dispose from being called twice\n    this.off('dispose');\n\n    if (this.styleEl_ && this.styleEl_.parentNode) {\n      this.styleEl_.parentNode.removeChild(this.styleEl_);\n      this.styleEl_ = null;\n    }\n\n    // Kill reference to this player\n    Player.players[this.id_] = null;\n\n    if (this.tag && this.tag.player) {\n      this.tag.player = null;\n    }\n\n    if (this.el_ && this.el_.player) {\n      this.el_.player = null;\n    }\n\n    if (this.tech_) {\n      this.tech_.dispose();\n      this.isPosterFromTech_ = false;\n      this.poster_ = '';\n    }\n\n    if (this.playerElIngest_) {\n      this.playerElIngest_ = null;\n    }\n\n    if (this.tag) {\n      this.tag = null;\n    }\n\n    clearCacheForPlayer(this);\n\n    // the actual .el_ is removed here\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Create the `Player`'s DOM element.\n   *\n   * @return {Element}\n   *         The DOM element that gets created.\n   */\n\n\n  Player.prototype.createEl = function createEl$$1() {\n    var tag = this.tag;\n    var el = void 0;\n    var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');\n    var divEmbed = this.tag.tagName.toLowerCase() === 'video-js';\n\n    if (playerElIngest) {\n      el = this.el_ = tag.parentNode;\n    } else if (!divEmbed) {\n      el = this.el_ = _Component.prototype.createEl.call(this, 'div');\n    }\n\n    // Copy over all the attributes from the tag, including ID and class\n    // ID will now reference player box, not the video tag\n    var attrs = getAttributes(tag);\n\n    if (divEmbed) {\n      el = this.el_ = tag;\n      tag = this.tag = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('video');\n      while (el.children.length) {\n        tag.appendChild(el.firstChild);\n      }\n\n      if (!hasClass(el, 'video-js')) {\n        addClass(el, 'video-js');\n      }\n\n      el.appendChild(tag);\n\n      playerElIngest = this.playerElIngest_ = el;\n      // move properties over from our custom `video-js` element\n      // to our new `video` element. This will move things like\n      // `src` or `controls` that were set via js before the player\n      // was initialized.\n      Object.keys(el).forEach(function (k) {\n        tag[k] = el[k];\n      });\n    }\n\n    // set tabindex to -1 to remove the video element from the focus order\n    tag.setAttribute('tabindex', '-1');\n    // Workaround for #4583 (JAWS+IE doesn't announce BPB or play button)\n    // See https://github.com/FreedomScientific/VFO-standards-support/issues/78\n    // Note that we can't detect if JAWS is being used, but this ARIA attribute\n    //  doesn't change behavior of IE11 if JAWS is not being used\n    if (IE_VERSION) {\n      tag.setAttribute('role', 'application');\n    }\n\n    // Remove width/height attrs from tag so CSS can make it 100% width/height\n    tag.removeAttribute('width');\n    tag.removeAttribute('height');\n\n    Object.getOwnPropertyNames(attrs).forEach(function (attr) {\n      // don't copy over the class attribute to the player element when we're in a div embed\n      // the class is already set up properly in the divEmbed case\n      // and we want to make sure that the `video-js` class doesn't get lost\n      if (!(divEmbed && attr === 'class')) {\n        el.setAttribute(attr, attrs[attr]);\n      }\n\n      if (divEmbed) {\n        tag.setAttribute(attr, attrs[attr]);\n      }\n    });\n\n    // Update tag id/class for use as HTML5 playback tech\n    // Might think we should do this after embedding in container so .vjs-tech class\n    // doesn't flash 100% width/height, but class only applies with .video-js parent\n    tag.playerId = tag.id;\n    tag.id += '_html5_api';\n    tag.className = 'vjs-tech';\n\n    // Make player findable on elements\n    tag.player = el.player = this;\n    // Default state of video is paused\n    this.addClass('vjs-paused');\n\n    // Add a style element in the player that we'll use to set the width/height\n    // of the player in a way that's still overrideable by CSS, just like the\n    // video element\n    if (global_window__WEBPACK_IMPORTED_MODULE_0___default.a.VIDEOJS_NO_DYNAMIC_STYLE !== true) {\n      this.styleEl_ = createStyleElement('vjs-styles-dimensions');\n      var defaultsStyleEl = $('.vjs-styles-defaults');\n      var head = $('head');\n\n      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);\n    }\n\n    // Pass in the width/height/aspectRatio options which will update the style el\n    this.width(this.options_.width);\n    this.height(this.options_.height);\n    this.fluid(this.options_.fluid);\n    this.aspectRatio(this.options_.aspectRatio);\n\n    // Hide any links within the video/audio tag,\n    // because IE doesn't hide them completely from screen readers.\n    var links = tag.getElementsByTagName('a');\n\n    for (var i = 0; i < links.length; i++) {\n      var linkEl = links.item(i);\n\n      addClass(linkEl, 'vjs-hidden');\n      linkEl.setAttribute('hidden', 'hidden');\n    }\n\n    // insertElFirst seems to cause the networkState to flicker from 3 to 2, so\n    // keep track of the original for later so we can know if the source originally failed\n    tag.initNetworkState_ = tag.networkState;\n\n    // Wrap video tag in div (el/box) container\n    if (tag.parentNode && !playerElIngest) {\n      tag.parentNode.insertBefore(el, tag);\n    }\n\n    // insert the tag as the first child of the player element\n    // then manually add it to the children array so that this.addChild\n    // will work properly for other components\n    //\n    // Breaks iPhone, fixed in HTML5 setup.\n    prependTo(tag, el);\n    this.children_.unshift(tag);\n\n    // Set lang attr on player to ensure CSS :lang() in consistent with player\n    // if it's been set to something different to the doc\n    this.el_.setAttribute('lang', this.language_);\n\n    this.el_ = el;\n\n    return el;\n  };\n\n  /**\n   * A getter/setter for the `Player`'s width. Returns the player's configured value.\n   * To get the current width use `currentWidth()`.\n   *\n   * @param {number} [value]\n   *        The value to set the `Player`'s width to.\n   *\n   * @return {number}\n   *         The current width of the `Player` when getting.\n   */\n\n\n  Player.prototype.width = function width(value) {\n    return this.dimension('width', value);\n  };\n\n  /**\n   * A getter/setter for the `Player`'s height. Returns the player's configured value.\n   * To get the current height use `currentheight()`.\n   *\n   * @param {number} [value]\n   *        The value to set the `Player`'s heigth to.\n   *\n   * @return {number}\n   *         The current height of the `Player` when getting.\n   */\n\n\n  Player.prototype.height = function height(value) {\n    return this.dimension('height', value);\n  };\n\n  /**\n   * A getter/setter for the `Player`'s width & height.\n   *\n   * @param {string} dimension\n   *        This string can be:\n   *        - 'width'\n   *        - 'height'\n   *\n   * @param {number} [value]\n   *        Value for dimension specified in the first argument.\n   *\n   * @return {number}\n   *         The dimension arguments value when getting (width/height).\n   */\n\n\n  Player.prototype.dimension = function dimension(_dimension, value) {\n    var privDimension = _dimension + '_';\n\n    if (value === undefined) {\n      return this[privDimension] || 0;\n    }\n\n    if (value === '') {\n      // If an empty string is given, reset the dimension to be automatic\n      this[privDimension] = undefined;\n      this.updateStyleEl_();\n      return;\n    }\n\n    var parsedVal = parseFloat(value);\n\n    if (isNaN(parsedVal)) {\n      log$1.error('Improper value \"' + value + '\" supplied for for ' + _dimension);\n      return;\n    }\n\n    this[privDimension] = parsedVal;\n    this.updateStyleEl_();\n  };\n\n  /**\n   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.\n   *\n   * @param {boolean} [bool]\n   *        - A value of true adds the class.\n   *        - A value of false removes the class.\n   *        - No value will toggle the fluid class.\n   *\n   * @return {boolean|undefined}\n   *         - The value of fluid when getting.\n   *         - `undefined` when setting.\n   */\n\n\n  Player.prototype.fluid = function fluid(bool) {\n    if (bool === undefined) {\n      return !!this.fluid_;\n    }\n\n    this.fluid_ = !!bool;\n\n    if (bool) {\n      this.addClass('vjs-fluid');\n    } else {\n      this.removeClass('vjs-fluid');\n    }\n\n    this.updateStyleEl_();\n  };\n\n  /**\n   * Get/Set the aspect ratio\n   *\n   * @param {string} [ratio]\n   *        Aspect ratio for player\n   *\n   * @return {string|undefined}\n   *         returns the current aspect ratio when getting\n   */\n\n  /**\n   * A getter/setter for the `Player`'s aspect ratio.\n   *\n   * @param {string} [ratio]\n   *        The value to set the `Player's aspect ratio to.\n   *\n   * @return {string|undefined}\n   *         - The current aspect ratio of the `Player` when getting.\n   *         - undefined when setting\n   */\n\n\n  Player.prototype.aspectRatio = function aspectRatio(ratio) {\n    if (ratio === undefined) {\n      return this.aspectRatio_;\n    }\n\n    // Check for width:height format\n    if (!/^\\d+\\:\\d+$/.test(ratio)) {\n      throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');\n    }\n    this.aspectRatio_ = ratio;\n\n    // We're assuming if you set an aspect ratio you want fluid mode,\n    // because in fixed mode you could calculate width and height yourself.\n    this.fluid(true);\n\n    this.updateStyleEl_();\n  };\n\n  /**\n   * Update styles of the `Player` element (height, width and aspect ratio).\n   *\n   * @private\n   * @listens Tech#loadedmetadata\n   */\n\n\n  Player.prototype.updateStyleEl_ = function updateStyleEl_() {\n    if (global_window__WEBPACK_IMPORTED_MODULE_0___default.a.VIDEOJS_NO_DYNAMIC_STYLE === true) {\n      var _width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;\n      var _height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;\n      var techEl = this.tech_ && this.tech_.el();\n\n      if (techEl) {\n        if (_width >= 0) {\n          techEl.width = _width;\n        }\n        if (_height >= 0) {\n          techEl.height = _height;\n        }\n      }\n\n      return;\n    }\n\n    var width = void 0;\n    var height = void 0;\n    var aspectRatio = void 0;\n    var idClass = void 0;\n\n    // The aspect ratio is either used directly or to calculate width and height.\n    if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {\n      // Use any aspectRatio that's been specifically set\n      aspectRatio = this.aspectRatio_;\n    } else if (this.videoWidth() > 0) {\n      // Otherwise try to get the aspect ratio from the video metadata\n      aspectRatio = this.videoWidth() + ':' + this.videoHeight();\n    } else {\n      // Or use a default. The video element's is 2:1, but 16:9 is more common.\n      aspectRatio = '16:9';\n    }\n\n    // Get the ratio as a decimal we can use to calculate dimensions\n    var ratioParts = aspectRatio.split(':');\n    var ratioMultiplier = ratioParts[1] / ratioParts[0];\n\n    if (this.width_ !== undefined) {\n      // Use any width that's been specifically set\n      width = this.width_;\n    } else if (this.height_ !== undefined) {\n      // Or calulate the width from the aspect ratio if a height has been set\n      width = this.height_ / ratioMultiplier;\n    } else {\n      // Or use the video's metadata, or use the video el's default of 300\n      width = this.videoWidth() || 300;\n    }\n\n    if (this.height_ !== undefined) {\n      // Use any height that's been specifically set\n      height = this.height_;\n    } else {\n      // Otherwise calculate the height from the ratio and the width\n      height = width * ratioMultiplier;\n    }\n\n    // Ensure the CSS class is valid by starting with an alpha character\n    if (/^[^a-zA-Z]/.test(this.id())) {\n      idClass = 'dimensions-' + this.id();\n    } else {\n      idClass = this.id() + '-dimensions';\n    }\n\n    // Ensure the right class is still on the player for the style element\n    this.addClass(idClass);\n\n    setTextContent(this.styleEl_, '\\n      .' + idClass + ' {\\n        width: ' + width + 'px;\\n        height: ' + height + 'px;\\n      }\\n\\n      .' + idClass + '.vjs-fluid {\\n        padding-top: ' + ratioMultiplier * 100 + '%;\\n      }\\n    ');\n  };\n\n  /**\n   * Load/Create an instance of playback {@link Tech} including element\n   * and API methods. Then append the `Tech` element in `Player` as a child.\n   *\n   * @param {string} techName\n   *        name of the playback technology\n   *\n   * @param {string} source\n   *        video source\n   *\n   * @private\n   */\n\n\n  Player.prototype.loadTech_ = function loadTech_(techName, source) {\n    var _this2 = this;\n\n    // Pause and remove current playback technology\n    if (this.tech_) {\n      this.unloadTech_();\n    }\n\n    var titleTechName = toTitleCase(techName);\n    var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);\n\n    // get rid of the HTML5 video tag as soon as we are using another tech\n    if (titleTechName !== 'Html5' && this.tag) {\n      Tech.getTech('Html5').disposeMediaElement(this.tag);\n      this.tag.player = null;\n      this.tag = null;\n    }\n\n    this.techName_ = titleTechName;\n\n    // Turn off API access because we're loading a new tech that might load asynchronously\n    this.isReady_ = false;\n\n    // if autoplay is a string we pass false to the tech\n    // because the player is going to handle autoplay on `loadstart`\n    var autoplay = typeof this.autoplay() === 'string' ? false : this.autoplay();\n\n    // Grab tech-specific options from player options and add source and parent element to use.\n    var techOptions = {\n      source: source,\n      autoplay: autoplay,\n      'nativeControlsForTouch': this.options_.nativeControlsForTouch,\n      'playerId': this.id(),\n      'techId': this.id() + '_' + titleTechName + '_api',\n      'playsinline': this.options_.playsinline,\n      'preload': this.options_.preload,\n      'loop': this.options_.loop,\n      'muted': this.options_.muted,\n      'poster': this.poster(),\n      'language': this.language(),\n      'playerElIngest': this.playerElIngest_ || false,\n      'vtt.js': this.options_['vtt.js'],\n      'canOverridePoster': !!this.options_.techCanOverridePoster,\n      'enableSourceset': this.options_.enableSourceset\n    };\n\n    ALL.names.forEach(function (name$$1) {\n      var props = ALL[name$$1];\n\n      techOptions[props.getterName] = _this2[props.privateName];\n    });\n\n    assign(techOptions, this.options_[titleTechName]);\n    assign(techOptions, this.options_[camelTechName]);\n    assign(techOptions, this.options_[techName.toLowerCase()]);\n\n    if (this.tag) {\n      techOptions.tag = this.tag;\n    }\n\n    if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {\n      techOptions.startTime = this.cache_.currentTime;\n    }\n\n    // Initialize tech instance\n    var TechClass = Tech.getTech(techName);\n\n    if (!TechClass) {\n      throw new Error('No Tech named \\'' + titleTechName + '\\' exists! \\'' + titleTechName + '\\' should be registered using videojs.registerTech()\\'');\n    }\n\n    this.tech_ = new TechClass(techOptions);\n\n    // player.triggerReady is always async, so don't need this to be async\n    this.tech_.ready(bind(this, this.handleTechReady_), true);\n\n    textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);\n\n    // Listen to all HTML5-defined events and trigger them on the player\n    TECH_EVENTS_RETRIGGER.forEach(function (event) {\n      _this2.on(_this2.tech_, event, _this2['handleTech' + toTitleCase(event) + '_']);\n    });\n\n    Object.keys(TECH_EVENTS_QUEUE).forEach(function (event) {\n      _this2.on(_this2.tech_, event, function (eventObj) {\n        if (_this2.tech_.playbackRate() === 0 && _this2.tech_.seeking()) {\n          _this2.queuedCallbacks_.push({\n            callback: _this2['handleTech' + TECH_EVENTS_QUEUE[event] + '_'].bind(_this2),\n            event: eventObj\n          });\n          return;\n        }\n        _this2['handleTech' + TECH_EVENTS_QUEUE[event] + '_'](eventObj);\n      });\n    });\n\n    this.on(this.tech_, 'loadstart', this.handleTechLoadStart_);\n    this.on(this.tech_, 'sourceset', this.handleTechSourceset_);\n    this.on(this.tech_, 'waiting', this.handleTechWaiting_);\n    this.on(this.tech_, 'ended', this.handleTechEnded_);\n    this.on(this.tech_, 'seeking', this.handleTechSeeking_);\n    this.on(this.tech_, 'play', this.handleTechPlay_);\n    this.on(this.tech_, 'firstplay', this.handleTechFirstPlay_);\n    this.on(this.tech_, 'pause', this.handleTechPause_);\n    this.on(this.tech_, 'durationchange', this.handleTechDurationChange_);\n    this.on(this.tech_, 'fullscreenchange', this.handleTechFullscreenChange_);\n    this.on(this.tech_, 'error', this.handleTechError_);\n    this.on(this.tech_, 'loadedmetadata', this.updateStyleEl_);\n    this.on(this.tech_, 'posterchange', this.handleTechPosterChange_);\n    this.on(this.tech_, 'textdata', this.handleTechTextData_);\n    this.on(this.tech_, 'ratechange', this.handleTechRateChange_);\n\n    this.usingNativeControls(this.techGet_('controls'));\n\n    if (this.controls() && !this.usingNativeControls()) {\n      this.addTechControlsListeners_();\n    }\n\n    // Add the tech element in the DOM if it was not already there\n    // Make sure to not insert the original video element if using Html5\n    if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {\n      prependTo(this.tech_.el(), this.el());\n    }\n\n    // Get rid of the original video tag reference after the first tech is loaded\n    if (this.tag) {\n      this.tag.player = null;\n      this.tag = null;\n    }\n  };\n\n  /**\n   * Unload and dispose of the current playback {@link Tech}.\n   *\n   * @private\n   */\n\n\n  Player.prototype.unloadTech_ = function unloadTech_() {\n    var _this3 = this;\n\n    // Save the current text tracks so that we can reuse the same text tracks with the next tech\n    ALL.names.forEach(function (name$$1) {\n      var props = ALL[name$$1];\n\n      _this3[props.privateName] = _this3[props.getterName]();\n    });\n    this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);\n\n    this.isReady_ = false;\n\n    this.tech_.dispose();\n\n    this.tech_ = false;\n\n    if (this.isPosterFromTech_) {\n      this.poster_ = '';\n      this.trigger('posterchange');\n    }\n\n    this.isPosterFromTech_ = false;\n  };\n\n  /**\n   * Return a reference to the current {@link Tech}.\n   * It will print a warning by default about the danger of using the tech directly\n   * but any argument that is passed in will silence the warning.\n   *\n   * @param {*} [safety]\n   *        Anything passed in to silence the warning\n   *\n   * @return {Tech}\n   *         The Tech\n   */\n\n\n  Player.prototype.tech = function tech(safety) {\n    if (safety === undefined) {\n      log$1.warn(tsml__WEBPACK_IMPORTED_MODULE_2___default()(_templateObject$2));\n    }\n\n    return this.tech_;\n  };\n\n  /**\n   * Set up click and touch listeners for the playback element\n   *\n   * - On desktops: a click on the video itself will toggle playback\n   * - On mobile devices: a click on the video toggles controls\n   *   which is done by toggling the user state between active and\n   *   inactive\n   * - A tap can signal that a user has become active or has become inactive\n   *   e.g. a quick tap on an iPhone movie should reveal the controls. Another\n   *   quick tap should hide them again (signaling the user is in an inactive\n   *   viewing state)\n   * - In addition to this, we still want the user to be considered inactive after\n   *   a few seconds of inactivity.\n   *\n   * > Note: the only part of iOS interaction we can't mimic with this setup\n   * is a touch and hold on the video element counting as activity in order to\n   * keep the controls showing, but that shouldn't be an issue. A touch and hold\n   * on any controls will still keep the user active\n   *\n   * @private\n   */\n\n\n  Player.prototype.addTechControlsListeners_ = function addTechControlsListeners_() {\n    // Make sure to remove all the previous listeners in case we are called multiple times.\n    this.removeTechControlsListeners_();\n\n    // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do\n    // trigger mousedown/up.\n    // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object\n    // Any touch events are set to block the mousedown event from happening\n    this.on(this.tech_, 'mousedown', this.handleTechClick_);\n    this.on(this.tech_, 'dblclick', this.handleTechDoubleClick_);\n\n    // If the controls were hidden we don't want that to change without a tap event\n    // so we'll check if the controls were already showing before reporting user\n    // activity\n    this.on(this.tech_, 'touchstart', this.handleTechTouchStart_);\n    this.on(this.tech_, 'touchmove', this.handleTechTouchMove_);\n    this.on(this.tech_, 'touchend', this.handleTechTouchEnd_);\n\n    // The tap listener needs to come after the touchend listener because the tap\n    // listener cancels out any reportedUserActivity when setting userActive(false)\n    this.on(this.tech_, 'tap', this.handleTechTap_);\n  };\n\n  /**\n   * Remove the listeners used for click and tap controls. This is needed for\n   * toggling to controls disabled, where a tap/touch should do nothing.\n   *\n   * @private\n   */\n\n\n  Player.prototype.removeTechControlsListeners_ = function removeTechControlsListeners_() {\n    // We don't want to just use `this.off()` because there might be other needed\n    // listeners added by techs that extend this.\n    this.off(this.tech_, 'tap', this.handleTechTap_);\n    this.off(this.tech_, 'touchstart', this.handleTechTouchStart_);\n    this.off(this.tech_, 'touchmove', this.handleTechTouchMove_);\n    this.off(this.tech_, 'touchend', this.handleTechTouchEnd_);\n    this.off(this.tech_, 'mousedown', this.handleTechClick_);\n    this.off(this.tech_, 'dblclick', this.handleTechDoubleClick_);\n  };\n\n  /**\n   * Player waits for the tech to be ready\n   *\n   * @private\n   */\n\n\n  Player.prototype.handleTechReady_ = function handleTechReady_() {\n    this.triggerReady();\n\n    // Keep the same volume as before\n    if (this.cache_.volume) {\n      this.techCall_('setVolume', this.cache_.volume);\n    }\n\n    // Look if the tech found a higher resolution poster while loading\n    this.handleTechPosterChange_();\n\n    // Update the duration if available\n    this.handleTechDurationChange_();\n  };\n\n  /**\n   * Retrigger the `loadstart` event that was triggered by the {@link Tech}. This\n   * function will also trigger {@link Player#firstplay} if it is the first loadstart\n   * for a video.\n   *\n   * @fires Player#loadstart\n   * @fires Player#firstplay\n   * @listens Tech#loadstart\n   * @private\n   */\n\n\n  Player.prototype.handleTechLoadStart_ = function handleTechLoadStart_() {\n    // TODO: Update to use `emptied` event instead. See #1277.\n\n    this.removeClass('vjs-ended');\n    this.removeClass('vjs-seeking');\n\n    // reset the error state\n    this.error(null);\n\n    // If it's already playing we want to trigger a firstplay event now.\n    // The firstplay event relies on both the play and loadstart events\n    // which can happen in any order for a new source\n    if (!this.paused()) {\n      /**\n       * Fired when the user agent begins looking for media data\n       *\n       * @event Player#loadstart\n       * @type {EventTarget~Event}\n       */\n      this.trigger('loadstart');\n      this.trigger('firstplay');\n    } else {\n      // reset the hasStarted state\n      this.hasStarted(false);\n      this.trigger('loadstart');\n    }\n\n    // autoplay happens after loadstart for the browser,\n    // so we mimic that behavior\n    this.manualAutoplay_(this.autoplay());\n  };\n\n  /**\n   * Handle autoplay string values, rather than the typical boolean\n   * values that should be handled by the tech. Note that this is not\n   * part of any specification. Valid values and what they do can be\n   * found on the autoplay getter at Player#autoplay()\n   */\n\n\n  Player.prototype.manualAutoplay_ = function manualAutoplay_(type) {\n    var _this4 = this;\n\n    if (!this.tech_ || typeof type !== 'string') {\n      return;\n    }\n\n    var muted = function muted() {\n      var previouslyMuted = _this4.muted();\n\n      _this4.muted(true);\n\n      var playPromise = _this4.play();\n\n      if (!playPromise || !playPromise.then || !playPromise.catch) {\n        return;\n      }\n\n      return playPromise.catch(function (e) {\n        // restore old value of muted on failure\n        _this4.muted(previouslyMuted);\n      });\n    };\n\n    var promise = void 0;\n\n    if (type === 'any') {\n      promise = this.play();\n\n      if (promise && promise.then && promise.catch) {\n        promise.catch(function () {\n          return muted();\n        });\n      }\n    } else if (type === 'muted') {\n      promise = muted();\n    } else {\n      promise = this.play();\n    }\n\n    if (!promise || !promise.then || !promise.catch) {\n      return;\n    }\n\n    return promise.then(function () {\n      _this4.trigger({ type: 'autoplay-success', autoplay: type });\n    }).catch(function (e) {\n      _this4.trigger({ type: 'autoplay-failure', autoplay: type });\n    });\n  };\n\n  /**\n   * Update the internal source caches so that we return the correct source from\n   * `src()`, `currentSource()`, and `currentSources()`.\n   *\n   * > Note: `currentSources` will not be updated if the source that is passed in exists\n   *         in the current `currentSources` cache.\n   *\n   *\n   * @param {Tech~SourceObject} srcObj\n   *        A string or object source to update our caches to.\n   */\n\n\n  Player.prototype.updateSourceCaches_ = function updateSourceCaches_() {\n    var srcObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n\n    var src = srcObj;\n    var type = '';\n\n    if (typeof src !== 'string') {\n      src = srcObj.src;\n      type = srcObj.type;\n    }\n    // make sure all the caches are set to default values\n    // to prevent null checking\n    this.cache_.source = this.cache_.source || {};\n    this.cache_.sources = this.cache_.sources || [];\n\n    // try to get the type of the src that was passed in\n    if (src && !type) {\n      type = findMimetype(this, src);\n    }\n\n    // update `currentSource` cache always\n    this.cache_.source = mergeOptions({}, srcObj, { src: src, type: type });\n\n    var matchingSources = this.cache_.sources.filter(function (s) {\n      return s.src && s.src === src;\n    });\n    var sourceElSources = [];\n    var sourceEls = this.$$('source');\n    var matchingSourceEls = [];\n\n    for (var i = 0; i < sourceEls.length; i++) {\n      var sourceObj = getAttributes(sourceEls[i]);\n\n      sourceElSources.push(sourceObj);\n\n      if (sourceObj.src && sourceObj.src === src) {\n        matchingSourceEls.push(sourceObj.src);\n      }\n    }\n\n    // if we have matching source els but not matching sources\n    // the current source cache is not up to date\n    if (matchingSourceEls.length && !matchingSources.length) {\n      this.cache_.sources = sourceElSources;\n      // if we don't have matching source or source els set the\n      // sources cache to the `currentSource` cache\n    } else if (!matchingSources.length) {\n      this.cache_.sources = [this.cache_.source];\n    }\n\n    // update the tech `src` cache\n    this.cache_.src = src;\n  };\n\n  /**\n   * *EXPERIMENTAL* Fired when the source is set or changed on the {@link Tech}\n   * causing the media element to reload.\n   *\n   * It will fire for the initial source and each subsequent source.\n   * This event is a custom event from Video.js and is triggered by the {@link Tech}.\n   *\n   * The event object for this event contains a `src` property that will contain the source\n   * that was available when the event was triggered. This is generally only necessary if Video.js\n   * is switching techs while the source was being changed.\n   *\n   * It is also fired when `load` is called on the player (or media element)\n   * because the {@link https://html.spec.whatwg.org/multipage/media.html#dom-media-load|specification for `load`}\n   * says that the resource selection algorithm needs to be aborted and restarted.\n   * In this case, it is very likely that the `src` property will be set to the\n   * empty string `\"\"` to indicate we do not know what the source will be but\n   * that it is changing.\n   *\n   * *This event is currently still experimental and may change in minor releases.*\n   * __To use this, pass `enableSourceset` option to the player.__\n   *\n   * @event Player#sourceset\n   * @type {EventTarget~Event}\n   * @prop {string} src\n   *                The source url available when the `sourceset` was triggered.\n   *                It will be an empty string if we cannot know what the source is\n   *                but know that the source will change.\n   */\n  /**\n   * Retrigger the `sourceset` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#sourceset\n   * @listens Tech#sourceset\n   * @private\n   */\n\n\n  Player.prototype.handleTechSourceset_ = function handleTechSourceset_(event) {\n    var _this5 = this;\n\n    // only update the source cache when the source\n    // was not updated using the player api\n    if (!this.changingSrc_) {\n      // update the source to the intial source right away\n      // in some cases this will be empty string\n      this.updateSourceCaches_(event.src);\n\n      // if the `sourceset` `src` was an empty string\n      // wait for a `loadstart` to update the cache to `currentSrc`.\n      // If a sourceset happens before a `loadstart`, we reset the state\n      // as this function will be called again.\n      if (!event.src) {\n        var updateCache = function updateCache(e) {\n          if (e.type !== 'sourceset') {\n            _this5.updateSourceCaches_(_this5.techGet_('currentSrc'));\n          }\n\n          _this5.tech_.off(['sourceset', 'loadstart'], updateCache);\n        };\n\n        this.tech_.one(['sourceset', 'loadstart'], updateCache);\n      }\n    }\n\n    this.trigger({\n      src: event.src,\n      type: 'sourceset'\n    });\n  };\n\n  /**\n   * Add/remove the vjs-has-started class\n   *\n   * @fires Player#firstplay\n   *\n   * @param {boolean} request\n   *        - true: adds the class\n   *        - false: remove the class\n   *\n   * @return {boolean}\n   *         the boolean value of hasStarted_\n   */\n\n\n  Player.prototype.hasStarted = function hasStarted(request) {\n    if (request === undefined) {\n      // act as getter, if we have no request to change\n      return this.hasStarted_;\n    }\n\n    if (request === this.hasStarted_) {\n      return;\n    }\n\n    this.hasStarted_ = request;\n\n    if (this.hasStarted_) {\n      this.addClass('vjs-has-started');\n      this.trigger('firstplay');\n    } else {\n      this.removeClass('vjs-has-started');\n    }\n  };\n\n  /**\n   * Fired whenever the media begins or resumes playback\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}\n   * @fires Player#play\n   * @listens Tech#play\n   * @private\n   */\n\n\n  Player.prototype.handleTechPlay_ = function handleTechPlay_() {\n    this.removeClass('vjs-ended');\n    this.removeClass('vjs-paused');\n    this.addClass('vjs-playing');\n\n    // hide the poster when the user hits play\n    this.hasStarted(true);\n    /**\n     * Triggered whenever an {@link Tech#play} event happens. Indicates that\n     * playback has started or resumed.\n     *\n     * @event Player#play\n     * @type {EventTarget~Event}\n     */\n    this.trigger('play');\n  };\n\n  /**\n   * Retrigger the `ratechange` event that was triggered by the {@link Tech}.\n   *\n   * If there were any events queued while the playback rate was zero, fire\n   * those events now.\n   *\n   * @private\n   * @method Player#handleTechRateChange_\n   * @fires Player#ratechange\n   * @listens Tech#ratechange\n   */\n\n\n  Player.prototype.handleTechRateChange_ = function handleTechRateChange_() {\n    if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {\n      this.queuedCallbacks_.forEach(function (queued) {\n        return queued.callback(queued.event);\n      });\n      this.queuedCallbacks_ = [];\n    }\n    this.cache_.lastPlaybackRate = this.tech_.playbackRate();\n    /**\n     * Fires when the playing speed of the audio/video is changed\n     *\n     * @event Player#ratechange\n     * @type {event}\n     */\n    this.trigger('ratechange');\n  };\n\n  /**\n   * Retrigger the `waiting` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#waiting\n   * @listens Tech#waiting\n   * @private\n   */\n\n\n  Player.prototype.handleTechWaiting_ = function handleTechWaiting_() {\n    var _this6 = this;\n\n    this.addClass('vjs-waiting');\n    /**\n     * A readyState change on the DOM element has caused playback to stop.\n     *\n     * @event Player#waiting\n     * @type {EventTarget~Event}\n     */\n    this.trigger('waiting');\n    this.one('timeupdate', function () {\n      return _this6.removeClass('vjs-waiting');\n    });\n  };\n\n  /**\n   * Retrigger the `canplay` event that was triggered by the {@link Tech}.\n   * > Note: This is not consistent between browsers. See #1351\n   *\n   * @fires Player#canplay\n   * @listens Tech#canplay\n   * @private\n   */\n\n\n  Player.prototype.handleTechCanPlay_ = function handleTechCanPlay_() {\n    this.removeClass('vjs-waiting');\n    /**\n     * The media has a readyState of HAVE_FUTURE_DATA or greater.\n     *\n     * @event Player#canplay\n     * @type {EventTarget~Event}\n     */\n    this.trigger('canplay');\n  };\n\n  /**\n   * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#canplaythrough\n   * @listens Tech#canplaythrough\n   * @private\n   */\n\n\n  Player.prototype.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {\n    this.removeClass('vjs-waiting');\n    /**\n     * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the\n     * entire media file can be played without buffering.\n     *\n     * @event Player#canplaythrough\n     * @type {EventTarget~Event}\n     */\n    this.trigger('canplaythrough');\n  };\n\n  /**\n   * Retrigger the `playing` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#playing\n   * @listens Tech#playing\n   * @private\n   */\n\n\n  Player.prototype.handleTechPlaying_ = function handleTechPlaying_() {\n    this.removeClass('vjs-waiting');\n    /**\n     * The media is no longer blocked from playback, and has started playing.\n     *\n     * @event Player#playing\n     * @type {EventTarget~Event}\n     */\n    this.trigger('playing');\n  };\n\n  /**\n   * Retrigger the `seeking` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#seeking\n   * @listens Tech#seeking\n   * @private\n   */\n\n\n  Player.prototype.handleTechSeeking_ = function handleTechSeeking_() {\n    this.addClass('vjs-seeking');\n    /**\n     * Fired whenever the player is jumping to a new time\n     *\n     * @event Player#seeking\n     * @type {EventTarget~Event}\n     */\n    this.trigger('seeking');\n  };\n\n  /**\n   * Retrigger the `seeked` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#seeked\n   * @listens Tech#seeked\n   * @private\n   */\n\n\n  Player.prototype.handleTechSeeked_ = function handleTechSeeked_() {\n    this.removeClass('vjs-seeking');\n    /**\n     * Fired when the player has finished jumping to a new time\n     *\n     * @event Player#seeked\n     * @type {EventTarget~Event}\n     */\n    this.trigger('seeked');\n  };\n\n  /**\n   * Retrigger the `firstplay` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#firstplay\n   * @listens Tech#firstplay\n   * @deprecated As of 6.0 firstplay event is deprecated.\n   * @deprecated As of 6.0 passing the `starttime` option to the player and the firstplay event are deprecated.\n   * @private\n   */\n\n\n  Player.prototype.handleTechFirstPlay_ = function handleTechFirstPlay_() {\n    // If the first starttime attribute is specified\n    // then we will start at the given offset in seconds\n    if (this.options_.starttime) {\n      log$1.warn('Passing the `starttime` option to the player will be deprecated in 6.0');\n      this.currentTime(this.options_.starttime);\n    }\n\n    this.addClass('vjs-has-started');\n    /**\n     * Fired the first time a video is played. Not part of the HLS spec, and this is\n     * probably not the best implementation yet, so use sparingly. If you don't have a\n     * reason to prevent playback, use `myPlayer.one('play');` instead.\n     *\n     * @event Player#firstplay\n     * @deprecated As of 6.0 firstplay event is deprecated.\n     * @type {EventTarget~Event}\n     */\n    this.trigger('firstplay');\n  };\n\n  /**\n   * Retrigger the `pause` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#pause\n   * @listens Tech#pause\n   * @private\n   */\n\n\n  Player.prototype.handleTechPause_ = function handleTechPause_() {\n    this.removeClass('vjs-playing');\n    this.addClass('vjs-paused');\n    /**\n     * Fired whenever the media has been paused\n     *\n     * @event Player#pause\n     * @type {EventTarget~Event}\n     */\n    this.trigger('pause');\n  };\n\n  /**\n   * Retrigger the `ended` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#ended\n   * @listens Tech#ended\n   * @private\n   */\n\n\n  Player.prototype.handleTechEnded_ = function handleTechEnded_() {\n    this.addClass('vjs-ended');\n    if (this.options_.loop) {\n      this.currentTime(0);\n      this.play();\n    } else if (!this.paused()) {\n      this.pause();\n    }\n\n    /**\n     * Fired when the end of the media resource is reached (currentTime == duration)\n     *\n     * @event Player#ended\n     * @type {EventTarget~Event}\n     */\n    this.trigger('ended');\n  };\n\n  /**\n   * Fired when the duration of the media resource is first known or changed\n   *\n   * @listens Tech#durationchange\n   * @private\n   */\n\n\n  Player.prototype.handleTechDurationChange_ = function handleTechDurationChange_() {\n    this.duration(this.techGet_('duration'));\n  };\n\n  /**\n   * Handle a click on the media element to play/pause\n   *\n   * @param {EventTarget~Event} event\n   *        the event that caused this function to trigger\n   *\n   * @listens Tech#mousedown\n   * @private\n   */\n\n\n  Player.prototype.handleTechClick_ = function handleTechClick_(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    // When controls are disabled a click should not toggle playback because\n    // the click is considered a control\n    if (!this.controls_) {\n      return;\n    }\n\n    if (this.paused()) {\n      silencePromise(this.play());\n    } else {\n      this.pause();\n    }\n  };\n\n  /**\n   * Handle a double-click on the media element to enter/exit fullscreen\n   *\n   * @param {EventTarget~Event} event\n   *        the event that caused this function to trigger\n   *\n   * @listens Tech#dblclick\n   * @private\n   */\n\n\n  Player.prototype.handleTechDoubleClick_ = function handleTechDoubleClick_(event) {\n    if (!this.controls_) {\n      return;\n    }\n\n    // we do not want to toggle fullscreen state\n    // when double-clicking inside a control bar or a modal\n    var inAllowedEls = Array.prototype.some.call(this.$$('.vjs-control-bar, .vjs-modal-dialog'), function (el) {\n      return el.contains(event.target);\n    });\n\n    if (!inAllowedEls) {\n      if (this.isFullscreen()) {\n        this.exitFullscreen();\n      } else {\n        this.requestFullscreen();\n      }\n    }\n  };\n\n  /**\n   * Handle a tap on the media element. It will toggle the user\n   * activity state, which hides and shows the controls.\n   *\n   * @listens Tech#tap\n   * @private\n   */\n\n\n  Player.prototype.handleTechTap_ = function handleTechTap_() {\n    this.userActive(!this.userActive());\n  };\n\n  /**\n   * Handle touch to start\n   *\n   * @listens Tech#touchstart\n   * @private\n   */\n\n\n  Player.prototype.handleTechTouchStart_ = function handleTechTouchStart_() {\n    this.userWasActive = this.userActive();\n  };\n\n  /**\n   * Handle touch to move\n   *\n   * @listens Tech#touchmove\n   * @private\n   */\n\n\n  Player.prototype.handleTechTouchMove_ = function handleTechTouchMove_() {\n    if (this.userWasActive) {\n      this.reportUserActivity();\n    }\n  };\n\n  /**\n   * Handle touch to end\n   *\n   * @param {EventTarget~Event} event\n   *        the touchend event that triggered\n   *        this function\n   *\n   * @listens Tech#touchend\n   * @private\n   */\n\n\n  Player.prototype.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {\n    // Stop the mouse events from also happening\n    event.preventDefault();\n  };\n\n  /**\n   * Fired when the player switches in or out of fullscreen mode\n   *\n   * @private\n   * @listens Player#fullscreenchange\n   */\n\n\n  Player.prototype.handleFullscreenChange_ = function handleFullscreenChange_() {\n    if (this.isFullscreen()) {\n      this.addClass('vjs-fullscreen');\n    } else {\n      this.removeClass('vjs-fullscreen');\n    }\n  };\n\n  /**\n   * native click events on the SWF aren't triggered on IE11, Win8.1RT\n   * use stageclick events triggered from inside the SWF instead\n   *\n   * @private\n   * @listens stageclick\n   */\n\n\n  Player.prototype.handleStageClick_ = function handleStageClick_() {\n    this.reportUserActivity();\n  };\n\n  /**\n   * Handle Tech Fullscreen Change\n   *\n   * @param {EventTarget~Event} event\n   *        the fullscreenchange event that triggered this function\n   *\n   * @param {Object} data\n   *        the data that was sent with the event\n   *\n   * @private\n   * @listens Tech#fullscreenchange\n   * @fires Player#fullscreenchange\n   */\n\n\n  Player.prototype.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {\n    if (data) {\n      this.isFullscreen(data.isFullscreen);\n    }\n    /**\n     * Fired when going in and out of fullscreen.\n     *\n     * @event Player#fullscreenchange\n     * @type {EventTarget~Event}\n     */\n    this.trigger('fullscreenchange');\n  };\n\n  /**\n   * Fires when an error occurred during the loading of an audio/video.\n   *\n   * @private\n   * @listens Tech#error\n   */\n\n\n  Player.prototype.handleTechError_ = function handleTechError_() {\n    var error = this.tech_.error();\n\n    this.error(error);\n  };\n\n  /**\n   * Retrigger the `textdata` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#textdata\n   * @listens Tech#textdata\n   * @private\n   */\n\n\n  Player.prototype.handleTechTextData_ = function handleTechTextData_() {\n    var data = null;\n\n    if (arguments.length > 1) {\n      data = arguments[1];\n    }\n\n    /**\n     * Fires when we get a textdata event from tech\n     *\n     * @event Player#textdata\n     * @type {EventTarget~Event}\n     */\n    this.trigger('textdata', data);\n  };\n\n  /**\n   * Get object for cached values.\n   *\n   * @return {Object}\n   *         get the current object cache\n   */\n\n\n  Player.prototype.getCache = function getCache() {\n    return this.cache_;\n  };\n\n  /**\n   * Pass values to the playback tech\n   *\n   * @param {string} [method]\n   *        the method to call\n   *\n   * @param {Object} arg\n   *        the argument to pass\n   *\n   * @private\n   */\n\n\n  Player.prototype.techCall_ = function techCall_(method, arg) {\n    // If it's not ready yet, call method when it is\n\n    this.ready(function () {\n      if (method in allowedSetters) {\n        return set$1(this.middleware_, this.tech_, method, arg);\n      } else if (method in allowedMediators) {\n        return mediate(this.middleware_, this.tech_, method, arg);\n      }\n\n      try {\n        if (this.tech_) {\n          this.tech_[method](arg);\n        }\n      } catch (e) {\n        log$1(e);\n        throw e;\n      }\n    }, true);\n  };\n\n  /**\n   * Get calls can't wait for the tech, and sometimes don't need to.\n   *\n   * @param {string} method\n   *        Tech method\n   *\n   * @return {Function|undefined}\n   *         the method or undefined\n   *\n   * @private\n   */\n\n\n  Player.prototype.techGet_ = function techGet_(method) {\n    if (!this.tech_ || !this.tech_.isReady_) {\n      return;\n    }\n\n    if (method in allowedGetters) {\n      return get$1(this.middleware_, this.tech_, method);\n    } else if (method in allowedMediators) {\n      return mediate(this.middleware_, this.tech_, method);\n    }\n\n    // Flash likes to die and reload when you hide or reposition it.\n    // In these cases the object methods go away and we get errors.\n    // When that happens we'll catch the errors and inform tech that it's not ready any more.\n    try {\n      return this.tech_[method]();\n    } catch (e) {\n\n      // When building additional tech libs, an expected method may not be defined yet\n      if (this.tech_[method] === undefined) {\n        log$1('Video.js: ' + method + ' method not defined for ' + this.techName_ + ' playback technology.', e);\n        throw e;\n      }\n\n      // When a method isn't available on the object it throws a TypeError\n      if (e.name === 'TypeError') {\n        log$1('Video.js: ' + method + ' unavailable on ' + this.techName_ + ' playback technology element.', e);\n        this.tech_.isReady_ = false;\n        throw e;\n      }\n\n      // If error unknown, just log and throw\n      log$1(e);\n      throw e;\n    }\n  };\n\n  /**\n   * Attempt to begin playback at the first opportunity.\n   *\n   * @return {Promise|undefined}\n   *         Returns a `Promise` only if the browser returns one and the player\n   *         is ready to begin playback. For some browsers and all non-ready\n   *         situations, this will return `undefined`.\n   */\n\n\n  Player.prototype.play = function play() {\n    var _this7 = this;\n\n    // If this is called while we have a play queued up on a loadstart, remove\n    // that listener to avoid getting in a potentially bad state.\n    if (this.playOnLoadstart_) {\n      this.off('loadstart', this.playOnLoadstart_);\n    }\n\n    // If the player/tech is not ready, queue up another call to `play()` for\n    // when it is. This will loop back into this method for another attempt at\n    // playback when the tech is ready.\n    if (!this.isReady_) {\n\n      // Bail out if we're already waiting for `ready`!\n      if (this.playWaitingForReady_) {\n        return;\n      }\n\n      this.playWaitingForReady_ = true;\n      this.ready(function () {\n        _this7.playWaitingForReady_ = false;\n        silencePromise(_this7.play());\n      });\n\n      // If the player/tech is ready and we have a source, we can attempt playback.\n    } else if (!this.changingSrc_ && (this.src() || this.currentSrc())) {\n      return this.techGet_('play');\n\n      // If the tech is ready, but we do not have a source, we'll need to wait\n      // for both the `ready` and a `loadstart` when the source is finally\n      // resolved by middleware and set on the player.\n      //\n      // This can happen if `play()` is called while changing sources or before\n      // one has been set on the player.\n    } else {\n\n      this.playOnLoadstart_ = function () {\n        _this7.playOnLoadstart_ = null;\n        silencePromise(_this7.play());\n      };\n\n      this.one('loadstart', this.playOnLoadstart_);\n    }\n  };\n\n  /**\n   * Pause the video playback\n   *\n   * @return {Player}\n   *         A reference to the player object this function was called on\n   */\n\n\n  Player.prototype.pause = function pause() {\n    this.techCall_('pause');\n  };\n\n  /**\n   * Check if the player is paused or has yet to play\n   *\n   * @return {boolean}\n   *         - false: if the media is currently playing\n   *         - true: if media is not currently playing\n   */\n\n\n  Player.prototype.paused = function paused() {\n    // The initial state of paused should be true (in Safari it's actually false)\n    return this.techGet_('paused') === false ? false : true;\n  };\n\n  /**\n   * Get a TimeRange object representing the current ranges of time that the user\n   * has played.\n   *\n   * @return {TimeRange}\n   *         A time range object that represents all the increments of time that have\n   *         been played.\n   */\n\n\n  Player.prototype.played = function played() {\n    return this.techGet_('played') || createTimeRanges(0, 0);\n  };\n\n  /**\n   * Returns whether or not the user is \"scrubbing\". Scrubbing is\n   * when the user has clicked the progress bar handle and is\n   * dragging it along the progress bar.\n   *\n   * @param {boolean} [isScrubbing]\n   *        whether the user is or is not scrubbing\n   *\n   * @return {boolean}\n   *         The value of scrubbing when getting\n   */\n\n\n  Player.prototype.scrubbing = function scrubbing(isScrubbing) {\n    if (typeof isScrubbing === 'undefined') {\n      return this.scrubbing_;\n    }\n    this.scrubbing_ = !!isScrubbing;\n\n    if (isScrubbing) {\n      this.addClass('vjs-scrubbing');\n    } else {\n      this.removeClass('vjs-scrubbing');\n    }\n  };\n\n  /**\n   * Get or set the current time (in seconds)\n   *\n   * @param {number|string} [seconds]\n   *        The time to seek to in seconds\n   *\n   * @return {number}\n   *         - the current time in seconds when getting\n   */\n\n\n  Player.prototype.currentTime = function currentTime(seconds) {\n    if (typeof seconds !== 'undefined') {\n      if (seconds < 0) {\n        seconds = 0;\n      }\n      this.techCall_('setCurrentTime', seconds);\n      return;\n    }\n\n    // cache last currentTime and return. default to 0 seconds\n    //\n    // Caching the currentTime is meant to prevent a massive amount of reads on the tech's\n    // currentTime when scrubbing, but may not provide much performance benefit afterall.\n    // Should be tested. Also something has to read the actual current time or the cache will\n    // never get updated.\n    this.cache_.currentTime = this.techGet_('currentTime') || 0;\n    return this.cache_.currentTime;\n  };\n\n  /**\n   * Normally gets the length in time of the video in seconds;\n   * in all but the rarest use cases an argument will NOT be passed to the method\n   *\n   * > **NOTE**: The video must have started loading before the duration can be\n   * known, and in the case of Flash, may not be known until the video starts\n   * playing.\n   *\n   * @fires Player#durationchange\n   *\n   * @param {number} [seconds]\n   *        The duration of the video to set in seconds\n   *\n   * @return {number}\n   *         - The duration of the video in seconds when getting\n   */\n\n\n  Player.prototype.duration = function duration(seconds) {\n    if (seconds === undefined) {\n      // return NaN if the duration is not known\n      return this.cache_.duration !== undefined ? this.cache_.duration : NaN;\n    }\n\n    seconds = parseFloat(seconds);\n\n    // Standardize on Infinity for signaling video is live\n    if (seconds < 0) {\n      seconds = Infinity;\n    }\n\n    if (seconds !== this.cache_.duration) {\n      // Cache the last set value for optimized scrubbing (esp. Flash)\n      this.cache_.duration = seconds;\n\n      if (seconds === Infinity) {\n        this.addClass('vjs-live');\n      } else {\n        this.removeClass('vjs-live');\n      }\n      /**\n       * @event Player#durationchange\n       * @type {EventTarget~Event}\n       */\n      this.trigger('durationchange');\n    }\n  };\n\n  /**\n   * Calculates how much time is left in the video. Not part\n   * of the native video API.\n   *\n   * @return {number}\n   *         The time remaining in seconds\n   */\n\n\n  Player.prototype.remainingTime = function remainingTime() {\n    return this.duration() - this.currentTime();\n  };\n\n  /**\n   * A remaining time function that is intented to be used when\n   * the time is to be displayed directly to the user.\n   *\n   * @return {number}\n   *         The rounded time remaining in seconds\n   */\n\n\n  Player.prototype.remainingTimeDisplay = function remainingTimeDisplay() {\n    return Math.floor(this.duration()) - Math.floor(this.currentTime());\n  };\n\n  //\n  // Kind of like an array of portions of the video that have been downloaded.\n\n  /**\n   * Get a TimeRange object with an array of the times of the video\n   * that have been downloaded. If you just want the percent of the\n   * video that's been downloaded, use bufferedPercent.\n   *\n   * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}\n   *\n   * @return {TimeRange}\n   *         A mock TimeRange object (following HTML spec)\n   */\n\n\n  Player.prototype.buffered = function buffered() {\n    var buffered = this.techGet_('buffered');\n\n    if (!buffered || !buffered.length) {\n      buffered = createTimeRanges(0, 0);\n    }\n\n    return buffered;\n  };\n\n  /**\n   * Get the percent (as a decimal) of the video that's been downloaded.\n   * This method is not a part of the native HTML video API.\n   *\n   * @return {number}\n   *         A decimal between 0 and 1 representing the percent\n   *         that is buffered 0 being 0% and 1 being 100%\n   */\n\n\n  Player.prototype.bufferedPercent = function bufferedPercent$$1() {\n    return bufferedPercent(this.buffered(), this.duration());\n  };\n\n  /**\n   * Get the ending time of the last buffered time range\n   * This is used in the progress bar to encapsulate all time ranges.\n   *\n   * @return {number}\n   *         The end of the last buffered time range\n   */\n\n\n  Player.prototype.bufferedEnd = function bufferedEnd() {\n    var buffered = this.buffered();\n    var duration = this.duration();\n    var end = buffered.end(buffered.length - 1);\n\n    if (end > duration) {\n      end = duration;\n    }\n\n    return end;\n  };\n\n  /**\n   * Get or set the current volume of the media\n   *\n   * @param  {number} [percentAsDecimal]\n   *         The new volume as a decimal percent:\n   *         - 0 is muted/0%/off\n   *         - 1.0 is 100%/full\n   *         - 0.5 is half volume or 50%\n   *\n   * @return {number}\n   *         The current volume as a percent when getting\n   */\n\n\n  Player.prototype.volume = function volume(percentAsDecimal) {\n    var vol = void 0;\n\n    if (percentAsDecimal !== undefined) {\n      // Force value to between 0 and 1\n      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));\n      this.cache_.volume = vol;\n      this.techCall_('setVolume', vol);\n\n      if (vol > 0) {\n        this.lastVolume_(vol);\n      }\n\n      return;\n    }\n\n    // Default to 1 when returning current volume.\n    vol = parseFloat(this.techGet_('volume'));\n    return isNaN(vol) ? 1 : vol;\n  };\n\n  /**\n   * Get the current muted state, or turn mute on or off\n   *\n   * @param {boolean} [muted]\n   *        - true to mute\n   *        - false to unmute\n   *\n   * @return {boolean}\n   *         - true if mute is on and getting\n   *         - false if mute is off and getting\n   */\n\n\n  Player.prototype.muted = function muted(_muted) {\n    if (_muted !== undefined) {\n      this.techCall_('setMuted', _muted);\n      return;\n    }\n    return this.techGet_('muted') || false;\n  };\n\n  /**\n   * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted\n   * indicates the state of muted on initial playback.\n   *\n   * ```js\n   *   var myPlayer = videojs('some-player-id');\n   *\n   *   myPlayer.src(\"http://www.example.com/path/to/video.mp4\");\n   *\n   *   // get, should be false\n   *   console.log(myPlayer.defaultMuted());\n   *   // set to true\n   *   myPlayer.defaultMuted(true);\n   *   // get should be true\n   *   console.log(myPlayer.defaultMuted());\n   * ```\n   *\n   * @param {boolean} [defaultMuted]\n   *        - true to mute\n   *        - false to unmute\n   *\n   * @return {boolean|Player}\n   *         - true if defaultMuted is on and getting\n   *         - false if defaultMuted is off and getting\n   *         - A reference to the current player when setting\n   */\n\n\n  Player.prototype.defaultMuted = function defaultMuted(_defaultMuted) {\n    if (_defaultMuted !== undefined) {\n      return this.techCall_('setDefaultMuted', _defaultMuted);\n    }\n    return this.techGet_('defaultMuted') || false;\n  };\n\n  /**\n   * Get the last volume, or set it\n   *\n   * @param  {number} [percentAsDecimal]\n   *         The new last volume as a decimal percent:\n   *         - 0 is muted/0%/off\n   *         - 1.0 is 100%/full\n   *         - 0.5 is half volume or 50%\n   *\n   * @return {number}\n   *         the current value of lastVolume as a percent when getting\n   *\n   * @private\n   */\n\n\n  Player.prototype.lastVolume_ = function lastVolume_(percentAsDecimal) {\n    if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {\n      this.cache_.lastVolume = percentAsDecimal;\n      return;\n    }\n    return this.cache_.lastVolume;\n  };\n\n  /**\n   * Check if current tech can support native fullscreen\n   * (e.g. with built in controls like iOS, so not our flash swf)\n   *\n   * @return {boolean}\n   *         if native fullscreen is supported\n   */\n\n\n  Player.prototype.supportsFullScreen = function supportsFullScreen() {\n    return this.techGet_('supportsFullScreen') || false;\n  };\n\n  /**\n   * Check if the player is in fullscreen mode or tell the player that it\n   * is or is not in fullscreen mode.\n   *\n   * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official\n   * property and instead document.fullscreenElement is used. But isFullscreen is\n   * still a valuable property for internal player workings.\n   *\n   * @param  {boolean} [isFS]\n   *         Set the players current fullscreen state\n   *\n   * @return {boolean}\n   *         - true if fullscreen is on and getting\n   *         - false if fullscreen is off and getting\n   */\n\n\n  Player.prototype.isFullscreen = function isFullscreen(isFS) {\n    if (isFS !== undefined) {\n      this.isFullscreen_ = !!isFS;\n      return;\n    }\n    return !!this.isFullscreen_;\n  };\n\n  /**\n   * Increase the size of the video to full screen\n   * In some browsers, full screen is not supported natively, so it enters\n   * \"full window mode\", where the video fills the browser window.\n   * In browsers and devices that support native full screen, sometimes the\n   * browser's default controls will be shown, and not the Video.js custom skin.\n   * This includes most mobile devices (iOS, Android) and older versions of\n   * Safari.\n   *\n   * @fires Player#fullscreenchange\n   */\n\n\n  Player.prototype.requestFullscreen = function requestFullscreen() {\n    var fsApi = FullscreenApi;\n\n    this.isFullscreen(true);\n\n    if (fsApi.requestFullscreen) {\n      // the browser supports going fullscreen at the element level so we can\n      // take the controls fullscreen as well as the video\n\n      // Trigger fullscreenchange event after change\n      // We have to specifically add this each time, and remove\n      // when canceling fullscreen. Otherwise if there's multiple\n      // players on a page, they would all be reacting to the same fullscreen\n      // events\n      on(global_document__WEBPACK_IMPORTED_MODULE_1___default.a, fsApi.fullscreenchange, bind(this, function documentFullscreenChange(e) {\n        this.isFullscreen(global_document__WEBPACK_IMPORTED_MODULE_1___default.a[fsApi.fullscreenElement]);\n\n        // If cancelling fullscreen, remove event listener.\n        if (this.isFullscreen() === false) {\n          off(global_document__WEBPACK_IMPORTED_MODULE_1___default.a, fsApi.fullscreenchange, documentFullscreenChange);\n        }\n        /**\n         * @event Player#fullscreenchange\n         * @type {EventTarget~Event}\n         */\n        this.trigger('fullscreenchange');\n      }));\n\n      this.el_[fsApi.requestFullscreen]();\n    } else if (this.tech_.supportsFullScreen()) {\n      // we can't take the video.js controls fullscreen but we can go fullscreen\n      // with native controls\n      this.techCall_('enterFullScreen');\n    } else {\n      // fullscreen isn't supported so we'll just stretch the video element to\n      // fill the viewport\n      this.enterFullWindow();\n      /**\n       * @event Player#fullscreenchange\n       * @type {EventTarget~Event}\n       */\n      this.trigger('fullscreenchange');\n    }\n  };\n\n  /**\n   * Return the video to its normal size after having been in full screen mode\n   *\n   * @fires Player#fullscreenchange\n   */\n\n\n  Player.prototype.exitFullscreen = function exitFullscreen() {\n    var fsApi = FullscreenApi;\n\n    this.isFullscreen(false);\n\n    // Check for browser element fullscreen support\n    if (fsApi.requestFullscreen) {\n      global_document__WEBPACK_IMPORTED_MODULE_1___default.a[fsApi.exitFullscreen]();\n    } else if (this.tech_.supportsFullScreen()) {\n      this.techCall_('exitFullScreen');\n    } else {\n      this.exitFullWindow();\n      /**\n       * @event Player#fullscreenchange\n       * @type {EventTarget~Event}\n       */\n      this.trigger('fullscreenchange');\n    }\n  };\n\n  /**\n   * When fullscreen isn't supported we can stretch the\n   * video container to as wide as the browser will let us.\n   *\n   * @fires Player#enterFullWindow\n   */\n\n\n  Player.prototype.enterFullWindow = function enterFullWindow() {\n    this.isFullWindow = true;\n\n    // Storing original doc overflow value to return to when fullscreen is off\n    this.docOrigOverflow = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.documentElement.style.overflow;\n\n    // Add listener for esc key to exit fullscreen\n    on(global_document__WEBPACK_IMPORTED_MODULE_1___default.a, 'keydown', bind(this, this.fullWindowOnEscKey));\n\n    // Hide any scroll bars\n    global_document__WEBPACK_IMPORTED_MODULE_1___default.a.documentElement.style.overflow = 'hidden';\n\n    // Apply fullscreen styles\n    addClass(global_document__WEBPACK_IMPORTED_MODULE_1___default.a.body, 'vjs-full-window');\n\n    /**\n     * @event Player#enterFullWindow\n     * @type {EventTarget~Event}\n     */\n    this.trigger('enterFullWindow');\n  };\n\n  /**\n   * Check for call to either exit full window or\n   * full screen on ESC key\n   *\n   * @param {string} event\n   *        Event to check for key press\n   */\n\n\n  Player.prototype.fullWindowOnEscKey = function fullWindowOnEscKey(event) {\n    if (event.keyCode === 27) {\n      if (this.isFullscreen() === true) {\n        this.exitFullscreen();\n      } else {\n        this.exitFullWindow();\n      }\n    }\n  };\n\n  /**\n   * Exit full window\n   *\n   * @fires Player#exitFullWindow\n   */\n\n\n  Player.prototype.exitFullWindow = function exitFullWindow() {\n    this.isFullWindow = false;\n    off(global_document__WEBPACK_IMPORTED_MODULE_1___default.a, 'keydown', this.fullWindowOnEscKey);\n\n    // Unhide scroll bars.\n    global_document__WEBPACK_IMPORTED_MODULE_1___default.a.documentElement.style.overflow = this.docOrigOverflow;\n\n    // Remove fullscreen styles\n    removeClass(global_document__WEBPACK_IMPORTED_MODULE_1___default.a.body, 'vjs-full-window');\n\n    // Resize the box, controller, and poster to original sizes\n    // this.positionAll();\n    /**\n     * @event Player#exitFullWindow\n     * @type {EventTarget~Event}\n     */\n    this.trigger('exitFullWindow');\n  };\n\n  /**\n   * Check whether the player can play a given mimetype\n   *\n   * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype\n   *\n   * @param {string} type\n   *        The mimetype to check\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */\n\n\n  Player.prototype.canPlayType = function canPlayType(type) {\n    var can = void 0;\n\n    // Loop through each playback technology in the options order\n    for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {\n      var techName = j[i];\n      var tech = Tech.getTech(techName);\n\n      // Support old behavior of techs being registered as components.\n      // Remove once that deprecated behavior is removed.\n      if (!tech) {\n        tech = Component.getComponent(techName);\n      }\n\n      // Check if the current tech is defined before continuing\n      if (!tech) {\n        log$1.error('The \"' + techName + '\" tech is undefined. Skipped browser support check for that tech.');\n        continue;\n      }\n\n      // Check if the browser supports this technology\n      if (tech.isSupported()) {\n        can = tech.canPlayType(type);\n\n        if (can) {\n          return can;\n        }\n      }\n    }\n\n    return '';\n  };\n\n  /**\n   * Select source based on tech-order or source-order\n   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,\n   * defaults to tech-order selection\n   *\n   * @param {Array} sources\n   *        The sources for a media asset\n   *\n   * @return {Object|boolean}\n   *         Object of source and tech order or false\n   */\n\n\n  Player.prototype.selectSource = function selectSource(sources) {\n    var _this8 = this;\n\n    // Get only the techs specified in `techOrder` that exist and are supported by the\n    // current platform\n    var techs = this.options_.techOrder.map(function (techName) {\n      return [techName, Tech.getTech(techName)];\n    }).filter(function (_ref) {\n      var techName = _ref[0],\n          tech = _ref[1];\n\n      // Check if the current tech is defined before continuing\n      if (tech) {\n        // Check if the browser supports this technology\n        return tech.isSupported();\n      }\n\n      log$1.error('The \"' + techName + '\" tech is undefined. Skipped browser support check for that tech.');\n      return false;\n    });\n\n    // Iterate over each `innerArray` element once per `outerArray` element and execute\n    // `tester` with both. If `tester` returns a non-falsy value, exit early and return\n    // that value.\n    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair(outerArray, innerArray, tester) {\n      var found = void 0;\n\n      outerArray.some(function (outerChoice) {\n        return innerArray.some(function (innerChoice) {\n          found = tester(outerChoice, innerChoice);\n\n          if (found) {\n            return true;\n          }\n        });\n      });\n\n      return found;\n    };\n\n    var foundSourceAndTech = void 0;\n    var flip = function flip(fn) {\n      return function (a, b) {\n        return fn(b, a);\n      };\n    };\n    var finder = function finder(_ref2, source) {\n      var techName = _ref2[0],\n          tech = _ref2[1];\n\n      if (tech.canPlaySource(source, _this8.options_[techName.toLowerCase()])) {\n        return { source: source, tech: techName };\n      }\n    };\n\n    // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources\n    // to select from them based on their priority.\n    if (this.options_.sourceOrder) {\n      // Source-first ordering\n      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));\n    } else {\n      // Tech-first ordering\n      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);\n    }\n\n    return foundSourceAndTech || false;\n  };\n\n  /**\n   * Get or set the video source.\n   *\n   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]\n   *        A SourceObject, an array of SourceObjects, or a string referencing\n   *        a URL to a media source. It is _highly recommended_ that an object\n   *        or array of objects is used here, so that source selection\n   *        algorithms can take the `type` into account.\n   *\n   *        If not provided, this method acts as a getter.\n   *\n   * @return {string|undefined}\n   *         If the `source` argument is missing, returns the current source\n   *         URL. Otherwise, returns nothing/undefined.\n   */\n\n\n  Player.prototype.src = function src(source) {\n    var _this9 = this;\n\n    // getter usage\n    if (typeof source === 'undefined') {\n      return this.cache_.src || '';\n    }\n    // filter out invalid sources and turn our source into\n    // an array of source objects\n    var sources = filterSource(source);\n\n    // if a source was passed in then it is invalid because\n    // it was filtered to a zero length Array. So we have to\n    // show an error\n    if (!sources.length) {\n      this.setTimeout(function () {\n        this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });\n      }, 0);\n      return;\n    }\n\n    // intial sources\n    this.changingSrc_ = true;\n\n    this.cache_.sources = sources;\n    this.updateSourceCaches_(sources[0]);\n\n    // middlewareSource is the source after it has been changed by middleware\n    setSource(this, sources[0], function (middlewareSource, mws) {\n      _this9.middleware_ = mws;\n\n      // since sourceSet is async we have to update the cache again after we select a source since\n      // the source that is selected could be out of order from the cache update above this callback.\n      _this9.cache_.sources = sources;\n      _this9.updateSourceCaches_(middlewareSource);\n\n      var err = _this9.src_(middlewareSource);\n\n      if (err) {\n        if (sources.length > 1) {\n          return _this9.src(sources.slice(1));\n        }\n\n        _this9.changingSrc_ = false;\n\n        // We need to wrap this in a timeout to give folks a chance to add error event handlers\n        _this9.setTimeout(function () {\n          this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });\n        }, 0);\n\n        // we could not find an appropriate tech, but let's still notify the delegate that this is it\n        // this needs a better comment about why this is needed\n        _this9.triggerReady();\n\n        return;\n      }\n\n      setTech(mws, _this9.tech_);\n    });\n  };\n\n  /**\n   * Set the source object on the tech, returns a boolean that indicates whether\n   * there is a tech that can play the source or not\n   *\n   * @param {Tech~SourceObject} source\n   *        The source object to set on the Tech\n   *\n   * @return {Boolean}\n   *         - True if there is no Tech to playback this source\n   *         - False otherwise\n   *\n   * @private\n   */\n\n\n  Player.prototype.src_ = function src_(source) {\n    var _this10 = this;\n\n    var sourceTech = this.selectSource([source]);\n\n    if (!sourceTech) {\n      return true;\n    }\n\n    if (!titleCaseEquals(sourceTech.tech, this.techName_)) {\n      this.changingSrc_ = true;\n      // load this technology with the chosen source\n      this.loadTech_(sourceTech.tech, sourceTech.source);\n      this.tech_.ready(function () {\n        _this10.changingSrc_ = false;\n      });\n      return false;\n    }\n\n    // wait until the tech is ready to set the source\n    // and set it synchronously if possible (#2326)\n    this.ready(function () {\n\n      // The setSource tech method was added with source handlers\n      // so older techs won't support it\n      // We need to check the direct prototype for the case where subclasses\n      // of the tech do not support source handlers\n      if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {\n        this.techCall_('setSource', source);\n      } else {\n        this.techCall_('src', source.src);\n      }\n\n      this.changingSrc_ = false;\n    }, true);\n\n    return false;\n  };\n\n  /**\n   * Begin loading the src data.\n   */\n\n\n  Player.prototype.load = function load() {\n    this.techCall_('load');\n  };\n\n  /**\n   * Reset the player. Loads the first tech in the techOrder,\n   * and calls `reset` on the tech`.\n   */\n\n\n  Player.prototype.reset = function reset() {\n    this.loadTech_(this.options_.techOrder[0], null);\n    this.techCall_('reset');\n  };\n\n  /**\n   * Returns all of the current source objects.\n   *\n   * @return {Tech~SourceObject[]}\n   *         The current source objects\n   */\n\n\n  Player.prototype.currentSources = function currentSources() {\n    var source = this.currentSource();\n    var sources = [];\n\n    // assume `{}` or `{ src }`\n    if (Object.keys(source).length !== 0) {\n      sources.push(source);\n    }\n\n    return this.cache_.sources || sources;\n  };\n\n  /**\n   * Returns the current source object.\n   *\n   * @return {Tech~SourceObject}\n   *         The current source object\n   */\n\n\n  Player.prototype.currentSource = function currentSource() {\n    return this.cache_.source || {};\n  };\n\n  /**\n   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4\n   * Can be used in conjunction with `currentType` to assist in rebuilding the current source object.\n   *\n   * @return {string}\n   *         The current source\n   */\n\n\n  Player.prototype.currentSrc = function currentSrc() {\n    return this.currentSource() && this.currentSource().src || '';\n  };\n\n  /**\n   * Get the current source type e.g. video/mp4\n   * This can allow you rebuild the current source object so that you could load the same\n   * source and tech later\n   *\n   * @return {string}\n   *         The source MIME type\n   */\n\n\n  Player.prototype.currentType = function currentType() {\n    return this.currentSource() && this.currentSource().type || '';\n  };\n\n  /**\n   * Get or set the preload attribute\n   *\n   * @param {boolean} [value]\n   *        - true means that we should preload\n   *        - false means that we should not preload\n   *\n   * @return {string}\n   *         The preload attribute value when getting\n   */\n\n\n  Player.prototype.preload = function preload(value) {\n    if (value !== undefined) {\n      this.techCall_('setPreload', value);\n      this.options_.preload = value;\n      return;\n    }\n    return this.techGet_('preload');\n  };\n\n  /**\n   * Get or set the autoplay option. When this is a boolean it will\n   * modify the attribute on the tech. When this is a string the attribute on\n   * the tech will be removed and `Player` will handle autoplay on loadstarts.\n   *\n   * @param {boolean|string} [value]\n   *        - true: autoplay using the browser behavior\n   *        - false: do not autoplay\n   *        - 'play': call play() on every loadstart\n   *        - 'muted': call muted() then play() on every loadstart\n   *        - 'any': call play() on every loadstart. if that fails call muted() then play().\n   *        - *: values other than those listed here will be set `autoplay` to true\n   *\n   * @return {boolean|string}\n   *         The current value of autoplay when getting\n   */\n\n\n  Player.prototype.autoplay = function autoplay(value) {\n    // getter usage\n    if (value === undefined) {\n      return this.options_.autoplay || false;\n    }\n\n    var techAutoplay = void 0;\n\n    // if the value is a valid string set it to that\n    if (typeof value === 'string' && /(any|play|muted)/.test(value)) {\n      this.options_.autoplay = value;\n      this.manualAutoplay_(value);\n      techAutoplay = false;\n\n      // any falsy value sets autoplay to false in the browser,\n      // lets do the same\n    } else if (!value) {\n      this.options_.autoplay = false;\n\n      // any other value (ie truthy) sets autoplay to true\n    } else {\n      this.options_.autoplay = true;\n    }\n\n    techAutoplay = techAutoplay || this.options_.autoplay;\n\n    // if we don't have a tech then we do not queue up\n    // a setAutoplay call on tech ready. We do this because the\n    // autoplay option will be passed in the constructor and we\n    // do not need to set it twice\n    if (this.tech_) {\n      this.techCall_('setAutoplay', techAutoplay);\n    }\n  };\n\n  /**\n   * Set or unset the playsinline attribute.\n   * Playsinline tells the browser that non-fullscreen playback is preferred.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should try to play inline by default\n   *        - false means that we should use the browser's default playback mode,\n   *          which in most cases is inline. iOS Safari is a notable exception\n   *          and plays fullscreen by default.\n   *\n   * @return {string|Player}\n   *         - the current value of playsinline\n   *         - the player when setting\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n   */\n\n\n  Player.prototype.playsinline = function playsinline(value) {\n    if (value !== undefined) {\n      this.techCall_('setPlaysinline', value);\n      this.options_.playsinline = value;\n      return this;\n    }\n    return this.techGet_('playsinline');\n  };\n\n  /**\n   * Get or set the loop attribute on the video element.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should loop the video\n   *        - false means that we should not loop the video\n   *\n   * @return {string}\n   *         The current value of loop when getting\n   */\n\n\n  Player.prototype.loop = function loop(value) {\n    if (value !== undefined) {\n      this.techCall_('setLoop', value);\n      this.options_.loop = value;\n      return;\n    }\n    return this.techGet_('loop');\n  };\n\n  /**\n   * Get or set the poster image source url\n   *\n   * @fires Player#posterchange\n   *\n   * @param {string} [src]\n   *        Poster image source URL\n   *\n   * @return {string}\n   *         The current value of poster when getting\n   */\n\n\n  Player.prototype.poster = function poster(src) {\n    if (src === undefined) {\n      return this.poster_;\n    }\n\n    // The correct way to remove a poster is to set as an empty string\n    // other falsey values will throw errors\n    if (!src) {\n      src = '';\n    }\n\n    if (src === this.poster_) {\n      return;\n    }\n\n    // update the internal poster variable\n    this.poster_ = src;\n\n    // update the tech's poster\n    this.techCall_('setPoster', src);\n\n    this.isPosterFromTech_ = false;\n\n    // alert components that the poster has been set\n    /**\n     * This event fires when the poster image is changed on the player.\n     *\n     * @event Player#posterchange\n     * @type {EventTarget~Event}\n     */\n    this.trigger('posterchange');\n  };\n\n  /**\n   * Some techs (e.g. YouTube) can provide a poster source in an\n   * asynchronous way. We want the poster component to use this\n   * poster source so that it covers up the tech's controls.\n   * (YouTube's play button). However we only want to use this\n   * source if the player user hasn't set a poster through\n   * the normal APIs.\n   *\n   * @fires Player#posterchange\n   * @listens Tech#posterchange\n   * @private\n   */\n\n\n  Player.prototype.handleTechPosterChange_ = function handleTechPosterChange_() {\n    if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {\n      var newPoster = this.tech_.poster() || '';\n\n      if (newPoster !== this.poster_) {\n        this.poster_ = newPoster;\n        this.isPosterFromTech_ = true;\n\n        // Let components know the poster has changed\n        this.trigger('posterchange');\n      }\n    }\n  };\n\n  /**\n   * Get or set whether or not the controls are showing.\n   *\n   * @fires Player#controlsenabled\n   *\n   * @param {boolean} [bool]\n   *        - true to turn controls on\n   *        - false to turn controls off\n   *\n   * @return {boolean}\n   *         The current value of controls when getting\n   */\n\n\n  Player.prototype.controls = function controls(bool) {\n    if (bool === undefined) {\n      return !!this.controls_;\n    }\n\n    bool = !!bool;\n\n    // Don't trigger a change event unless it actually changed\n    if (this.controls_ === bool) {\n      return;\n    }\n\n    this.controls_ = bool;\n\n    if (this.usingNativeControls()) {\n      this.techCall_('setControls', bool);\n    }\n\n    if (this.controls_) {\n      this.removeClass('vjs-controls-disabled');\n      this.addClass('vjs-controls-enabled');\n      /**\n       * @event Player#controlsenabled\n       * @type {EventTarget~Event}\n       */\n      this.trigger('controlsenabled');\n      if (!this.usingNativeControls()) {\n        this.addTechControlsListeners_();\n      }\n    } else {\n      this.removeClass('vjs-controls-enabled');\n      this.addClass('vjs-controls-disabled');\n      /**\n       * @event Player#controlsdisabled\n       * @type {EventTarget~Event}\n       */\n      this.trigger('controlsdisabled');\n      if (!this.usingNativeControls()) {\n        this.removeTechControlsListeners_();\n      }\n    }\n  };\n\n  /**\n   * Toggle native controls on/off. Native controls are the controls built into\n   * devices (e.g. default iPhone controls), Flash, or other techs\n   * (e.g. Vimeo Controls)\n   * **This should only be set by the current tech, because only the tech knows\n   * if it can support native controls**\n   *\n   * @fires Player#usingnativecontrols\n   * @fires Player#usingcustomcontrols\n   *\n   * @param {boolean} [bool]\n   *        - true to turn native controls on\n   *        - false to turn native controls off\n   *\n   * @return {boolean}\n   *         The current value of native controls when getting\n   */\n\n\n  Player.prototype.usingNativeControls = function usingNativeControls(bool) {\n    if (bool === undefined) {\n      return !!this.usingNativeControls_;\n    }\n\n    bool = !!bool;\n\n    // Don't trigger a change event unless it actually changed\n    if (this.usingNativeControls_ === bool) {\n      return;\n    }\n\n    this.usingNativeControls_ = bool;\n\n    if (this.usingNativeControls_) {\n      this.addClass('vjs-using-native-controls');\n\n      /**\n       * player is using the native device controls\n       *\n       * @event Player#usingnativecontrols\n       * @type {EventTarget~Event}\n       */\n      this.trigger('usingnativecontrols');\n    } else {\n      this.removeClass('vjs-using-native-controls');\n\n      /**\n       * player is using the custom HTML controls\n       *\n       * @event Player#usingcustomcontrols\n       * @type {EventTarget~Event}\n       */\n      this.trigger('usingcustomcontrols');\n    }\n  };\n\n  /**\n   * Set or get the current MediaError\n   *\n   * @fires Player#error\n   *\n   * @param  {MediaError|string|number} [err]\n   *         A MediaError or a string/number to be turned\n   *         into a MediaError\n   *\n   * @return {MediaError|null}\n   *         The current MediaError when getting (or null)\n   */\n\n\n  Player.prototype.error = function error(err) {\n    if (err === undefined) {\n      return this.error_ || null;\n    }\n\n    // restoring to default\n    if (err === null) {\n      this.error_ = err;\n      this.removeClass('vjs-error');\n      if (this.errorDisplay) {\n        this.errorDisplay.close();\n      }\n      return;\n    }\n\n    this.error_ = new MediaError(err);\n\n    // add the vjs-error classname to the player\n    this.addClass('vjs-error');\n\n    // log the name of the error type and any message\n    // IE11 logs \"[object object]\" and required you to expand message to see error object\n    log$1.error('(CODE:' + this.error_.code + ' ' + MediaError.errorTypes[this.error_.code] + ')', this.error_.message, this.error_);\n\n    /**\n     * @event Player#error\n     * @type {EventTarget~Event}\n     */\n    this.trigger('error');\n\n    return;\n  };\n\n  /**\n   * Report user activity\n   *\n   * @param {Object} event\n   *        Event object\n   */\n\n\n  Player.prototype.reportUserActivity = function reportUserActivity(event) {\n    this.userActivity_ = true;\n  };\n\n  /**\n   * Get/set if user is active\n   *\n   * @fires Player#useractive\n   * @fires Player#userinactive\n   *\n   * @param {boolean} [bool]\n   *        - true if the user is active\n   *        - false if the user is inactive\n   *\n   * @return {boolean}\n   *         The current value of userActive when getting\n   */\n\n\n  Player.prototype.userActive = function userActive(bool) {\n    if (bool === undefined) {\n      return this.userActive_;\n    }\n\n    bool = !!bool;\n\n    if (bool === this.userActive_) {\n      return;\n    }\n\n    this.userActive_ = bool;\n\n    if (this.userActive_) {\n      this.userActivity_ = true;\n      this.removeClass('vjs-user-inactive');\n      this.addClass('vjs-user-active');\n      /**\n       * @event Player#useractive\n       * @type {EventTarget~Event}\n       */\n      this.trigger('useractive');\n      return;\n    }\n\n    // Chrome/Safari/IE have bugs where when you change the cursor it can\n    // trigger a mousemove event. This causes an issue when you're hiding\n    // the cursor when the user is inactive, and a mousemove signals user\n    // activity. Making it impossible to go into inactive mode. Specifically\n    // this happens in fullscreen when we really need to hide the cursor.\n    //\n    // When this gets resolved in ALL browsers it can be removed\n    // https://code.google.com/p/chromium/issues/detail?id=103041\n    if (this.tech_) {\n      this.tech_.one('mousemove', function (e) {\n        e.stopPropagation();\n        e.preventDefault();\n      });\n    }\n\n    this.userActivity_ = false;\n    this.removeClass('vjs-user-active');\n    this.addClass('vjs-user-inactive');\n    /**\n     * @event Player#userinactive\n     * @type {EventTarget~Event}\n     */\n    this.trigger('userinactive');\n  };\n\n  /**\n   * Listen for user activity based on timeout value\n   *\n   * @private\n   */\n\n\n  Player.prototype.listenForUserActivity_ = function listenForUserActivity_() {\n    var mouseInProgress = void 0;\n    var lastMoveX = void 0;\n    var lastMoveY = void 0;\n    var handleActivity = bind(this, this.reportUserActivity);\n\n    var handleMouseMove = function handleMouseMove(e) {\n      // #1068 - Prevent mousemove spamming\n      // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970\n      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {\n        lastMoveX = e.screenX;\n        lastMoveY = e.screenY;\n        handleActivity();\n      }\n    };\n\n    var handleMouseDown = function handleMouseDown() {\n      handleActivity();\n      // For as long as the they are touching the device or have their mouse down,\n      // we consider them active even if they're not moving their finger or mouse.\n      // So we want to continue to update that they are active\n      this.clearInterval(mouseInProgress);\n      // Setting userActivity=true now and setting the interval to the same time\n      // as the activityCheck interval (250) should ensure we never miss the\n      // next activityCheck\n      mouseInProgress = this.setInterval(handleActivity, 250);\n    };\n\n    var handleMouseUp = function handleMouseUp(event) {\n      handleActivity();\n      // Stop the interval that maintains activity if the mouse/touch is down\n      this.clearInterval(mouseInProgress);\n    };\n\n    // Any mouse movement will be considered user activity\n    this.on('mousedown', handleMouseDown);\n    this.on('mousemove', handleMouseMove);\n    this.on('mouseup', handleMouseUp);\n\n    // Listen for keyboard navigation\n    // Shouldn't need to use inProgress interval because of key repeat\n    this.on('keydown', handleActivity);\n    this.on('keyup', handleActivity);\n\n    // Run an interval every 250 milliseconds instead of stuffing everything into\n    // the mousemove/touchmove function itself, to prevent performance degradation.\n    // `this.reportUserActivity` simply sets this.userActivity_ to true, which\n    // then gets picked up by this loop\n    // http://ejohn.org/blog/learning-from-twitter/\n    var inactivityTimeout = void 0;\n\n    this.setInterval(function () {\n      // Check to see if mouse/touch activity has happened\n      if (!this.userActivity_) {\n        return;\n      }\n\n      // Reset the activity tracker\n      this.userActivity_ = false;\n\n      // If the user state was inactive, set the state to active\n      this.userActive(true);\n\n      // Clear any existing inactivity timeout to start the timer over\n      this.clearTimeout(inactivityTimeout);\n\n      var timeout = this.options_.inactivityTimeout;\n\n      if (timeout <= 0) {\n        return;\n      }\n\n      // In <timeout> milliseconds, if no more activity has occurred the\n      // user will be considered inactive\n      inactivityTimeout = this.setTimeout(function () {\n        // Protect against the case where the inactivityTimeout can trigger just\n        // before the next user activity is picked up by the activity check loop\n        // causing a flicker\n        if (!this.userActivity_) {\n          this.userActive(false);\n        }\n      }, timeout);\n    }, 250);\n  };\n\n  /**\n   * Gets or sets the current playback rate. A playback rate of\n   * 1.0 represents normal speed and 0.5 would indicate half-speed\n   * playback, for instance.\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate\n   *\n   * @param {number} [rate]\n   *       New playback rate to set.\n   *\n   * @return {number}\n   *         The current playback rate when getting or 1.0\n   */\n\n\n  Player.prototype.playbackRate = function playbackRate(rate) {\n    if (rate !== undefined) {\n      // NOTE: this.cache_.lastPlaybackRate is set from the tech handler\n      // that is registered above\n      this.techCall_('setPlaybackRate', rate);\n      return;\n    }\n\n    if (this.tech_ && this.tech_.featuresPlaybackRate) {\n      return this.cache_.lastPlaybackRate || this.techGet_('playbackRate');\n    }\n    return 1.0;\n  };\n\n  /**\n   * Gets or sets the current default playback rate. A default playback rate of\n   * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.\n   * defaultPlaybackRate will only represent what the initial playbackRate of a video was, not\n   * not the current playbackRate.\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate\n   *\n   * @param {number} [rate]\n   *       New default playback rate to set.\n   *\n   * @return {number|Player}\n   *         - The default playback rate when getting or 1.0\n   *         - the player when setting\n   */\n\n\n  Player.prototype.defaultPlaybackRate = function defaultPlaybackRate(rate) {\n    if (rate !== undefined) {\n      return this.techCall_('setDefaultPlaybackRate', rate);\n    }\n\n    if (this.tech_ && this.tech_.featuresPlaybackRate) {\n      return this.techGet_('defaultPlaybackRate');\n    }\n    return 1.0;\n  };\n\n  /**\n   * Gets or sets the audio flag\n   *\n   * @param {boolean} bool\n   *        - true signals that this is an audio player\n   *        - false signals that this is not an audio player\n   *\n   * @return {boolean}\n   *         The current value of isAudio when getting\n   */\n\n\n  Player.prototype.isAudio = function isAudio(bool) {\n    if (bool !== undefined) {\n      this.isAudio_ = !!bool;\n      return;\n    }\n\n    return !!this.isAudio_;\n  };\n\n  /**\n   * A helper method for adding a {@link TextTrack} to our\n   * {@link TextTrackList}.\n   *\n   * In addition to the W3C settings we allow adding additional info through options.\n   *\n   * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack\n   *\n   * @param {string} [kind]\n   *        the kind of TextTrack you are adding\n   *\n   * @param {string} [label]\n   *        the label to give the TextTrack label\n   *\n   * @param {string} [language]\n   *        the language to set on the TextTrack\n   *\n   * @return {TextTrack|undefined}\n   *         the TextTrack that was added or undefined\n   *         if there is no tech\n   */\n\n\n  Player.prototype.addTextTrack = function addTextTrack(kind, label, language) {\n    if (this.tech_) {\n      return this.tech_.addTextTrack(kind, label, language);\n    }\n  };\n\n  /**\n   * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}. It will\n   * automatically removed from the video element whenever the source changes, unless\n   * manualCleanup is set to false.\n   *\n   * @param {Object} options\n   *        Options to pass to {@link HTMLTrackElement} during creation. See\n   *        {@link HTMLTrackElement} for object properties that you should use.\n   *\n   * @param {boolean} [manualCleanup=true] if set to false, the TextTrack will be\n   *\n   * @return {HtmlTrackElement}\n   *         the HTMLTrackElement that was created and added\n   *         to the HtmlTrackElementList and the remote\n   *         TextTrackList\n   *\n   * @deprecated The default value of the \"manualCleanup\" parameter will default\n   *             to \"false\" in upcoming versions of Video.js\n   */\n\n\n  Player.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {\n    if (this.tech_) {\n      return this.tech_.addRemoteTextTrack(options, manualCleanup);\n    }\n  };\n\n  /**\n   * Remove a remote {@link TextTrack} from the respective\n   * {@link TextTrackList} and {@link HtmlTrackElementList}.\n   *\n   * @param {Object} track\n   *        Remote {@link TextTrack} to remove\n   *\n   * @return {undefined}\n   *         does not return anything\n   */\n\n\n  Player.prototype.removeRemoteTextTrack = function removeRemoteTextTrack() {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$track = _ref3.track,\n        track = _ref3$track === undefined ? arguments[0] : _ref3$track;\n\n    // destructure the input into an object with a track argument, defaulting to arguments[0]\n    // default the whole argument to an empty object if nothing was passed in\n\n    if (this.tech_) {\n      return this.tech_.removeRemoteTextTrack(track);\n    }\n  };\n\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object|undefined}\n   *         An object with supported media playback quality metrics or undefined if there\n   *         is no tech or the tech does not support it.\n   */\n\n\n  Player.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    return this.techGet_('getVideoPlaybackQuality');\n  };\n\n  /**\n   * Get video width\n   *\n   * @return {number}\n   *         current video width\n   */\n\n\n  Player.prototype.videoWidth = function videoWidth() {\n    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;\n  };\n\n  /**\n   * Get video height\n   *\n   * @return {number}\n   *         current video height\n   */\n\n\n  Player.prototype.videoHeight = function videoHeight() {\n    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;\n  };\n\n  /**\n   * The player's language code\n   * NOTE: The language should be set in the player options if you want the\n   * the controls to be built with a specific language. Changing the language\n   * later will not update controls text.\n   *\n   * @param {string} [code]\n   *        the language code to set the player to\n   *\n   * @return {string}\n   *         The current language code when getting\n   */\n\n\n  Player.prototype.language = function language(code) {\n    if (code === undefined) {\n      return this.language_;\n    }\n\n    this.language_ = String(code).toLowerCase();\n  };\n\n  /**\n   * Get the player's language dictionary\n   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time\n   * Languages specified directly in the player options have precedence\n   *\n   * @return {Array}\n   *         An array of of supported languages\n   */\n\n\n  Player.prototype.languages = function languages() {\n    return mergeOptions(Player.prototype.options_.languages, this.languages_);\n  };\n\n  /**\n   * returns a JavaScript object reperesenting the current track\n   * information. **DOES not return it as JSON**\n   *\n   * @return {Object}\n   *         Object representing the current of track info\n   */\n\n\n  Player.prototype.toJSON = function toJSON() {\n    var options = mergeOptions(this.options_);\n    var tracks = options.tracks;\n\n    options.tracks = [];\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      // deep merge tracks and null out player so no circular references\n      track = mergeOptions(track);\n      track.player = undefined;\n      options.tracks[i] = track;\n    }\n\n    return options;\n  };\n\n  /**\n   * Creates a simple modal dialog (an instance of the {@link ModalDialog}\n   * component) that immediately overlays the player with arbitrary\n   * content and removes itself when closed.\n   *\n   * @param {string|Function|Element|Array|null} content\n   *        Same as {@link ModalDialog#content}'s param of the same name.\n   *        The most straight-forward usage is to provide a string or DOM\n   *        element.\n   *\n   * @param {Object} [options]\n   *        Extra options which will be passed on to the {@link ModalDialog}.\n   *\n   * @return {ModalDialog}\n   *         the {@link ModalDialog} that was created\n   */\n\n\n  Player.prototype.createModal = function createModal(content, options) {\n    var _this11 = this;\n\n    options = options || {};\n    options.content = content || '';\n\n    var modal = new ModalDialog(this, options);\n\n    this.addChild(modal);\n    modal.on('dispose', function () {\n      _this11.removeChild(modal);\n    });\n\n    modal.open();\n    return modal;\n  };\n\n  /**\n   * Gets tag settings\n   *\n   * @param {Element} tag\n   *        The player tag\n   *\n   * @return {Object}\n   *         An object containing all of the settings\n   *         for a player tag\n   */\n\n\n  Player.getTagSettings = function getTagSettings(tag) {\n    var baseOptions = {\n      sources: [],\n      tracks: []\n    };\n\n    var tagOptions = getAttributes(tag);\n    var dataSetup = tagOptions['data-setup'];\n\n    if (hasClass(tag, 'vjs-fluid')) {\n      tagOptions.fluid = true;\n    }\n\n    // Check if data-setup attr exists.\n    if (dataSetup !== null) {\n      // Parse options JSON\n      // If empty string, make it a parsable json object.\n      var _safeParseTuple = safe_json_parse_tuple__WEBPACK_IMPORTED_MODULE_5___default()(dataSetup || '{}'),\n          err = _safeParseTuple[0],\n          data = _safeParseTuple[1];\n\n      if (err) {\n        log$1.error(err);\n      }\n      assign(tagOptions, data);\n    }\n\n    assign(baseOptions, tagOptions);\n\n    // Get tag children settings\n    if (tag.hasChildNodes()) {\n      var children = tag.childNodes;\n\n      for (var i = 0, j = children.length; i < j; i++) {\n        var child = children[i];\n        // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/\n        var childName = child.nodeName.toLowerCase();\n\n        if (childName === 'source') {\n          baseOptions.sources.push(getAttributes(child));\n        } else if (childName === 'track') {\n          baseOptions.tracks.push(getAttributes(child));\n        }\n      }\n    }\n\n    return baseOptions;\n  };\n\n  /**\n   * Determine whether or not flexbox is supported\n   *\n   * @return {boolean}\n   *         - true if flexbox is supported\n   *         - false if flexbox is not supported\n   */\n\n\n  Player.prototype.flexNotSupported_ = function flexNotSupported_() {\n    var elem = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('i');\n\n    // Note: We don't actually use flexBasis (or flexOrder), but it's one of the more\n    // common flex features that we can rely on when checking for flex support.\n    return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style ||\n    // IE10-specific (2012 flex spec), available for completeness\n    'msFlexOrder' in elem.style);\n  };\n\n  return Player;\n}(Component);\n\n/**\n * Get the {@link VideoTrackList}\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist\n *\n * @return {VideoTrackList}\n *         the current video track list\n *\n * @method Player.prototype.videoTracks\n */\n\n/**\n * Get the {@link AudioTrackList}\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist\n *\n * @return {AudioTrackList}\n *         the current audio track list\n *\n * @method Player.prototype.audioTracks\n */\n\n/**\n * Get the {@link TextTrackList}\n *\n * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks\n *\n * @return {TextTrackList}\n *         the current text track list\n *\n * @method Player.prototype.textTracks\n */\n\n/**\n * Get the remote {@link TextTrackList}\n *\n * @return {TextTrackList}\n *         The current remote text track list\n *\n * @method Player.prototype.remoteTextTracks\n */\n\n/**\n * Get the remote {@link HtmlTrackElementList} tracks.\n *\n * @return {HtmlTrackElementList}\n *         The current remote text track element list\n *\n * @method Player.prototype.remoteTextTrackEls\n */\n\nALL.names.forEach(function (name$$1) {\n  var props = ALL[name$$1];\n\n  Player.prototype[props.getterName] = function () {\n    if (this.tech_) {\n      return this.tech_[props.getterName]();\n    }\n\n    // if we have not yet loadTech_, we create {video,audio,text}Tracks_\n    // these will be passed to the tech during loading\n    this[props.privateName] = this[props.privateName] || new props.ListClass();\n    return this[props.privateName];\n  };\n});\n\n/**\n * Global player list\n *\n * @type {Object}\n */\nPlayer.players = {};\n\nvar navigator = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.navigator;\n\n/*\n * Player instance options, surfaced using options\n * options = Player.prototype.options_\n * Make changes in options, not here.\n *\n * @type {Object}\n * @private\n */\nPlayer.prototype.options_ = {\n  // Default order of fallback technology\n  techOrder: Tech.defaultTechOrder_,\n\n  html5: {},\n  flash: {},\n\n  // default inactivity timeout\n  inactivityTimeout: 2000,\n\n  // default playback rates\n  playbackRates: [],\n  // Add playback rate selection by adding rates\n  // 'playbackRates': [0.5, 1, 1.5, 2],\n\n  // Included control sets\n  children: ['mediaLoader', 'posterImage', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'controlBar', 'errorDisplay', 'textTrackSettings', 'resizeManager'],\n\n  language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || 'en',\n\n  // locales and their language translations\n  languages: {},\n\n  // Default message to show when a video cannot be played.\n  notSupportedMessage: 'No compatible source was found for this media.'\n};\n\n[\n/**\n * Returns whether or not the player is in the \"ended\" state.\n *\n * @return {Boolean} True if the player is in the ended state, false if not.\n * @method Player#ended\n */\n'ended',\n/**\n * Returns whether or not the player is in the \"seeking\" state.\n *\n * @return {Boolean} True if the player is in the seeking state, false if not.\n * @method Player#seeking\n */\n'seeking',\n/**\n * Returns the TimeRanges of the media that are currently available\n * for seeking to.\n *\n * @return {TimeRanges} the seekable intervals of the media timeline\n * @method Player#seekable\n */\n'seekable',\n/**\n * Returns the current state of network activity for the element, from\n * the codes in the list below.\n * - NETWORK_EMPTY (numeric value 0)\n *   The element has not yet been initialised. All attributes are in\n *   their initial states.\n * - NETWORK_IDLE (numeric value 1)\n *   The element's resource selection algorithm is active and has\n *   selected a resource, but it is not actually using the network at\n *   this time.\n * - NETWORK_LOADING (numeric value 2)\n *   The user agent is actively trying to download data.\n * - NETWORK_NO_SOURCE (numeric value 3)\n *   The element's resource selection algorithm is active, but it has\n *   not yet found a resource to use.\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states\n * @return {number} the current network activity state\n * @method Player#networkState\n */\n'networkState',\n/**\n * Returns a value that expresses the current state of the element\n * with respect to rendering the current playback position, from the\n * codes in the list below.\n * - HAVE_NOTHING (numeric value 0)\n *   No information regarding the media resource is available.\n * - HAVE_METADATA (numeric value 1)\n *   Enough of the resource has been obtained that the duration of the\n *   resource is available.\n * - HAVE_CURRENT_DATA (numeric value 2)\n *   Data for the immediate current playback position is available.\n * - HAVE_FUTURE_DATA (numeric value 3)\n *   Data for the immediate current playback position is available, as\n *   well as enough data for the user agent to advance the current\n *   playback position in the direction of playback.\n * - HAVE_ENOUGH_DATA (numeric value 4)\n *   The user agent estimates that enough data is available for\n *   playback to proceed uninterrupted.\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate\n * @return {number} the current playback rendering state\n * @method Player#readyState\n */\n'readyState'].forEach(function (fn) {\n  Player.prototype[fn] = function () {\n    return this.techGet_(fn);\n  };\n});\n\nTECH_EVENTS_RETRIGGER.forEach(function (event) {\n  Player.prototype['handleTech' + toTitleCase(event) + '_'] = function () {\n    return this.trigger(event);\n  };\n});\n\n/**\n * Fired when the player has initial duration and dimension information\n *\n * @event Player#loadedmetadata\n * @type {EventTarget~Event}\n */\n\n/**\n * Fired when the player has downloaded data at the current playback position\n *\n * @event Player#loadeddata\n * @type {EventTarget~Event}\n */\n\n/**\n * Fired when the current playback position has changed *\n * During playback this is fired every 15-250 milliseconds, depending on the\n * playback technology in use.\n *\n * @event Player#timeupdate\n * @type {EventTarget~Event}\n */\n\n/**\n * Fired when the volume changes\n *\n * @event Player#volumechange\n * @type {EventTarget~Event}\n */\n\n/**\n * Reports whether or not a player has a plugin available.\n *\n * This does not report whether or not the plugin has ever been initialized\n * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.\n *\n * @method Player#hasPlugin\n * @param  {string}  name\n *         The name of a plugin.\n *\n * @return {boolean}\n *         Whether or not this player has the requested plugin available.\n */\n\n/**\n * Reports whether or not a player is using a plugin by name.\n *\n * For basic plugins, this only reports whether the plugin has _ever_ been\n * initialized on this player.\n *\n * @method Player#usingPlugin\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {boolean}\n *         Whether or not this player is using the requested plugin.\n */\n\nComponent.registerComponent('Player', Player);\n\n/**\n * @file plugin.js\n */\n\n/**\n * The base plugin name.\n *\n * @private\n * @constant\n * @type {string}\n */\nvar BASE_PLUGIN_NAME = 'plugin';\n\n/**\n * The key on which a player's active plugins cache is stored.\n *\n * @private\n * @constant\n * @type     {string}\n */\nvar PLUGIN_CACHE_KEY = 'activePlugins_';\n\n/**\n * Stores registered plugins in a private space.\n *\n * @private\n * @type    {Object}\n */\nvar pluginStorage = {};\n\n/**\n * Reports whether or not a plugin has been registered.\n *\n * @private\n * @param   {string} name\n *          The name of a plugin.\n *\n * @returns {boolean}\n *          Whether or not the plugin has been registered.\n */\nvar pluginExists = function pluginExists(name) {\n  return pluginStorage.hasOwnProperty(name);\n};\n\n/**\n * Get a single registered plugin by name.\n *\n * @private\n * @param   {string} name\n *          The name of a plugin.\n *\n * @returns {Function|undefined}\n *          The plugin (or undefined).\n */\nvar getPlugin = function getPlugin(name) {\n  return pluginExists(name) ? pluginStorage[name] : undefined;\n};\n\n/**\n * Marks a plugin as \"active\" on a player.\n *\n * Also, ensures that the player has an object for tracking active plugins.\n *\n * @private\n * @param   {Player} player\n *          A Video.js player instance.\n *\n * @param   {string} name\n *          The name of a plugin.\n */\nvar markPluginAsActive = function markPluginAsActive(player, name) {\n  player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};\n  player[PLUGIN_CACHE_KEY][name] = true;\n};\n\n/**\n * Triggers a pair of plugin setup events.\n *\n * @private\n * @param  {Player} player\n *         A Video.js player instance.\n *\n * @param  {Plugin~PluginEventHash} hash\n *         A plugin event hash.\n *\n * @param  {Boolean} [before]\n *         If true, prefixes the event name with \"before\". In other words,\n *         use this to trigger \"beforepluginsetup\" instead of \"pluginsetup\".\n */\nvar triggerSetupEvent = function triggerSetupEvent(player, hash, before) {\n  var eventName = (before ? 'before' : '') + 'pluginsetup';\n\n  player.trigger(eventName, hash);\n  player.trigger(eventName + ':' + hash.name, hash);\n};\n\n/**\n * Takes a basic plugin function and returns a wrapper function which marks\n * on the player that the plugin has been activated.\n *\n * @private\n * @param   {string} name\n *          The name of the plugin.\n *\n * @param   {Function} plugin\n *          The basic plugin.\n *\n * @returns {Function}\n *          A wrapper function for the given plugin.\n */\nvar createBasicPlugin = function createBasicPlugin(name, plugin) {\n  var basicPluginWrapper = function basicPluginWrapper() {\n\n    // We trigger the \"beforepluginsetup\" and \"pluginsetup\" events on the player\n    // regardless, but we want the hash to be consistent with the hash provided\n    // for advanced plugins.\n    //\n    // The only potentially counter-intuitive thing here is the `instance` in\n    // the \"pluginsetup\" event is the value returned by the `plugin` function.\n    triggerSetupEvent(this, { name: name, plugin: plugin, instance: null }, true);\n\n    var instance = plugin.apply(this, arguments);\n\n    markPluginAsActive(this, name);\n    triggerSetupEvent(this, { name: name, plugin: plugin, instance: instance });\n\n    return instance;\n  };\n\n  Object.keys(plugin).forEach(function (prop) {\n    basicPluginWrapper[prop] = plugin[prop];\n  });\n\n  return basicPluginWrapper;\n};\n\n/**\n * Takes a plugin sub-class and returns a factory function for generating\n * instances of it.\n *\n * This factory function will replace itself with an instance of the requested\n * sub-class of Plugin.\n *\n * @private\n * @param   {string} name\n *          The name of the plugin.\n *\n * @param   {Plugin} PluginSubClass\n *          The advanced plugin.\n *\n * @returns {Function}\n */\nvar createPluginFactory = function createPluginFactory(name, PluginSubClass) {\n\n  // Add a `name` property to the plugin prototype so that each plugin can\n  // refer to itself by name.\n  PluginSubClass.prototype.name = name;\n\n  return function () {\n    triggerSetupEvent(this, { name: name, plugin: PluginSubClass, instance: null }, true);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var instance = new (Function.prototype.bind.apply(PluginSubClass, [null].concat([this].concat(args))))();\n\n    // The plugin is replaced by a function that returns the current instance.\n    this[name] = function () {\n      return instance;\n    };\n\n    triggerSetupEvent(this, instance.getEventHash());\n\n    return instance;\n  };\n};\n\n/**\n * Parent class for all advanced plugins.\n *\n * @mixes   module:evented~EventedMixin\n * @mixes   module:stateful~StatefulMixin\n * @fires   Player#beforepluginsetup\n * @fires   Player#beforepluginsetup:$name\n * @fires   Player#pluginsetup\n * @fires   Player#pluginsetup:$name\n * @listens Player#dispose\n * @throws  {Error}\n *          If attempting to instantiate the base {@link Plugin} class\n *          directly instead of via a sub-class.\n */\n\nvar Plugin = function () {\n\n  /**\n   * Creates an instance of this class.\n   *\n   * Sub-classes should call `super` to ensure plugins are properly initialized.\n   *\n   * @param {Player} player\n   *        A Video.js player instance.\n   */\n  function Plugin(player) {\n    classCallCheck(this, Plugin);\n\n    if (this.constructor === Plugin) {\n      throw new Error('Plugin must be sub-classed; not directly instantiated.');\n    }\n\n    this.player = player;\n\n    // Make this object evented, but remove the added `trigger` method so we\n    // use the prototype version instead.\n    evented(this);\n    delete this.trigger;\n\n    stateful(this, this.constructor.defaultState);\n    markPluginAsActive(player, this.name);\n\n    // Auto-bind the dispose method so we can use it as a listener and unbind\n    // it later easily.\n    this.dispose = bind(this, this.dispose);\n\n    // If the player is disposed, dispose the plugin.\n    player.on('dispose', this.dispose);\n  }\n\n  /**\n   * Get the version of the plugin that was set on <pluginName>.VERSION\n   */\n\n\n  Plugin.prototype.version = function version() {\n    return this.constructor.VERSION;\n  };\n\n  /**\n   * Each event triggered by plugins includes a hash of additional data with\n   * conventional properties.\n   *\n   * This returns that object or mutates an existing hash.\n   *\n   * @param   {Object} [hash={}]\n   *          An object to be used as event an event hash.\n   *\n   * @returns {Plugin~PluginEventHash}\n   *          An event hash object with provided properties mixed-in.\n   */\n\n\n  Plugin.prototype.getEventHash = function getEventHash() {\n    var hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    hash.name = this.name;\n    hash.plugin = this.constructor;\n    hash.instance = this;\n    return hash;\n  };\n\n  /**\n   * Triggers an event on the plugin object and overrides\n   * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.\n   *\n   * @param   {string|Object} event\n   *          An event type or an object with a type property.\n   *\n   * @param   {Object} [hash={}]\n   *          Additional data hash to merge with a\n   *          {@link Plugin~PluginEventHash|PluginEventHash}.\n   *\n   * @returns {boolean}\n   *          Whether or not default was prevented.\n   */\n\n\n  Plugin.prototype.trigger = function trigger$$1(event) {\n    var hash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    return trigger(this.eventBusEl_, event, this.getEventHash(hash));\n  };\n\n  /**\n   * Handles \"statechanged\" events on the plugin. No-op by default, override by\n   * subclassing.\n   *\n   * @abstract\n   * @param    {Event} e\n   *           An event object provided by a \"statechanged\" event.\n   *\n   * @param    {Object} e.changes\n   *           An object describing changes that occurred with the \"statechanged\"\n   *           event.\n   */\n\n\n  Plugin.prototype.handleStateChanged = function handleStateChanged(e) {};\n\n  /**\n   * Disposes a plugin.\n   *\n   * Subclasses can override this if they want, but for the sake of safety,\n   * it's probably best to subscribe the \"dispose\" event.\n   *\n   * @fires Plugin#dispose\n   */\n\n\n  Plugin.prototype.dispose = function dispose() {\n    var name = this.name,\n        player = this.player;\n\n    /**\n     * Signals that a advanced plugin is about to be disposed.\n     *\n     * @event Plugin#dispose\n     * @type  {EventTarget~Event}\n     */\n\n    this.trigger('dispose');\n    this.off();\n    player.off('dispose', this.dispose);\n\n    // Eliminate any possible sources of leaking memory by clearing up\n    // references between the player and the plugin instance and nulling out\n    // the plugin's state and replacing methods with a function that throws.\n    player[PLUGIN_CACHE_KEY][name] = false;\n    this.player = this.state = null;\n\n    // Finally, replace the plugin name on the player with a new factory\n    // function, so that the plugin is ready to be set up again.\n    player[name] = createPluginFactory(name, pluginStorage[name]);\n  };\n\n  /**\n   * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).\n   *\n   * @param   {string|Function} plugin\n   *          If a string, matches the name of a plugin. If a function, will be\n   *          tested directly.\n   *\n   * @returns {boolean}\n   *          Whether or not a plugin is a basic plugin.\n   */\n\n\n  Plugin.isBasic = function isBasic(plugin) {\n    var p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;\n\n    return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);\n  };\n\n  /**\n   * Register a Video.js plugin.\n   *\n   * @param   {string} name\n   *          The name of the plugin to be registered. Must be a string and\n   *          must not match an existing plugin or a method on the `Player`\n   *          prototype.\n   *\n   * @param   {Function} plugin\n   *          A sub-class of `Plugin` or a function for basic plugins.\n   *\n   * @returns {Function}\n   *          For advanced plugins, a factory function for that plugin. For\n   *          basic plugins, a wrapper function that initializes the plugin.\n   */\n\n\n  Plugin.registerPlugin = function registerPlugin(name, plugin) {\n    if (typeof name !== 'string') {\n      throw new Error('Illegal plugin name, \"' + name + '\", must be a string, was ' + (typeof name === 'undefined' ? 'undefined' : _typeof(name)) + '.');\n    }\n\n    if (pluginExists(name)) {\n      log$1.warn('A plugin named \"' + name + '\" already exists. You may want to avoid re-registering plugins!');\n    } else if (Player.prototype.hasOwnProperty(name)) {\n      throw new Error('Illegal plugin name, \"' + name + '\", cannot share a name with an existing player method!');\n    }\n\n    if (typeof plugin !== 'function') {\n      throw new Error('Illegal plugin for \"' + name + '\", must be a function, was ' + (typeof plugin === 'undefined' ? 'undefined' : _typeof(plugin)) + '.');\n    }\n\n    pluginStorage[name] = plugin;\n\n    // Add a player prototype method for all sub-classed plugins (but not for\n    // the base Plugin class).\n    if (name !== BASE_PLUGIN_NAME) {\n      if (Plugin.isBasic(plugin)) {\n        Player.prototype[name] = createBasicPlugin(name, plugin);\n      } else {\n        Player.prototype[name] = createPluginFactory(name, plugin);\n      }\n    }\n\n    return plugin;\n  };\n\n  /**\n   * De-register a Video.js plugin.\n   *\n   * @param {string} name\n   *        The name of the plugin to be deregistered.\n   */\n\n\n  Plugin.deregisterPlugin = function deregisterPlugin(name) {\n    if (name === BASE_PLUGIN_NAME) {\n      throw new Error('Cannot de-register base plugin.');\n    }\n    if (pluginExists(name)) {\n      delete pluginStorage[name];\n      delete Player.prototype[name];\n    }\n  };\n\n  /**\n   * Gets an object containing multiple Video.js plugins.\n   *\n   * @param   {Array} [names]\n   *          If provided, should be an array of plugin names. Defaults to _all_\n   *          plugin names.\n   *\n   * @returns {Object|undefined}\n   *          An object containing plugin(s) associated with their name(s) or\n   *          `undefined` if no matching plugins exist).\n   */\n\n\n  Plugin.getPlugins = function getPlugins() {\n    var names = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.keys(pluginStorage);\n\n    var result = void 0;\n\n    names.forEach(function (name) {\n      var plugin = getPlugin(name);\n\n      if (plugin) {\n        result = result || {};\n        result[name] = plugin;\n      }\n    });\n\n    return result;\n  };\n\n  /**\n   * Gets a plugin's version, if available\n   *\n   * @param   {string} name\n   *          The name of a plugin.\n   *\n   * @returns {string}\n   *          The plugin's version or an empty string.\n   */\n\n\n  Plugin.getPluginVersion = function getPluginVersion(name) {\n    var plugin = getPlugin(name);\n\n    return plugin && plugin.VERSION || '';\n  };\n\n  return Plugin;\n}();\n\n/**\n * Gets a plugin by name if it exists.\n *\n * @static\n * @method   getPlugin\n * @memberOf Plugin\n * @param    {string} name\n *           The name of a plugin.\n *\n * @returns  {Function|undefined}\n *           The plugin (or `undefined`).\n */\n\n\nPlugin.getPlugin = getPlugin;\n\n/**\n * The name of the base plugin class as it is registered.\n *\n * @type {string}\n */\nPlugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;\n\nPlugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);\n\n/**\n * Documented in player.js\n *\n * @ignore\n */\nPlayer.prototype.usingPlugin = function (name) {\n  return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;\n};\n\n/**\n * Documented in player.js\n *\n * @ignore\n */\nPlayer.prototype.hasPlugin = function (name) {\n  return !!pluginExists(name);\n};\n\n/**\n * @file extend.js\n * @module extend\n */\n\n/**\n * A combination of node inherits and babel's inherits (after transpile).\n * Both work the same but node adds `super_` to the subClass\n * and Bable adds the superClass as __proto__. Both seem useful.\n *\n * @param {Object} subClass\n *        The class to inherit to\n *\n * @param {Object} superClass\n *        The class to inherit from\n *\n * @private\n */\nvar _inherits = function _inherits(subClass, superClass) {\n  if (typeof superClass !== 'function' && superClass !== null) {\n    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (superClass) {\n    // node\n    subClass.super_ = superClass;\n  }\n};\n\n/**\n * Function for subclassing using the same inheritance that\n * videojs uses internally\n *\n * @static\n * @const\n *\n * @param {Object} superClass\n *        The class to inherit from\n *\n * @param {Object} [subClassMethods={}]\n *        The class to inherit to\n *\n * @return {Object}\n *         The new object with subClassMethods that inherited superClass.\n */\nvar extendFn = function extendFn(superClass) {\n  var subClassMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var subClass = function subClass() {\n    superClass.apply(this, arguments);\n  };\n\n  var methods = {};\n\n  if ((typeof subClassMethods === 'undefined' ? 'undefined' : _typeof(subClassMethods)) === 'object') {\n    if (subClassMethods.constructor !== Object.prototype.constructor) {\n      subClass = subClassMethods.constructor;\n    }\n    methods = subClassMethods;\n  } else if (typeof subClassMethods === 'function') {\n    subClass = subClassMethods;\n  }\n\n  _inherits(subClass, superClass);\n\n  // Extend subObj's prototype with functions and other properties from props\n  for (var name in methods) {\n    if (methods.hasOwnProperty(name)) {\n      subClass.prototype[name] = methods[name];\n    }\n  }\n\n  return subClass;\n};\n\n/**\n * @file video.js\n * @module videojs\n */\n\n/**\n * Normalize an `id` value by trimming off a leading `#`\n *\n * @param   {string} id\n *          A string, maybe with a leading `#`.\n *\n * @returns {string}\n *          The string, without any leading `#`.\n */\nvar normalizeId = function normalizeId(id) {\n  return id.indexOf('#') === 0 ? id.slice(1) : id;\n};\n\n/**\n * Doubles as the main function for users to create a player instance and also\n * the main library object.\n * The `videojs` function can be used to initialize or retrieve a player.\n  *\n * @param {string|Element} id\n *        Video element or video element ID\n *\n * @param {Object} [options]\n *        Optional options object for config/settings\n *\n * @param {Component~ReadyCallback} [ready]\n *        Optional ready callback\n *\n * @return {Player}\n *         A player instance\n */\nfunction videojs$1(id, options, ready) {\n  var player = videojs$1.getPlayer(id);\n\n  if (player) {\n    if (options) {\n      log$1.warn('Player \"' + id + '\" is already initialised. Options will not be applied.');\n    }\n    if (ready) {\n      player.ready(ready);\n    }\n    return player;\n  }\n\n  var el = typeof id === 'string' ? $('#' + normalizeId(id)) : id;\n\n  if (!isEl(el)) {\n    throw new TypeError('The element or ID supplied is not valid. (videojs)');\n  }\n\n  if (!global_document__WEBPACK_IMPORTED_MODULE_1___default.a.body.contains(el)) {\n    log$1.warn('The element supplied is not included in the DOM');\n  }\n\n  options = options || {};\n\n  videojs$1.hooks('beforesetup').forEach(function (hookFunction) {\n    var opts = hookFunction(el, mergeOptions(options));\n\n    if (!isObject(opts) || Array.isArray(opts)) {\n      log$1.error('please return an object in beforesetup hooks');\n      return;\n    }\n\n    options = mergeOptions(options, opts);\n  });\n\n  // We get the current \"Player\" component here in case an integration has\n  // replaced it with a custom player.\n  var PlayerComponent = Component.getComponent('Player');\n\n  player = new PlayerComponent(el, options, ready);\n\n  videojs$1.hooks('setup').forEach(function (hookFunction) {\n    return hookFunction(player);\n  });\n\n  return player;\n}\n\n/**\n * An Object that contains lifecycle hooks as keys which point to an array\n * of functions that are run when a lifecycle is triggered\n */\nvideojs$1.hooks_ = {};\n\n/**\n * Get a list of hooks for a specific lifecycle\n * @function videojs.hooks\n *\n * @param {string} type\n *        the lifecyle to get hooks from\n *\n * @param {Function|Function[]} [fn]\n *        Optionally add a hook (or hooks) to the lifecycle that your are getting.\n *\n * @return {Array}\n *         an array of hooks, or an empty array if there are none.\n */\nvideojs$1.hooks = function (type, fn) {\n  videojs$1.hooks_[type] = videojs$1.hooks_[type] || [];\n  if (fn) {\n    videojs$1.hooks_[type] = videojs$1.hooks_[type].concat(fn);\n  }\n  return videojs$1.hooks_[type];\n};\n\n/**\n * Add a function hook to a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle to hook the function to.\n *\n * @param {Function|Function[]}\n *        The function or array of functions to attach.\n */\nvideojs$1.hook = function (type, fn) {\n  videojs$1.hooks(type, fn);\n};\n\n/**\n * Add a function hook that will only run once to a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle to hook the function to.\n *\n * @param {Function|Function[]}\n *        The function or array of functions to attach.\n */\nvideojs$1.hookOnce = function (type, fn) {\n  videojs$1.hooks(type, [].concat(fn).map(function (original) {\n    var wrapper = function wrapper() {\n      videojs$1.removeHook(type, wrapper);\n      return original.apply(undefined, arguments);\n    };\n\n    return wrapper;\n  }));\n};\n\n/**\n * Remove a hook from a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle that the function hooked to\n *\n * @param {Function} fn\n *        The hooked function to remove\n *\n * @return {boolean}\n *         The function that was removed or undef\n */\nvideojs$1.removeHook = function (type, fn) {\n  var index = videojs$1.hooks(type).indexOf(fn);\n\n  if (index <= -1) {\n    return false;\n  }\n\n  videojs$1.hooks_[type] = videojs$1.hooks_[type].slice();\n  videojs$1.hooks_[type].splice(index, 1);\n\n  return true;\n};\n\n// Add default styles\nif (global_window__WEBPACK_IMPORTED_MODULE_0___default.a.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {\n  var style$1 = $('.vjs-styles-defaults');\n\n  if (!style$1) {\n    style$1 = createStyleElement('vjs-styles-defaults');\n    var head = $('head');\n\n    if (head) {\n      head.insertBefore(style$1, head.firstChild);\n    }\n    setTextContent(style$1, '\\n      .video-js {\\n        width: 300px;\\n        height: 150px;\\n      }\\n\\n      .vjs-fluid {\\n        padding-top: 56.25%\\n      }\\n    ');\n  }\n}\n\n// Run Auto-load players\n// You have to wait at least once in case this script is loaded after your\n// video in the DOM (weird behavior only with minified version)\nautoSetupTimeout(1, videojs$1);\n\n/**\n * Current software version. Follows semver.\n *\n * @type {string}\n */\nvideojs$1.VERSION = version;\n\n/**\n * The global options object. These are the settings that take effect\n * if no overrides are specified when the player is created.\n *\n * @type {Object}\n */\nvideojs$1.options = Player.prototype.options_;\n\n/**\n * Get an object with the currently created players, keyed by player ID\n *\n * @return {Object}\n *         The created players\n */\nvideojs$1.getPlayers = function () {\n  return Player.players;\n};\n\n/**\n * Get a single player based on an ID or DOM element.\n *\n * This is useful if you want to check if an element or ID has an associated\n * Video.js player, but not create one if it doesn't.\n *\n * @param   {string|Element} id\n *          An HTML element - `<video>`, `<audio>`, or `<video-js>` -\n *          or a string matching the `id` of such an element.\n *\n * @returns {Player|undefined}\n *          A player instance or `undefined` if there is no player instance\n *          matching the argument.\n */\nvideojs$1.getPlayer = function (id) {\n  var players = Player.players;\n  var tag = void 0;\n\n  if (typeof id === 'string') {\n    var nId = normalizeId(id);\n    var player = players[nId];\n\n    if (player) {\n      return player;\n    }\n\n    tag = $('#' + nId);\n  } else {\n    tag = id;\n  }\n\n  if (isEl(tag)) {\n    var _tag = tag,\n        _player = _tag.player,\n        playerId = _tag.playerId;\n\n    // Element may have a `player` property referring to an already created\n    // player instance. If so, return that.\n\n    if (_player || players[playerId]) {\n      return _player || players[playerId];\n    }\n  }\n};\n\n/**\n * Returns an array of all current players.\n *\n * @return {Array}\n *         An array of all players. The array will be in the order that\n *         `Object.keys` provides, which could potentially vary between\n *         JavaScript engines.\n *\n */\nvideojs$1.getAllPlayers = function () {\n  return (\n\n    // Disposed players leave a key with a `null` value, so we need to make sure\n    // we filter those out.\n    Object.keys(Player.players).map(function (k) {\n      return Player.players[k];\n    }).filter(Boolean)\n  );\n};\n\n/**\n * Expose players object.\n *\n * @memberOf videojs\n * @property {Object} players\n */\nvideojs$1.players = Player.players;\n\n/**\n * Get a component class object by name\n *\n * @borrows Component.getComponent as videojs.getComponent\n */\nvideojs$1.getComponent = Component.getComponent;\n\n/**\n * Register a component so it can referred to by name. Used when adding to other\n * components, either through addChild `component.addChild('myComponent')` or through\n * default children options  `{ children: ['myComponent'] }`.\n *\n * > NOTE: You could also just initialize the component before adding.\n * `component.addChild(new MyComponent());`\n *\n * @param {string} name\n *        The class name of the component\n *\n * @param {Component} comp\n *        The component class\n *\n * @return {Component}\n *         The newly registered component\n */\nvideojs$1.registerComponent = function (name$$1, comp) {\n  if (Tech.isTech(comp)) {\n    log$1.warn('The ' + name$$1 + ' tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)');\n  }\n\n  Component.registerComponent.call(Component, name$$1, comp);\n};\n\n/**\n * Get a Tech class object by name\n *\n * @borrows Tech.getTech as videojs.getTech\n */\nvideojs$1.getTech = Tech.getTech;\n\n/**\n * Register a Tech so it can referred to by name.\n * This is used in the tech order for the player.\n *\n * @borrows Tech.registerTech as videojs.registerTech\n */\nvideojs$1.registerTech = Tech.registerTech;\n\n/**\n * Register a middleware to a source type.\n *\n * @param {String} type A string representing a MIME type.\n * @param {function(player):object} middleware A middleware factory that takes a player.\n */\nvideojs$1.use = use;\n\n/**\n * An object that can be returned by a middleware to signify\n * that the middleware is being terminated.\n *\n * @type {object}\n * @memberOf {videojs}\n * @property {object} middleware.TERMINATOR\n */\nObject.defineProperty(videojs$1, 'middleware', {\n  value: {},\n  writeable: false,\n  enumerable: true\n});\n\nObject.defineProperty(videojs$1.middleware, 'TERMINATOR', {\n  value: TERMINATOR,\n  writeable: false,\n  enumerable: true\n});\n\n/**\n * A suite of browser and device tests from {@link browser}.\n *\n * @type {Object}\n * @private\n */\nvideojs$1.browser = browser;\n\n/**\n * Whether or not the browser supports touch events. Included for backward\n * compatibility with 4.x, but deprecated. Use `videojs.browser.TOUCH_ENABLED`\n * instead going forward.\n *\n * @deprecated since version 5.0\n * @type {boolean}\n */\nvideojs$1.TOUCH_ENABLED = TOUCH_ENABLED;\n\n/**\n * Subclass an existing class\n * Mimics ES6 subclassing with the `extend` keyword\n *\n * @borrows extend:extendFn as videojs.extend\n */\nvideojs$1.extend = extendFn;\n\n/**\n * Merge two options objects recursively\n * Performs a deep merge like lodash.merge but **only merges plain objects**\n * (not arrays, elements, anything else)\n * Other values will be copied directly from the second object.\n *\n * @borrows merge-options:mergeOptions as videojs.mergeOptions\n */\nvideojs$1.mergeOptions = mergeOptions;\n\n/**\n * Change the context (this) of a function\n *\n * > NOTE: as of v5.0 we require an ES5 shim, so you should use the native\n * `function() {}.bind(newContext);` instead of this.\n *\n * @borrows fn:bind as videojs.bind\n */\nvideojs$1.bind = bind;\n\n/**\n * Register a Video.js plugin.\n *\n * @borrows plugin:registerPlugin as videojs.registerPlugin\n * @method registerPlugin\n *\n * @param  {string} name\n *         The name of the plugin to be registered. Must be a string and\n *         must not match an existing plugin or a method on the `Player`\n *         prototype.\n *\n * @param  {Function} plugin\n *         A sub-class of `Plugin` or a function for basic plugins.\n *\n * @return {Function}\n *         For advanced plugins, a factory function for that plugin. For\n *         basic plugins, a wrapper function that initializes the plugin.\n */\nvideojs$1.registerPlugin = Plugin.registerPlugin;\n\n/**\n * Deprecated method to register a plugin with Video.js\n *\n * @deprecated\n *        videojs.plugin() is deprecated; use videojs.registerPlugin() instead\n *\n * @param {string} name\n *        The plugin name\n *\n * @param {Plugin|Function} plugin\n *         The plugin sub-class or function\n */\nvideojs$1.plugin = function (name$$1, plugin) {\n  log$1.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');\n  return Plugin.registerPlugin(name$$1, plugin);\n};\n\n/**\n * Gets an object containing multiple Video.js plugins.\n *\n * @param  {Array} [names]\n *         If provided, should be an array of plugin names. Defaults to _all_\n *         plugin names.\n *\n * @return {Object|undefined}\n *         An object containing plugin(s) associated with their name(s) or\n *         `undefined` if no matching plugins exist).\n */\nvideojs$1.getPlugins = Plugin.getPlugins;\n\n/**\n * Gets a plugin by name if it exists.\n *\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {Function|undefined}\n *         The plugin (or `undefined`).\n */\nvideojs$1.getPlugin = Plugin.getPlugin;\n\n/**\n * Gets a plugin's version, if available\n *\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {string}\n *         The plugin's version or an empty string.\n */\nvideojs$1.getPluginVersion = Plugin.getPluginVersion;\n\n/**\n * Adding languages so that they're available to all players.\n * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`\n *\n * @param {string} code\n *        The language code or dictionary property\n *\n * @param {Object} data\n *        The data values to be translated\n *\n * @return {Object}\n *         The resulting language dictionary object\n */\nvideojs$1.addLanguage = function (code, data) {\n  var _mergeOptions;\n\n  code = ('' + code).toLowerCase();\n\n  videojs$1.options.languages = mergeOptions(videojs$1.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));\n\n  return videojs$1.options.languages[code];\n};\n\n/**\n * Log messages\n *\n * @borrows log:log as videojs.log\n */\nvideojs$1.log = log$1;\n\n/**\n * Creates an emulated TimeRange object.\n *\n * @borrows time-ranges:createTimeRanges as videojs.createTimeRange\n */\n/**\n * @borrows time-ranges:createTimeRanges as videojs.createTimeRanges\n */\nvideojs$1.createTimeRange = videojs$1.createTimeRanges = createTimeRanges;\n\n/**\n * Format seconds as a time string, H:MM:SS or M:SS\n * Supplying a guide (in seconds) will force a number of leading zeros\n * to cover the length of the guide\n *\n * @borrows format-time:formatTime as videojs.formatTime\n */\nvideojs$1.formatTime = formatTime;\n\n/**\n * Replaces format-time with a custom implementation, to be used in place of the default.\n *\n * @borrows format-time:setFormatTime as videojs.setFormatTime\n *\n * @method setFormatTime\n *\n * @param {Function} customFn\n *        A custom format-time function which will be called with the current time and guide (in seconds) as arguments.\n *        Passed fn should return a string.\n */\nvideojs$1.setFormatTime = setFormatTime;\n\n/**\n * Resets format-time to the default implementation.\n *\n * @borrows format-time:resetFormatTime as videojs.resetFormatTime\n *\n * @method resetFormatTime\n */\nvideojs$1.resetFormatTime = resetFormatTime;\n\n/**\n * Resolve and parse the elements of a URL\n *\n * @borrows url:parseUrl as videojs.parseUrl\n *\n */\nvideojs$1.parseUrl = parseUrl;\n\n/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @borrows url:isCrossOrigin as videojs.isCrossOrigin\n */\nvideojs$1.isCrossOrigin = isCrossOrigin;\n\n/**\n * Event target class.\n *\n * @borrows EventTarget as videojs.EventTarget\n */\nvideojs$1.EventTarget = EventTarget;\n\n/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @borrows events:on as videojs.on\n */\nvideojs$1.on = on;\n\n/**\n * Trigger a listener only once for an event\n *\n * @borrows events:one as videojs.one\n */\nvideojs$1.one = one;\n\n/**\n * Removes event listeners from an element\n *\n * @borrows events:off as videojs.off\n */\nvideojs$1.off = off;\n\n/**\n * Trigger an event for an element\n *\n * @borrows events:trigger as videojs.trigger\n */\nvideojs$1.trigger = trigger;\n\n/**\n * A cross-browser XMLHttpRequest wrapper. Here's a simple example:\n *\n * @param {Object} options\n *        settings for the request.\n *\n * @return {XMLHttpRequest|XDomainRequest}\n *         The request object.\n *\n * @see https://github.com/Raynos/xhr\n */\nvideojs$1.xhr = xhr__WEBPACK_IMPORTED_MODULE_3___default.a;\n\n/**\n * TextTrack class\n *\n * @borrows TextTrack as videojs.TextTrack\n */\nvideojs$1.TextTrack = TextTrack;\n\n/**\n * export the AudioTrack class so that source handlers can create\n * AudioTracks and then add them to the players AudioTrackList\n *\n * @borrows AudioTrack as videojs.AudioTrack\n */\nvideojs$1.AudioTrack = AudioTrack;\n\n/**\n * export the VideoTrack class so that source handlers can create\n * VideoTracks and then add them to the players VideoTrackList\n *\n * @borrows VideoTrack as videojs.VideoTrack\n */\nvideojs$1.VideoTrack = VideoTrack;\n\n/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @borrows dom:isEl as videojs.isEl\n * @deprecated Use videojs.dom.isEl() instead\n */\n\n/**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @borrows dom:isTextNode as videojs.isTextNode\n * @deprecated Use videojs.dom.isTextNode() instead\n */\n\n/**\n * Creates an element and applies properties.\n *\n * @borrows dom:createEl as videojs.createEl\n * @deprecated Use videojs.dom.createEl() instead\n */\n\n/**\n * Check if an element has a CSS class\n *\n * @borrows dom:hasElClass as videojs.hasClass\n * @deprecated Use videojs.dom.hasClass() instead\n */\n\n/**\n * Add a CSS class name to an element\n *\n * @borrows dom:addElClass as videojs.addClass\n * @deprecated Use videojs.dom.addClass() instead\n */\n\n/**\n * Remove a CSS class name from an element\n *\n * @borrows dom:removeElClass as videojs.removeClass\n * @deprecated Use videojs.dom.removeClass() instead\n */\n\n/**\n * Adds or removes a CSS class name on an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @borrows dom:toggleElClass as videojs.toggleClass\n * @deprecated Use videojs.dom.toggleClass() instead\n */\n\n/**\n * Apply attributes to an HTML element.\n *\n * @borrows dom:setElAttributes as videojs.setAttribute\n * @deprecated Use videojs.dom.setAttributes() instead\n */\n\n/**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n *\n * @borrows dom:getElAttributes as videojs.getAttributes\n * @deprecated Use videojs.dom.getAttributes() instead\n */\n\n/**\n * Empties the contents of an element.\n *\n * @borrows dom:emptyEl as videojs.emptyEl\n * @deprecated Use videojs.dom.emptyEl() instead\n */\n\n/**\n * Normalizes and appends content to an element.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * - String\n *   Normalized into a text node.\n *\n * - Element, TextNode\n *   Passed through.\n *\n * - Array\n *   A one-dimensional array of strings, elements, nodes, or functions (which\n *   return single strings, elements, or nodes).\n *\n * - Function\n *   If the sole argument, is expected to produce a string, element,\n *   node, or array.\n *\n * @borrows dom:appendContents as videojs.appendContet\n * @deprecated Use videojs.dom.appendContent() instead\n */\n\n/**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * - String\n *   Normalized into a text node.\n *\n * - Element, TextNode\n *   Passed through.\n *\n * - Array\n *   A one-dimensional array of strings, elements, nodes, or functions (which\n *   return single strings, elements, or nodes).\n *\n * - Function\n *   If the sole argument, is expected to produce a string, element,\n *   node, or array.\n *\n * @borrows dom:insertContent as videojs.insertContent\n * @deprecated Use videojs.dom.insertContent() instead\n */\n['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(function (k) {\n  videojs$1[k] = function () {\n    log$1.warn('videojs.' + k + '() is deprecated; use videojs.dom.' + k + '() instead');\n    return Dom[k].apply(null, arguments);\n  };\n});\n\n/**\n * A safe getComputedStyle.\n *\n * This is because in Firefox, if the player is loaded in an iframe with `display:none`,\n * then `getComputedStyle` returns `null`, so, we do a null-check to make sure\n * that the player doesn't break in these cases.\n * See https://bugzilla.mozilla.org/show_bug.cgi?id=548397 for more details.\n *\n * @borrows computed-style:computedStyle as videojs.computedStyle\n */\nvideojs$1.computedStyle = computedStyle;\n\n/**\n * Export the Dom utilities for use in external plugins\n * and Tech's\n */\nvideojs$1.dom = Dom;\n\n/**\n * Export the Url utilities for use in external plugins\n * and Tech's\n */\nvideojs$1.url = Url;\n\n/**\n * @videojs/http-streaming\n * @version 1.1.0\n * @copyright 2018 Brightcove, Inc\n * @license Apache-2.0\n */\n\n/**\n * @file resolve-url.js\n */\n\nvar resolveUrl = function resolveUrl(baseURL, relativeURL) {\n  // return early if we don't need to resolve\n  if (/^[a-z]+:/i.test(relativeURL)) {\n    return relativeURL;\n  }\n\n  // if the base URL is relative then combine with the current location\n  if (!/\\/\\//i.test(baseURL)) {\n    baseURL = url_toolkit__WEBPACK_IMPORTED_MODULE_6___default.a.buildAbsoluteURL(global_window__WEBPACK_IMPORTED_MODULE_0___default.a.location.href, baseURL);\n  }\n\n  return url_toolkit__WEBPACK_IMPORTED_MODULE_6___default.a.buildAbsoluteURL(baseURL, relativeURL);\n};\n\nvar classCallCheck$1 = function classCallCheck$$1(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass$1 = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar get$2 = function get$$1(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get$$1(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits$1 = function inherits$$1(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn$1 = function possibleConstructorReturn$$1(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray$1 = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n/**\n * @file playlist-loader.js\n *\n * A state machine that manages the loading, caching, and updating of\n * M3U8 playlists.\n *\n */\n\nvar mergeOptions$1 = videojs$1.mergeOptions,\n    EventTarget$1 = videojs$1.EventTarget,\n    log$2 = videojs$1.log;\n\n/**\n * Loops through all supported media groups in master and calls the provided\n * callback for each group\n *\n * @param {Object} master\n *        The parsed master manifest object\n * @param {Function} callback\n *        Callback to call for each media group\n */\n\nvar forEachMediaGroup = function forEachMediaGroup(master, callback) {\n  ['AUDIO', 'SUBTITLES'].forEach(function (mediaType) {\n    for (var groupKey in master.mediaGroups[mediaType]) {\n      for (var labelKey in master.mediaGroups[mediaType][groupKey]) {\n        var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];\n\n        callback(mediaProperties, mediaType, groupKey, labelKey);\n      }\n    }\n  });\n};\n\n/**\n  * Returns a new array of segments that is the result of merging\n  * properties from an older list of segments onto an updated\n  * list. No properties on the updated playlist will be overridden.\n  *\n  * @param {Array} original the outdated list of segments\n  * @param {Array} update the updated list of segments\n  * @param {Number=} offset the index of the first update\n  * segment in the original segment list. For non-live playlists,\n  * this should always be zero and does not need to be\n  * specified. For live playlists, it should be the difference\n  * between the media sequence numbers in the original and updated\n  * playlists.\n  * @return a list of merged segment objects\n  */\nvar updateSegments = function updateSegments(original, update, offset) {\n  var result = update.slice();\n\n  offset = offset || 0;\n  var length = Math.min(original.length, update.length + offset);\n\n  for (var i = offset; i < length; i++) {\n    result[i - offset] = mergeOptions$1(original[i], result[i - offset]);\n  }\n  return result;\n};\n\nvar resolveSegmentUris = function resolveSegmentUris(segment, baseUri) {\n  if (!segment.resolvedUri) {\n    segment.resolvedUri = resolveUrl(baseUri, segment.uri);\n  }\n  if (segment.key && !segment.key.resolvedUri) {\n    segment.key.resolvedUri = resolveUrl(baseUri, segment.key.uri);\n  }\n  if (segment.map && !segment.map.resolvedUri) {\n    segment.map.resolvedUri = resolveUrl(baseUri, segment.map.uri);\n  }\n};\n\n/**\n  * Returns a new master playlist that is the result of merging an\n  * updated media playlist into the original version. If the\n  * updated media playlist does not match any of the playlist\n  * entries in the original master playlist, null is returned.\n  *\n  * @param {Object} master a parsed master M3U8 object\n  * @param {Object} media a parsed media M3U8 object\n  * @return {Object} a new object that represents the original\n  * master playlist with the updated media playlist merged in, or\n  * null if the merge produced no change.\n  */\nvar updateMaster = function updateMaster(master, media) {\n  var result = mergeOptions$1(master, {});\n  var playlist = result.playlists[media.uri];\n\n  if (!playlist) {\n    return null;\n  }\n\n  // consider the playlist unchanged if the number of segments is equal and the media\n  // sequence number is unchanged\n  if (playlist.segments && media.segments && playlist.segments.length === media.segments.length && playlist.mediaSequence === media.mediaSequence) {\n    return null;\n  }\n\n  var mergedPlaylist = mergeOptions$1(playlist, media);\n\n  // if the update could overlap existing segment information, merge the two segment lists\n  if (playlist.segments) {\n    mergedPlaylist.segments = updateSegments(playlist.segments, media.segments, media.mediaSequence - playlist.mediaSequence);\n  }\n\n  // resolve any segment URIs to prevent us from having to do it later\n  mergedPlaylist.segments.forEach(function (segment) {\n    resolveSegmentUris(segment, mergedPlaylist.resolvedUri);\n  });\n\n  // TODO Right now in the playlists array there are two references to each playlist, one\n  // that is referenced by index, and one by URI. The index reference may no longer be\n  // necessary.\n  for (var i = 0; i < result.playlists.length; i++) {\n    if (result.playlists[i].uri === media.uri) {\n      result.playlists[i] = mergedPlaylist;\n    }\n  }\n  result.playlists[media.uri] = mergedPlaylist;\n\n  return result;\n};\n\nvar setupMediaPlaylists = function setupMediaPlaylists(master) {\n  // setup by-URI lookups and resolve media playlist URIs\n  var i = master.playlists.length;\n\n  while (i--) {\n    var playlist = master.playlists[i];\n\n    master.playlists[playlist.uri] = playlist;\n    playlist.resolvedUri = resolveUrl(master.uri, playlist.uri);\n    playlist.id = i;\n\n    if (!playlist.attributes) {\n      // Although the spec states an #EXT-X-STREAM-INF tag MUST have a\n      // BANDWIDTH attribute, we can play the stream without it. This means a poorly\n      // formatted master playlist may not have an attribute list. An attributes\n      // property is added here to prevent undefined references when we encounter\n      // this scenario.\n      playlist.attributes = {};\n\n      log$2.warn('Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.');\n    }\n  }\n};\n\nvar resolveMediaGroupUris = function resolveMediaGroupUris(master) {\n  forEachMediaGroup(master, function (properties) {\n    if (properties.uri) {\n      properties.resolvedUri = resolveUrl(master.uri, properties.uri);\n    }\n  });\n};\n\n/**\n * Calculates the time to wait before refreshing a live playlist\n *\n * @param {Object} media\n *        The current media\n * @param {Boolean} update\n *        True if there were any updates from the last refresh, false otherwise\n * @return {Number}\n *         The time in ms to wait before refreshing the live playlist\n */\nvar refreshDelay = function refreshDelay(media, update) {\n  var lastSegment = media.segments[media.segments.length - 1];\n  var delay = void 0;\n\n  if (update && lastSegment && lastSegment.duration) {\n    delay = lastSegment.duration * 1000;\n  } else {\n    // if the playlist is unchanged since the last reload or last segment duration\n    // cannot be determined, try again after half the target duration\n    delay = (media.targetDuration || 10) * 500;\n  }\n  return delay;\n};\n\n/**\n * Load a playlist from a remote location\n *\n * @class PlaylistLoader\n * @extends Stream\n * @param {String} srcUrl the url to start with\n * @param {Boolean} withCredentials the withCredentials xhr option\n * @constructor\n */\n\nvar PlaylistLoader = function (_EventTarget) {\n  inherits$1(PlaylistLoader, _EventTarget);\n\n  function PlaylistLoader(srcUrl, hls, withCredentials) {\n    classCallCheck$1(this, PlaylistLoader);\n\n    var _this = possibleConstructorReturn$1(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this));\n\n    _this.srcUrl = srcUrl;\n    _this.hls_ = hls;\n    _this.withCredentials = withCredentials;\n\n    if (!_this.srcUrl) {\n      throw new Error('A non-empty playlist URL is required');\n    }\n\n    // initialize the loader state\n    _this.state = 'HAVE_NOTHING';\n\n    // live playlist staleness timeout\n    _this.on('mediaupdatetimeout', function () {\n      if (_this.state !== 'HAVE_METADATA') {\n        // only refresh the media playlist if no other activity is going on\n        return;\n      }\n\n      _this.state = 'HAVE_CURRENT_METADATA';\n\n      _this.request = _this.hls_.xhr({\n        uri: resolveUrl(_this.master.uri, _this.media().uri),\n        withCredentials: _this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this.request) {\n          return;\n        }\n\n        if (error) {\n          return _this.playlistRequestError(_this.request, _this.media().uri, 'HAVE_METADATA');\n        }\n\n        _this.haveMetadata(_this.request, _this.media().uri);\n      });\n    });\n    return _this;\n  }\n\n  createClass$1(PlaylistLoader, [{\n    key: 'playlistRequestError',\n    value: function playlistRequestError(xhr$$1, url, startingState) {\n      // any in-flight request is now finished\n      this.request = null;\n\n      if (startingState) {\n        this.state = startingState;\n      }\n\n      this.error = {\n        playlist: this.master.playlists[url],\n        status: xhr$$1.status,\n        message: 'HLS playlist request error at URL: ' + url,\n        responseText: xhr$$1.responseText,\n        code: xhr$$1.status >= 500 ? 4 : 2\n      };\n\n      this.trigger('error');\n    }\n\n    // update the playlist loader's state in response to a new or\n    // updated playlist.\n\n  }, {\n    key: 'haveMetadata',\n    value: function haveMetadata(xhr$$1, url) {\n      var _this2 = this;\n\n      // any in-flight request is now finished\n      this.request = null;\n      this.state = 'HAVE_METADATA';\n\n      var parser = new m3u8_parser__WEBPACK_IMPORTED_MODULE_7__[\"Parser\"]();\n\n      parser.push(xhr$$1.responseText);\n      parser.end();\n      parser.manifest.uri = url;\n      // m3u8-parser does not attach an attributes property to media playlists so make\n      // sure that the property is attached to avoid undefined reference errors\n      parser.manifest.attributes = parser.manifest.attributes || {};\n\n      // merge this playlist into the master\n      var update = updateMaster(this.master, parser.manifest);\n\n      this.targetDuration = parser.manifest.targetDuration;\n\n      if (update) {\n        this.master = update;\n        this.media_ = this.master.playlists[parser.manifest.uri];\n      } else {\n        this.trigger('playlistunchanged');\n      }\n\n      // refresh live playlists after a target duration passes\n      if (!this.media().endList) {\n        global_window__WEBPACK_IMPORTED_MODULE_0___default.a.clearTimeout(this.mediaUpdateTimeout);\n        this.mediaUpdateTimeout = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.setTimeout(function () {\n          _this2.trigger('mediaupdatetimeout');\n        }, refreshDelay(this.media(), !!update));\n      }\n\n      this.trigger('loadedplaylist');\n    }\n\n    /**\n     * Abort any outstanding work and clean up.\n     */\n\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.stopRequest();\n      global_window__WEBPACK_IMPORTED_MODULE_0___default.a.clearTimeout(this.mediaUpdateTimeout);\n    }\n  }, {\n    key: 'stopRequest',\n    value: function stopRequest() {\n      if (this.request) {\n        var oldRequest = this.request;\n\n        this.request = null;\n        oldRequest.onreadystatechange = null;\n        oldRequest.abort();\n      }\n    }\n\n    /**\n     * When called without any arguments, returns the currently\n     * active media playlist. When called with a single argument,\n     * triggers the playlist loader to asynchronously switch to the\n     * specified media playlist. Calling this method while the\n     * loader is in the HAVE_NOTHING causes an error to be emitted\n     * but otherwise has no effect.\n     *\n     * @param {Object=} playlist the parsed media playlist\n     * object to switch to\n     * @return {Playlist} the current loaded media\n     */\n\n  }, {\n    key: 'media',\n    value: function media(playlist) {\n      var _this3 = this;\n\n      // getter\n      if (!playlist) {\n        return this.media_;\n      }\n\n      // setter\n      if (this.state === 'HAVE_NOTHING') {\n        throw new Error('Cannot switch media playlist from ' + this.state);\n      }\n\n      var startingState = this.state;\n\n      // find the playlist object if the target playlist has been\n      // specified by URI\n      if (typeof playlist === 'string') {\n        if (!this.master.playlists[playlist]) {\n          throw new Error('Unknown playlist URI: ' + playlist);\n        }\n        playlist = this.master.playlists[playlist];\n      }\n\n      var mediaChange = !this.media_ || playlist.uri !== this.media_.uri;\n\n      // switch to fully loaded playlists immediately\n      if (this.master.playlists[playlist.uri].endList) {\n        // abort outstanding playlist requests\n        if (this.request) {\n          this.request.onreadystatechange = null;\n          this.request.abort();\n          this.request = null;\n        }\n        this.state = 'HAVE_METADATA';\n        this.media_ = playlist;\n\n        // trigger media change if the active media has been updated\n        if (mediaChange) {\n          this.trigger('mediachanging');\n          this.trigger('mediachange');\n        }\n        return;\n      }\n\n      // switching to the active playlist is a no-op\n      if (!mediaChange) {\n        return;\n      }\n\n      this.state = 'SWITCHING_MEDIA';\n\n      // there is already an outstanding playlist request\n      if (this.request) {\n        if (resolveUrl(this.master.uri, playlist.uri) === this.request.url) {\n          // requesting to switch to the same playlist multiple times\n          // has no effect after the first\n          return;\n        }\n        this.request.onreadystatechange = null;\n        this.request.abort();\n        this.request = null;\n      }\n\n      // request the new playlist\n      if (this.media_) {\n        this.trigger('mediachanging');\n      }\n\n      this.request = this.hls_.xhr({\n        uri: resolveUrl(this.master.uri, playlist.uri),\n        withCredentials: this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this3.request) {\n          return;\n        }\n\n        if (error) {\n          return _this3.playlistRequestError(_this3.request, playlist.uri, startingState);\n        }\n\n        _this3.haveMetadata(req, playlist.uri);\n\n        // fire loadedmetadata the first time a media playlist is loaded\n        if (startingState === 'HAVE_MASTER') {\n          _this3.trigger('loadedmetadata');\n        } else {\n          _this3.trigger('mediachange');\n        }\n      });\n    }\n\n    /**\n     * pause loading of the playlist\n     */\n\n  }, {\n    key: 'pause',\n    value: function pause() {\n      this.stopRequest();\n      global_window__WEBPACK_IMPORTED_MODULE_0___default.a.clearTimeout(this.mediaUpdateTimeout);\n      if (this.state === 'HAVE_NOTHING') {\n        // If we pause the loader before any data has been retrieved, its as if we never\n        // started, so reset to an unstarted state.\n        this.started = false;\n      }\n      // Need to restore state now that no activity is happening\n      if (this.state === 'SWITCHING_MEDIA') {\n        // if the loader was in the process of switching media, it should either return to\n        // HAVE_MASTER or HAVE_METADATA depending on if the loader has loaded a media\n        // playlist yet. This is determined by the existence of loader.media_\n        if (this.media_) {\n          this.state = 'HAVE_METADATA';\n        } else {\n          this.state = 'HAVE_MASTER';\n        }\n      } else if (this.state === 'HAVE_CURRENT_METADATA') {\n        this.state = 'HAVE_METADATA';\n      }\n    }\n\n    /**\n     * start loading of the playlist\n     */\n\n  }, {\n    key: 'load',\n    value: function load(isFinalRendition) {\n      var _this4 = this;\n\n      global_window__WEBPACK_IMPORTED_MODULE_0___default.a.clearTimeout(this.mediaUpdateTimeout);\n\n      var media = this.media();\n\n      if (isFinalRendition) {\n        var delay = media ? media.targetDuration / 2 * 1000 : 5 * 1000;\n\n        this.mediaUpdateTimeout = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.setTimeout(function () {\n          return _this4.load();\n        }, delay);\n        return;\n      }\n\n      if (!this.started) {\n        this.start();\n        return;\n      }\n\n      if (media && !media.endList) {\n        this.trigger('mediaupdatetimeout');\n      } else {\n        this.trigger('loadedplaylist');\n      }\n    }\n\n    /**\n     * start loading of the playlist\n     */\n\n  }, {\n    key: 'start',\n    value: function start() {\n      var _this5 = this;\n\n      this.started = true;\n\n      // request the specified URL\n      this.request = this.hls_.xhr({\n        uri: this.srcUrl,\n        withCredentials: this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this5.request) {\n          return;\n        }\n\n        // clear the loader's request reference\n        _this5.request = null;\n\n        if (error) {\n          _this5.error = {\n            status: req.status,\n            message: 'HLS playlist request error at URL: ' + _this5.srcUrl,\n            responseText: req.responseText,\n            // MEDIA_ERR_NETWORK\n            code: 2\n          };\n          if (_this5.state === 'HAVE_NOTHING') {\n            _this5.started = false;\n          }\n          return _this5.trigger('error');\n        }\n\n        var parser = new m3u8_parser__WEBPACK_IMPORTED_MODULE_7__[\"Parser\"]();\n\n        parser.push(req.responseText);\n        parser.end();\n\n        _this5.state = 'HAVE_MASTER';\n\n        parser.manifest.uri = _this5.srcUrl;\n\n        // loaded a master playlist\n        if (parser.manifest.playlists) {\n          _this5.master = parser.manifest;\n\n          setupMediaPlaylists(_this5.master);\n          resolveMediaGroupUris(_this5.master);\n\n          _this5.trigger('loadedplaylist');\n          if (!_this5.request) {\n            // no media playlist was specifically selected so start\n            // from the first listed one\n            _this5.media(parser.manifest.playlists[0]);\n          }\n          return;\n        }\n\n        // loaded a media playlist\n        // infer a master playlist if none was previously requested\n        _this5.master = {\n          mediaGroups: {\n            'AUDIO': {},\n            'VIDEO': {},\n            'CLOSED-CAPTIONS': {},\n            'SUBTITLES': {}\n          },\n          uri: global_window__WEBPACK_IMPORTED_MODULE_0___default.a.location.href,\n          playlists: [{\n            uri: _this5.srcUrl,\n            id: 0\n          }]\n        };\n        _this5.master.playlists[_this5.srcUrl] = _this5.master.playlists[0];\n        _this5.master.playlists[0].resolvedUri = _this5.srcUrl;\n        // m3u8-parser does not attach an attributes property to media playlists so make\n        // sure that the property is attached to avoid undefined reference errors\n        _this5.master.playlists[0].attributes = _this5.master.playlists[0].attributes || {};\n        _this5.haveMetadata(req, _this5.srcUrl);\n        return _this5.trigger('loadedmetadata');\n      });\n    }\n  }]);\n  return PlaylistLoader;\n}(EventTarget$1);\n\n/**\n * @file playlist.js\n *\n * Playlist related utilities.\n */\n\nvar createTimeRange = videojs$1.createTimeRange;\n\n/**\n * walk backward until we find a duration we can use\n * or return a failure\n *\n * @param {Playlist} playlist the playlist to walk through\n * @param {Number} endSequence the mediaSequence to stop walking on\n */\n\nvar backwardDuration = function backwardDuration(playlist, endSequence) {\n  var result = 0;\n  var i = endSequence - playlist.mediaSequence;\n  // if a start time is available for segment immediately following\n  // the interval, use it\n  var segment = playlist.segments[i];\n\n  // Walk backward until we find the latest segment with timeline\n  // information that is earlier than endSequence\n  if (segment) {\n    if (typeof segment.start !== 'undefined') {\n      return { result: segment.start, precise: true };\n    }\n    if (typeof segment.end !== 'undefined') {\n      return {\n        result: segment.end - segment.duration,\n        precise: true\n      };\n    }\n  }\n  while (i--) {\n    segment = playlist.segments[i];\n    if (typeof segment.end !== 'undefined') {\n      return { result: result + segment.end, precise: true };\n    }\n\n    result += segment.duration;\n\n    if (typeof segment.start !== 'undefined') {\n      return { result: result + segment.start, precise: true };\n    }\n  }\n  return { result: result, precise: false };\n};\n\n/**\n * walk forward until we find a duration we can use\n * or return a failure\n *\n * @param {Playlist} playlist the playlist to walk through\n * @param {Number} endSequence the mediaSequence to stop walking on\n */\nvar forwardDuration = function forwardDuration(playlist, endSequence) {\n  var result = 0;\n  var segment = void 0;\n  var i = endSequence - playlist.mediaSequence;\n  // Walk forward until we find the earliest segment with timeline\n  // information\n\n  for (; i < playlist.segments.length; i++) {\n    segment = playlist.segments[i];\n    if (typeof segment.start !== 'undefined') {\n      return {\n        result: segment.start - result,\n        precise: true\n      };\n    }\n\n    result += segment.duration;\n\n    if (typeof segment.end !== 'undefined') {\n      return {\n        result: segment.end - result,\n        precise: true\n      };\n    }\n  }\n  // indicate we didn't find a useful duration estimate\n  return { result: -1, precise: false };\n};\n\n/**\n  * Calculate the media duration from the segments associated with a\n  * playlist. The duration of a subinterval of the available segments\n  * may be calculated by specifying an end index.\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {Number=} endSequence an exclusive upper boundary\n  * for the playlist.  Defaults to playlist length.\n  * @param {Number} expired the amount of time that has dropped\n  * off the front of the playlist in a live scenario\n  * @return {Number} the duration between the first available segment\n  * and end index.\n  */\nvar intervalDuration = function intervalDuration(playlist, endSequence, expired) {\n  var backward = void 0;\n  var forward = void 0;\n\n  if (typeof endSequence === 'undefined') {\n    endSequence = playlist.mediaSequence + playlist.segments.length;\n  }\n\n  if (endSequence < playlist.mediaSequence) {\n    return 0;\n  }\n\n  // do a backward walk to estimate the duration\n  backward = backwardDuration(playlist, endSequence);\n  if (backward.precise) {\n    // if we were able to base our duration estimate on timing\n    // information provided directly from the Media Source, return\n    // it\n    return backward.result;\n  }\n\n  // walk forward to see if a precise duration estimate can be made\n  // that way\n  forward = forwardDuration(playlist, endSequence);\n  if (forward.precise) {\n    // we found a segment that has been buffered and so it's\n    // position is known precisely\n    return forward.result;\n  }\n\n  // return the less-precise, playlist-based duration estimate\n  return backward.result + expired;\n};\n\n/**\n  * Calculates the duration of a playlist. If a start and end index\n  * are specified, the duration will be for the subset of the media\n  * timeline between those two indices. The total duration for live\n  * playlists is always Infinity.\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {Number=} endSequence an exclusive upper\n  * boundary for the playlist. Defaults to the playlist media\n  * sequence number plus its length.\n  * @param {Number=} expired the amount of time that has\n  * dropped off the front of the playlist in a live scenario\n  * @return {Number} the duration between the start index and end\n  * index.\n  */\nvar duration = function duration(playlist, endSequence, expired) {\n  if (!playlist) {\n    return 0;\n  }\n\n  if (typeof expired !== 'number') {\n    expired = 0;\n  }\n\n  // if a slice of the total duration is not requested, use\n  // playlist-level duration indicators when they're present\n  if (typeof endSequence === 'undefined') {\n    // if present, use the duration specified in the playlist\n    if (playlist.totalDuration) {\n      return playlist.totalDuration;\n    }\n\n    // duration should be Infinity for live playlists\n    if (!playlist.endList) {\n      return global_window__WEBPACK_IMPORTED_MODULE_0___default.a.Infinity;\n    }\n  }\n\n  // calculate the total duration based on the segment durations\n  return intervalDuration(playlist, endSequence, expired);\n};\n\n/**\n  * Calculate the time between two indexes in the current playlist\n  * neight the start- nor the end-index need to be within the current\n  * playlist in which case, the targetDuration of the playlist is used\n  * to approximate the durations of the segments\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {Number} startIndex\n  * @param {Number} endIndex\n  * @return {Number} the number of seconds between startIndex and endIndex\n  */\nvar sumDurations = function sumDurations(playlist, startIndex, endIndex) {\n  var durations = 0;\n\n  if (startIndex > endIndex) {\n    var _ref = [endIndex, startIndex];\n    startIndex = _ref[0];\n    endIndex = _ref[1];\n  }\n\n  if (startIndex < 0) {\n    for (var i = startIndex; i < Math.min(0, endIndex); i++) {\n      durations += playlist.targetDuration;\n    }\n    startIndex = 0;\n  }\n\n  for (var _i = startIndex; _i < endIndex; _i++) {\n    durations += playlist.segments[_i].duration;\n  }\n\n  return durations;\n};\n\n/**\n * Determines the media index of the segment corresponding to the safe edge of the live\n * window which is the duration of the last segment plus 2 target durations from the end\n * of the playlist.\n *\n * @param {Object} playlist\n *        a media playlist object\n * @return {Number}\n *         The media index of the segment at the safe live point. 0 if there is no \"safe\"\n *         point.\n * @function safeLiveIndex\n */\nvar safeLiveIndex = function safeLiveIndex(playlist) {\n  if (!playlist.segments.length) {\n    return 0;\n  }\n\n  var i = playlist.segments.length - 1;\n  var distanceFromEnd = playlist.segments[i].duration || playlist.targetDuration;\n  var safeDistance = distanceFromEnd + playlist.targetDuration * 2;\n\n  while (i--) {\n    distanceFromEnd += playlist.segments[i].duration;\n\n    if (distanceFromEnd >= safeDistance) {\n      break;\n    }\n  }\n\n  return Math.max(0, i);\n};\n\n/**\n * Calculates the playlist end time\n *\n * @param {Object} playlist a media playlist object\n * @param {Number=} expired the amount of time that has\n *                  dropped off the front of the playlist in a live scenario\n * @param {Boolean|false} useSafeLiveEnd a boolean value indicating whether or not the\n *                        playlist end calculation should consider the safe live end\n *                        (truncate the playlist end by three segments). This is normally\n *                        used for calculating the end of the playlist's seekable range.\n * @returns {Number} the end time of playlist\n * @function playlistEnd\n */\nvar playlistEnd = function playlistEnd(playlist, expired, useSafeLiveEnd) {\n  if (!playlist || !playlist.segments) {\n    return null;\n  }\n  if (playlist.endList) {\n    return duration(playlist);\n  }\n\n  if (expired === null) {\n    return null;\n  }\n\n  expired = expired || 0;\n\n  var endSequence = useSafeLiveEnd ? safeLiveIndex(playlist) : playlist.segments.length;\n\n  return intervalDuration(playlist, playlist.mediaSequence + endSequence, expired);\n};\n\n/**\n  * Calculates the interval of time that is currently seekable in a\n  * playlist. The returned time ranges are relative to the earliest\n  * moment in the specified playlist that is still available. A full\n  * seekable implementation for live streams would need to offset\n  * these values by the duration of content that has expired from the\n  * stream.\n  *\n  * @param {Object} playlist a media playlist object\n  * dropped off the front of the playlist in a live scenario\n  * @param {Number=} expired the amount of time that has\n  * dropped off the front of the playlist in a live scenario\n  * @return {TimeRanges} the periods of time that are valid targets\n  * for seeking\n  */\nvar seekable = function seekable(playlist, expired) {\n  var useSafeLiveEnd = true;\n  var seekableStart = expired || 0;\n  var seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd);\n\n  if (seekableEnd === null) {\n    return createTimeRange();\n  }\n  return createTimeRange(seekableStart, seekableEnd);\n};\n\nvar isWholeNumber = function isWholeNumber(num) {\n  return num - Math.floor(num) === 0;\n};\n\nvar roundSignificantDigit = function roundSignificantDigit(increment, num) {\n  // If we have a whole number, just add 1 to it\n  if (isWholeNumber(num)) {\n    return num + increment * 0.1;\n  }\n\n  var numDecimalDigits = num.toString().split('.')[1].length;\n\n  for (var i = 1; i <= numDecimalDigits; i++) {\n    var scale = Math.pow(10, i);\n    var temp = num * scale;\n\n    if (isWholeNumber(temp) || i === numDecimalDigits) {\n      return (temp + increment) / scale;\n    }\n  }\n};\n\nvar ceilLeastSignificantDigit = roundSignificantDigit.bind(null, 1);\nvar floorLeastSignificantDigit = roundSignificantDigit.bind(null, -1);\n\n/**\n * Determine the index and estimated starting time of the segment that\n * contains a specified playback position in a media playlist.\n *\n * @param {Object} playlist the media playlist to query\n * @param {Number} currentTime The number of seconds since the earliest\n * possible position to determine the containing segment for\n * @param {Number} startIndex\n * @param {Number} startTime\n * @return {Object}\n */\nvar getMediaInfoForTime = function getMediaInfoForTime(playlist, currentTime, startIndex, startTime) {\n  var i = void 0;\n  var segment = void 0;\n  var numSegments = playlist.segments.length;\n\n  var time = currentTime - startTime;\n\n  if (time < 0) {\n    // Walk backward from startIndex in the playlist, adding durations\n    // until we find a segment that contains `time` and return it\n    if (startIndex > 0) {\n      for (i = startIndex - 1; i >= 0; i--) {\n        segment = playlist.segments[i];\n        time += floorLeastSignificantDigit(segment.duration);\n        if (time > 0) {\n          return {\n            mediaIndex: i,\n            startTime: startTime - sumDurations(playlist, startIndex, i)\n          };\n        }\n      }\n    }\n    // We were unable to find a good segment within the playlist\n    // so select the first segment\n    return {\n      mediaIndex: 0,\n      startTime: currentTime\n    };\n  }\n\n  // When startIndex is negative, we first walk forward to first segment\n  // adding target durations. If we \"run out of time\" before getting to\n  // the first segment, return the first segment\n  if (startIndex < 0) {\n    for (i = startIndex; i < 0; i++) {\n      time -= playlist.targetDuration;\n      if (time < 0) {\n        return {\n          mediaIndex: 0,\n          startTime: currentTime\n        };\n      }\n    }\n    startIndex = 0;\n  }\n\n  // Walk forward from startIndex in the playlist, subtracting durations\n  // until we find a segment that contains `time` and return it\n  for (i = startIndex; i < numSegments; i++) {\n    segment = playlist.segments[i];\n    time -= ceilLeastSignificantDigit(segment.duration);\n    if (time < 0) {\n      return {\n        mediaIndex: i,\n        startTime: startTime + sumDurations(playlist, startIndex, i)\n      };\n    }\n  }\n\n  // We are out of possible candidates so load the last one...\n  return {\n    mediaIndex: numSegments - 1,\n    startTime: currentTime\n  };\n};\n\n/**\n * Check whether the playlist is blacklisted or not.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is blacklisted or not\n * @function isBlacklisted\n */\nvar isBlacklisted = function isBlacklisted(playlist) {\n  return playlist.excludeUntil && playlist.excludeUntil > Date.now();\n};\n\n/**\n * Check whether the playlist is compatible with current playback configuration or has\n * been blacklisted permanently for being incompatible.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is incompatible or not\n * @function isIncompatible\n */\nvar isIncompatible = function isIncompatible(playlist) {\n  return playlist.excludeUntil && playlist.excludeUntil === Infinity;\n};\n\n/**\n * Check whether the playlist is enabled or not.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is enabled or not\n * @function isEnabled\n */\nvar isEnabled = function isEnabled(playlist) {\n  var blacklisted = isBlacklisted(playlist);\n\n  return !playlist.disabled && !blacklisted;\n};\n\n/**\n * Check whether the playlist has been manually disabled through the representations api.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is disabled manually or not\n * @function isDisabled\n */\nvar isDisabled = function isDisabled(playlist) {\n  return playlist.disabled;\n};\n\n/**\n * Returns whether the current playlist is an AES encrypted HLS stream\n *\n * @return {Boolean} true if it's an AES encrypted HLS stream\n */\nvar isAes = function isAes(media) {\n  for (var i = 0; i < media.segments.length; i++) {\n    if (media.segments[i].key) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns whether the current playlist contains fMP4\n *\n * @return {Boolean} true if the playlist contains fMP4\n */\nvar isFmp4 = function isFmp4(media) {\n  for (var i = 0; i < media.segments.length; i++) {\n    if (media.segments[i].map) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Checks if the playlist has a value for the specified attribute\n *\n * @param {String} attr\n *        Attribute to check for\n * @param {Object} playlist\n *        The media playlist object\n * @return {Boolean}\n *         Whether the playlist contains a value for the attribute or not\n * @function hasAttribute\n */\nvar hasAttribute = function hasAttribute(attr, playlist) {\n  return playlist.attributes && playlist.attributes[attr];\n};\n\n/**\n * Estimates the time required to complete a segment download from the specified playlist\n *\n * @param {Number} segmentDuration\n *        Duration of requested segment\n * @param {Number} bandwidth\n *        Current measured bandwidth of the player\n * @param {Object} playlist\n *        The media playlist object\n * @param {Number=} bytesReceived\n *        Number of bytes already received for the request. Defaults to 0\n * @return {Number|NaN}\n *         The estimated time to request the segment. NaN if bandwidth information for\n *         the given playlist is unavailable\n * @function estimateSegmentRequestTime\n */\nvar estimateSegmentRequestTime = function estimateSegmentRequestTime(segmentDuration, bandwidth, playlist) {\n  var bytesReceived = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  if (!hasAttribute('BANDWIDTH', playlist)) {\n    return NaN;\n  }\n\n  var size = segmentDuration * playlist.attributes.BANDWIDTH;\n\n  return (size - bytesReceived * 8) / bandwidth;\n};\n\n/*\n * Returns whether the current playlist is the lowest rendition\n *\n * @return {Boolean} true if on lowest rendition\n */\nvar isLowestEnabledRendition = function isLowestEnabledRendition(master, media) {\n  if (master.playlists.length === 1) {\n    return true;\n  }\n\n  var currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;\n\n  return master.playlists.filter(function (playlist) {\n    if (!isEnabled(playlist)) {\n      return false;\n    }\n\n    return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;\n  }).length === 0;\n};\n\n// exports\nvar Playlist = {\n  duration: duration,\n  seekable: seekable,\n  safeLiveIndex: safeLiveIndex,\n  getMediaInfoForTime: getMediaInfoForTime,\n  isEnabled: isEnabled,\n  isDisabled: isDisabled,\n  isBlacklisted: isBlacklisted,\n  isIncompatible: isIncompatible,\n  playlistEnd: playlistEnd,\n  isAes: isAes,\n  isFmp4: isFmp4,\n  hasAttribute: hasAttribute,\n  estimateSegmentRequestTime: estimateSegmentRequestTime,\n  isLowestEnabledRendition: isLowestEnabledRendition\n};\n\n/**\n * @file xhr.js\n */\n\nvar videojsXHR = videojs$1.xhr,\n    mergeOptions$1$1 = videojs$1.mergeOptions;\n\nvar xhrFactory = function xhrFactory() {\n  var xhr$$1 = function XhrFunction(options, callback) {\n    // Add a default timeout for all hls requests\n    options = mergeOptions$1$1({\n      timeout: 45e3\n    }, options);\n\n    // Allow an optional user-specified function to modify the option\n    // object before we construct the xhr request\n    var beforeRequest = XhrFunction.beforeRequest || videojs$1.Hls.xhr.beforeRequest;\n\n    if (beforeRequest && typeof beforeRequest === 'function') {\n      var newOptions = beforeRequest(options);\n\n      if (newOptions) {\n        options = newOptions;\n      }\n    }\n\n    var request = videojsXHR(options, function (error, response) {\n      var reqResponse = request.response;\n\n      if (!error && reqResponse) {\n        request.responseTime = Date.now();\n        request.roundTripTime = request.responseTime - request.requestTime;\n        request.bytesReceived = reqResponse.byteLength || reqResponse.length;\n        if (!request.bandwidth) {\n          request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1000);\n        }\n      }\n\n      if (response.headers) {\n        request.responseHeaders = response.headers;\n      }\n\n      // videojs.xhr now uses a specific code on the error\n      // object to signal that a request has timed out instead\n      // of setting a boolean on the request object\n      if (error && error.code === 'ETIMEDOUT') {\n        request.timedout = true;\n      }\n\n      // videojs.xhr no longer considers status codes outside of 200 and 0\n      // (for file uris) to be errors, but the old XHR did, so emulate that\n      // behavior. Status 206 may be used in response to byterange requests.\n      if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {\n        error = new Error('XHR Failed with a response of: ' + (request && (reqResponse || request.responseText)));\n      }\n\n      callback(error, request);\n    });\n    var originalAbort = request.abort;\n\n    request.abort = function () {\n      request.aborted = true;\n      return originalAbort.apply(request, arguments);\n    };\n    request.uri = options.uri;\n    request.requestTime = Date.now();\n    return request;\n  };\n\n  return xhr$$1;\n};\n\n/**\n * @file bin-utils.js\n */\n\n/**\n * convert a TimeRange to text\n *\n * @param {TimeRange} range the timerange to use for conversion\n * @param {Number} i the iterator on the range to convert\n */\nvar textRange = function textRange(range, i) {\n  return range.start(i) + '-' + range.end(i);\n};\n\n/**\n * format a number as hex string\n *\n * @param {Number} e The number\n * @param {Number} i the iterator\n */\nvar formatHexString = function formatHexString(e, i) {\n  var value = e.toString(16);\n\n  return '00'.substring(0, 2 - value.length) + value + (i % 2 ? ' ' : '');\n};\nvar formatAsciiString = function formatAsciiString(e) {\n  if (e >= 0x20 && e < 0x7e) {\n    return String.fromCharCode(e);\n  }\n  return '.';\n};\n\n/**\n * Creates an object for sending to a web worker modifying properties that are TypedArrays\n * into a new object with seperated properties for the buffer, byteOffset, and byteLength.\n *\n * @param {Object} message\n *        Object of properties and values to send to the web worker\n * @return {Object}\n *         Modified message with TypedArray values expanded\n * @function createTransferableMessage\n */\nvar createTransferableMessage = function createTransferableMessage(message) {\n  var transferable = {};\n\n  Object.keys(message).forEach(function (key) {\n    var value = message[key];\n\n    if (ArrayBuffer.isView(value)) {\n      transferable[key] = {\n        bytes: value.buffer,\n        byteOffset: value.byteOffset,\n        byteLength: value.byteLength\n      };\n    } else {\n      transferable[key] = value;\n    }\n  });\n\n  return transferable;\n};\n\n/**\n * Returns a unique string identifier for a media initialization\n * segment.\n */\nvar initSegmentId = function initSegmentId(initSegment) {\n  var byterange = initSegment.byterange || {\n    length: Infinity,\n    offset: 0\n  };\n\n  return [byterange.length, byterange.offset, initSegment.resolvedUri].join(',');\n};\n\n/**\n * utils to help dump binary data to the console\n */\nvar hexDump = function hexDump(data) {\n  var bytes = Array.prototype.slice.call(data);\n  var step = 16;\n  var result = '';\n  var hex = void 0;\n  var ascii = void 0;\n\n  for (var j = 0; j < bytes.length / step; j++) {\n    hex = bytes.slice(j * step, j * step + step).map(formatHexString).join('');\n    ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join('');\n    result += hex + ' ' + ascii + '\\n';\n  }\n\n  return result;\n};\n\nvar tagDump = function tagDump(_ref) {\n  var bytes = _ref.bytes;\n  return hexDump(bytes);\n};\n\nvar textRanges = function textRanges(ranges) {\n  var result = '';\n  var i = void 0;\n\n  for (i = 0; i < ranges.length; i++) {\n    result += textRange(ranges, i) + ' ';\n  }\n  return result;\n};\n\nvar utils = /*#__PURE__*/Object.freeze({\n  createTransferableMessage: createTransferableMessage,\n  initSegmentId: initSegmentId,\n  hexDump: hexDump,\n  tagDump: tagDump,\n  textRanges: textRanges\n});\n\n/**\n * ranges\n *\n * Utilities for working with TimeRanges.\n *\n */\n\n// Fudge factor to account for TimeRanges rounding\nvar TIME_FUDGE_FACTOR = 1 / 30;\n// Comparisons between time values such as current time and the end of the buffered range\n// can be misleading because of precision differences or when the current media has poorly\n// aligned audio and video, which can cause values to be slightly off from what you would\n// expect. This value is what we consider to be safe to use in such comparisons to account\n// for these scenarios.\nvar SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;\nvar filterRanges = function filterRanges(timeRanges, predicate) {\n  var results = [];\n  var i = void 0;\n\n  if (timeRanges && timeRanges.length) {\n    // Search for ranges that match the predicate\n    for (i = 0; i < timeRanges.length; i++) {\n      if (predicate(timeRanges.start(i), timeRanges.end(i))) {\n        results.push([timeRanges.start(i), timeRanges.end(i)]);\n      }\n    }\n  }\n\n  return videojs$1.createTimeRanges(results);\n};\n\n/**\n * Attempts to find the buffered TimeRange that contains the specified\n * time.\n * @param {TimeRanges} buffered - the TimeRanges object to query\n * @param {number} time  - the time to filter on.\n * @returns {TimeRanges} a new TimeRanges object\n */\nvar findRange = function findRange(buffered, time) {\n  return filterRanges(buffered, function (start, end) {\n    return start - TIME_FUDGE_FACTOR <= time && end + TIME_FUDGE_FACTOR >= time;\n  });\n};\n\n/**\n * Returns the TimeRanges that begin later than the specified time.\n * @param {TimeRanges} timeRanges - the TimeRanges object to query\n * @param {number} time - the time to filter on.\n * @returns {TimeRanges} a new TimeRanges object.\n */\nvar findNextRange = function findNextRange(timeRanges, time) {\n  return filterRanges(timeRanges, function (start) {\n    return start - TIME_FUDGE_FACTOR >= time;\n  });\n};\n\n/**\n * Returns gaps within a list of TimeRanges\n * @param {TimeRanges} buffered - the TimeRanges object\n * @return {TimeRanges} a TimeRanges object of gaps\n */\nvar findGaps = function findGaps(buffered) {\n  if (buffered.length < 2) {\n    return videojs$1.createTimeRanges();\n  }\n\n  var ranges = [];\n\n  for (var i = 1; i < buffered.length; i++) {\n    var start = buffered.end(i - 1);\n    var end = buffered.start(i);\n\n    ranges.push([start, end]);\n  }\n\n  return videojs$1.createTimeRanges(ranges);\n};\n\n/**\n * Gets a human readable string for a TimeRange\n *\n * @param {TimeRange} range\n * @returns {String} a human readable string\n */\nvar printableRange = function printableRange(range) {\n  var strArr = [];\n\n  if (!range || !range.length) {\n    return '';\n  }\n\n  for (var i = 0; i < range.length; i++) {\n    strArr.push(range.start(i) + ' => ' + range.end(i));\n  }\n\n  return strArr.join(', ');\n};\n\n/**\n * Calculates the amount of time left in seconds until the player hits the end of the\n * buffer and causes a rebuffer\n *\n * @param {TimeRange} buffered\n *        The state of the buffer\n * @param {Numnber} currentTime\n *        The current time of the player\n * @param {Number} playbackRate\n *        The current playback rate of the player. Defaults to 1.\n * @return {Number}\n *         Time until the player has to start rebuffering in seconds.\n * @function timeUntilRebuffer\n */\nvar timeUntilRebuffer = function timeUntilRebuffer(buffered, currentTime) {\n  var playbackRate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n  var bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;\n\n  return (bufferedEnd - currentTime) / playbackRate;\n};\n\n/**\n * Converts a TimeRanges object into an array representation\n * @param {TimeRanges} timeRanges\n * @returns {Array}\n */\nvar timeRangesToArray = function timeRangesToArray(timeRanges) {\n  var timeRangesList = [];\n\n  for (var i = 0; i < timeRanges.length; i++) {\n    timeRangesList.push({\n      start: timeRanges.start(i),\n      end: timeRanges.end(i)\n    });\n  }\n\n  return timeRangesList;\n};\n\n/**\n * @file create-text-tracks-if-necessary.js\n */\n\n/**\n * Create text tracks on video.js if they exist on a segment.\n *\n * @param {Object} sourceBuffer the VSB or FSB\n * @param {Object} mediaSource the HTML media source\n * @param {Object} segment the segment that may contain the text track\n * @private\n */\nvar createTextTracksIfNecessary = function createTextTracksIfNecessary(sourceBuffer, mediaSource, segment) {\n  var player = mediaSource.player_;\n\n  // create an in-band caption track if one is present in the segment\n  if (segment.captions && segment.captions.length) {\n    if (!sourceBuffer.inbandTextTracks_) {\n      sourceBuffer.inbandTextTracks_ = {};\n    }\n\n    for (var trackId in segment.captionStreams) {\n      if (!sourceBuffer.inbandTextTracks_[trackId]) {\n        player.tech_.trigger({ type: 'usage', name: 'hls-608' });\n        var track = player.textTracks().getTrackById(trackId);\n\n        if (track) {\n          // Resuse an existing track with a CC# id because this was\n          // very likely created by videojs-contrib-hls from information\n          // in the m3u8 for us to use\n          sourceBuffer.inbandTextTracks_[trackId] = track;\n        } else {\n          // Otherwise, create a track with the default `CC#` label and\n          // without a language\n          sourceBuffer.inbandTextTracks_[trackId] = player.addRemoteTextTrack({\n            kind: 'captions',\n            id: trackId,\n            label: trackId\n          }, false).track;\n        }\n      }\n    }\n  }\n\n  if (segment.metadata && segment.metadata.length && !sourceBuffer.metadataTrack_) {\n    sourceBuffer.metadataTrack_ = player.addRemoteTextTrack({\n      kind: 'metadata',\n      label: 'Timed Metadata'\n    }, false).track;\n    sourceBuffer.metadataTrack_.inBandMetadataTrackDispatchType = segment.metadata.dispatchType;\n  }\n};\n\n/**\n * @file remove-cues-from-track.js\n */\n\n/**\n * Remove cues from a track on video.js.\n *\n * @param {Double} start start of where we should remove the cue\n * @param {Double} end end of where the we should remove the cue\n * @param {Object} track the text track to remove the cues from\n * @private\n */\nvar removeCuesFromTrack = function removeCuesFromTrack(start, end, track) {\n  var i = void 0;\n  var cue = void 0;\n\n  if (!track) {\n    return;\n  }\n\n  if (!track.cues) {\n    return;\n  }\n\n  i = track.cues.length;\n\n  while (i--) {\n    cue = track.cues[i];\n\n    // Remove any overlapping cue\n    if (cue.startTime <= end && cue.endTime >= start) {\n      track.removeCue(cue);\n    }\n  }\n};\n\n/**\n * @file add-text-track-data.js\n */\n/**\n * Define properties on a cue for backwards compatability,\n * but warn the user that the way that they are using it\n * is depricated and will be removed at a later date.\n *\n * @param {Cue} cue the cue to add the properties on\n * @private\n */\nvar deprecateOldCue = function deprecateOldCue(cue) {\n  Object.defineProperties(cue.frame, {\n    id: {\n      get: function get$$1() {\n        videojs$1.log.warn('cue.frame.id is deprecated. Use cue.value.key instead.');\n        return cue.value.key;\n      }\n    },\n    value: {\n      get: function get$$1() {\n        videojs$1.log.warn('cue.frame.value is deprecated. Use cue.value.data instead.');\n        return cue.value.data;\n      }\n    },\n    privateData: {\n      get: function get$$1() {\n        videojs$1.log.warn('cue.frame.privateData is deprecated. Use cue.value.data instead.');\n        return cue.value.data;\n      }\n    }\n  });\n};\n\nvar durationOfVideo = function durationOfVideo(duration) {\n  var dur = void 0;\n\n  if (isNaN(duration) || Math.abs(duration) === Infinity) {\n    dur = Number.MAX_VALUE;\n  } else {\n    dur = duration;\n  }\n  return dur;\n};\n/**\n * Add text track data to a source handler given the captions and\n * metadata from the buffer.\n *\n * @param {Object} sourceHandler the virtual source buffer\n * @param {Array} captionArray an array of caption data\n * @param {Array} metadataArray an array of meta data\n * @private\n */\nvar addTextTrackData = function addTextTrackData(sourceHandler, captionArray, metadataArray) {\n  var Cue = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.WebKitDataCue || global_window__WEBPACK_IMPORTED_MODULE_0___default.a.VTTCue;\n\n  if (captionArray) {\n    captionArray.forEach(function (caption) {\n      var track = caption.stream;\n\n      this.inbandTextTracks_[track].addCue(new Cue(caption.startTime + this.timestampOffset, caption.endTime + this.timestampOffset, caption.text));\n    }, sourceHandler);\n  }\n\n  if (metadataArray) {\n    var videoDuration = durationOfVideo(sourceHandler.mediaSource_.duration);\n\n    metadataArray.forEach(function (metadata) {\n      var time = metadata.cueTime + this.timestampOffset;\n\n      metadata.frames.forEach(function (frame) {\n        var cue = new Cue(time, time, frame.value || frame.url || frame.data || '');\n\n        cue.frame = frame;\n        cue.value = frame;\n        deprecateOldCue(cue);\n\n        this.metadataTrack_.addCue(cue);\n      }, this);\n    }, sourceHandler);\n\n    // Updating the metadeta cues so that\n    // the endTime of each cue is the startTime of the next cue\n    // the endTime of last cue is the duration of the video\n    if (sourceHandler.metadataTrack_ && sourceHandler.metadataTrack_.cues && sourceHandler.metadataTrack_.cues.length) {\n      var cues = sourceHandler.metadataTrack_.cues;\n      var cuesArray = [];\n\n      // Create a copy of the TextTrackCueList...\n      // ...disregarding cues with a falsey value\n      for (var i = 0; i < cues.length; i++) {\n        if (cues[i]) {\n          cuesArray.push(cues[i]);\n        }\n      }\n\n      // Group cues by their startTime value\n      var cuesGroupedByStartTime = cuesArray.reduce(function (obj, cue) {\n        var timeSlot = obj[cue.startTime] || [];\n\n        timeSlot.push(cue);\n        obj[cue.startTime] = timeSlot;\n\n        return obj;\n      }, {});\n\n      // Sort startTimes by ascending order\n      var sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort(function (a, b) {\n        return Number(a) - Number(b);\n      });\n\n      // Map each cue group's endTime to the next group's startTime\n      sortedStartTimes.forEach(function (startTime, idx) {\n        var cueGroup = cuesGroupedByStartTime[startTime];\n        var nextTime = Number(sortedStartTimes[idx + 1]) || videoDuration;\n\n        // Map each cue's endTime the next group's startTime\n        cueGroup.forEach(function (cue) {\n          cue.endTime = nextTime;\n        });\n      });\n    }\n  }\n};\n\nvar win = typeof window !== 'undefined' ? window : {},\n    TARGET = typeof Symbol === 'undefined' ? '__target' : Symbol(),\n    SCRIPT_TYPE = 'application/javascript',\n    BlobBuilder = win.BlobBuilder || win.WebKitBlobBuilder || win.MozBlobBuilder || win.MSBlobBuilder,\n    URL = win.URL || win.webkitURL || URL && URL.msURL,\n    Worker = win.Worker;\n\n/**\n * Returns a wrapper around Web Worker code that is constructible.\n *\n * @function shimWorker\n *\n * @param { String }    filename    The name of the file\n * @param { Function }  fn          Function wrapping the code of the worker\n */\nfunction shimWorker(filename, fn) {\n  return function ShimWorker(forceFallback) {\n    var o = this;\n\n    if (!fn) {\n      return new Worker(filename);\n    } else if (Worker && !forceFallback) {\n      // Convert the function's inner code to a string to construct the worker\n      var source = fn.toString().replace(/^function.+?{/, '').slice(0, -1),\n          objURL = createSourceObject(source);\n\n      this[TARGET] = new Worker(objURL);\n      wrapTerminate(this[TARGET], objURL);\n      return this[TARGET];\n    } else {\n      var selfShim = {\n        postMessage: function postMessage(m) {\n          if (o.onmessage) {\n            setTimeout(function () {\n              o.onmessage({ data: m, target: selfShim });\n            });\n          }\n        }\n      };\n\n      fn.call(selfShim);\n      this.postMessage = function (m) {\n        setTimeout(function () {\n          selfShim.onmessage({ data: m, target: o });\n        });\n      };\n      this.isThisThread = true;\n    }\n  };\n}\n// Test Worker capabilities\nif (Worker) {\n  var testWorker,\n      objURL = createSourceObject('self.onmessage = function () {}'),\n      testArray = new Uint8Array(1);\n\n  try {\n    testWorker = new Worker(objURL);\n\n    // Native browser on some Samsung devices throws for transferables, let's detect it\n    testWorker.postMessage(testArray, [testArray.buffer]);\n  } catch (e) {\n    Worker = null;\n  } finally {\n    URL.revokeObjectURL(objURL);\n    if (testWorker) {\n      testWorker.terminate();\n    }\n  }\n}\n\nfunction createSourceObject(str) {\n  try {\n    return URL.createObjectURL(new Blob([str], { type: SCRIPT_TYPE }));\n  } catch (e) {\n    var blob = new BlobBuilder();\n    blob.append(str);\n    return URL.createObjectURL(blob.getBlob(type));\n  }\n}\n\nfunction wrapTerminate(worker, objURL) {\n  if (!worker || !objURL) return;\n  var term = worker.terminate;\n  worker.objURL = objURL;\n  worker.terminate = function () {\n    if (worker.objURL) URL.revokeObjectURL(worker.objURL);\n    term.call(worker);\n  };\n}\n\nvar TransmuxWorker = new shimWorker(\"./transmuxer-worker.worker.js\", function (window, document$$1) {\n  var self = this;\n  var transmuxerWorker = function () {\n\n    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n    var win;\n\n    if (typeof window !== \"undefined\") {\n      win = window;\n    } else if (typeof commonjsGlobal !== \"undefined\") {\n      win = commonjsGlobal;\n    } else if (typeof self !== \"undefined\") {\n      win = self;\n    } else {\n      win = {};\n    }\n\n    var window_1 = win;\n\n    /**\n     * mux.js\n     *\n     * Copyright (c) 2015 Brightcove\n     * All rights reserved.\n     *\n     * Functions that generate fragmented MP4s suitable for use with Media\n     * Source Extensions.\n     */\n\n    var UINT32_MAX = Math.pow(2, 32) - 1;\n\n    var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;\n\n    // pre-calculate constants\n    (function () {\n      var i;\n      types = {\n        avc1: [], // codingname\n        avcC: [],\n        btrt: [],\n        dinf: [],\n        dref: [],\n        esds: [],\n        ftyp: [],\n        hdlr: [],\n        mdat: [],\n        mdhd: [],\n        mdia: [],\n        mfhd: [],\n        minf: [],\n        moof: [],\n        moov: [],\n        mp4a: [], // codingname\n        mvex: [],\n        mvhd: [],\n        sdtp: [],\n        smhd: [],\n        stbl: [],\n        stco: [],\n        stsc: [],\n        stsd: [],\n        stsz: [],\n        stts: [],\n        styp: [],\n        tfdt: [],\n        tfhd: [],\n        traf: [],\n        trak: [],\n        trun: [],\n        trex: [],\n        tkhd: [],\n        vmhd: []\n      };\n\n      // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n      // don't throw an error\n      if (typeof Uint8Array === 'undefined') {\n        return;\n      }\n\n      for (i in types) {\n        if (types.hasOwnProperty(i)) {\n          types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n        }\n      }\n\n      MAJOR_BRAND = new Uint8Array(['i'.charCodeAt(0), 's'.charCodeAt(0), 'o'.charCodeAt(0), 'm'.charCodeAt(0)]);\n      AVC1_BRAND = new Uint8Array(['a'.charCodeAt(0), 'v'.charCodeAt(0), 'c'.charCodeAt(0), '1'.charCodeAt(0)]);\n      MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n      VIDEO_HDLR = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n      ]);\n      AUDIO_HDLR = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n      ]);\n      HDLR_TYPES = {\n        video: VIDEO_HDLR,\n        audio: AUDIO_HDLR\n      };\n      DREF = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // entry_count\n      0x00, 0x00, 0x00, 0x0c, // entry_size\n      0x75, 0x72, 0x6c, 0x20, // 'url' type\n      0x00, // version 0\n      0x00, 0x00, 0x01 // entry_flags\n      ]);\n      SMHD = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, // balance, 0 means centered\n      0x00, 0x00 // reserved\n      ]);\n      STCO = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00 // entry_count\n      ]);\n      STSC = STCO;\n      STSZ = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // sample_size\n      0x00, 0x00, 0x00, 0x00 // sample_count\n      ]);\n      STTS = STCO;\n      VMHD = new Uint8Array([0x00, // version\n      0x00, 0x00, 0x01, // flags\n      0x00, 0x00, // graphicsmode\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n      ]);\n    })();\n\n    box = function box(type) {\n      var payload = [],\n          size = 0,\n          i,\n          result,\n          view;\n\n      for (i = 1; i < arguments.length; i++) {\n        payload.push(arguments[i]);\n      }\n\n      i = payload.length;\n\n      // calculate the total size we need to allocate\n      while (i--) {\n        size += payload[i].byteLength;\n      }\n      result = new Uint8Array(size + 8);\n      view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n      view.setUint32(0, result.byteLength);\n      result.set(type, 4);\n\n      // copy the payload into the result\n      for (i = 0, size = 8; i < payload.length; i++) {\n        result.set(payload[i], size);\n        size += payload[i].byteLength;\n      }\n      return result;\n    };\n\n    dinf = function dinf() {\n      return box(types.dinf, box(types.dref, DREF));\n    };\n\n    esds = function esds(track) {\n      return box(types.esds, new Uint8Array([0x00, // version\n      0x00, 0x00, 0x00, // flags\n\n      // ES_Descriptor\n      0x03, // tag, ES_DescrTag\n      0x19, // length\n      0x00, 0x00, // ES_ID\n      0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n\n      // DecoderConfigDescriptor\n      0x04, // tag, DecoderConfigDescrTag\n      0x11, // length\n      0x40, // object type\n      0x15, // streamType\n      0x00, 0x06, 0x00, // bufferSizeDB\n      0x00, 0x00, 0xda, 0xc0, // maxBitrate\n      0x00, 0x00, 0xda, 0xc0, // avgBitrate\n\n      // DecoderSpecificInfo\n      0x05, // tag, DecoderSpecificInfoTag\n      0x02, // length\n      // ISO/IEC 14496-3, AudioSpecificConfig\n      // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n      track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1, track.samplingfrequencyindex << 7 | track.channelcount << 3, 0x06, 0x01, 0x02 // GASpecificConfig\n      ]));\n    };\n\n    ftyp = function ftyp() {\n      return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n    };\n\n    hdlr = function hdlr(type) {\n      return box(types.hdlr, HDLR_TYPES[type]);\n    };\n    mdat = function mdat(data) {\n      return box(types.mdat, data);\n    };\n    mdhd = function mdhd(track) {\n      var result = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x02, // creation_time\n      0x00, 0x00, 0x00, 0x03, // modification_time\n      0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n\n      track.duration >>> 24 & 0xFF, track.duration >>> 16 & 0xFF, track.duration >>> 8 & 0xFF, track.duration & 0xFF, // duration\n      0x55, 0xc4, // 'und' language (undetermined)\n      0x00, 0x00]);\n\n      // Use the sample rate from the track metadata, when it is\n      // defined. The sample rate can be parsed out of an ADTS header, for\n      // instance.\n      if (track.samplerate) {\n        result[12] = track.samplerate >>> 24 & 0xFF;\n        result[13] = track.samplerate >>> 16 & 0xFF;\n        result[14] = track.samplerate >>> 8 & 0xFF;\n        result[15] = track.samplerate & 0xFF;\n      }\n\n      return box(types.mdhd, result);\n    };\n    mdia = function mdia(track) {\n      return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n    };\n    mfhd = function mfhd(sequenceNumber) {\n      return box(types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags\n      (sequenceNumber & 0xFF000000) >> 24, (sequenceNumber & 0xFF0000) >> 16, (sequenceNumber & 0xFF00) >> 8, sequenceNumber & 0xFF // sequence_number\n      ]));\n    };\n    minf = function minf(track) {\n      return box(types.minf, track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));\n    };\n    moof = function moof(sequenceNumber, tracks) {\n      var trackFragments = [],\n          i = tracks.length;\n      // build traf boxes for each track fragment\n      while (i--) {\n        trackFragments[i] = traf(tracks[i]);\n      }\n      return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));\n    };\n    /**\n     * Returns a movie box.\n     * @param tracks {array} the tracks associated with this movie\n     * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n     */\n    moov = function moov(tracks) {\n      var i = tracks.length,\n          boxes = [];\n\n      while (i--) {\n        boxes[i] = trak(tracks[i]);\n      }\n\n      return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n    };\n    mvex = function mvex(tracks) {\n      var i = tracks.length,\n          boxes = [];\n\n      while (i--) {\n        boxes[i] = trex(tracks[i]);\n      }\n      return box.apply(null, [types.mvex].concat(boxes));\n    };\n    mvhd = function mvhd(duration) {\n      var bytes = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // creation_time\n      0x00, 0x00, 0x00, 0x02, // modification_time\n      0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n      (duration & 0xFF000000) >> 24, (duration & 0xFF0000) >> 16, (duration & 0xFF00) >> 8, duration & 0xFF, // duration\n      0x00, 0x01, 0x00, 0x00, // 1.0 rate\n      0x01, 0x00, // 1.0 volume\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n      0xff, 0xff, 0xff, 0xff // next_track_ID\n      ]);\n      return box(types.mvhd, bytes);\n    };\n\n    sdtp = function sdtp(track) {\n      var samples = track.samples || [],\n          bytes = new Uint8Array(4 + samples.length),\n          flags,\n          i;\n\n      // leave the full box header (4 bytes) all zero\n\n      // write the sample table\n      for (i = 0; i < samples.length; i++) {\n        flags = samples[i].flags;\n\n        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n      }\n\n      return box(types.sdtp, bytes);\n    };\n\n    stbl = function stbl(track) {\n      return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));\n    };\n\n    (function () {\n      var videoSample, audioSample;\n\n      stsd = function stsd(track) {\n\n        return box(types.stsd, new Uint8Array([0x00, // version 0\n        0x00, 0x00, 0x00, // flags\n        0x00, 0x00, 0x00, 0x01]), track.type === 'video' ? videoSample(track) : audioSample(track));\n      };\n\n      videoSample = function videoSample(track) {\n        var sps = track.sps || [],\n            pps = track.pps || [],\n            sequenceParameterSets = [],\n            pictureParameterSets = [],\n            i;\n\n        // assemble the SPSs\n        for (i = 0; i < sps.length; i++) {\n          sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n          sequenceParameterSets.push(sps[i].byteLength & 0xFF); // sequenceParameterSetLength\n          sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n        }\n\n        // assemble the PPSs\n        for (i = 0; i < pps.length; i++) {\n          pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n          pictureParameterSets.push(pps[i].byteLength & 0xFF);\n          pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n        }\n\n        return box(types.avc1, new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, // data_reference_index\n        0x00, 0x00, // pre_defined\n        0x00, 0x00, // reserved\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n        (track.width & 0xff00) >> 8, track.width & 0xff, // width\n        (track.height & 0xff00) >> 8, track.height & 0xff, // height\n        0x00, 0x48, 0x00, 0x00, // horizresolution\n        0x00, 0x48, 0x00, 0x00, // vertresolution\n        0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, // frame_count\n        0x13, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x6a, 0x73, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x2d, 0x68, 0x6c, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n        0x00, 0x18, // depth = 24\n        0x11, 0x11 // pre_defined = -1\n        ]), box(types.avcC, new Uint8Array([0x01, // configurationVersion\n        track.profileIdc, // AVCProfileIndication\n        track.profileCompatibility, // profile_compatibility\n        track.levelIdc, // AVCLevelIndication\n        0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n        ].concat([sps.length // numOfSequenceParameterSets\n        ]).concat(sequenceParameterSets).concat([pps.length // numOfPictureParameterSets\n        ]).concat(pictureParameterSets))), // \"PPS\"\n        box(types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n        0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n        0x00, 0x2d, 0xc6, 0xc0])) // avgBitrate\n        );\n      };\n\n      audioSample = function audioSample(track) {\n        return box(types.mp4a, new Uint8Array([\n\n        // SampleEntry, ISO/IEC 14496-12\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, // data_reference_index\n\n        // AudioSampleEntry, ISO/IEC 14496-12\n        0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x00, 0x00, 0x00, // reserved\n        (track.channelcount & 0xff00) >> 8, track.channelcount & 0xff, // channelcount\n\n        (track.samplesize & 0xff00) >> 8, track.samplesize & 0xff, // samplesize\n        0x00, 0x00, // pre_defined\n        0x00, 0x00, // reserved\n\n        (track.samplerate & 0xff00) >> 8, track.samplerate & 0xff, 0x00, 0x00 // samplerate, 16.16\n\n        // MP4AudioSampleEntry, ISO/IEC 14496-14\n        ]), esds(track));\n      };\n    })();\n\n    tkhd = function tkhd(track) {\n      var result = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x07, // flags\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // modification_time\n      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n      0x00, 0x00, 0x00, 0x00, // reserved\n      (track.duration & 0xFF000000) >> 24, (track.duration & 0xFF0000) >> 16, (track.duration & 0xFF00) >> 8, track.duration & 0xFF, // duration\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, // layer\n      0x00, 0x00, // alternate_group\n      0x01, 0x00, // non-audio track volume\n      0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      (track.width & 0xFF00) >> 8, track.width & 0xFF, 0x00, 0x00, // width\n      (track.height & 0xFF00) >> 8, track.height & 0xFF, 0x00, 0x00 // height\n      ]);\n\n      return box(types.tkhd, result);\n    };\n\n    /**\n     * Generate a track fragment (traf) box. A traf box collects metadata\n     * about tracks in a movie fragment (moof) box.\n     */\n    traf = function traf(track) {\n      var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n\n      trackFragmentHeader = box(types.tfhd, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x3a, // flags\n      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n      0x00, 0x00, 0x00, 0x01, // sample_description_index\n      0x00, 0x00, 0x00, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x00, 0x00, 0x00 // default_sample_flags\n      ]));\n\n      upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / (UINT32_MAX + 1));\n      lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % (UINT32_MAX + 1));\n\n      trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([0x01, // version 1\n      0x00, 0x00, 0x00, // flags\n      // baseMediaDecodeTime\n      upperWordBaseMediaDecodeTime >>> 24 & 0xFF, upperWordBaseMediaDecodeTime >>> 16 & 0xFF, upperWordBaseMediaDecodeTime >>> 8 & 0xFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >>> 24 & 0xFF, lowerWordBaseMediaDecodeTime >>> 16 & 0xFF, lowerWordBaseMediaDecodeTime >>> 8 & 0xFF, lowerWordBaseMediaDecodeTime & 0xFF]));\n\n      // the data offset specifies the number of bytes from the start of\n      // the containing moof to the first payload byte of the associated\n      // mdat\n      dataOffset = 32 + // tfhd\n      20 + // tfdt\n      8 + // traf header\n      16 + // mfhd\n      8 + // moof header\n      8; // mdat header\n\n      // audio tracks require less metadata\n      if (track.type === 'audio') {\n        trackFragmentRun = trun(track, dataOffset);\n        return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);\n      }\n\n      // video tracks should contain an independent and disposable samples\n      // box (sdtp)\n      // generate one and adjust offsets to match\n      sampleDependencyTable = sdtp(track);\n      trackFragmentRun = trun(track, sampleDependencyTable.length + dataOffset);\n      return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);\n    };\n\n    /**\n     * Generate a track box.\n     * @param track {object} a track definition\n     * @return {Uint8Array} the track box\n     */\n    trak = function trak(track) {\n      track.duration = track.duration || 0xffffffff;\n      return box(types.trak, tkhd(track), mdia(track));\n    };\n\n    trex = function trex(track) {\n      var result = new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x00, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x01, 0x00, 0x01 // default_sample_flags\n      ]);\n      // the last two bytes of default_sample_flags is the sample\n      // degradation priority, a hint about the importance of this sample\n      // relative to others. Lower the degradation priority for all sample\n      // types other than video.\n      if (track.type !== 'video') {\n        result[result.length - 1] = 0x00;\n      }\n\n      return box(types.trex, result);\n    };\n\n    (function () {\n      var audioTrun, videoTrun, trunHeader;\n\n      // This method assumes all samples are uniform. That is, if a\n      // duration is present for the first sample, it will be present for\n      // all subsequent samples.\n      // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n      trunHeader = function trunHeader(samples, offset) {\n        var durationPresent = 0,\n            sizePresent = 0,\n            flagsPresent = 0,\n            compositionTimeOffset = 0;\n\n        // trun flag constants\n        if (samples.length) {\n          if (samples[0].duration !== undefined) {\n            durationPresent = 0x1;\n          }\n          if (samples[0].size !== undefined) {\n            sizePresent = 0x2;\n          }\n          if (samples[0].flags !== undefined) {\n            flagsPresent = 0x4;\n          }\n          if (samples[0].compositionTimeOffset !== undefined) {\n            compositionTimeOffset = 0x8;\n          }\n        }\n\n        return [0x00, // version 0\n        0x00, durationPresent | sizePresent | flagsPresent | compositionTimeOffset, 0x01, // flags\n        (samples.length & 0xFF000000) >>> 24, (samples.length & 0xFF0000) >>> 16, (samples.length & 0xFF00) >>> 8, samples.length & 0xFF, // sample_count\n        (offset & 0xFF000000) >>> 24, (offset & 0xFF0000) >>> 16, (offset & 0xFF00) >>> 8, offset & 0xFF // data_offset\n        ];\n      };\n\n      videoTrun = function videoTrun(track, offset) {\n        var bytes, samples, sample, i;\n\n        samples = track.samples || [];\n        offset += 8 + 12 + 16 * samples.length;\n\n        bytes = trunHeader(samples, offset);\n\n        for (i = 0; i < samples.length; i++) {\n          sample = samples[i];\n          bytes = bytes.concat([(sample.duration & 0xFF000000) >>> 24, (sample.duration & 0xFF0000) >>> 16, (sample.duration & 0xFF00) >>> 8, sample.duration & 0xFF, // sample_duration\n          (sample.size & 0xFF000000) >>> 24, (sample.size & 0xFF0000) >>> 16, (sample.size & 0xFF00) >>> 8, sample.size & 0xFF, // sample_size\n          sample.flags.isLeading << 2 | sample.flags.dependsOn, sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample, sample.flags.degradationPriority & 0xF0 << 8, sample.flags.degradationPriority & 0x0F, // sample_flags\n          (sample.compositionTimeOffset & 0xFF000000) >>> 24, (sample.compositionTimeOffset & 0xFF0000) >>> 16, (sample.compositionTimeOffset & 0xFF00) >>> 8, sample.compositionTimeOffset & 0xFF // sample_composition_time_offset\n          ]);\n        }\n        return box(types.trun, new Uint8Array(bytes));\n      };\n\n      audioTrun = function audioTrun(track, offset) {\n        var bytes, samples, sample, i;\n\n        samples = track.samples || [];\n        offset += 8 + 12 + 8 * samples.length;\n\n        bytes = trunHeader(samples, offset);\n\n        for (i = 0; i < samples.length; i++) {\n          sample = samples[i];\n          bytes = bytes.concat([(sample.duration & 0xFF000000) >>> 24, (sample.duration & 0xFF0000) >>> 16, (sample.duration & 0xFF00) >>> 8, sample.duration & 0xFF, // sample_duration\n          (sample.size & 0xFF000000) >>> 24, (sample.size & 0xFF0000) >>> 16, (sample.size & 0xFF00) >>> 8, sample.size & 0xFF]); // sample_size\n        }\n\n        return box(types.trun, new Uint8Array(bytes));\n      };\n\n      trun = function trun(track, offset) {\n        if (track.type === 'audio') {\n          return audioTrun(track, offset);\n        }\n\n        return videoTrun(track, offset);\n      };\n    })();\n\n    var mp4Generator = {\n      ftyp: ftyp,\n      mdat: mdat,\n      moof: moof,\n      moov: moov,\n      initSegment: function initSegment(tracks) {\n        var fileType = ftyp(),\n            movie = moov(tracks),\n            result;\n\n        result = new Uint8Array(fileType.byteLength + movie.byteLength);\n        result.set(fileType);\n        result.set(movie, fileType.byteLength);\n        return result;\n      }\n    };\n\n    /**\n     * mux.js\n     *\n     * Copyright (c) 2014 Brightcove\n     * All rights reserved.\n     *\n     * A lightweight readable stream implemention that handles event dispatching.\n     * Objects that inherit from streams should call init in their constructors.\n     */\n\n    var Stream = function Stream() {\n      this.init = function () {\n        var listeners = {};\n        /**\n         * Add a listener for a specified event type.\n         * @param type {string} the event name\n         * @param listener {function} the callback to be invoked when an event of\n         * the specified type occurs\n         */\n        this.on = function (type, listener) {\n          if (!listeners[type]) {\n            listeners[type] = [];\n          }\n          listeners[type] = listeners[type].concat(listener);\n        };\n        /**\n         * Remove a listener for a specified event type.\n         * @param type {string} the event name\n         * @param listener {function} a function previously registered for this\n         * type of event through `on`\n         */\n        this.off = function (type, listener) {\n          var index;\n          if (!listeners[type]) {\n            return false;\n          }\n          index = listeners[type].indexOf(listener);\n          listeners[type] = listeners[type].slice();\n          listeners[type].splice(index, 1);\n          return index > -1;\n        };\n        /**\n         * Trigger an event of the specified type on this stream. Any additional\n         * arguments to this function are passed as parameters to event listeners.\n         * @param type {string} the event name\n         */\n        this.trigger = function (type) {\n          var callbacks, i, length, args;\n          callbacks = listeners[type];\n          if (!callbacks) {\n            return;\n          }\n          // Slicing the arguments on every invocation of this method\n          // can add a significant amount of overhead. Avoid the\n          // intermediate object creation for the common case of a\n          // single callback argument\n          if (arguments.length === 2) {\n            length = callbacks.length;\n            for (i = 0; i < length; ++i) {\n              callbacks[i].call(this, arguments[1]);\n            }\n          } else {\n            args = [];\n            i = arguments.length;\n            for (i = 1; i < arguments.length; ++i) {\n              args.push(arguments[i]);\n            }\n            length = callbacks.length;\n            for (i = 0; i < length; ++i) {\n              callbacks[i].apply(this, args);\n            }\n          }\n        };\n        /**\n         * Destroys the stream and cleans up.\n         */\n        this.dispose = function () {\n          listeners = {};\n        };\n      };\n    };\n\n    /**\n     * Forwards all `data` events on this stream to the destination stream. The\n     * destination stream should provide a method `push` to receive the data\n     * events as they arrive.\n     * @param destination {stream} the stream that will receive all `data` events\n     * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n     *                            when the current stream emits a 'done' event\n     * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n     */\n    Stream.prototype.pipe = function (destination) {\n      this.on('data', function (data) {\n        destination.push(data);\n      });\n\n      this.on('done', function (flushSource) {\n        destination.flush(flushSource);\n      });\n\n      return destination;\n    };\n\n    // Default stream functions that are expected to be overridden to perform\n    // actual work. These are provided by the prototype as a sort of no-op\n    // implementation so that we don't have to check for their existence in the\n    // `pipe` function above.\n    Stream.prototype.push = function (data) {\n      this.trigger('data', data);\n    };\n\n    Stream.prototype.flush = function (flushSource) {\n      this.trigger('done', flushSource);\n    };\n\n    var stream = Stream;\n\n    // -----------------\n    // Link To Transport\n    // -----------------\n\n    // Supplemental enhancement information (SEI) NAL units have a\n    // payload type field to indicate how they are to be\n    // interpreted. CEAS-708 caption content is always transmitted with\n    // payload type 0x04.\n    var USER_DATA_REGISTERED_ITU_T_T35 = 4,\n        RBSP_TRAILING_BITS = 128;\n\n    /**\n      * Parse a supplemental enhancement information (SEI) NAL unit.\n      * Stops parsing once a message of type ITU T T35 has been found.\n      *\n      * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n      * @return {object} the parsed SEI payload\n      * @see Rec. ITU-T H.264, 7.3.2.3.1\n      */\n    var parseSei = function parseSei(bytes) {\n      var i = 0,\n          result = {\n        payloadType: -1,\n        payloadSize: 0\n      },\n          payloadType = 0,\n          payloadSize = 0;\n\n      // go through the sei_rbsp parsing each each individual sei_message\n      while (i < bytes.byteLength) {\n        // stop once we have hit the end of the sei_rbsp\n        if (bytes[i] === RBSP_TRAILING_BITS) {\n          break;\n        }\n\n        // Parse payload type\n        while (bytes[i] === 0xFF) {\n          payloadType += 255;\n          i++;\n        }\n        payloadType += bytes[i++];\n\n        // Parse payload size\n        while (bytes[i] === 0xFF) {\n          payloadSize += 255;\n          i++;\n        }\n        payloadSize += bytes[i++];\n\n        // this sei_message is a 608/708 caption so save it and break\n        // there can only ever be one caption message in a frame's sei\n        if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n          result.payloadType = payloadType;\n          result.payloadSize = payloadSize;\n          result.payload = bytes.subarray(i, i + payloadSize);\n          break;\n        }\n\n        // skip the payload and parse the next message\n        i += payloadSize;\n        payloadType = 0;\n        payloadSize = 0;\n      }\n\n      return result;\n    };\n\n    // see ANSI/SCTE 128-1 (2013), section 8.1\n    var parseUserData = function parseUserData(sei) {\n      // itu_t_t35_contry_code must be 181 (United States) for\n      // captions\n      if (sei.payload[0] !== 181) {\n        return null;\n      }\n\n      // itu_t_t35_provider_code should be 49 (ATSC) for captions\n      if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {\n        return null;\n      }\n\n      // the user_identifier should be \"GA94\" to indicate ATSC1 data\n      if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== 'GA94') {\n        return null;\n      }\n\n      // finally, user_data_type_code should be 0x03 for caption data\n      if (sei.payload[7] !== 0x03) {\n        return null;\n      }\n\n      // return the user_data_type_structure and strip the trailing\n      // marker bits\n      return sei.payload.subarray(8, sei.payload.length - 1);\n    };\n\n    // see CEA-708-D, section 4.4\n    var parseCaptionPackets = function parseCaptionPackets(pts, userData) {\n      var results = [],\n          i,\n          count,\n          offset,\n          data;\n\n      // if this is just filler, return immediately\n      if (!(userData[0] & 0x40)) {\n        return results;\n      }\n\n      // parse out the cc_data_1 and cc_data_2 fields\n      count = userData[0] & 0x1f;\n      for (i = 0; i < count; i++) {\n        offset = i * 3;\n        data = {\n          type: userData[offset + 2] & 0x03,\n          pts: pts\n        };\n\n        // capture cc data when cc_valid is 1\n        if (userData[offset + 2] & 0x04) {\n          data.ccData = userData[offset + 3] << 8 | userData[offset + 4];\n          results.push(data);\n        }\n      }\n      return results;\n    };\n\n    var CaptionStream = function CaptionStream() {\n\n      CaptionStream.prototype.init.call(this);\n\n      this.captionPackets_ = [];\n\n      this.ccStreams_ = [new Cea608Stream(0, 0), // eslint-disable-line no-use-before-define\n      new Cea608Stream(0, 1), // eslint-disable-line no-use-before-define\n      new Cea608Stream(1, 0), // eslint-disable-line no-use-before-define\n      new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n      ];\n\n      this.reset();\n\n      // forward data and done events from CCs to this CaptionStream\n      this.ccStreams_.forEach(function (cc) {\n        cc.on('data', this.trigger.bind(this, 'data'));\n        cc.on('done', this.trigger.bind(this, 'done'));\n      }, this);\n    };\n\n    CaptionStream.prototype = new stream();\n    CaptionStream.prototype.push = function (event) {\n      var sei, userData;\n\n      // only examine SEI NALs\n      if (event.nalUnitType !== 'sei_rbsp') {\n        return;\n      }\n\n      // parse the sei\n      sei = parseSei(event.escapedRBSP);\n\n      // ignore everything but user_data_registered_itu_t_t35\n      if (sei.payloadType !== USER_DATA_REGISTERED_ITU_T_T35) {\n        return;\n      }\n\n      // parse out the user data payload\n      userData = parseUserData(sei);\n\n      // ignore unrecognized userData\n      if (!userData) {\n        return;\n      }\n\n      // Sometimes, the same segment # will be downloaded twice. To stop the\n      // caption data from being processed twice, we track the latest dts we've\n      // received and ignore everything with a dts before that. However, since\n      // data for a specific dts can be split across packets on either side of\n      // a segment boundary, we need to make sure we *don't* ignore the packets\n      // from the *next* segment that have dts === this.latestDts_. By constantly\n      // tracking the number of packets received with dts === this.latestDts_, we\n      // know how many should be ignored once we start receiving duplicates.\n      if (event.dts < this.latestDts_) {\n        // We've started getting older data, so set the flag.\n        this.ignoreNextEqualDts_ = true;\n        return;\n      } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {\n        this.numSameDts_--;\n        if (!this.numSameDts_) {\n          // We've received the last duplicate packet, time to start processing again\n          this.ignoreNextEqualDts_ = false;\n        }\n        return;\n      }\n\n      // parse out CC data packets and save them for later\n      this.captionPackets_ = this.captionPackets_.concat(parseCaptionPackets(event.pts, userData));\n      if (this.latestDts_ !== event.dts) {\n        this.numSameDts_ = 0;\n      }\n      this.numSameDts_++;\n      this.latestDts_ = event.dts;\n    };\n\n    CaptionStream.prototype.flush = function () {\n      // make sure we actually parsed captions before proceeding\n      if (!this.captionPackets_.length) {\n        this.ccStreams_.forEach(function (cc) {\n          cc.flush();\n        }, this);\n        return;\n      }\n\n      // In Chrome, the Array#sort function is not stable so add a\n      // presortIndex that we can use to ensure we get a stable-sort\n      this.captionPackets_.forEach(function (elem, idx) {\n        elem.presortIndex = idx;\n      });\n\n      // sort caption byte-pairs based on their PTS values\n      this.captionPackets_.sort(function (a, b) {\n        if (a.pts === b.pts) {\n          return a.presortIndex - b.presortIndex;\n        }\n        return a.pts - b.pts;\n      });\n\n      this.captionPackets_.forEach(function (packet) {\n        if (packet.type < 2) {\n          // Dispatch packet to the right Cea608Stream\n          this.dispatchCea608Packet(packet);\n        }\n        // this is where an 'else' would go for a dispatching packets\n        // to a theoretical Cea708Stream that handles SERVICEn data\n      }, this);\n\n      this.captionPackets_.length = 0;\n      this.ccStreams_.forEach(function (cc) {\n        cc.flush();\n      }, this);\n      return;\n    };\n\n    CaptionStream.prototype.reset = function () {\n      this.latestDts_ = null;\n      this.ignoreNextEqualDts_ = false;\n      this.numSameDts_ = 0;\n      this.activeCea608Channel_ = [null, null];\n      this.ccStreams_.forEach(function (ccStream) {\n        ccStream.reset();\n      });\n    };\n\n    CaptionStream.prototype.dispatchCea608Packet = function (packet) {\n      // NOTE: packet.type is the CEA608 field\n      if (this.setsChannel1Active(packet)) {\n        this.activeCea608Channel_[packet.type] = 0;\n      } else if (this.setsChannel2Active(packet)) {\n        this.activeCea608Channel_[packet.type] = 1;\n      }\n      if (this.activeCea608Channel_[packet.type] === null) {\n        // If we haven't received anything to set the active channel, discard the\n        // data; we don't want jumbled captions\n        return;\n      }\n      this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n    };\n\n    CaptionStream.prototype.setsChannel1Active = function (packet) {\n      return (packet.ccData & 0x7800) === 0x1000;\n    };\n    CaptionStream.prototype.setsChannel2Active = function (packet) {\n      return (packet.ccData & 0x7800) === 0x1800;\n    };\n\n    // ----------------------\n    // Session to Application\n    // ----------------------\n\n    var CHARACTER_TRANSLATION = {\n      0x2a: 0xe1, // á\n      0x5c: 0xe9, // é\n      0x5e: 0xed, // í\n      0x5f: 0xf3, // ó\n      0x60: 0xfa, // ú\n      0x7b: 0xe7, // ç\n      0x7c: 0xf7, // ÷\n      0x7d: 0xd1, // Ñ\n      0x7e: 0xf1, // ñ\n      0x7f: 0x2588, // █\n      0x0130: 0xae, // ®\n      0x0131: 0xb0, // °\n      0x0132: 0xbd, // ½\n      0x0133: 0xbf, // ¿\n      0x0134: 0x2122, // ™\n      0x0135: 0xa2, // ¢\n      0x0136: 0xa3, // £\n      0x0137: 0x266a, // ♪\n      0x0138: 0xe0, // à\n      0x0139: 0xa0, //\n      0x013a: 0xe8, // è\n      0x013b: 0xe2, // â\n      0x013c: 0xea, // ê\n      0x013d: 0xee, // î\n      0x013e: 0xf4, // ô\n      0x013f: 0xfb, // û\n      0x0220: 0xc1, // Á\n      0x0221: 0xc9, // É\n      0x0222: 0xd3, // Ó\n      0x0223: 0xda, // Ú\n      0x0224: 0xdc, // Ü\n      0x0225: 0xfc, // ü\n      0x0226: 0x2018, // ‘\n      0x0227: 0xa1, // ¡\n      0x0228: 0x2a, // *\n      0x0229: 0x27, // '\n      0x022a: 0x2014, // —\n      0x022b: 0xa9, // ©\n      0x022c: 0x2120, // ℠\n      0x022d: 0x2022, // •\n      0x022e: 0x201c, // “\n      0x022f: 0x201d, // ”\n      0x0230: 0xc0, // À\n      0x0231: 0xc2, // Â\n      0x0232: 0xc7, // Ç\n      0x0233: 0xc8, // È\n      0x0234: 0xca, // Ê\n      0x0235: 0xcb, // Ë\n      0x0236: 0xeb, // ë\n      0x0237: 0xce, // Î\n      0x0238: 0xcf, // Ï\n      0x0239: 0xef, // ï\n      0x023a: 0xd4, // Ô\n      0x023b: 0xd9, // Ù\n      0x023c: 0xf9, // ù\n      0x023d: 0xdb, // Û\n      0x023e: 0xab, // «\n      0x023f: 0xbb, // »\n      0x0320: 0xc3, // Ã\n      0x0321: 0xe3, // ã\n      0x0322: 0xcd, // Í\n      0x0323: 0xcc, // Ì\n      0x0324: 0xec, // ì\n      0x0325: 0xd2, // Ò\n      0x0326: 0xf2, // ò\n      0x0327: 0xd5, // Õ\n      0x0328: 0xf5, // õ\n      0x0329: 0x7b, // {\n      0x032a: 0x7d, // }\n      0x032b: 0x5c, // \\\n      0x032c: 0x5e, // ^\n      0x032d: 0x5f, // _\n      0x032e: 0x7c, // |\n      0x032f: 0x7e, // ~\n      0x0330: 0xc4, // Ä\n      0x0331: 0xe4, // ä\n      0x0332: 0xd6, // Ö\n      0x0333: 0xf6, // ö\n      0x0334: 0xdf, // ß\n      0x0335: 0xa5, // ¥\n      0x0336: 0xa4, // ¤\n      0x0337: 0x2502, // │\n      0x0338: 0xc5, // Å\n      0x0339: 0xe5, // å\n      0x033a: 0xd8, // Ø\n      0x033b: 0xf8, // ø\n      0x033c: 0x250c, // ┌\n      0x033d: 0x2510, // ┐\n      0x033e: 0x2514, // └\n      0x033f: 0x2518 // ┘\n    };\n\n    var getCharFromCode = function getCharFromCode(code) {\n      if (code === null) {\n        return '';\n      }\n      code = CHARACTER_TRANSLATION[code] || code;\n      return String.fromCharCode(code);\n    };\n\n    // the index of the last row in a CEA-608 display buffer\n    var BOTTOM_ROW = 14;\n\n    // This array is used for mapping PACs -> row #, since there's no way of\n    // getting it through bit logic.\n    var ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620, 0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420];\n\n    // CEA-608 captions are rendered onto a 34x15 matrix of character\n    // cells. The \"bottom\" row is the last element in the outer array.\n    var createDisplayBuffer = function createDisplayBuffer() {\n      var result = [],\n          i = BOTTOM_ROW + 1;\n      while (i--) {\n        result.push('');\n      }\n      return result;\n    };\n\n    var Cea608Stream = function Cea608Stream(field, dataChannel) {\n      Cea608Stream.prototype.init.call(this);\n\n      this.field_ = field || 0;\n      this.dataChannel_ = dataChannel || 0;\n\n      this.name_ = 'CC' + ((this.field_ << 1 | this.dataChannel_) + 1);\n\n      this.setConstants();\n      this.reset();\n\n      this.push = function (packet) {\n        var data, swap, char0, char1, text;\n        // remove the parity bits\n        data = packet.ccData & 0x7f7f;\n\n        // ignore duplicate control codes; the spec demands they're sent twice\n        if (data === this.lastControlCode_) {\n          this.lastControlCode_ = null;\n          return;\n        }\n\n        // Store control codes\n        if ((data & 0xf000) === 0x1000) {\n          this.lastControlCode_ = data;\n        } else if (data !== this.PADDING_) {\n          this.lastControlCode_ = null;\n        }\n\n        char0 = data >>> 8;\n        char1 = data & 0xff;\n\n        if (data === this.PADDING_) {\n          return;\n        } else if (data === this.RESUME_CAPTION_LOADING_) {\n          this.mode_ = 'popOn';\n        } else if (data === this.END_OF_CAPTION_) {\n          this.clearFormatting(packet.pts);\n          // if a caption was being displayed, it's gone now\n          this.flushDisplayed(packet.pts);\n\n          // flip memory\n          swap = this.displayed_;\n          this.displayed_ = this.nonDisplayed_;\n          this.nonDisplayed_ = swap;\n\n          // start measuring the time to display the caption\n          this.startPts_ = packet.pts;\n        } else if (data === this.ROLL_UP_2_ROWS_) {\n          this.topRow_ = BOTTOM_ROW - 1;\n          this.mode_ = 'rollUp';\n        } else if (data === this.ROLL_UP_3_ROWS_) {\n          this.topRow_ = BOTTOM_ROW - 2;\n          this.mode_ = 'rollUp';\n        } else if (data === this.ROLL_UP_4_ROWS_) {\n          this.topRow_ = BOTTOM_ROW - 3;\n          this.mode_ = 'rollUp';\n        } else if (data === this.CARRIAGE_RETURN_) {\n          this.clearFormatting(packet.pts);\n          this.flushDisplayed(packet.pts);\n          this.shiftRowsUp_();\n          this.startPts_ = packet.pts;\n        } else if (data === this.BACKSPACE_) {\n          if (this.mode_ === 'popOn') {\n            this.nonDisplayed_[BOTTOM_ROW] = this.nonDisplayed_[BOTTOM_ROW].slice(0, -1);\n          } else {\n            this.displayed_[BOTTOM_ROW] = this.displayed_[BOTTOM_ROW].slice(0, -1);\n          }\n        } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n          this.flushDisplayed(packet.pts);\n          this.displayed_ = createDisplayBuffer();\n        } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n          this.nonDisplayed_ = createDisplayBuffer();\n        } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n          this.mode_ = 'paintOn';\n\n          // Append special characters to caption text\n        } else if (this.isSpecialCharacter(char0, char1)) {\n          // Bitmask char0 so that we can apply character transformations\n          // regardless of field and data channel.\n          // Then byte-shift to the left and OR with char1 so we can pass the\n          // entire character code to `getCharFromCode`.\n          char0 = (char0 & 0x03) << 8;\n          text = getCharFromCode(char0 | char1);\n          this[this.mode_](packet.pts, text);\n          this.column_++;\n\n          // Append extended characters to caption text\n        } else if (this.isExtCharacter(char0, char1)) {\n          // Extended characters always follow their \"non-extended\" equivalents.\n          // IE if a \"è\" is desired, you'll always receive \"eè\"; non-compliant\n          // decoders are supposed to drop the \"è\", while compliant decoders\n          // backspace the \"e\" and insert \"è\".\n\n          // Delete the previous character\n          if (this.mode_ === 'popOn') {\n            this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n          } else {\n            this.displayed_[BOTTOM_ROW] = this.displayed_[BOTTOM_ROW].slice(0, -1);\n          }\n\n          // Bitmask char0 so that we can apply character transformations\n          // regardless of field and data channel.\n          // Then byte-shift to the left and OR with char1 so we can pass the\n          // entire character code to `getCharFromCode`.\n          char0 = (char0 & 0x03) << 8;\n          text = getCharFromCode(char0 | char1);\n          this[this.mode_](packet.pts, text);\n          this.column_++;\n\n          // Process mid-row codes\n        } else if (this.isMidRowCode(char0, char1)) {\n          // Attributes are not additive, so clear all formatting\n          this.clearFormatting(packet.pts);\n\n          // According to the standard, mid-row codes\n          // should be replaced with spaces, so add one now\n          this[this.mode_](packet.pts, ' ');\n          this.column_++;\n\n          if ((char1 & 0xe) === 0xe) {\n            this.addFormatting(packet.pts, ['i']);\n          }\n\n          if ((char1 & 0x1) === 0x1) {\n            this.addFormatting(packet.pts, ['u']);\n          }\n\n          // Detect offset control codes and adjust cursor\n        } else if (this.isOffsetControlCode(char0, char1)) {\n          // Cursor position is set by indent PAC (see below) in 4-column\n          // increments, with an additional offset code of 1-3 to reach any\n          // of the 32 columns specified by CEA-608. So all we need to do\n          // here is increment the column cursor by the given offset.\n          this.column_ += char1 & 0x03;\n\n          // Detect PACs (Preamble Address Codes)\n        } else if (this.isPAC(char0, char1)) {\n\n          // There's no logic for PAC -> row mapping, so we have to just\n          // find the row code in an array and use its index :(\n          var row = ROWS.indexOf(data & 0x1f20);\n\n          if (row !== this.row_) {\n            // formatting is only persistent for current row\n            this.clearFormatting(packet.pts);\n            this.row_ = row;\n          }\n          // All PACs can apply underline, so detect and apply\n          // (All odd-numbered second bytes set underline)\n          if (char1 & 0x1 && this.formatting_.indexOf('u') === -1) {\n            this.addFormatting(packet.pts, ['u']);\n          }\n\n          if ((data & 0x10) === 0x10) {\n            // We've got an indent level code. Each successive even number\n            // increments the column cursor by 4, so we can get the desired\n            // column position by bit-shifting to the right (to get n/2)\n            // and multiplying by 4.\n            this.column_ = ((data & 0xe) >> 1) * 4;\n          }\n\n          if (this.isColorPAC(char1)) {\n            // it's a color code, though we only support white, which\n            // can be either normal or italicized. white italics can be\n            // either 0x4e or 0x6e depending on the row, so we just\n            // bitwise-and with 0xe to see if italics should be turned on\n            if ((char1 & 0xe) === 0xe) {\n              this.addFormatting(packet.pts, ['i']);\n            }\n          }\n\n          // We have a normal character in char0, and possibly one in char1\n        } else if (this.isNormalChar(char0)) {\n          if (char1 === 0x00) {\n            char1 = null;\n          }\n          text = getCharFromCode(char0);\n          text += getCharFromCode(char1);\n          this[this.mode_](packet.pts, text);\n          this.column_ += text.length;\n        } // finish data processing\n      };\n    };\n    Cea608Stream.prototype = new stream();\n    // Trigger a cue point that captures the current state of the\n    // display buffer\n    Cea608Stream.prototype.flushDisplayed = function (pts) {\n      var content = this.displayed_\n      // remove spaces from the start and end of the string\n      .map(function (row) {\n        return row.trim();\n      })\n      // combine all text rows to display in one cue\n      .join('\\n')\n      // and remove blank rows from the start and end, but not the middle\n      .replace(/^\\n+|\\n+$/g, '');\n\n      if (content.length) {\n        this.trigger('data', {\n          startPts: this.startPts_,\n          endPts: pts,\n          text: content,\n          stream: this.name_\n        });\n      }\n    };\n\n    /**\n     * Zero out the data, used for startup and on seek\n     */\n    Cea608Stream.prototype.reset = function () {\n      this.mode_ = 'popOn';\n      // When in roll-up mode, the index of the last row that will\n      // actually display captions. If a caption is shifted to a row\n      // with a lower index than this, it is cleared from the display\n      // buffer\n      this.topRow_ = 0;\n      this.startPts_ = 0;\n      this.displayed_ = createDisplayBuffer();\n      this.nonDisplayed_ = createDisplayBuffer();\n      this.lastControlCode_ = null;\n\n      // Track row and column for proper line-breaking and spacing\n      this.column_ = 0;\n      this.row_ = BOTTOM_ROW;\n\n      // This variable holds currently-applied formatting\n      this.formatting_ = [];\n    };\n\n    /**\n     * Sets up control code and related constants for this instance\n     */\n    Cea608Stream.prototype.setConstants = function () {\n      // The following attributes have these uses:\n      // ext_ :    char0 for mid-row codes, and the base for extended\n      //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n      //           extended codes)\n      // control_: char0 for control codes, except byte-shifted to the\n      //           left so that we can do this.control_ | CONTROL_CODE\n      // offset_:  char0 for tab offset codes\n      //\n      // It's also worth noting that control codes, and _only_ control codes,\n      // differ between field 1 and field2. Field 2 control codes are always\n      // their field 1 value plus 1. That's why there's the \"| field\" on the\n      // control value.\n      if (this.dataChannel_ === 0) {\n        this.BASE_ = 0x10;\n        this.EXT_ = 0x11;\n        this.CONTROL_ = (0x14 | this.field_) << 8;\n        this.OFFSET_ = 0x17;\n      } else if (this.dataChannel_ === 1) {\n        this.BASE_ = 0x18;\n        this.EXT_ = 0x19;\n        this.CONTROL_ = (0x1c | this.field_) << 8;\n        this.OFFSET_ = 0x1f;\n      }\n\n      // Constants for the LSByte command codes recognized by Cea608Stream. This\n      // list is not exhaustive. For a more comprehensive listing and semantics see\n      // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n      // Padding\n      this.PADDING_ = 0x0000;\n      // Pop-on Mode\n      this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 0x20;\n      this.END_OF_CAPTION_ = this.CONTROL_ | 0x2f;\n      // Roll-up Mode\n      this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 0x25;\n      this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 0x26;\n      this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 0x27;\n      this.CARRIAGE_RETURN_ = this.CONTROL_ | 0x2d;\n      // paint-on mode (not supported)\n      this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 0x29;\n      // Erasure\n      this.BACKSPACE_ = this.CONTROL_ | 0x21;\n      this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2c;\n      this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n    };\n\n    /**\n     * Detects if the 2-byte packet data is a special character\n     *\n     * Special characters have a second byte in the range 0x30 to 0x3f,\n     * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n     * data channel 2).\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are an special character\n     */\n    Cea608Stream.prototype.isSpecialCharacter = function (char0, char1) {\n      return char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f;\n    };\n\n    /**\n     * Detects if the 2-byte packet data is an extended character\n     *\n     * Extended characters have a second byte in the range 0x20 to 0x3f,\n     * with the first byte being 0x12 or 0x13 (for data channel 1) or\n     * 0x1a or 0x1b (for data channel 2).\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are an extended character\n     */\n    Cea608Stream.prototype.isExtCharacter = function (char0, char1) {\n      return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 0x20 && char1 <= 0x3f;\n    };\n\n    /**\n     * Detects if the 2-byte packet is a mid-row code\n     *\n     * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n     * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n     * channel 2).\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are a mid-row code\n     */\n    Cea608Stream.prototype.isMidRowCode = function (char0, char1) {\n      return char0 === this.EXT_ && char1 >= 0x20 && char1 <= 0x2f;\n    };\n\n    /**\n     * Detects if the 2-byte packet is an offset control code\n     *\n     * Offset control codes have a second byte in the range 0x21 to 0x23,\n     * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n     * data channel 2).\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are an offset control code\n     */\n    Cea608Stream.prototype.isOffsetControlCode = function (char0, char1) {\n      return char0 === this.OFFSET_ && char1 >= 0x21 && char1 <= 0x23;\n    };\n\n    /**\n     * Detects if the 2-byte packet is a Preamble Address Code\n     *\n     * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n     * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n     * range 0x40 to 0x7f.\n     *\n     * @param  {Integer} char0 The first byte\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the 2 bytes are a PAC\n     */\n    Cea608Stream.prototype.isPAC = function (char0, char1) {\n      return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 0x40 && char1 <= 0x7f;\n    };\n\n    /**\n     * Detects if a packet's second byte is in the range of a PAC color code\n     *\n     * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n     * 0x60 to 0x6f.\n     *\n     * @param  {Integer} char1 The second byte\n     * @return {Boolean}       Whether the byte is a color PAC\n     */\n    Cea608Stream.prototype.isColorPAC = function (char1) {\n      return char1 >= 0x40 && char1 <= 0x4f || char1 >= 0x60 && char1 <= 0x7f;\n    };\n\n    /**\n     * Detects if a single byte is in the range of a normal character\n     *\n     * Normal text bytes are in the range 0x20 to 0x7f.\n     *\n     * @param  {Integer} char  The byte\n     * @return {Boolean}       Whether the byte is a normal character\n     */\n    Cea608Stream.prototype.isNormalChar = function (char) {\n      return char >= 0x20 && char <= 0x7f;\n    };\n\n    // Adds the opening HTML tag for the passed character to the caption text,\n    // and keeps track of it for later closing\n    Cea608Stream.prototype.addFormatting = function (pts, format) {\n      this.formatting_ = this.formatting_.concat(format);\n      var text = format.reduce(function (text, format) {\n        return text + '<' + format + '>';\n      }, '');\n      this[this.mode_](pts, text);\n    };\n\n    // Adds HTML closing tags for current formatting to caption text and\n    // clears remembered formatting\n    Cea608Stream.prototype.clearFormatting = function (pts) {\n      if (!this.formatting_.length) {\n        return;\n      }\n      var text = this.formatting_.reverse().reduce(function (text, format) {\n        return text + '</' + format + '>';\n      }, '');\n      this.formatting_ = [];\n      this[this.mode_](pts, text);\n    };\n\n    // Mode Implementations\n    Cea608Stream.prototype.popOn = function (pts, text) {\n      var baseRow = this.nonDisplayed_[this.row_];\n\n      // buffer characters\n      baseRow += text;\n      this.nonDisplayed_[this.row_] = baseRow;\n    };\n\n    Cea608Stream.prototype.rollUp = function (pts, text) {\n      var baseRow = this.displayed_[BOTTOM_ROW];\n\n      baseRow += text;\n      this.displayed_[BOTTOM_ROW] = baseRow;\n    };\n\n    Cea608Stream.prototype.shiftRowsUp_ = function () {\n      var i;\n      // clear out inactive rows\n      for (i = 0; i < this.topRow_; i++) {\n        this.displayed_[i] = '';\n      }\n      // shift displayed rows up\n      for (i = this.topRow_; i < BOTTOM_ROW; i++) {\n        this.displayed_[i] = this.displayed_[i + 1];\n      }\n      // clear out the bottom row\n      this.displayed_[BOTTOM_ROW] = '';\n    };\n\n    // paintOn mode is not implemented\n    Cea608Stream.prototype.paintOn = function () {};\n\n    // exports\n    var captionStream = {\n      CaptionStream: CaptionStream,\n      Cea608Stream: Cea608Stream\n    };\n\n    var streamTypes = {\n      H264_STREAM_TYPE: 0x1B,\n      ADTS_STREAM_TYPE: 0x0F,\n      METADATA_STREAM_TYPE: 0x15\n    };\n\n    var MAX_TS = 8589934592;\n\n    var RO_THRESH = 4294967296;\n\n    var handleRollover = function handleRollover(value, reference) {\n      var direction = 1;\n\n      if (value > reference) {\n        // If the current timestamp value is greater than our reference timestamp and we detect a\n        // timestamp rollover, this means the roll over is happening in the opposite direction.\n        // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n        // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n        // rollover point. In loading this segment, the timestamp values will be very large,\n        // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n        // the time stamp to be `value - 2^33`.\n        direction = -1;\n      }\n\n      // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n      // cause an incorrect adjustment.\n      while (Math.abs(reference - value) > RO_THRESH) {\n        value += direction * MAX_TS;\n      }\n\n      return value;\n    };\n\n    var TimestampRolloverStream = function TimestampRolloverStream(type) {\n      var lastDTS, referenceDTS;\n\n      TimestampRolloverStream.prototype.init.call(this);\n\n      this.type_ = type;\n\n      this.push = function (data) {\n        if (data.type !== this.type_) {\n          return;\n        }\n\n        if (referenceDTS === undefined) {\n          referenceDTS = data.dts;\n        }\n\n        data.dts = handleRollover(data.dts, referenceDTS);\n        data.pts = handleRollover(data.pts, referenceDTS);\n\n        lastDTS = data.dts;\n\n        this.trigger('data', data);\n      };\n\n      this.flush = function () {\n        referenceDTS = lastDTS;\n        this.trigger('done');\n      };\n\n      this.discontinuity = function () {\n        referenceDTS = void 0;\n        lastDTS = void 0;\n      };\n    };\n\n    TimestampRolloverStream.prototype = new stream();\n\n    var timestampRolloverStream = {\n      TimestampRolloverStream: TimestampRolloverStream,\n      handleRollover: handleRollover\n    };\n\n    var percentEncode = function percentEncode(bytes, start, end) {\n      var i,\n          result = '';\n      for (i = start; i < end; i++) {\n        result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n      }\n      return result;\n    },\n\n\n    // return the string representation of the specified byte range,\n    // interpreted as UTf-8.\n    parseUtf8 = function parseUtf8(bytes, start, end) {\n      return decodeURIComponent(percentEncode(bytes, start, end));\n    },\n\n\n    // return the string representation of the specified byte range,\n    // interpreted as ISO-8859-1.\n    parseIso88591 = function parseIso88591(bytes, start, end) {\n      return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n    },\n        parseSyncSafeInteger = function parseSyncSafeInteger(data) {\n      return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n    },\n        tagParsers = {\n      TXXX: function TXXX(tag) {\n        var i;\n        if (tag.data[0] !== 3) {\n          // ignore frames with unrecognized character encodings\n          return;\n        }\n\n        for (i = 1; i < tag.data.length; i++) {\n          if (tag.data[i] === 0) {\n            // parse the text fields\n            tag.description = parseUtf8(tag.data, 1, i);\n            // do not include the null terminator in the tag value\n            tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\\0*$/, '');\n            break;\n          }\n        }\n        tag.data = tag.value;\n      },\n      WXXX: function WXXX(tag) {\n        var i;\n        if (tag.data[0] !== 3) {\n          // ignore frames with unrecognized character encodings\n          return;\n        }\n\n        for (i = 1; i < tag.data.length; i++) {\n          if (tag.data[i] === 0) {\n            // parse the description and URL fields\n            tag.description = parseUtf8(tag.data, 1, i);\n            tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\n            break;\n          }\n        }\n      },\n      PRIV: function PRIV(tag) {\n        var i;\n\n        for (i = 0; i < tag.data.length; i++) {\n          if (tag.data[i] === 0) {\n            // parse the description and URL fields\n            tag.owner = parseIso88591(tag.data, 0, i);\n            break;\n          }\n        }\n        tag.privateData = tag.data.subarray(i + 1);\n        tag.data = tag.privateData;\n      }\n    },\n        _MetadataStream;\n\n    _MetadataStream = function MetadataStream(options) {\n      var settings = {\n        debug: !!(options && options.debug),\n\n        // the bytes of the program-level descriptor field in MP2T\n        // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n        // program element descriptors\"\n        descriptor: options && options.descriptor\n      },\n\n\n      // the total size in bytes of the ID3 tag being parsed\n      tagSize = 0,\n\n\n      // tag data that is not complete enough to be parsed\n      buffer = [],\n\n\n      // the total number of bytes currently in the buffer\n      bufferSize = 0,\n          i;\n\n      _MetadataStream.prototype.init.call(this);\n\n      // calculate the text track in-band metadata track dispatch type\n      // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n      this.dispatchType = streamTypes.METADATA_STREAM_TYPE.toString(16);\n      if (settings.descriptor) {\n        for (i = 0; i < settings.descriptor.length; i++) {\n          this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n        }\n      }\n\n      this.push = function (chunk) {\n        var tag, frameStart, frameSize, frame, i, frameHeader;\n        if (chunk.type !== 'timed-metadata') {\n          return;\n        }\n\n        // if data_alignment_indicator is set in the PES header,\n        // we must have the start of a new ID3 tag. Assume anything\n        // remaining in the buffer was malformed and throw it out\n        if (chunk.dataAlignmentIndicator) {\n          bufferSize = 0;\n          buffer.length = 0;\n        }\n\n        // ignore events that don't look like ID3 data\n        if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== 'I'.charCodeAt(0) || chunk.data[1] !== 'D'.charCodeAt(0) || chunk.data[2] !== '3'.charCodeAt(0))) {\n          if (settings.debug) {\n            // eslint-disable-next-line no-console\n            console.log('Skipping unrecognized metadata packet');\n          }\n          return;\n        }\n\n        // add this chunk to the data we've collected so far\n\n        buffer.push(chunk);\n        bufferSize += chunk.data.byteLength;\n\n        // grab the size of the entire frame from the ID3 header\n        if (buffer.length === 1) {\n          // the frame size is transmitted as a 28-bit integer in the\n          // last four bytes of the ID3 header.\n          // The most significant bit of each byte is dropped and the\n          // results concatenated to recover the actual value.\n          tagSize = parseSyncSafeInteger(chunk.data.subarray(6, 10));\n\n          // ID3 reports the tag size excluding the header but it's more\n          // convenient for our comparisons to include it\n          tagSize += 10;\n        }\n\n        // if the entire frame has not arrived, wait for more data\n        if (bufferSize < tagSize) {\n          return;\n        }\n\n        // collect the entire frame so it can be parsed\n        tag = {\n          data: new Uint8Array(tagSize),\n          frames: [],\n          pts: buffer[0].pts,\n          dts: buffer[0].dts\n        };\n        for (i = 0; i < tagSize;) {\n          tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n          i += buffer[0].data.byteLength;\n          bufferSize -= buffer[0].data.byteLength;\n          buffer.shift();\n        }\n\n        // find the start of the first frame and the end of the tag\n        frameStart = 10;\n        if (tag.data[5] & 0x40) {\n          // advance the frame start past the extended header\n          frameStart += 4; // header size field\n          frameStart += parseSyncSafeInteger(tag.data.subarray(10, 14));\n\n          // clip any padding off the end\n          tagSize -= parseSyncSafeInteger(tag.data.subarray(16, 20));\n        }\n\n        // parse one or more ID3 frames\n        // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n        do {\n          // determine the number of bytes in this frame\n          frameSize = parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));\n          if (frameSize < 1) {\n            // eslint-disable-next-line no-console\n            return console.log('Malformed ID3 frame encountered. Skipping metadata parsing.');\n          }\n          frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);\n\n          frame = {\n            id: frameHeader,\n            data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n          };\n          frame.key = frame.id;\n          if (tagParsers[frame.id]) {\n            tagParsers[frame.id](frame);\n\n            // handle the special PRIV frame used to indicate the start\n            // time for raw AAC data\n            if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n              var d = frame.data,\n                  size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n\n              size *= 4;\n              size += d[7] & 0x03;\n              frame.timeStamp = size;\n              // in raw AAC, all subsequent data will be timestamped based\n              // on the value of this frame\n              // we couldn't have known the appropriate pts and dts before\n              // parsing this ID3 tag so set those values now\n              if (tag.pts === undefined && tag.dts === undefined) {\n                tag.pts = frame.timeStamp;\n                tag.dts = frame.timeStamp;\n              }\n              this.trigger('timestamp', frame);\n            }\n          }\n          tag.frames.push(frame);\n\n          frameStart += 10; // advance past the frame header\n          frameStart += frameSize; // advance past the frame body\n        } while (frameStart < tagSize);\n        this.trigger('data', tag);\n      };\n    };\n    _MetadataStream.prototype = new stream();\n\n    var metadataStream = _MetadataStream;\n\n    var TimestampRolloverStream$1 = timestampRolloverStream.TimestampRolloverStream;\n\n    // object types\n    var _TransportPacketStream, _TransportParseStream, _ElementaryStream;\n\n    // constants\n    var MP2T_PACKET_LENGTH = 188,\n\n\n    // bytes\n    SYNC_BYTE = 0x47;\n\n    /**\n     * Splits an incoming stream of binary data into MPEG-2 Transport\n     * Stream packets.\n     */\n    _TransportPacketStream = function TransportPacketStream() {\n      var buffer = new Uint8Array(MP2T_PACKET_LENGTH),\n          bytesInBuffer = 0;\n\n      _TransportPacketStream.prototype.init.call(this);\n\n      // Deliver new bytes to the stream.\n\n      this.push = function (bytes) {\n        var startIndex = 0,\n            endIndex = MP2T_PACKET_LENGTH,\n            everything;\n\n        // If there are bytes remaining from the last segment, prepend them to the\n        // bytes that were pushed in\n        if (bytesInBuffer) {\n          everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\n          everything.set(buffer.subarray(0, bytesInBuffer));\n          everything.set(bytes, bytesInBuffer);\n          bytesInBuffer = 0;\n        } else {\n          everything = bytes;\n        }\n\n        // While we have enough data for a packet\n        while (endIndex < everything.byteLength) {\n          // Look for a pair of start and end sync bytes in the data..\n          if (everything[startIndex] === SYNC_BYTE && everything[endIndex] === SYNC_BYTE) {\n            // We found a packet so emit it and jump one whole packet forward in\n            // the stream\n            this.trigger('data', everything.subarray(startIndex, endIndex));\n            startIndex += MP2T_PACKET_LENGTH;\n            endIndex += MP2T_PACKET_LENGTH;\n            continue;\n          }\n          // If we get here, we have somehow become de-synchronized and we need to step\n          // forward one byte at a time until we find a pair of sync bytes that denote\n          // a packet\n          startIndex++;\n          endIndex++;\n        }\n\n        // If there was some data left over at the end of the segment that couldn't\n        // possibly be a whole packet, keep it because it might be the start of a packet\n        // that continues in the next segment\n        if (startIndex < everything.byteLength) {\n          buffer.set(everything.subarray(startIndex), 0);\n          bytesInBuffer = everything.byteLength - startIndex;\n        }\n      };\n\n      this.flush = function () {\n        // If the buffer contains a whole packet when we are being flushed, emit it\n        // and empty the buffer. Otherwise hold onto the data because it may be\n        // important for decoding the next segment\n        if (bytesInBuffer === MP2T_PACKET_LENGTH && buffer[0] === SYNC_BYTE) {\n          this.trigger('data', buffer);\n          bytesInBuffer = 0;\n        }\n        this.trigger('done');\n      };\n    };\n    _TransportPacketStream.prototype = new stream();\n\n    /**\n     * Accepts an MP2T TransportPacketStream and emits data events with parsed\n     * forms of the individual transport stream packets.\n     */\n    _TransportParseStream = function TransportParseStream() {\n      var parsePsi, parsePat, parsePmt, self;\n      _TransportParseStream.prototype.init.call(this);\n      self = this;\n\n      this.packetsWaitingForPmt = [];\n      this.programMapTable = undefined;\n\n      parsePsi = function parsePsi(payload, psi) {\n        var offset = 0;\n\n        // PSI packets may be split into multiple sections and those\n        // sections may be split into multiple packets. If a PSI\n        // section starts in this packet, the payload_unit_start_indicator\n        // will be true and the first byte of the payload will indicate\n        // the offset from the current position to the start of the\n        // section.\n        if (psi.payloadUnitStartIndicator) {\n          offset += payload[offset] + 1;\n        }\n\n        if (psi.type === 'pat') {\n          parsePat(payload.subarray(offset), psi);\n        } else {\n          parsePmt(payload.subarray(offset), psi);\n        }\n      };\n\n      parsePat = function parsePat(payload, pat) {\n        pat.section_number = payload[7]; // eslint-disable-line camelcase\n        pat.last_section_number = payload[8]; // eslint-disable-line camelcase\n\n        // skip the PSI header and parse the first PMT entry\n        self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\n        pat.pmtPid = self.pmtPid;\n      };\n\n      /**\n       * Parse out the relevant fields of a Program Map Table (PMT).\n       * @param payload {Uint8Array} the PMT-specific portion of an MP2T\n       * packet. The first byte in this array should be the table_id\n       * field.\n       * @param pmt {object} the object that should be decorated with\n       * fields parsed from the PMT.\n       */\n      parsePmt = function parsePmt(payload, pmt) {\n        var sectionLength, tableEnd, programInfoLength, offset;\n\n        // PMTs can be sent ahead of the time when they should actually\n        // take effect. We don't believe this should ever be the case\n        // for HLS but we'll ignore \"forward\" PMT declarations if we see\n        // them. Future PMT declarations have the current_next_indicator\n        // set to zero.\n        if (!(payload[5] & 0x01)) {\n          return;\n        }\n\n        // overwrite any existing program map table\n        self.programMapTable = {\n          video: null,\n          audio: null,\n          'timed-metadata': {}\n        };\n\n        // the mapping table ends at the end of the current section\n        sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\n        tableEnd = 3 + sectionLength - 4;\n\n        // to determine where the table is, we have to figure out how\n        // long the program info descriptors are\n        programInfoLength = (payload[10] & 0x0f) << 8 | payload[11];\n\n        // advance the offset to the first entry in the mapping table\n        offset = 12 + programInfoLength;\n        while (offset < tableEnd) {\n          var streamType = payload[offset];\n          var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2];\n\n          // only map a single elementary_pid for audio and video stream types\n          // TODO: should this be done for metadata too? for now maintain behavior of\n          //       multiple metadata streams\n          if (streamType === streamTypes.H264_STREAM_TYPE && self.programMapTable.video === null) {\n            self.programMapTable.video = pid;\n          } else if (streamType === streamTypes.ADTS_STREAM_TYPE && self.programMapTable.audio === null) {\n            self.programMapTable.audio = pid;\n          } else if (streamType === streamTypes.METADATA_STREAM_TYPE) {\n            // map pid to stream type for metadata streams\n            self.programMapTable['timed-metadata'][pid] = streamType;\n          }\n\n          // move to the next table entry\n          // skip past the elementary stream descriptors, if present\n          offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\n        }\n\n        // record the map on the packet as well\n        pmt.programMapTable = self.programMapTable;\n      };\n\n      /**\n       * Deliver a new MP2T packet to the stream.\n       */\n      this.push = function (packet) {\n        var result = {},\n            offset = 4;\n\n        result.payloadUnitStartIndicator = !!(packet[1] & 0x40);\n\n        // pid is a 13-bit field starting at the last bit of packet[1]\n        result.pid = packet[1] & 0x1f;\n        result.pid <<= 8;\n        result.pid |= packet[2];\n\n        // if an adaption field is present, its length is specified by the\n        // fifth byte of the TS packet header. The adaptation field is\n        // used to add stuffing to PES packets that don't fill a complete\n        // TS packet, and to specify some forms of timing and control data\n        // that we do not currently use.\n        if ((packet[3] & 0x30) >>> 4 > 0x01) {\n          offset += packet[offset] + 1;\n        }\n\n        // parse the rest of the packet based on the type\n        if (result.pid === 0) {\n          result.type = 'pat';\n          parsePsi(packet.subarray(offset), result);\n          this.trigger('data', result);\n        } else if (result.pid === this.pmtPid) {\n          result.type = 'pmt';\n          parsePsi(packet.subarray(offset), result);\n          this.trigger('data', result);\n\n          // if there are any packets waiting for a PMT to be found, process them now\n          while (this.packetsWaitingForPmt.length) {\n            this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\n          }\n        } else if (this.programMapTable === undefined) {\n          // When we have not seen a PMT yet, defer further processing of\n          // PES packets until one has been parsed\n          this.packetsWaitingForPmt.push([packet, offset, result]);\n        } else {\n          this.processPes_(packet, offset, result);\n        }\n      };\n\n      this.processPes_ = function (packet, offset, result) {\n        // set the appropriate stream type\n        if (result.pid === this.programMapTable.video) {\n          result.streamType = streamTypes.H264_STREAM_TYPE;\n        } else if (result.pid === this.programMapTable.audio) {\n          result.streamType = streamTypes.ADTS_STREAM_TYPE;\n        } else {\n          // if not video or audio, it is timed-metadata or unknown\n          // if unknown, streamType will be undefined\n          result.streamType = this.programMapTable['timed-metadata'][result.pid];\n        }\n\n        result.type = 'pes';\n        result.data = packet.subarray(offset);\n\n        this.trigger('data', result);\n      };\n    };\n    _TransportParseStream.prototype = new stream();\n    _TransportParseStream.STREAM_TYPES = {\n      h264: 0x1b,\n      adts: 0x0f\n    };\n\n    /**\n     * Reconsistutes program elementary stream (PES) packets from parsed\n     * transport stream packets. That is, if you pipe an\n     * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\n     * events will be events which capture the bytes for individual PES\n     * packets plus relevant metadata that has been extracted from the\n     * container.\n     */\n    _ElementaryStream = function ElementaryStream() {\n      var self = this,\n\n\n      // PES packet fragments\n      video = {\n        data: [],\n        size: 0\n      },\n          audio = {\n        data: [],\n        size: 0\n      },\n          timedMetadata = {\n        data: [],\n        size: 0\n      },\n          parsePes = function parsePes(payload, pes) {\n        var ptsDtsFlags;\n\n        // get the packet length, this will be 0 for video\n        pes.packetLength = 6 + (payload[4] << 8 | payload[5]);\n\n        // find out if this packets starts a new keyframe\n        pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0;\n        // PES packets may be annotated with a PTS value, or a PTS value\n        // and a DTS value. Determine what combination of values is\n        // available to work with.\n        ptsDtsFlags = payload[7];\n\n        // PTS and DTS are normally stored as a 33-bit number.  Javascript\n        // performs all bitwise operations on 32-bit integers but javascript\n        // supports a much greater range (52-bits) of integer using standard\n        // mathematical operations.\n        // We construct a 31-bit value using bitwise operators over the 31\n        // most significant bits and then multiply by 4 (equal to a left-shift\n        // of 2) before we add the final 2 least significant bits of the\n        // timestamp (equal to an OR.)\n        if (ptsDtsFlags & 0xC0) {\n          // the PTS and DTS are not written out directly. For information\n          // on how they are encoded, see\n          // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n          pes.pts = (payload[9] & 0x0E) << 27 | (payload[10] & 0xFF) << 20 | (payload[11] & 0xFE) << 12 | (payload[12] & 0xFF) << 5 | (payload[13] & 0xFE) >>> 3;\n          pes.pts *= 4; // Left shift by 2\n          pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\n          pes.dts = pes.pts;\n          if (ptsDtsFlags & 0x40) {\n            pes.dts = (payload[14] & 0x0E) << 27 | (payload[15] & 0xFF) << 20 | (payload[16] & 0xFE) << 12 | (payload[17] & 0xFF) << 5 | (payload[18] & 0xFE) >>> 3;\n            pes.dts *= 4; // Left shift by 2\n            pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\n          }\n        }\n        // the data section starts immediately after the PES header.\n        // pes_header_data_length specifies the number of header bytes\n        // that follow the last byte of the field.\n        pes.data = payload.subarray(9 + payload[8]);\n      },\n          flushStream = function flushStream(stream$$1, type, forceFlush) {\n        var packetData = new Uint8Array(stream$$1.size),\n            event = {\n          type: type\n        },\n            i = 0,\n            offset = 0,\n            packetFlushable = false,\n            fragment;\n\n        // do nothing if there is not enough buffered data for a complete\n        // PES header\n        if (!stream$$1.data.length || stream$$1.size < 9) {\n          return;\n        }\n        event.trackId = stream$$1.data[0].pid;\n\n        // reassemble the packet\n        for (i = 0; i < stream$$1.data.length; i++) {\n          fragment = stream$$1.data[i];\n\n          packetData.set(fragment.data, offset);\n          offset += fragment.data.byteLength;\n        }\n\n        // parse assembled packet's PES header\n        parsePes(packetData, event);\n\n        // non-video PES packets MUST have a non-zero PES_packet_length\n        // check that there is enough stream data to fill the packet\n        packetFlushable = type === 'video' || event.packetLength <= stream$$1.size;\n\n        // flush pending packets if the conditions are right\n        if (forceFlush || packetFlushable) {\n          stream$$1.size = 0;\n          stream$$1.data.length = 0;\n        }\n\n        // only emit packets that are complete. this is to avoid assembling\n        // incomplete PES packets due to poor segmentation\n        if (packetFlushable) {\n          self.trigger('data', event);\n        }\n      };\n\n      _ElementaryStream.prototype.init.call(this);\n\n      this.push = function (data) {\n        ({\n          pat: function pat() {\n            // we have to wait for the PMT to arrive as well before we\n            // have any meaningful metadata\n          },\n          pes: function pes() {\n            var stream$$1, streamType;\n\n            switch (data.streamType) {\n              case streamTypes.H264_STREAM_TYPE:\n              case streamTypes.H264_STREAM_TYPE:\n                stream$$1 = video;\n                streamType = 'video';\n                break;\n              case streamTypes.ADTS_STREAM_TYPE:\n                stream$$1 = audio;\n                streamType = 'audio';\n                break;\n              case streamTypes.METADATA_STREAM_TYPE:\n                stream$$1 = timedMetadata;\n                streamType = 'timed-metadata';\n                break;\n              default:\n                // ignore unknown stream types\n                return;\n            }\n\n            // if a new packet is starting, we can flush the completed\n            // packet\n            if (data.payloadUnitStartIndicator) {\n              flushStream(stream$$1, streamType, true);\n            }\n\n            // buffer this fragment until we are sure we've received the\n            // complete payload\n            stream$$1.data.push(data);\n            stream$$1.size += data.data.byteLength;\n          },\n          pmt: function pmt() {\n            var event = {\n              type: 'metadata',\n              tracks: []\n            },\n                programMapTable = data.programMapTable;\n\n            // translate audio and video streams to tracks\n            if (programMapTable.video !== null) {\n              event.tracks.push({\n                timelineStartInfo: {\n                  baseMediaDecodeTime: 0\n                },\n                id: +programMapTable.video,\n                codec: 'avc',\n                type: 'video'\n              });\n            }\n            if (programMapTable.audio !== null) {\n              event.tracks.push({\n                timelineStartInfo: {\n                  baseMediaDecodeTime: 0\n                },\n                id: +programMapTable.audio,\n                codec: 'adts',\n                type: 'audio'\n              });\n            }\n\n            self.trigger('data', event);\n          }\n        })[data.type]();\n      };\n\n      /**\n       * Flush any remaining input. Video PES packets may be of variable\n       * length. Normally, the start of a new video packet can trigger the\n       * finalization of the previous packet. That is not possible if no\n       * more video is forthcoming, however. In that case, some other\n       * mechanism (like the end of the file) has to be employed. When it is\n       * clear that no additional data is forthcoming, calling this method\n       * will flush the buffered packets.\n       */\n      this.flush = function () {\n        // !!THIS ORDER IS IMPORTANT!!\n        // video first then audio\n        flushStream(video, 'video');\n        flushStream(audio, 'audio');\n        flushStream(timedMetadata, 'timed-metadata');\n        this.trigger('done');\n      };\n    };\n    _ElementaryStream.prototype = new stream();\n\n    var m2ts = {\n      PAT_PID: 0x0000,\n      MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH,\n      TransportPacketStream: _TransportPacketStream,\n      TransportParseStream: _TransportParseStream,\n      ElementaryStream: _ElementaryStream,\n      TimestampRolloverStream: TimestampRolloverStream$1,\n      CaptionStream: captionStream.CaptionStream,\n      Cea608Stream: captionStream.Cea608Stream,\n      MetadataStream: metadataStream\n    };\n\n    for (var type in streamTypes) {\n      if (streamTypes.hasOwnProperty(type)) {\n        m2ts[type] = streamTypes[type];\n      }\n    }\n\n    var m2ts_1 = m2ts;\n\n    var _AdtsStream;\n\n    var ADTS_SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n\n    /*\n     * Accepts a ElementaryStream and emits data events with parsed\n     * AAC Audio Frames of the individual packets. Input audio in ADTS\n     * format is unpacked and re-emitted as AAC frames.\n     *\n     * @see http://wiki.multimedia.cx/index.php?title=ADTS\n     * @see http://wiki.multimedia.cx/?title=Understanding_AAC\n     */\n    _AdtsStream = function AdtsStream() {\n      var buffer;\n\n      _AdtsStream.prototype.init.call(this);\n\n      this.push = function (packet) {\n        var i = 0,\n            frameNum = 0,\n            frameLength,\n            protectionSkipBytes,\n            frameEnd,\n            oldBuffer,\n            sampleCount,\n            adtsFrameDuration;\n\n        if (packet.type !== 'audio') {\n          // ignore non-audio data\n          return;\n        }\n\n        // Prepend any data in the buffer to the input data so that we can parse\n        // aac frames the cross a PES packet boundary\n        if (buffer) {\n          oldBuffer = buffer;\n          buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\n          buffer.set(oldBuffer);\n          buffer.set(packet.data, oldBuffer.byteLength);\n        } else {\n          buffer = packet.data;\n        }\n\n        // unpack any ADTS frames which have been fully received\n        // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\n        while (i + 5 < buffer.length) {\n\n          // Loook for the start of an ADTS header..\n          if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\n            // If a valid header was not found,  jump one forward and attempt to\n            // find a valid ADTS header starting at the next byte\n            i++;\n            continue;\n          }\n\n          // The protection skip bit tells us if we have 2 bytes of CRC data at the\n          // end of the ADTS header\n          protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2;\n\n          // Frame length is a 13 bit integer starting 16 bits from the\n          // end of the sync sequence\n          frameLength = (buffer[i + 3] & 0x03) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 0xe0) >> 5;\n\n          sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\n          adtsFrameDuration = sampleCount * 90000 / ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2];\n\n          frameEnd = i + frameLength;\n\n          // If we don't have enough data to actually finish this ADTS frame, return\n          // and wait for more data\n          if (buffer.byteLength < frameEnd) {\n            return;\n          }\n\n          // Otherwise, deliver the complete AAC frame\n          this.trigger('data', {\n            pts: packet.pts + frameNum * adtsFrameDuration,\n            dts: packet.dts + frameNum * adtsFrameDuration,\n            sampleCount: sampleCount,\n            audioobjecttype: (buffer[i + 2] >>> 6 & 0x03) + 1,\n            channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 0xc0) >>> 6,\n            samplerate: ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2],\n            samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\n            // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\n            samplesize: 16,\n            data: buffer.subarray(i + 7 + protectionSkipBytes, frameEnd)\n          });\n\n          // If the buffer is empty, clear it and return\n          if (buffer.byteLength === frameEnd) {\n            buffer = undefined;\n            return;\n          }\n\n          frameNum++;\n\n          // Remove the finished frame from the buffer and start the process again\n          buffer = buffer.subarray(frameEnd);\n        }\n      };\n      this.flush = function () {\n        this.trigger('done');\n      };\n    };\n\n    _AdtsStream.prototype = new stream();\n\n    var adts = _AdtsStream;\n\n    var ExpGolomb;\n\n    /**\n     * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n     * scheme used by h264.\n     */\n    ExpGolomb = function ExpGolomb(workingData) {\n      var\n      // the number of bytes left to examine in workingData\n      workingBytesAvailable = workingData.byteLength,\n\n\n      // the current word being examined\n      workingWord = 0,\n\n\n      // :uint\n\n      // the number of bits left to examine in the current word\n      workingBitsAvailable = 0; // :uint;\n\n      // ():uint\n      this.length = function () {\n        return 8 * workingBytesAvailable;\n      };\n\n      // ():uint\n      this.bitsAvailable = function () {\n        return 8 * workingBytesAvailable + workingBitsAvailable;\n      };\n\n      // ():void\n      this.loadWord = function () {\n        var position = workingData.byteLength - workingBytesAvailable,\n            workingBytes = new Uint8Array(4),\n            availableBytes = Math.min(4, workingBytesAvailable);\n\n        if (availableBytes === 0) {\n          throw new Error('no bytes available');\n        }\n\n        workingBytes.set(workingData.subarray(position, position + availableBytes));\n        workingWord = new DataView(workingBytes.buffer).getUint32(0);\n\n        // track the amount of workingData that has been processed\n        workingBitsAvailable = availableBytes * 8;\n        workingBytesAvailable -= availableBytes;\n      };\n\n      // (count:int):void\n      this.skipBits = function (count) {\n        var skipBytes; // :int\n        if (workingBitsAvailable > count) {\n          workingWord <<= count;\n          workingBitsAvailable -= count;\n        } else {\n          count -= workingBitsAvailable;\n          skipBytes = Math.floor(count / 8);\n\n          count -= skipBytes * 8;\n          workingBytesAvailable -= skipBytes;\n\n          this.loadWord();\n\n          workingWord <<= count;\n          workingBitsAvailable -= count;\n        }\n      };\n\n      // (size:int):uint\n      this.readBits = function (size) {\n        var bits = Math.min(workingBitsAvailable, size),\n\n\n        // :uint\n        valu = workingWord >>> 32 - bits; // :uint\n        // if size > 31, handle error\n        workingBitsAvailable -= bits;\n        if (workingBitsAvailable > 0) {\n          workingWord <<= bits;\n        } else if (workingBytesAvailable > 0) {\n          this.loadWord();\n        }\n\n        bits = size - bits;\n        if (bits > 0) {\n          return valu << bits | this.readBits(bits);\n        }\n        return valu;\n      };\n\n      // ():uint\n      this.skipLeadingZeros = function () {\n        var leadingZeroCount; // :uint\n        for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n          if ((workingWord & 0x80000000 >>> leadingZeroCount) !== 0) {\n            // the first bit of working word is 1\n            workingWord <<= leadingZeroCount;\n            workingBitsAvailable -= leadingZeroCount;\n            return leadingZeroCount;\n          }\n        }\n\n        // we exhausted workingWord and still have not found a 1\n        this.loadWord();\n        return leadingZeroCount + this.skipLeadingZeros();\n      };\n\n      // ():void\n      this.skipUnsignedExpGolomb = function () {\n        this.skipBits(1 + this.skipLeadingZeros());\n      };\n\n      // ():void\n      this.skipExpGolomb = function () {\n        this.skipBits(1 + this.skipLeadingZeros());\n      };\n\n      // ():uint\n      this.readUnsignedExpGolomb = function () {\n        var clz = this.skipLeadingZeros(); // :uint\n        return this.readBits(clz + 1) - 1;\n      };\n\n      // ():int\n      this.readExpGolomb = function () {\n        var valu = this.readUnsignedExpGolomb(); // :int\n        if (0x01 & valu) {\n          // the number is odd if the low order bit is set\n          return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n        }\n        return -1 * (valu >>> 1); // divide by two then make it negative\n      };\n\n      // Some convenience functions\n      // :Boolean\n      this.readBoolean = function () {\n        return this.readBits(1) === 1;\n      };\n\n      // ():int\n      this.readUnsignedByte = function () {\n        return this.readBits(8);\n      };\n\n      this.loadWord();\n    };\n\n    var expGolomb = ExpGolomb;\n\n    var _H264Stream, _NalByteStream;\n    var PROFILES_WITH_OPTIONAL_SPS_DATA;\n\n    /**\n     * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\n     */\n    _NalByteStream = function NalByteStream() {\n      var syncPoint = 0,\n          i,\n          buffer;\n      _NalByteStream.prototype.init.call(this);\n\n      this.push = function (data) {\n        var swapBuffer;\n\n        if (!buffer) {\n          buffer = data.data;\n        } else {\n          swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\n          swapBuffer.set(buffer);\n          swapBuffer.set(data.data, buffer.byteLength);\n          buffer = swapBuffer;\n        }\n\n        // Rec. ITU-T H.264, Annex B\n        // scan for NAL unit boundaries\n\n        // a match looks like this:\n        // 0 0 1 .. NAL .. 0 0 1\n        // ^ sync point        ^ i\n        // or this:\n        // 0 0 1 .. NAL .. 0 0 0\n        // ^ sync point        ^ i\n\n        // advance the sync point to a NAL start, if necessary\n        for (; syncPoint < buffer.byteLength - 3; syncPoint++) {\n          if (buffer[syncPoint + 2] === 1) {\n            // the sync point is properly aligned\n            i = syncPoint + 5;\n            break;\n          }\n        }\n\n        while (i < buffer.byteLength) {\n          // look at the current byte to determine if we've hit the end of\n          // a NAL unit boundary\n          switch (buffer[i]) {\n            case 0:\n              // skip past non-sync sequences\n              if (buffer[i - 1] !== 0) {\n                i += 2;\n                break;\n              } else if (buffer[i - 2] !== 0) {\n                i++;\n                break;\n              }\n\n              // deliver the NAL unit if it isn't empty\n              if (syncPoint + 3 !== i - 2) {\n                this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n              }\n\n              // drop trailing zeroes\n              do {\n                i++;\n              } while (buffer[i] !== 1 && i < buffer.length);\n              syncPoint = i - 2;\n              i += 3;\n              break;\n            case 1:\n              // skip past non-sync sequences\n              if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {\n                i += 3;\n                break;\n              }\n\n              // deliver the NAL unit\n              this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n              syncPoint = i - 2;\n              i += 3;\n              break;\n            default:\n              // the current byte isn't a one or zero, so it cannot be part\n              // of a sync sequence\n              i += 3;\n              break;\n          }\n        }\n        // filter out the NAL units that were delivered\n        buffer = buffer.subarray(syncPoint);\n        i -= syncPoint;\n        syncPoint = 0;\n      };\n\n      this.flush = function () {\n        // deliver the last buffered NAL unit\n        if (buffer && buffer.byteLength > 3) {\n          this.trigger('data', buffer.subarray(syncPoint + 3));\n        }\n        // reset the stream state\n        buffer = null;\n        syncPoint = 0;\n        this.trigger('done');\n      };\n    };\n    _NalByteStream.prototype = new stream();\n\n    // values of profile_idc that indicate additional fields are included in the SPS\n    // see Recommendation ITU-T H.264 (4/2013),\n    // 7.3.2.1.1 Sequence parameter set data syntax\n    PROFILES_WITH_OPTIONAL_SPS_DATA = {\n      100: true,\n      110: true,\n      122: true,\n      244: true,\n      44: true,\n      83: true,\n      86: true,\n      118: true,\n      128: true,\n      138: true,\n      139: true,\n      134: true\n    };\n\n    /**\n     * Accepts input from a ElementaryStream and produces H.264 NAL unit data\n     * events.\n     */\n    _H264Stream = function H264Stream() {\n      var nalByteStream = new _NalByteStream(),\n          self,\n          trackId,\n          currentPts,\n          currentDts,\n          discardEmulationPreventionBytes,\n          readSequenceParameterSet,\n          skipScalingList;\n\n      _H264Stream.prototype.init.call(this);\n      self = this;\n\n      this.push = function (packet) {\n        if (packet.type !== 'video') {\n          return;\n        }\n        trackId = packet.trackId;\n        currentPts = packet.pts;\n        currentDts = packet.dts;\n\n        nalByteStream.push(packet);\n      };\n\n      nalByteStream.on('data', function (data) {\n        var event = {\n          trackId: trackId,\n          pts: currentPts,\n          dts: currentDts,\n          data: data\n        };\n\n        switch (data[0] & 0x1f) {\n          case 0x05:\n            event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\n            break;\n          case 0x06:\n            event.nalUnitType = 'sei_rbsp';\n            event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n            break;\n          case 0x07:\n            event.nalUnitType = 'seq_parameter_set_rbsp';\n            event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n            event.config = readSequenceParameterSet(event.escapedRBSP);\n            break;\n          case 0x08:\n            event.nalUnitType = 'pic_parameter_set_rbsp';\n            break;\n          case 0x09:\n            event.nalUnitType = 'access_unit_delimiter_rbsp';\n            break;\n\n          default:\n            break;\n        }\n        self.trigger('data', event);\n      });\n      nalByteStream.on('done', function () {\n        self.trigger('done');\n      });\n\n      this.flush = function () {\n        nalByteStream.flush();\n      };\n\n      /**\n       * Advance the ExpGolomb decoder past a scaling list. The scaling\n       * list is optionally transmitted as part of a sequence parameter\n       * set and is not relevant to transmuxing.\n       * @param count {number} the number of entries in this scaling list\n       * @param expGolombDecoder {object} an ExpGolomb pointed to the\n       * start of a scaling list\n       * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n       */\n      skipScalingList = function skipScalingList(count, expGolombDecoder) {\n        var lastScale = 8,\n            nextScale = 8,\n            j,\n            deltaScale;\n\n        for (j = 0; j < count; j++) {\n          if (nextScale !== 0) {\n            deltaScale = expGolombDecoder.readExpGolomb();\n            nextScale = (lastScale + deltaScale + 256) % 256;\n          }\n\n          lastScale = nextScale === 0 ? lastScale : nextScale;\n        }\n      };\n\n      /**\n       * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n       * Sequence Payload\"\n       * @param data {Uint8Array} the bytes of a RBSP from a NAL\n       * unit\n       * @return {Uint8Array} the RBSP without any Emulation\n       * Prevention Bytes\n       */\n      discardEmulationPreventionBytes = function discardEmulationPreventionBytes(data) {\n        var length = data.byteLength,\n            emulationPreventionBytesPositions = [],\n            i = 1,\n            newLength,\n            newData;\n\n        // Find all `Emulation Prevention Bytes`\n        while (i < length - 2) {\n          if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n            emulationPreventionBytesPositions.push(i + 2);\n            i += 2;\n          } else {\n            i++;\n          }\n        }\n\n        // If no Emulation Prevention Bytes were found just return the original\n        // array\n        if (emulationPreventionBytesPositions.length === 0) {\n          return data;\n        }\n\n        // Create a new array to hold the NAL unit data\n        newLength = length - emulationPreventionBytesPositions.length;\n        newData = new Uint8Array(newLength);\n        var sourceIndex = 0;\n\n        for (i = 0; i < newLength; sourceIndex++, i++) {\n          if (sourceIndex === emulationPreventionBytesPositions[0]) {\n            // Skip this byte\n            sourceIndex++;\n            // Remove this position index\n            emulationPreventionBytesPositions.shift();\n          }\n          newData[i] = data[sourceIndex];\n        }\n\n        return newData;\n      };\n\n      /**\n       * Read a sequence parameter set and return some interesting video\n       * properties. A sequence parameter set is the H264 metadata that\n       * describes the properties of upcoming video frames.\n       * @param data {Uint8Array} the bytes of a sequence parameter set\n       * @return {object} an object with configuration parsed from the\n       * sequence parameter set, including the dimensions of the\n       * associated video frames.\n       */\n      readSequenceParameterSet = function readSequenceParameterSet(data) {\n        var frameCropLeftOffset = 0,\n            frameCropRightOffset = 0,\n            frameCropTopOffset = 0,\n            frameCropBottomOffset = 0,\n            sarScale = 1,\n            expGolombDecoder,\n            profileIdc,\n            levelIdc,\n            profileCompatibility,\n            chromaFormatIdc,\n            picOrderCntType,\n            numRefFramesInPicOrderCntCycle,\n            picWidthInMbsMinus1,\n            picHeightInMapUnitsMinus1,\n            frameMbsOnlyFlag,\n            scalingListCount,\n            sarRatio,\n            aspectRatioIdc,\n            i;\n\n        expGolombDecoder = new expGolomb(data);\n        profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\n        profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\n        levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\n        expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\n\n        // some profiles have more optional data we don't need\n        if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\n          chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\n          if (chromaFormatIdc === 3) {\n            expGolombDecoder.skipBits(1); // separate_colour_plane_flag\n          }\n          expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\n          expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\n          expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n          if (expGolombDecoder.readBoolean()) {\n            // seq_scaling_matrix_present_flag\n            scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n            for (i = 0; i < scalingListCount; i++) {\n              if (expGolombDecoder.readBoolean()) {\n                // seq_scaling_list_present_flag[ i ]\n                if (i < 6) {\n                  skipScalingList(16, expGolombDecoder);\n                } else {\n                  skipScalingList(64, expGolombDecoder);\n                }\n              }\n            }\n          }\n        }\n\n        expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\n        picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\n\n        if (picOrderCntType === 0) {\n          expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\n        } else if (picOrderCntType === 1) {\n          expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\n          expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\n          expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\n          numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\n          for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n            expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\n          }\n        }\n\n        expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\n        expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n        picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n        picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n\n        frameMbsOnlyFlag = expGolombDecoder.readBits(1);\n        if (frameMbsOnlyFlag === 0) {\n          expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\n        }\n\n        expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\n        if (expGolombDecoder.readBoolean()) {\n          // frame_cropping_flag\n          frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\n          frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\n          frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\n          frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\n        }\n        if (expGolombDecoder.readBoolean()) {\n          // vui_parameters_present_flag\n          if (expGolombDecoder.readBoolean()) {\n            // aspect_ratio_info_present_flag\n            aspectRatioIdc = expGolombDecoder.readUnsignedByte();\n            switch (aspectRatioIdc) {\n              case 1:\n                sarRatio = [1, 1];break;\n              case 2:\n                sarRatio = [12, 11];break;\n              case 3:\n                sarRatio = [10, 11];break;\n              case 4:\n                sarRatio = [16, 11];break;\n              case 5:\n                sarRatio = [40, 33];break;\n              case 6:\n                sarRatio = [24, 11];break;\n              case 7:\n                sarRatio = [20, 11];break;\n              case 8:\n                sarRatio = [32, 11];break;\n              case 9:\n                sarRatio = [80, 33];break;\n              case 10:\n                sarRatio = [18, 11];break;\n              case 11:\n                sarRatio = [15, 11];break;\n              case 12:\n                sarRatio = [64, 33];break;\n              case 13:\n                sarRatio = [160, 99];break;\n              case 14:\n                sarRatio = [4, 3];break;\n              case 15:\n                sarRatio = [3, 2];break;\n              case 16:\n                sarRatio = [2, 1];break;\n              case 255:\n                {\n                  sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];\n                  break;\n                }\n            }\n            if (sarRatio) {\n              sarScale = sarRatio[0] / sarRatio[1];\n            }\n          }\n        }\n        return {\n          profileIdc: profileIdc,\n          levelIdc: levelIdc,\n          profileCompatibility: profileCompatibility,\n          width: Math.ceil(((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale),\n          height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2\n        };\n      };\n    };\n    _H264Stream.prototype = new stream();\n\n    var h264 = {\n      H264Stream: _H264Stream,\n      NalByteStream: _NalByteStream\n    };\n\n    // Constants\n    var _AacStream;\n\n    /**\n     * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n     */\n\n    _AacStream = function AacStream() {\n      var everything = new Uint8Array(),\n          timeStamp = 0;\n\n      _AacStream.prototype.init.call(this);\n\n      this.setTimestamp = function (timestamp) {\n        timeStamp = timestamp;\n      };\n\n      this.parseId3TagSize = function (header, byteIndex) {\n        var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9],\n            flags = header[byteIndex + 5],\n            footerPresent = (flags & 16) >> 4;\n\n        if (footerPresent) {\n          return returnSize + 20;\n        }\n        return returnSize + 10;\n      };\n\n      this.parseAdtsSize = function (header, byteIndex) {\n        var lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n            middle = header[byteIndex + 4] << 3,\n            highTwo = header[byteIndex + 3] & 0x3 << 11;\n\n        return highTwo | middle | lowThree;\n      };\n\n      this.push = function (bytes) {\n        var frameSize = 0,\n            byteIndex = 0,\n            bytesLeft,\n            chunk,\n            packet,\n            tempLength;\n\n        // If there are bytes remaining from the last segment, prepend them to the\n        // bytes that were pushed in\n        if (everything.length) {\n          tempLength = everything.length;\n          everything = new Uint8Array(bytes.byteLength + tempLength);\n          everything.set(everything.subarray(0, tempLength));\n          everything.set(bytes, tempLength);\n        } else {\n          everything = bytes;\n        }\n\n        while (everything.length - byteIndex >= 3) {\n          if (everything[byteIndex] === 'I'.charCodeAt(0) && everything[byteIndex + 1] === 'D'.charCodeAt(0) && everything[byteIndex + 2] === '3'.charCodeAt(0)) {\n\n            // Exit early because we don't have enough to parse\n            // the ID3 tag header\n            if (everything.length - byteIndex < 10) {\n              break;\n            }\n\n            // check framesize\n            frameSize = this.parseId3TagSize(everything, byteIndex);\n\n            // Exit early if we don't have enough in the buffer\n            // to emit a full packet\n            if (frameSize > everything.length) {\n              break;\n            }\n            chunk = {\n              type: 'timed-metadata',\n              data: everything.subarray(byteIndex, byteIndex + frameSize)\n            };\n            this.trigger('data', chunk);\n            byteIndex += frameSize;\n            continue;\n          } else if (everything[byteIndex] & 0xff === 0xff && (everything[byteIndex + 1] & 0xf0) === 0xf0) {\n\n            // Exit early because we don't have enough to parse\n            // the ADTS frame header\n            if (everything.length - byteIndex < 7) {\n              break;\n            }\n\n            frameSize = this.parseAdtsSize(everything, byteIndex);\n\n            // Exit early if we don't have enough in the buffer\n            // to emit a full packet\n            if (frameSize > everything.length) {\n              break;\n            }\n\n            packet = {\n              type: 'audio',\n              data: everything.subarray(byteIndex, byteIndex + frameSize),\n              pts: timeStamp,\n              dts: timeStamp\n            };\n            this.trigger('data', packet);\n            byteIndex += frameSize;\n            continue;\n          }\n          byteIndex++;\n        }\n        bytesLeft = everything.length - byteIndex;\n\n        if (bytesLeft > 0) {\n          everything = everything.subarray(byteIndex);\n        } else {\n          everything = new Uint8Array();\n        }\n      };\n    };\n\n    _AacStream.prototype = new stream();\n\n    var aac = _AacStream;\n\n    var highPrefix = [33, 16, 5, 32, 164, 27];\n    var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\n    var zeroFill = function zeroFill(count) {\n      var a = [];\n      while (count--) {\n        a.push(0);\n      }\n      return a;\n    };\n\n    var makeTable = function makeTable(metaTable) {\n      return Object.keys(metaTable).reduce(function (obj, key) {\n        obj[key] = new Uint8Array(metaTable[key].reduce(function (arr, part) {\n          return arr.concat(part);\n        }, []));\n        return obj;\n      }, {});\n    };\n\n    // Frames-of-silence to use for filling in missing AAC frames\n    var coneOfSilence = {\n      96000: [highPrefix, [227, 64], zeroFill(154), [56]],\n      88200: [highPrefix, [231], zeroFill(170), [56]],\n      64000: [highPrefix, [248, 192], zeroFill(240), [56]],\n      48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\n      44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\n      32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\n      24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\n      16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\n      12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\n      11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\n      8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\n    };\n\n    var silence = makeTable(coneOfSilence);\n\n    var ONE_SECOND_IN_TS = 90000,\n\n\n    // 90kHz clock\n    secondsToVideoTs,\n        secondsToAudioTs,\n        videoTsToSeconds,\n        audioTsToSeconds,\n        audioTsToVideoTs,\n        videoTsToAudioTs;\n\n    secondsToVideoTs = function secondsToVideoTs(seconds) {\n      return seconds * ONE_SECOND_IN_TS;\n    };\n\n    secondsToAudioTs = function secondsToAudioTs(seconds, sampleRate) {\n      return seconds * sampleRate;\n    };\n\n    videoTsToSeconds = function videoTsToSeconds(timestamp) {\n      return timestamp / ONE_SECOND_IN_TS;\n    };\n\n    audioTsToSeconds = function audioTsToSeconds(timestamp, sampleRate) {\n      return timestamp / sampleRate;\n    };\n\n    audioTsToVideoTs = function audioTsToVideoTs(timestamp, sampleRate) {\n      return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n    };\n\n    videoTsToAudioTs = function videoTsToAudioTs(timestamp, sampleRate) {\n      return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n    };\n\n    var clock = {\n      secondsToVideoTs: secondsToVideoTs,\n      secondsToAudioTs: secondsToAudioTs,\n      videoTsToSeconds: videoTsToSeconds,\n      audioTsToSeconds: audioTsToSeconds,\n      audioTsToVideoTs: audioTsToVideoTs,\n      videoTsToAudioTs: videoTsToAudioTs\n    };\n\n    var H264Stream = h264.H264Stream;\n\n    // constants\n    var AUDIO_PROPERTIES = ['audioobjecttype', 'channelcount', 'samplerate', 'samplingfrequencyindex', 'samplesize'];\n\n    var VIDEO_PROPERTIES = ['width', 'height', 'profileIdc', 'levelIdc', 'profileCompatibility'];\n\n    var ONE_SECOND_IN_TS$1 = 90000; // 90kHz clock\n\n    // object types\n    var _VideoSegmentStream, _AudioSegmentStream, _Transmuxer, _CoalesceStream;\n\n    // Helper functions\n    var createDefaultSample, isLikelyAacData, collectDtsInfo, clearDtsInfo, calculateTrackBaseMediaDecodeTime, arrayEquals, sumFrameByteLengths;\n\n    /**\n     * Default sample object\n     * see ISO/IEC 14496-12:2012, section 8.6.4.3\n     */\n    createDefaultSample = function createDefaultSample() {\n      return {\n        size: 0,\n        flags: {\n          isLeading: 0,\n          dependsOn: 1,\n          isDependedOn: 0,\n          hasRedundancy: 0,\n          degradationPriority: 0\n        }\n      };\n    };\n\n    isLikelyAacData = function isLikelyAacData(data) {\n      if (data[0] === 'I'.charCodeAt(0) && data[1] === 'D'.charCodeAt(0) && data[2] === '3'.charCodeAt(0)) {\n        return true;\n      }\n      return false;\n    };\n\n    /**\n     * Compare two arrays (even typed) for same-ness\n     */\n    arrayEquals = function arrayEquals(a, b) {\n      var i;\n\n      if (a.length !== b.length) {\n        return false;\n      }\n\n      // compare the value of each element in the array\n      for (i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    /**\n     * Sum the `byteLength` properties of the data in each AAC frame\n     */\n    sumFrameByteLengths = function sumFrameByteLengths(array) {\n      var i,\n          currentObj,\n          sum = 0;\n\n      // sum the byteLength's all each nal unit in the frame\n      for (i = 0; i < array.length; i++) {\n        currentObj = array[i];\n        sum += currentObj.data.byteLength;\n      }\n\n      return sum;\n    };\n\n    /**\n     * Constructs a single-track, ISO BMFF media segment from AAC data\n     * events. The output of this stream can be fed to a SourceBuffer\n     * configured with a suitable initialization segment.\n     * @param track {object} track metadata configuration\n     * @param options {object} transmuxer options object\n     * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n     *        in the source; false to adjust the first segment to start at 0.\n     */\n    _AudioSegmentStream = function AudioSegmentStream(track, options) {\n      var adtsFrames = [],\n          sequenceNumber = 0,\n          earliestAllowedDts = 0,\n          audioAppendStartTs = 0,\n          videoBaseMediaDecodeTime = Infinity;\n\n      options = options || {};\n\n      _AudioSegmentStream.prototype.init.call(this);\n\n      this.push = function (data) {\n        collectDtsInfo(track, data);\n\n        if (track) {\n          AUDIO_PROPERTIES.forEach(function (prop) {\n            track[prop] = data[prop];\n          });\n        }\n\n        // buffer audio data until end() is called\n        adtsFrames.push(data);\n      };\n\n      this.setEarliestDts = function (earliestDts) {\n        earliestAllowedDts = earliestDts - track.timelineStartInfo.baseMediaDecodeTime;\n      };\n\n      this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n        videoBaseMediaDecodeTime = baseMediaDecodeTime;\n      };\n\n      this.setAudioAppendStart = function (timestamp) {\n        audioAppendStartTs = timestamp;\n      };\n\n      this.flush = function () {\n        var frames, moof, mdat, boxes;\n\n        // return early if no audio data has been observed\n        if (adtsFrames.length === 0) {\n          this.trigger('done', 'AudioSegmentStream');\n          return;\n        }\n\n        frames = this.trimAdtsFramesByEarliestDts_(adtsFrames);\n        track.baseMediaDecodeTime = calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n\n        this.prefixWithSilence_(track, frames);\n\n        // we have to build the index from byte locations to\n        // samples (that is, adts frames) in the audio data\n        track.samples = this.generateSampleTable_(frames);\n\n        // concatenate the audio data to constuct the mdat\n        mdat = mp4Generator.mdat(this.concatenateFrameData_(frames));\n\n        adtsFrames = [];\n\n        moof = mp4Generator.moof(sequenceNumber, [track]);\n        boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n        // bump the sequence number for next time\n        sequenceNumber++;\n\n        boxes.set(moof);\n        boxes.set(mdat, moof.byteLength);\n\n        clearDtsInfo(track);\n\n        this.trigger('data', { track: track, boxes: boxes });\n        this.trigger('done', 'AudioSegmentStream');\n      };\n\n      // Possibly pad (prefix) the audio track with silence if appending this track\n      // would lead to the introduction of a gap in the audio buffer\n      this.prefixWithSilence_ = function (track, frames) {\n        var baseMediaDecodeTimeTs,\n            frameDuration = 0,\n            audioGapDuration = 0,\n            audioFillFrameCount = 0,\n            audioFillDuration = 0,\n            silentFrame,\n            i;\n\n        if (!frames.length) {\n          return;\n        }\n\n        baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);\n        // determine frame clock duration based on sample rate, round up to avoid overfills\n        frameDuration = Math.ceil(ONE_SECOND_IN_TS$1 / (track.samplerate / 1024));\n\n        if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n          // insert the shortest possible amount (audio gap or audio to video gap)\n          audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);\n          // number of full frames in the audio gap\n          audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n          audioFillDuration = audioFillFrameCount * frameDuration;\n        }\n\n        // don't attempt to fill gaps smaller than a single frame or larger\n        // than a half second\n        if (audioFillFrameCount < 1 || audioFillDuration > ONE_SECOND_IN_TS$1 / 2) {\n          return;\n        }\n\n        silentFrame = silence[track.samplerate];\n\n        if (!silentFrame) {\n          // we don't have a silent frame pregenerated for the sample rate, so use a frame\n          // from the content instead\n          silentFrame = frames[0].data;\n        }\n\n        for (i = 0; i < audioFillFrameCount; i++) {\n          frames.splice(i, 0, {\n            data: silentFrame\n          });\n        }\n\n        track.baseMediaDecodeTime -= Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));\n      };\n\n      // If the audio segment extends before the earliest allowed dts\n      // value, remove AAC frames until starts at or after the earliest\n      // allowed DTS so that we don't end up with a negative baseMedia-\n      // DecodeTime for the audio track\n      this.trimAdtsFramesByEarliestDts_ = function (adtsFrames) {\n        if (track.minSegmentDts >= earliestAllowedDts) {\n          return adtsFrames;\n        }\n\n        // We will need to recalculate the earliest segment Dts\n        track.minSegmentDts = Infinity;\n\n        return adtsFrames.filter(function (currentFrame) {\n          // If this is an allowed frame, keep it and record it's Dts\n          if (currentFrame.dts >= earliestAllowedDts) {\n            track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n            track.minSegmentPts = track.minSegmentDts;\n            return true;\n          }\n          // Otherwise, discard it\n          return false;\n        });\n      };\n\n      // generate the track's raw mdat data from an array of frames\n      this.generateSampleTable_ = function (frames) {\n        var i,\n            currentFrame,\n            samples = [];\n\n        for (i = 0; i < frames.length; i++) {\n          currentFrame = frames[i];\n          samples.push({\n            size: currentFrame.data.byteLength,\n            duration: 1024 // For AAC audio, all samples contain 1024 samples\n          });\n        }\n        return samples;\n      };\n\n      // generate the track's sample table from an array of frames\n      this.concatenateFrameData_ = function (frames) {\n        var i,\n            currentFrame,\n            dataOffset = 0,\n            data = new Uint8Array(sumFrameByteLengths(frames));\n\n        for (i = 0; i < frames.length; i++) {\n          currentFrame = frames[i];\n\n          data.set(currentFrame.data, dataOffset);\n          dataOffset += currentFrame.data.byteLength;\n        }\n        return data;\n      };\n    };\n\n    _AudioSegmentStream.prototype = new stream();\n\n    /**\n     * Constructs a single-track, ISO BMFF media segment from H264 data\n     * events. The output of this stream can be fed to a SourceBuffer\n     * configured with a suitable initialization segment.\n     * @param track {object} track metadata configuration\n     * @param options {object} transmuxer options object\n     * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n     *        gopsToAlignWith list when attempting to align gop pts\n     * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n     *        in the source; false to adjust the first segment to start at 0.\n     */\n    _VideoSegmentStream = function VideoSegmentStream(track, options) {\n      var sequenceNumber = 0,\n          nalUnits = [],\n          gopsToAlignWith = [],\n          config,\n          pps;\n\n      options = options || {};\n\n      _VideoSegmentStream.prototype.init.call(this);\n\n      delete track.minPTS;\n\n      this.gopCache_ = [];\n\n      this.push = function (nalUnit) {\n        collectDtsInfo(track, nalUnit);\n\n        // record the track config\n        if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n          config = nalUnit.config;\n          track.sps = [nalUnit.data];\n\n          VIDEO_PROPERTIES.forEach(function (prop) {\n            track[prop] = config[prop];\n          }, this);\n        }\n\n        if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n          pps = nalUnit.data;\n          track.pps = [nalUnit.data];\n        }\n\n        // buffer video until flush() is called\n        nalUnits.push(nalUnit);\n      };\n\n      this.flush = function () {\n        var frames, gopForFusion, gops, moof, mdat, boxes;\n\n        // Throw away nalUnits at the start of the byte stream until\n        // we find the first AUD\n        while (nalUnits.length) {\n          if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n            break;\n          }\n          nalUnits.shift();\n        }\n\n        // Return early if no video data has been observed\n        if (nalUnits.length === 0) {\n          this.resetStream_();\n          this.trigger('done', 'VideoSegmentStream');\n          return;\n        }\n\n        // Organize the raw nal-units into arrays that represent\n        // higher-level constructs such as frames and gops\n        // (group-of-pictures)\n        frames = this.groupNalsIntoFrames_(nalUnits);\n        gops = this.groupFramesIntoGops_(frames);\n\n        // If the first frame of this fragment is not a keyframe we have\n        // a problem since MSE (on Chrome) requires a leading keyframe.\n        //\n        // We have two approaches to repairing this situation:\n        // 1) GOP-FUSION:\n        //    This is where we keep track of the GOPS (group-of-pictures)\n        //    from previous fragments and attempt to find one that we can\n        //    prepend to the current fragment in order to create a valid\n        //    fragment.\n        // 2) KEYFRAME-PULLING:\n        //    Here we search for the first keyframe in the fragment and\n        //    throw away all the frames between the start of the fragment\n        //    and that keyframe. We then extend the duration and pull the\n        //    PTS of the keyframe forward so that it covers the time range\n        //    of the frames that were disposed of.\n        //\n        // #1 is far prefereable over #2 which can cause \"stuttering\" but\n        // requires more things to be just right.\n        if (!gops[0][0].keyFrame) {\n          // Search for a gop for fusion from our gopCache\n          gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n\n          if (gopForFusion) {\n            gops.unshift(gopForFusion);\n            // Adjust Gops' metadata to account for the inclusion of the\n            // new gop at the beginning\n            gops.byteLength += gopForFusion.byteLength;\n            gops.nalCount += gopForFusion.nalCount;\n            gops.pts = gopForFusion.pts;\n            gops.dts = gopForFusion.dts;\n            gops.duration += gopForFusion.duration;\n          } else {\n            // If we didn't find a candidate gop fall back to keyframe-pulling\n            gops = this.extendFirstKeyFrame_(gops);\n          }\n        }\n\n        // Trim gops to align with gopsToAlignWith\n        if (gopsToAlignWith.length) {\n          var alignedGops;\n\n          if (options.alignGopsAtEnd) {\n            alignedGops = this.alignGopsAtEnd_(gops);\n          } else {\n            alignedGops = this.alignGopsAtStart_(gops);\n          }\n\n          if (!alignedGops) {\n            // save all the nals in the last GOP into the gop cache\n            this.gopCache_.unshift({\n              gop: gops.pop(),\n              pps: track.pps,\n              sps: track.sps\n            });\n\n            // Keep a maximum of 6 GOPs in the cache\n            this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n            // Clear nalUnits\n            nalUnits = [];\n\n            // return early no gops can be aligned with desired gopsToAlignWith\n            this.resetStream_();\n            this.trigger('done', 'VideoSegmentStream');\n            return;\n          }\n\n          // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n          // when recalculated before sending off to CoalesceStream\n          clearDtsInfo(track);\n\n          gops = alignedGops;\n        }\n\n        collectDtsInfo(track, gops);\n\n        // First, we have to build the index from byte locations to\n        // samples (that is, frames) in the video data\n        track.samples = this.generateSampleTable_(gops);\n\n        // Concatenate the video data and construct the mdat\n        mdat = mp4Generator.mdat(this.concatenateNalData_(gops));\n\n        track.baseMediaDecodeTime = calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n\n        this.trigger('processedGopsInfo', gops.map(function (gop) {\n          return {\n            pts: gop.pts,\n            dts: gop.dts,\n            byteLength: gop.byteLength\n          };\n        }));\n\n        // save all the nals in the last GOP into the gop cache\n        this.gopCache_.unshift({\n          gop: gops.pop(),\n          pps: track.pps,\n          sps: track.sps\n        });\n\n        // Keep a maximum of 6 GOPs in the cache\n        this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n        // Clear nalUnits\n        nalUnits = [];\n\n        this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n        this.trigger('timelineStartInfo', track.timelineStartInfo);\n\n        moof = mp4Generator.moof(sequenceNumber, [track]);\n\n        // it would be great to allocate this array up front instead of\n        // throwing away hundreds of media segment fragments\n        boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n        // Bump the sequence number for next time\n        sequenceNumber++;\n\n        boxes.set(moof);\n        boxes.set(mdat, moof.byteLength);\n\n        this.trigger('data', { track: track, boxes: boxes });\n\n        this.resetStream_();\n\n        // Continue with the flush process now\n        this.trigger('done', 'VideoSegmentStream');\n      };\n\n      this.resetStream_ = function () {\n        clearDtsInfo(track);\n\n        // reset config and pps because they may differ across segments\n        // for instance, when we are rendition switching\n        config = undefined;\n        pps = undefined;\n      };\n\n      // Search for a candidate Gop for gop-fusion from the gop cache and\n      // return it or return null if no good candidate was found\n      this.getGopForFusion_ = function (nalUnit) {\n        var halfSecond = 45000,\n\n\n        // Half-a-second in a 90khz clock\n        allowableOverlap = 10000,\n\n\n        // About 3 frames @ 30fps\n        nearestDistance = Infinity,\n            dtsDistance,\n            nearestGopObj,\n            currentGop,\n            currentGopObj,\n            i;\n\n        // Search for the GOP nearest to the beginning of this nal unit\n        for (i = 0; i < this.gopCache_.length; i++) {\n          currentGopObj = this.gopCache_[i];\n          currentGop = currentGopObj.gop;\n\n          // Reject Gops with different SPS or PPS\n          if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n            continue;\n          }\n\n          // Reject Gops that would require a negative baseMediaDecodeTime\n          if (currentGop.dts < track.timelineStartInfo.dts) {\n            continue;\n          }\n\n          // The distance between the end of the gop and the start of the nalUnit\n          dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration;\n\n          // Only consider GOPS that start before the nal unit and end within\n          // a half-second of the nal unit\n          if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {\n\n            // Always use the closest GOP we found if there is more than\n            // one candidate\n            if (!nearestGopObj || nearestDistance > dtsDistance) {\n              nearestGopObj = currentGopObj;\n              nearestDistance = dtsDistance;\n            }\n          }\n        }\n\n        if (nearestGopObj) {\n          return nearestGopObj.gop;\n        }\n        return null;\n      };\n\n      this.extendFirstKeyFrame_ = function (gops) {\n        var currentGop;\n\n        if (!gops[0][0].keyFrame && gops.length > 1) {\n          // Remove the first GOP\n          currentGop = gops.shift();\n\n          gops.byteLength -= currentGop.byteLength;\n          gops.nalCount -= currentGop.nalCount;\n\n          // Extend the first frame of what is now the\n          // first gop to cover the time period of the\n          // frames we just removed\n          gops[0][0].dts = currentGop.dts;\n          gops[0][0].pts = currentGop.pts;\n          gops[0][0].duration += currentGop.duration;\n        }\n\n        return gops;\n      };\n\n      // Convert an array of nal units into an array of frames with each frame being\n      // composed of the nal units that make up that frame\n      // Also keep track of cummulative data about the frame from the nal units such\n      // as the frame duration, starting pts, etc.\n      this.groupNalsIntoFrames_ = function (nalUnits) {\n        var i,\n            currentNal,\n            currentFrame = [],\n            frames = [];\n\n        currentFrame.byteLength = 0;\n\n        for (i = 0; i < nalUnits.length; i++) {\n          currentNal = nalUnits[i];\n\n          // Split on 'aud'-type nal units\n          if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n            // Since the very first nal unit is expected to be an AUD\n            // only push to the frames array when currentFrame is not empty\n            if (currentFrame.length) {\n              currentFrame.duration = currentNal.dts - currentFrame.dts;\n              frames.push(currentFrame);\n            }\n            currentFrame = [currentNal];\n            currentFrame.byteLength = currentNal.data.byteLength;\n            currentFrame.pts = currentNal.pts;\n            currentFrame.dts = currentNal.dts;\n          } else {\n            // Specifically flag key frames for ease of use later\n            if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n              currentFrame.keyFrame = true;\n            }\n            currentFrame.duration = currentNal.dts - currentFrame.dts;\n            currentFrame.byteLength += currentNal.data.byteLength;\n            currentFrame.push(currentNal);\n          }\n        }\n\n        // For the last frame, use the duration of the previous frame if we\n        // have nothing better to go on\n        if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {\n          currentFrame.duration = frames[frames.length - 1].duration;\n        }\n\n        // Push the final frame\n        frames.push(currentFrame);\n        return frames;\n      };\n\n      // Convert an array of frames into an array of Gop with each Gop being composed\n      // of the frames that make up that Gop\n      // Also keep track of cummulative data about the Gop from the frames such as the\n      // Gop duration, starting pts, etc.\n      this.groupFramesIntoGops_ = function (frames) {\n        var i,\n            currentFrame,\n            currentGop = [],\n            gops = [];\n\n        // We must pre-set some of the values on the Gop since we\n        // keep running totals of these values\n        currentGop.byteLength = 0;\n        currentGop.nalCount = 0;\n        currentGop.duration = 0;\n        currentGop.pts = frames[0].pts;\n        currentGop.dts = frames[0].dts;\n\n        // store some metadata about all the Gops\n        gops.byteLength = 0;\n        gops.nalCount = 0;\n        gops.duration = 0;\n        gops.pts = frames[0].pts;\n        gops.dts = frames[0].dts;\n\n        for (i = 0; i < frames.length; i++) {\n          currentFrame = frames[i];\n\n          if (currentFrame.keyFrame) {\n            // Since the very first frame is expected to be an keyframe\n            // only push to the gops array when currentGop is not empty\n            if (currentGop.length) {\n              gops.push(currentGop);\n              gops.byteLength += currentGop.byteLength;\n              gops.nalCount += currentGop.nalCount;\n              gops.duration += currentGop.duration;\n            }\n\n            currentGop = [currentFrame];\n            currentGop.nalCount = currentFrame.length;\n            currentGop.byteLength = currentFrame.byteLength;\n            currentGop.pts = currentFrame.pts;\n            currentGop.dts = currentFrame.dts;\n            currentGop.duration = currentFrame.duration;\n          } else {\n            currentGop.duration += currentFrame.duration;\n            currentGop.nalCount += currentFrame.length;\n            currentGop.byteLength += currentFrame.byteLength;\n            currentGop.push(currentFrame);\n          }\n        }\n\n        if (gops.length && currentGop.duration <= 0) {\n          currentGop.duration = gops[gops.length - 1].duration;\n        }\n        gops.byteLength += currentGop.byteLength;\n        gops.nalCount += currentGop.nalCount;\n        gops.duration += currentGop.duration;\n\n        // push the final Gop\n        gops.push(currentGop);\n        return gops;\n      };\n\n      // generate the track's sample table from an array of gops\n      this.generateSampleTable_ = function (gops, baseDataOffset) {\n        var h,\n            i,\n            sample,\n            currentGop,\n            currentFrame,\n            dataOffset = baseDataOffset || 0,\n            samples = [];\n\n        for (h = 0; h < gops.length; h++) {\n          currentGop = gops[h];\n\n          for (i = 0; i < currentGop.length; i++) {\n            currentFrame = currentGop[i];\n\n            sample = createDefaultSample();\n\n            sample.dataOffset = dataOffset;\n            sample.compositionTimeOffset = currentFrame.pts - currentFrame.dts;\n            sample.duration = currentFrame.duration;\n            sample.size = 4 * currentFrame.length; // Space for nal unit size\n            sample.size += currentFrame.byteLength;\n\n            if (currentFrame.keyFrame) {\n              sample.flags.dependsOn = 2;\n            }\n\n            dataOffset += sample.size;\n\n            samples.push(sample);\n          }\n        }\n        return samples;\n      };\n\n      // generate the track's raw mdat data from an array of gops\n      this.concatenateNalData_ = function (gops) {\n        var h,\n            i,\n            j,\n            currentGop,\n            currentFrame,\n            currentNal,\n            dataOffset = 0,\n            nalsByteLength = gops.byteLength,\n            numberOfNals = gops.nalCount,\n            totalByteLength = nalsByteLength + 4 * numberOfNals,\n            data = new Uint8Array(totalByteLength),\n            view = new DataView(data.buffer);\n\n        // For each Gop..\n        for (h = 0; h < gops.length; h++) {\n          currentGop = gops[h];\n\n          // For each Frame..\n          for (i = 0; i < currentGop.length; i++) {\n            currentFrame = currentGop[i];\n\n            // For each NAL..\n            for (j = 0; j < currentFrame.length; j++) {\n              currentNal = currentFrame[j];\n\n              view.setUint32(dataOffset, currentNal.data.byteLength);\n              dataOffset += 4;\n              data.set(currentNal.data, dataOffset);\n              dataOffset += currentNal.data.byteLength;\n            }\n          }\n        }\n        return data;\n      };\n\n      // trim gop list to the first gop found that has a matching pts with a gop in the list\n      // of gopsToAlignWith starting from the START of the list\n      this.alignGopsAtStart_ = function (gops) {\n        var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n\n        byteLength = gops.byteLength;\n        nalCount = gops.nalCount;\n        duration = gops.duration;\n        alignIndex = gopIndex = 0;\n\n        while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n          align = gopsToAlignWith[alignIndex];\n          gop = gops[gopIndex];\n\n          if (align.pts === gop.pts) {\n            break;\n          }\n\n          if (gop.pts > align.pts) {\n            // this current gop starts after the current gop we want to align on, so increment\n            // align index\n            alignIndex++;\n            continue;\n          }\n\n          // current gop starts before the current gop we want to align on. so increment gop\n          // index\n          gopIndex++;\n          byteLength -= gop.byteLength;\n          nalCount -= gop.nalCount;\n          duration -= gop.duration;\n        }\n\n        if (gopIndex === 0) {\n          // no gops to trim\n          return gops;\n        }\n\n        if (gopIndex === gops.length) {\n          // all gops trimmed, skip appending all gops\n          return null;\n        }\n\n        alignedGops = gops.slice(gopIndex);\n        alignedGops.byteLength = byteLength;\n        alignedGops.duration = duration;\n        alignedGops.nalCount = nalCount;\n        alignedGops.pts = alignedGops[0].pts;\n        alignedGops.dts = alignedGops[0].dts;\n\n        return alignedGops;\n      };\n\n      // trim gop list to the first gop found that has a matching pts with a gop in the list\n      // of gopsToAlignWith starting from the END of the list\n      this.alignGopsAtEnd_ = function (gops) {\n        var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n\n        alignIndex = gopsToAlignWith.length - 1;\n        gopIndex = gops.length - 1;\n        alignEndIndex = null;\n        matchFound = false;\n\n        while (alignIndex >= 0 && gopIndex >= 0) {\n          align = gopsToAlignWith[alignIndex];\n          gop = gops[gopIndex];\n\n          if (align.pts === gop.pts) {\n            matchFound = true;\n            break;\n          }\n\n          if (align.pts > gop.pts) {\n            alignIndex--;\n            continue;\n          }\n\n          if (alignIndex === gopsToAlignWith.length - 1) {\n            // gop.pts is greater than the last alignment candidate. If no match is found\n            // by the end of this loop, we still want to append gops that come after this\n            // point\n            alignEndIndex = gopIndex;\n          }\n\n          gopIndex--;\n        }\n\n        if (!matchFound && alignEndIndex === null) {\n          return null;\n        }\n\n        var trimIndex;\n\n        if (matchFound) {\n          trimIndex = gopIndex;\n        } else {\n          trimIndex = alignEndIndex;\n        }\n\n        if (trimIndex === 0) {\n          return gops;\n        }\n\n        var alignedGops = gops.slice(trimIndex);\n        var metadata = alignedGops.reduce(function (total, gop) {\n          total.byteLength += gop.byteLength;\n          total.duration += gop.duration;\n          total.nalCount += gop.nalCount;\n          return total;\n        }, { byteLength: 0, duration: 0, nalCount: 0 });\n\n        alignedGops.byteLength = metadata.byteLength;\n        alignedGops.duration = metadata.duration;\n        alignedGops.nalCount = metadata.nalCount;\n        alignedGops.pts = alignedGops[0].pts;\n        alignedGops.dts = alignedGops[0].dts;\n\n        return alignedGops;\n      };\n\n      this.alignGopsWith = function (newGopsToAlignWith) {\n        gopsToAlignWith = newGopsToAlignWith;\n      };\n    };\n\n    _VideoSegmentStream.prototype = new stream();\n\n    /**\n     * Store information about the start and end of the track and the\n     * duration for each frame/sample we process in order to calculate\n     * the baseMediaDecodeTime\n     */\n    collectDtsInfo = function collectDtsInfo(track, data) {\n      if (typeof data.pts === 'number') {\n        if (track.timelineStartInfo.pts === undefined) {\n          track.timelineStartInfo.pts = data.pts;\n        }\n\n        if (track.minSegmentPts === undefined) {\n          track.minSegmentPts = data.pts;\n        } else {\n          track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n        }\n\n        if (track.maxSegmentPts === undefined) {\n          track.maxSegmentPts = data.pts;\n        } else {\n          track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n        }\n      }\n\n      if (typeof data.dts === 'number') {\n        if (track.timelineStartInfo.dts === undefined) {\n          track.timelineStartInfo.dts = data.dts;\n        }\n\n        if (track.minSegmentDts === undefined) {\n          track.minSegmentDts = data.dts;\n        } else {\n          track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n        }\n\n        if (track.maxSegmentDts === undefined) {\n          track.maxSegmentDts = data.dts;\n        } else {\n          track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n        }\n      }\n    };\n\n    /**\n     * Clear values used to calculate the baseMediaDecodeTime between\n     * tracks\n     */\n    clearDtsInfo = function clearDtsInfo(track) {\n      delete track.minSegmentDts;\n      delete track.maxSegmentDts;\n      delete track.minSegmentPts;\n      delete track.maxSegmentPts;\n    };\n\n    /**\n     * Calculate the track's baseMediaDecodeTime based on the earliest\n     * DTS the transmuxer has ever seen and the minimum DTS for the\n     * current track\n     * @param track {object} track metadata configuration\n     * @param keepOriginalTimestamps {boolean} If true, keep the timestamps\n     *        in the source; false to adjust the first segment to start at 0.\n     */\n    calculateTrackBaseMediaDecodeTime = function calculateTrackBaseMediaDecodeTime(track, keepOriginalTimestamps) {\n      var baseMediaDecodeTime,\n          scale,\n          minSegmentDts = track.minSegmentDts;\n\n      // Optionally adjust the time so the first segment starts at zero.\n      if (!keepOriginalTimestamps) {\n        minSegmentDts -= track.timelineStartInfo.dts;\n      }\n\n      // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n      // we want the start of the first segment to be placed\n      baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;\n\n      // Add to that the distance this segment is from the very first\n      baseMediaDecodeTime += minSegmentDts;\n\n      // baseMediaDecodeTime must not become negative\n      baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n\n      if (track.type === 'audio') {\n        // Audio has a different clock equal to the sampling_rate so we need to\n        // scale the PTS values into the clock rate of the track\n        scale = track.samplerate / ONE_SECOND_IN_TS$1;\n        baseMediaDecodeTime *= scale;\n        baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n      }\n\n      return baseMediaDecodeTime;\n    };\n\n    /**\n     * A Stream that can combine multiple streams (ie. audio & video)\n     * into a single output segment for MSE. Also supports audio-only\n     * and video-only streams.\n     */\n    _CoalesceStream = function CoalesceStream(options, metadataStream) {\n      // Number of Tracks per output segment\n      // If greater than 1, we combine multiple\n      // tracks into a single segment\n      this.numberOfTracks = 0;\n      this.metadataStream = metadataStream;\n\n      if (typeof options.remux !== 'undefined') {\n        this.remuxTracks = !!options.remux;\n      } else {\n        this.remuxTracks = true;\n      }\n\n      this.pendingTracks = [];\n      this.videoTrack = null;\n      this.pendingBoxes = [];\n      this.pendingCaptions = [];\n      this.pendingMetadata = [];\n      this.pendingBytes = 0;\n      this.emittedTracks = 0;\n\n      _CoalesceStream.prototype.init.call(this);\n\n      // Take output from multiple\n      this.push = function (output) {\n        // buffer incoming captions until the associated video segment\n        // finishes\n        if (output.text) {\n          return this.pendingCaptions.push(output);\n        }\n        // buffer incoming id3 tags until the final flush\n        if (output.frames) {\n          return this.pendingMetadata.push(output);\n        }\n\n        // Add this track to the list of pending tracks and store\n        // important information required for the construction of\n        // the final segment\n        this.pendingTracks.push(output.track);\n        this.pendingBoxes.push(output.boxes);\n        this.pendingBytes += output.boxes.byteLength;\n\n        if (output.track.type === 'video') {\n          this.videoTrack = output.track;\n        }\n        if (output.track.type === 'audio') {\n          this.audioTrack = output.track;\n        }\n      };\n    };\n\n    _CoalesceStream.prototype = new stream();\n    _CoalesceStream.prototype.flush = function (flushSource) {\n      var offset = 0,\n          event = {\n        captions: [],\n        captionStreams: {},\n        metadata: [],\n        info: {}\n      },\n          caption,\n          id3,\n          initSegment,\n          timelineStartPts = 0,\n          i;\n\n      if (this.pendingTracks.length < this.numberOfTracks) {\n        if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n          // Return because we haven't received a flush from a data-generating\n          // portion of the segment (meaning that we have only recieved meta-data\n          // or captions.)\n          return;\n        } else if (this.remuxTracks) {\n          // Return until we have enough tracks from the pipeline to remux (if we\n          // are remuxing audio and video into a single MP4)\n          return;\n        } else if (this.pendingTracks.length === 0) {\n          // In the case where we receive a flush without any data having been\n          // received we consider it an emitted track for the purposes of coalescing\n          // `done` events.\n          // We do this for the case where there is an audio and video track in the\n          // segment but no audio data. (seen in several playlists with alternate\n          // audio tracks and no audio present in the main TS segments.)\n          this.emittedTracks++;\n\n          if (this.emittedTracks >= this.numberOfTracks) {\n            this.trigger('done');\n            this.emittedTracks = 0;\n          }\n          return;\n        }\n      }\n\n      if (this.videoTrack) {\n        timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n        VIDEO_PROPERTIES.forEach(function (prop) {\n          event.info[prop] = this.videoTrack[prop];\n        }, this);\n      } else if (this.audioTrack) {\n        timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n        AUDIO_PROPERTIES.forEach(function (prop) {\n          event.info[prop] = this.audioTrack[prop];\n        }, this);\n      }\n\n      if (this.pendingTracks.length === 1) {\n        event.type = this.pendingTracks[0].type;\n      } else {\n        event.type = 'combined';\n      }\n\n      this.emittedTracks += this.pendingTracks.length;\n\n      initSegment = mp4Generator.initSegment(this.pendingTracks);\n\n      // Create a new typed array to hold the init segment\n      event.initSegment = new Uint8Array(initSegment.byteLength);\n\n      // Create an init segment containing a moov\n      // and track definitions\n      event.initSegment.set(initSegment);\n\n      // Create a new typed array to hold the moof+mdats\n      event.data = new Uint8Array(this.pendingBytes);\n\n      // Append each moof+mdat (one per track) together\n      for (i = 0; i < this.pendingBoxes.length; i++) {\n        event.data.set(this.pendingBoxes[i], offset);\n        offset += this.pendingBoxes[i].byteLength;\n      }\n\n      // Translate caption PTS times into second offsets into the\n      // video timeline for the segment, and add track info\n      for (i = 0; i < this.pendingCaptions.length; i++) {\n        caption = this.pendingCaptions[i];\n        caption.startTime = caption.startPts - timelineStartPts;\n        caption.startTime /= 90e3;\n        caption.endTime = caption.endPts - timelineStartPts;\n        caption.endTime /= 90e3;\n        event.captionStreams[caption.stream] = true;\n        event.captions.push(caption);\n      }\n\n      // Translate ID3 frame PTS times into second offsets into the\n      // video timeline for the segment\n      for (i = 0; i < this.pendingMetadata.length; i++) {\n        id3 = this.pendingMetadata[i];\n        id3.cueTime = id3.pts - timelineStartPts;\n        id3.cueTime /= 90e3;\n        event.metadata.push(id3);\n      }\n      // We add this to every single emitted segment even though we only need\n      // it for the first\n      event.metadata.dispatchType = this.metadataStream.dispatchType;\n\n      // Reset stream state\n      this.pendingTracks.length = 0;\n      this.videoTrack = null;\n      this.pendingBoxes.length = 0;\n      this.pendingCaptions.length = 0;\n      this.pendingBytes = 0;\n      this.pendingMetadata.length = 0;\n\n      // Emit the built segment\n      this.trigger('data', event);\n\n      // Only emit `done` if all tracks have been flushed and emitted\n      if (this.emittedTracks >= this.numberOfTracks) {\n        this.trigger('done');\n        this.emittedTracks = 0;\n      }\n    };\n    /**\n     * A Stream that expects MP2T binary data as input and produces\n     * corresponding media segments, suitable for use with Media Source\n     * Extension (MSE) implementations that support the ISO BMFF byte\n     * stream format, like Chrome.\n     */\n    _Transmuxer = function Transmuxer(options) {\n      var self = this,\n          hasFlushed = true,\n          videoTrack,\n          audioTrack;\n\n      _Transmuxer.prototype.init.call(this);\n\n      options = options || {};\n      this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n      this.transmuxPipeline_ = {};\n\n      this.setupAacPipeline = function () {\n        var pipeline = {};\n        this.transmuxPipeline_ = pipeline;\n\n        pipeline.type = 'aac';\n        pipeline.metadataStream = new m2ts_1.MetadataStream();\n\n        // set up the parsing pipeline\n        pipeline.aacStream = new aac();\n        pipeline.audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('audio');\n        pipeline.timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('timed-metadata');\n        pipeline.adtsStream = new adts();\n        pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);\n        pipeline.headOfPipeline = pipeline.aacStream;\n\n        pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);\n        pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);\n\n        pipeline.metadataStream.on('timestamp', function (frame) {\n          pipeline.aacStream.setTimestamp(frame.timeStamp);\n        });\n\n        pipeline.aacStream.on('data', function (data) {\n          if (data.type === 'timed-metadata' && !pipeline.audioSegmentStream) {\n            audioTrack = audioTrack || {\n              timelineStartInfo: {\n                baseMediaDecodeTime: self.baseMediaDecodeTime\n              },\n              codec: 'adts',\n              type: 'audio'\n            };\n            // hook up the audio segment stream to the first track with aac data\n            pipeline.coalesceStream.numberOfTracks++;\n            pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);\n            // Set up the final part of the audio pipeline\n            pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);\n          }\n        });\n\n        // Re-emit any data coming from the coalesce stream to the outside world\n        pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n        // Let the consumer know we have finished flushing the entire pipeline\n        pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n      };\n\n      this.setupTsPipeline = function () {\n        var pipeline = {};\n        this.transmuxPipeline_ = pipeline;\n\n        pipeline.type = 'ts';\n        pipeline.metadataStream = new m2ts_1.MetadataStream();\n\n        // set up the parsing pipeline\n        pipeline.packetStream = new m2ts_1.TransportPacketStream();\n        pipeline.parseStream = new m2ts_1.TransportParseStream();\n        pipeline.elementaryStream = new m2ts_1.ElementaryStream();\n        pipeline.videoTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('video');\n        pipeline.audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('audio');\n        pipeline.timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('timed-metadata');\n        pipeline.adtsStream = new adts();\n        pipeline.h264Stream = new H264Stream();\n        pipeline.captionStream = new m2ts_1.CaptionStream();\n        pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);\n        pipeline.headOfPipeline = pipeline.packetStream;\n\n        // disassemble MPEG2-TS packets into elementary streams\n        pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream);\n\n        // !!THIS ORDER IS IMPORTANT!!\n        // demux the streams\n        pipeline.elementaryStream.pipe(pipeline.videoTimestampRolloverStream).pipe(pipeline.h264Stream);\n        pipeline.elementaryStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);\n\n        pipeline.elementaryStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);\n\n        // Hook up CEA-608/708 caption stream\n        pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);\n\n        pipeline.elementaryStream.on('data', function (data) {\n          var i;\n\n          if (data.type === 'metadata') {\n            i = data.tracks.length;\n\n            // scan the tracks listed in the metadata\n            while (i--) {\n              if (!videoTrack && data.tracks[i].type === 'video') {\n                videoTrack = data.tracks[i];\n                videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n              } else if (!audioTrack && data.tracks[i].type === 'audio') {\n                audioTrack = data.tracks[i];\n                audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n              }\n            }\n\n            // hook up the video segment stream to the first track with h264 data\n            if (videoTrack && !pipeline.videoSegmentStream) {\n              pipeline.coalesceStream.numberOfTracks++;\n              pipeline.videoSegmentStream = new _VideoSegmentStream(videoTrack, options);\n\n              pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n                // When video emits timelineStartInfo data after a flush, we forward that\n                // info to the AudioSegmentStream, if it exists, because video timeline\n                // data takes precedence.\n                if (audioTrack) {\n                  audioTrack.timelineStartInfo = timelineStartInfo;\n                  // On the first segment we trim AAC frames that exist before the\n                  // very earliest DTS we have seen in video because Chrome will\n                  // interpret any video track with a baseMediaDecodeTime that is\n                  // non-zero as a gap.\n                  pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts);\n                }\n              });\n\n              pipeline.videoSegmentStream.on('processedGopsInfo', self.trigger.bind(self, 'gopInfo'));\n\n              pipeline.videoSegmentStream.on('baseMediaDecodeTime', function (baseMediaDecodeTime) {\n                if (audioTrack) {\n                  pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n                }\n              });\n\n              // Set up the final part of the video pipeline\n              pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);\n            }\n\n            if (audioTrack && !pipeline.audioSegmentStream) {\n              // hook up the audio segment stream to the first track with aac data\n              pipeline.coalesceStream.numberOfTracks++;\n              pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);\n\n              // Set up the final part of the audio pipeline\n              pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);\n            }\n          }\n        });\n\n        // Re-emit any data coming from the coalesce stream to the outside world\n        pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n        // Let the consumer know we have finished flushing the entire pipeline\n        pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n      };\n\n      // hook up the segment streams once track metadata is delivered\n      this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n        var pipeline = this.transmuxPipeline_;\n\n        this.baseMediaDecodeTime = baseMediaDecodeTime;\n        if (audioTrack) {\n          audioTrack.timelineStartInfo.dts = undefined;\n          audioTrack.timelineStartInfo.pts = undefined;\n          clearDtsInfo(audioTrack);\n          audioTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n          if (pipeline.audioTimestampRolloverStream) {\n            pipeline.audioTimestampRolloverStream.discontinuity();\n          }\n        }\n        if (videoTrack) {\n          if (pipeline.videoSegmentStream) {\n            pipeline.videoSegmentStream.gopCache_ = [];\n            pipeline.videoTimestampRolloverStream.discontinuity();\n          }\n          videoTrack.timelineStartInfo.dts = undefined;\n          videoTrack.timelineStartInfo.pts = undefined;\n          clearDtsInfo(videoTrack);\n          pipeline.captionStream.reset();\n          videoTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n        }\n\n        if (pipeline.timedMetadataTimestampRolloverStream) {\n          pipeline.timedMetadataTimestampRolloverStream.discontinuity();\n        }\n      };\n\n      this.setAudioAppendStart = function (timestamp) {\n        if (audioTrack) {\n          this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n        }\n      };\n\n      this.alignGopsWith = function (gopsToAlignWith) {\n        if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n          this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n        }\n      };\n\n      // feed incoming data to the front of the parsing pipeline\n      this.push = function (data) {\n        if (hasFlushed) {\n          var isAac = isLikelyAacData(data);\n\n          if (isAac && this.transmuxPipeline_.type !== 'aac') {\n            this.setupAacPipeline();\n          } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n            this.setupTsPipeline();\n          }\n          hasFlushed = false;\n        }\n        this.transmuxPipeline_.headOfPipeline.push(data);\n      };\n\n      // flush any buffered data\n      this.flush = function () {\n        hasFlushed = true;\n        // Start at the top of the pipeline and flush all pending work\n        this.transmuxPipeline_.headOfPipeline.flush();\n      };\n\n      // Caption data has to be reset when seeking outside buffered range\n      this.resetCaptions = function () {\n        if (this.transmuxPipeline_.captionStream) {\n          this.transmuxPipeline_.captionStream.reset();\n        }\n      };\n    };\n    _Transmuxer.prototype = new stream();\n\n    var transmuxer = {\n      Transmuxer: _Transmuxer,\n      VideoSegmentStream: _VideoSegmentStream,\n      AudioSegmentStream: _AudioSegmentStream,\n      AUDIO_PROPERTIES: AUDIO_PROPERTIES,\n      VIDEO_PROPERTIES: VIDEO_PROPERTIES\n    };\n\n    var mp4 = {\n      generator: mp4Generator,\n      Transmuxer: transmuxer.Transmuxer,\n      AudioSegmentStream: transmuxer.AudioSegmentStream,\n      VideoSegmentStream: transmuxer.VideoSegmentStream\n    };\n\n    var classCallCheck$$1 = function classCallCheck$$1(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    };\n\n    var createClass$$1 = function () {\n      function defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      return function (Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n      };\n    }();\n\n    /**\n     * @file transmuxer-worker.js\n     */\n\n    /**\n     * Re-emits transmuxer events by converting them into messages to the\n     * world outside the worker.\n     *\n     * @param {Object} transmuxer the transmuxer to wire events on\n     * @private\n     */\n    var wireTransmuxerEvents = function wireTransmuxerEvents(transmuxer) {\n      transmuxer.on('data', function (segment) {\n        // transfer ownership of the underlying ArrayBuffer\n        // instead of doing a copy to save memory\n        // ArrayBuffers are transferable but generic TypedArrays are not\n        // @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers#Passing_data_by_transferring_ownership_(transferable_objects)\n        var initArray = segment.initSegment;\n\n        segment.initSegment = {\n          data: initArray.buffer,\n          byteOffset: initArray.byteOffset,\n          byteLength: initArray.byteLength\n        };\n\n        var typedArray = segment.data;\n\n        segment.data = typedArray.buffer;\n        window_1.postMessage({\n          action: 'data',\n          segment: segment,\n          byteOffset: typedArray.byteOffset,\n          byteLength: typedArray.byteLength\n        }, [segment.data]);\n      });\n\n      if (transmuxer.captionStream) {\n        transmuxer.captionStream.on('data', function (caption) {\n          window_1.postMessage({\n            action: 'caption',\n            data: caption\n          });\n        });\n      }\n\n      transmuxer.on('done', function (data) {\n        window_1.postMessage({ action: 'done' });\n      });\n\n      transmuxer.on('gopInfo', function (gopInfo) {\n        window_1.postMessage({\n          action: 'gopInfo',\n          gopInfo: gopInfo\n        });\n      });\n    };\n\n    /**\n     * All incoming messages route through this hash. If no function exists\n     * to handle an incoming message, then we ignore the message.\n     *\n     * @class MessageHandlers\n     * @param {Object} options the options to initialize with\n     */\n\n    var MessageHandlers = function () {\n      function MessageHandlers(options) {\n        classCallCheck$$1(this, MessageHandlers);\n\n        this.options = options || {};\n        this.init();\n      }\n\n      /**\n       * initialize our web worker and wire all the events.\n       */\n\n      createClass$$1(MessageHandlers, [{\n        key: 'init',\n        value: function init() {\n          if (this.transmuxer) {\n            this.transmuxer.dispose();\n          }\n          this.transmuxer = new mp4.Transmuxer(this.options);\n          wireTransmuxerEvents(this.transmuxer);\n        }\n\n        /**\n         * Adds data (a ts segment) to the start of the transmuxer pipeline for\n         * processing.\n         *\n         * @param {ArrayBuffer} data data to push into the muxer\n         */\n\n      }, {\n        key: 'push',\n        value: function push(data) {\n          // Cast array buffer to correct type for transmuxer\n          var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\n\n          this.transmuxer.push(segment);\n        }\n\n        /**\n         * Recreate the transmuxer so that the next segment added via `push`\n         * start with a fresh transmuxer.\n         */\n\n      }, {\n        key: 'reset',\n        value: function reset() {\n          this.init();\n        }\n\n        /**\n         * Set the value that will be used as the `baseMediaDecodeTime` time for the\n         * next segment pushed in. Subsequent segments will have their `baseMediaDecodeTime`\n         * set relative to the first based on the PTS values.\n         *\n         * @param {Object} data used to set the timestamp offset in the muxer\n         */\n\n      }, {\n        key: 'setTimestampOffset',\n        value: function setTimestampOffset(data) {\n          var timestampOffset = data.timestampOffset || 0;\n\n          this.transmuxer.setBaseMediaDecodeTime(Math.round(timestampOffset * 90000));\n        }\n      }, {\n        key: 'setAudioAppendStart',\n        value: function setAudioAppendStart(data) {\n          this.transmuxer.setAudioAppendStart(Math.ceil(data.appendStart * 90000));\n        }\n\n        /**\n         * Forces the pipeline to finish processing the last segment and emit it's\n         * results.\n         *\n         * @param {Object} data event data, not really used\n         */\n\n      }, {\n        key: 'flush',\n        value: function flush(data) {\n          this.transmuxer.flush();\n        }\n      }, {\n        key: 'resetCaptions',\n        value: function resetCaptions() {\n          this.transmuxer.resetCaptions();\n        }\n      }, {\n        key: 'alignGopsWith',\n        value: function alignGopsWith(data) {\n          this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());\n        }\n      }]);\n      return MessageHandlers;\n    }();\n\n    /**\n     * Our web wroker interface so that things can talk to mux.js\n     * that will be running in a web worker. the scope is passed to this by\n     * webworkify.\n     *\n     * @param {Object} self the scope for the web worker\n     */\n\n    var TransmuxerWorker = function TransmuxerWorker(self) {\n      self.onmessage = function (event) {\n        if (event.data.action === 'init' && event.data.options) {\n          this.messageHandlers = new MessageHandlers(event.data.options);\n          return;\n        }\n\n        if (!this.messageHandlers) {\n          this.messageHandlers = new MessageHandlers();\n        }\n\n        if (event.data && event.data.action && event.data.action !== 'init') {\n          if (this.messageHandlers[event.data.action]) {\n            this.messageHandlers[event.data.action](event.data);\n          }\n        }\n      };\n    };\n\n    var transmuxerWorker = new TransmuxerWorker(self);\n\n    return transmuxerWorker;\n  }();\n});\n\n/**\n * @file codec-utils.js\n */\n\n/**\n * Check if a codec string refers to an audio codec.\n *\n * @param {String} codec codec string to check\n * @return {Boolean} if this is an audio codec\n * @private\n */\nvar isAudioCodec = function isAudioCodec(codec) {\n  return (/mp4a\\.\\d+.\\d+/i.test(codec)\n  );\n};\n\n/**\n * Check if a codec string refers to a video codec.\n *\n * @param {String} codec codec string to check\n * @return {Boolean} if this is a video codec\n * @private\n */\nvar isVideoCodec = function isVideoCodec(codec) {\n  return (/avc1\\.[\\da-f]+/i.test(codec)\n  );\n};\n\n/**\n * Parse a content type header into a type and parameters\n * object\n *\n * @param {String} type the content type header\n * @return {Object} the parsed content-type\n * @private\n */\nvar parseContentType = function parseContentType(type) {\n  var object = { type: '', parameters: {} };\n  var parameters = type.trim().split(';');\n\n  // first parameter should always be content-type\n  object.type = parameters.shift().trim();\n  parameters.forEach(function (parameter) {\n    var pair = parameter.trim().split('=');\n\n    if (pair.length > 1) {\n      var name = pair[0].replace(/\"/g, '').trim();\n      var value = pair[1].replace(/\"/g, '').trim();\n\n      object.parameters[name] = value;\n    }\n  });\n\n  return object;\n};\n\n/**\n * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\n * `avc1.<hhhhhh>`\n *\n * @param {Array} codecs an array of codec strings to fix\n * @return {Array} the translated codec array\n * @private\n */\nvar translateLegacyCodecs = function translateLegacyCodecs(codecs) {\n  return codecs.map(function (codec) {\n    return codec.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (orig, profile, avcLevel) {\n      var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\n      var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\n\n      return 'avc1.' + profileHex + '00' + avcLevelHex;\n    });\n  });\n};\n\n/**\n * @file virtual-source-buffer.js\n */\n\n// We create a wrapper around the SourceBuffer so that we can manage the\n// state of the `updating` property manually. We have to do this because\n// Firefox changes `updating` to false long before triggering `updateend`\n// events and that was causing strange problems in videojs-contrib-hls\nvar makeWrappedSourceBuffer = function makeWrappedSourceBuffer(mediaSource, mimeType) {\n  var sourceBuffer = mediaSource.addSourceBuffer(mimeType);\n  var wrapper = Object.create(null);\n\n  wrapper.updating = false;\n  wrapper.realBuffer_ = sourceBuffer;\n\n  var _loop = function _loop(key) {\n    if (typeof sourceBuffer[key] === 'function') {\n      wrapper[key] = function () {\n        return sourceBuffer[key].apply(sourceBuffer, arguments);\n      };\n    } else if (typeof wrapper[key] === 'undefined') {\n      Object.defineProperty(wrapper, key, {\n        get: function get$$1() {\n          return sourceBuffer[key];\n        },\n        set: function set$$1(v) {\n          return sourceBuffer[key] = v;\n        }\n      });\n    }\n  };\n\n  for (var key in sourceBuffer) {\n    _loop(key);\n  }\n\n  return wrapper;\n};\n\n/**\n * Returns a list of gops in the buffer that have a pts value of 3 seconds or more in\n * front of current time.\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Player} player\n *        The player instance\n * @param {Double} mapping\n *        Offset to map display time to stream presentation time\n * @return {Array}\n *         List of gops considered safe to append over\n */\nvar gopsSafeToAlignWith = function gopsSafeToAlignWith(buffer, player, mapping) {\n  if (!player || !buffer.length) {\n    return [];\n  }\n\n  // pts value for current time + 3 seconds to give a bit more wiggle room\n  var currentTimePts = Math.ceil((player.currentTime() - mapping + 3) * 90000);\n\n  var i = void 0;\n\n  for (i = 0; i < buffer.length; i++) {\n    if (buffer[i].pts > currentTimePts) {\n      break;\n    }\n  }\n\n  return buffer.slice(i);\n};\n\n/**\n * Appends gop information (timing and byteLength) received by the transmuxer for the\n * gops appended in the last call to appendBuffer\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Array} gops\n *        List of new gop information\n * @param {boolean} replace\n *        If true, replace the buffer with the new gop information. If false, append the\n *        new gop information to the buffer in the right location of time.\n * @return {Array}\n *         Updated list of gop information\n */\nvar updateGopBuffer = function updateGopBuffer(buffer, gops, replace) {\n  if (!gops.length) {\n    return buffer;\n  }\n\n  if (replace) {\n    // If we are in safe append mode, then completely overwrite the gop buffer\n    // with the most recent appeneded data. This will make sure that when appending\n    // future segments, we only try to align with gops that are both ahead of current\n    // time and in the last segment appended.\n    return gops.slice();\n  }\n\n  var start = gops[0].pts;\n\n  var i = 0;\n\n  for (i; i < buffer.length; i++) {\n    if (buffer[i].pts >= start) {\n      break;\n    }\n  }\n\n  return buffer.slice(0, i).concat(gops);\n};\n\n/**\n * Removes gop information in buffer that overlaps with provided start and end\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Double} start\n *        position to start the remove at\n * @param {Double} end\n *        position to end the remove at\n * @param {Double} mapping\n *        Offset to map display time to stream presentation time\n */\nvar removeGopBuffer = function removeGopBuffer(buffer, start, end, mapping) {\n  var startPts = Math.ceil((start - mapping) * 90000);\n  var endPts = Math.ceil((end - mapping) * 90000);\n  var updatedBuffer = buffer.slice();\n\n  var i = buffer.length;\n\n  while (i--) {\n    if (buffer[i].pts <= endPts) {\n      break;\n    }\n  }\n\n  if (i === -1) {\n    // no removal because end of remove range is before start of buffer\n    return updatedBuffer;\n  }\n\n  var j = i + 1;\n\n  while (j--) {\n    if (buffer[j].pts <= startPts) {\n      break;\n    }\n  }\n\n  // clamp remove range start to 0 index\n  j = Math.max(j, 0);\n\n  updatedBuffer.splice(j, i - j + 1);\n\n  return updatedBuffer;\n};\n\n/**\n * VirtualSourceBuffers exist so that we can transmux non native formats\n * into a native format, but keep the same api as a native source buffer.\n * It creates a transmuxer, that works in its own thread (a web worker) and\n * that transmuxer muxes the data into a native format. VirtualSourceBuffer will\n * then send all of that data to the naive sourcebuffer so that it is\n * indestinguishable from a natively supported format.\n *\n * @param {HtmlMediaSource} mediaSource the parent mediaSource\n * @param {Array} codecs array of codecs that we will be dealing with\n * @class VirtualSourceBuffer\n * @extends video.js.EventTarget\n */\n\nvar VirtualSourceBuffer = function (_videojs$EventTarget) {\n  inherits$1(VirtualSourceBuffer, _videojs$EventTarget);\n\n  function VirtualSourceBuffer(mediaSource, codecs) {\n    classCallCheck$1(this, VirtualSourceBuffer);\n\n    var _this = possibleConstructorReturn$1(this, (VirtualSourceBuffer.__proto__ || Object.getPrototypeOf(VirtualSourceBuffer)).call(this, videojs$1.EventTarget));\n\n    _this.timestampOffset_ = 0;\n    _this.pendingBuffers_ = [];\n    _this.bufferUpdating_ = false;\n\n    _this.mediaSource_ = mediaSource;\n    _this.codecs_ = codecs;\n    _this.audioCodec_ = null;\n    _this.videoCodec_ = null;\n    _this.audioDisabled_ = false;\n    _this.appendAudioInitSegment_ = true;\n    _this.gopBuffer_ = [];\n    _this.timeMapping_ = 0;\n    _this.safeAppend_ = videojs$1.browser.IE_VERSION >= 11;\n\n    var options = {\n      remux: false,\n      alignGopsAtEnd: _this.safeAppend_\n    };\n\n    _this.codecs_.forEach(function (codec) {\n      if (isAudioCodec(codec)) {\n        _this.audioCodec_ = codec;\n      } else if (isVideoCodec(codec)) {\n        _this.videoCodec_ = codec;\n      }\n    });\n\n    // append muxed segments to their respective native buffers as\n    // soon as they are available\n    _this.transmuxer_ = new TransmuxWorker();\n    _this.transmuxer_.postMessage({ action: 'init', options: options });\n\n    _this.transmuxer_.onmessage = function (event) {\n      if (event.data.action === 'data') {\n        return _this.data_(event);\n      }\n\n      if (event.data.action === 'done') {\n        return _this.done_(event);\n      }\n\n      if (event.data.action === 'gopInfo') {\n        return _this.appendGopInfo_(event);\n      }\n    };\n\n    // this timestampOffset is a property with the side-effect of resetting\n    // baseMediaDecodeTime in the transmuxer on the setter\n    Object.defineProperty(_this, 'timestampOffset', {\n      get: function get$$1() {\n        return this.timestampOffset_;\n      },\n      set: function set$$1(val) {\n        if (typeof val === 'number' && val >= 0) {\n          this.timestampOffset_ = val;\n          this.appendAudioInitSegment_ = true;\n\n          // reset gop buffer on timestampoffset as this signals a change in timeline\n          this.gopBuffer_.length = 0;\n          this.timeMapping_ = 0;\n\n          // We have to tell the transmuxer to set the baseMediaDecodeTime to\n          // the desired timestampOffset for the next segment\n          this.transmuxer_.postMessage({\n            action: 'setTimestampOffset',\n            timestampOffset: val\n          });\n        }\n      }\n    });\n\n    // setting the append window affects both source buffers\n    Object.defineProperty(_this, 'appendWindowStart', {\n      get: function get$$1() {\n        return (this.videoBuffer_ || this.audioBuffer_).appendWindowStart;\n      },\n      set: function set$$1(start) {\n        if (this.videoBuffer_) {\n          this.videoBuffer_.appendWindowStart = start;\n        }\n        if (this.audioBuffer_) {\n          this.audioBuffer_.appendWindowStart = start;\n        }\n      }\n    });\n\n    // this buffer is \"updating\" if either of its native buffers are\n    Object.defineProperty(_this, 'updating', {\n      get: function get$$1() {\n        return !!(this.bufferUpdating_ || !this.audioDisabled_ && this.audioBuffer_ && this.audioBuffer_.updating || this.videoBuffer_ && this.videoBuffer_.updating);\n      }\n    });\n\n    // the buffered property is the intersection of the buffered\n    // ranges of the native source buffers\n    Object.defineProperty(_this, 'buffered', {\n      get: function get$$1() {\n        var start = null;\n        var end = null;\n        var arity = 0;\n        var extents = [];\n        var ranges = [];\n\n        // neither buffer has been created yet\n        if (!this.videoBuffer_ && !this.audioBuffer_) {\n          return videojs$1.createTimeRange();\n        }\n\n        // only one buffer is configured\n        if (!this.videoBuffer_) {\n          return this.audioBuffer_.buffered;\n        }\n        if (!this.audioBuffer_) {\n          return this.videoBuffer_.buffered;\n        }\n\n        // both buffers are configured\n        if (this.audioDisabled_) {\n          return this.videoBuffer_.buffered;\n        }\n\n        // both buffers are empty\n        if (this.videoBuffer_.buffered.length === 0 && this.audioBuffer_.buffered.length === 0) {\n          return videojs$1.createTimeRange();\n        }\n\n        // Handle the case where we have both buffers and create an\n        // intersection of the two\n        var videoBuffered = this.videoBuffer_.buffered;\n        var audioBuffered = this.audioBuffer_.buffered;\n        var count = videoBuffered.length;\n\n        // A) Gather up all start and end times\n        while (count--) {\n          extents.push({ time: videoBuffered.start(count), type: 'start' });\n          extents.push({ time: videoBuffered.end(count), type: 'end' });\n        }\n        count = audioBuffered.length;\n        while (count--) {\n          extents.push({ time: audioBuffered.start(count), type: 'start' });\n          extents.push({ time: audioBuffered.end(count), type: 'end' });\n        }\n        // B) Sort them by time\n        extents.sort(function (a, b) {\n          return a.time - b.time;\n        });\n\n        // C) Go along one by one incrementing arity for start and decrementing\n        //    arity for ends\n        for (count = 0; count < extents.length; count++) {\n          if (extents[count].type === 'start') {\n            arity++;\n\n            // D) If arity is ever incremented to 2 we are entering an\n            //    overlapping range\n            if (arity === 2) {\n              start = extents[count].time;\n            }\n          } else if (extents[count].type === 'end') {\n            arity--;\n\n            // E) If arity is ever decremented to 1 we leaving an\n            //    overlapping range\n            if (arity === 1) {\n              end = extents[count].time;\n            }\n          }\n\n          // F) Record overlapping ranges\n          if (start !== null && end !== null) {\n            ranges.push([start, end]);\n            start = null;\n            end = null;\n          }\n        }\n\n        return videojs$1.createTimeRanges(ranges);\n      }\n    });\n    return _this;\n  }\n\n  /**\n   * When we get a data event from the transmuxer\n   * we call this function and handle the data that\n   * was sent to us\n   *\n   * @private\n   * @param {Event} event the data event from the transmuxer\n   */\n\n  createClass$1(VirtualSourceBuffer, [{\n    key: 'data_',\n    value: function data_(event) {\n      var segment = event.data.segment;\n\n      // Cast ArrayBuffer to TypedArray\n      segment.data = new Uint8Array(segment.data, event.data.byteOffset, event.data.byteLength);\n\n      segment.initSegment = new Uint8Array(segment.initSegment.data, segment.initSegment.byteOffset, segment.initSegment.byteLength);\n\n      createTextTracksIfNecessary(this, this.mediaSource_, segment);\n\n      // Add the segments to the pendingBuffers array\n      this.pendingBuffers_.push(segment);\n      return;\n    }\n\n    /**\n     * When we get a done event from the transmuxer\n     * we call this function and we process all\n     * of the pending data that we have been saving in the\n     * data_ function\n     *\n     * @private\n     * @param {Event} event the done event from the transmuxer\n     */\n\n  }, {\n    key: 'done_',\n    value: function done_(event) {\n      // Don't process and append data if the mediaSource is closed\n      if (this.mediaSource_.readyState === 'closed') {\n        this.pendingBuffers_.length = 0;\n        return;\n      }\n\n      // All buffers should have been flushed from the muxer\n      // start processing anything we have received\n      this.processPendingSegments_();\n      return;\n    }\n\n    /**\n     * Create our internal native audio/video source buffers and add\n     * event handlers to them with the following conditions:\n     * 1. they do not already exist on the mediaSource\n     * 2. this VSB has a codec for them\n     *\n     * @private\n     */\n\n  }, {\n    key: 'createRealSourceBuffers_',\n    value: function createRealSourceBuffers_() {\n      var _this2 = this;\n\n      var types = ['audio', 'video'];\n\n      types.forEach(function (type) {\n        // Don't create a SourceBuffer of this type if we don't have a\n        // codec for it\n        if (!_this2[type + 'Codec_']) {\n          return;\n        }\n\n        // Do nothing if a SourceBuffer of this type already exists\n        if (_this2[type + 'Buffer_']) {\n          return;\n        }\n\n        var buffer = null;\n\n        // If the mediasource already has a SourceBuffer for the codec\n        // use that\n        if (_this2.mediaSource_[type + 'Buffer_']) {\n          buffer = _this2.mediaSource_[type + 'Buffer_'];\n          // In multiple audio track cases, the audio source buffer is disabled\n          // on the main VirtualSourceBuffer by the HTMLMediaSource much earlier\n          // than createRealSourceBuffers_ is called to create the second\n          // VirtualSourceBuffer because that happens as a side-effect of\n          // videojs-contrib-hls starting the audioSegmentLoader. As a result,\n          // the audioBuffer is essentially \"ownerless\" and no one will toggle\n          // the `updating` state back to false once the `updateend` event is received\n          //\n          // Setting `updating` to false manually will work around this\n          // situation and allow work to continue\n          buffer.updating = false;\n        } else {\n          var codecProperty = type + 'Codec_';\n          var mimeType = type + '/mp4;codecs=\"' + _this2[codecProperty] + '\"';\n\n          buffer = makeWrappedSourceBuffer(_this2.mediaSource_.nativeMediaSource_, mimeType);\n\n          _this2.mediaSource_[type + 'Buffer_'] = buffer;\n        }\n\n        _this2[type + 'Buffer_'] = buffer;\n\n        // Wire up the events to the SourceBuffer\n        ['update', 'updatestart', 'updateend'].forEach(function (event) {\n          buffer.addEventListener(event, function () {\n            // if audio is disabled\n            if (type === 'audio' && _this2.audioDisabled_) {\n              return;\n            }\n\n            if (event === 'updateend') {\n              _this2[type + 'Buffer_'].updating = false;\n            }\n\n            var shouldTrigger = types.every(function (t) {\n              // skip checking audio's updating status if audio\n              // is not enabled\n              if (t === 'audio' && _this2.audioDisabled_) {\n                return true;\n              }\n              // if the other type if updating we don't trigger\n              if (type !== t && _this2[t + 'Buffer_'] && _this2[t + 'Buffer_'].updating) {\n                return false;\n              }\n              return true;\n            });\n\n            if (shouldTrigger) {\n              return _this2.trigger(event);\n            }\n          });\n        });\n      });\n    }\n\n    /**\n     * Emulate the native mediasource function, but our function will\n     * send all of the proposed segments to the transmuxer so that we\n     * can transmux them before we append them to our internal\n     * native source buffers in the correct format.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/appendBuffer\n     * @param {Uint8Array} segment the segment to append to the buffer\n     */\n\n  }, {\n    key: 'appendBuffer',\n    value: function appendBuffer(segment) {\n      // Start the internal \"updating\" state\n      this.bufferUpdating_ = true;\n\n      if (this.audioBuffer_ && this.audioBuffer_.buffered.length) {\n        var audioBuffered = this.audioBuffer_.buffered;\n\n        this.transmuxer_.postMessage({\n          action: 'setAudioAppendStart',\n          appendStart: audioBuffered.end(audioBuffered.length - 1)\n        });\n      }\n\n      if (this.videoBuffer_) {\n        this.transmuxer_.postMessage({\n          action: 'alignGopsWith',\n          gopsToAlignWith: gopsSafeToAlignWith(this.gopBuffer_, this.mediaSource_.player_, this.timeMapping_)\n        });\n      }\n\n      this.transmuxer_.postMessage({\n        action: 'push',\n        // Send the typed-array of data as an ArrayBuffer so that\n        // it can be sent as a \"Transferable\" and avoid the costly\n        // memory copy\n        data: segment.buffer,\n\n        // To recreate the original typed-array, we need information\n        // about what portion of the ArrayBuffer it was a view into\n        byteOffset: segment.byteOffset,\n        byteLength: segment.byteLength\n      }, [segment.buffer]);\n      this.transmuxer_.postMessage({ action: 'flush' });\n    }\n\n    /**\n     * Appends gop information (timing and byteLength) received by the transmuxer for the\n     * gops appended in the last call to appendBuffer\n     *\n     * @param {Event} event\n     *        The gopInfo event from the transmuxer\n     * @param {Array} event.data.gopInfo\n     *        List of gop info to append\n     */\n\n  }, {\n    key: 'appendGopInfo_',\n    value: function appendGopInfo_(event) {\n      this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, event.data.gopInfo, this.safeAppend_);\n    }\n\n    /**\n     * Emulate the native mediasource function and remove parts\n     * of the buffer from any of our internal buffers that exist\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/remove\n     * @param {Double} start position to start the remove at\n     * @param {Double} end position to end the remove at\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      if (this.videoBuffer_) {\n        this.videoBuffer_.updating = true;\n        this.videoBuffer_.remove(start, end);\n        this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_);\n      }\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.audioBuffer_.updating = true;\n        this.audioBuffer_.remove(start, end);\n      }\n\n      // Remove Metadata Cues (id3)\n      removeCuesFromTrack(start, end, this.metadataTrack_);\n\n      // Remove Any Captions\n      if (this.inbandTextTracks_) {\n        for (var track in this.inbandTextTracks_) {\n          removeCuesFromTrack(start, end, this.inbandTextTracks_[track]);\n        }\n      }\n    }\n\n    /**\n     * Process any segments that the muxer has output\n     * Concatenate segments together based on type and append them into\n     * their respective sourceBuffers\n     *\n     * @private\n     */\n\n  }, {\n    key: 'processPendingSegments_',\n    value: function processPendingSegments_() {\n      var sortedSegments = {\n        video: {\n          segments: [],\n          bytes: 0\n        },\n        audio: {\n          segments: [],\n          bytes: 0\n        },\n        captions: [],\n        metadata: []\n      };\n\n      // Sort segments into separate video/audio arrays and\n      // keep track of their total byte lengths\n      sortedSegments = this.pendingBuffers_.reduce(function (segmentObj, segment) {\n        var type = segment.type;\n        var data = segment.data;\n        var initSegment = segment.initSegment;\n\n        segmentObj[type].segments.push(data);\n        segmentObj[type].bytes += data.byteLength;\n\n        segmentObj[type].initSegment = initSegment;\n\n        // Gather any captions into a single array\n        if (segment.captions) {\n          segmentObj.captions = segmentObj.captions.concat(segment.captions);\n        }\n\n        if (segment.info) {\n          segmentObj[type].info = segment.info;\n        }\n\n        // Gather any metadata into a single array\n        if (segment.metadata) {\n          segmentObj.metadata = segmentObj.metadata.concat(segment.metadata);\n        }\n\n        return segmentObj;\n      }, sortedSegments);\n\n      // Create the real source buffers if they don't exist by now since we\n      // finally are sure what tracks are contained in the source\n      if (!this.videoBuffer_ && !this.audioBuffer_) {\n        // Remove any codecs that may have been specified by default but\n        // are no longer applicable now\n        if (sortedSegments.video.bytes === 0) {\n          this.videoCodec_ = null;\n        }\n        if (sortedSegments.audio.bytes === 0) {\n          this.audioCodec_ = null;\n        }\n\n        this.createRealSourceBuffers_();\n      }\n\n      if (sortedSegments.audio.info) {\n        this.mediaSource_.trigger({ type: 'audioinfo', info: sortedSegments.audio.info });\n      }\n      if (sortedSegments.video.info) {\n        this.mediaSource_.trigger({ type: 'videoinfo', info: sortedSegments.video.info });\n      }\n\n      if (this.appendAudioInitSegment_) {\n        if (!this.audioDisabled_ && this.audioBuffer_) {\n          sortedSegments.audio.segments.unshift(sortedSegments.audio.initSegment);\n          sortedSegments.audio.bytes += sortedSegments.audio.initSegment.byteLength;\n        }\n        this.appendAudioInitSegment_ = false;\n      }\n\n      var triggerUpdateend = false;\n\n      // Merge multiple video and audio segments into one and append\n      if (this.videoBuffer_ && sortedSegments.video.bytes) {\n        sortedSegments.video.segments.unshift(sortedSegments.video.initSegment);\n        sortedSegments.video.bytes += sortedSegments.video.initSegment.byteLength;\n        this.concatAndAppendSegments_(sortedSegments.video, this.videoBuffer_);\n        // TODO: are video tracks the only ones with text tracks?\n        addTextTrackData(this, sortedSegments.captions, sortedSegments.metadata);\n      } else if (this.videoBuffer_ && (this.audioDisabled_ || !this.audioBuffer_)) {\n        // The transmuxer did not return any bytes of video, meaning it was all trimmed\n        // for gop alignment. Since we have a video buffer and audio is disabled, updateend\n        // will never be triggered by this source buffer, which will cause contrib-hls\n        // to be stuck forever waiting for updateend. If audio is not disabled, updateend\n        // will be triggered by the audio buffer, which will be sent upwards since the video\n        // buffer will not be in an updating state.\n        triggerUpdateend = true;\n      }\n\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.concatAndAppendSegments_(sortedSegments.audio, this.audioBuffer_);\n      }\n\n      this.pendingBuffers_.length = 0;\n\n      if (triggerUpdateend) {\n        this.trigger('updateend');\n      }\n\n      // We are no longer in the internal \"updating\" state\n      this.bufferUpdating_ = false;\n    }\n\n    /**\n     * Combine all segments into a single Uint8Array and then append them\n     * to the destination buffer\n     *\n     * @param {Object} segmentObj\n     * @param {SourceBuffer} destinationBuffer native source buffer to append data to\n     * @private\n     */\n\n  }, {\n    key: 'concatAndAppendSegments_',\n    value: function concatAndAppendSegments_(segmentObj, destinationBuffer) {\n      var offset = 0;\n      var tempBuffer = void 0;\n\n      if (segmentObj.bytes) {\n        tempBuffer = new Uint8Array(segmentObj.bytes);\n\n        // Combine the individual segments into one large typed-array\n        segmentObj.segments.forEach(function (segment) {\n          tempBuffer.set(segment, offset);\n          offset += segment.byteLength;\n        });\n\n        try {\n          destinationBuffer.updating = true;\n          destinationBuffer.appendBuffer(tempBuffer);\n        } catch (error) {\n          if (this.mediaSource_.player_) {\n            this.mediaSource_.player_.error({\n              code: -3,\n              type: 'APPEND_BUFFER_ERR',\n              message: error.message,\n              originalError: error\n            });\n          }\n        }\n      }\n    }\n\n    /**\n     * Emulate the native mediasource function. abort any soureBuffer\n     * actions and throw out any un-appended data.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/abort\n     */\n\n  }, {\n    key: 'abort',\n    value: function abort() {\n      if (this.videoBuffer_) {\n        this.videoBuffer_.abort();\n      }\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.audioBuffer_.abort();\n      }\n      if (this.transmuxer_) {\n        this.transmuxer_.postMessage({ action: 'reset' });\n      }\n      this.pendingBuffers_.length = 0;\n      this.bufferUpdating_ = false;\n    }\n  }]);\n  return VirtualSourceBuffer;\n}(videojs$1.EventTarget);\n\n/**\n * @file html-media-source.js\n */\n\n/**\n * Our MediaSource implementation in HTML, mimics native\n * MediaSource where/if possible.\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\n * @class HtmlMediaSource\n * @extends videojs.EventTarget\n */\n\nvar HtmlMediaSource = function (_videojs$EventTarget) {\n  inherits$1(HtmlMediaSource, _videojs$EventTarget);\n\n  function HtmlMediaSource() {\n    classCallCheck$1(this, HtmlMediaSource);\n\n    var _this = possibleConstructorReturn$1(this, (HtmlMediaSource.__proto__ || Object.getPrototypeOf(HtmlMediaSource)).call(this));\n\n    var property = void 0;\n\n    _this.nativeMediaSource_ = new global_window__WEBPACK_IMPORTED_MODULE_0___default.a.MediaSource();\n    // delegate to the native MediaSource's methods by default\n    for (property in _this.nativeMediaSource_) {\n      if (!(property in HtmlMediaSource.prototype) && typeof _this.nativeMediaSource_[property] === 'function') {\n        _this[property] = _this.nativeMediaSource_[property].bind(_this.nativeMediaSource_);\n      }\n    }\n\n    // emulate `duration` and `seekable` until seeking can be\n    // handled uniformly for live streams\n    // see https://github.com/w3c/media-source/issues/5\n    _this.duration_ = NaN;\n    Object.defineProperty(_this, 'duration', {\n      get: function get$$1() {\n        if (this.duration_ === Infinity) {\n          return this.duration_;\n        }\n        return this.nativeMediaSource_.duration;\n      },\n      set: function set$$1(duration) {\n        this.duration_ = duration;\n        if (duration !== Infinity) {\n          this.nativeMediaSource_.duration = duration;\n          return;\n        }\n      }\n    });\n    Object.defineProperty(_this, 'seekable', {\n      get: function get$$1() {\n        if (this.duration_ === Infinity) {\n          return videojs$1.createTimeRanges([[0, this.nativeMediaSource_.duration]]);\n        }\n        return this.nativeMediaSource_.seekable;\n      }\n    });\n\n    Object.defineProperty(_this, 'readyState', {\n      get: function get$$1() {\n        return this.nativeMediaSource_.readyState;\n      }\n    });\n\n    Object.defineProperty(_this, 'activeSourceBuffers', {\n      get: function get$$1() {\n        return this.activeSourceBuffers_;\n      }\n    });\n\n    // the list of virtual and native SourceBuffers created by this\n    // MediaSource\n    _this.sourceBuffers = [];\n\n    _this.activeSourceBuffers_ = [];\n\n    /**\n     * update the list of active source buffers based upon various\n     * imformation from HLS and video.js\n     *\n     * @private\n     */\n    _this.updateActiveSourceBuffers_ = function () {\n      // Retain the reference but empty the array\n      _this.activeSourceBuffers_.length = 0;\n\n      // If there is only one source buffer, then it will always be active and audio will\n      // be disabled based on the codec of the source buffer\n      if (_this.sourceBuffers.length === 1) {\n        var sourceBuffer = _this.sourceBuffers[0];\n\n        sourceBuffer.appendAudioInitSegment_ = true;\n        sourceBuffer.audioDisabled_ = !sourceBuffer.audioCodec_;\n        _this.activeSourceBuffers_.push(sourceBuffer);\n        return;\n      }\n\n      // There are 2 source buffers, a combined (possibly video only) source buffer and\n      // and an audio only source buffer.\n      // By default, the audio in the combined virtual source buffer is enabled\n      // and the audio-only source buffer (if it exists) is disabled.\n      var disableCombined = false;\n      var disableAudioOnly = true;\n\n      // TODO: maybe we can store the sourcebuffers on the track objects?\n      // safari may do something like this\n      for (var i = 0; i < _this.player_.audioTracks().length; i++) {\n        var track = _this.player_.audioTracks()[i];\n\n        if (track.enabled && track.kind !== 'main') {\n          // The enabled track is an alternate audio track so disable the audio in\n          // the combined source buffer and enable the audio-only source buffer.\n          disableCombined = true;\n          disableAudioOnly = false;\n          break;\n        }\n      }\n\n      _this.sourceBuffers.forEach(function (sourceBuffer, index) {\n        /* eslinst-disable */\n        // TODO once codecs are required, we can switch to using the codecs to determine\n        //      what stream is the video stream, rather than relying on videoTracks\n        /* eslinst-enable */\n\n        sourceBuffer.appendAudioInitSegment_ = true;\n\n        if (sourceBuffer.videoCodec_ && sourceBuffer.audioCodec_) {\n          // combined\n          sourceBuffer.audioDisabled_ = disableCombined;\n        } else if (sourceBuffer.videoCodec_ && !sourceBuffer.audioCodec_) {\n          // If the \"combined\" source buffer is video only, then we do not want\n          // disable the audio-only source buffer (this is mostly for demuxed\n          // audio and video hls)\n          sourceBuffer.audioDisabled_ = true;\n          disableAudioOnly = false;\n        } else if (!sourceBuffer.videoCodec_ && sourceBuffer.audioCodec_) {\n          // audio only\n          // In the case of audio only with alternate audio and disableAudioOnly is true\n          // this means we want to disable the audio on the alternate audio sourcebuffer\n          // but not the main \"combined\" source buffer. The \"combined\" source buffer is\n          // always at index 0, so this ensures audio won't be disabled in both source\n          // buffers.\n          sourceBuffer.audioDisabled_ = index ? disableAudioOnly : !disableAudioOnly;\n          if (sourceBuffer.audioDisabled_) {\n            return;\n          }\n        }\n\n        _this.activeSourceBuffers_.push(sourceBuffer);\n      });\n    };\n\n    _this.onPlayerMediachange_ = function () {\n      _this.sourceBuffers.forEach(function (sourceBuffer) {\n        sourceBuffer.appendAudioInitSegment_ = true;\n      });\n    };\n\n    _this.onHlsReset_ = function () {\n      _this.sourceBuffers.forEach(function (sourceBuffer) {\n        if (sourceBuffer.transmuxer_) {\n          sourceBuffer.transmuxer_.postMessage({ action: 'resetCaptions' });\n        }\n      });\n    };\n\n    _this.onHlsSegmentTimeMapping_ = function (event) {\n      _this.sourceBuffers.forEach(function (buffer) {\n        return buffer.timeMapping_ = event.mapping;\n      });\n    };\n\n    // Re-emit MediaSource events on the polyfill\n    ['sourceopen', 'sourceclose', 'sourceended'].forEach(function (eventName) {\n      this.nativeMediaSource_.addEventListener(eventName, this.trigger.bind(this));\n    }, _this);\n\n    // capture the associated player when the MediaSource is\n    // successfully attached\n    _this.on('sourceopen', function (event) {\n      // Get the player this MediaSource is attached to\n      var video = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.querySelector('[src=\"' + _this.url_ + '\"]');\n\n      if (!video) {\n        return;\n      }\n\n      _this.player_ = videojs$1(video.parentNode);\n\n      // hls-reset is fired by videojs.Hls on to the tech after the main SegmentLoader\n      // resets its state and flushes the buffer\n      _this.player_.tech_.on('hls-reset', _this.onHlsReset_);\n      // hls-segment-time-mapping is fired by videojs.Hls on to the tech after the main\n      // SegmentLoader inspects an MTS segment and has an accurate stream to display\n      // time mapping\n      _this.player_.tech_.on('hls-segment-time-mapping', _this.onHlsSegmentTimeMapping_);\n\n      if (_this.player_.audioTracks && _this.player_.audioTracks()) {\n        _this.player_.audioTracks().on('change', _this.updateActiveSourceBuffers_);\n        _this.player_.audioTracks().on('addtrack', _this.updateActiveSourceBuffers_);\n        _this.player_.audioTracks().on('removetrack', _this.updateActiveSourceBuffers_);\n      }\n\n      _this.player_.on('mediachange', _this.onPlayerMediachange_);\n    });\n\n    _this.on('sourceended', function (event) {\n      var duration = durationOfVideo(_this.duration);\n\n      for (var i = 0; i < _this.sourceBuffers.length; i++) {\n        var sourcebuffer = _this.sourceBuffers[i];\n        var cues = sourcebuffer.metadataTrack_ && sourcebuffer.metadataTrack_.cues;\n\n        if (cues && cues.length) {\n          cues[cues.length - 1].endTime = duration;\n        }\n      }\n    });\n\n    // explicitly terminate any WebWorkers that were created\n    // by SourceHandlers\n    _this.on('sourceclose', function (event) {\n      this.sourceBuffers.forEach(function (sourceBuffer) {\n        if (sourceBuffer.transmuxer_) {\n          sourceBuffer.transmuxer_.terminate();\n        }\n      });\n\n      this.sourceBuffers.length = 0;\n      if (!this.player_) {\n        return;\n      }\n\n      if (this.player_.audioTracks && this.player_.audioTracks()) {\n        this.player_.audioTracks().off('change', this.updateActiveSourceBuffers_);\n        this.player_.audioTracks().off('addtrack', this.updateActiveSourceBuffers_);\n        this.player_.audioTracks().off('removetrack', this.updateActiveSourceBuffers_);\n      }\n\n      // We can only change this if the player hasn't been disposed of yet\n      // because `off` eventually tries to use the el_ property. If it has\n      // been disposed of, then don't worry about it because there are no\n      // event handlers left to unbind anyway\n      if (this.player_.el_) {\n        this.player_.off('mediachange', this.onPlayerMediachange_);\n        this.player_.tech_.off('hls-reset', this.onHlsReset_);\n        this.player_.tech_.off('hls-segment-time-mapping', this.onHlsSegmentTimeMapping_);\n      }\n    });\n    return _this;\n  }\n\n  /**\n   * Add a range that that can now be seeked to.\n   *\n   * @param {Double} start where to start the addition\n   * @param {Double} end where to end the addition\n   * @private\n   */\n\n  createClass$1(HtmlMediaSource, [{\n    key: 'addSeekableRange_',\n    value: function addSeekableRange_(start, end) {\n      var error = void 0;\n\n      if (this.duration !== Infinity) {\n        error = new Error('MediaSource.addSeekableRange() can only be invoked ' + 'when the duration is Infinity');\n        error.name = 'InvalidStateError';\n        error.code = 11;\n        throw error;\n      }\n\n      if (end > this.nativeMediaSource_.duration || isNaN(this.nativeMediaSource_.duration)) {\n        this.nativeMediaSource_.duration = end;\n      }\n    }\n\n    /**\n     * Add a source buffer to the media source.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/addSourceBuffer\n     * @param {String} type the content-type of the content\n     * @return {Object} the created source buffer\n     */\n\n  }, {\n    key: 'addSourceBuffer',\n    value: function addSourceBuffer(type) {\n      var buffer = void 0;\n      var parsedType = parseContentType(type);\n\n      // Create a VirtualSourceBuffer to transmux MPEG-2 transport\n      // stream segments into fragmented MP4s\n      if (/^(video|audio)\\/mp2t$/i.test(parsedType.type)) {\n        var codecs = [];\n\n        if (parsedType.parameters && parsedType.parameters.codecs) {\n          codecs = parsedType.parameters.codecs.split(',');\n          codecs = translateLegacyCodecs(codecs);\n          codecs = codecs.filter(function (codec) {\n            return isAudioCodec(codec) || isVideoCodec(codec);\n          });\n        }\n\n        if (codecs.length === 0) {\n          codecs = ['avc1.4d400d', 'mp4a.40.2'];\n        }\n\n        buffer = new VirtualSourceBuffer(this, codecs);\n\n        if (this.sourceBuffers.length !== 0) {\n          // If another VirtualSourceBuffer already exists, then we are creating a\n          // SourceBuffer for an alternate audio track and therefore we know that\n          // the source has both an audio and video track.\n          // That means we should trigger the manual creation of the real\n          // SourceBuffers instead of waiting for the transmuxer to return data\n          this.sourceBuffers[0].createRealSourceBuffers_();\n          buffer.createRealSourceBuffers_();\n\n          // Automatically disable the audio on the first source buffer if\n          // a second source buffer is ever created\n          this.sourceBuffers[0].audioDisabled_ = true;\n        }\n      } else {\n        // delegate to the native implementation\n        buffer = this.nativeMediaSource_.addSourceBuffer(type);\n      }\n\n      this.sourceBuffers.push(buffer);\n      return buffer;\n    }\n  }]);\n  return HtmlMediaSource;\n}(videojs$1.EventTarget);\n\n/**\n * @file videojs-contrib-media-sources.js\n */\nvar urlCount = 0;\n\n// ------------\n// Media Source\n// ------------\n\n// store references to the media sources so they can be connected\n// to a video element (a swf object)\n// TODO: can we store this somewhere local to this module?\nvideojs$1.mediaSources = {};\n\n/**\n * Provide a method for a swf object to notify JS that a\n * media source is now open.\n *\n * @param {String} msObjectURL string referencing the MSE Object URL\n * @param {String} swfId the swf id\n */\nvar open = function open(msObjectURL, swfId) {\n  var mediaSource = videojs$1.mediaSources[msObjectURL];\n\n  if (mediaSource) {\n    mediaSource.trigger({ type: 'sourceopen', swfId: swfId });\n  } else {\n    throw new Error('Media Source not found (Video.js)');\n  }\n};\n\n/**\n * Check to see if the native MediaSource object exists and supports\n * an MP4 container with both H.264 video and AAC-LC audio.\n *\n * @return {Boolean} if  native media sources are supported\n */\nvar supportsNativeMediaSources = function supportsNativeMediaSources() {\n  return !!global_window__WEBPACK_IMPORTED_MODULE_0___default.a.MediaSource && !!global_window__WEBPACK_IMPORTED_MODULE_0___default.a.MediaSource.isTypeSupported && global_window__WEBPACK_IMPORTED_MODULE_0___default.a.MediaSource.isTypeSupported('video/mp4;codecs=\"avc1.4d400d,mp4a.40.2\"');\n};\n\n/**\n * An emulation of the MediaSource API so that we can support\n * native and non-native functionality. returns an instance of\n * HtmlMediaSource.\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/MediaSource\n */\nvar MediaSource = function MediaSource() {\n  this.MediaSource = {\n    open: open,\n    supportsNativeMediaSources: supportsNativeMediaSources\n  };\n\n  if (supportsNativeMediaSources()) {\n    return new HtmlMediaSource();\n  }\n\n  throw new Error('Cannot use create a virtual MediaSource for this video');\n};\n\nMediaSource.open = open;\nMediaSource.supportsNativeMediaSources = supportsNativeMediaSources;\n\n/**\n * A wrapper around the native URL for our MSE object\n * implementation, this object is exposed under videojs.URL\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/URL/URL\n */\nvar URL$1 = {\n  /**\n   * A wrapper around the native createObjectURL for our objects.\n   * This function maps a native or emulated mediaSource to a blob\n   * url so that it can be loaded into video.js\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\n   * @param {MediaSource} object the object to create a blob url to\n   */\n  createObjectURL: function createObjectURL(object) {\n    var objectUrlPrefix = 'blob:vjs-media-source/';\n    var url = void 0;\n\n    // use the native MediaSource to generate an object URL\n    if (object instanceof HtmlMediaSource) {\n      url = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.URL.createObjectURL(object.nativeMediaSource_);\n      object.url_ = url;\n      return url;\n    }\n    // if the object isn't an emulated MediaSource, delegate to the\n    // native implementation\n    if (!(object instanceof HtmlMediaSource)) {\n      url = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.URL.createObjectURL(object);\n      object.url_ = url;\n      return url;\n    }\n\n    // build a URL that can be used to map back to the emulated\n    // MediaSource\n    url = objectUrlPrefix + urlCount;\n\n    urlCount++;\n\n    // setup the mapping back to object\n    videojs$1.mediaSources[url] = object;\n\n    return url;\n  }\n};\n\nvideojs$1.MediaSource = MediaSource;\nvideojs$1.URL = URL$1;\n\nvar EventTarget$1$1 = videojs$1.EventTarget,\n    mergeOptions$2 = videojs$1.mergeOptions;\n\n/**\n * Returns a new master manifest that is the result of merging an updated master manifest\n * into the original version.\n *\n * @param {Object} oldMaster\n *        The old parsed mpd object\n * @param {Object} newMaster\n *        The updated parsed mpd object\n * @return {Object}\n *         A new object representing the original master manifest with the updated media\n *         playlists merged in\n */\n\nvar updateMaster$1 = function updateMaster$$1(oldMaster, newMaster) {\n  var update = mergeOptions$2(oldMaster, {\n    // These are top level properties that can be updated\n    duration: newMaster.duration,\n    minimumUpdatePeriod: newMaster.minimumUpdatePeriod\n  });\n\n  // First update the playlists in playlist list\n  for (var i = 0; i < newMaster.playlists.length; i++) {\n    var playlistUpdate = updateMaster(update, newMaster.playlists[i]);\n\n    if (playlistUpdate) {\n      update = playlistUpdate;\n    }\n  }\n\n  // Then update media group playlists\n  forEachMediaGroup(newMaster, function (properties, type, group, label) {\n    if (properties.playlists && properties.playlists.length) {\n      var uri = properties.playlists[0].uri;\n      var _playlistUpdate = updateMaster(update, properties.playlists[0]);\n\n      if (_playlistUpdate) {\n        update = _playlistUpdate;\n        // update the playlist reference within media groups\n        update.mediaGroups[type][group][label].playlists[0] = update.playlists[uri];\n      }\n    }\n  });\n\n  return update;\n};\n\nvar DashPlaylistLoader = function (_EventTarget) {\n  inherits$1(DashPlaylistLoader, _EventTarget);\n\n  // DashPlaylistLoader must accept either a src url or a playlist because subsequent\n  // playlist loader setups from media groups will expect to be able to pass a playlist\n  // (since there aren't external URLs to media playlists with DASH)\n  function DashPlaylistLoader(srcUrlOrPlaylist, hls, withCredentials, masterPlaylistLoader) {\n    classCallCheck$1(this, DashPlaylistLoader);\n\n    var _this = possibleConstructorReturn$1(this, (DashPlaylistLoader.__proto__ || Object.getPrototypeOf(DashPlaylistLoader)).call(this));\n\n    _this.hls_ = hls;\n    _this.withCredentials = withCredentials;\n\n    if (!srcUrlOrPlaylist) {\n      throw new Error('A non-empty playlist URL or playlist is required');\n    }\n\n    // event naming?\n    _this.on('minimumUpdatePeriod', function () {\n      _this.refreshXml_();\n    });\n\n    // live playlist staleness timeout\n    _this.on('mediaupdatetimeout', function () {\n      _this.refreshMedia_();\n    });\n\n    // initialize the loader state\n    if (typeof srcUrlOrPlaylist === 'string') {\n      _this.srcUrl = srcUrlOrPlaylist;\n      _this.state = 'HAVE_NOTHING';\n      return possibleConstructorReturn$1(_this);\n    }\n\n    _this.masterPlaylistLoader_ = masterPlaylistLoader;\n\n    _this.state = 'HAVE_METADATA';\n    _this.started = true;\n    // we only should have one playlist so select it\n    _this.media(srcUrlOrPlaylist);\n    // trigger async to mimic behavior of HLS, where it must request a playlist\n    global_window__WEBPACK_IMPORTED_MODULE_0___default.a.setTimeout(function () {\n      _this.trigger('loadedmetadata');\n    }, 0);\n    return _this;\n  }\n\n  createClass$1(DashPlaylistLoader, [{\n    key: 'dispose',\n    value: function dispose() {\n      this.stopRequest();\n      global_window__WEBPACK_IMPORTED_MODULE_0___default.a.clearTimeout(this.mediaUpdateTimeout);\n    }\n  }, {\n    key: 'stopRequest',\n    value: function stopRequest() {\n      if (this.request) {\n        var oldRequest = this.request;\n\n        this.request = null;\n        oldRequest.onreadystatechange = null;\n        oldRequest.abort();\n      }\n    }\n  }, {\n    key: 'media',\n    value: function media(playlist) {\n      // getter\n      if (!playlist) {\n        return this.media_;\n      }\n\n      // setter\n      if (this.state === 'HAVE_NOTHING') {\n        throw new Error('Cannot switch media playlist from ' + this.state);\n      }\n\n      var startingState = this.state;\n\n      // find the playlist object if the target playlist has been specified by URI\n      if (typeof playlist === 'string') {\n        if (!this.master.playlists[playlist]) {\n          throw new Error('Unknown playlist URI: ' + playlist);\n        }\n        playlist = this.master.playlists[playlist];\n      }\n\n      var mediaChange = !this.media_ || playlist.uri !== this.media_.uri;\n\n      this.state = 'HAVE_METADATA';\n\n      // switching to the active playlist is a no-op\n      if (!mediaChange) {\n        return;\n      }\n\n      // switching from an already loaded playlist\n      if (this.media_) {\n        this.trigger('mediachanging');\n      }\n\n      this.media_ = playlist;\n\n      this.refreshMedia_();\n\n      // trigger media change if the active media has been updated\n      if (startingState !== 'HAVE_MASTER') {\n        this.trigger('mediachange');\n      }\n    }\n  }, {\n    key: 'pause',\n    value: function pause() {\n      this.stopRequest();\n      if (this.state === 'HAVE_NOTHING') {\n        // If we pause the loader before any data has been retrieved, its as if we never\n        // started, so reset to an unstarted state.\n        this.started = false;\n      }\n    }\n  }, {\n    key: 'load',\n    value: function load() {\n      // because the playlists are internal to the manifest, load should either load the\n      // main manifest, or do nothing but trigger an event\n      if (!this.started) {\n        this.start();\n        return;\n      }\n\n      this.trigger('loadedplaylist');\n    }\n\n    /**\n     * Parses the master xml string and updates playlist uri references\n     *\n     * @return {Object}\n     *         The parsed mpd manifest object\n     */\n\n  }, {\n    key: 'parseMasterXml',\n    value: function parseMasterXml() {\n      var master = Object(mpd_parser__WEBPACK_IMPORTED_MODULE_8__[\"parse\"])(this.masterXml_, {\n        manifestUri: this.srcUrl,\n        clientOffset: this.clientOffset_\n      });\n\n      master.uri = this.srcUrl;\n\n      // Set up phony URIs for the playlists since we won't have external URIs for DASH\n      // but reference playlists by their URI throughout the project\n      // TODO: Should we create the dummy uris in mpd-parser as well (leaning towards yes).\n      for (var i = 0; i < master.playlists.length; i++) {\n        var phonyUri = 'placeholder-uri-' + i;\n\n        master.playlists[i].uri = phonyUri;\n        // set up by URI references\n        master.playlists[phonyUri] = master.playlists[i];\n      }\n\n      // set up phony URIs for the media group playlists since we won't have external\n      // URIs for DASH but reference playlists by their URI throughout the project\n      forEachMediaGroup(master, function (properties, mediaType, groupKey, labelKey) {\n        if (properties.playlists && properties.playlists.length) {\n          var _phonyUri = 'placeholder-uri-' + mediaType + '-' + groupKey + '-' + labelKey;\n\n          properties.playlists[0].uri = _phonyUri;\n          // setup URI references\n          master.playlists[_phonyUri] = properties.playlists[0];\n        }\n      });\n\n      setupMediaPlaylists(master);\n      resolveMediaGroupUris(master);\n\n      return master;\n    }\n  }, {\n    key: 'start',\n    value: function start() {\n      var _this2 = this;\n\n      this.started = true;\n\n      // request the specified URL\n      this.request = this.hls_.xhr({\n        uri: this.srcUrl,\n        withCredentials: this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this2.request) {\n          return;\n        }\n\n        // clear the loader's request reference\n        _this2.request = null;\n\n        if (error) {\n          _this2.error = {\n            status: req.status,\n            message: 'DASH playlist request error at URL: ' + _this2.srcUrl,\n            responseText: req.responseText,\n            // MEDIA_ERR_NETWORK\n            code: 2\n          };\n          if (_this2.state === 'HAVE_NOTHING') {\n            _this2.started = false;\n          }\n          return _this2.trigger('error');\n        }\n\n        _this2.masterXml_ = req.responseText;\n\n        if (req.responseHeaders && req.responseHeaders.date) {\n          _this2.masterLoaded_ = Date.parse(req.responseHeaders.date);\n        } else {\n          _this2.masterLoaded_ = Date.now();\n        }\n\n        _this2.syncClientServerClock_(_this2.onClientServerClockSync_.bind(_this2));\n      });\n    }\n\n    /**\n     * Parses the master xml for UTCTiming node to sync the client clock to the server\n     * clock. If the UTCTiming node requires a HEAD or GET request, that request is made.\n     *\n     * @param {Function} done\n     *        Function to call when clock sync has completed\n     */\n\n  }, {\n    key: 'syncClientServerClock_',\n    value: function syncClientServerClock_(done) {\n      var _this3 = this;\n\n      var utcTiming = Object(mpd_parser__WEBPACK_IMPORTED_MODULE_8__[\"parseUTCTiming\"])(this.masterXml_);\n\n      // No UTCTiming element found in the mpd. Use Date header from mpd request as the\n      // server clock\n      if (utcTiming === null) {\n        this.clientOffset_ = this.masterLoaded_ - Date.now();\n        return done();\n      }\n\n      if (utcTiming.method === 'DIRECT') {\n        this.clientOffset_ = utcTiming.value - Date.now();\n        return done();\n      }\n\n      this.request = this.hls_.xhr({\n        uri: resolveUrl(this.srcUrl, utcTiming.value),\n        method: utcTiming.method,\n        withCredentials: this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this3.request) {\n          return;\n        }\n\n        if (error) {\n          // sync request failed, fall back to using date header from mpd\n          // TODO: log warning\n          _this3.clientOffset_ = _this3.masterLoaded_ - Date.now();\n          return done();\n        }\n\n        var serverTime = void 0;\n\n        if (utcTiming.method === 'HEAD') {\n          if (!req.responseHeaders || !req.responseHeaders.date) {\n            // expected date header not preset, fall back to using date header from mpd\n            // TODO: log warning\n            serverTime = _this3.masterLoaded_;\n          } else {\n            serverTime = Date.parse(req.responseHeaders.date);\n          }\n        } else {\n          serverTime = Date.parse(req.responseText);\n        }\n\n        _this3.clientOffset_ = serverTime - Date.now();\n\n        done();\n      });\n    }\n\n    /**\n     * Handler for after client/server clock synchronization has happened. Sets up\n     * xml refresh timer if specificed by the manifest.\n     */\n\n  }, {\n    key: 'onClientServerClockSync_',\n    value: function onClientServerClockSync_() {\n      var _this4 = this;\n\n      this.master = this.parseMasterXml();\n\n      this.state = 'HAVE_MASTER';\n\n      this.trigger('loadedplaylist');\n\n      if (!this.media_) {\n        // no media playlist was specifically selected so start\n        // from the first listed one\n        this.media(this.master.playlists[0]);\n      }\n      // trigger loadedmetadata to resolve setup of media groups\n      // trigger async to mimic behavior of HLS, where it must request a playlist\n      global_window__WEBPACK_IMPORTED_MODULE_0___default.a.setTimeout(function () {\n        _this4.trigger('loadedmetadata');\n      }, 0);\n\n      // TODO: minimumUpdatePeriod can have a value of 0. Currently the manifest will not\n      // be refreshed when this is the case. The inter-op guide says that when the\n      // minimumUpdatePeriod is 0, the manifest should outline all currently available\n      // segments, but future segments may require an update. I think a good solution\n      // would be to update the manifest at the same rate that the media playlists\n      // are \"refreshed\", i.e. every targetDuration.\n      if (this.master.minimumUpdatePeriod) {\n        global_window__WEBPACK_IMPORTED_MODULE_0___default.a.setTimeout(function () {\n          _this4.trigger('minimumUpdatePeriod');\n        }, this.master.minimumUpdatePeriod);\n      }\n    }\n\n    /**\n     * Sends request to refresh the master xml and updates the parsed master manifest\n     * TODO: Does the client offset need to be recalculated when the xml is refreshed?\n     */\n\n  }, {\n    key: 'refreshXml_',\n    value: function refreshXml_() {\n      var _this5 = this;\n\n      this.request = this.hls_.xhr({\n        uri: this.srcUrl,\n        withCredentials: this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this5.request) {\n          return;\n        }\n\n        // clear the loader's request reference\n        _this5.request = null;\n\n        if (error) {\n          _this5.error = {\n            status: req.status,\n            message: 'DASH playlist request error at URL: ' + _this5.srcUrl,\n            responseText: req.responseText,\n            // MEDIA_ERR_NETWORK\n            code: 2\n          };\n          if (_this5.state === 'HAVE_NOTHING') {\n            _this5.started = false;\n          }\n          return _this5.trigger('error');\n        }\n\n        _this5.masterXml_ = req.responseText;\n\n        var newMaster = _this5.parseMasterXml();\n\n        _this5.master = updateMaster$1(_this5.master, newMaster);\n\n        global_window__WEBPACK_IMPORTED_MODULE_0___default.a.setTimeout(function () {\n          _this5.trigger('minimumUpdatePeriod');\n        }, _this5.master.minimumUpdatePeriod);\n      });\n    }\n\n    /**\n     * Refreshes the media playlist by re-parsing the master xml and updating playlist\n     * references. If this is an alternate loader, the updated parsed manifest is retrieved\n     * from the master loader.\n     */\n\n  }, {\n    key: 'refreshMedia_',\n    value: function refreshMedia_() {\n      var _this6 = this;\n\n      var oldMaster = void 0;\n      var newMaster = void 0;\n\n      if (this.masterPlaylistLoader_) {\n        oldMaster = this.masterPlaylistLoader_.master;\n        newMaster = this.masterPlaylistLoader_.parseMasterXml();\n      } else {\n        oldMaster = this.master;\n        newMaster = this.parseMasterXml();\n      }\n\n      var updatedMaster = updateMaster$1(oldMaster, newMaster);\n\n      if (updatedMaster) {\n        if (this.masterPlaylistLoader_) {\n          this.masterPlaylistLoader_.master = updatedMaster;\n        } else {\n          this.master = updatedMaster;\n        }\n        this.media_ = updatedMaster.playlists[this.media_.uri];\n      } else {\n        this.trigger('playlistunchanged');\n      }\n\n      if (!this.media().endList) {\n        this.mediaUpdateTimeout = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.setTimeout(function () {\n          _this6.trigger('mediaupdatetimeout');\n        }, refreshDelay(this.media(), !!updatedMaster));\n      }\n\n      this.trigger('loadedplaylist');\n    }\n  }]);\n  return DashPlaylistLoader;\n}(EventTarget$1$1);\n\nvar logger = function logger(source) {\n  if (videojs$1.log.debug) {\n    return videojs$1.log.debug.bind(videojs$1, 'VHS:', source + ' >');\n  }\n\n  return function () {};\n};\n\nfunction noop() {}\n\n/**\n * @file source-updater.js\n */\n\n/**\n * A queue of callbacks to be serialized and applied when a\n * MediaSource and its associated SourceBuffers are not in the\n * updating state. It is used by the segment loader to update the\n * underlying SourceBuffers when new data is loaded, for instance.\n *\n * @class SourceUpdater\n * @param {MediaSource} mediaSource the MediaSource to create the\n * SourceBuffer from\n * @param {String} mimeType the desired MIME type of the underlying\n * SourceBuffer\n * @param {Object} sourceBufferEmitter an event emitter that fires when a source buffer is\n * added to the media source\n */\n\nvar SourceUpdater = function () {\n  function SourceUpdater(mediaSource, mimeType, type, sourceBufferEmitter) {\n    classCallCheck$1(this, SourceUpdater);\n\n    this.callbacks_ = [];\n    this.pendingCallback_ = null;\n    this.timestampOffset_ = 0;\n    this.mediaSource = mediaSource;\n    this.processedAppend_ = false;\n    this.type_ = type;\n    this.mimeType_ = mimeType;\n    this.logger_ = logger('SourceUpdater[' + type + '][' + mimeType + ']');\n\n    if (mediaSource.readyState === 'closed') {\n      mediaSource.addEventListener('sourceopen', this.createSourceBuffer_.bind(this, mimeType, sourceBufferEmitter));\n    } else {\n      this.createSourceBuffer_(mimeType, sourceBufferEmitter);\n    }\n  }\n\n  createClass$1(SourceUpdater, [{\n    key: 'createSourceBuffer_',\n    value: function createSourceBuffer_(mimeType, sourceBufferEmitter) {\n      var _this = this;\n\n      this.sourceBuffer_ = this.mediaSource.addSourceBuffer(mimeType);\n\n      this.logger_('created SourceBuffer');\n\n      if (sourceBufferEmitter) {\n        sourceBufferEmitter.trigger('sourcebufferadded');\n\n        if (this.mediaSource.sourceBuffers.length < 2) {\n          // There's another source buffer we must wait for before we can start updating\n          // our own (or else we can get into a bad state, i.e., appending video/audio data\n          // before the other video/audio source buffer is available and leading to a video\n          // or audio only buffer).\n          sourceBufferEmitter.on('sourcebufferadded', function () {\n            _this.start_();\n          });\n          return;\n        }\n      }\n\n      this.start_();\n    }\n  }, {\n    key: 'start_',\n    value: function start_() {\n      var _this2 = this;\n\n      this.started_ = true;\n\n      // run completion handlers and process callbacks as updateend\n      // events fire\n      this.onUpdateendCallback_ = function () {\n        var pendingCallback = _this2.pendingCallback_;\n\n        _this2.pendingCallback_ = null;\n\n        _this2.logger_('buffered [' + printableRange(_this2.buffered()) + ']');\n\n        if (pendingCallback) {\n          pendingCallback();\n        }\n\n        _this2.runCallback_();\n      };\n\n      this.sourceBuffer_.addEventListener('updateend', this.onUpdateendCallback_);\n\n      this.runCallback_();\n    }\n\n    /**\n     * Aborts the current segment and resets the segment parser.\n     *\n     * @param {Function} done function to call when done\n     * @see http://w3c.github.io/media-source/#widl-SourceBuffer-abort-void\n     */\n\n  }, {\n    key: 'abort',\n    value: function abort(done) {\n      var _this3 = this;\n\n      if (this.processedAppend_) {\n        this.queueCallback_(function () {\n          _this3.sourceBuffer_.abort();\n        }, done);\n      }\n    }\n\n    /**\n     * Queue an update to append an ArrayBuffer.\n     *\n     * @param {ArrayBuffer} bytes\n     * @param {Function} done the function to call when done\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-appendBuffer-void-ArrayBuffer-data\n     */\n\n  }, {\n    key: 'appendBuffer',\n    value: function appendBuffer(bytes, done) {\n      var _this4 = this;\n\n      this.processedAppend_ = true;\n      this.queueCallback_(function () {\n        _this4.sourceBuffer_.appendBuffer(bytes);\n      }, done);\n    }\n\n    /**\n     * Indicates what TimeRanges are buffered in the managed SourceBuffer.\n     *\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-buffered\n     */\n\n  }, {\n    key: 'buffered',\n    value: function buffered() {\n      if (!this.sourceBuffer_) {\n        return videojs$1.createTimeRanges();\n      }\n      return this.sourceBuffer_.buffered;\n    }\n\n    /**\n     * Queue an update to remove a time range from the buffer.\n     *\n     * @param {Number} start where to start the removal\n     * @param {Number} end where to end the removal\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      var _this5 = this;\n\n      if (this.processedAppend_) {\n        this.queueCallback_(function () {\n          _this5.logger_('remove [' + start + ' => ' + end + ']');\n          _this5.sourceBuffer_.remove(start, end);\n        }, noop);\n      }\n    }\n\n    /**\n     * Whether the underlying sourceBuffer is updating or not\n     *\n     * @return {Boolean} the updating status of the SourceBuffer\n     */\n\n  }, {\n    key: 'updating',\n    value: function updating() {\n      return !this.sourceBuffer_ || this.sourceBuffer_.updating || this.pendingCallback_;\n    }\n\n    /**\n     * Set/get the timestampoffset on the SourceBuffer\n     *\n     * @return {Number} the timestamp offset\n     */\n\n  }, {\n    key: 'timestampOffset',\n    value: function timestampOffset(offset) {\n      var _this6 = this;\n\n      if (typeof offset !== 'undefined') {\n        this.queueCallback_(function () {\n          _this6.sourceBuffer_.timestampOffset = offset;\n        });\n        this.timestampOffset_ = offset;\n      }\n      return this.timestampOffset_;\n    }\n\n    /**\n     * Queue a callback to run\n     */\n\n  }, {\n    key: 'queueCallback_',\n    value: function queueCallback_(callback, done) {\n      this.callbacks_.push([callback.bind(this), done]);\n      this.runCallback_();\n    }\n\n    /**\n     * Run a queued callback\n     */\n\n  }, {\n    key: 'runCallback_',\n    value: function runCallback_() {\n      var callbacks = void 0;\n\n      if (!this.updating() && this.callbacks_.length && this.started_) {\n        callbacks = this.callbacks_.shift();\n        this.pendingCallback_ = callbacks[1];\n        callbacks[0]();\n      }\n    }\n\n    /**\n     * dispose of the source updater and the underlying sourceBuffer\n     */\n\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.sourceBuffer_.removeEventListener('updateend', this.onUpdateendCallback_);\n      if (this.sourceBuffer_ && this.mediaSource.readyState === 'open') {\n        this.sourceBuffer_.abort();\n      }\n    }\n  }]);\n  return SourceUpdater;\n}();\n\nvar Config = {\n  GOAL_BUFFER_LENGTH: 30,\n  MAX_GOAL_BUFFER_LENGTH: 60,\n  GOAL_BUFFER_LENGTH_RATE: 1,\n  // A fudge factor to apply to advertised playlist bitrates to account for\n  // temporary flucations in client bandwidth\n  BANDWIDTH_VARIANCE: 1.2,\n  // How much of the buffer must be filled before we consider upswitching\n  BUFFER_LOW_WATER_LINE: 0,\n  MAX_BUFFER_LOW_WATER_LINE: 30,\n  BUFFER_LOW_WATER_LINE_RATE: 1\n};\n\nvar REQUEST_ERRORS = {\n  FAILURE: 2,\n  TIMEOUT: -101,\n  ABORTED: -102\n};\n\n/**\n * Turns segment byterange into a string suitable for use in\n * HTTP Range requests\n *\n * @param {Object} byterange - an object with two values defining the start and end\n *                             of a byte-range\n */\nvar byterangeStr = function byterangeStr(byterange) {\n  var byterangeStart = void 0;\n  var byterangeEnd = void 0;\n\n  // `byterangeEnd` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  byterangeEnd = byterange.offset + byterange.length - 1;\n  byterangeStart = byterange.offset;\n  return 'bytes=' + byterangeStart + '-' + byterangeEnd;\n};\n\n/**\n * Defines headers for use in the xhr request for a particular segment.\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n */\nvar segmentXhrHeaders = function segmentXhrHeaders(segment) {\n  var headers = {};\n\n  if (segment.byterange) {\n    headers.Range = byterangeStr(segment.byterange);\n  }\n  return headers;\n};\n\n/**\n * Abort all requests\n *\n * @param {Object} activeXhrs - an object that tracks all XHR requests\n */\nvar abortAll = function abortAll(activeXhrs) {\n  activeXhrs.forEach(function (xhr$$1) {\n    xhr$$1.abort();\n  });\n};\n\n/**\n * Gather important bandwidth stats once a request has completed\n *\n * @param {Object} request - the XHR request from which to gather stats\n */\nvar getRequestStats = function getRequestStats(request) {\n  return {\n    bandwidth: request.bandwidth,\n    bytesReceived: request.bytesReceived || 0,\n    roundTripTime: request.roundTripTime || 0\n  };\n};\n\n/**\n * If possible gather bandwidth stats as a request is in\n * progress\n *\n * @param {Event} progressEvent - an event object from an XHR's progress event\n */\nvar getProgressStats = function getProgressStats(progressEvent) {\n  var request = progressEvent.target;\n  var roundTripTime = Date.now() - request.requestTime;\n  var stats = {\n    bandwidth: Infinity,\n    bytesReceived: 0,\n    roundTripTime: roundTripTime || 0\n  };\n\n  stats.bytesReceived = progressEvent.loaded;\n  // This can result in Infinity if stats.roundTripTime is 0 but that is ok\n  // because we should only use bandwidth stats on progress to determine when\n  // abort a request early due to insufficient bandwidth\n  stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1000);\n\n  return stats;\n};\n\n/**\n * Handle all error conditions in one place and return an object\n * with all the information\n *\n * @param {Error|null} error - if non-null signals an error occured with the XHR\n * @param {Object} request -  the XHR request that possibly generated the error\n */\nvar handleErrors = function handleErrors(error, request) {\n  if (request.timedout) {\n    return {\n      status: request.status,\n      message: 'HLS request timed-out at URL: ' + request.uri,\n      code: REQUEST_ERRORS.TIMEOUT,\n      xhr: request\n    };\n  }\n\n  if (request.aborted) {\n    return {\n      status: request.status,\n      message: 'HLS request aborted at URL: ' + request.uri,\n      code: REQUEST_ERRORS.ABORTED,\n      xhr: request\n    };\n  }\n\n  if (error) {\n    return {\n      status: request.status,\n      message: 'HLS request errored at URL: ' + request.uri,\n      code: REQUEST_ERRORS.FAILURE,\n      xhr: request\n    };\n  }\n\n  return null;\n};\n\n/**\n * Handle responses for key data and convert the key data to the correct format\n * for the decryption step later\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\nvar handleKeyResponse = function handleKeyResponse(segment, finishProcessingFn) {\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n\n    if (response.byteLength !== 16) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Invalid HLS key at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n\n    var view = new DataView(response);\n\n    segment.key.bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);\n    return finishProcessingFn(null, segment);\n  };\n};\n\n/**\n * Handle init-segment responses\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\nvar handleInitSegmentResponse = function handleInitSegmentResponse(segment, finishProcessingFn) {\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n\n    // stop processing if received empty content\n    if (response.byteLength === 0) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Empty HLS segment content at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n\n    segment.map.bytes = new Uint8Array(request.response);\n    return finishProcessingFn(null, segment);\n  };\n};\n\n/**\n * Response handler for segment-requests being sure to set the correct\n * property depending on whether the segment is encryped or not\n * Also records and keeps track of stats that are used for ABR purposes\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\nvar handleSegmentResponse = function handleSegmentResponse(segment, finishProcessingFn) {\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n\n    // stop processing if received empty content\n    if (response.byteLength === 0) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Empty HLS segment content at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n\n    segment.stats = getRequestStats(request);\n\n    if (segment.key) {\n      segment.encryptedBytes = new Uint8Array(request.response);\n    } else {\n      segment.bytes = new Uint8Array(request.response);\n    }\n\n    return finishProcessingFn(null, segment);\n  };\n};\n\n/**\n * Decrypt the segment via the decryption web worker\n *\n * @param {WebWorker} decrypter - a WebWorker interface to AES-128 decryption routines\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} doneFn - a callback that is executed after decryption has completed\n */\nvar decryptSegment = function decryptSegment(decrypter, segment, doneFn) {\n  var decryptionHandler = function decryptionHandler(event) {\n    if (event.data.source === segment.requestId) {\n      decrypter.removeEventListener('message', decryptionHandler);\n      var decrypted = event.data.decrypted;\n\n      segment.bytes = new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength);\n      return doneFn(null, segment);\n    }\n  };\n\n  decrypter.addEventListener('message', decryptionHandler);\n\n  // this is an encrypted segment\n  // incrementally decrypt the segment\n  decrypter.postMessage(createTransferableMessage({\n    source: segment.requestId,\n    encrypted: segment.encryptedBytes,\n    key: segment.key.bytes,\n    iv: segment.key.iv\n  }), [segment.encryptedBytes.buffer, segment.key.bytes.buffer]);\n};\n\n/**\n * The purpose of this function is to get the most pertinent error from the\n * array of errors.\n * For instance if a timeout and two aborts occur, then the aborts were\n * likely triggered by the timeout so return that error object.\n */\nvar getMostImportantError = function getMostImportantError(errors) {\n  return errors.reduce(function (prev, err) {\n    return err.code > prev.code ? err : prev;\n  });\n};\n\n/**\n * This function waits for all XHRs to finish (with either success or failure)\n * before continueing processing via it's callback. The function gathers errors\n * from each request into a single errors array so that the error status for\n * each request can be examined later.\n *\n * @param {Object} activeXhrs - an object that tracks all XHR requests\n * @param {WebWorker} decrypter - a WebWorker interface to AES-128 decryption routines\n * @param {Function} doneFn - a callback that is executed after all resources have been\n *                            downloaded and any decryption completed\n */\nvar waitForCompletion = function waitForCompletion(activeXhrs, decrypter, doneFn) {\n  var errors = [];\n  var count = 0;\n\n  return function (error, segment) {\n    if (error) {\n      // If there are errors, we have to abort any outstanding requests\n      abortAll(activeXhrs);\n      errors.push(error);\n    }\n    count += 1;\n\n    if (count === activeXhrs.length) {\n      // Keep track of when *all* of the requests have completed\n      segment.endOfAllRequests = Date.now();\n\n      if (errors.length > 0) {\n        var worstError = getMostImportantError(errors);\n\n        return doneFn(worstError, segment);\n      }\n      if (segment.encryptedBytes) {\n        return decryptSegment(decrypter, segment, doneFn);\n      }\n      // Otherwise, everything is ready just continue\n      return doneFn(null, segment);\n    }\n  };\n};\n\n/**\n * Simple progress event callback handler that gathers some stats before\n * executing a provided callback with the `segment` object\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} progressFn - a callback that is executed each time a progress event\n *                                is received\n * @param {Event} event - the progress event object from XMLHttpRequest\n */\nvar handleProgress = function handleProgress(segment, progressFn) {\n  return function (event) {\n    segment.stats = videojs$1.mergeOptions(segment.stats, getProgressStats(event));\n\n    // record the time that we receive the first byte of data\n    if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {\n      segment.stats.firstBytesReceivedAt = Date.now();\n    }\n\n    return progressFn(event, segment);\n  };\n};\n\n/**\n * Load all resources and does any processing necessary for a media-segment\n *\n * Features:\n *   decrypts the media-segment if it has a key uri and an iv\n *   aborts *all* requests if *any* one request fails\n *\n * The segment object, at minimum, has the following format:\n * {\n *   resolvedUri: String,\n *   [byterange]: {\n *     offset: Number,\n *     length: Number\n *   },\n *   [key]: {\n *     resolvedUri: String\n *     [byterange]: {\n *       offset: Number,\n *       length: Number\n *     },\n *     iv: {\n *       bytes: Uint32Array\n *     }\n *   },\n *   [map]: {\n *     resolvedUri: String,\n *     [byterange]: {\n *       offset: Number,\n *       length: Number\n *     },\n *     [bytes]: Uint8Array\n *   }\n * }\n * ...where [name] denotes optional properties\n *\n * @param {Function} xhr - an instance of the xhr wrapper in xhr.js\n * @param {Object} xhrOptions - the base options to provide to all xhr requests\n * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128\n *                                       decryption routines\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} progressFn - a callback that receives progress events from the main\n *                                segment's xhr request\n * @param {Function} doneFn - a callback that is executed only once all requests have\n *                            succeeded or failed\n * @returns {Function} a function that, when invoked, immediately aborts all\n *                     outstanding requests\n */\nvar mediaSegmentRequest = function mediaSegmentRequest(xhr$$1, xhrOptions, decryptionWorker, segment, progressFn, doneFn) {\n  var activeXhrs = [];\n  var finishProcessingFn = waitForCompletion(activeXhrs, decryptionWorker, doneFn);\n\n  // optionally, request the decryption key\n  if (segment.key) {\n    var keyRequestOptions = videojs$1.mergeOptions(xhrOptions, {\n      uri: segment.key.resolvedUri,\n      responseType: 'arraybuffer'\n    });\n    var keyRequestCallback = handleKeyResponse(segment, finishProcessingFn);\n    var keyXhr = xhr$$1(keyRequestOptions, keyRequestCallback);\n\n    activeXhrs.push(keyXhr);\n  }\n\n  // optionally, request the associated media init segment\n  if (segment.map && !segment.map.bytes) {\n    var initSegmentOptions = videojs$1.mergeOptions(xhrOptions, {\n      uri: segment.map.resolvedUri,\n      responseType: 'arraybuffer',\n      headers: segmentXhrHeaders(segment.map)\n    });\n    var initSegmentRequestCallback = handleInitSegmentResponse(segment, finishProcessingFn);\n    var initSegmentXhr = xhr$$1(initSegmentOptions, initSegmentRequestCallback);\n\n    activeXhrs.push(initSegmentXhr);\n  }\n\n  var segmentRequestOptions = videojs$1.mergeOptions(xhrOptions, {\n    uri: segment.resolvedUri,\n    responseType: 'arraybuffer',\n    headers: segmentXhrHeaders(segment)\n  });\n  var segmentRequestCallback = handleSegmentResponse(segment, finishProcessingFn);\n  var segmentXhr = xhr$$1(segmentRequestOptions, segmentRequestCallback);\n\n  segmentXhr.addEventListener('progress', handleProgress(segment, progressFn));\n  activeXhrs.push(segmentXhr);\n\n  return function () {\n    return abortAll(activeXhrs);\n  };\n};\n\n/**\n * @file - codecs.js - Handles tasks regarding codec strings such as translating them to\n * codec strings, or translating codec strings into objects that can be examined.\n */\n\n// Default codec parameters if none were provided for video and/or audio\nvar defaultCodecs = {\n  videoCodec: 'avc1',\n  videoObjectTypeIndicator: '.4d400d',\n  // AAC-LC\n  audioProfile: '2'\n};\n\n/**\n * Parses a codec string to retrieve the number of codecs specified,\n * the video codec and object type indicator, and the audio profile.\n */\n\nvar parseCodecs = function parseCodecs() {\n  var codecs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n  var result = {\n    codecCount: 0\n  };\n  var parsed = void 0;\n\n  result.codecCount = codecs.split(',').length;\n  result.codecCount = result.codecCount || 2;\n\n  // parse the video codec\n  parsed = /(^|\\s|,)+(avc[13])([^ ,]*)/i.exec(codecs);\n  if (parsed) {\n    result.videoCodec = parsed[2];\n    result.videoObjectTypeIndicator = parsed[3];\n  }\n\n  // parse the last field of the audio codec\n  result.audioProfile = /(^|\\s|,)+mp4a.[0-9A-Fa-f]+\\.([0-9A-Fa-f]+)/i.exec(codecs);\n  result.audioProfile = result.audioProfile && result.audioProfile[2];\n\n  return result;\n};\n\n/**\n * Replace codecs in the codec string with the old apple-style `avc1.<dd>.<dd>` to the\n * standard `avc1.<hhhhhh>`.\n *\n * @param codecString {String} the codec string\n * @return {String} the codec string with old apple-style codecs replaced\n *\n * @private\n */\nvar mapLegacyAvcCodecs = function mapLegacyAvcCodecs(codecString) {\n  return codecString.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (match) {\n    return translateLegacyCodecs([match])[0];\n  });\n};\n\n/**\n * Build a media mime-type string from a set of parameters\n * @param {String} type either 'audio' or 'video'\n * @param {String} container either 'mp2t' or 'mp4'\n * @param {Array} codecs an array of codec strings to add\n * @return {String} a valid media mime-type\n */\nvar makeMimeTypeString = function makeMimeTypeString(type, container, codecs) {\n  // The codecs array is filtered so that falsey values are\n  // dropped and don't cause Array#join to create spurious\n  // commas\n  return type + '/' + container + '; codecs=\"' + codecs.filter(function (c) {\n    return !!c;\n  }).join(', ') + '\"';\n};\n\n/**\n * Returns the type container based on information in the playlist\n * @param {Playlist} media the current media playlist\n * @return {String} a valid media container type\n */\nvar getContainerType = function getContainerType(media) {\n  // An initialization segment means the media playlist is an iframe\n  // playlist or is using the mp4 container. We don't currently\n  // support iframe playlists, so assume this is signalling mp4\n  // fragments.\n  if (media.segments && media.segments.length && media.segments[0].map) {\n    return 'mp4';\n  }\n  return 'mp2t';\n};\n\n/**\n * Returns a set of codec strings parsed from the playlist or the default\n * codec strings if no codecs were specified in the playlist\n * @param {Playlist} media the current media playlist\n * @return {Object} an object with the video and audio codecs\n */\nvar getCodecs = function getCodecs(media) {\n  // if the codecs were explicitly specified, use them instead of the\n  // defaults\n  var mediaAttributes = media.attributes || {};\n\n  if (mediaAttributes.CODECS) {\n    return parseCodecs(mediaAttributes.CODECS);\n  }\n  return defaultCodecs;\n};\n\nvar audioProfileFromDefault = function audioProfileFromDefault(master, audioGroupId) {\n  if (!master.mediaGroups.AUDIO || !audioGroupId) {\n    return null;\n  }\n\n  var audioGroup = master.mediaGroups.AUDIO[audioGroupId];\n\n  if (!audioGroup) {\n    return null;\n  }\n\n  for (var name in audioGroup) {\n    var audioType = audioGroup[name];\n\n    if (audioType.default && audioType.playlists) {\n      // codec should be the same for all playlists within the audio type\n      return parseCodecs(audioType.playlists[0].attributes.CODECS).audioProfile;\n    }\n  }\n\n  return null;\n};\n\n/**\n * Calculates the MIME type strings for a working configuration of\n * SourceBuffers to play variant streams in a master playlist. If\n * there is no possible working configuration, an empty array will be\n * returned.\n *\n * @param master {Object} the m3u8 object for the master playlist\n * @param media {Object} the m3u8 object for the variant playlist\n * @return {Array} the MIME type strings. If the array has more than\n * one entry, the first element should be applied to the video\n * SourceBuffer and the second to the audio SourceBuffer.\n *\n * @private\n */\nvar mimeTypesForPlaylist = function mimeTypesForPlaylist(master, media) {\n  var containerType = getContainerType(media);\n  var codecInfo = getCodecs(media);\n  var mediaAttributes = media.attributes || {};\n  // Default condition for a traditional HLS (no demuxed audio/video)\n  var isMuxed = true;\n  var isMaat = false;\n\n  if (!media) {\n    // Not enough information\n    return [];\n  }\n\n  if (master.mediaGroups.AUDIO && mediaAttributes.AUDIO) {\n    var audioGroup = master.mediaGroups.AUDIO[mediaAttributes.AUDIO];\n\n    // Handle the case where we are in a multiple-audio track scenario\n    if (audioGroup) {\n      isMaat = true;\n      // Start with the everything demuxed then...\n      isMuxed = false;\n      // ...check to see if any audio group tracks are muxed (ie. lacking a uri)\n      for (var groupId in audioGroup) {\n        // either a uri is present (if the case of HLS and an external playlist), or\n        // playlists is present (in the case of DASH where we don't have external audio\n        // playlists)\n        if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) {\n          isMuxed = true;\n          break;\n        }\n      }\n    }\n  }\n\n  // HLS with multiple-audio tracks must always get an audio codec.\n  // Put another way, there is no way to have a video-only multiple-audio HLS!\n  if (isMaat && !codecInfo.audioProfile) {\n    if (!isMuxed) {\n      // It is possible for codecs to be specified on the audio media group playlist but\n      // not on the rendition playlist. This is mostly the case for DASH, where audio and\n      // video are always separate (and separately specified).\n      codecInfo.audioProfile = audioProfileFromDefault(master, mediaAttributes.AUDIO);\n    }\n\n    if (!codecInfo.audioProfile) {\n      videojs$1.log.warn('Multiple audio tracks present but no audio codec string is specified. ' + 'Attempting to use the default audio codec (mp4a.40.2)');\n      codecInfo.audioProfile = defaultCodecs.audioProfile;\n    }\n  }\n\n  // Generate the final codec strings from the codec object generated above\n  var codecStrings = {};\n\n  if (codecInfo.videoCodec) {\n    codecStrings.video = '' + codecInfo.videoCodec + codecInfo.videoObjectTypeIndicator;\n  }\n\n  if (codecInfo.audioProfile) {\n    codecStrings.audio = 'mp4a.40.' + codecInfo.audioProfile;\n  }\n\n  // Finally, make and return an array with proper mime-types depending on\n  // the configuration\n  var justAudio = makeMimeTypeString('audio', containerType, [codecStrings.audio]);\n  var justVideo = makeMimeTypeString('video', containerType, [codecStrings.video]);\n  var bothVideoAudio = makeMimeTypeString('video', containerType, [codecStrings.video, codecStrings.audio]);\n\n  if (isMaat) {\n    if (!isMuxed && codecStrings.video) {\n      return [justVideo, justAudio];\n    }\n\n    if (!isMuxed && !codecStrings.video) {\n      // There is no muxed content and no video codec string, so this is an audio only\n      // stream with alternate audio.\n      return [justAudio, justAudio];\n    }\n\n    // There exists the possiblity that this will return a `video/container`\n    // mime-type for the first entry in the array even when there is only audio.\n    // This doesn't appear to be a problem and simplifies the code.\n    return [bothVideoAudio, justAudio];\n  }\n\n  // If there is no video codec at all, always just return a single\n  // audio/<container> mime-type\n  if (!codecStrings.video) {\n    return [justAudio];\n  }\n\n  // When not using separate audio media groups, audio and video is\n  // *always* muxed\n  return [bothVideoAudio];\n};\n\n// Utilities\n\n/**\n * Returns the CSS value for the specified property on an element\n * using `getComputedStyle`. Firefox has a long-standing issue where\n * getComputedStyle() may return null when running in an iframe with\n * `display: none`.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n * @param {HTMLElement} el the htmlelement to work on\n * @param {string} the proprety to get the style for\n */\nvar safeGetComputedStyle = function safeGetComputedStyle(el, property) {\n  var result = void 0;\n\n  if (!el) {\n    return '';\n  }\n\n  result = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.getComputedStyle(el);\n  if (!result) {\n    return '';\n  }\n\n  return result[property];\n};\n\n/**\n * Resuable stable sort function\n *\n * @param {Playlists} array\n * @param {Function} sortFn Different comparators\n * @function stableSort\n */\nvar stableSort = function stableSort(array, sortFn) {\n  var newArray = array.slice();\n\n  array.sort(function (left, right) {\n    var cmp = sortFn(left, right);\n\n    if (cmp === 0) {\n      return newArray.indexOf(left) - newArray.indexOf(right);\n    }\n    return cmp;\n  });\n};\n\n/**\n * A comparator function to sort two playlist object by bandwidth.\n *\n * @param {Object} left a media playlist object\n * @param {Object} right a media playlist object\n * @return {Number} Greater than zero if the bandwidth attribute of\n * left is greater than the corresponding attribute of right. Less\n * than zero if the bandwidth of right is greater than left and\n * exactly zero if the two are equal.\n */\nvar comparePlaylistBandwidth = function comparePlaylistBandwidth(left, right) {\n  var leftBandwidth = void 0;\n  var rightBandwidth = void 0;\n\n  if (left.attributes.BANDWIDTH) {\n    leftBandwidth = left.attributes.BANDWIDTH;\n  }\n  leftBandwidth = leftBandwidth || global_window__WEBPACK_IMPORTED_MODULE_0___default.a.Number.MAX_VALUE;\n  if (right.attributes.BANDWIDTH) {\n    rightBandwidth = right.attributes.BANDWIDTH;\n  }\n  rightBandwidth = rightBandwidth || global_window__WEBPACK_IMPORTED_MODULE_0___default.a.Number.MAX_VALUE;\n\n  return leftBandwidth - rightBandwidth;\n};\n\n/**\n * A comparator function to sort two playlist object by resolution (width).\n * @param {Object} left a media playlist object\n * @param {Object} right a media playlist object\n * @return {Number} Greater than zero if the resolution.width attribute of\n * left is greater than the corresponding attribute of right. Less\n * than zero if the resolution.width of right is greater than left and\n * exactly zero if the two are equal.\n */\nvar comparePlaylistResolution = function comparePlaylistResolution(left, right) {\n  var leftWidth = void 0;\n  var rightWidth = void 0;\n\n  if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {\n    leftWidth = left.attributes.RESOLUTION.width;\n  }\n\n  leftWidth = leftWidth || global_window__WEBPACK_IMPORTED_MODULE_0___default.a.Number.MAX_VALUE;\n\n  if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {\n    rightWidth = right.attributes.RESOLUTION.width;\n  }\n\n  rightWidth = rightWidth || global_window__WEBPACK_IMPORTED_MODULE_0___default.a.Number.MAX_VALUE;\n\n  // NOTE - Fallback to bandwidth sort as appropriate in cases where multiple renditions\n  // have the same media dimensions/ resolution\n  if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {\n    return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;\n  }\n  return leftWidth - rightWidth;\n};\n\n/**\n * Chooses the appropriate media playlist based on bandwidth and player size\n *\n * @param {Object} master\n *        Object representation of the master manifest\n * @param {Number} playerBandwidth\n *        Current calculated bandwidth of the player\n * @param {Number} playerWidth\n *        Current width of the player element\n * @param {Number} playerHeight\n *        Current height of the player element\n * @return {Playlist} the highest bitrate playlist less than the\n * currently detected bandwidth, accounting for some amount of\n * bandwidth variance\n */\nvar simpleSelector = function simpleSelector(master, playerBandwidth, playerWidth, playerHeight) {\n  // convert the playlists to an intermediary representation to make comparisons easier\n  var sortedPlaylistReps = master.playlists.map(function (playlist) {\n    var width = void 0;\n    var height = void 0;\n    var bandwidth = void 0;\n\n    width = playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;\n    height = playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;\n    bandwidth = playlist.attributes.BANDWIDTH;\n\n    bandwidth = bandwidth || global_window__WEBPACK_IMPORTED_MODULE_0___default.a.Number.MAX_VALUE;\n\n    return {\n      bandwidth: bandwidth,\n      width: width,\n      height: height,\n      playlist: playlist\n    };\n  });\n\n  stableSort(sortedPlaylistReps, function (left, right) {\n    return left.bandwidth - right.bandwidth;\n  });\n\n  // filter out any playlists that have been excluded due to\n  // incompatible configurations\n  sortedPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n    return !Playlist.isIncompatible(rep.playlist);\n  });\n\n  // filter out any playlists that have been disabled manually through the representations\n  // api or blacklisted temporarily due to playback errors.\n  var enabledPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n    return Playlist.isEnabled(rep.playlist);\n  });\n\n  if (!enabledPlaylistReps.length) {\n    // if there are no enabled playlists, then they have all been blacklisted or disabled\n    // by the user through the representations api. In this case, ignore blacklisting and\n    // fallback to what the user wants by using playlists the user has not disabled.\n    enabledPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n      return !Playlist.isDisabled(rep.playlist);\n    });\n  }\n\n  // filter out any variant that has greater effective bitrate\n  // than the current estimated bandwidth\n  var bandwidthPlaylistReps = enabledPlaylistReps.filter(function (rep) {\n    return rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth;\n  });\n\n  var highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1];\n\n  // get all of the renditions with the same (highest) bandwidth\n  // and then taking the very first element\n  var bandwidthBestRep = bandwidthPlaylistReps.filter(function (rep) {\n    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n  })[0];\n\n  // filter out playlists without resolution information\n  var haveResolution = bandwidthPlaylistReps.filter(function (rep) {\n    return rep.width && rep.height;\n  });\n\n  // sort variants by resolution\n  stableSort(haveResolution, function (left, right) {\n    return left.width - right.width;\n  });\n\n  // if we have the exact resolution as the player use it\n  var resolutionBestRepList = haveResolution.filter(function (rep) {\n    return rep.width === playerWidth && rep.height === playerHeight;\n  });\n\n  highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1];\n  // ensure that we pick the highest bandwidth variant that have exact resolution\n  var resolutionBestRep = resolutionBestRepList.filter(function (rep) {\n    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n  })[0];\n\n  var resolutionPlusOneList = void 0;\n  var resolutionPlusOneSmallest = void 0;\n  var resolutionPlusOneRep = void 0;\n\n  // find the smallest variant that is larger than the player\n  // if there is no match of exact resolution\n  if (!resolutionBestRep) {\n    resolutionPlusOneList = haveResolution.filter(function (rep) {\n      return rep.width > playerWidth || rep.height > playerHeight;\n    });\n\n    // find all the variants have the same smallest resolution\n    resolutionPlusOneSmallest = resolutionPlusOneList.filter(function (rep) {\n      return rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height;\n    });\n\n    // ensure that we also pick the highest bandwidth variant that\n    // is just-larger-than the video player\n    highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];\n    resolutionPlusOneRep = resolutionPlusOneSmallest.filter(function (rep) {\n      return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n    })[0];\n  }\n\n  // fallback chain of variants\n  var chosenRep = resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];\n\n  return chosenRep ? chosenRep.playlist : null;\n};\n\n// Playlist Selectors\n\n/**\n * Chooses the appropriate media playlist based on the most recent\n * bandwidth estimate and the player size.\n *\n * Expects to be called within the context of an instance of HlsHandler\n *\n * @return {Playlist} the highest bitrate playlist less than the\n * currently detected bandwidth, accounting for some amount of\n * bandwidth variance\n */\nvar lastBandwidthSelector = function lastBandwidthSelector() {\n  return simpleSelector(this.playlists.master, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10), parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10));\n};\n\n/**\n * Chooses the appropriate media playlist based on the potential to rebuffer\n *\n * @param {Object} settings\n *        Object of information required to use this selector\n * @param {Object} settings.master\n *        Object representation of the master manifest\n * @param {Number} settings.currentTime\n *        The current time of the player\n * @param {Number} settings.bandwidth\n *        Current measured bandwidth\n * @param {Number} settings.duration\n *        Duration of the media\n * @param {Number} settings.segmentDuration\n *        Segment duration to be used in round trip time calculations\n * @param {Number} settings.timeUntilRebuffer\n *        Time left in seconds until the player has to rebuffer\n * @param {Number} settings.currentTimeline\n *        The current timeline segments are being loaded from\n * @param {SyncController} settings.syncController\n *        SyncController for determining if we have a sync point for a given playlist\n * @return {Object|null}\n *         {Object} return.playlist\n *         The highest bandwidth playlist with the least amount of rebuffering\n *         {Number} return.rebufferingImpact\n *         The amount of time in seconds switching to this playlist will rebuffer. A\n *         negative value means that switching will cause zero rebuffering.\n */\nvar minRebufferMaxBandwidthSelector = function minRebufferMaxBandwidthSelector(settings) {\n  var master = settings.master,\n      currentTime = settings.currentTime,\n      bandwidth = settings.bandwidth,\n      duration$$1 = settings.duration,\n      segmentDuration = settings.segmentDuration,\n      timeUntilRebuffer = settings.timeUntilRebuffer,\n      currentTimeline = settings.currentTimeline,\n      syncController = settings.syncController;\n\n  // filter out any playlists that have been excluded due to\n  // incompatible configurations\n\n  var compatiblePlaylists = master.playlists.filter(function (playlist) {\n    return !Playlist.isIncompatible(playlist);\n  });\n\n  // filter out any playlists that have been disabled manually through the representations\n  // api or blacklisted temporarily due to playback errors.\n  var enabledPlaylists = compatiblePlaylists.filter(Playlist.isEnabled);\n\n  if (!enabledPlaylists.length) {\n    // if there are no enabled playlists, then they have all been blacklisted or disabled\n    // by the user through the representations api. In this case, ignore blacklisting and\n    // fallback to what the user wants by using playlists the user has not disabled.\n    enabledPlaylists = compatiblePlaylists.filter(function (playlist) {\n      return !Playlist.isDisabled(playlist);\n    });\n  }\n\n  var bandwidthPlaylists = enabledPlaylists.filter(Playlist.hasAttribute.bind(null, 'BANDWIDTH'));\n\n  var rebufferingEstimates = bandwidthPlaylists.map(function (playlist) {\n    var syncPoint = syncController.getSyncPoint(playlist, duration$$1, currentTimeline, currentTime);\n    // If there is no sync point for this playlist, switching to it will require a\n    // sync request first. This will double the request time\n    var numRequests = syncPoint ? 1 : 2;\n    var requestTimeEstimate = Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);\n    var rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer;\n\n    return {\n      playlist: playlist,\n      rebufferingImpact: rebufferingImpact\n    };\n  });\n\n  var noRebufferingPlaylists = rebufferingEstimates.filter(function (estimate) {\n    return estimate.rebufferingImpact <= 0;\n  });\n\n  // Sort by bandwidth DESC\n  stableSort(noRebufferingPlaylists, function (a, b) {\n    return comparePlaylistBandwidth(b.playlist, a.playlist);\n  });\n\n  if (noRebufferingPlaylists.length) {\n    return noRebufferingPlaylists[0];\n  }\n\n  stableSort(rebufferingEstimates, function (a, b) {\n    return a.rebufferingImpact - b.rebufferingImpact;\n  });\n\n  return rebufferingEstimates[0] || null;\n};\n\n/**\n * Chooses the appropriate media playlist, which in this case is the lowest bitrate\n * one with video.  If no renditions with video exist, return the lowest audio rendition.\n *\n * Expects to be called within the context of an instance of HlsHandler\n *\n * @return {Object|null}\n *         {Object} return.playlist\n *         The lowest bitrate playlist that contains a video codec.  If no such rendition\n *         exists pick the lowest audio rendition.\n */\nvar lowestBitrateCompatibleVariantSelector = function lowestBitrateCompatibleVariantSelector() {\n  // filter out any playlists that have been excluded due to\n  // incompatible configurations or playback errors\n  var playlists = this.playlists.master.playlists.filter(Playlist.isEnabled);\n\n  // Sort ascending by bitrate\n  stableSort(playlists, function (a, b) {\n    return comparePlaylistBandwidth(a, b);\n  });\n\n  // Parse and assume that playlists with no video codec have no video\n  // (this is not necessarily true, although it is generally true).\n  //\n  // If an entire manifest has no valid videos everything will get filtered\n  // out.\n  var playlistsWithVideo = playlists.filter(function (playlist) {\n    return parseCodecs(playlist.attributes.CODECS).videoCodec;\n  });\n\n  return playlistsWithVideo[0] || null;\n};\n\n/**\n * @file segment-loader.js\n */\n\n// in ms\nvar CHECK_BUFFER_DELAY = 500;\n\n/**\n * Determines if we should call endOfStream on the media source based\n * on the state of the buffer or if appened segment was the final\n * segment in the playlist.\n *\n * @param {Object} playlist a media playlist object\n * @param {Object} mediaSource the MediaSource object\n * @param {Number} segmentIndex the index of segment we last appended\n * @returns {Boolean} do we need to call endOfStream on the MediaSource\n */\nvar detectEndOfStream = function detectEndOfStream(playlist, mediaSource, segmentIndex) {\n  if (!playlist || !mediaSource) {\n    return false;\n  }\n\n  var segments = playlist.segments;\n\n  // determine a few boolean values to help make the branch below easier\n  // to read\n  var appendedLastSegment = segmentIndex === segments.length;\n\n  // if we've buffered to the end of the video, we need to call endOfStream\n  // so that MediaSources can trigger the `ended` event when it runs out of\n  // buffered data instead of waiting for me\n  return playlist.endList && mediaSource.readyState === 'open' && appendedLastSegment;\n};\n\nvar finite = function finite(num) {\n  return typeof num === 'number' && isFinite(num);\n};\n\nvar illegalMediaSwitch = function illegalMediaSwitch(loaderType, startingMedia, newSegmentMedia) {\n  // Although these checks should most likely cover non 'main' types, for now it narrows\n  // the scope of our checks.\n  if (loaderType !== 'main' || !startingMedia || !newSegmentMedia) {\n    return null;\n  }\n\n  if (!newSegmentMedia.containsAudio && !newSegmentMedia.containsVideo) {\n    return 'Neither audio nor video found in segment.';\n  }\n\n  if (startingMedia.containsVideo && !newSegmentMedia.containsVideo) {\n    return 'Only audio found in segment when we expected video.' + ' We can\\'t switch to audio only from a stream that had video.' + ' To get rid of this message, please add codec information to the manifest.';\n  }\n\n  if (!startingMedia.containsVideo && newSegmentMedia.containsVideo) {\n    return 'Video found in segment when we expected only audio.' + ' We can\\'t switch to a stream with video from an audio only stream.' + ' To get rid of this message, please add codec information to the manifest.';\n  }\n\n  return null;\n};\n\n/**\n * Calculates a time value that is safe to remove from the back buffer without interupting\n * playback.\n *\n * @param {TimeRange} seekable\n *        The current seekable range\n * @param {Number} currentTime\n *        The current time of the player\n * @param {Number} targetDuration\n *        The target duration of the current playlist\n * @return {Number}\n *         Time that is safe to remove from the back buffer without interupting playback\n */\nvar safeBackBufferTrimTime = function safeBackBufferTrimTime(seekable$$1, currentTime, targetDuration) {\n  var removeToTime = void 0;\n\n  if (seekable$$1.length && seekable$$1.start(0) > 0 && seekable$$1.start(0) < currentTime) {\n    // If we have a seekable range use that as the limit for what can be removed safely\n    removeToTime = seekable$$1.start(0);\n  } else {\n    // otherwise remove anything older than 30 seconds before the current play head\n    removeToTime = currentTime - 30;\n  }\n\n  // Don't allow removing from the buffer within target duration of current time\n  // to avoid the possibility of removing the GOP currently being played which could\n  // cause playback stalls.\n  return Math.min(removeToTime, currentTime - targetDuration);\n};\n\nvar segmentInfoString = function segmentInfoString(segmentInfo) {\n  var _segmentInfo$segment = segmentInfo.segment,\n      start = _segmentInfo$segment.start,\n      end = _segmentInfo$segment.end,\n      _segmentInfo$playlist = segmentInfo.playlist,\n      seq = _segmentInfo$playlist.mediaSequence,\n      id = _segmentInfo$playlist.id,\n      _segmentInfo$playlist2 = _segmentInfo$playlist.segments,\n      segments = _segmentInfo$playlist2 === undefined ? [] : _segmentInfo$playlist2,\n      index = segmentInfo.mediaIndex,\n      timeline = segmentInfo.timeline;\n\n  return ['appending [' + index + '] of [' + seq + ', ' + (seq + segments.length) + '] from playlist [' + id + ']', '[' + start + ' => ' + end + '] in timeline [' + timeline + ']'].join(' ');\n};\n\n/**\n * An object that manages segment loading and appending.\n *\n * @class SegmentLoader\n * @param {Object} options required and optional options\n * @extends videojs.EventTarget\n */\n\nvar SegmentLoader = function (_videojs$EventTarget) {\n  inherits$1(SegmentLoader, _videojs$EventTarget);\n\n  function SegmentLoader(settings) {\n    classCallCheck$1(this, SegmentLoader);\n\n    // check pre-conditions\n    var _this = possibleConstructorReturn$1(this, (SegmentLoader.__proto__ || Object.getPrototypeOf(SegmentLoader)).call(this));\n\n    if (!settings) {\n      throw new TypeError('Initialization settings are required');\n    }\n    if (typeof settings.currentTime !== 'function') {\n      throw new TypeError('No currentTime getter specified');\n    }\n    if (!settings.mediaSource) {\n      throw new TypeError('No MediaSource specified');\n    }\n    // public properties\n    _this.bandwidth = settings.bandwidth;\n    _this.throughput = { rate: 0, count: 0 };\n    _this.roundTrip = NaN;\n    _this.resetStats_();\n    _this.mediaIndex = null;\n\n    // private settings\n    _this.hasPlayed_ = settings.hasPlayed;\n    _this.currentTime_ = settings.currentTime;\n    _this.seekable_ = settings.seekable;\n    _this.seeking_ = settings.seeking;\n    _this.duration_ = settings.duration;\n    _this.mediaSource_ = settings.mediaSource;\n    _this.hls_ = settings.hls;\n    _this.loaderType_ = settings.loaderType;\n    _this.startingMedia_ = void 0;\n    _this.segmentMetadataTrack_ = settings.segmentMetadataTrack;\n    _this.goalBufferLength_ = settings.goalBufferLength;\n    _this.sourceType_ = settings.sourceType;\n    _this.state_ = 'INIT';\n\n    // private instance variables\n    _this.checkBufferTimeout_ = null;\n    _this.error_ = void 0;\n    _this.currentTimeline_ = -1;\n    _this.pendingSegment_ = null;\n    _this.mimeType_ = null;\n    _this.sourceUpdater_ = null;\n    _this.xhrOptions_ = null;\n\n    // Fragmented mp4 playback\n    _this.activeInitSegmentId_ = null;\n    _this.initSegments_ = {};\n\n    _this.decrypter_ = settings.decrypter;\n\n    // Manages the tracking and generation of sync-points, mappings\n    // between a time in the display time and a segment index within\n    // a playlist\n    _this.syncController_ = settings.syncController;\n    _this.syncPoint_ = {\n      segmentIndex: 0,\n      time: 0\n    };\n\n    _this.syncController_.on('syncinfoupdate', function () {\n      return _this.trigger('syncinfoupdate');\n    });\n\n    _this.mediaSource_.addEventListener('sourceopen', function () {\n      return _this.ended_ = false;\n    });\n\n    // ...for determining the fetch location\n    _this.fetchAtBuffer_ = false;\n\n    _this.logger_ = logger('SegmentLoader[' + _this.loaderType_ + ']');\n\n    Object.defineProperty(_this, 'state', {\n      get: function get$$1() {\n        return this.state_;\n      },\n      set: function set$$1(newState) {\n        if (newState !== this.state_) {\n          this.logger_(this.state_ + ' -> ' + newState);\n          this.state_ = newState;\n        }\n      }\n    });\n    return _this;\n  }\n\n  /**\n   * reset all of our media stats\n   *\n   * @private\n   */\n\n  createClass$1(SegmentLoader, [{\n    key: 'resetStats_',\n    value: function resetStats_() {\n      this.mediaBytesTransferred = 0;\n      this.mediaRequests = 0;\n      this.mediaRequestsAborted = 0;\n      this.mediaRequestsTimedout = 0;\n      this.mediaRequestsErrored = 0;\n      this.mediaTransferDuration = 0;\n      this.mediaSecondsLoaded = 0;\n    }\n\n    /**\n     * dispose of the SegmentLoader and reset to the default state\n     */\n\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.state = 'DISPOSED';\n      this.pause();\n      this.abort_();\n      if (this.sourceUpdater_) {\n        this.sourceUpdater_.dispose();\n      }\n      this.resetStats_();\n    }\n\n    /**\n     * abort anything that is currently doing on with the SegmentLoader\n     * and reset to a default state\n     */\n\n  }, {\n    key: 'abort',\n    value: function abort() {\n      if (this.state !== 'WAITING') {\n        if (this.pendingSegment_) {\n          this.pendingSegment_ = null;\n        }\n        return;\n      }\n\n      this.abort_();\n\n      // We aborted the requests we were waiting on, so reset the loader's state to READY\n      // since we are no longer \"waiting\" on any requests. XHR callback is not always run\n      // when the request is aborted. This will prevent the loader from being stuck in the\n      // WAITING state indefinitely.\n      this.state = 'READY';\n\n      // don't wait for buffer check timeouts to begin fetching the\n      // next segment\n      if (!this.paused()) {\n        this.monitorBuffer_();\n      }\n    }\n\n    /**\n     * abort all pending xhr requests and null any pending segements\n     *\n     * @private\n     */\n\n  }, {\n    key: 'abort_',\n    value: function abort_() {\n      if (this.pendingSegment_) {\n        this.pendingSegment_.abortRequests();\n      }\n\n      // clear out the segment being processed\n      this.pendingSegment_ = null;\n    }\n\n    /**\n     * set an error on the segment loader and null out any pending segements\n     *\n     * @param {Error} error the error to set on the SegmentLoader\n     * @return {Error} the error that was set or that is currently set\n     */\n\n  }, {\n    key: 'error',\n    value: function error(_error) {\n      if (typeof _error !== 'undefined') {\n        this.error_ = _error;\n      }\n\n      this.pendingSegment_ = null;\n      return this.error_;\n    }\n  }, {\n    key: 'endOfStream',\n    value: function endOfStream() {\n      this.ended_ = true;\n      this.pause();\n      this.trigger('ended');\n    }\n\n    /**\n     * Indicates which time ranges are buffered\n     *\n     * @return {TimeRange}\n     *         TimeRange object representing the current buffered ranges\n     */\n\n  }, {\n    key: 'buffered_',\n    value: function buffered_() {\n      if (!this.sourceUpdater_) {\n        return videojs$1.createTimeRanges();\n      }\n\n      return this.sourceUpdater_.buffered();\n    }\n\n    /**\n     * Gets and sets init segment for the provided map\n     *\n     * @param {Object} map\n     *        The map object representing the init segment to get or set\n     * @param {Boolean=} set\n     *        If true, the init segment for the provided map should be saved\n     * @return {Object}\n     *         map object for desired init segment\n     */\n\n  }, {\n    key: 'initSegment',\n    value: function initSegment(map) {\n      var set$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!map) {\n        return null;\n      }\n\n      var id = initSegmentId(map);\n      var storedMap = this.initSegments_[id];\n\n      if (set$$1 && !storedMap && map.bytes) {\n        this.initSegments_[id] = storedMap = {\n          resolvedUri: map.resolvedUri,\n          byterange: map.byterange,\n          bytes: map.bytes\n        };\n      }\n\n      return storedMap || map;\n    }\n\n    /**\n     * Returns true if all configuration required for loading is present, otherwise false.\n     *\n     * @return {Boolean} True if the all configuration is ready for loading\n     * @private\n     */\n\n  }, {\n    key: 'couldBeginLoading_',\n    value: function couldBeginLoading_() {\n      return this.playlist_ && (\n      // the source updater is created when init_ is called, so either having a\n      // source updater or being in the INIT state with a mimeType is enough\n      // to say we have all the needed configuration to start loading.\n      this.sourceUpdater_ || this.mimeType_ && this.state === 'INIT') && !this.paused();\n    }\n\n    /**\n     * load a playlist and start to fill the buffer\n     */\n\n  }, {\n    key: 'load',\n    value: function load() {\n      // un-pause\n      this.monitorBuffer_();\n\n      // if we don't have a playlist yet, keep waiting for one to be\n      // specified\n      if (!this.playlist_) {\n        return;\n      }\n\n      // not sure if this is the best place for this\n      this.syncController_.setDateTimeMapping(this.playlist_);\n\n      // if all the configuration is ready, initialize and begin loading\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        return this.init_();\n      }\n\n      // if we're in the middle of processing a segment already, don't\n      // kick off an additional segment request\n      if (!this.couldBeginLoading_() || this.state !== 'READY' && this.state !== 'INIT') {\n        return;\n      }\n\n      this.state = 'READY';\n    }\n\n    /**\n     * Once all the starting parameters have been specified, begin\n     * operation. This method should only be invoked from the INIT\n     * state.\n     *\n     * @private\n     */\n\n  }, {\n    key: 'init_',\n    value: function init_() {\n      this.state = 'READY';\n      this.sourceUpdater_ = new SourceUpdater(this.mediaSource_, this.mimeType_, this.loaderType_, this.sourceBufferEmitter_);\n      this.resetEverything();\n      return this.monitorBuffer_();\n    }\n\n    /**\n     * set a playlist on the segment loader\n     *\n     * @param {PlaylistLoader} media the playlist to set on the segment loader\n     */\n\n  }, {\n    key: 'playlist',\n    value: function playlist(newPlaylist) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!newPlaylist) {\n        return;\n      }\n\n      var oldPlaylist = this.playlist_;\n      var segmentInfo = this.pendingSegment_;\n\n      this.playlist_ = newPlaylist;\n      this.xhrOptions_ = options;\n\n      // when we haven't started playing yet, the start of a live playlist\n      // is always our zero-time so force a sync update each time the playlist\n      // is refreshed from the server\n      if (!this.hasPlayed_()) {\n        newPlaylist.syncInfo = {\n          mediaSequence: newPlaylist.mediaSequence,\n          time: 0\n        };\n      }\n\n      var oldId = oldPlaylist ? oldPlaylist.id : null;\n\n      this.logger_('playlist update [' + oldId + ' => ' + newPlaylist.id + ']');\n\n      // in VOD, this is always a rendition switch (or we updated our syncInfo above)\n      // in LIVE, we always want to update with new playlists (including refreshes)\n      this.trigger('syncinfoupdate');\n\n      // if we were unpaused but waiting for a playlist, start\n      // buffering now\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        return this.init_();\n      }\n\n      if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {\n        if (this.mediaIndex !== null) {\n          // we must \"resync\" the segment loader when we switch renditions and\n          // the segment loader is already synced to the previous rendition\n          this.resyncLoader();\n        }\n\n        // the rest of this function depends on `oldPlaylist` being defined\n        return;\n      }\n\n      // we reloaded the same playlist so we are in a live scenario\n      // and we will likely need to adjust the mediaIndex\n      var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;\n\n      this.logger_('live window shift [' + mediaSequenceDiff + ']');\n\n      // update the mediaIndex on the SegmentLoader\n      // this is important because we can abort a request and this value must be\n      // equal to the last appended mediaIndex\n      if (this.mediaIndex !== null) {\n        this.mediaIndex -= mediaSequenceDiff;\n      }\n\n      // update the mediaIndex on the SegmentInfo object\n      // this is important because we will update this.mediaIndex with this value\n      // in `handleUpdateEnd_` after the segment has been successfully appended\n      if (segmentInfo) {\n        segmentInfo.mediaIndex -= mediaSequenceDiff;\n\n        // we need to update the referenced segment so that timing information is\n        // saved for the new playlist's segment, however, if the segment fell off the\n        // playlist, we can leave the old reference and just lose the timing info\n        if (segmentInfo.mediaIndex >= 0) {\n          segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];\n        }\n      }\n\n      this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);\n    }\n\n    /**\n     * Prevent the loader from fetching additional segments. If there\n     * is a segment request outstanding, it will finish processing\n     * before the loader halts. A segment loader can be unpaused by\n     * calling load().\n     */\n\n  }, {\n    key: 'pause',\n    value: function pause() {\n      if (this.checkBufferTimeout_) {\n        global_window__WEBPACK_IMPORTED_MODULE_0___default.a.clearTimeout(this.checkBufferTimeout_);\n\n        this.checkBufferTimeout_ = null;\n      }\n    }\n\n    /**\n     * Returns whether the segment loader is fetching additional\n     * segments when given the opportunity. This property can be\n     * modified through calls to pause() and load().\n     */\n\n  }, {\n    key: 'paused',\n    value: function paused() {\n      return this.checkBufferTimeout_ === null;\n    }\n\n    /**\n     * create/set the following mimetype on the SourceBuffer through a\n     * SourceUpdater\n     *\n     * @param {String} mimeType the mime type string to use\n     * @param {Object} sourceBufferEmitter an event emitter that fires when a source buffer\n     * is added to the media source\n     */\n\n  }, {\n    key: 'mimeType',\n    value: function mimeType(_mimeType, sourceBufferEmitter) {\n      if (this.mimeType_) {\n        return;\n      }\n\n      this.mimeType_ = _mimeType;\n      this.sourceBufferEmitter_ = sourceBufferEmitter;\n      // if we were unpaused but waiting for a sourceUpdater, start\n      // buffering now\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        this.init_();\n      }\n    }\n\n    /**\n     * Delete all the buffered data and reset the SegmentLoader\n     */\n\n  }, {\n    key: 'resetEverything',\n    value: function resetEverything() {\n      this.ended_ = false;\n      this.resetLoader();\n      this.remove(0, this.duration_());\n      this.trigger('reseteverything');\n    }\n\n    /**\n     * Force the SegmentLoader to resync and start loading around the currentTime instead\n     * of starting at the end of the buffer\n     *\n     * Useful for fast quality changes\n     */\n\n  }, {\n    key: 'resetLoader',\n    value: function resetLoader() {\n      this.fetchAtBuffer_ = false;\n      this.resyncLoader();\n    }\n\n    /**\n     * Force the SegmentLoader to restart synchronization and make a conservative guess\n     * before returning to the simple walk-forward method\n     */\n\n  }, {\n    key: 'resyncLoader',\n    value: function resyncLoader() {\n      this.mediaIndex = null;\n      this.syncPoint_ = null;\n      this.abort();\n    }\n\n    /**\n     * Remove any data in the source buffer between start and end times\n     * @param {Number} start - the start time of the region to remove from the buffer\n     * @param {Number} end - the end time of the region to remove from the buffer\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      if (this.sourceUpdater_) {\n        this.sourceUpdater_.remove(start, end);\n      }\n      removeCuesFromTrack(start, end, this.segmentMetadataTrack_);\n    }\n\n    /**\n     * (re-)schedule monitorBufferTick_ to run as soon as possible\n     *\n     * @private\n     */\n\n  }, {\n    key: 'monitorBuffer_',\n    value: function monitorBuffer_() {\n      if (this.checkBufferTimeout_) {\n        global_window__WEBPACK_IMPORTED_MODULE_0___default.a.clearTimeout(this.checkBufferTimeout_);\n      }\n\n      this.checkBufferTimeout_ = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.setTimeout(this.monitorBufferTick_.bind(this), 1);\n    }\n\n    /**\n     * As long as the SegmentLoader is in the READY state, periodically\n     * invoke fillBuffer_().\n     *\n     * @private\n     */\n\n  }, {\n    key: 'monitorBufferTick_',\n    value: function monitorBufferTick_() {\n      if (this.state === 'READY') {\n        this.fillBuffer_();\n      }\n\n      if (this.checkBufferTimeout_) {\n        global_window__WEBPACK_IMPORTED_MODULE_0___default.a.clearTimeout(this.checkBufferTimeout_);\n      }\n\n      this.checkBufferTimeout_ = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);\n    }\n\n    /**\n     * fill the buffer with segements unless the sourceBuffers are\n     * currently updating\n     *\n     * Note: this function should only ever be called by monitorBuffer_\n     * and never directly\n     *\n     * @private\n     */\n\n  }, {\n    key: 'fillBuffer_',\n    value: function fillBuffer_() {\n      if (this.sourceUpdater_.updating()) {\n        return;\n      }\n\n      if (!this.syncPoint_) {\n        this.syncPoint_ = this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());\n      }\n\n      // see if we need to begin loading immediately\n      var segmentInfo = this.checkBuffer_(this.buffered_(), this.playlist_, this.mediaIndex, this.hasPlayed_(), this.currentTime_(), this.syncPoint_);\n\n      if (!segmentInfo) {\n        return;\n      }\n\n      var isEndOfStream = detectEndOfStream(this.playlist_, this.mediaSource_, segmentInfo.mediaIndex);\n\n      if (isEndOfStream) {\n        this.endOfStream();\n        return;\n      }\n\n      if (segmentInfo.mediaIndex === this.playlist_.segments.length - 1 && this.mediaSource_.readyState === 'ended' && !this.seeking_()) {\n        return;\n      }\n\n      // We will need to change timestampOffset of the sourceBuffer if either of\n      // the following conditions are true:\n      // - The segment.timeline !== this.currentTimeline\n      //   (we are crossing a discontinuity somehow)\n      // - The \"timestampOffset\" for the start of this segment is less than\n      //   the currently set timestampOffset\n      if (segmentInfo.timeline !== this.currentTimeline_ || segmentInfo.startOfSegment !== null && segmentInfo.startOfSegment < this.sourceUpdater_.timestampOffset()) {\n        this.syncController_.reset();\n        segmentInfo.timestampOffset = segmentInfo.startOfSegment;\n      }\n\n      this.loadSegment_(segmentInfo);\n    }\n\n    /**\n     * Determines what segment request should be made, given current playback\n     * state.\n     *\n     * @param {TimeRanges} buffered - the state of the buffer\n     * @param {Object} playlist - the playlist object to fetch segments from\n     * @param {Number} mediaIndex - the previous mediaIndex fetched or null\n     * @param {Boolean} hasPlayed - a flag indicating whether we have played or not\n     * @param {Number} currentTime - the playback position in seconds\n     * @param {Object} syncPoint - a segment info object that describes the\n     * @returns {Object} a segment request object that describes the segment to load\n     */\n\n  }, {\n    key: 'checkBuffer_',\n    value: function checkBuffer_(buffered, playlist, mediaIndex, hasPlayed, currentTime, syncPoint) {\n      var lastBufferedEnd = 0;\n      var startOfSegment = void 0;\n\n      if (buffered.length) {\n        lastBufferedEnd = buffered.end(buffered.length - 1);\n      }\n\n      var bufferedTime = Math.max(0, lastBufferedEnd - currentTime);\n\n      if (!playlist.segments.length) {\n        return null;\n      }\n\n      // if there is plenty of content buffered, and the video has\n      // been played before relax for awhile\n      if (bufferedTime >= this.goalBufferLength_()) {\n        return null;\n      }\n\n      // if the video has not yet played once, and we already have\n      // one segment downloaded do nothing\n      if (!hasPlayed && bufferedTime >= 1) {\n        return null;\n      }\n\n      // When the syncPoint is null, there is no way of determining a good\n      // conservative segment index to fetch from\n      // The best thing to do here is to get the kind of sync-point data by\n      // making a request\n      if (syncPoint === null) {\n        mediaIndex = this.getSyncSegmentCandidate_(playlist);\n        return this.generateSegmentInfo_(playlist, mediaIndex, null, true);\n      }\n\n      // Under normal playback conditions fetching is a simple walk forward\n      if (mediaIndex !== null) {\n        var segment = playlist.segments[mediaIndex];\n\n        if (segment && segment.end) {\n          startOfSegment = segment.end;\n        } else {\n          startOfSegment = lastBufferedEnd;\n        }\n        return this.generateSegmentInfo_(playlist, mediaIndex + 1, startOfSegment, false);\n      }\n\n      // There is a sync-point but the lack of a mediaIndex indicates that\n      // we need to make a good conservative guess about which segment to\n      // fetch\n      if (this.fetchAtBuffer_) {\n        // Find the segment containing the end of the buffer\n        var mediaSourceInfo = Playlist.getMediaInfoForTime(playlist, lastBufferedEnd, syncPoint.segmentIndex, syncPoint.time);\n\n        mediaIndex = mediaSourceInfo.mediaIndex;\n        startOfSegment = mediaSourceInfo.startTime;\n      } else {\n        // Find the segment containing currentTime\n        var _mediaSourceInfo = Playlist.getMediaInfoForTime(playlist, currentTime, syncPoint.segmentIndex, syncPoint.time);\n\n        mediaIndex = _mediaSourceInfo.mediaIndex;\n        startOfSegment = _mediaSourceInfo.startTime;\n      }\n\n      return this.generateSegmentInfo_(playlist, mediaIndex, startOfSegment, false);\n    }\n\n    /**\n     * The segment loader has no recourse except to fetch a segment in the\n     * current playlist and use the internal timestamps in that segment to\n     * generate a syncPoint. This function returns a good candidate index\n     * for that process.\n     *\n     * @param {Object} playlist - the playlist object to look for a\n     * @returns {Number} An index of a segment from the playlist to load\n     */\n\n  }, {\n    key: 'getSyncSegmentCandidate_',\n    value: function getSyncSegmentCandidate_(playlist) {\n      var _this2 = this;\n\n      if (this.currentTimeline_ === -1) {\n        return 0;\n      }\n\n      var segmentIndexArray = playlist.segments.map(function (s, i) {\n        return {\n          timeline: s.timeline,\n          segmentIndex: i\n        };\n      }).filter(function (s) {\n        return s.timeline === _this2.currentTimeline_;\n      });\n\n      if (segmentIndexArray.length) {\n        return segmentIndexArray[Math.min(segmentIndexArray.length - 1, 1)].segmentIndex;\n      }\n\n      return Math.max(playlist.segments.length - 1, 0);\n    }\n  }, {\n    key: 'generateSegmentInfo_',\n    value: function generateSegmentInfo_(playlist, mediaIndex, startOfSegment, isSyncRequest) {\n      if (mediaIndex < 0 || mediaIndex >= playlist.segments.length) {\n        return null;\n      }\n\n      var segment = playlist.segments[mediaIndex];\n\n      return {\n        requestId: 'segment-loader-' + Math.random(),\n        // resolve the segment URL relative to the playlist\n        uri: segment.resolvedUri,\n        // the segment's mediaIndex at the time it was requested\n        mediaIndex: mediaIndex,\n        // whether or not to update the SegmentLoader's state with this\n        // segment's mediaIndex\n        isSyncRequest: isSyncRequest,\n        startOfSegment: startOfSegment,\n        // the segment's playlist\n        playlist: playlist,\n        // unencrypted bytes of the segment\n        bytes: null,\n        // when a key is defined for this segment, the encrypted bytes\n        encryptedBytes: null,\n        // The target timestampOffset for this segment when we append it\n        // to the source buffer\n        timestampOffset: null,\n        // The timeline that the segment is in\n        timeline: segment.timeline,\n        // The expected duration of the segment in seconds\n        duration: segment.duration,\n        // retain the segment in case the playlist updates while doing an async process\n        segment: segment\n      };\n    }\n\n    /**\n     * Determines if the network has enough bandwidth to complete the current segment\n     * request in a timely manner. If not, the request will be aborted early and bandwidth\n     * updated to trigger a playlist switch.\n     *\n     * @param {Object} stats\n     *        Object containing stats about the request timing and size\n     * @return {Boolean} True if the request was aborted, false otherwise\n     * @private\n     */\n\n  }, {\n    key: 'abortRequestEarly_',\n    value: function abortRequestEarly_(stats) {\n      if (this.hls_.tech_.paused() ||\n      // Don't abort if the current playlist is on the lowestEnabledRendition\n      // TODO: Replace using timeout with a boolean indicating whether this playlist is\n      //       the lowestEnabledRendition.\n      !this.xhrOptions_.timeout ||\n      // Don't abort if we have no bandwidth information to estimate segment sizes\n      !this.playlist_.attributes.BANDWIDTH) {\n        return false;\n      }\n\n      // Wait at least 1 second since the first byte of data has been received before\n      // using the calculated bandwidth from the progress event to allow the bitrate\n      // to stabilize\n      if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1000) {\n        return false;\n      }\n\n      var currentTime = this.currentTime_();\n      var measuredBandwidth = stats.bandwidth;\n      var segmentDuration = this.pendingSegment_.duration;\n\n      var requestTimeRemaining = Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived);\n\n      // Subtract 1 from the timeUntilRebuffer so we still consider an early abort\n      // if we are only left with less than 1 second when the request completes.\n      // A negative timeUntilRebuffering indicates we are already rebuffering\n      var timeUntilRebuffer$$1 = timeUntilRebuffer(this.buffered_(), currentTime, this.hls_.tech_.playbackRate()) - 1;\n\n      // Only consider aborting early if the estimated time to finish the download\n      // is larger than the estimated time until the player runs out of forward buffer\n      if (requestTimeRemaining <= timeUntilRebuffer$$1) {\n        return false;\n      }\n\n      var switchCandidate = minRebufferMaxBandwidthSelector({\n        master: this.hls_.playlists.master,\n        currentTime: currentTime,\n        bandwidth: measuredBandwidth,\n        duration: this.duration_(),\n        segmentDuration: segmentDuration,\n        timeUntilRebuffer: timeUntilRebuffer$$1,\n        currentTimeline: this.currentTimeline_,\n        syncController: this.syncController_\n      });\n\n      if (!switchCandidate) {\n        return;\n      }\n\n      var rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$$1;\n\n      var timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;\n\n      var minimumTimeSaving = 0.5;\n\n      // If we are already rebuffering, increase the amount of variance we add to the\n      // potential round trip time of the new request so that we are not too aggressive\n      // with switching to a playlist that might save us a fraction of a second.\n      if (timeUntilRebuffer$$1 <= TIME_FUDGE_FACTOR) {\n        minimumTimeSaving = 1;\n      }\n\n      if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {\n        return false;\n      }\n\n      // set the bandwidth to that of the desired playlist being sure to scale by\n      // BANDWIDTH_VARIANCE and add one so the playlist selector does not exclude it\n      // don't trigger a bandwidthupdate as the bandwidth is artifial\n      this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1;\n      this.abort();\n      this.trigger('earlyabort');\n      return true;\n    }\n\n    /**\n     * XHR `progress` event handler\n     *\n     * @param {Event}\n     *        The XHR `progress` event\n     * @param {Object} simpleSegment\n     *        A simplified segment object copy\n     * @private\n     */\n\n  }, {\n    key: 'handleProgress_',\n    value: function handleProgress_(event, simpleSegment) {\n      if (!this.pendingSegment_ || simpleSegment.requestId !== this.pendingSegment_.requestId || this.abortRequestEarly_(simpleSegment.stats)) {\n        return;\n      }\n\n      this.trigger('progress');\n    }\n\n    /**\n     * load a specific segment from a request into the buffer\n     *\n     * @private\n     */\n\n  }, {\n    key: 'loadSegment_',\n    value: function loadSegment_(segmentInfo) {\n      this.state = 'WAITING';\n      this.pendingSegment_ = segmentInfo;\n      this.trimBackBuffer_(segmentInfo);\n\n      segmentInfo.abortRequests = mediaSegmentRequest(this.hls_.xhr, this.xhrOptions_, this.decrypter_, this.createSimplifiedSegmentObj_(segmentInfo),\n      // progress callback\n      this.handleProgress_.bind(this), this.segmentRequestFinished_.bind(this));\n    }\n\n    /**\n     * trim the back buffer so that we don't have too much data\n     * in the source buffer\n     *\n     * @private\n     *\n     * @param {Object} segmentInfo - the current segment\n     */\n\n  }, {\n    key: 'trimBackBuffer_',\n    value: function trimBackBuffer_(segmentInfo) {\n      var removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);\n\n      // Chrome has a hard limit of 150MB of\n      // buffer and a very conservative \"garbage collector\"\n      // We manually clear out the old buffer to ensure\n      // we don't trigger the QuotaExceeded error\n      // on the source buffer during subsequent appends\n\n      if (removeToTime > 0) {\n        this.remove(0, removeToTime);\n      }\n    }\n\n    /**\n     * created a simplified copy of the segment object with just the\n     * information necessary to perform the XHR and decryption\n     *\n     * @private\n     *\n     * @param {Object} segmentInfo - the current segment\n     * @returns {Object} a simplified segment object copy\n     */\n\n  }, {\n    key: 'createSimplifiedSegmentObj_',\n    value: function createSimplifiedSegmentObj_(segmentInfo) {\n      var segment = segmentInfo.segment;\n      var simpleSegment = {\n        resolvedUri: segment.resolvedUri,\n        byterange: segment.byterange,\n        requestId: segmentInfo.requestId\n      };\n\n      if (segment.key) {\n        // if the media sequence is greater than 2^32, the IV will be incorrect\n        // assuming 10s segments, that would be about 1300 years\n        var iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);\n\n        simpleSegment.key = {\n          resolvedUri: segment.key.resolvedUri,\n          iv: iv\n        };\n      }\n\n      if (segment.map) {\n        simpleSegment.map = this.initSegment(segment.map);\n      }\n\n      return simpleSegment;\n    }\n\n    /**\n     * Handle the callback from the segmentRequest function and set the\n     * associated SegmentLoader state and errors if necessary\n     *\n     * @private\n     */\n\n  }, {\n    key: 'segmentRequestFinished_',\n    value: function segmentRequestFinished_(error, simpleSegment) {\n      // every request counts as a media request even if it has been aborted\n      // or canceled due to a timeout\n      this.mediaRequests += 1;\n\n      if (simpleSegment.stats) {\n        this.mediaBytesTransferred += simpleSegment.stats.bytesReceived;\n        this.mediaTransferDuration += simpleSegment.stats.roundTripTime;\n      }\n\n      // The request was aborted and the SegmentLoader has already been reset\n      if (!this.pendingSegment_) {\n        this.mediaRequestsAborted += 1;\n        return;\n      }\n\n      // the request was aborted and the SegmentLoader has already started\n      // another request. this can happen when the timeout for an aborted\n      // request triggers due to a limitation in the XHR library\n      // do not count this as any sort of request or we risk double-counting\n      if (simpleSegment.requestId !== this.pendingSegment_.requestId) {\n        return;\n      }\n\n      // an error occurred from the active pendingSegment_ so reset everything\n      if (error) {\n        this.pendingSegment_ = null;\n        this.state = 'READY';\n\n        // the requests were aborted just record the aborted stat and exit\n        // this is not a true error condition and nothing corrective needs\n        // to be done\n        if (error.code === REQUEST_ERRORS.ABORTED) {\n          this.mediaRequestsAborted += 1;\n          return;\n        }\n\n        this.pause();\n\n        // the error is really just that at least one of the requests timed-out\n        // set the bandwidth to a very low value and trigger an ABR switch to\n        // take emergency action\n        if (error.code === REQUEST_ERRORS.TIMEOUT) {\n          this.mediaRequestsTimedout += 1;\n          this.bandwidth = 1;\n          this.roundTrip = NaN;\n          this.trigger('bandwidthupdate');\n          return;\n        }\n\n        // if control-flow has arrived here, then the error is real\n        // emit an error event to blacklist the current playlist\n        this.mediaRequestsErrored += 1;\n        this.error(error);\n        this.trigger('error');\n        return;\n      }\n\n      // the response was a success so set any bandwidth stats the request\n      // generated for ABR purposes\n      this.bandwidth = simpleSegment.stats.bandwidth;\n      this.roundTrip = simpleSegment.stats.roundTripTime;\n\n      // if this request included an initialization segment, save that data\n      // to the initSegment cache\n      if (simpleSegment.map) {\n        simpleSegment.map = this.initSegment(simpleSegment.map, true);\n      }\n\n      this.processSegmentResponse_(simpleSegment);\n    }\n\n    /**\n     * Move any important data from the simplified segment object\n     * back to the real segment object for future phases\n     *\n     * @private\n     */\n\n  }, {\n    key: 'processSegmentResponse_',\n    value: function processSegmentResponse_(simpleSegment) {\n      var segmentInfo = this.pendingSegment_;\n\n      segmentInfo.bytes = simpleSegment.bytes;\n      if (simpleSegment.map) {\n        segmentInfo.segment.map.bytes = simpleSegment.map.bytes;\n      }\n\n      segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;\n      this.handleSegment_();\n    }\n\n    /**\n     * append a decrypted segement to the SourceBuffer through a SourceUpdater\n     *\n     * @private\n     */\n\n  }, {\n    key: 'handleSegment_',\n    value: function handleSegment_() {\n      var _this3 = this;\n\n      if (!this.pendingSegment_) {\n        this.state = 'READY';\n        return;\n      }\n\n      var segmentInfo = this.pendingSegment_;\n      var segment = segmentInfo.segment;\n      var timingInfo = this.syncController_.probeSegmentInfo(segmentInfo);\n\n      // When we have our first timing info, determine what media types this loader is\n      // dealing with. Although we're maintaining extra state, it helps to preserve the\n      // separation of segment loader from the actual source buffers.\n      if (typeof this.startingMedia_ === 'undefined' && timingInfo && (\n      // Guard against cases where we're not getting timing info at all until we are\n      // certain that all streams will provide it.\n      timingInfo.containsAudio || timingInfo.containsVideo)) {\n        this.startingMedia_ = {\n          containsAudio: timingInfo.containsAudio,\n          containsVideo: timingInfo.containsVideo\n        };\n      }\n\n      var illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.startingMedia_, timingInfo);\n\n      if (illegalMediaSwitchError) {\n        this.error({\n          message: illegalMediaSwitchError,\n          blacklistDuration: Infinity\n        });\n        this.trigger('error');\n        return;\n      }\n\n      if (segmentInfo.isSyncRequest) {\n        this.trigger('syncinfoupdate');\n        this.pendingSegment_ = null;\n        this.state = 'READY';\n        return;\n      }\n\n      if (segmentInfo.timestampOffset !== null && segmentInfo.timestampOffset !== this.sourceUpdater_.timestampOffset()) {\n        this.sourceUpdater_.timestampOffset(segmentInfo.timestampOffset);\n        // fired when a timestamp offset is set in HLS (can also identify discontinuities)\n        this.trigger('timestampoffset');\n      }\n\n      var timelineMapping = this.syncController_.mappingForTimeline(segmentInfo.timeline);\n\n      if (timelineMapping !== null) {\n        this.trigger({\n          type: 'segmenttimemapping',\n          mapping: timelineMapping\n        });\n      }\n\n      this.state = 'APPENDING';\n\n      // if the media initialization segment is changing, append it\n      // before the content segment\n      if (segment.map) {\n        var initId = initSegmentId(segment.map);\n\n        if (!this.activeInitSegmentId_ || this.activeInitSegmentId_ !== initId) {\n          var initSegment = this.initSegment(segment.map);\n\n          this.sourceUpdater_.appendBuffer(initSegment.bytes, function () {\n            _this3.activeInitSegmentId_ = initId;\n          });\n        }\n      }\n\n      segmentInfo.byteLength = segmentInfo.bytes.byteLength;\n      if (typeof segment.start === 'number' && typeof segment.end === 'number') {\n        this.mediaSecondsLoaded += segment.end - segment.start;\n      } else {\n        this.mediaSecondsLoaded += segment.duration;\n      }\n\n      this.logger_(segmentInfoString(segmentInfo));\n\n      this.sourceUpdater_.appendBuffer(segmentInfo.bytes, this.handleUpdateEnd_.bind(this));\n    }\n\n    /**\n     * callback to run when appendBuffer is finished. detects if we are\n     * in a good state to do things with the data we got, or if we need\n     * to wait for more\n     *\n     * @private\n     */\n\n  }, {\n    key: 'handleUpdateEnd_',\n    value: function handleUpdateEnd_() {\n      if (!this.pendingSegment_) {\n        this.state = 'READY';\n        if (!this.paused()) {\n          this.monitorBuffer_();\n        }\n        return;\n      }\n\n      var segmentInfo = this.pendingSegment_;\n      var segment = segmentInfo.segment;\n      var isWalkingForward = this.mediaIndex !== null;\n\n      this.pendingSegment_ = null;\n      this.recordThroughput_(segmentInfo);\n      this.addSegmentMetadataCue_(segmentInfo);\n\n      this.state = 'READY';\n\n      this.mediaIndex = segmentInfo.mediaIndex;\n      this.fetchAtBuffer_ = true;\n      this.currentTimeline_ = segmentInfo.timeline;\n\n      // We must update the syncinfo to recalculate the seekable range before\n      // the following conditional otherwise it may consider this a bad \"guess\"\n      // and attempt to resync when the post-update seekable window and live\n      // point would mean that this was the perfect segment to fetch\n      this.trigger('syncinfoupdate');\n\n      // If we previously appended a segment that ends more than 3 targetDurations before\n      // the currentTime_ that means that our conservative guess was too conservative.\n      // In that case, reset the loader state so that we try to use any information gained\n      // from the previous request to create a new, more accurate, sync-point.\n      if (segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3) {\n        this.resetEverything();\n        return;\n      }\n\n      // Don't do a rendition switch unless we have enough time to get a sync segment\n      // and conservatively guess\n      if (isWalkingForward) {\n        this.trigger('bandwidthupdate');\n      }\n      this.trigger('progress');\n\n      // any time an update finishes and the last segment is in the\n      // buffer, end the stream. this ensures the \"ended\" event will\n      // fire if playback reaches that point.\n      var isEndOfStream = detectEndOfStream(segmentInfo.playlist, this.mediaSource_, segmentInfo.mediaIndex + 1);\n\n      if (isEndOfStream) {\n        this.endOfStream();\n      }\n\n      if (!this.paused()) {\n        this.monitorBuffer_();\n      }\n    }\n\n    /**\n     * Records the current throughput of the decrypt, transmux, and append\n     * portion of the semgment pipeline. `throughput.rate` is a the cumulative\n     * moving average of the throughput. `throughput.count` is the number of\n     * data points in the average.\n     *\n     * @private\n     * @param {Object} segmentInfo the object returned by loadSegment\n     */\n\n  }, {\n    key: 'recordThroughput_',\n    value: function recordThroughput_(segmentInfo) {\n      var rate = this.throughput.rate;\n      // Add one to the time to ensure that we don't accidentally attempt to divide\n      // by zero in the case where the throughput is ridiculously high\n      var segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1;\n      // Multiply by 8000 to convert from bytes/millisecond to bits/second\n      var segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1000);\n\n      // This is just a cumulative moving average calculation:\n      //   newAvg = oldAvg + (sample - oldAvg) / (sampleCount + 1)\n      this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;\n    }\n\n    /**\n     * Adds a cue to the segment-metadata track with some metadata information about the\n     * segment\n     *\n     * @private\n     * @param {Object} segmentInfo\n     *        the object returned by loadSegment\n     * @method addSegmentMetadataCue_\n     */\n\n  }, {\n    key: 'addSegmentMetadataCue_',\n    value: function addSegmentMetadataCue_(segmentInfo) {\n      if (!this.segmentMetadataTrack_) {\n        return;\n      }\n\n      var segment = segmentInfo.segment;\n      var start = segment.start;\n      var end = segment.end;\n\n      // Do not try adding the cue if the start and end times are invalid.\n      if (!finite(start) || !finite(end)) {\n        return;\n      }\n\n      removeCuesFromTrack(start, end, this.segmentMetadataTrack_);\n\n      var Cue = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.WebKitDataCue || global_window__WEBPACK_IMPORTED_MODULE_0___default.a.VTTCue;\n      var value = {\n        bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,\n        resolution: segmentInfo.playlist.attributes.RESOLUTION,\n        codecs: segmentInfo.playlist.attributes.CODECS,\n        byteLength: segmentInfo.byteLength,\n        uri: segmentInfo.uri,\n        timeline: segmentInfo.timeline,\n        playlist: segmentInfo.playlist.uri,\n        start: start,\n        end: end\n      };\n      var data = JSON.stringify(value);\n      var cue = new Cue(start, end, data);\n\n      // Attach the metadata to the value property of the cue to keep consistency between\n      // the differences of WebKitDataCue in safari and VTTCue in other browsers\n      cue.value = value;\n\n      this.segmentMetadataTrack_.addCue(cue);\n    }\n  }]);\n  return SegmentLoader;\n}(videojs$1.EventTarget);\n\n/**\n * @file vtt-segment-loader.js\n */\n\nvar VTT_LINE_TERMINATORS = new Uint8Array('\\n\\n'.split('').map(function (char) {\n  return char.charCodeAt(0);\n}));\n\nvar uintToString = function uintToString(uintArray) {\n  return String.fromCharCode.apply(null, uintArray);\n};\n\n/**\n * An object that manages segment loading and appending.\n *\n * @class VTTSegmentLoader\n * @param {Object} options required and optional options\n * @extends videojs.EventTarget\n */\n\nvar VTTSegmentLoader = function (_SegmentLoader) {\n  inherits$1(VTTSegmentLoader, _SegmentLoader);\n\n  function VTTSegmentLoader(settings) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck$1(this, VTTSegmentLoader);\n\n    // SegmentLoader requires a MediaSource be specified or it will throw an error;\n    // however, VTTSegmentLoader has no need of a media source, so delete the reference\n    var _this = possibleConstructorReturn$1(this, (VTTSegmentLoader.__proto__ || Object.getPrototypeOf(VTTSegmentLoader)).call(this, settings, options));\n\n    _this.mediaSource_ = null;\n\n    _this.subtitlesTrack_ = null;\n    return _this;\n  }\n\n  /**\n   * Indicates which time ranges are buffered\n   *\n   * @return {TimeRange}\n   *         TimeRange object representing the current buffered ranges\n   */\n\n  createClass$1(VTTSegmentLoader, [{\n    key: 'buffered_',\n    value: function buffered_() {\n      if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues.length) {\n        return videojs$1.createTimeRanges();\n      }\n\n      var cues = this.subtitlesTrack_.cues;\n      var start = cues[0].startTime;\n      var end = cues[cues.length - 1].startTime;\n\n      return videojs$1.createTimeRanges([[start, end]]);\n    }\n\n    /**\n     * Gets and sets init segment for the provided map\n     *\n     * @param {Object} map\n     *        The map object representing the init segment to get or set\n     * @param {Boolean=} set\n     *        If true, the init segment for the provided map should be saved\n     * @return {Object}\n     *         map object for desired init segment\n     */\n\n  }, {\n    key: 'initSegment',\n    value: function initSegment(map) {\n      var set$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!map) {\n        return null;\n      }\n\n      var id = initSegmentId(map);\n      var storedMap = this.initSegments_[id];\n\n      if (set$$1 && !storedMap && map.bytes) {\n        // append WebVTT line terminators to the media initialization segment if it exists\n        // to follow the WebVTT spec (https://w3c.github.io/webvtt/#file-structure) that\n        // requires two or more WebVTT line terminators between the WebVTT header and the\n        // rest of the file\n        var combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;\n        var combinedSegment = new Uint8Array(combinedByteLength);\n\n        combinedSegment.set(map.bytes);\n        combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);\n\n        this.initSegments_[id] = storedMap = {\n          resolvedUri: map.resolvedUri,\n          byterange: map.byterange,\n          bytes: combinedSegment\n        };\n      }\n\n      return storedMap || map;\n    }\n\n    /**\n     * Returns true if all configuration required for loading is present, otherwise false.\n     *\n     * @return {Boolean} True if the all configuration is ready for loading\n     * @private\n     */\n\n  }, {\n    key: 'couldBeginLoading_',\n    value: function couldBeginLoading_() {\n      return this.playlist_ && this.subtitlesTrack_ && !this.paused();\n    }\n\n    /**\n     * Once all the starting parameters have been specified, begin\n     * operation. This method should only be invoked from the INIT\n     * state.\n     *\n     * @private\n     */\n\n  }, {\n    key: 'init_',\n    value: function init_() {\n      this.state = 'READY';\n      this.resetEverything();\n      return this.monitorBuffer_();\n    }\n\n    /**\n     * Set a subtitle track on the segment loader to add subtitles to\n     *\n     * @param {TextTrack=} track\n     *        The text track to add loaded subtitles to\n     * @return {TextTrack}\n     *        Returns the subtitles track\n     */\n\n  }, {\n    key: 'track',\n    value: function track(_track) {\n      if (typeof _track === 'undefined') {\n        return this.subtitlesTrack_;\n      }\n\n      this.subtitlesTrack_ = _track;\n\n      // if we were unpaused but waiting for a sourceUpdater, start\n      // buffering now\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        this.init_();\n      }\n\n      return this.subtitlesTrack_;\n    }\n\n    /**\n     * Remove any data in the source buffer between start and end times\n     * @param {Number} start - the start time of the region to remove from the buffer\n     * @param {Number} end - the end time of the region to remove from the buffer\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      removeCuesFromTrack(start, end, this.subtitlesTrack_);\n    }\n\n    /**\n     * fill the buffer with segements unless the sourceBuffers are\n     * currently updating\n     *\n     * Note: this function should only ever be called by monitorBuffer_\n     * and never directly\n     *\n     * @private\n     */\n\n  }, {\n    key: 'fillBuffer_',\n    value: function fillBuffer_() {\n      var _this2 = this;\n\n      if (!this.syncPoint_) {\n        this.syncPoint_ = this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());\n      }\n\n      // see if we need to begin loading immediately\n      var segmentInfo = this.checkBuffer_(this.buffered_(), this.playlist_, this.mediaIndex, this.hasPlayed_(), this.currentTime_(), this.syncPoint_);\n\n      segmentInfo = this.skipEmptySegments_(segmentInfo);\n\n      if (!segmentInfo) {\n        return;\n      }\n\n      if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {\n        // We don't have the timestamp offset that we need to sync subtitles.\n        // Rerun on a timestamp offset or user interaction.\n        var checkTimestampOffset = function checkTimestampOffset() {\n          _this2.state = 'READY';\n          if (!_this2.paused()) {\n            // if not paused, queue a buffer check as soon as possible\n            _this2.monitorBuffer_();\n          }\n        };\n\n        this.syncController_.one('timestampoffset', checkTimestampOffset);\n        this.state = 'WAITING_ON_TIMELINE';\n        return;\n      }\n\n      this.loadSegment_(segmentInfo);\n    }\n\n    /**\n     * Prevents the segment loader from requesting segments we know contain no subtitles\n     * by walking forward until we find the next segment that we don't know whether it is\n     * empty or not.\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @return {Object}\n     *         a segment info object that describes the current segment\n     */\n\n  }, {\n    key: 'skipEmptySegments_',\n    value: function skipEmptySegments_(segmentInfo) {\n      while (segmentInfo && segmentInfo.segment.empty) {\n        segmentInfo = this.generateSegmentInfo_(segmentInfo.playlist, segmentInfo.mediaIndex + 1, segmentInfo.startOfSegment + segmentInfo.duration, segmentInfo.isSyncRequest);\n      }\n      return segmentInfo;\n    }\n\n    /**\n     * append a decrypted segement to the SourceBuffer through a SourceUpdater\n     *\n     * @private\n     */\n\n  }, {\n    key: 'handleSegment_',\n    value: function handleSegment_() {\n      var _this3 = this;\n\n      if (!this.pendingSegment_ || !this.subtitlesTrack_) {\n        this.state = 'READY';\n        return;\n      }\n\n      this.state = 'APPENDING';\n\n      var segmentInfo = this.pendingSegment_;\n      var segment = segmentInfo.segment;\n\n      // Make sure that vttjs has loaded, otherwise, wait till it finished loading\n      if (typeof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.WebVTT !== 'function' && this.subtitlesTrack_ && this.subtitlesTrack_.tech_) {\n\n        var loadHandler = function loadHandler() {\n          _this3.handleSegment_();\n        };\n\n        this.state = 'WAITING_ON_VTTJS';\n        this.subtitlesTrack_.tech_.one('vttjsloaded', loadHandler);\n        this.subtitlesTrack_.tech_.one('vttjserror', function () {\n          _this3.subtitlesTrack_.tech_.off('vttjsloaded', loadHandler);\n          _this3.error({\n            message: 'Error loading vtt.js'\n          });\n          _this3.state = 'READY';\n          _this3.pause();\n          _this3.trigger('error');\n        });\n\n        return;\n      }\n\n      segment.requested = true;\n\n      try {\n        this.parseVTTCues_(segmentInfo);\n      } catch (e) {\n        this.error({\n          message: e.message\n        });\n        this.state = 'READY';\n        this.pause();\n        return this.trigger('error');\n      }\n\n      this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);\n\n      if (segmentInfo.isSyncRequest) {\n        this.trigger('syncinfoupdate');\n        this.pendingSegment_ = null;\n        this.state = 'READY';\n        return;\n      }\n\n      segmentInfo.byteLength = segmentInfo.bytes.byteLength;\n\n      this.mediaSecondsLoaded += segment.duration;\n\n      if (segmentInfo.cues.length) {\n        // remove any overlapping cues to prevent doubling\n        this.remove(segmentInfo.cues[0].endTime, segmentInfo.cues[segmentInfo.cues.length - 1].endTime);\n      }\n\n      segmentInfo.cues.forEach(function (cue) {\n        _this3.subtitlesTrack_.addCue(cue);\n      });\n\n      this.handleUpdateEnd_();\n    }\n\n    /**\n     * Uses the WebVTT parser to parse the segment response\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @private\n     */\n\n  }, {\n    key: 'parseVTTCues_',\n    value: function parseVTTCues_(segmentInfo) {\n      var decoder = void 0;\n      var decodeBytesToString = false;\n\n      if (typeof global_window__WEBPACK_IMPORTED_MODULE_0___default.a.TextDecoder === 'function') {\n        decoder = new global_window__WEBPACK_IMPORTED_MODULE_0___default.a.TextDecoder('utf8');\n      } else {\n        decoder = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.WebVTT.StringDecoder();\n        decodeBytesToString = true;\n      }\n\n      var parser = new global_window__WEBPACK_IMPORTED_MODULE_0___default.a.WebVTT.Parser(global_window__WEBPACK_IMPORTED_MODULE_0___default.a, global_window__WEBPACK_IMPORTED_MODULE_0___default.a.vttjs, decoder);\n\n      segmentInfo.cues = [];\n      segmentInfo.timestampmap = { MPEGTS: 0, LOCAL: 0 };\n\n      parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);\n      parser.ontimestampmap = function (map) {\n        return segmentInfo.timestampmap = map;\n      };\n      parser.onparsingerror = function (error) {\n        videojs$1.log.warn('Error encountered when parsing cues: ' + error.message);\n      };\n\n      if (segmentInfo.segment.map) {\n        var mapData = segmentInfo.segment.map.bytes;\n\n        if (decodeBytesToString) {\n          mapData = uintToString(mapData);\n        }\n\n        parser.parse(mapData);\n      }\n\n      var segmentData = segmentInfo.bytes;\n\n      if (decodeBytesToString) {\n        segmentData = uintToString(segmentData);\n      }\n\n      parser.parse(segmentData);\n      parser.flush();\n    }\n\n    /**\n     * Updates the start and end times of any cues parsed by the WebVTT parser using\n     * the information parsed from the X-TIMESTAMP-MAP header and a TS to media time mapping\n     * from the SyncController\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @param {Object} mappingObj\n     *        object containing a mapping from TS to media time\n     * @param {Object} playlist\n     *        the playlist object containing the segment\n     * @private\n     */\n\n  }, {\n    key: 'updateTimeMapping_',\n    value: function updateTimeMapping_(segmentInfo, mappingObj, playlist) {\n      var segment = segmentInfo.segment;\n\n      if (!mappingObj) {\n        // If the sync controller does not have a mapping of TS to Media Time for the\n        // timeline, then we don't have enough information to update the cue\n        // start/end times\n        return;\n      }\n\n      if (!segmentInfo.cues.length) {\n        // If there are no cues, we also do not have enough information to figure out\n        // segment timing. Mark that the segment contains no cues so we don't re-request\n        // an empty segment.\n        segment.empty = true;\n        return;\n      }\n\n      var timestampmap = segmentInfo.timestampmap;\n      var diff = timestampmap.MPEGTS / 90000 - timestampmap.LOCAL + mappingObj.mapping;\n\n      segmentInfo.cues.forEach(function (cue) {\n        // First convert cue time to TS time using the timestamp-map provided within the vtt\n        cue.startTime += diff;\n        cue.endTime += diff;\n      });\n\n      if (!playlist.syncInfo) {\n        var firstStart = segmentInfo.cues[0].startTime;\n        var lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;\n\n        playlist.syncInfo = {\n          mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,\n          time: Math.min(firstStart, lastStart - segment.duration)\n        };\n      }\n    }\n  }]);\n  return VTTSegmentLoader;\n}(SegmentLoader);\n\n/**\n * @file ad-cue-tags.js\n */\n\n/**\n * Searches for an ad cue that overlaps with the given mediaTime\n */\nvar findAdCue = function findAdCue(track, mediaTime) {\n  var cues = track.cues;\n\n  for (var i = 0; i < cues.length; i++) {\n    var cue = cues[i];\n\n    if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {\n      return cue;\n    }\n  }\n  return null;\n};\n\nvar updateAdCues = function updateAdCues(media, track) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  if (!media.segments) {\n    return;\n  }\n\n  var mediaTime = offset;\n  var cue = void 0;\n\n  for (var i = 0; i < media.segments.length; i++) {\n    var segment = media.segments[i];\n\n    if (!cue) {\n      // Since the cues will span for at least the segment duration, adding a fudge\n      // factor of half segment duration will prevent duplicate cues from being\n      // created when timing info is not exact (e.g. cue start time initialized\n      // at 10.006677, but next call mediaTime is 10.003332 )\n      cue = findAdCue(track, mediaTime + segment.duration / 2);\n    }\n\n    if (cue) {\n      if ('cueIn' in segment) {\n        // Found a CUE-IN so end the cue\n        cue.endTime = mediaTime;\n        cue.adEndTime = mediaTime;\n        mediaTime += segment.duration;\n        cue = null;\n        continue;\n      }\n\n      if (mediaTime < cue.endTime) {\n        // Already processed this mediaTime for this cue\n        mediaTime += segment.duration;\n        continue;\n      }\n\n      // otherwise extend cue until a CUE-IN is found\n      cue.endTime += segment.duration;\n    } else {\n      if ('cueOut' in segment) {\n        cue = new global_window__WEBPACK_IMPORTED_MODULE_0___default.a.VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);\n        cue.adStartTime = mediaTime;\n        // Assumes tag format to be\n        // #EXT-X-CUE-OUT:30\n        cue.adEndTime = mediaTime + parseFloat(segment.cueOut);\n        track.addCue(cue);\n      }\n\n      if ('cueOutCont' in segment) {\n        // Entered into the middle of an ad cue\n        var adOffset = void 0;\n        var adTotal = void 0;\n\n        // Assumes tag formate to be\n        // #EXT-X-CUE-OUT-CONT:10/30\n\n        var _segment$cueOutCont$s = segment.cueOutCont.split('/').map(parseFloat);\n\n        var _segment$cueOutCont$s2 = slicedToArray$1(_segment$cueOutCont$s, 2);\n\n        adOffset = _segment$cueOutCont$s2[0];\n        adTotal = _segment$cueOutCont$s2[1];\n\n        cue = new global_window__WEBPACK_IMPORTED_MODULE_0___default.a.VTTCue(mediaTime, mediaTime + segment.duration, '');\n        cue.adStartTime = mediaTime - adOffset;\n        cue.adEndTime = cue.adStartTime + adTotal;\n        track.addCue(cue);\n      }\n    }\n    mediaTime += segment.duration;\n  }\n};\n\n/**\n * @file sync-controller.js\n */\n\nvar tsprobe = mux_js_lib_tools_ts_inspector_js__WEBPACK_IMPORTED_MODULE_10___default.a.inspect;\n\nvar syncPointStrategies = [\n// Stategy \"VOD\": Handle the VOD-case where the sync-point is *always*\n//                the equivalence display-time 0 === segment-index 0\n{\n  name: 'VOD',\n  run: function run(syncController, playlist, duration$$1, currentTimeline, currentTime) {\n    if (duration$$1 !== Infinity) {\n      var syncPoint = {\n        time: 0,\n        segmentIndex: 0\n      };\n\n      return syncPoint;\n    }\n    return null;\n  }\n},\n// Stategy \"ProgramDateTime\": We have a program-date-time tag in this playlist\n{\n  name: 'ProgramDateTime',\n  run: function run(syncController, playlist, duration$$1, currentTimeline, currentTime) {\n    if (!syncController.datetimeToDisplayTime) {\n      return null;\n    }\n\n    var segments = playlist.segments || [];\n    var syncPoint = null;\n    var lastDistance = null;\n\n    currentTime = currentTime || 0;\n\n    for (var i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n\n      if (segment.dateTimeObject) {\n        var segmentTime = segment.dateTimeObject.getTime() / 1000;\n        var segmentStart = segmentTime + syncController.datetimeToDisplayTime;\n        var distance = Math.abs(currentTime - segmentStart);\n\n        // Once the distance begins to increase, we have passed\n        // currentTime and can stop looking for better candidates\n        if (lastDistance !== null && lastDistance < distance) {\n          break;\n        }\n\n        lastDistance = distance;\n        syncPoint = {\n          time: segmentStart,\n          segmentIndex: i\n        };\n      }\n    }\n    return syncPoint;\n  }\n},\n// Stategy \"Segment\": We have a known time mapping for a timeline and a\n//                    segment in the current timeline with timing data\n{\n  name: 'Segment',\n  run: function run(syncController, playlist, duration$$1, currentTimeline, currentTime) {\n    var segments = playlist.segments || [];\n    var syncPoint = null;\n    var lastDistance = null;\n\n    currentTime = currentTime || 0;\n\n    for (var i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n\n      if (segment.timeline === currentTimeline && typeof segment.start !== 'undefined') {\n        var distance = Math.abs(currentTime - segment.start);\n\n        // Once the distance begins to increase, we have passed\n        // currentTime and can stop looking for better candidates\n        if (lastDistance !== null && lastDistance < distance) {\n          break;\n        }\n\n        if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n          lastDistance = distance;\n          syncPoint = {\n            time: segment.start,\n            segmentIndex: i\n          };\n        }\n      }\n    }\n    return syncPoint;\n  }\n},\n// Stategy \"Discontinuity\": We have a discontinuity with a known\n//                          display-time\n{\n  name: 'Discontinuity',\n  run: function run(syncController, playlist, duration$$1, currentTimeline, currentTime) {\n    var syncPoint = null;\n\n    currentTime = currentTime || 0;\n\n    if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\n      var lastDistance = null;\n\n      for (var i = 0; i < playlist.discontinuityStarts.length; i++) {\n        var segmentIndex = playlist.discontinuityStarts[i];\n        var discontinuity = playlist.discontinuitySequence + i + 1;\n        var discontinuitySync = syncController.discontinuities[discontinuity];\n\n        if (discontinuitySync) {\n          var distance = Math.abs(currentTime - discontinuitySync.time);\n\n          // Once the distance begins to increase, we have passed\n          // currentTime and can stop looking for better candidates\n          if (lastDistance !== null && lastDistance < distance) {\n            break;\n          }\n\n          if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n            lastDistance = distance;\n            syncPoint = {\n              time: discontinuitySync.time,\n              segmentIndex: segmentIndex\n            };\n          }\n        }\n      }\n    }\n    return syncPoint;\n  }\n},\n// Stategy \"Playlist\": We have a playlist with a known mapping of\n//                     segment index to display time\n{\n  name: 'Playlist',\n  run: function run(syncController, playlist, duration$$1, currentTimeline, currentTime) {\n    if (playlist.syncInfo) {\n      var syncPoint = {\n        time: playlist.syncInfo.time,\n        segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence\n      };\n\n      return syncPoint;\n    }\n    return null;\n  }\n}];\n\nvar SyncController = function (_videojs$EventTarget) {\n  inherits$1(SyncController, _videojs$EventTarget);\n\n  function SyncController() {\n    classCallCheck$1(this, SyncController);\n\n    // Segment Loader state variables...\n    // ...for synching across variants\n    var _this = possibleConstructorReturn$1(this, (SyncController.__proto__ || Object.getPrototypeOf(SyncController)).call(this));\n\n    _this.inspectCache_ = undefined;\n\n    // ...for synching across variants\n    _this.timelines = [];\n    _this.discontinuities = [];\n    _this.datetimeToDisplayTime = null;\n\n    _this.logger_ = logger('SyncController');\n    return _this;\n  }\n\n  /**\n   * Find a sync-point for the playlist specified\n   *\n   * A sync-point is defined as a known mapping from display-time to\n   * a segment-index in the current playlist.\n   *\n   * @param {Playlist} playlist\n   *        The playlist that needs a sync-point\n   * @param {Number} duration\n   *        Duration of the MediaSource (Infinite if playing a live source)\n   * @param {Number} currentTimeline\n   *        The last timeline from which a segment was loaded\n   * @returns {Object}\n   *          A sync-point object\n   */\n\n  createClass$1(SyncController, [{\n    key: 'getSyncPoint',\n    value: function getSyncPoint(playlist, duration$$1, currentTimeline, currentTime) {\n      var syncPoints = this.runStrategies_(playlist, duration$$1, currentTimeline, currentTime);\n\n      if (!syncPoints.length) {\n        // Signal that we need to attempt to get a sync-point manually\n        // by fetching a segment in the playlist and constructing\n        // a sync-point from that information\n        return null;\n      }\n\n      // Now find the sync-point that is closest to the currentTime because\n      // that should result in the most accurate guess about which segment\n      // to fetch\n      return this.selectSyncPoint_(syncPoints, { key: 'time', value: currentTime });\n    }\n\n    /**\n     * Calculate the amount of time that has expired off the playlist during playback\n     *\n     * @param {Playlist} playlist\n     *        Playlist object to calculate expired from\n     * @param {Number} duration\n     *        Duration of the MediaSource (Infinity if playling a live source)\n     * @returns {Number|null}\n     *          The amount of time that has expired off the playlist during playback. Null\n     *          if no sync-points for the playlist can be found.\n     */\n\n  }, {\n    key: 'getExpiredTime',\n    value: function getExpiredTime(playlist, duration$$1) {\n      if (!playlist || !playlist.segments) {\n        return null;\n      }\n\n      var syncPoints = this.runStrategies_(playlist, duration$$1, playlist.discontinuitySequence, 0);\n\n      // Without sync-points, there is not enough information to determine the expired time\n      if (!syncPoints.length) {\n        return null;\n      }\n\n      var syncPoint = this.selectSyncPoint_(syncPoints, {\n        key: 'segmentIndex',\n        value: 0\n      });\n\n      // If the sync-point is beyond the start of the playlist, we want to subtract the\n      // duration from index 0 to syncPoint.segmentIndex instead of adding.\n      if (syncPoint.segmentIndex > 0) {\n        syncPoint.time *= -1;\n      }\n\n      return Math.abs(syncPoint.time + sumDurations(playlist, syncPoint.segmentIndex, 0));\n    }\n\n    /**\n     * Runs each sync-point strategy and returns a list of sync-points returned by the\n     * strategies\n     *\n     * @private\n     * @param {Playlist} playlist\n     *        The playlist that needs a sync-point\n     * @param {Number} duration\n     *        Duration of the MediaSource (Infinity if playing a live source)\n     * @param {Number} currentTimeline\n     *        The last timeline from which a segment was loaded\n     * @returns {Array}\n     *          A list of sync-point objects\n     */\n\n  }, {\n    key: 'runStrategies_',\n    value: function runStrategies_(playlist, duration$$1, currentTimeline, currentTime) {\n      var syncPoints = [];\n\n      // Try to find a sync-point in by utilizing various strategies...\n      for (var i = 0; i < syncPointStrategies.length; i++) {\n        var strategy = syncPointStrategies[i];\n        var syncPoint = strategy.run(this, playlist, duration$$1, currentTimeline, currentTime);\n\n        if (syncPoint) {\n          syncPoint.strategy = strategy.name;\n          syncPoints.push({\n            strategy: strategy.name,\n            syncPoint: syncPoint\n          });\n        }\n      }\n\n      return syncPoints;\n    }\n\n    /**\n     * Selects the sync-point nearest the specified target\n     *\n     * @private\n     * @param {Array} syncPoints\n     *        List of sync-points to select from\n     * @param {Object} target\n     *        Object specifying the property and value we are targeting\n     * @param {String} target.key\n     *        Specifies the property to target. Must be either 'time' or 'segmentIndex'\n     * @param {Number} target.value\n     *        The value to target for the specified key.\n     * @returns {Object}\n     *          The sync-point nearest the target\n     */\n\n  }, {\n    key: 'selectSyncPoint_',\n    value: function selectSyncPoint_(syncPoints, target) {\n      var bestSyncPoint = syncPoints[0].syncPoint;\n      var bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);\n      var bestStrategy = syncPoints[0].strategy;\n\n      for (var i = 1; i < syncPoints.length; i++) {\n        var newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);\n\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          bestSyncPoint = syncPoints[i].syncPoint;\n          bestStrategy = syncPoints[i].strategy;\n        }\n      }\n\n      this.logger_('syncPoint for [' + target.key + ': ' + target.value + '] chosen with strategy' + (' [' + bestStrategy + ']: [time:' + bestSyncPoint.time + ',') + (' segmentIndex:' + bestSyncPoint.segmentIndex + ']'));\n\n      return bestSyncPoint;\n    }\n\n    /**\n     * Save any meta-data present on the segments when segments leave\n     * the live window to the playlist to allow for synchronization at the\n     * playlist level later.\n     *\n     * @param {Playlist} oldPlaylist - The previous active playlist\n     * @param {Playlist} newPlaylist - The updated and most current playlist\n     */\n\n  }, {\n    key: 'saveExpiredSegmentInfo',\n    value: function saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {\n      var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;\n\n      // When a segment expires from the playlist and it has a start time\n      // save that information as a possible sync-point reference in future\n      for (var i = mediaSequenceDiff - 1; i >= 0; i--) {\n        var lastRemovedSegment = oldPlaylist.segments[i];\n\n        if (lastRemovedSegment && typeof lastRemovedSegment.start !== 'undefined') {\n          newPlaylist.syncInfo = {\n            mediaSequence: oldPlaylist.mediaSequence + i,\n            time: lastRemovedSegment.start\n          };\n          this.logger_('playlist refresh sync: [time:' + newPlaylist.syncInfo.time + ',' + (' mediaSequence: ' + newPlaylist.syncInfo.mediaSequence + ']'));\n          this.trigger('syncinfoupdate');\n          break;\n        }\n      }\n    }\n\n    /**\n     * Save the mapping from playlist's ProgramDateTime to display. This should\n     * only ever happen once at the start of playback.\n     *\n     * @param {Playlist} playlist - The currently active playlist\n     */\n\n  }, {\n    key: 'setDateTimeMapping',\n    value: function setDateTimeMapping(playlist) {\n      if (!this.datetimeToDisplayTime && playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {\n        var playlistTimestamp = playlist.segments[0].dateTimeObject.getTime() / 1000;\n\n        this.datetimeToDisplayTime = -playlistTimestamp;\n      }\n    }\n\n    /**\n     * Reset the state of the inspection cache when we do a rendition\n     * switch\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.inspectCache_ = undefined;\n    }\n\n    /**\n     * Probe or inspect a fmp4 or an mpeg2-ts segment to determine the start\n     * and end of the segment in it's internal \"media time\". Used to generate\n     * mappings from that internal \"media time\" to the display time that is\n     * shown on the player.\n     *\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     */\n\n  }, {\n    key: 'probeSegmentInfo',\n    value: function probeSegmentInfo(segmentInfo) {\n      var segment = segmentInfo.segment;\n      var playlist = segmentInfo.playlist;\n      var timingInfo = void 0;\n\n      if (segment.map) {\n        timingInfo = this.probeMp4Segment_(segmentInfo);\n      } else {\n        timingInfo = this.probeTsSegment_(segmentInfo);\n      }\n\n      if (timingInfo) {\n        if (this.calculateSegmentTimeMapping_(segmentInfo, timingInfo)) {\n          this.saveDiscontinuitySyncInfo_(segmentInfo);\n\n          // If the playlist does not have sync information yet, record that information\n          // now with segment timing information\n          if (!playlist.syncInfo) {\n            playlist.syncInfo = {\n              mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,\n              time: segment.start\n            };\n          }\n        }\n      }\n\n      return timingInfo;\n    }\n\n    /**\n     * Probe an fmp4 or an mpeg2-ts segment to determine the start of the segment\n     * in it's internal \"media time\".\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     * @return {object} The start and end time of the current segment in \"media time\"\n     */\n\n  }, {\n    key: 'probeMp4Segment_',\n    value: function probeMp4Segment_(segmentInfo) {\n      var segment = segmentInfo.segment;\n      var timescales = mux_js_lib_mp4_probe__WEBPACK_IMPORTED_MODULE_9___default.a.timescale(segment.map.bytes);\n      var startTime = mux_js_lib_mp4_probe__WEBPACK_IMPORTED_MODULE_9___default.a.startTime(timescales, segmentInfo.bytes);\n\n      if (segmentInfo.timestampOffset !== null) {\n        segmentInfo.timestampOffset -= startTime;\n      }\n\n      return {\n        start: startTime,\n        end: startTime + segment.duration\n      };\n    }\n\n    /**\n     * Probe an mpeg2-ts segment to determine the start and end of the segment\n     * in it's internal \"media time\".\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     * @return {object} The start and end time of the current segment in \"media time\"\n     */\n\n  }, {\n    key: 'probeTsSegment_',\n    value: function probeTsSegment_(segmentInfo) {\n      var timeInfo = tsprobe(segmentInfo.bytes, this.inspectCache_);\n      var segmentStartTime = void 0;\n      var segmentEndTime = void 0;\n\n      if (!timeInfo) {\n        return null;\n      }\n\n      if (timeInfo.video && timeInfo.video.length === 2) {\n        this.inspectCache_ = timeInfo.video[1].dts;\n        segmentStartTime = timeInfo.video[0].dtsTime;\n        segmentEndTime = timeInfo.video[1].dtsTime;\n      } else if (timeInfo.audio && timeInfo.audio.length === 2) {\n        this.inspectCache_ = timeInfo.audio[1].dts;\n        segmentStartTime = timeInfo.audio[0].dtsTime;\n        segmentEndTime = timeInfo.audio[1].dtsTime;\n      }\n\n      return {\n        start: segmentStartTime,\n        end: segmentEndTime,\n        containsVideo: timeInfo.video && timeInfo.video.length === 2,\n        containsAudio: timeInfo.audio && timeInfo.audio.length === 2\n      };\n    }\n  }, {\n    key: 'timestampOffsetForTimeline',\n    value: function timestampOffsetForTimeline(timeline) {\n      if (typeof this.timelines[timeline] === 'undefined') {\n        return null;\n      }\n      return this.timelines[timeline].time;\n    }\n  }, {\n    key: 'mappingForTimeline',\n    value: function mappingForTimeline(timeline) {\n      if (typeof this.timelines[timeline] === 'undefined') {\n        return null;\n      }\n      return this.timelines[timeline].mapping;\n    }\n\n    /**\n     * Use the \"media time\" for a segment to generate a mapping to \"display time\" and\n     * save that display time to the segment.\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo\n     *        The current active request information\n     * @param {object} timingInfo\n     *        The start and end time of the current segment in \"media time\"\n     * @returns {Boolean}\n     *          Returns false if segment time mapping could not be calculated\n     */\n\n  }, {\n    key: 'calculateSegmentTimeMapping_',\n    value: function calculateSegmentTimeMapping_(segmentInfo, timingInfo) {\n      var segment = segmentInfo.segment;\n      var mappingObj = this.timelines[segmentInfo.timeline];\n\n      if (segmentInfo.timestampOffset !== null) {\n        mappingObj = {\n          time: segmentInfo.startOfSegment,\n          mapping: segmentInfo.startOfSegment - timingInfo.start\n        };\n        this.timelines[segmentInfo.timeline] = mappingObj;\n        this.trigger('timestampoffset');\n\n        this.logger_('time mapping for timeline ' + segmentInfo.timeline + ': ' + ('[time: ' + mappingObj.time + '] [mapping: ' + mappingObj.mapping + ']'));\n\n        segment.start = segmentInfo.startOfSegment;\n        segment.end = timingInfo.end + mappingObj.mapping;\n      } else if (mappingObj) {\n        segment.start = timingInfo.start + mappingObj.mapping;\n        segment.end = timingInfo.end + mappingObj.mapping;\n      } else {\n        return false;\n      }\n\n      return true;\n    }\n\n    /**\n     * Each time we have discontinuity in the playlist, attempt to calculate the location\n     * in display of the start of the discontinuity and save that. We also save an accuracy\n     * value so that we save values with the most accuracy (closest to 0.)\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     */\n\n  }, {\n    key: 'saveDiscontinuitySyncInfo_',\n    value: function saveDiscontinuitySyncInfo_(segmentInfo) {\n      var playlist = segmentInfo.playlist;\n      var segment = segmentInfo.segment;\n\n      // If the current segment is a discontinuity then we know exactly where\n      // the start of the range and it's accuracy is 0 (greater accuracy values\n      // mean more approximation)\n      if (segment.discontinuity) {\n        this.discontinuities[segment.timeline] = {\n          time: segment.start,\n          accuracy: 0\n        };\n      } else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\n        // Search for future discontinuities that we can provide better timing\n        // information for and save that information for sync purposes\n        for (var i = 0; i < playlist.discontinuityStarts.length; i++) {\n          var segmentIndex = playlist.discontinuityStarts[i];\n          var discontinuity = playlist.discontinuitySequence + i + 1;\n          var mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;\n          var accuracy = Math.abs(mediaIndexDiff);\n\n          if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {\n            var time = void 0;\n\n            if (mediaIndexDiff < 0) {\n              time = segment.start - sumDurations(playlist, segmentInfo.mediaIndex, segmentIndex);\n            } else {\n              time = segment.end + sumDurations(playlist, segmentInfo.mediaIndex + 1, segmentIndex);\n            }\n\n            this.discontinuities[discontinuity] = {\n              time: time,\n              accuracy: accuracy\n            };\n          }\n        }\n      }\n    }\n  }]);\n  return SyncController;\n}(videojs$1.EventTarget);\n\nvar Decrypter$1 = new shimWorker(\"./decrypter-worker.worker.js\", function (window, document$$1) {\n  var self = this;\n  var decrypterWorker = function () {\n\n    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n    var win;\n\n    if (typeof window !== \"undefined\") {\n      win = window;\n    } else if (typeof commonjsGlobal !== \"undefined\") {\n      win = commonjsGlobal;\n    } else if (typeof self !== \"undefined\") {\n      win = self;\n    } else {\n      win = {};\n    }\n\n    var window_1 = win;\n\n    /*\n     * pkcs7.pad\n     * https://github.com/brightcove/pkcs7\n     *\n     * Copyright (c) 2014 Brightcove\n     * Licensed under the apache2 license.\n     */\n\n    /**\n     * Returns the subarray of a Uint8Array without PKCS#7 padding.\n     * @param padded {Uint8Array} unencrypted bytes that have been padded\n     * @return {Uint8Array} the unpadded bytes\n     * @see http://tools.ietf.org/html/rfc5652\n     */\n    function unpad(padded) {\n      return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);\n    }\n\n    var classCallCheck$$1 = function classCallCheck$$1(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    };\n\n    var createClass$$1 = function () {\n      function defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      return function (Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n      };\n    }();\n\n    var inherits$$1 = function inherits$$1(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));\n      }\n\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n          value: subClass,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    };\n\n    var possibleConstructorReturn$$1 = function possibleConstructorReturn$$1(self, call) {\n      if (!self) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n\n      return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n    };\n\n    /**\n     * @file aes.js\n     *\n     * This file contains an adaptation of the AES decryption algorithm\n     * from the Standford Javascript Cryptography Library. That work is\n     * covered by the following copyright and permissions notice:\n     *\n     * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.\n     * All rights reserved.\n     *\n     * Redistribution and use in source and binary forms, with or without\n     * modification, are permitted provided that the following conditions are\n     * met:\n     *\n     * 1. Redistributions of source code must retain the above copyright\n     *    notice, this list of conditions and the following disclaimer.\n     *\n     * 2. Redistributions in binary form must reproduce the above\n     *    copyright notice, this list of conditions and the following\n     *    disclaimer in the documentation and/or other materials provided\n     *    with the distribution.\n     *\n     * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\n     * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n     * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE\n     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n     * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n     * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n     * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     *\n     * The views and conclusions contained in the software and documentation\n     * are those of the authors and should not be interpreted as representing\n     * official policies, either expressed or implied, of the authors.\n     */\n\n    /**\n     * Expand the S-box tables.\n     *\n     * @private\n     */\n    var precompute = function precompute() {\n      var tables = [[[], [], [], [], []], [[], [], [], [], []]];\n      var encTable = tables[0];\n      var decTable = tables[1];\n      var sbox = encTable[4];\n      var sboxInv = decTable[4];\n      var i = void 0;\n      var x = void 0;\n      var xInv = void 0;\n      var d = [];\n      var th = [];\n      var x2 = void 0;\n      var x4 = void 0;\n      var x8 = void 0;\n      var s = void 0;\n      var tEnc = void 0;\n      var tDec = void 0;\n\n      // Compute double and third tables\n      for (i = 0; i < 256; i++) {\n        th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\n      }\n\n      for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n        // Compute sbox\n        s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\n        s = s >> 8 ^ s & 255 ^ 99;\n        sbox[x] = s;\n        sboxInv[s] = x;\n\n        // Compute MixColumns\n        x8 = d[x4 = d[x2 = d[x]]];\n        tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n        tEnc = d[s] * 0x101 ^ s * 0x1010100;\n\n        for (i = 0; i < 4; i++) {\n          encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n          decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\n        }\n      }\n\n      // Compactify. Considerable speedup on Firefox.\n      for (i = 0; i < 5; i++) {\n        encTable[i] = encTable[i].slice(0);\n        decTable[i] = decTable[i].slice(0);\n      }\n      return tables;\n    };\n    var aesTables = null;\n\n    /**\n     * Schedule out an AES key for both encryption and decryption. This\n     * is a low-level class. Use a cipher mode to do bulk encryption.\n     *\n     * @class AES\n     * @param key {Array} The key as an array of 4, 6 or 8 words.\n     */\n\n    var AES = function () {\n      function AES(key) {\n        classCallCheck$$1(this, AES);\n\n        /**\n         * The expanded S-box and inverse S-box tables. These will be computed\n         * on the client so that we don't have to send them down the wire.\n         *\n         * There are two tables, _tables[0] is for encryption and\n         * _tables[1] is for decryption.\n         *\n         * The first 4 sub-tables are the expanded S-box with MixColumns. The\n         * last (_tables[01][4]) is the S-box itself.\n         *\n         * @private\n         */\n        // if we have yet to precompute the S-box tables\n        // do so now\n        if (!aesTables) {\n          aesTables = precompute();\n        }\n        // then make a copy of that object for use\n        this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];\n        var i = void 0;\n        var j = void 0;\n        var tmp = void 0;\n        var encKey = void 0;\n        var decKey = void 0;\n        var sbox = this._tables[0][4];\n        var decTable = this._tables[1];\n        var keyLen = key.length;\n        var rcon = 1;\n\n        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n          throw new Error('Invalid aes key size');\n        }\n\n        encKey = key.slice(0);\n        decKey = [];\n        this._key = [encKey, decKey];\n\n        // schedule encryption keys\n        for (i = keyLen; i < 4 * keyLen + 28; i++) {\n          tmp = encKey[i - 1];\n\n          // apply sbox\n          if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {\n            tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];\n\n            // shift rows and add rcon\n            if (i % keyLen === 0) {\n              tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\n              rcon = rcon << 1 ^ (rcon >> 7) * 283;\n            }\n          }\n\n          encKey[i] = encKey[i - keyLen] ^ tmp;\n        }\n\n        // schedule decryption keys\n        for (j = 0; i; j++, i--) {\n          tmp = encKey[j & 3 ? i : i - 4];\n          if (i <= 4 || j < 4) {\n            decKey[j] = tmp;\n          } else {\n            decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];\n          }\n        }\n      }\n\n      /**\n       * Decrypt 16 bytes, specified as four 32-bit words.\n       *\n       * @param {Number} encrypted0 the first word to decrypt\n       * @param {Number} encrypted1 the second word to decrypt\n       * @param {Number} encrypted2 the third word to decrypt\n       * @param {Number} encrypted3 the fourth word to decrypt\n       * @param {Int32Array} out the array to write the decrypted words\n       * into\n       * @param {Number} offset the offset into the output array to start\n       * writing results\n       * @return {Array} The plaintext.\n       */\n\n      AES.prototype.decrypt = function decrypt$$1(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {\n        var key = this._key[1];\n        // state variables a,b,c,d are loaded with pre-whitened data\n        var a = encrypted0 ^ key[0];\n        var b = encrypted3 ^ key[1];\n        var c = encrypted2 ^ key[2];\n        var d = encrypted1 ^ key[3];\n        var a2 = void 0;\n        var b2 = void 0;\n        var c2 = void 0;\n\n        // key.length === 2 ?\n        var nInnerRounds = key.length / 4 - 2;\n        var i = void 0;\n        var kIndex = 4;\n        var table = this._tables[1];\n\n        // load up the tables\n        var table0 = table[0];\n        var table1 = table[1];\n        var table2 = table[2];\n        var table3 = table[3];\n        var sbox = table[4];\n\n        // Inner rounds. Cribbed from OpenSSL.\n        for (i = 0; i < nInnerRounds; i++) {\n          a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];\n          b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];\n          c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];\n          d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];\n          kIndex += 4;\n          a = a2;b = b2;c = c2;\n        }\n\n        // Last round.\n        for (i = 0; i < 4; i++) {\n          out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];\n          a2 = a;a = b;b = c;c = d;d = a2;\n        }\n      };\n\n      return AES;\n    }();\n\n    /**\n     * @file stream.js\n     */\n    /**\n     * A lightweight readable stream implemention that handles event dispatching.\n     *\n     * @class Stream\n     */\n    var Stream = function () {\n      function Stream() {\n        classCallCheck$$1(this, Stream);\n\n        this.listeners = {};\n      }\n\n      /**\n       * Add a listener for a specified event type.\n       *\n       * @param {String} type the event name\n       * @param {Function} listener the callback to be invoked when an event of\n       * the specified type occurs\n       */\n\n      Stream.prototype.on = function on(type, listener) {\n        if (!this.listeners[type]) {\n          this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n      };\n\n      /**\n       * Remove a listener for a specified event type.\n       *\n       * @param {String} type the event name\n       * @param {Function} listener  a function previously registered for this\n       * type of event through `on`\n       * @return {Boolean} if we could turn it off or not\n       */\n\n      Stream.prototype.off = function off(type, listener) {\n        if (!this.listeners[type]) {\n          return false;\n        }\n\n        var index = this.listeners[type].indexOf(listener);\n\n        this.listeners[type].splice(index, 1);\n        return index > -1;\n      };\n\n      /**\n       * Trigger an event of the specified type on this stream. Any additional\n       * arguments to this function are passed as parameters to event listeners.\n       *\n       * @param {String} type the event name\n       */\n\n      Stream.prototype.trigger = function trigger(type) {\n        var callbacks = this.listeners[type];\n\n        if (!callbacks) {\n          return;\n        }\n\n        // Slicing the arguments on every invocation of this method\n        // can add a significant amount of overhead. Avoid the\n        // intermediate object creation for the common case of a\n        // single callback argument\n        if (arguments.length === 2) {\n          var length = callbacks.length;\n\n          for (var i = 0; i < length; ++i) {\n            callbacks[i].call(this, arguments[1]);\n          }\n        } else {\n          var args = Array.prototype.slice.call(arguments, 1);\n          var _length = callbacks.length;\n\n          for (var _i = 0; _i < _length; ++_i) {\n            callbacks[_i].apply(this, args);\n          }\n        }\n      };\n\n      /**\n       * Destroys the stream and cleans up.\n       */\n\n      Stream.prototype.dispose = function dispose() {\n        this.listeners = {};\n      };\n      /**\n       * Forwards all `data` events on this stream to the destination stream. The\n       * destination stream should provide a method `push` to receive the data\n       * events as they arrive.\n       *\n       * @param {Stream} destination the stream that will receive all `data` events\n       * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n       */\n\n      Stream.prototype.pipe = function pipe(destination) {\n        this.on('data', function (data) {\n          destination.push(data);\n        });\n      };\n\n      return Stream;\n    }();\n\n    /**\n     * @file async-stream.js\n     */\n    /**\n     * A wrapper around the Stream class to use setTiemout\n     * and run stream \"jobs\" Asynchronously\n     *\n     * @class AsyncStream\n     * @extends Stream\n     */\n\n    var AsyncStream$$1 = function (_Stream) {\n      inherits$$1(AsyncStream$$1, _Stream);\n\n      function AsyncStream$$1() {\n        classCallCheck$$1(this, AsyncStream$$1);\n\n        var _this = possibleConstructorReturn$$1(this, _Stream.call(this, Stream));\n\n        _this.jobs = [];\n        _this.delay = 1;\n        _this.timeout_ = null;\n        return _this;\n      }\n\n      /**\n       * process an async job\n       *\n       * @private\n       */\n\n      AsyncStream$$1.prototype.processJob_ = function processJob_() {\n        this.jobs.shift()();\n        if (this.jobs.length) {\n          this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\n        } else {\n          this.timeout_ = null;\n        }\n      };\n\n      /**\n       * push a job into the stream\n       *\n       * @param {Function} job the job to push into the stream\n       */\n\n      AsyncStream$$1.prototype.push = function push(job) {\n        this.jobs.push(job);\n        if (!this.timeout_) {\n          this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\n        }\n      };\n\n      return AsyncStream$$1;\n    }(Stream);\n\n    /**\n     * @file decrypter.js\n     *\n     * An asynchronous implementation of AES-128 CBC decryption with\n     * PKCS#7 padding.\n     */\n\n    /**\n     * Convert network-order (big-endian) bytes into their little-endian\n     * representation.\n     */\n    var ntoh = function ntoh(word) {\n      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n    };\n\n    /**\n     * Decrypt bytes using AES-128 with CBC and PKCS#7 padding.\n     *\n     * @param {Uint8Array} encrypted the encrypted bytes\n     * @param {Uint32Array} key the bytes of the decryption key\n     * @param {Uint32Array} initVector the initialization vector (IV) to\n     * use for the first round of CBC.\n     * @return {Uint8Array} the decrypted bytes\n     *\n     * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n     * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29\n     * @see https://tools.ietf.org/html/rfc2315\n     */\n    var decrypt$$1 = function decrypt$$1(encrypted, key, initVector) {\n      // word-level access to the encrypted bytes\n      var encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);\n\n      var decipher = new AES(Array.prototype.slice.call(key));\n\n      // byte and word-level access for the decrypted output\n      var decrypted = new Uint8Array(encrypted.byteLength);\n      var decrypted32 = new Int32Array(decrypted.buffer);\n\n      // temporary variables for working with the IV, encrypted, and\n      // decrypted data\n      var init0 = void 0;\n      var init1 = void 0;\n      var init2 = void 0;\n      var init3 = void 0;\n      var encrypted0 = void 0;\n      var encrypted1 = void 0;\n      var encrypted2 = void 0;\n      var encrypted3 = void 0;\n\n      // iteration variable\n      var wordIx = void 0;\n\n      // pull out the words of the IV to ensure we don't modify the\n      // passed-in reference and easier access\n      init0 = initVector[0];\n      init1 = initVector[1];\n      init2 = initVector[2];\n      init3 = initVector[3];\n\n      // decrypt four word sequences, applying cipher-block chaining (CBC)\n      // to each decrypted block\n      for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {\n        // convert big-endian (network order) words into little-endian\n        // (javascript order)\n        encrypted0 = ntoh(encrypted32[wordIx]);\n        encrypted1 = ntoh(encrypted32[wordIx + 1]);\n        encrypted2 = ntoh(encrypted32[wordIx + 2]);\n        encrypted3 = ntoh(encrypted32[wordIx + 3]);\n\n        // decrypt the block\n        decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);\n\n        // XOR with the IV, and restore network byte-order to obtain the\n        // plaintext\n        decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);\n        decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);\n        decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);\n        decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3);\n\n        // setup the IV for the next round\n        init0 = encrypted0;\n        init1 = encrypted1;\n        init2 = encrypted2;\n        init3 = encrypted3;\n      }\n\n      return decrypted;\n    };\n\n    /**\n     * The `Decrypter` class that manages decryption of AES\n     * data through `AsyncStream` objects and the `decrypt`\n     * function\n     *\n     * @param {Uint8Array} encrypted the encrypted bytes\n     * @param {Uint32Array} key the bytes of the decryption key\n     * @param {Uint32Array} initVector the initialization vector (IV) to\n     * @param {Function} done the function to run when done\n     * @class Decrypter\n     */\n\n    var Decrypter$$1 = function () {\n      function Decrypter$$1(encrypted, key, initVector, done) {\n        classCallCheck$$1(this, Decrypter$$1);\n\n        var step = Decrypter$$1.STEP;\n        var encrypted32 = new Int32Array(encrypted.buffer);\n        var decrypted = new Uint8Array(encrypted.byteLength);\n        var i = 0;\n\n        this.asyncStream_ = new AsyncStream$$1();\n\n        // split up the encryption job and do the individual chunks asynchronously\n        this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\n        for (i = step; i < encrypted32.length; i += step) {\n          initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);\n          this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\n        }\n        // invoke the done() callback when everything is finished\n        this.asyncStream_.push(function () {\n          // remove pkcs#7 padding from the decrypted bytes\n          done(null, unpad(decrypted));\n        });\n      }\n\n      /**\n       * a getter for step the maximum number of bytes to process at one time\n       *\n       * @return {Number} the value of step 32000\n       */\n\n      /**\n       * @private\n       */\n      Decrypter$$1.prototype.decryptChunk_ = function decryptChunk_(encrypted, key, initVector, decrypted) {\n        return function () {\n          var bytes = decrypt$$1(encrypted, key, initVector);\n\n          decrypted.set(bytes, encrypted.byteOffset);\n        };\n      };\n\n      createClass$$1(Decrypter$$1, null, [{\n        key: 'STEP',\n        get: function get$$1() {\n          // 4 * 8000;\n          return 32000;\n        }\n      }]);\n      return Decrypter$$1;\n    }();\n\n    /**\n     * @file bin-utils.js\n     */\n\n    /**\n     * Creates an object for sending to a web worker modifying properties that are TypedArrays\n     * into a new object with seperated properties for the buffer, byteOffset, and byteLength.\n     *\n     * @param {Object} message\n     *        Object of properties and values to send to the web worker\n     * @return {Object}\n     *         Modified message with TypedArray values expanded\n     * @function createTransferableMessage\n     */\n    var createTransferableMessage = function createTransferableMessage(message) {\n      var transferable = {};\n\n      Object.keys(message).forEach(function (key) {\n        var value = message[key];\n\n        if (ArrayBuffer.isView(value)) {\n          transferable[key] = {\n            bytes: value.buffer,\n            byteOffset: value.byteOffset,\n            byteLength: value.byteLength\n          };\n        } else {\n          transferable[key] = value;\n        }\n      });\n\n      return transferable;\n    };\n\n    /**\n     * Our web worker interface so that things can talk to aes-decrypter\n     * that will be running in a web worker. the scope is passed to this by\n     * webworkify.\n     *\n     * @param {Object} self\n     *        the scope for the web worker\n     */\n    var DecrypterWorker = function DecrypterWorker(self) {\n      self.onmessage = function (event) {\n        var data = event.data;\n        var encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);\n        var key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);\n        var iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);\n\n        /* eslint-disable no-new, handle-callback-err */\n        new Decrypter$$1(encrypted, key, iv, function (err, bytes) {\n          window_1.postMessage(createTransferableMessage({\n            source: data.source,\n            decrypted: bytes\n          }), [bytes.buffer]);\n        });\n        /* eslint-enable */\n      };\n    };\n\n    var decrypterWorker = new DecrypterWorker(self);\n\n    return decrypterWorker;\n  }();\n});\n\n/**\n * Convert the properties of an HLS track into an audioTrackKind.\n *\n * @private\n */\nvar audioTrackKind_ = function audioTrackKind_(properties) {\n  var kind = properties.default ? 'main' : 'alternative';\n\n  if (properties.characteristics && properties.characteristics.indexOf('public.accessibility.describes-video') >= 0) {\n    kind = 'main-desc';\n  }\n\n  return kind;\n};\n\n/**\n * Pause provided segment loader and playlist loader if active\n *\n * @param {SegmentLoader} segmentLoader\n *        SegmentLoader to pause\n * @param {Object} mediaType\n *        Active media type\n * @function stopLoaders\n */\nvar stopLoaders = function stopLoaders(segmentLoader, mediaType) {\n  segmentLoader.abort();\n  segmentLoader.pause();\n\n  if (mediaType && mediaType.activePlaylistLoader) {\n    mediaType.activePlaylistLoader.pause();\n    mediaType.activePlaylistLoader = null;\n  }\n};\n\n/**\n * Start loading provided segment loader and playlist loader\n *\n * @param {PlaylistLoader} playlistLoader\n *        PlaylistLoader to start loading\n * @param {Object} mediaType\n *        Active media type\n * @function startLoaders\n */\nvar startLoaders = function startLoaders(playlistLoader, mediaType) {\n  // Segment loader will be started after `loadedmetadata` or `loadedplaylist` from the\n  // playlist loader\n  mediaType.activePlaylistLoader = playlistLoader;\n  playlistLoader.load();\n};\n\n/**\n * Returns a function to be called when the media group changes. It performs a\n * non-destructive (preserve the buffer) resync of the SegmentLoader. This is because a\n * change of group is merely a rendition switch of the same content at another encoding,\n * rather than a change of content, such as switching audio from English to Spanish.\n *\n * @param {String} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Handler for a non-destructive resync of SegmentLoader when the active media\n *         group changes.\n * @function onGroupChanged\n */\nvar onGroupChanged = function onGroupChanged(type, settings) {\n  return function () {\n    var _settings$segmentLoad = settings.segmentLoaders,\n        segmentLoader = _settings$segmentLoad[type],\n        mainSegmentLoader = _settings$segmentLoad.main,\n        mediaType = settings.mediaTypes[type];\n\n    var activeTrack = mediaType.activeTrack();\n    var activeGroup = mediaType.activeGroup(activeTrack);\n    var previousActiveLoader = mediaType.activePlaylistLoader;\n\n    stopLoaders(segmentLoader, mediaType);\n\n    if (!activeGroup) {\n      // there is no group active\n      return;\n    }\n\n    if (!activeGroup.playlistLoader) {\n      if (previousActiveLoader) {\n        // The previous group had a playlist loader but the new active group does not\n        // this means we are switching from demuxed to muxed audio. In this case we want to\n        // do a destructive reset of the main segment loader and not restart the audio\n        // loaders.\n        mainSegmentLoader.resetEverything();\n      }\n      return;\n    }\n\n    // Non-destructive resync\n    segmentLoader.resyncLoader();\n\n    startLoaders(activeGroup.playlistLoader, mediaType);\n  };\n};\n\n/**\n * Returns a function to be called when the media track changes. It performs a\n * destructive reset of the SegmentLoader to ensure we start loading as close to\n * currentTime as possible.\n *\n * @param {String} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Handler for a destructive reset of SegmentLoader when the active media\n *         track changes.\n * @function onTrackChanged\n */\nvar onTrackChanged = function onTrackChanged(type, settings) {\n  return function () {\n    var _settings$segmentLoad2 = settings.segmentLoaders,\n        segmentLoader = _settings$segmentLoad2[type],\n        mainSegmentLoader = _settings$segmentLoad2.main,\n        mediaType = settings.mediaTypes[type];\n\n    var activeTrack = mediaType.activeTrack();\n    var activeGroup = mediaType.activeGroup(activeTrack);\n    var previousActiveLoader = mediaType.activePlaylistLoader;\n\n    stopLoaders(segmentLoader, mediaType);\n\n    if (!activeGroup) {\n      // there is no group active so we do not want to restart loaders\n      return;\n    }\n\n    if (!activeGroup.playlistLoader) {\n      // when switching from demuxed audio/video to muxed audio/video (noted by no playlist\n      // loader for the audio group), we want to do a destructive reset of the main segment\n      // loader and not restart the audio loaders\n      mainSegmentLoader.resetEverything();\n      return;\n    }\n\n    if (previousActiveLoader === activeGroup.playlistLoader) {\n      // Nothing has actually changed. This can happen because track change events can fire\n      // multiple times for a \"single\" change. One for enabling the new active track, and\n      // one for disabling the track that was active\n      startLoaders(activeGroup.playlistLoader, mediaType);\n      return;\n    }\n\n    if (segmentLoader.track) {\n      // For WebVTT, set the new text track in the segmentloader\n      segmentLoader.track(activeTrack);\n    }\n\n    // destructive reset\n    segmentLoader.resetEverything();\n\n    startLoaders(activeGroup.playlistLoader, mediaType);\n  };\n};\n\nvar onError = {\n  /**\n   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n   * an error.\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Error handler. Logs warning (or error if the playlist is blacklisted) to\n   *         console and switches back to default audio track.\n   * @function onError.AUDIO\n   */\n  AUDIO: function AUDIO(type, settings) {\n    return function () {\n      var segmentLoader = settings.segmentLoaders[type],\n          mediaType = settings.mediaTypes[type],\n          blacklistCurrentPlaylist = settings.blacklistCurrentPlaylist;\n\n      stopLoaders(segmentLoader, mediaType);\n\n      // switch back to default audio track\n      var activeTrack = mediaType.activeTrack();\n      var activeGroup = mediaType.activeGroup();\n      var id = (activeGroup.filter(function (group) {\n        return group.default;\n      })[0] || activeGroup[0]).id;\n      var defaultTrack = mediaType.tracks[id];\n\n      if (activeTrack === defaultTrack) {\n        // Default track encountered an error. All we can do now is blacklist the current\n        // rendition and hope another will switch audio groups\n        blacklistCurrentPlaylist({\n          message: 'Problem encountered loading the default audio track.'\n        });\n        return;\n      }\n\n      videojs$1.log.warn('Problem encountered loading the alternate audio track.' + 'Switching back to default.');\n\n      for (var trackId in mediaType.tracks) {\n        mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;\n      }\n\n      mediaType.onTrackChanged();\n    };\n  },\n  /**\n   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n   * an error.\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Error handler. Logs warning to console and disables the active subtitle track\n   * @function onError.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, settings) {\n    return function () {\n      var segmentLoader = settings.segmentLoaders[type],\n          mediaType = settings.mediaTypes[type];\n\n      videojs$1.log.warn('Problem encountered loading the subtitle track.' + 'Disabling subtitle track.');\n\n      stopLoaders(segmentLoader, mediaType);\n\n      var track = mediaType.activeTrack();\n\n      if (track) {\n        track.mode = 'disabled';\n      }\n\n      mediaType.onTrackChanged();\n    };\n  }\n};\n\nvar setupListeners = {\n  /**\n   * Setup event listeners for audio playlist loader\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {PlaylistLoader|null} playlistLoader\n   *        PlaylistLoader to register listeners on\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function setupListeners.AUDIO\n   */\n  AUDIO: function AUDIO(type, playlistLoader, settings) {\n    if (!playlistLoader) {\n      // no playlist loader means audio will be muxed with the video\n      return;\n    }\n\n    var tech = settings.tech,\n        requestOptions = settings.requestOptions,\n        segmentLoader = settings.segmentLoaders[type];\n\n    playlistLoader.on('loadedmetadata', function () {\n      var media = playlistLoader.media();\n\n      segmentLoader.playlist(media, requestOptions);\n\n      // if the video is already playing, or if this isn't a live video and preload\n      // permits, start downloading segments\n      if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n        segmentLoader.load();\n      }\n    });\n\n    playlistLoader.on('loadedplaylist', function () {\n      segmentLoader.playlist(playlistLoader.media(), requestOptions);\n\n      // If the player isn't paused, ensure that the segment loader is running\n      if (!tech.paused()) {\n        segmentLoader.load();\n      }\n    });\n\n    playlistLoader.on('error', onError[type](type, settings));\n  },\n  /**\n   * Setup event listeners for subtitle playlist loader\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {PlaylistLoader|null} playlistLoader\n   *        PlaylistLoader to register listeners on\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function setupListeners.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, playlistLoader, settings) {\n    var tech = settings.tech,\n        requestOptions = settings.requestOptions,\n        segmentLoader = settings.segmentLoaders[type],\n        mediaType = settings.mediaTypes[type];\n\n    playlistLoader.on('loadedmetadata', function () {\n      var media = playlistLoader.media();\n\n      segmentLoader.playlist(media, requestOptions);\n      segmentLoader.track(mediaType.activeTrack());\n\n      // if the video is already playing, or if this isn't a live video and preload\n      // permits, start downloading segments\n      if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n        segmentLoader.load();\n      }\n    });\n\n    playlistLoader.on('loadedplaylist', function () {\n      segmentLoader.playlist(playlistLoader.media(), requestOptions);\n\n      // If the player isn't paused, ensure that the segment loader is running\n      if (!tech.paused()) {\n        segmentLoader.load();\n      }\n    });\n\n    playlistLoader.on('error', onError[type](type, settings));\n  }\n};\n\nvar byGroupId = function byGroupId(type, groupId) {\n  return function (playlist) {\n    return playlist.attributes[type] === groupId;\n  };\n};\n\nvar byResolvedUri = function byResolvedUri(resolvedUri) {\n  return function (playlist) {\n    return playlist.resolvedUri === resolvedUri;\n  };\n};\n\nvar initialize = {\n  /**\n   * Setup PlaylistLoaders and AudioTracks for the audio groups\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize.AUDIO\n   */\n  'AUDIO': function AUDIO(type, settings) {\n    var hls = settings.hls,\n        sourceType = settings.sourceType,\n        segmentLoader = settings.segmentLoaders[type],\n        withCredentials = settings.requestOptions.withCredentials,\n        _settings$master = settings.master,\n        mediaGroups = _settings$master.mediaGroups,\n        playlists = _settings$master.playlists,\n        _settings$mediaTypes$ = settings.mediaTypes[type],\n        groups = _settings$mediaTypes$.groups,\n        tracks = _settings$mediaTypes$.tracks,\n        masterPlaylistLoader = settings.masterPlaylistLoader;\n\n    // force a default if we have none\n\n    if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0) {\n      mediaGroups[type] = { main: { default: { default: true } } };\n    }\n\n    for (var groupId in mediaGroups[type]) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      }\n\n      // List of playlists that have an AUDIO attribute value matching the current\n      // group ID\n      var groupPlaylists = playlists.filter(byGroupId(type, groupId));\n\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        var properties = mediaGroups[type][groupId][variantLabel];\n\n        // List of playlists for the current group ID that have a matching uri with\n        // this alternate audio variant\n        var matchingPlaylists = groupPlaylists.filter(byResolvedUri(properties.resolvedUri));\n\n        if (matchingPlaylists.length) {\n          // If there is a playlist that has the same uri as this audio variant, assume\n          // that the playlist is audio only. We delete the resolvedUri property here\n          // to prevent a playlist loader from being created so that we don't have\n          // both the main and audio segment loaders loading the same audio segments\n          // from the same playlist.\n          delete properties.resolvedUri;\n        }\n\n        var playlistLoader = void 0;\n\n        if (properties.resolvedUri) {\n          playlistLoader = new PlaylistLoader(properties.resolvedUri, hls, withCredentials);\n        } else if (properties.playlists && sourceType === 'dash') {\n          playlistLoader = new DashPlaylistLoader(properties.playlists[0], hls, withCredentials, masterPlaylistLoader);\n        } else {\n          // no resolvedUri means the audio is muxed with the video when using this\n          // audio track\n          playlistLoader = null;\n        }\n\n        properties = videojs$1.mergeOptions({ id: variantLabel, playlistLoader: playlistLoader }, properties);\n\n        setupListeners[type](type, properties.playlistLoader, settings);\n\n        groups[groupId].push(properties);\n\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = new videojs$1.AudioTrack({\n            id: variantLabel,\n            kind: audioTrackKind_(properties),\n            enabled: false,\n            language: properties.language,\n            default: properties.default,\n            label: variantLabel\n          });\n\n          tracks[variantLabel] = track;\n        }\n      }\n    }\n\n    // setup single error event handler for the segment loader\n    segmentLoader.on('error', onError[type](type, settings));\n  },\n  /**\n   * Setup PlaylistLoaders and TextTracks for the subtitle groups\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize.SUBTITLES\n   */\n  'SUBTITLES': function SUBTITLES(type, settings) {\n    var tech = settings.tech,\n        hls = settings.hls,\n        sourceType = settings.sourceType,\n        segmentLoader = settings.segmentLoaders[type],\n        withCredentials = settings.requestOptions.withCredentials,\n        mediaGroups = settings.master.mediaGroups,\n        _settings$mediaTypes$2 = settings.mediaTypes[type],\n        groups = _settings$mediaTypes$2.groups,\n        tracks = _settings$mediaTypes$2.tracks,\n        masterPlaylistLoader = settings.masterPlaylistLoader;\n\n    for (var groupId in mediaGroups[type]) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      }\n\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        if (mediaGroups[type][groupId][variantLabel].forced) {\n          // Subtitle playlists with the forced attribute are not selectable in Safari.\n          // According to Apple's HLS Authoring Specification:\n          //   If content has forced subtitles and regular subtitles in a given language,\n          //   the regular subtitles track in that language MUST contain both the forced\n          //   subtitles and the regular subtitles for that language.\n          // Because of this requirement and that Safari does not add forced subtitles,\n          // forced subtitles are skipped here to maintain consistent experience across\n          // all platforms\n          continue;\n        }\n\n        var properties = mediaGroups[type][groupId][variantLabel];\n\n        var playlistLoader = void 0;\n\n        if (sourceType === 'hls') {\n          playlistLoader = new PlaylistLoader(properties.resolvedUri, hls, withCredentials);\n        } else if (sourceType === 'dash') {\n          playlistLoader = new DashPlaylistLoader(properties.playlists[0], hls, withCredentials, masterPlaylistLoader);\n        }\n\n        properties = videojs$1.mergeOptions({\n          id: variantLabel,\n          playlistLoader: playlistLoader\n        }, properties);\n\n        setupListeners[type](type, properties.playlistLoader, settings);\n\n        groups[groupId].push(properties);\n\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = tech.addRemoteTextTrack({\n            id: variantLabel,\n            kind: 'subtitles',\n            enabled: false,\n            language: properties.language,\n            label: variantLabel\n          }, false).track;\n\n          tracks[variantLabel] = track;\n        }\n      }\n    }\n\n    // setup single error event handler for the segment loader\n    segmentLoader.on('error', onError[type](type, settings));\n  },\n  /**\n   * Setup TextTracks for the closed-caption groups\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize['CLOSED-CAPTIONS']\n   */\n  'CLOSED-CAPTIONS': function CLOSEDCAPTIONS(type, settings) {\n    var tech = settings.tech,\n        mediaGroups = settings.master.mediaGroups,\n        _settings$mediaTypes$3 = settings.mediaTypes[type],\n        groups = _settings$mediaTypes$3.groups,\n        tracks = _settings$mediaTypes$3.tracks;\n\n    for (var groupId in mediaGroups[type]) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      }\n\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        var properties = mediaGroups[type][groupId][variantLabel];\n\n        // We only support CEA608 captions for now, so ignore anything that\n        // doesn't use a CCx INSTREAM-ID\n        if (!properties.instreamId.match(/CC\\d/)) {\n          continue;\n        }\n\n        // No PlaylistLoader is required for Closed-Captions because the captions are\n        // embedded within the video stream\n        groups[groupId].push(videojs$1.mergeOptions({ id: variantLabel }, properties));\n\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = tech.addRemoteTextTrack({\n            id: properties.instreamId,\n            kind: 'captions',\n            enabled: false,\n            language: properties.language,\n            label: variantLabel\n          }, false).track;\n\n          tracks[variantLabel] = track;\n        }\n      }\n    }\n  }\n};\n\n/**\n * Returns a function used to get the active group of the provided type\n *\n * @param {String} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Function that returns the active media group for the provided type. Takes an\n *         optional parameter {TextTrack} track. If no track is provided, a list of all\n *         variants in the group, otherwise the variant corresponding to the provided\n *         track is returned.\n * @function activeGroup\n */\nvar activeGroup = function activeGroup(type, settings) {\n  return function (track) {\n    var masterPlaylistLoader = settings.masterPlaylistLoader,\n        groups = settings.mediaTypes[type].groups;\n\n    var media = masterPlaylistLoader.media();\n\n    if (!media) {\n      return null;\n    }\n\n    var variants = null;\n\n    if (media.attributes[type]) {\n      variants = groups[media.attributes[type]];\n    }\n\n    variants = variants || groups.main;\n\n    if (typeof track === 'undefined') {\n      return variants;\n    }\n\n    if (track === null) {\n      // An active track was specified so a corresponding group is expected. track === null\n      // means no track is currently active so there is no corresponding group\n      return null;\n    }\n\n    return variants.filter(function (props) {\n      return props.id === track.id;\n    })[0] || null;\n  };\n};\n\nvar activeTrack = {\n  /**\n   * Returns a function used to get the active track of type provided\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Function that returns the active media track for the provided type. Returns\n   *         null if no track is active\n   * @function activeTrack.AUDIO\n   */\n  AUDIO: function AUDIO(type, settings) {\n    return function () {\n      var tracks = settings.mediaTypes[type].tracks;\n\n      for (var id in tracks) {\n        if (tracks[id].enabled) {\n          return tracks[id];\n        }\n      }\n\n      return null;\n    };\n  },\n  /**\n   * Returns a function used to get the active track of type provided\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Function that returns the active media track for the provided type. Returns\n   *         null if no track is active\n   * @function activeTrack.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, settings) {\n    return function () {\n      var tracks = settings.mediaTypes[type].tracks;\n\n      for (var id in tracks) {\n        if (tracks[id].mode === 'showing') {\n          return tracks[id];\n        }\n      }\n\n      return null;\n    };\n  }\n};\n\n/**\n * Setup PlaylistLoaders and Tracks for media groups (Audio, Subtitles,\n * Closed-Captions) specified in the master manifest.\n *\n * @param {Object} settings\n *        Object containing required information for setting up the media groups\n * @param {SegmentLoader} settings.segmentLoaders.AUDIO\n *        Audio segment loader\n * @param {SegmentLoader} settings.segmentLoaders.SUBTITLES\n *        Subtitle segment loader\n * @param {SegmentLoader} settings.segmentLoaders.main\n *        Main segment loader\n * @param {Tech} settings.tech\n *        The tech of the player\n * @param {Object} settings.requestOptions\n *        XHR request options used by the segment loaders\n * @param {PlaylistLoader} settings.masterPlaylistLoader\n *        PlaylistLoader for the master source\n * @param {HlsHandler} settings.hls\n *        HLS SourceHandler\n * @param {Object} settings.master\n *        The parsed master manifest\n * @param {Object} settings.mediaTypes\n *        Object to store the loaders, tracks, and utility methods for each media type\n * @param {Function} settings.blacklistCurrentPlaylist\n *        Blacklists the current rendition and forces a rendition switch.\n * @function setupMediaGroups\n */\nvar setupMediaGroups = function setupMediaGroups(settings) {\n  ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(function (type) {\n    initialize[type](type, settings);\n  });\n\n  var mediaTypes = settings.mediaTypes,\n      masterPlaylistLoader = settings.masterPlaylistLoader,\n      tech = settings.tech,\n      hls = settings.hls;\n\n  // setup active group and track getters and change event handlers\n\n  ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n    mediaTypes[type].activeGroup = activeGroup(type, settings);\n    mediaTypes[type].activeTrack = activeTrack[type](type, settings);\n    mediaTypes[type].onGroupChanged = onGroupChanged(type, settings);\n    mediaTypes[type].onTrackChanged = onTrackChanged(type, settings);\n  });\n\n  // DO NOT enable the default subtitle or caption track.\n  // DO enable the default audio track\n  var audioGroup = mediaTypes.AUDIO.activeGroup();\n  var groupId = (audioGroup.filter(function (group) {\n    return group.default;\n  })[0] || audioGroup[0]).id;\n\n  mediaTypes.AUDIO.tracks[groupId].enabled = true;\n  mediaTypes.AUDIO.onTrackChanged();\n\n  masterPlaylistLoader.on('mediachange', function () {\n    ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n      return mediaTypes[type].onGroupChanged();\n    });\n  });\n\n  // custom audio track change event handler for usage event\n  var onAudioTrackChanged = function onAudioTrackChanged() {\n    mediaTypes.AUDIO.onTrackChanged();\n    tech.trigger({ type: 'usage', name: 'hls-audio-change' });\n  };\n\n  tech.audioTracks().addEventListener('change', onAudioTrackChanged);\n  tech.remoteTextTracks().addEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n\n  hls.on('dispose', function () {\n    tech.audioTracks().removeEventListener('change', onAudioTrackChanged);\n    tech.remoteTextTracks().removeEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n  });\n\n  // clear existing audio tracks and add the ones we just created\n  tech.clearTracks('audio');\n\n  for (var id in mediaTypes.AUDIO.tracks) {\n    tech.audioTracks().addTrack(mediaTypes.AUDIO.tracks[id]);\n  }\n};\n\n/**\n * Creates skeleton object used to store the loaders, tracks, and utility methods for each\n * media type\n *\n * @return {Object}\n *         Object to store the loaders, tracks, and utility methods for each media type\n * @function createMediaTypes\n */\nvar createMediaTypes = function createMediaTypes() {\n  var mediaTypes = {};\n\n  ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(function (type) {\n    mediaTypes[type] = {\n      groups: {},\n      tracks: {},\n      activePlaylistLoader: null,\n      activeGroup: noop,\n      activeTrack: noop,\n      onGroupChanged: noop,\n      onTrackChanged: noop\n    };\n  });\n\n  return mediaTypes;\n};\n\n/**\n * @file master-playlist-controller.js\n */\n\nvar ABORT_EARLY_BLACKLIST_SECONDS = 60 * 2;\n\nvar Hls = void 0;\n\n// SegmentLoader stats that need to have each loader's\n// values summed to calculate the final value\nvar loaderStats = ['mediaRequests', 'mediaRequestsAborted', 'mediaRequestsTimedout', 'mediaRequestsErrored', 'mediaTransferDuration', 'mediaBytesTransferred'];\nvar sumLoaderStat = function sumLoaderStat(stat) {\n  return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];\n};\n\n/**\n * the master playlist controller controller all interactons\n * between playlists and segmentloaders. At this time this mainly\n * involves a master playlist and a series of audio playlists\n * if they are available\n *\n * @class MasterPlaylistController\n * @extends videojs.EventTarget\n */\nvar MasterPlaylistController = function (_videojs$EventTarget) {\n  inherits$1(MasterPlaylistController, _videojs$EventTarget);\n\n  function MasterPlaylistController(options) {\n    classCallCheck$1(this, MasterPlaylistController);\n\n    var _this = possibleConstructorReturn$1(this, (MasterPlaylistController.__proto__ || Object.getPrototypeOf(MasterPlaylistController)).call(this));\n\n    var url = options.url,\n        withCredentials = options.withCredentials,\n        tech = options.tech,\n        bandwidth = options.bandwidth,\n        externHls = options.externHls,\n        useCueTags = options.useCueTags,\n        blacklistDuration = options.blacklistDuration,\n        enableLowInitialPlaylist = options.enableLowInitialPlaylist,\n        sourceType = options.sourceType;\n\n    if (!url) {\n      throw new Error('A non-empty playlist URL is required');\n    }\n\n    Hls = externHls;\n\n    _this.withCredentials = withCredentials;\n    _this.tech_ = tech;\n    _this.hls_ = tech.hls;\n    _this.sourceType_ = sourceType;\n    _this.useCueTags_ = useCueTags;\n    _this.blacklistDuration = blacklistDuration;\n    _this.enableLowInitialPlaylist = enableLowInitialPlaylist;\n    if (_this.useCueTags_) {\n      _this.cueTagsTrack_ = _this.tech_.addTextTrack('metadata', 'ad-cues');\n      _this.cueTagsTrack_.inBandMetadataTrackDispatchType = '';\n    }\n\n    _this.requestOptions_ = {\n      withCredentials: _this.withCredentials,\n      timeout: null\n    };\n\n    _this.mediaTypes_ = createMediaTypes();\n\n    _this.mediaSource = new videojs$1.MediaSource();\n\n    // load the media source into the player\n    _this.mediaSource.addEventListener('sourceopen', _this.handleSourceOpen_.bind(_this));\n\n    _this.seekable_ = videojs$1.createTimeRanges();\n    _this.hasPlayed_ = function () {\n      return false;\n    };\n\n    _this.syncController_ = new SyncController(options);\n    _this.segmentMetadataTrack_ = tech.addRemoteTextTrack({\n      kind: 'metadata',\n      label: 'segment-metadata'\n    }, false).track;\n\n    _this.decrypter_ = new Decrypter$1();\n\n    var segmentLoaderSettings = {\n      hls: _this.hls_,\n      mediaSource: _this.mediaSource,\n      currentTime: _this.tech_.currentTime.bind(_this.tech_),\n      seekable: function seekable$$1() {\n        return _this.seekable();\n      },\n      seeking: function seeking() {\n        return _this.tech_.seeking();\n      },\n      duration: function duration$$1() {\n        return _this.mediaSource.duration;\n      },\n      hasPlayed: function hasPlayed() {\n        return _this.hasPlayed_();\n      },\n      goalBufferLength: function goalBufferLength() {\n        return _this.goalBufferLength();\n      },\n      bandwidth: bandwidth,\n      syncController: _this.syncController_,\n      decrypter: _this.decrypter_,\n      sourceType: _this.sourceType_\n    };\n\n    _this.masterPlaylistLoader_ = _this.sourceType_ === 'dash' ? new DashPlaylistLoader(url, _this.hls_, _this.withCredentials) : new PlaylistLoader(url, _this.hls_, _this.withCredentials);\n    _this.setupMasterPlaylistLoaderListeners_();\n\n    // setup segment loaders\n    // combined audio/video or just video when alternate audio track is selected\n    _this.mainSegmentLoader_ = new SegmentLoader(videojs$1.mergeOptions(segmentLoaderSettings, {\n      segmentMetadataTrack: _this.segmentMetadataTrack_,\n      loaderType: 'main'\n    }), options);\n\n    // alternate audio track\n    _this.audioSegmentLoader_ = new SegmentLoader(videojs$1.mergeOptions(segmentLoaderSettings, {\n      loaderType: 'audio'\n    }), options);\n\n    _this.subtitleSegmentLoader_ = new VTTSegmentLoader(videojs$1.mergeOptions(segmentLoaderSettings, {\n      loaderType: 'vtt'\n    }), options);\n\n    _this.setupSegmentLoaderListeners_();\n\n    // Create SegmentLoader stat-getters\n    loaderStats.forEach(function (stat) {\n      _this[stat + '_'] = sumLoaderStat.bind(_this, stat);\n    });\n\n    _this.logger_ = logger('MPC');\n\n    _this.masterPlaylistLoader_.load();\n    return _this;\n  }\n\n  /**\n   * Register event handlers on the master playlist loader. A helper\n   * function for construction time.\n   *\n   * @private\n   */\n\n  createClass$1(MasterPlaylistController, [{\n    key: 'setupMasterPlaylistLoaderListeners_',\n    value: function setupMasterPlaylistLoaderListeners_() {\n      var _this2 = this;\n\n      this.masterPlaylistLoader_.on('loadedmetadata', function () {\n        var media = _this2.masterPlaylistLoader_.media();\n        var requestTimeout = _this2.masterPlaylistLoader_.targetDuration * 1.5 * 1000;\n\n        // If we don't have any more available playlists, we don't want to\n        // timeout the request.\n        if (isLowestEnabledRendition(_this2.masterPlaylistLoader_.master, _this2.masterPlaylistLoader_.media())) {\n          _this2.requestOptions_.timeout = 0;\n        } else {\n          _this2.requestOptions_.timeout = requestTimeout;\n        }\n\n        // if this isn't a live video and preload permits, start\n        // downloading segments\n        if (media.endList && _this2.tech_.preload() !== 'none') {\n          _this2.mainSegmentLoader_.playlist(media, _this2.requestOptions_);\n          _this2.mainSegmentLoader_.load();\n        }\n\n        setupMediaGroups({\n          sourceType: _this2.sourceType_,\n          segmentLoaders: {\n            AUDIO: _this2.audioSegmentLoader_,\n            SUBTITLES: _this2.subtitleSegmentLoader_,\n            main: _this2.mainSegmentLoader_\n          },\n          tech: _this2.tech_,\n          requestOptions: _this2.requestOptions_,\n          masterPlaylistLoader: _this2.masterPlaylistLoader_,\n          hls: _this2.hls_,\n          master: _this2.master(),\n          mediaTypes: _this2.mediaTypes_,\n          blacklistCurrentPlaylist: _this2.blacklistCurrentPlaylist.bind(_this2)\n        });\n\n        _this2.triggerPresenceUsage_(_this2.master(), media);\n\n        try {\n          _this2.setupSourceBuffers_();\n        } catch (e) {\n          videojs$1.log.warn('Failed to create SourceBuffers', e);\n          return _this2.mediaSource.endOfStream('decode');\n        }\n        _this2.setupFirstPlay();\n\n        _this2.trigger('selectedinitialmedia');\n      });\n\n      this.masterPlaylistLoader_.on('loadedplaylist', function () {\n        var updatedPlaylist = _this2.masterPlaylistLoader_.media();\n\n        if (!updatedPlaylist) {\n          // blacklist any variants that are not supported by the browser before selecting\n          // an initial media as the playlist selectors do not consider browser support\n          _this2.excludeUnsupportedVariants_();\n\n          var selectedMedia = void 0;\n\n          if (_this2.enableLowInitialPlaylist) {\n            selectedMedia = _this2.selectInitialPlaylist();\n          }\n\n          if (!selectedMedia) {\n            selectedMedia = _this2.selectPlaylist();\n          }\n\n          _this2.initialMedia_ = selectedMedia;\n          _this2.masterPlaylistLoader_.media(_this2.initialMedia_);\n          return;\n        }\n\n        if (_this2.useCueTags_) {\n          _this2.updateAdCues_(updatedPlaylist);\n        }\n\n        // TODO: Create a new event on the PlaylistLoader that signals\n        // that the segments have changed in some way and use that to\n        // update the SegmentLoader instead of doing it twice here and\n        // on `mediachange`\n        _this2.mainSegmentLoader_.playlist(updatedPlaylist, _this2.requestOptions_);\n        _this2.updateDuration();\n\n        // If the player isn't paused, ensure that the segment loader is running,\n        // as it is possible that it was temporarily stopped while waiting for\n        // a playlist (e.g., in case the playlist errored and we re-requested it).\n        if (!_this2.tech_.paused()) {\n          _this2.mainSegmentLoader_.load();\n        }\n\n        if (!updatedPlaylist.endList) {\n          var addSeekableRange = function addSeekableRange() {\n            var seekable$$1 = _this2.seekable();\n\n            if (seekable$$1.length !== 0) {\n              _this2.mediaSource.addSeekableRange_(seekable$$1.start(0), seekable$$1.end(0));\n            }\n          };\n\n          if (_this2.duration() !== Infinity) {\n            var onDurationchange = function onDurationchange() {\n              if (_this2.duration() === Infinity) {\n                addSeekableRange();\n              } else {\n                _this2.tech_.one('durationchange', onDurationchange);\n              }\n            };\n\n            _this2.tech_.one('durationchange', onDurationchange);\n          } else {\n            addSeekableRange();\n          }\n        }\n      });\n\n      this.masterPlaylistLoader_.on('error', function () {\n        _this2.blacklistCurrentPlaylist(_this2.masterPlaylistLoader_.error);\n      });\n\n      this.masterPlaylistLoader_.on('mediachanging', function () {\n        _this2.mainSegmentLoader_.abort();\n        _this2.mainSegmentLoader_.pause();\n      });\n\n      this.masterPlaylistLoader_.on('mediachange', function () {\n        var media = _this2.masterPlaylistLoader_.media();\n        var requestTimeout = _this2.masterPlaylistLoader_.targetDuration * 1.5 * 1000;\n\n        // If we don't have any more available playlists, we don't want to\n        // timeout the request.\n        if (isLowestEnabledRendition(_this2.masterPlaylistLoader_.master, _this2.masterPlaylistLoader_.media())) {\n          _this2.requestOptions_.timeout = 0;\n        } else {\n          _this2.requestOptions_.timeout = requestTimeout;\n        }\n\n        // TODO: Create a new event on the PlaylistLoader that signals\n        // that the segments have changed in some way and use that to\n        // update the SegmentLoader instead of doing it twice here and\n        // on `loadedplaylist`\n        _this2.mainSegmentLoader_.playlist(media, _this2.requestOptions_);\n        _this2.mainSegmentLoader_.load();\n\n        _this2.tech_.trigger({\n          type: 'mediachange',\n          bubbles: true\n        });\n      });\n\n      this.masterPlaylistLoader_.on('playlistunchanged', function () {\n        var updatedPlaylist = _this2.masterPlaylistLoader_.media();\n        var playlistOutdated = _this2.stuckAtPlaylistEnd_(updatedPlaylist);\n\n        if (playlistOutdated) {\n          // Playlist has stopped updating and we're stuck at its end. Try to\n          // blacklist it and switch to another playlist in the hope that that\n          // one is updating (and give the player a chance to re-adjust to the\n          // safe live point).\n          _this2.blacklistCurrentPlaylist({\n            message: 'Playlist no longer updating.'\n          });\n          // useful for monitoring QoS\n          _this2.tech_.trigger('playliststuck');\n        }\n      });\n\n      this.masterPlaylistLoader_.on('renditiondisabled', function () {\n        _this2.tech_.trigger({ type: 'usage', name: 'hls-rendition-disabled' });\n      });\n      this.masterPlaylistLoader_.on('renditionenabled', function () {\n        _this2.tech_.trigger({ type: 'usage', name: 'hls-rendition-enabled' });\n      });\n    }\n\n    /**\n     * A helper function for triggerring presence usage events once per source\n     *\n     * @private\n     */\n\n  }, {\n    key: 'triggerPresenceUsage_',\n    value: function triggerPresenceUsage_(master, media) {\n      var mediaGroups = master.mediaGroups || {};\n      var defaultDemuxed = true;\n      var audioGroupKeys = Object.keys(mediaGroups.AUDIO);\n\n      for (var mediaGroup in mediaGroups.AUDIO) {\n        for (var label in mediaGroups.AUDIO[mediaGroup]) {\n          var properties = mediaGroups.AUDIO[mediaGroup][label];\n\n          if (!properties.uri) {\n            defaultDemuxed = false;\n          }\n        }\n      }\n\n      if (defaultDemuxed) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-demuxed' });\n      }\n\n      if (Object.keys(mediaGroups.SUBTITLES).length) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-webvtt' });\n      }\n\n      if (Hls.Playlist.isAes(media)) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-aes' });\n      }\n\n      if (Hls.Playlist.isFmp4(media)) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-fmp4' });\n      }\n\n      if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-alternate-audio' });\n      }\n\n      if (this.useCueTags_) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-playlist-cue-tags' });\n      }\n    }\n    /**\n     * Register event handlers on the segment loaders. A helper function\n     * for construction time.\n     *\n     * @private\n     */\n\n  }, {\n    key: 'setupSegmentLoaderListeners_',\n    value: function setupSegmentLoaderListeners_() {\n      var _this3 = this;\n\n      this.mainSegmentLoader_.on('bandwidthupdate', function () {\n        var nextPlaylist = _this3.selectPlaylist();\n        var currentPlaylist = _this3.masterPlaylistLoader_.media();\n        var buffered = _this3.tech_.buffered();\n        var forwardBuffer = buffered.length ? buffered.end(buffered.length - 1) - _this3.tech_.currentTime() : 0;\n\n        var bufferLowWaterLine = _this3.bufferLowWaterLine();\n\n        // If the playlist is live, then we want to not take low water line into account.\n        // This is because in LIVE, the player plays 3 segments from the end of the\n        // playlist, and if `BUFFER_LOW_WATER_LINE` is greater than the duration availble\n        // in those segments, a viewer will never experience a rendition upswitch.\n        if (!currentPlaylist.endList ||\n        // For the same reason as LIVE, we ignore the low water line when the VOD\n        // duration is below the max potential low water line\n        _this3.duration() < Config.MAX_BUFFER_LOW_WATER_LINE ||\n        // we want to switch down to lower resolutions quickly to continue playback, but\n        nextPlaylist.attributes.BANDWIDTH < currentPlaylist.attributes.BANDWIDTH ||\n        // ensure we have some buffer before we switch up to prevent us running out of\n        // buffer while loading a higher rendition.\n        forwardBuffer >= bufferLowWaterLine) {\n          _this3.masterPlaylistLoader_.media(nextPlaylist);\n        }\n\n        _this3.tech_.trigger('bandwidthupdate');\n      });\n      this.mainSegmentLoader_.on('progress', function () {\n        _this3.trigger('progress');\n      });\n\n      this.mainSegmentLoader_.on('error', function () {\n        _this3.blacklistCurrentPlaylist(_this3.mainSegmentLoader_.error());\n      });\n\n      this.mainSegmentLoader_.on('syncinfoupdate', function () {\n        _this3.onSyncInfoUpdate_();\n      });\n\n      this.mainSegmentLoader_.on('timestampoffset', function () {\n        _this3.tech_.trigger({ type: 'usage', name: 'hls-timestamp-offset' });\n      });\n      this.audioSegmentLoader_.on('syncinfoupdate', function () {\n        _this3.onSyncInfoUpdate_();\n      });\n\n      this.mainSegmentLoader_.on('ended', function () {\n        _this3.onEndOfStream();\n      });\n\n      this.mainSegmentLoader_.on('earlyabort', function () {\n        _this3.blacklistCurrentPlaylist({\n          message: 'Aborted early because there isn\\'t enough bandwidth to complete the ' + 'request without rebuffering.'\n        }, ABORT_EARLY_BLACKLIST_SECONDS);\n      });\n\n      this.mainSegmentLoader_.on('reseteverything', function () {\n        // If playing an MTS stream, a videojs.MediaSource is listening for\n        // hls-reset to reset caption parsing state in the transmuxer\n        _this3.tech_.trigger('hls-reset');\n      });\n\n      this.mainSegmentLoader_.on('segmenttimemapping', function (event) {\n        // If playing an MTS stream in html, a videojs.MediaSource is listening for\n        // hls-segment-time-mapping update its internal mapping of stream to display time\n        _this3.tech_.trigger({\n          type: 'hls-segment-time-mapping',\n          mapping: event.mapping\n        });\n      });\n\n      this.audioSegmentLoader_.on('ended', function () {\n        _this3.onEndOfStream();\n      });\n    }\n  }, {\n    key: 'mediaSecondsLoaded_',\n    value: function mediaSecondsLoaded_() {\n      return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);\n    }\n\n    /**\n     * Call load on our SegmentLoaders\n     */\n\n  }, {\n    key: 'load',\n    value: function load() {\n      this.mainSegmentLoader_.load();\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        this.audioSegmentLoader_.load();\n      }\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n        this.subtitleSegmentLoader_.load();\n      }\n    }\n\n    /**\n     * Re-tune playback quality level for the current player\n     * conditions. This method may perform destructive actions, like\n     * removing already buffered content, to readjust the currently\n     * active playlist quickly.\n     *\n     * @private\n     */\n\n  }, {\n    key: 'fastQualityChange_',\n    value: function fastQualityChange_() {\n      var media = this.selectPlaylist();\n\n      if (media !== this.masterPlaylistLoader_.media()) {\n        this.masterPlaylistLoader_.media(media);\n\n        this.mainSegmentLoader_.resetLoader();\n        // don't need to reset audio as it is reset when media changes\n      }\n    }\n\n    /**\n     * Begin playback.\n     */\n\n  }, {\n    key: 'play',\n    value: function play() {\n      if (this.setupFirstPlay()) {\n        return;\n      }\n\n      if (this.tech_.ended()) {\n        this.tech_.setCurrentTime(0);\n      }\n\n      if (this.hasPlayed_()) {\n        this.load();\n      }\n\n      var seekable$$1 = this.tech_.seekable();\n\n      // if the viewer has paused and we fell out of the live window,\n      // seek forward to the live point\n      if (this.tech_.duration() === Infinity) {\n        if (this.tech_.currentTime() < seekable$$1.start(0)) {\n          return this.tech_.setCurrentTime(seekable$$1.end(seekable$$1.length - 1));\n        }\n      }\n    }\n\n    /**\n     * Seek to the latest media position if this is a live video and the\n     * player and video are loaded and initialized.\n     */\n\n  }, {\n    key: 'setupFirstPlay',\n    value: function setupFirstPlay() {\n      var _this4 = this;\n\n      var media = this.masterPlaylistLoader_.media();\n\n      // Check that everything is ready to begin buffering for the first call to play\n      //  If 1) there is no active media\n      //     2) the player is paused\n      //     3) the first play has already been setup\n      // then exit early\n      if (!media || this.tech_.paused() || this.hasPlayed_()) {\n        return false;\n      }\n\n      // when the video is a live stream\n      if (!media.endList) {\n        var seekable$$1 = this.seekable();\n\n        if (!seekable$$1.length) {\n          // without a seekable range, the player cannot seek to begin buffering at the live\n          // point\n          return false;\n        }\n\n        if (videojs$1.browser.IE_VERSION && this.tech_.readyState() === 0) {\n          // IE11 throws an InvalidStateError if you try to set currentTime while the\n          // readyState is 0, so it must be delayed until the tech fires loadedmetadata.\n          this.tech_.one('loadedmetadata', function () {\n            _this4.trigger('firstplay');\n            _this4.tech_.setCurrentTime(seekable$$1.end(0));\n            _this4.hasPlayed_ = function () {\n              return true;\n            };\n          });\n\n          return false;\n        }\n\n        // trigger firstplay to inform the source handler to ignore the next seek event\n        this.trigger('firstplay');\n        // seek to the live point\n        this.tech_.setCurrentTime(seekable$$1.end(0));\n      }\n\n      this.hasPlayed_ = function () {\n        return true;\n      };\n      // we can begin loading now that everything is ready\n      this.load();\n      return true;\n    }\n\n    /**\n     * handle the sourceopen event on the MediaSource\n     *\n     * @private\n     */\n\n  }, {\n    key: 'handleSourceOpen_',\n    value: function handleSourceOpen_() {\n      // Only attempt to create the source buffer if none already exist.\n      // handleSourceOpen is also called when we are \"re-opening\" a source buffer\n      // after `endOfStream` has been called (in response to a seek for instance)\n      try {\n        this.setupSourceBuffers_();\n      } catch (e) {\n        videojs$1.log.warn('Failed to create Source Buffers', e);\n        return this.mediaSource.endOfStream('decode');\n      }\n\n      // if autoplay is enabled, begin playback. This is duplicative of\n      // code in video.js but is required because play() must be invoked\n      // *after* the media source has opened.\n      if (this.tech_.autoplay()) {\n        var playPromise = this.tech_.play();\n\n        // Catch/silence error when a pause interrupts a play request\n        // on browsers which return a promise\n        if (typeof playPromise !== 'undefined' && typeof playPromise.then === 'function') {\n          playPromise.then(null, function (e) {});\n        }\n      }\n\n      this.trigger('sourceopen');\n    }\n\n    /**\n     * Calls endOfStream on the media source when all active stream types have called\n     * endOfStream\n     *\n     * @param {string} streamType\n     *        Stream type of the segment loader that called endOfStream\n     * @private\n     */\n\n  }, {\n    key: 'onEndOfStream',\n    value: function onEndOfStream() {\n      var isEndOfStream = this.mainSegmentLoader_.ended_;\n\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        // if the audio playlist loader exists, then alternate audio is active\n        if (!this.mainSegmentLoader_.startingMedia_ || this.mainSegmentLoader_.startingMedia_.containsVideo) {\n          // if we do not know if the main segment loader contains video yet or if we\n          // definitively know the main segment loader contains video, then we need to wait\n          // for both main and audio segment loaders to call endOfStream\n          isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;\n        } else {\n          // otherwise just rely on the audio loader\n          isEndOfStream = this.audioSegmentLoader_.ended_;\n        }\n      }\n\n      if (isEndOfStream) {\n        this.mediaSource.endOfStream();\n      }\n    }\n\n    /**\n     * Check if a playlist has stopped being updated\n     * @param {Object} playlist the media playlist object\n     * @return {boolean} whether the playlist has stopped being updated or not\n     */\n\n  }, {\n    key: 'stuckAtPlaylistEnd_',\n    value: function stuckAtPlaylistEnd_(playlist) {\n      var seekable$$1 = this.seekable();\n\n      if (!seekable$$1.length) {\n        // playlist doesn't have enough information to determine whether we are stuck\n        return false;\n      }\n\n      var expired = this.syncController_.getExpiredTime(playlist, this.mediaSource.duration);\n\n      if (expired === null) {\n        return false;\n      }\n\n      // does not use the safe live end to calculate playlist end, since we\n      // don't want to say we are stuck while there is still content\n      var absolutePlaylistEnd = Hls.Playlist.playlistEnd(playlist, expired);\n      var currentTime = this.tech_.currentTime();\n      var buffered = this.tech_.buffered();\n\n      if (!buffered.length) {\n        // return true if the playhead reached the absolute end of the playlist\n        return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;\n      }\n      var bufferedEnd = buffered.end(buffered.length - 1);\n\n      // return true if there is too little buffer left and buffer has reached absolute\n      // end of playlist\n      return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;\n    }\n\n    /**\n     * Blacklists a playlist when an error occurs for a set amount of time\n     * making it unavailable for selection by the rendition selection algorithm\n     * and then forces a new playlist (rendition) selection.\n     *\n     * @param {Object=} error an optional error that may include the playlist\n     * to blacklist\n     * @param {Number=} blacklistDuration an optional number of seconds to blacklist the\n     * playlist\n     */\n\n  }, {\n    key: 'blacklistCurrentPlaylist',\n    value: function blacklistCurrentPlaylist() {\n      var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var blacklistDuration = arguments[1];\n\n      var currentPlaylist = void 0;\n      var nextPlaylist = void 0;\n\n      // If the `error` was generated by the playlist loader, it will contain\n      // the playlist we were trying to load (but failed) and that should be\n      // blacklisted instead of the currently selected playlist which is likely\n      // out-of-date in this scenario\n      currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();\n\n      blacklistDuration = blacklistDuration || error.blacklistDuration || this.blacklistDuration;\n\n      // If there is no current playlist, then an error occurred while we were\n      // trying to load the master OR while we were disposing of the tech\n      if (!currentPlaylist) {\n        this.error = error;\n\n        try {\n          return this.mediaSource.endOfStream('network');\n        } catch (e) {\n          return this.trigger('error');\n        }\n      }\n\n      var isFinalRendition = this.masterPlaylistLoader_.master.playlists.filter(isEnabled).length === 1;\n\n      if (isFinalRendition) {\n        // Never blacklisting this playlist because it's final rendition\n        videojs$1.log.warn('Problem encountered with the current ' + 'HLS playlist. Trying again since it is the final playlist.');\n\n        this.tech_.trigger('retryplaylist');\n        return this.masterPlaylistLoader_.load(isFinalRendition);\n      }\n      // Blacklist this playlist\n      currentPlaylist.excludeUntil = Date.now() + blacklistDuration * 1000;\n      this.tech_.trigger('blacklistplaylist');\n      this.tech_.trigger({ type: 'usage', name: 'hls-rendition-blacklisted' });\n\n      // Select a new playlist\n      nextPlaylist = this.selectPlaylist();\n      videojs$1.log.warn('Problem encountered with the current HLS playlist.' + (error.message ? ' ' + error.message : '') + ' Switching to another playlist.');\n\n      return this.masterPlaylistLoader_.media(nextPlaylist);\n    }\n\n    /**\n     * Pause all segment loaders\n     */\n\n  }, {\n    key: 'pauseLoading',\n    value: function pauseLoading() {\n      this.mainSegmentLoader_.pause();\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        this.audioSegmentLoader_.pause();\n      }\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n        this.subtitleSegmentLoader_.pause();\n      }\n    }\n\n    /**\n     * set the current time on all segment loaders\n     *\n     * @param {TimeRange} currentTime the current time to set\n     * @return {TimeRange} the current time\n     */\n\n  }, {\n    key: 'setCurrentTime',\n    value: function setCurrentTime(currentTime) {\n      var buffered = findRange(this.tech_.buffered(), currentTime);\n\n      if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media())) {\n        // return immediately if the metadata is not ready yet\n        return 0;\n      }\n\n      // it's clearly an edge-case but don't thrown an error if asked to\n      // seek within an empty playlist\n      if (!this.masterPlaylistLoader_.media().segments) {\n        return 0;\n      }\n\n      // In flash playback, the segment loaders should be reset on every seek, even\n      // in buffer seeks. If the seek location is already buffered, continue buffering as\n      // usual\n      // TODO: redo this comment\n      if (buffered && buffered.length) {\n        return currentTime;\n      }\n\n      // cancel outstanding requests so we begin buffering at the new\n      // location\n      this.mainSegmentLoader_.resetEverything();\n      this.mainSegmentLoader_.abort();\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        this.audioSegmentLoader_.resetEverything();\n        this.audioSegmentLoader_.abort();\n      }\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n        this.subtitleSegmentLoader_.resetEverything();\n        this.subtitleSegmentLoader_.abort();\n      }\n\n      // start segment loader loading in case they are paused\n      this.load();\n    }\n\n    /**\n     * get the current duration\n     *\n     * @return {TimeRange} the duration\n     */\n\n  }, {\n    key: 'duration',\n    value: function duration$$1() {\n      if (!this.masterPlaylistLoader_) {\n        return 0;\n      }\n\n      if (this.mediaSource) {\n        return this.mediaSource.duration;\n      }\n\n      return Hls.Playlist.duration(this.masterPlaylistLoader_.media());\n    }\n\n    /**\n     * check the seekable range\n     *\n     * @return {TimeRange} the seekable range\n     */\n\n  }, {\n    key: 'seekable',\n    value: function seekable$$1() {\n      return this.seekable_;\n    }\n  }, {\n    key: 'onSyncInfoUpdate_',\n    value: function onSyncInfoUpdate_() {\n      var mainSeekable = void 0;\n      var audioSeekable = void 0;\n\n      if (!this.masterPlaylistLoader_) {\n        return;\n      }\n\n      var media = this.masterPlaylistLoader_.media();\n\n      if (!media) {\n        return;\n      }\n\n      var expired = this.syncController_.getExpiredTime(media, this.mediaSource.duration);\n\n      if (expired === null) {\n        // not enough information to update seekable\n        return;\n      }\n\n      mainSeekable = Hls.Playlist.seekable(media, expired);\n\n      if (mainSeekable.length === 0) {\n        return;\n      }\n\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();\n        expired = this.syncController_.getExpiredTime(media, this.mediaSource.duration);\n\n        if (expired === null) {\n          return;\n        }\n\n        audioSeekable = Hls.Playlist.seekable(media, expired);\n\n        if (audioSeekable.length === 0) {\n          return;\n        }\n      }\n\n      if (!audioSeekable) {\n        // seekable has been calculated based on buffering video data so it\n        // can be returned directly\n        this.seekable_ = mainSeekable;\n      } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {\n        // seekables are pretty far off, rely on main\n        this.seekable_ = mainSeekable;\n      } else {\n        this.seekable_ = videojs$1.createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);\n      }\n\n      this.logger_('seekable updated [' + printableRange(this.seekable_) + ']');\n\n      this.tech_.trigger('seekablechanged');\n    }\n\n    /**\n     * Update the player duration\n     */\n\n  }, {\n    key: 'updateDuration',\n    value: function updateDuration() {\n      var _this5 = this;\n\n      var oldDuration = this.mediaSource.duration;\n      var newDuration = Hls.Playlist.duration(this.masterPlaylistLoader_.media());\n      var buffered = this.tech_.buffered();\n      var setDuration = function setDuration() {\n        _this5.mediaSource.duration = newDuration;\n        _this5.tech_.trigger('durationchange');\n\n        _this5.mediaSource.removeEventListener('sourceopen', setDuration);\n      };\n\n      if (buffered.length > 0) {\n        newDuration = Math.max(newDuration, buffered.end(buffered.length - 1));\n      }\n\n      // if the duration has changed, invalidate the cached value\n      if (oldDuration !== newDuration) {\n        // update the duration\n        if (this.mediaSource.readyState !== 'open') {\n          this.mediaSource.addEventListener('sourceopen', setDuration);\n        } else {\n          setDuration();\n        }\n      }\n    }\n\n    /**\n     * dispose of the MasterPlaylistController and everything\n     * that it controls\n     */\n\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      var _this6 = this;\n\n      this.decrypter_.terminate();\n      this.masterPlaylistLoader_.dispose();\n      this.mainSegmentLoader_.dispose();\n\n      ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n        var groups = _this6.mediaTypes_[type].groups;\n\n        for (var id in groups) {\n          groups[id].forEach(function (group) {\n            if (group.playlistLoader) {\n              group.playlistLoader.dispose();\n            }\n          });\n        }\n      });\n\n      this.audioSegmentLoader_.dispose();\n      this.subtitleSegmentLoader_.dispose();\n    }\n\n    /**\n     * return the master playlist object if we have one\n     *\n     * @return {Object} the master playlist object that we parsed\n     */\n\n  }, {\n    key: 'master',\n    value: function master() {\n      return this.masterPlaylistLoader_.master;\n    }\n\n    /**\n     * return the currently selected playlist\n     *\n     * @return {Object} the currently selected playlist object that we parsed\n     */\n\n  }, {\n    key: 'media',\n    value: function media() {\n      // playlist loader will not return media if it has not been fully loaded\n      return this.masterPlaylistLoader_.media() || this.initialMedia_;\n    }\n\n    /**\n     * setup our internal source buffers on our segment Loaders\n     *\n     * @private\n     */\n\n  }, {\n    key: 'setupSourceBuffers_',\n    value: function setupSourceBuffers_() {\n      var media = this.masterPlaylistLoader_.media();\n      var mimeTypes = void 0;\n\n      // wait until a media playlist is available and the Media Source is\n      // attached\n      if (!media || this.mediaSource.readyState !== 'open') {\n        return;\n      }\n\n      mimeTypes = mimeTypesForPlaylist(this.masterPlaylistLoader_.master, media);\n      if (mimeTypes.length < 1) {\n        this.error = 'No compatible SourceBuffer configuration for the variant stream:' + media.resolvedUri;\n        return this.mediaSource.endOfStream('decode');\n      }\n\n      this.configureLoaderMimeTypes_(mimeTypes);\n      // exclude any incompatible variant streams from future playlist\n      // selection\n      this.excludeIncompatibleVariants_(media);\n    }\n  }, {\n    key: 'configureLoaderMimeTypes_',\n    value: function configureLoaderMimeTypes_(mimeTypes) {\n      // If the content is demuxed, we can't start appending segments to a source buffer\n      // until both source buffers are set up, or else the browser may not let us add the\n      // second source buffer (it will assume we are playing either audio only or video\n      // only).\n      var sourceBufferEmitter =\n      // If there is more than one mime type\n      mimeTypes.length > 1 &&\n      // and the first mime type does not have muxed video and audio\n      mimeTypes[0].indexOf(',') === -1 &&\n      // and the two mime types are different (they can be the same in the case of audio\n      // only with alternate audio)\n      mimeTypes[0] !== mimeTypes[1] ?\n      // then we want to wait on the second source buffer\n      new videojs$1.EventTarget() :\n      // otherwise there is no need to wait as the content is either audio only,\n      // video only, or muxed content.\n      null;\n\n      this.mainSegmentLoader_.mimeType(mimeTypes[0], sourceBufferEmitter);\n      if (mimeTypes[1]) {\n        this.audioSegmentLoader_.mimeType(mimeTypes[1], sourceBufferEmitter);\n      }\n    }\n\n    /**\n     * Blacklists playlists with codecs that are unsupported by the browser.\n     */\n\n  }, {\n    key: 'excludeUnsupportedVariants_',\n    value: function excludeUnsupportedVariants_() {\n      this.master().playlists.forEach(function (variant) {\n        if (variant.attributes.CODECS && global_window__WEBPACK_IMPORTED_MODULE_0___default.a.MediaSource && global_window__WEBPACK_IMPORTED_MODULE_0___default.a.MediaSource.isTypeSupported && !global_window__WEBPACK_IMPORTED_MODULE_0___default.a.MediaSource.isTypeSupported('video/mp4; codecs=\"' + mapLegacyAvcCodecs(variant.attributes.CODECS) + '\"')) {\n          variant.excludeUntil = Infinity;\n        }\n      });\n    }\n\n    /**\n     * Blacklist playlists that are known to be codec or\n     * stream-incompatible with the SourceBuffer configuration. For\n     * instance, Media Source Extensions would cause the video element to\n     * stall waiting for video data if you switched from a variant with\n     * video and audio to an audio-only one.\n     *\n     * @param {Object} media a media playlist compatible with the current\n     * set of SourceBuffers. Variants in the current master playlist that\n     * do not appear to have compatible codec or stream configurations\n     * will be excluded from the default playlist selection algorithm\n     * indefinitely.\n     * @private\n     */\n\n  }, {\n    key: 'excludeIncompatibleVariants_',\n    value: function excludeIncompatibleVariants_(media) {\n      var codecCount = 2;\n      var videoCodec = null;\n      var codecs = void 0;\n\n      if (media.attributes.CODECS) {\n        codecs = parseCodecs(media.attributes.CODECS);\n        videoCodec = codecs.videoCodec;\n        codecCount = codecs.codecCount;\n      }\n\n      this.master().playlists.forEach(function (variant) {\n        var variantCodecs = {\n          codecCount: 2,\n          videoCodec: null\n        };\n\n        if (variant.attributes.CODECS) {\n          variantCodecs = parseCodecs(variant.attributes.CODECS);\n        }\n\n        // if the streams differ in the presence or absence of audio or\n        // video, they are incompatible\n        if (variantCodecs.codecCount !== codecCount) {\n          variant.excludeUntil = Infinity;\n        }\n\n        // if h.264 is specified on the current playlist, some flavor of\n        // it must be specified on all compatible variants\n        if (variantCodecs.videoCodec !== videoCodec) {\n          variant.excludeUntil = Infinity;\n        }\n      });\n    }\n  }, {\n    key: 'updateAdCues_',\n    value: function updateAdCues_(media) {\n      var offset = 0;\n      var seekable$$1 = this.seekable();\n\n      if (seekable$$1.length) {\n        offset = seekable$$1.start(0);\n      }\n\n      updateAdCues(media, this.cueTagsTrack_, offset);\n    }\n\n    /**\n     * Calculates the desired forward buffer length based on current time\n     *\n     * @return {Number} Desired forward buffer length in seconds\n     */\n\n  }, {\n    key: 'goalBufferLength',\n    value: function goalBufferLength() {\n      var currentTime = this.tech_.currentTime();\n      var initial = Config.GOAL_BUFFER_LENGTH;\n      var rate = Config.GOAL_BUFFER_LENGTH_RATE;\n      var max = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);\n\n      return Math.min(initial + currentTime * rate, max);\n    }\n\n    /**\n     * Calculates the desired buffer low water line based on current time\n     *\n     * @return {Number} Desired buffer low water line in seconds\n     */\n\n  }, {\n    key: 'bufferLowWaterLine',\n    value: function bufferLowWaterLine() {\n      var currentTime = this.tech_.currentTime();\n      var initial = Config.BUFFER_LOW_WATER_LINE;\n      var rate = Config.BUFFER_LOW_WATER_LINE_RATE;\n      var max = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE);\n\n      return Math.min(initial + currentTime * rate, max);\n    }\n  }]);\n  return MasterPlaylistController;\n}(videojs$1.EventTarget);\n\n/**\n * Returns a function that acts as the Enable/disable playlist function.\n *\n * @param {PlaylistLoader} loader - The master playlist loader\n * @param {String} playlistUri - uri of the playlist\n * @param {Function} changePlaylistFn - A function to be called after a\n * playlist's enabled-state has been changed. Will NOT be called if a\n * playlist's enabled-state is unchanged\n * @param {Boolean=} enable - Value to set the playlist enabled-state to\n * or if undefined returns the current enabled-state for the playlist\n * @return {Function} Function for setting/getting enabled\n */\nvar enableFunction = function enableFunction(loader, playlistUri, changePlaylistFn) {\n  return function (enable) {\n    var playlist = loader.master.playlists[playlistUri];\n    var incompatible = isIncompatible(playlist);\n    var currentlyEnabled = isEnabled(playlist);\n\n    if (typeof enable === 'undefined') {\n      return currentlyEnabled;\n    }\n\n    if (enable) {\n      delete playlist.disabled;\n    } else {\n      playlist.disabled = true;\n    }\n\n    if (enable !== currentlyEnabled && !incompatible) {\n      // Ensure the outside world knows about our changes\n      changePlaylistFn();\n      if (enable) {\n        loader.trigger('renditionenabled');\n      } else {\n        loader.trigger('renditiondisabled');\n      }\n    }\n    return enable;\n  };\n};\n\n/**\n * The representation object encapsulates the publicly visible information\n * in a media playlist along with a setter/getter-type function (enabled)\n * for changing the enabled-state of a particular playlist entry\n *\n * @class Representation\n */\n\nvar Representation = function Representation(hlsHandler, playlist, id) {\n  classCallCheck$1(this, Representation);\n\n  // Get a reference to a bound version of fastQualityChange_\n  var fastChangeFunction = hlsHandler.masterPlaylistController_.fastQualityChange_.bind(hlsHandler.masterPlaylistController_);\n\n  // some playlist attributes are optional\n  if (playlist.attributes.RESOLUTION) {\n    var resolution = playlist.attributes.RESOLUTION;\n\n    this.width = resolution.width;\n    this.height = resolution.height;\n  }\n\n  this.bandwidth = playlist.attributes.BANDWIDTH;\n\n  // The id is simply the ordinality of the media playlist\n  // within the master playlist\n  this.id = id;\n\n  // Partially-apply the enableFunction to create a playlist-\n  // specific variant\n  this.enabled = enableFunction(hlsHandler.playlists, playlist.uri, fastChangeFunction);\n};\n\n/**\n * A mixin function that adds the `representations` api to an instance\n * of the HlsHandler class\n * @param {HlsHandler} hlsHandler - An instance of HlsHandler to add the\n * representation API into\n */\n\nvar renditionSelectionMixin = function renditionSelectionMixin(hlsHandler) {\n  var playlists = hlsHandler.playlists;\n\n  // Add a single API-specific function to the HlsHandler instance\n  hlsHandler.representations = function () {\n    return playlists.master.playlists.filter(function (media) {\n      return !isIncompatible(media);\n    }).map(function (e, i) {\n      return new Representation(hlsHandler, e, e.uri);\n    });\n  };\n};\n\n/**\n * @file playback-watcher.js\n *\n * Playback starts, and now my watch begins. It shall not end until my death. I shall\n * take no wait, hold no uncleared timeouts, father no bad seeks. I shall wear no crowns\n * and win no glory. I shall live and die at my post. I am the corrector of the underflow.\n * I am the watcher of gaps. I am the shield that guards the realms of seekable. I pledge\n * my life and honor to the Playback Watch, for this Player and all the Players to come.\n */\n\n// Set of events that reset the playback-watcher time check logic and clear the timeout\nvar timerCancelEvents = ['seeking', 'seeked', 'pause', 'playing', 'error'];\n\n/**\n * @class PlaybackWatcher\n */\n\nvar PlaybackWatcher = function () {\n  /**\n   * Represents an PlaybackWatcher object.\n   * @constructor\n   * @param {object} options an object that includes the tech and settings\n   */\n  function PlaybackWatcher(options) {\n    var _this = this;\n\n    classCallCheck$1(this, PlaybackWatcher);\n\n    this.tech_ = options.tech;\n    this.seekable = options.seekable;\n\n    this.consecutiveUpdates = 0;\n    this.lastRecordedTime = null;\n    this.timer_ = null;\n    this.checkCurrentTimeTimeout_ = null;\n    this.logger_ = logger('PlaybackWatcher');\n\n    this.logger_('initialize');\n\n    var canPlayHandler = function canPlayHandler() {\n      return _this.monitorCurrentTime_();\n    };\n    var waitingHandler = function waitingHandler() {\n      return _this.techWaiting_();\n    };\n    var cancelTimerHandler = function cancelTimerHandler() {\n      return _this.cancelTimer_();\n    };\n    var fixesBadSeeksHandler = function fixesBadSeeksHandler() {\n      return _this.fixesBadSeeks_();\n    };\n\n    this.tech_.on('seekablechanged', fixesBadSeeksHandler);\n    this.tech_.on('waiting', waitingHandler);\n    this.tech_.on(timerCancelEvents, cancelTimerHandler);\n    this.tech_.on('canplay', canPlayHandler);\n\n    // Define the dispose function to clean up our events\n    this.dispose = function () {\n      _this.logger_('dispose');\n      _this.tech_.off('seekablechanged', fixesBadSeeksHandler);\n      _this.tech_.off('waiting', waitingHandler);\n      _this.tech_.off(timerCancelEvents, cancelTimerHandler);\n      _this.tech_.off('canplay', canPlayHandler);\n      if (_this.checkCurrentTimeTimeout_) {\n        global_window__WEBPACK_IMPORTED_MODULE_0___default.a.clearTimeout(_this.checkCurrentTimeTimeout_);\n      }\n      _this.cancelTimer_();\n    };\n  }\n\n  /**\n   * Periodically check current time to see if playback stopped\n   *\n   * @private\n   */\n\n  createClass$1(PlaybackWatcher, [{\n    key: 'monitorCurrentTime_',\n    value: function monitorCurrentTime_() {\n      this.checkCurrentTime_();\n\n      if (this.checkCurrentTimeTimeout_) {\n        global_window__WEBPACK_IMPORTED_MODULE_0___default.a.clearTimeout(this.checkCurrentTimeTimeout_);\n      }\n\n      // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n      this.checkCurrentTimeTimeout_ = global_window__WEBPACK_IMPORTED_MODULE_0___default.a.setTimeout(this.monitorCurrentTime_.bind(this), 250);\n    }\n\n    /**\n     * The purpose of this function is to emulate the \"waiting\" event on\n     * browsers that do not emit it when they are waiting for more\n     * data to continue playback\n     *\n     * @private\n     */\n\n  }, {\n    key: 'checkCurrentTime_',\n    value: function checkCurrentTime_() {\n      if (this.tech_.seeking() && this.fixesBadSeeks_()) {\n        this.consecutiveUpdates = 0;\n        this.lastRecordedTime = this.tech_.currentTime();\n        return;\n      }\n\n      if (this.tech_.paused() || this.tech_.seeking()) {\n        return;\n      }\n\n      var currentTime = this.tech_.currentTime();\n      var buffered = this.tech_.buffered();\n\n      if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) {\n        // If current time is at the end of the final buffered region, then any playback\n        // stall is most likely caused by buffering in a low bandwidth environment. The tech\n        // should fire a `waiting` event in this scenario, but due to browser and tech\n        // inconsistencies. Calling `techWaiting_` here allows us to simulate\n        // responding to a native `waiting` event when the tech fails to emit one.\n        return this.techWaiting_();\n      }\n\n      if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {\n        this.consecutiveUpdates++;\n        this.waiting_();\n      } else if (currentTime === this.lastRecordedTime) {\n        this.consecutiveUpdates++;\n      } else {\n        this.consecutiveUpdates = 0;\n        this.lastRecordedTime = currentTime;\n      }\n    }\n\n    /**\n     * Cancels any pending timers and resets the 'timeupdate' mechanism\n     * designed to detect that we are stalled\n     *\n     * @private\n     */\n\n  }, {\n    key: 'cancelTimer_',\n    value: function cancelTimer_() {\n      this.consecutiveUpdates = 0;\n\n      if (this.timer_) {\n        this.logger_('cancelTimer_');\n        clearTimeout(this.timer_);\n      }\n\n      this.timer_ = null;\n    }\n\n    /**\n     * Fixes situations where there's a bad seek\n     *\n     * @return {Boolean} whether an action was taken to fix the seek\n     * @private\n     */\n\n  }, {\n    key: 'fixesBadSeeks_',\n    value: function fixesBadSeeks_() {\n      var seeking = this.tech_.seeking();\n      var seekable = this.seekable();\n      var currentTime = this.tech_.currentTime();\n      var seekTo = void 0;\n\n      if (seeking && this.afterSeekableWindow_(seekable, currentTime)) {\n        var seekableEnd = seekable.end(seekable.length - 1);\n\n        // sync to live point (if VOD, our seekable was updated and we're simply adjusting)\n        seekTo = seekableEnd;\n      }\n\n      if (seeking && this.beforeSeekableWindow_(seekable, currentTime)) {\n        var seekableStart = seekable.start(0);\n\n        // sync to the beginning of the live window\n        // provide a buffer of .1 seconds to handle rounding/imprecise numbers\n        seekTo = seekableStart + SAFE_TIME_DELTA;\n      }\n\n      if (typeof seekTo !== 'undefined') {\n        this.logger_('Trying to seek outside of seekable at time ' + currentTime + ' with ' + ('seekable range ' + printableRange(seekable) + '. Seeking to ') + (seekTo + '.'));\n\n        this.tech_.setCurrentTime(seekTo);\n        return true;\n      }\n\n      return false;\n    }\n\n    /**\n     * Handler for situations when we determine the player is waiting.\n     *\n     * @private\n     */\n\n  }, {\n    key: 'waiting_',\n    value: function waiting_() {\n      if (this.techWaiting_()) {\n        return;\n      }\n\n      // All tech waiting checks failed. Use last resort correction\n      var currentTime = this.tech_.currentTime();\n      var buffered = this.tech_.buffered();\n      var currentRange = findRange(buffered, currentTime);\n\n      // Sometimes the player can stall for unknown reasons within a contiguous buffered\n      // region with no indication that anything is amiss (seen in Firefox). Seeking to\n      // currentTime is usually enough to kickstart the player. This checks that the player\n      // is currently within a buffered region before attempting a corrective seek.\n      // Chrome does not appear to continue `timeupdate` events after a `waiting` event\n      // until there is ~ 3 seconds of forward buffer available. PlaybackWatcher should also\n      // make sure there is ~3 seconds of forward buffer before taking any corrective action\n      // to avoid triggering an `unknownwaiting` event when the network is slow.\n      if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {\n        this.cancelTimer_();\n        this.tech_.setCurrentTime(currentTime);\n\n        this.logger_('Stopped at ' + currentTime + ' while inside a buffered region ' + ('[' + currentRange.start(0) + ' -> ' + currentRange.end(0) + ']. Attempting to resume ') + 'playback by seeking to the current time.');\n\n        // unknown waiting corrections may be useful for monitoring QoS\n        this.tech_.trigger({ type: 'usage', name: 'hls-unknown-waiting' });\n        return;\n      }\n    }\n\n    /**\n     * Handler for situations when the tech fires a `waiting` event\n     *\n     * @return {Boolean}\n     *         True if an action (or none) was needed to correct the waiting. False if no\n     *         checks passed\n     * @private\n     */\n\n  }, {\n    key: 'techWaiting_',\n    value: function techWaiting_() {\n      var seekable = this.seekable();\n      var currentTime = this.tech_.currentTime();\n\n      if (this.tech_.seeking() && this.fixesBadSeeks_()) {\n        // Tech is seeking or bad seek fixed, no action needed\n        return true;\n      }\n\n      if (this.tech_.seeking() || this.timer_ !== null) {\n        // Tech is seeking or already waiting on another action, no action needed\n        return true;\n      }\n\n      if (this.beforeSeekableWindow_(seekable, currentTime)) {\n        var livePoint = seekable.end(seekable.length - 1);\n\n        this.logger_('Fell out of live window at time ' + currentTime + '. Seeking to ' + ('live point (seekable end) ' + livePoint));\n        this.cancelTimer_();\n        this.tech_.setCurrentTime(livePoint);\n\n        // live window resyncs may be useful for monitoring QoS\n        this.tech_.trigger({ type: 'usage', name: 'hls-live-resync' });\n        return true;\n      }\n\n      var buffered = this.tech_.buffered();\n      var nextRange = findNextRange(buffered, currentTime);\n\n      if (this.videoUnderflow_(nextRange, buffered, currentTime)) {\n        // Even though the video underflowed and was stuck in a gap, the audio overplayed\n        // the gap, leading currentTime into a buffered range. Seeking to currentTime\n        // allows the video to catch up to the audio position without losing any audio\n        // (only suffering ~3 seconds of frozen video and a pause in audio playback).\n        this.cancelTimer_();\n        this.tech_.setCurrentTime(currentTime);\n\n        // video underflow may be useful for monitoring QoS\n        this.tech_.trigger({ type: 'usage', name: 'hls-video-underflow' });\n        return true;\n      }\n\n      // check for gap\n      if (nextRange.length > 0) {\n        var difference = nextRange.start(0) - currentTime;\n\n        this.logger_('Stopped at ' + currentTime + ', setting timer for ' + difference + ', seeking ' + ('to ' + nextRange.start(0)));\n\n        this.timer_ = setTimeout(this.skipTheGap_.bind(this), difference * 1000, currentTime);\n        return true;\n      }\n\n      // All checks failed. Returning false to indicate failure to correct waiting\n      return false;\n    }\n  }, {\n    key: 'afterSeekableWindow_',\n    value: function afterSeekableWindow_(seekable, currentTime) {\n      if (!seekable.length) {\n        // we can't make a solid case if there's no seekable, default to false\n        return false;\n      }\n\n      if (currentTime > seekable.end(seekable.length - 1) + SAFE_TIME_DELTA) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: 'beforeSeekableWindow_',\n    value: function beforeSeekableWindow_(seekable, currentTime) {\n      if (seekable.length &&\n      // can't fall before 0 and 0 seekable start identifies VOD stream\n      seekable.start(0) > 0 && currentTime < seekable.start(0) - SAFE_TIME_DELTA) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: 'videoUnderflow_',\n    value: function videoUnderflow_(nextRange, buffered, currentTime) {\n      if (nextRange.length === 0) {\n        // Even if there is no available next range, there is still a possibility we are\n        // stuck in a gap due to video underflow.\n        var gap = this.gapFromVideoUnderflow_(buffered, currentTime);\n\n        if (gap) {\n          this.logger_('Encountered a gap in video from ' + gap.start + ' to ' + gap.end + '. ' + ('Seeking to current time ' + currentTime));\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Timer callback. If playback still has not proceeded, then we seek\n     * to the start of the next buffered region.\n     *\n     * @private\n     */\n\n  }, {\n    key: 'skipTheGap_',\n    value: function skipTheGap_(scheduledCurrentTime) {\n      var buffered = this.tech_.buffered();\n      var currentTime = this.tech_.currentTime();\n      var nextRange = findNextRange(buffered, currentTime);\n\n      this.cancelTimer_();\n\n      if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {\n        return;\n      }\n\n      this.logger_('skipTheGap_:', 'currentTime:', currentTime, 'scheduled currentTime:', scheduledCurrentTime, 'nextRange start:', nextRange.start(0));\n\n      // only seek if we still have not played\n      this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR);\n\n      this.tech_.trigger({ type: 'usage', name: 'hls-gap-skip' });\n    }\n  }, {\n    key: 'gapFromVideoUnderflow_',\n    value: function gapFromVideoUnderflow_(buffered, currentTime) {\n      // At least in Chrome, if there is a gap in the video buffer, the audio will continue\n      // playing for ~3 seconds after the video gap starts. This is done to account for\n      // video buffer underflow/underrun (note that this is not done when there is audio\n      // buffer underflow/underrun -- in that case the video will stop as soon as it\n      // encounters the gap, as audio stalls are more noticeable/jarring to a user than\n      // video stalls). The player's time will reflect the playthrough of audio, so the\n      // time will appear as if we are in a buffered region, even if we are stuck in a\n      // \"gap.\"\n      //\n      // Example:\n      // video buffer:   0 => 10.1, 10.2 => 20\n      // audio buffer:   0 => 20\n      // overall buffer: 0 => 10.1, 10.2 => 20\n      // current time: 13\n      //\n      // Chrome's video froze at 10 seconds, where the video buffer encountered the gap,\n      // however, the audio continued playing until it reached ~3 seconds past the gap\n      // (13 seconds), at which point it stops as well. Since current time is past the\n      // gap, findNextRange will return no ranges.\n      //\n      // To check for this issue, we see if there is a gap that starts somewhere within\n      // a 3 second range (3 seconds +/- 1 second) back from our current time.\n      var gaps = findGaps(buffered);\n\n      for (var i = 0; i < gaps.length; i++) {\n        var start = gaps.start(i);\n        var end = gaps.end(i);\n\n        // gap is starts no more than 4 seconds back\n        if (currentTime - start < 4 && currentTime - start > 2) {\n          return {\n            start: start,\n            end: end\n          };\n        }\n      }\n\n      return null;\n    }\n  }]);\n  return PlaybackWatcher;\n}();\n\nvar defaultOptions = {\n  errorInterval: 30,\n  getSource: function getSource(next) {\n    var tech = this.tech({ IWillNotUseThisInPlugins: true });\n    var sourceObj = tech.currentSource_;\n\n    return next(sourceObj);\n  }\n};\n\n/**\n * Main entry point for the plugin\n *\n * @param {Player} player a reference to a videojs Player instance\n * @param {Object} [options] an object with plugin options\n * @private\n */\nvar initPlugin = function initPlugin(player, options) {\n  var lastCalled = 0;\n  var seekTo = 0;\n  var localOptions = videojs$1.mergeOptions(defaultOptions, options);\n\n  player.ready(function () {\n    player.trigger({ type: 'usage', name: 'hls-error-reload-initialized' });\n  });\n\n  /**\n   * Player modifications to perform that must wait until `loadedmetadata`\n   * has been triggered\n   *\n   * @private\n   */\n  var loadedMetadataHandler = function loadedMetadataHandler() {\n    if (seekTo) {\n      player.currentTime(seekTo);\n    }\n  };\n\n  /**\n   * Set the source on the player element, play, and seek if necessary\n   *\n   * @param {Object} sourceObj An object specifying the source url and mime-type to play\n   * @private\n   */\n  var setSource = function setSource(sourceObj) {\n    if (sourceObj === null || sourceObj === undefined) {\n      return;\n    }\n    seekTo = player.duration() !== Infinity && player.currentTime() || 0;\n\n    player.one('loadedmetadata', loadedMetadataHandler);\n\n    player.src(sourceObj);\n    player.trigger({ type: 'usage', name: 'hls-error-reload' });\n    player.play();\n  };\n\n  /**\n   * Attempt to get a source from either the built-in getSource function\n   * or a custom function provided via the options\n   *\n   * @private\n   */\n  var errorHandler = function errorHandler() {\n    // Do not attempt to reload the source if a source-reload occurred before\n    // 'errorInterval' time has elapsed since the last source-reload\n    if (Date.now() - lastCalled < localOptions.errorInterval * 1000) {\n      player.trigger({ type: 'usage', name: 'hls-error-reload-canceled' });\n      return;\n    }\n\n    if (!localOptions.getSource || typeof localOptions.getSource !== 'function') {\n      videojs$1.log.error('ERROR: reloadSourceOnError - The option getSource must be a function!');\n      return;\n    }\n    lastCalled = Date.now();\n\n    return localOptions.getSource.call(player, setSource);\n  };\n\n  /**\n   * Unbind any event handlers that were bound by the plugin\n   *\n   * @private\n   */\n  var cleanupEvents = function cleanupEvents() {\n    player.off('loadedmetadata', loadedMetadataHandler);\n    player.off('error', errorHandler);\n    player.off('dispose', cleanupEvents);\n  };\n\n  /**\n   * Cleanup before re-initializing the plugin\n   *\n   * @param {Object} [newOptions] an object with plugin options\n   * @private\n   */\n  var reinitPlugin = function reinitPlugin(newOptions) {\n    cleanupEvents();\n    initPlugin(player, newOptions);\n  };\n\n  player.on('error', errorHandler);\n  player.on('dispose', cleanupEvents);\n\n  // Overwrite the plugin function so that we can correctly cleanup before\n  // initializing the plugin\n  player.reloadSourceOnError = reinitPlugin;\n};\n\n/**\n * Reload the source when an error is detected as long as there\n * wasn't an error previously within the last 30 seconds\n *\n * @param {Object} [options] an object with plugin options\n */\nvar reloadSourceOnError = function reloadSourceOnError(options) {\n  initPlugin(this, options);\n};\n\nvar version$1 = \"1.1.0\";\n\n/**\n * @file videojs-http-streaming.js\n *\n * The main file for the HLS project.\n * License: https://github.com/videojs/videojs-http-streaming/blob/master/LICENSE\n */\n\nvar Hls$1 = {\n  PlaylistLoader: PlaylistLoader,\n  Playlist: Playlist,\n  Decrypter: aes_decrypter__WEBPACK_IMPORTED_MODULE_11__[\"Decrypter\"],\n  AsyncStream: aes_decrypter__WEBPACK_IMPORTED_MODULE_11__[\"AsyncStream\"],\n  decrypt: aes_decrypter__WEBPACK_IMPORTED_MODULE_11__[\"decrypt\"],\n  utils: utils,\n\n  STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,\n  INITIAL_PLAYLIST_SELECTOR: lowestBitrateCompatibleVariantSelector,\n  comparePlaylistBandwidth: comparePlaylistBandwidth,\n  comparePlaylistResolution: comparePlaylistResolution,\n\n  xhr: xhrFactory()\n};\n\n// 0.5 MB/s\nvar INITIAL_BANDWIDTH = 4194304;\n\n// Define getter/setters for config properites\n['GOAL_BUFFER_LENGTH', 'MAX_GOAL_BUFFER_LENGTH', 'GOAL_BUFFER_LENGTH_RATE', 'BUFFER_LOW_WATER_LINE', 'MAX_BUFFER_LOW_WATER_LINE', 'BUFFER_LOW_WATER_LINE_RATE', 'BANDWIDTH_VARIANCE'].forEach(function (prop) {\n  Object.defineProperty(Hls$1, prop, {\n    get: function get$$1() {\n      videojs$1.log.warn('using Hls.' + prop + ' is UNSAFE be sure you know what you are doing');\n      return Config[prop];\n    },\n    set: function set$$1(value) {\n      videojs$1.log.warn('using Hls.' + prop + ' is UNSAFE be sure you know what you are doing');\n\n      if (typeof value !== 'number' || value < 0) {\n        videojs$1.log.warn('value of Hls.' + prop + ' must be greater than or equal to 0');\n        return;\n      }\n\n      Config[prop] = value;\n    }\n  });\n});\n\nvar simpleTypeFromSourceType = function simpleTypeFromSourceType(type) {\n  var mpegurlRE = /^(audio|video|application)\\/(x-|vnd\\.apple\\.)?mpegurl/i;\n\n  if (mpegurlRE.test(type)) {\n    return 'hls';\n  }\n\n  var dashRE = /^application\\/dash\\+xml/i;\n\n  if (dashRE.test(type)) {\n    return 'dash';\n  }\n\n  return null;\n};\n\n/**\n * Updates the selectedIndex of the QualityLevelList when a mediachange happens in hls.\n *\n * @param {QualityLevelList} qualityLevels The QualityLevelList to update.\n * @param {PlaylistLoader} playlistLoader PlaylistLoader containing the new media info.\n * @function handleHlsMediaChange\n */\nvar handleHlsMediaChange = function handleHlsMediaChange(qualityLevels, playlistLoader) {\n  var newPlaylist = playlistLoader.media();\n  var selectedIndex = -1;\n\n  for (var i = 0; i < qualityLevels.length; i++) {\n    if (qualityLevels[i].id === newPlaylist.uri) {\n      selectedIndex = i;\n      break;\n    }\n  }\n\n  qualityLevels.selectedIndex_ = selectedIndex;\n  qualityLevels.trigger({\n    selectedIndex: selectedIndex,\n    type: 'change'\n  });\n};\n\n/**\n * Adds quality levels to list once playlist metadata is available\n *\n * @param {QualityLevelList} qualityLevels The QualityLevelList to attach events to.\n * @param {Object} hls Hls object to listen to for media events.\n * @function handleHlsLoadedMetadata\n */\nvar handleHlsLoadedMetadata = function handleHlsLoadedMetadata(qualityLevels, hls) {\n  hls.representations().forEach(function (rep) {\n    qualityLevels.addQualityLevel(rep);\n  });\n  handleHlsMediaChange(qualityLevels, hls.playlists);\n};\n\n// HLS is a source handler, not a tech. Make sure attempts to use it\n// as one do not cause exceptions.\nHls$1.canPlaySource = function () {\n  return videojs$1.log.warn('HLS is no longer a tech. Please remove it from ' + 'your player\\'s techOrder.');\n};\n\nvar emeKeySystems = function emeKeySystems(keySystemOptions, videoPlaylist, audioPlaylist) {\n  if (!keySystemOptions) {\n    return keySystemOptions;\n  }\n\n  // upsert the content types based on the selected playlist\n  var keySystemContentTypes = {};\n\n  for (var keySystem in keySystemOptions) {\n    keySystemContentTypes[keySystem] = {\n      audioContentType: 'audio/mp4; codecs=\"' + audioPlaylist.attributes.CODECS + '\"',\n      videoContentType: 'video/mp4; codecs=\"' + videoPlaylist.attributes.CODECS + '\"'\n    };\n\n    if (videoPlaylist.contentProtection && videoPlaylist.contentProtection[keySystem] && videoPlaylist.contentProtection[keySystem].pssh) {\n      keySystemContentTypes[keySystem].pssh = videoPlaylist.contentProtection[keySystem].pssh;\n    }\n\n    // videojs-contrib-eme accepts the option of specifying: 'com.some.cdm': 'url'\n    // so we need to prevent overwriting the URL entirely\n    if (typeof keySystemOptions[keySystem] === 'string') {\n      keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];\n    }\n  }\n\n  return videojs$1.mergeOptions(keySystemOptions, keySystemContentTypes);\n};\n\nvar setupEmeOptions = function setupEmeOptions(hlsHandler) {\n  if (hlsHandler.options_.sourceType !== 'dash') {\n    return;\n  }\n  var player = videojs$1.players[hlsHandler.tech_.options_.playerId];\n\n  if (player.eme) {\n    var sourceOptions = emeKeySystems(hlsHandler.source_.keySystems, hlsHandler.playlists.media(), hlsHandler.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader.media());\n\n    if (sourceOptions) {\n      player.currentSource().keySystems = sourceOptions;\n    }\n  }\n};\n\n/**\n * Whether the browser has built-in HLS support.\n */\nHls$1.supportsNativeHls = function () {\n  var video = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('video');\n\n  // native HLS is definitely not supported if HTML5 video isn't\n  if (!videojs$1.getTech('Html5').isSupported()) {\n    return false;\n  }\n\n  // HLS manifests can go by many mime-types\n  var canPlay = [\n  // Apple santioned\n  'application/vnd.apple.mpegurl',\n  // Apple sanctioned for backwards compatibility\n  'audio/mpegurl',\n  // Very common\n  'audio/x-mpegurl',\n  // Very common\n  'application/x-mpegurl',\n  // Included for completeness\n  'video/x-mpegurl', 'video/mpegurl', 'application/mpegurl'];\n\n  return canPlay.some(function (canItPlay) {\n    return (/maybe|probably/i.test(video.canPlayType(canItPlay))\n    );\n  });\n}();\n\nHls$1.supportsNativeDash = function () {\n  if (!videojs$1.getTech('Html5').isSupported()) {\n    return false;\n  }\n\n  return (/maybe|probably/i.test(global_document__WEBPACK_IMPORTED_MODULE_1___default.a.createElement('video').canPlayType('application/dash+xml'))\n  );\n}();\n\nHls$1.supportsTypeNatively = function (type) {\n  if (type === 'hls') {\n    return Hls$1.supportsNativeHls;\n  }\n\n  if (type === 'dash') {\n    return Hls$1.supportsNativeDash;\n  }\n\n  return false;\n};\n\n/**\n * HLS is a source handler, not a tech. Make sure attempts to use it\n * as one do not cause exceptions.\n */\nHls$1.isSupported = function () {\n  return videojs$1.log.warn('HLS is no longer a tech. Please remove it from ' + 'your player\\'s techOrder.');\n};\n\nvar Component$1 = videojs$1.getComponent('Component');\n\n/**\n * The Hls Handler object, where we orchestrate all of the parts\n * of HLS to interact with video.js\n *\n * @class HlsHandler\n * @extends videojs.Component\n * @param {Object} source the soruce object\n * @param {Tech} tech the parent tech object\n * @param {Object} options optional and required options\n */\n\nvar HlsHandler = function (_Component) {\n  inherits$1(HlsHandler, _Component);\n\n  function HlsHandler(source, tech, options) {\n    classCallCheck$1(this, HlsHandler);\n\n    // tech.player() is deprecated but setup a reference to HLS for\n    // backwards-compatibility\n    var _this = possibleConstructorReturn$1(this, (HlsHandler.__proto__ || Object.getPrototypeOf(HlsHandler)).call(this, tech, options.hls));\n\n    if (tech.options_ && tech.options_.playerId) {\n      var _player = videojs$1(tech.options_.playerId);\n\n      if (!_player.hasOwnProperty('hls')) {\n        Object.defineProperty(_player, 'hls', {\n          get: function get$$1() {\n            videojs$1.log.warn('player.hls is deprecated. Use player.tech_.hls instead.');\n            tech.trigger({ type: 'usage', name: 'hls-player-access' });\n            return _this;\n          }\n        });\n      }\n\n      // Set up a reference to the HlsHandler from player.vhs. This allows users to start\n      // migrating from player.tech_.hls... to player.vhs... for API access. Although this\n      // isn't the most appropriate form of reference for video.js (since all APIs should\n      // be provided through core video.js), it is a common pattern for plugins, and vhs\n      // will act accordingly.\n      _player.vhs = _this;\n      // deprecated, for backwards compatibility\n      _player.dash = _this;\n    }\n\n    _this.tech_ = tech;\n    _this.source_ = source;\n    _this.stats = {};\n    _this.ignoreNextSeekingEvent_ = false;\n    _this.setOptions_();\n\n    if (_this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {\n      tech.overrideNativeAudioTracks(true);\n      tech.overrideNativeVideoTracks(true);\n    } else if (_this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) {\n      // overriding native HLS only works if audio tracks have been emulated\n      // error early if we're misconfigured\n      throw new Error('Overriding native HLS requires emulated tracks. ' + 'See https://git.io/vMpjB');\n    }\n\n    // listen for fullscreenchange events for this player so that we\n    // can adjust our quality selection quickly\n    _this.on(global_document__WEBPACK_IMPORTED_MODULE_1___default.a, ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'], function (event) {\n      var fullscreenElement = global_document__WEBPACK_IMPORTED_MODULE_1___default.a.fullscreenElement || global_document__WEBPACK_IMPORTED_MODULE_1___default.a.webkitFullscreenElement || global_document__WEBPACK_IMPORTED_MODULE_1___default.a.mozFullScreenElement || global_document__WEBPACK_IMPORTED_MODULE_1___default.a.msFullscreenElement;\n\n      if (fullscreenElement && fullscreenElement.contains(_this.tech_.el())) {\n        _this.masterPlaylistController_.fastQualityChange_();\n      }\n    });\n\n    _this.on(_this.tech_, 'seeking', function () {\n      if (this.ignoreNextSeekingEvent_) {\n        this.ignoreNextSeekingEvent_ = false;\n        return;\n      }\n\n      this.setCurrentTime(this.tech_.currentTime());\n    });\n    _this.on(_this.tech_, 'error', function () {\n      if (this.masterPlaylistController_) {\n        this.masterPlaylistController_.pauseLoading();\n      }\n    });\n\n    _this.on(_this.tech_, 'play', _this.play);\n    return _this;\n  }\n\n  createClass$1(HlsHandler, [{\n    key: 'setOptions_',\n    value: function setOptions_() {\n      var _this2 = this;\n\n      // defaults\n      this.options_.withCredentials = this.options_.withCredentials || false;\n\n      if (typeof this.options_.blacklistDuration !== 'number') {\n        this.options_.blacklistDuration = 5 * 60;\n      }\n\n      // start playlist selection at a reasonable bandwidth for\n      // broadband internet (0.5 MB/s) or mobile (0.0625 MB/s)\n      if (typeof this.options_.bandwidth !== 'number') {\n        this.options_.bandwidth = INITIAL_BANDWIDTH;\n      }\n\n      // If the bandwidth number is unchanged from the initial setting\n      // then this takes precedence over the enableLowInitialPlaylist option\n      this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === INITIAL_BANDWIDTH;\n\n      // grab options passed to player.src\n      ['withCredentials', 'bandwidth'].forEach(function (option) {\n        if (typeof _this2.source_[option] !== 'undefined') {\n          _this2.options_[option] = _this2.source_[option];\n        }\n      });\n\n      this.bandwidth = this.options_.bandwidth;\n    }\n    /**\n     * called when player.src gets called, handle a new source\n     *\n     * @param {Object} src the source object to handle\n     */\n\n  }, {\n    key: 'src',\n    value: function src(_src, type) {\n      var _this3 = this;\n\n      // do nothing if the src is falsey\n      if (!_src) {\n        return;\n      }\n      this.setOptions_();\n      // add master playlist controller options\n      this.options_.url = this.source_.src;\n      this.options_.tech = this.tech_;\n      this.options_.externHls = Hls$1;\n      this.options_.sourceType = simpleTypeFromSourceType(type);\n\n      this.masterPlaylistController_ = new MasterPlaylistController(this.options_);\n      this.playbackWatcher_ = new PlaybackWatcher(videojs$1.mergeOptions(this.options_, {\n        seekable: function seekable$$1() {\n          return _this3.seekable();\n        }\n      }));\n\n      this.masterPlaylistController_.on('error', function () {\n        var player = videojs$1.players[_this3.tech_.options_.playerId];\n\n        player.error(_this3.masterPlaylistController_.error);\n      });\n\n      // `this` in selectPlaylist should be the HlsHandler for backwards\n      // compatibility with < v2\n      this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : Hls$1.STANDARD_PLAYLIST_SELECTOR.bind(this);\n\n      this.masterPlaylistController_.selectInitialPlaylist = Hls$1.INITIAL_PLAYLIST_SELECTOR.bind(this);\n\n      // re-expose some internal objects for backwards compatibility with < v2\n      this.playlists = this.masterPlaylistController_.masterPlaylistLoader_;\n      this.mediaSource = this.masterPlaylistController_.mediaSource;\n\n      // Proxy assignment of some properties to the master playlist\n      // controller. Using a custom property for backwards compatibility\n      // with < v2\n      Object.defineProperties(this, {\n        selectPlaylist: {\n          get: function get$$1() {\n            return this.masterPlaylistController_.selectPlaylist;\n          },\n          set: function set$$1(selectPlaylist) {\n            this.masterPlaylistController_.selectPlaylist = selectPlaylist.bind(this);\n          }\n        },\n        throughput: {\n          get: function get$$1() {\n            return this.masterPlaylistController_.mainSegmentLoader_.throughput.rate;\n          },\n          set: function set$$1(throughput) {\n            this.masterPlaylistController_.mainSegmentLoader_.throughput.rate = throughput;\n            // By setting `count` to 1 the throughput value becomes the starting value\n            // for the cumulative average\n            this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1;\n          }\n        },\n        bandwidth: {\n          get: function get$$1() {\n            return this.masterPlaylistController_.mainSegmentLoader_.bandwidth;\n          },\n          set: function set$$1(bandwidth) {\n            this.masterPlaylistController_.mainSegmentLoader_.bandwidth = bandwidth;\n            // setting the bandwidth manually resets the throughput counter\n            // `count` is set to zero that current value of `rate` isn't included\n            // in the cumulative average\n            this.masterPlaylistController_.mainSegmentLoader_.throughput = {\n              rate: 0,\n              count: 0\n            };\n          }\n        },\n        /**\n         * `systemBandwidth` is a combination of two serial processes bit-rates. The first\n         * is the network bitrate provided by `bandwidth` and the second is the bitrate of\n         * the entire process after that - decryption, transmuxing, and appending - provided\n         * by `throughput`.\n         *\n         * Since the two process are serial, the overall system bandwidth is given by:\n         *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)\n         */\n        systemBandwidth: {\n          get: function get$$1() {\n            var invBandwidth = 1 / (this.bandwidth || 1);\n            var invThroughput = void 0;\n\n            if (this.throughput > 0) {\n              invThroughput = 1 / this.throughput;\n            } else {\n              invThroughput = 0;\n            }\n\n            var systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));\n\n            return systemBitrate;\n          },\n          set: function set$$1() {\n            videojs$1.log.error('The \"systemBandwidth\" property is read-only');\n          }\n        }\n      });\n\n      Object.defineProperties(this.stats, {\n        bandwidth: {\n          get: function get$$1() {\n            return _this3.bandwidth || 0;\n          },\n          enumerable: true\n        },\n        mediaRequests: {\n          get: function get$$1() {\n            return _this3.masterPlaylistController_.mediaRequests_() || 0;\n          },\n          enumerable: true\n        },\n        mediaRequestsAborted: {\n          get: function get$$1() {\n            return _this3.masterPlaylistController_.mediaRequestsAborted_() || 0;\n          },\n          enumerable: true\n        },\n        mediaRequestsTimedout: {\n          get: function get$$1() {\n            return _this3.masterPlaylistController_.mediaRequestsTimedout_() || 0;\n          },\n          enumerable: true\n        },\n        mediaRequestsErrored: {\n          get: function get$$1() {\n            return _this3.masterPlaylistController_.mediaRequestsErrored_() || 0;\n          },\n          enumerable: true\n        },\n        mediaTransferDuration: {\n          get: function get$$1() {\n            return _this3.masterPlaylistController_.mediaTransferDuration_() || 0;\n          },\n          enumerable: true\n        },\n        mediaBytesTransferred: {\n          get: function get$$1() {\n            return _this3.masterPlaylistController_.mediaBytesTransferred_() || 0;\n          },\n          enumerable: true\n        },\n        mediaSecondsLoaded: {\n          get: function get$$1() {\n            return _this3.masterPlaylistController_.mediaSecondsLoaded_() || 0;\n          },\n          enumerable: true\n        },\n        buffered: {\n          get: function get$$1() {\n            return timeRangesToArray(_this3.tech_.buffered());\n          },\n          enumerable: true\n        },\n        currentTime: {\n          get: function get$$1() {\n            return _this3.tech_.currentTime();\n          },\n          enumerable: true\n        },\n        currentSource: {\n          get: function get$$1() {\n            return _this3.tech_.currentSource_;\n          },\n          enumerable: true\n        },\n        currentTech: {\n          get: function get$$1() {\n            return _this3.tech_.name_;\n          },\n          enumerable: true\n        },\n        duration: {\n          get: function get$$1() {\n            return _this3.tech_.duration();\n          },\n          enumerable: true\n        },\n        master: {\n          get: function get$$1() {\n            return _this3.playlists.master;\n          },\n          enumerable: true\n        },\n        playerDimensions: {\n          get: function get$$1() {\n            return _this3.tech_.currentDimensions();\n          },\n          enumerable: true\n        },\n        seekable: {\n          get: function get$$1() {\n            return timeRangesToArray(_this3.tech_.seekable());\n          },\n          enumerable: true\n        },\n        timestamp: {\n          get: function get$$1() {\n            return Date.now();\n          },\n          enumerable: true\n        },\n        videoPlaybackQuality: {\n          get: function get$$1() {\n            return _this3.tech_.getVideoPlaybackQuality();\n          },\n          enumerable: true\n        }\n      });\n\n      this.tech_.one('canplay', this.masterPlaylistController_.setupFirstPlay.bind(this.masterPlaylistController_));\n\n      this.masterPlaylistController_.on('selectedinitialmedia', function () {\n        // Add the manual rendition mix-in to HlsHandler\n        renditionSelectionMixin(_this3);\n        setupEmeOptions(_this3);\n      });\n\n      // the bandwidth of the primary segment loader is our best\n      // estimate of overall bandwidth\n      this.on(this.masterPlaylistController_, 'progress', function () {\n        this.tech_.trigger('progress');\n      });\n\n      // In the live case, we need to ignore the very first `seeking` event since\n      // that will be the result of the seek-to-live behavior\n      this.on(this.masterPlaylistController_, 'firstplay', function () {\n        this.ignoreNextSeekingEvent_ = true;\n      });\n\n      this.tech_.ready(function () {\n        return _this3.setupQualityLevels_();\n      });\n\n      // do nothing if the tech has been disposed already\n      // this can occur if someone sets the src in player.ready(), for instance\n      if (!this.tech_.el()) {\n        return;\n      }\n\n      this.tech_.src(videojs$1.URL.createObjectURL(this.masterPlaylistController_.mediaSource));\n    }\n\n    /**\n     * Initializes the quality levels and sets listeners to update them.\n     *\n     * @method setupQualityLevels_\n     * @private\n     */\n\n  }, {\n    key: 'setupQualityLevels_',\n    value: function setupQualityLevels_() {\n      var _this4 = this;\n\n      var player = videojs$1.players[this.tech_.options_.playerId];\n\n      if (player && player.qualityLevels) {\n        this.qualityLevels_ = player.qualityLevels();\n\n        this.masterPlaylistController_.on('selectedinitialmedia', function () {\n          handleHlsLoadedMetadata(_this4.qualityLevels_, _this4);\n        });\n\n        this.playlists.on('mediachange', function () {\n          handleHlsMediaChange(_this4.qualityLevels_, _this4.playlists);\n        });\n      }\n    }\n\n    /**\n     * Begin playing the video.\n     */\n\n  }, {\n    key: 'play',\n    value: function play() {\n      this.masterPlaylistController_.play();\n    }\n\n    /**\n     * a wrapper around the function in MasterPlaylistController\n     */\n\n  }, {\n    key: 'setCurrentTime',\n    value: function setCurrentTime(currentTime) {\n      this.masterPlaylistController_.setCurrentTime(currentTime);\n    }\n\n    /**\n     * a wrapper around the function in MasterPlaylistController\n     */\n\n  }, {\n    key: 'duration',\n    value: function duration$$1() {\n      return this.masterPlaylistController_.duration();\n    }\n\n    /**\n     * a wrapper around the function in MasterPlaylistController\n     */\n\n  }, {\n    key: 'seekable',\n    value: function seekable$$1() {\n      return this.masterPlaylistController_.seekable();\n    }\n\n    /**\n     * Abort all outstanding work and cleanup.\n     */\n\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      if (this.playbackWatcher_) {\n        this.playbackWatcher_.dispose();\n      }\n      if (this.masterPlaylistController_) {\n        this.masterPlaylistController_.dispose();\n      }\n      if (this.qualityLevels_) {\n        this.qualityLevels_.dispose();\n      }\n      get$2(HlsHandler.prototype.__proto__ || Object.getPrototypeOf(HlsHandler.prototype), 'dispose', this).call(this);\n    }\n  }]);\n  return HlsHandler;\n}(Component$1);\n\n/**\n * The Source Handler object, which informs video.js what additional\n * MIME types are supported and sets up playback. It is registered\n * automatically to the appropriate tech based on the capabilities of\n * the browser it is running in. It is not necessary to use or modify\n * this object in normal usage.\n */\n\nvar HlsSourceHandler = {\n  name: 'videojs-http-streaming',\n  VERSION: version$1,\n  canHandleSource: function canHandleSource(srcObj) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var localOptions = videojs$1.mergeOptions(videojs$1.options, options);\n\n    return HlsSourceHandler.canPlayType(srcObj.type, localOptions);\n  },\n  handleSource: function handleSource(source, tech) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var localOptions = videojs$1.mergeOptions(videojs$1.options, options);\n\n    tech.hls = new HlsHandler(source, tech, localOptions);\n    tech.hls.xhr = xhrFactory();\n\n    tech.hls.src(source.src, source.type);\n    return tech.hls;\n  },\n  canPlayType: function canPlayType(type) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _videojs$mergeOptions = videojs$1.mergeOptions(videojs$1.options, options),\n        overrideNative = _videojs$mergeOptions.hls.overrideNative;\n\n    var supportedType = simpleTypeFromSourceType(type);\n    var canUseMsePlayback = supportedType && (!Hls$1.supportsTypeNatively(supportedType) || overrideNative);\n\n    return canUseMsePlayback ? 'maybe' : '';\n  }\n};\n\nif (typeof videojs$1.MediaSource === 'undefined' || typeof videojs$1.URL === 'undefined') {\n  videojs$1.MediaSource = MediaSource;\n  videojs$1.URL = URL$1;\n}\n\n// register source handlers with the appropriate techs\nif (MediaSource.supportsNativeMediaSources()) {\n  videojs$1.getTech('Html5').registerSourceHandler(HlsSourceHandler, 0);\n}\n\nvideojs$1.HlsHandler = HlsHandler;\nvideojs$1.HlsSourceHandler = HlsSourceHandler;\nvideojs$1.Hls = Hls$1;\nif (!videojs$1.use) {\n  videojs$1.registerComponent('Hls', Hls$1);\n}\nvideojs$1.options.hls = videojs$1.options.hls || {};\n\nif (videojs$1.registerPlugin) {\n  videojs$1.registerPlugin('reloadSourceOnError', reloadSourceOnError);\n} else {\n  videojs$1.plugin('reloadSourceOnError', reloadSourceOnError);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (videojs$1);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvZGlzdC92aWRlby5lcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92aWRlby5qcy9kaXN0L3ZpZGVvLmVzLmpzP2YwZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogVmlkZW8uanMgNy4xLjAgPGh0dHA6Ly92aWRlb2pzLmNvbS8+XG4gKiBDb3B5cmlnaHQgQnJpZ2h0Y292ZSwgSW5jLiA8aHR0cHM6Ly93d3cuYnJpZ2h0Y292ZS5jb20vPlxuICogQXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wXG4gKiA8aHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvYmxvYi9tYXN0ZXIvTElDRU5TRT5cbiAqXG4gKiBJbmNsdWRlcyB2dHQuanMgPGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcz5cbiAqIEF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMFxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcy9ibG9iL21hc3Rlci9MSUNFTlNFPlxuICovXG5cbmltcG9ydCB3aW5kb3ckMSBmcm9tICdnbG9iYWwvd2luZG93JztcbmltcG9ydCBkb2N1bWVudCBmcm9tICdnbG9iYWwvZG9jdW1lbnQnO1xuaW1wb3J0IHRzbWwgZnJvbSAndHNtbCc7XG5pbXBvcnQgeGhyIGZyb20gJ3hocic7XG5pbXBvcnQgdnR0IGZyb20gJ3ZpZGVvanMtdnR0LmpzJztcbmltcG9ydCBzYWZlUGFyc2VUdXBsZSBmcm9tICdzYWZlLWpzb24tcGFyc2UvdHVwbGUnO1xuaW1wb3J0IFVSTFRvb2xraXQgZnJvbSAndXJsLXRvb2xraXQnO1xuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSAnbTN1OC1wYXJzZXInO1xuaW1wb3J0IHsgcGFyc2UsIHBhcnNlVVRDVGltaW5nIH0gZnJvbSAnbXBkLXBhcnNlcic7XG5pbXBvcnQgbXA0cHJvYmUgZnJvbSAnbXV4LmpzL2xpYi9tcDQvcHJvYmUnO1xuaW1wb3J0IHRzSW5zcGVjdG9yIGZyb20gJ211eC5qcy9saWIvdG9vbHMvdHMtaW5zcGVjdG9yLmpzJztcbmltcG9ydCB7IERlY3J5cHRlciwgQXN5bmNTdHJlYW0sIGRlY3J5cHQgfSBmcm9tICdhZXMtZGVjcnlwdGVyJztcblxudmFyIHZlcnNpb24gPSBcIjcuMS4wXCI7XG5cbi8qKlxuICogQGZpbGUgbG9nLmpzXG4gKiBAbW9kdWxlIGxvZ1xuICovXG5cbnZhciBsb2cgPSB2b2lkIDA7XG5cbi8vIFRoaXMgaXMgdGhlIHByaXZhdGUgdHJhY2tpbmcgdmFyaWFibGUgZm9yIGxvZ2dpbmcgbGV2ZWwuXG52YXIgbGV2ZWwgPSAnaW5mbyc7XG5cbi8vIFRoaXMgaXMgdGhlIHByaXZhdGUgdHJhY2tpbmcgdmFyaWFibGUgZm9yIHRoZSBsb2dnaW5nIGhpc3RvcnkuXG52YXIgaGlzdG9yeSA9IFtdO1xuXG4vKipcbiAqIExvZyBtZXNzYWdlcyB0byB0aGUgY29uc29sZSBhbmQgaGlzdG9yeSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBtZXNzYWdlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZVxuICogICAgICAgICBUaGUgbmFtZSBvZiB0aGUgY29uc29sZSBtZXRob2QgdG8gdXNlLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBhcmdzXG4gKiAgICAgICAgIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBtYXRjaGluZyBjb25zb2xlIG1ldGhvZC5cbiAqL1xudmFyIGxvZ0J5VHlwZSA9IGZ1bmN0aW9uIGxvZ0J5VHlwZSh0eXBlLCBhcmdzKSB7XG4gIHZhciBsdmwgPSBsb2cubGV2ZWxzW2xldmVsXTtcbiAgdmFyIGx2bFJlZ0V4cCA9IG5ldyBSZWdFeHAoJ14oJyArIGx2bCArICcpJCcpO1xuXG4gIGlmICh0eXBlICE9PSAnbG9nJykge1xuXG4gICAgLy8gQWRkIHRoZSB0eXBlIHRvIHRoZSBmcm9udCBvZiB0aGUgbWVzc2FnZSB3aGVuIGl0J3Mgbm90IFwibG9nXCIuXG4gICAgYXJncy51bnNoaWZ0KHR5cGUudG9VcHBlckNhc2UoKSArICc6Jyk7XG4gIH1cblxuICAvLyBBZGQgYSBjbG9uZSBvZiB0aGUgYXJncyBhdCB0aGlzIHBvaW50IHRvIGhpc3RvcnkuXG4gIGlmIChoaXN0b3J5KSB7XG4gICAgaGlzdG9yeS5wdXNoKFtdLmNvbmNhdChhcmdzKSk7XG4gIH1cblxuICAvLyBBZGQgY29uc29sZSBwcmVmaXggYWZ0ZXIgYWRkaW5nIHRvIGhpc3RvcnkuXG4gIGFyZ3MudW5zaGlmdCgnVklERU9KUzonKTtcblxuICAvLyBJZiB0aGVyZSdzIG5vIGNvbnNvbGUgdGhlbiBkb24ndCB0cnkgdG8gb3V0cHV0IG1lc3NhZ2VzLCBidXQgdGhleSB3aWxsXG4gIC8vIHN0aWxsIGJlIHN0b3JlZCBpbiBoaXN0b3J5LlxuICBpZiAoIXdpbmRvdyQxLmNvbnNvbGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBXYXMgc2V0dGluZyB0aGVzZSBvbmNlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbiwgYnV0IGNvbnRhaW5pbmcgdGhlbVxuICAvLyBpbiB0aGUgZnVuY3Rpb24gbWFrZXMgaXQgZWFzaWVyIHRvIHRlc3QgY2FzZXMgd2hlcmUgY29uc29sZSBkb2Vzbid0IGV4aXN0XG4gIC8vIHdoZW4gdGhlIG1vZHVsZSBpcyBleGVjdXRlZC5cbiAgdmFyIGZuID0gd2luZG93JDEuY29uc29sZVt0eXBlXTtcblxuICBpZiAoIWZuICYmIHR5cGUgPT09ICdkZWJ1ZycpIHtcbiAgICAvLyBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IGhhdmUgc3VwcG9ydCBmb3IgY29uc29sZS5kZWJ1Zy4gRm9yIHRob3NlLCB3ZVxuICAgIC8vIHNob3VsZCBkZWZhdWx0IHRvIHRoZSBjbG9zZXN0IGNvbXBhcmFibGUgbG9nLlxuICAgIGZuID0gd2luZG93JDEuY29uc29sZS5pbmZvIHx8IHdpbmRvdyQxLmNvbnNvbGUubG9nO1xuICB9XG5cbiAgLy8gQmFpbCBvdXQgaWYgdGhlcmUncyBubyBjb25zb2xlIG9yIGlmIHRoaXMgdHlwZSBpcyBub3QgYWxsb3dlZCBieSB0aGVcbiAgLy8gY3VycmVudCBsb2dnaW5nIGxldmVsLlxuICBpZiAoIWZuIHx8ICFsdmwgfHwgIWx2bFJlZ0V4cC50ZXN0KHR5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm5bQXJyYXkuaXNBcnJheShhcmdzKSA/ICdhcHBseScgOiAnY2FsbCddKHdpbmRvdyQxLmNvbnNvbGUsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBMb2dzIHBsYWluIGRlYnVnIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0gICAge01peGVkW119IGFyZ3NcbiAqICAgICAgICAgICBPbmUgb3IgbW9yZSBtZXNzYWdlcyBvciBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIGxvZ2dlZC5cbiAqL1xubG9nID0gZnVuY3Rpb24gbG9nKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBsb2dCeVR5cGUoJ2xvZycsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBhdmFpbGFibGUgbG9nZ2luZyBsZXZlbHMsIHdoZXJlIHRoZSBrZXlzIGFyZSB0aGUgbGV2ZWwgbmFtZXNcbiAqIGFuZCB0aGUgdmFsdWVzIGFyZSBgfGAtc2VwYXJhdGVkIHN0cmluZ3MgY29udGFpbmluZyBsb2dnaW5nIG1ldGhvZHMgYWxsb3dlZFxuICogaW4gdGhhdCBsb2dnaW5nIGxldmVsLiBUaGVzZSBzdHJpbmdzIGFyZSB1c2VkIHRvIGNyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICogbWF0Y2hpbmcgdGhlIGZ1bmN0aW9uIG5hbWUgYmVpbmcgY2FsbGVkLlxuICpcbiAqIExldmVscyBwcm92aWRlZCBieSB2aWRlby5qcyBhcmU6XG4gKlxuICogLSBgb2ZmYDogTWF0Y2hlcyBubyBjYWxscy4gQW55IHZhbHVlIHRoYXQgY2FuIGJlIGNhc3QgdG8gYGZhbHNlYCB3aWxsIGhhdmVcbiAqICAgdGhpcyBlZmZlY3QuIFRoZSBtb3N0IHJlc3RyaWN0aXZlLlxuICogLSBgYWxsYDogTWF0Y2hlcyBvbmx5IFZpZGVvLmpzLXByb3ZpZGVkIGZ1bmN0aW9ucyAoYGRlYnVnYCwgYGxvZ2AsXG4gKiAgIGBsb2cud2FybmAsIGFuZCBgbG9nLmVycm9yYCkuXG4gKiAtIGBkZWJ1Z2A6IE1hdGNoZXMgYGxvZy5kZWJ1Z2AsIGBsb2dgLCBgbG9nLndhcm5gLCBhbmQgYGxvZy5lcnJvcmAgY2FsbHMuXG4gKiAtIGBpbmZvYCAoZGVmYXVsdCk6IE1hdGNoZXMgYGxvZ2AsIGBsb2cud2FybmAsIGFuZCBgbG9nLmVycm9yYCBjYWxscy5cbiAqIC0gYHdhcm5gOiBNYXRjaGVzIGBsb2cud2FybmAgYW5kIGBsb2cuZXJyb3JgIGNhbGxzLlxuICogLSBgZXJyb3JgOiBNYXRjaGVzIG9ubHkgYGxvZy5lcnJvcmAgY2FsbHMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xubG9nLmxldmVscyA9IHtcbiAgYWxsOiAnZGVidWd8bG9nfHdhcm58ZXJyb3InLFxuICBvZmY6ICcnLFxuICBkZWJ1ZzogJ2RlYnVnfGxvZ3x3YXJufGVycm9yJyxcbiAgaW5mbzogJ2xvZ3x3YXJufGVycm9yJyxcbiAgd2FybjogJ3dhcm58ZXJyb3InLFxuICBlcnJvcjogJ2Vycm9yJyxcbiAgREVGQVVMVDogbGV2ZWxcbn07XG5cbi8qKlxuICogR2V0IG9yIHNldCB0aGUgY3VycmVudCBsb2dnaW5nIGxldmVsLiBJZiBhIHN0cmluZyBtYXRjaGluZyBhIGtleSBmcm9tXG4gKiB7QGxpbmsgbG9nLmxldmVsc30gaXMgcHJvdmlkZWQsIGFjdHMgYXMgYSBzZXR0ZXIuIFJlZ2FyZGxlc3Mgb2YgYXJndW1lbnQsXG4gKiByZXR1cm5zIHRoZSBjdXJyZW50IGxvZ2dpbmcgbGV2ZWwuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBbbHZsXVxuICogICAgICAgICBQYXNzIHRvIHNldCBhIG5ldyBsb2dnaW5nIGxldmVsLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIGN1cnJlbnQgbG9nZ2luZyBsZXZlbC5cbiAqL1xubG9nLmxldmVsID0gZnVuY3Rpb24gKGx2bCkge1xuICBpZiAodHlwZW9mIGx2bCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIWxvZy5sZXZlbHMuaGFzT3duUHJvcGVydHkobHZsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBsdmwgKyAnXCIgaW4gbm90IGEgdmFsaWQgbG9nIGxldmVsJyk7XG4gICAgfVxuICAgIGxldmVsID0gbHZsO1xuICB9XG4gIHJldHVybiBsZXZlbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGV2ZXJ5dGhpbmcgdGhhdCBoYXMgYmVlbiBsb2dnZWQgdG8gdGhlIGhpc3RvcnkuXG4gKlxuICogVGhpcyBhcnJheSBpcyBhIHNoYWxsb3cgY2xvbmUgb2YgdGhlIGludGVybmFsIGhpc3RvcnkgcmVjb3JkLiBIb3dldmVyLCBpdHNcbiAqIGNvbnRlbnRzIGFyZSBfbm90XyBjbG9uZWQ7IHNvLCBtdXRhdGluZyBvYmplY3RzIGluc2lkZSB0aGlzIGFycmF5IHdpbGxcbiAqIG11dGF0ZSB0aGVtIGluIGhpc3RvcnkuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmxvZy5oaXN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaGlzdG9yeSA/IFtdLmNvbmNhdChoaXN0b3J5KSA6IFtdO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGludGVybmFsIGhpc3RvcnkgdHJhY2tpbmcsIGJ1dCBkb2VzIG5vdCBwcmV2ZW50IGZ1cnRoZXIgaGlzdG9yeVxuICogdHJhY2tpbmcuXG4gKi9cbmxvZy5oaXN0b3J5LmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaGlzdG9yeSkge1xuICAgIGhpc3RvcnkubGVuZ3RoID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBEaXNhYmxlIGhpc3RvcnkgdHJhY2tpbmcgaWYgaXQgaXMgY3VycmVudGx5IGVuYWJsZWQuXG4gKi9cbmxvZy5oaXN0b3J5LmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChoaXN0b3J5ICE9PSBudWxsKSB7XG4gICAgaGlzdG9yeS5sZW5ndGggPSAwO1xuICAgIGhpc3RvcnkgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEVuYWJsZSBoaXN0b3J5IHRyYWNraW5nIGlmIGl0IGlzIGN1cnJlbnRseSBkaXNhYmxlZC5cbiAqL1xubG9nLmhpc3RvcnkuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaGlzdG9yeSA9PT0gbnVsbCkge1xuICAgIGhpc3RvcnkgPSBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiBMb2dzIGVycm9yIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLmVycm9yYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkW119IGFyZ3NcbiAqICAgICAgICBPbmUgb3IgbW9yZSBtZXNzYWdlcyBvciBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIGxvZ2dlZCBhcyBhbiBlcnJvclxuICovXG5sb2cuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgcmV0dXJuIGxvZ0J5VHlwZSgnZXJyb3InLCBhcmdzKTtcbn07XG5cbi8qKlxuICogTG9ncyB3YXJuaW5nIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLndhcm5gLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWRbXX0gYXJnc1xuICogICAgICAgIE9uZSBvciBtb3JlIG1lc3NhZ2VzIG9yIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgbG9nZ2VkIGFzIGEgd2FybmluZy5cbiAqL1xubG9nLndhcm4gPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgcmV0dXJuIGxvZ0J5VHlwZSgnd2FybicsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBMb2dzIGRlYnVnIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLmRlYnVnYCwgYnV0IG1heSBhbHNvIGFjdCBhcyBhIGNvbXBhcmFibGVcbiAqIGxvZyBpZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZVxuICpcbiAqIEBwYXJhbSB7TWl4ZWRbXX0gYXJnc1xuICogICAgICAgIE9uZSBvciBtb3JlIG1lc3NhZ2VzIG9yIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgbG9nZ2VkIGFzIGRlYnVnLlxuICovXG5sb2cuZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgcmV0dXJuIGxvZ0J5VHlwZSgnZGVidWcnLCBhcmdzKTtcbn07XG5cbnZhciBsb2ckMSA9IGxvZztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxudmFyIHRhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlID0gZnVuY3Rpb24gKHN0cmluZ3MsIHJhdykge1xuICBzdHJpbmdzLnJhdyA9IHJhdztcbiAgcmV0dXJuIHN0cmluZ3M7XG59O1xuXG4vKipcbiAqIEBmaWxlIG9iai5qc1xuICogQG1vZHVsZSBvYmpcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvYmo6RWFjaENhbGxiYWNrXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAqICAgICAgICBUaGUgY3VycmVudCBrZXkgZm9yIHRoZSBvYmplY3QgdGhhdCBpcyBiZWluZyBpdGVyYXRlZCBvdmVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqICAgICAgICBUaGUgY3VycmVudCBrZXktdmFsdWUgZm9yIG9iamVjdCB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXJcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvYmo6UmVkdWNlQ2FsbGJhY2tcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhY2N1bVxuICogICAgICAgIFRoZSB2YWx1ZSB0aGF0IGlzIGFjY3VtdWxhdGluZyBvdmVyIHRoZSByZWR1Y2UgbG9vcC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogICAgICAgIFRoZSBjdXJyZW50IGtleSBmb3IgdGhlIG9iamVjdCB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogICAgICAgIFRoZSBjdXJyZW50IGtleS12YWx1ZSBmb3Igb2JqZWN0IHRoYXQgaXMgYmVpbmcgaXRlcmF0ZWQgb3ZlclxuICpcbiAqIEByZXR1cm4ge01peGVkfVxuICogICAgICAgICBUaGUgbmV3IGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIEdldCB0aGUga2V5cyBvZiBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqICAgICAgICBUaGUgT2JqZWN0IHRvIGdldCB0aGUga2V5cyBmcm9tXG4gKlxuICogQHJldHVybiB7c3RyaW5nW119XG4gKiAgICAgICAgIEFuIGFycmF5IG9mIHRoZSBrZXlzIGZyb20gdGhlIG9iamVjdC4gUmV0dXJucyBhbiBlbXB0eSBhcnJheSBpZiB0aGVcbiAqICAgICAgICAgb2JqZWN0IHBhc3NlZCBpbiB3YXMgaW52YWxpZCBvciBoYWQgbm8ga2V5cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIga2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc09iamVjdChvYmplY3QpID8gT2JqZWN0LmtleXMob2JqZWN0KSA6IFtdO1xufTtcblxuLyoqXG4gKiBBcnJheS1saWtlIGl0ZXJhdGlvbiBmb3Igb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiAgICAgICAgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXJcbiAqXG4gKiBAcGFyYW0ge29iajpFYWNoQ2FsbGJhY2t9IGZuXG4gKiAgICAgICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBmb3IgZWFjaCBrZXkgaW4gdGhlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZWFjaChvYmplY3QsIGZuKSB7XG4gIGtleXMob2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gZm4ob2JqZWN0W2tleV0sIGtleSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEFycmF5LWxpa2UgcmVkdWNlIGZvciBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqICAgICAgICBUaGUgT2JqZWN0IHRoYXQgeW91IHdhbnQgdG8gcmVkdWNlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiAgICAgICAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGZvciBlYWNoIGtleSBpbiB0aGUgb2JqZWN0LiBJdFxuICogICAgICAgICByZWNlaXZlcyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUgYW5kIHRoZSBwZXItaXRlcmF0aW9uIHZhbHVlIGFuZCBrZXlcbiAqICAgICAgICAgYXMgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IFtpbml0aWFsID0gMF1cbiAqICAgICAgICBTdGFydGluZyB2YWx1ZVxuICpcbiAqIEByZXR1cm4ge01peGVkfVxuICogICAgICAgICBUaGUgZmluYWwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZShvYmplY3QsIGZuKSB7XG4gIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuXG4gIHJldHVybiBrZXlzKG9iamVjdCkucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwga2V5KSB7XG4gICAgcmV0dXJuIGZuKGFjY3VtLCBvYmplY3Rba2V5XSwga2V5KTtcbiAgfSwgaW5pdGlhbCk7XG59XG5cbi8qKlxuICogT2JqZWN0LmFzc2lnbi1zdHlsZSBvYmplY3Qgc2hhbGxvdyBtZXJnZS9leHRlbmQuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSAge09iamVjdH0gLi4uc291cmNlc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNvdXJjZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKE9iamVjdC5hc3NpZ24pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIFt0YXJnZXRdLmNvbmNhdChzb3VyY2VzKSk7XG4gIH1cblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWFjaChzb3VyY2UsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhIHZhbHVlIGlzIGFuIG9iamVjdCBvZiBhbnkga2luZCAtIGluY2x1ZGluZyBET00gbm9kZXMsXG4gKiBhcnJheXMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGV0Yy4gTm90IGZ1bmN0aW9ucywgdGhvdWdoLlxuICpcbiAqIFRoaXMgYXZvaWRzIHRoZSBnb3RjaGEgd2hlcmUgdXNpbmcgYHR5cGVvZmAgb24gYSBgbnVsbGAgdmFsdWVcbiAqIHJlc3VsdHMgaW4gYCdvYmplY3QnYC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGFwcGVhcnMgdG8gYmUgYSBcInBsYWluXCIgb2JqZWN0IC0gdGhhdCBpcywgYVxuICogZGlyZWN0IGluc3RhbmNlIG9mIGBPYmplY3RgLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW4odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn1cblxuLyoqXG4gKiBAZmlsZSBjb21wdXRlZC1zdHlsZS5qc1xuICogQG1vZHVsZSBjb21wdXRlZC1zdHlsZVxuICovXG5cbi8qKlxuICogQSBzYWZlIGdldENvbXB1dGVkU3R5bGUuXG4gKlxuICogVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBpbiBGaXJlZm94LCBpZiB0aGUgcGxheWVyIGlzIGxvYWRlZCBpbiBhbiBpZnJhbWUgd2l0aFxuICogYGRpc3BsYXk6bm9uZWAsIHRoZW4gYGdldENvbXB1dGVkU3R5bGVgIHJldHVybnMgYG51bGxgLCBzbywgd2UgZG8gYSBudWxsLWNoZWNrIHRvXG4gKiBtYWtlIHN1cmUgIHRoYXQgdGhlIHBsYXllciBkb2Vzbid0IGJyZWFrIGluIHRoZXNlIGNhc2VzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgZWxlbWVudCB5b3Ugd2FudCB0aGUgY29tcHV0ZWQgc3R5bGUgb2ZcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICogICAgICAgIFRoZSBwcm9wZXJ0eSBuYW1lIHlvdSB3YW50XG4gKlxuICogQHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZWRTdHlsZShlbCwgcHJvcCkge1xuICBpZiAoIWVsIHx8ICFwcm9wKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3ckMS5nZXRDb21wdXRlZFN0eWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGNzID0gd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cbiAgICByZXR1cm4gY3MgPyBjc1twcm9wXSA6ICcnO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgX3RlbXBsYXRlT2JqZWN0ID0gdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UoWydTZXR0aW5nIGF0dHJpYnV0ZXMgaW4gdGhlIHNlY29uZCBhcmd1bWVudCBvZiBjcmVhdGVFbCgpXFxuICAgICAgICAgICAgICAgIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSB0aGUgdGhpcmQgYXJndW1lbnQgaW5zdGVhZC5cXG4gICAgICAgICAgICAgICAgY3JlYXRlRWwodHlwZSwgcHJvcGVydGllcywgYXR0cmlidXRlcykuIEF0dGVtcHRpbmcgdG8gc2V0ICcsICcgdG8gJywgJy4nXSwgWydTZXR0aW5nIGF0dHJpYnV0ZXMgaW4gdGhlIHNlY29uZCBhcmd1bWVudCBvZiBjcmVhdGVFbCgpXFxuICAgICAgICAgICAgICAgIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSB0aGUgdGhpcmQgYXJndW1lbnQgaW5zdGVhZC5cXG4gICAgICAgICAgICAgICAgY3JlYXRlRWwodHlwZSwgcHJvcGVydGllcywgYXR0cmlidXRlcykuIEF0dGVtcHRpbmcgdG8gc2V0ICcsICcgdG8gJywgJy4nXSk7XG5cbi8qKlxuICogRGV0ZWN0IGlmIGEgdmFsdWUgaXMgYSBzdHJpbmcgd2l0aCBhbnkgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiAgICAgICAgVGhlIHN0cmluZyB0byBjaGVja1xuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIG5vbi1ibGFua1xuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICpcbiAqL1xuZnVuY3Rpb24gaXNOb25CbGFua1N0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmIC9cXFMvLnRlc3Qoc3RyKTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHBhc3NlZCBzdHJpbmcgaGFzIHdoaXRlc3BhY2UuIFRoaXMgaXMgdXNlZCBieVxuICogY2xhc3MgbWV0aG9kcyB0byBiZSByZWxhdGl2ZWx5IGNvbnNpc3RlbnQgd2l0aCB0aGUgY2xhc3NMaXN0IEFQSS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiAgICAgICAgIFRoZSBzdHJpbmcgdG8gY2hlY2sgZm9yIHdoaXRlc3BhY2UuXG4gKlxuICogQHRocm93cyB7RXJyb3J9XG4gKiAgICAgICAgIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBpcyB3aGl0ZXNwYWNlIGluIHRoZSBzdHJpbmcuXG4gKlxuICovXG5mdW5jdGlvbiB0aHJvd0lmV2hpdGVzcGFjZShzdHIpIHtcbiAgaWYgKC9cXHMvLnRlc3Qoc3RyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xhc3MgaGFzIGlsbGVnYWwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9kdWNlIGEgcmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyBhIGNsYXNzTmFtZSB3aXRoaW4gYW4gZWxlbWVudHMgY2xhc3NOYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAqICAgICAgICAgVGhlIGNsYXNzTmFtZSB0byBnZW5lcmF0ZSB0aGUgUmVnRXhwIGZvci5cbiAqXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiAgICAgICAgIFRoZSBSZWdFeHAgdGhhdCB3aWxsIGNoZWNrIGZvciBhIHNwZWNpZmljIGBjbGFzc05hbWVgIGluIGFuIGVsZW1lbnRzXG4gKiAgICAgICAgIGNsYXNzTmFtZS5cbiAqL1xuZnVuY3Rpb24gY2xhc3NSZWdFeHAoY2xhc3NOYW1lKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgY2xhc3NOYW1lICsgJygkfFxcXFxzKScpO1xufVxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgRE9NIGludGVyZmFjZSBhcHBlYXJzIHRvIGJlIHJlYWwuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNSZWFsKCkge1xuICAvLyBCb3RoIGRvY3VtZW50IGFuZCB3aW5kb3cgd2lsbCBuZXZlciBiZSB1bmRlZmluZWQgdGhhbmtzIHRvIGBnbG9iYWxgLlxuICByZXR1cm4gZG9jdW1lbnQgPT09IHdpbmRvdyQxLmRvY3VtZW50O1xufVxuXG4vKipcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIERPTSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiAgICAgICAgVGhlIHRoaW5nIHRvIGNoZWNrXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIGl0IGlzIGEgRE9NIGVsZW1lbnRcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNFbCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgRE9NIGlzIGVtYmVkZGVkIGluIGFuIGlmcmFtZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICpcbiAqL1xuZnVuY3Rpb24gaXNJbkZyYW1lKCkge1xuXG4gIC8vIFdlIG5lZWQgYSB0cnkvY2F0Y2ggaGVyZSBiZWNhdXNlIFNhZmFyaSB3aWxsIHRocm93IGVycm9ycyB3aGVuIGF0dGVtcHRpbmdcbiAgLy8gdG8gZ2V0IGVpdGhlciBgcGFyZW50YCBvciBgc2VsZmBcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93JDEucGFyZW50ICE9PSB3aW5kb3ckMS5zZWxmO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGZ1bmN0aW9ucyB0byBxdWVyeSB0aGUgRE9NIHVzaW5nIGEgZ2l2ZW4gbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqICAgICAgICAgVGhlIG1ldGhvZCB0byBjcmVhdGUgdGhlIHF1ZXJ5IHdpdGguXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiAgICAgICAgIFRoZSBxdWVyeSBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUXVlcmllcihtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCkge1xuICAgIGlmICghaXNOb25CbGFua1N0cmluZyhzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudFttZXRob2RdKG51bGwpO1xuICAgIH1cbiAgICBpZiAoaXNOb25CbGFua1N0cmluZyhjb250ZXh0KSkge1xuICAgICAgY29udGV4dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGV4dCk7XG4gICAgfVxuXG4gICAgdmFyIGN0eCA9IGlzRWwoY29udGV4dCkgPyBjb250ZXh0IDogZG9jdW1lbnQ7XG5cbiAgICByZXR1cm4gY3R4W21ldGhvZF0gJiYgY3R4W21ldGhvZF0oc2VsZWN0b3IpO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZWxlbWVudCBhbmQgYXBwbGllcyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGFnTmFtZT0nZGl2J11cbiAqICAgICAgICAgTmFtZSBvZiB0YWcgdG8gYmUgY3JlYXRlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dXG4gKiAgICAgICAgIEVsZW1lbnQgcHJvcGVydGllcyB0byBiZSBhcHBsaWVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlcz17fV1cbiAqICAgICAgICAgRWxlbWVudCBhdHRyaWJ1dGVzIHRvIGJlIGFwcGxpZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gW2NvbnRlbnRdXG4gKiAgICAgICAgIENvbnRlbnRzIGZvciB0aGUgZWxlbWVudCAoc2VlOiB7QGxpbmsgZG9tOm5vcm1hbGl6ZUNvbnRlbnR9KVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICB2YXIgdGFnTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2Rpdic7XG4gIHZhciBwcm9wZXJ0aWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgY29udGVudCA9IGFyZ3VtZW50c1szXTtcblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgdmFyIHZhbCA9IHByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXG4gICAgLy8gU2VlICMyMTc2XG4gICAgLy8gV2Ugb3JpZ2luYWxseSB3ZXJlIGFjY2VwdGluZyBib3RoIHByb3BlcnRpZXMgYW5kIGF0dHJpYnV0ZXMgaW4gdGhlXG4gICAgLy8gc2FtZSBvYmplY3QsIGJ1dCB0aGF0IGRvZXNuJ3Qgd29yayBzbyB3ZWxsLlxuICAgIGlmIChwcm9wTmFtZS5pbmRleE9mKCdhcmlhLScpICE9PSAtMSB8fCBwcm9wTmFtZSA9PT0gJ3JvbGUnIHx8IHByb3BOYW1lID09PSAndHlwZScpIHtcbiAgICAgIGxvZyQxLndhcm4odHNtbChfdGVtcGxhdGVPYmplY3QsIHByb3BOYW1lLCB2YWwpKTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShwcm9wTmFtZSwgdmFsKTtcblxuICAgICAgLy8gSGFuZGxlIHRleHRDb250ZW50IHNpbmNlIGl0J3Mgbm90IHN1cHBvcnRlZCBldmVyeXdoZXJlIGFuZCB3ZSBoYXZlIGFcbiAgICAgIC8vIG1ldGhvZCBmb3IgaXQuXG4gICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PT0gJ3RleHRDb250ZW50Jykge1xuICAgICAgdGV4dENvbnRlbnQoZWwsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsW3Byb3BOYW1lXSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyaWJ1dGVzW2F0dHJOYW1lXSk7XG4gIH0pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgYXBwZW5kQ29udGVudChlbCwgY29udGVudCk7XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogSW5qZWN0cyB0ZXh0IGludG8gYW4gZWxlbWVudCwgcmVwbGFjaW5nIGFueSBleGlzdGluZyBjb250ZW50cyBlbnRpcmVseS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgVGhlIGVsZW1lbnQgdG8gYWRkIHRleHQgY29udGVudCBpbnRvXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqICAgICAgICBUaGUgdGV4dCBjb250ZW50IHRvIGFkZC5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIGFkZGVkIHRleHQgY29udGVudC5cbiAqL1xuZnVuY3Rpb24gdGV4dENvbnRlbnQoZWwsIHRleHQpIHtcbiAgaWYgKHR5cGVvZiBlbC50ZXh0Q29udGVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbC5pbm5lclRleHQgPSB0ZXh0O1xuICB9IGVsc2Uge1xuICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogSW5zZXJ0IGFuIGVsZW1lbnQgYXMgdGhlIGZpcnN0IGNoaWxkIG5vZGUgb2YgYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gY2hpbGRcbiAqICAgICAgICBFbGVtZW50IHRvIGluc2VydFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50XG4gKiAgICAgICAgRWxlbWVudCB0byBpbnNlcnQgY2hpbGQgaW50b1xuICovXG5mdW5jdGlvbiBwcmVwZW5kVG8oY2hpbGQsIHBhcmVudCkge1xuICBpZiAocGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBwYXJlbnQuZmlyc3RDaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaGFzIGEgQ1NTIGNsYXNzXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgICAgICAgRWxlbWVudCB0byBjaGVja1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvQ2hlY2tcbiAqICAgICAgICBDbGFzcyBuYW1lIHRvIGNoZWNrIGZvclxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgZWxlbWVudCBoYWQgdGhlIGNsYXNzXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogICAgICAgICBUaHJvd3MgYW4gZXJyb3IgaWYgYGNsYXNzVG9DaGVja2AgaGFzIHdoaXRlIHNwYWNlLlxuICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBjbGFzc1RvQ2hlY2spIHtcbiAgdGhyb3dJZldoaXRlc3BhY2UoY2xhc3NUb0NoZWNrKTtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzVG9DaGVjayk7XG4gIH1cbiAgcmV0dXJuIGNsYXNzUmVnRXhwKGNsYXNzVG9DaGVjaykudGVzdChlbGVtZW50LmNsYXNzTmFtZSk7XG59XG5cbi8qKlxuICogQWRkIGEgQ1NTIGNsYXNzIG5hbWUgdG8gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICAgICAgIEVsZW1lbnQgdG8gYWRkIGNsYXNzIG5hbWUgdG8uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9BZGRcbiAqICAgICAgICBDbGFzcyBuYW1lIHRvIGFkZC5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZG9tIGVsZW1lbnQgd2l0aCB0aGUgYWRkZWQgY2xhc3MgbmFtZS5cbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NUb0FkZCkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NUb0FkZCk7XG5cbiAgICAvLyBEb24ndCBuZWVkIHRvIGB0aHJvd0lmV2hpdGVzcGFjZWAgaGVyZSBiZWNhdXNlIGBoYXNFbENsYXNzYCB3aWxsIGRvIGl0XG4gICAgLy8gaW4gdGhlIGNhc2Ugb2YgY2xhc3NMaXN0IG5vdCBiZWluZyBzdXBwb3J0ZWQuXG4gIH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzVG9BZGQpKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSAoZWxlbWVudC5jbGFzc05hbWUgKyAnICcgKyBjbGFzc1RvQWRkKS50cmltKCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBDU1MgY2xhc3MgbmFtZSBmcm9tIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgICAgICBFbGVtZW50IHRvIHJlbW92ZSBhIGNsYXNzIG5hbWUgZnJvbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb1JlbW92ZVxuICogICAgICAgIENsYXNzIG5hbWUgdG8gcmVtb3ZlXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGRvbSBlbGVtZW50IHdpdGggY2xhc3MgbmFtZSByZW1vdmVkLlxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc1RvUmVtb3ZlKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc1RvUmVtb3ZlKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvd0lmV2hpdGVzcGFjZShjbGFzc1RvUmVtb3ZlKTtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLykuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYyAhPT0gY2xhc3NUb1JlbW92ZTtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBUaGUgY2FsbGJhY2sgZGVmaW5pdGlvbiBmb3IgdG9nZ2xlRWxDbGFzcy5cbiAqXG4gKiBAY2FsbGJhY2sgRG9tflByZWRpY2F0ZUNhbGxiYWNrXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgICAgICBUaGUgRE9NIGVsZW1lbnQgb2YgdGhlIENvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb1RvZ2dsZVxuICogICAgICAgIFRoZSBgY2xhc3NOYW1lYCB0aGF0IHdhbnRzIHRvIGJlIHRvZ2dsZWRcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAqICAgICAgICAgLSBJZiB0cnVlIHRoZSBgY2xhc3NUb1RvZ2dsZWAgd2lsbCBnZXQgYWRkZWQgdG8gYGVsZW1lbnRgLlxuICogICAgICAgICAtIElmIGZhbHNlIHRoZSBgY2xhc3NUb1RvZ2dsZWAgd2lsbCBnZXQgcmVtb3ZlZCBmcm9tIGBlbGVtZW50YC5cbiAqICAgICAgICAgLSBJZiB1bmRlZmluZWQgdGhpcyBjYWxsYmFjayB3aWxsIGJlIGlnbm9yZWRcbiAqL1xuXG4vKipcbiAqIEFkZHMgb3IgcmVtb3ZlcyBhIENTUyBjbGFzcyBuYW1lIG9uIGFuIGVsZW1lbnQgZGVwZW5kaW5nIG9uIGFuIG9wdGlvbmFsXG4gKiBjb25kaXRpb24gb3IgdGhlIHByZXNlbmNlL2Fic2VuY2Ugb2YgdGhlIGNsYXNzIG5hbWUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgICAgICAgVGhlIGVsZW1lbnQgdG8gdG9nZ2xlIGEgY2xhc3MgbmFtZSBvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb1RvZ2dsZVxuICogICAgICAgIFRoZSBjbGFzcyB0aGF0IHNob3VsZCBiZSB0b2dnbGVkXG4gKlxuICogQHBhcmFtIHtib29sZWFufFByZWRpY2F0ZUNhbGxiYWNrfSBbcHJlZGljYXRlXVxuICogICAgICAgIFNlZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB7QGxpbmsgRG9tflByZWRpY2F0ZUNhbGxiYWNrfVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHdpdGggYSBjbGFzcyB0aGF0IGhhcyBiZWVuIHRvZ2dsZWQuXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIGNsYXNzVG9Ub2dnbGUsIHByZWRpY2F0ZSkge1xuXG4gIC8vIFRoaXMgQ0FOTk9UIHVzZSBgY2xhc3NMaXN0YCBpbnRlcm5hbGx5IGJlY2F1c2UgSUUxMSBkb2VzIG5vdCBzdXBwb3J0IHRoZVxuICAvLyBzZWNvbmQgcGFyYW1ldGVyIHRvIHRoZSBgY2xhc3NMaXN0LnRvZ2dsZSgpYCBtZXRob2QhIFdoaWNoIGlzIGZpbmUgYmVjYXVzZVxuICAvLyBgY2xhc3NMaXN0YCB3aWxsIGJlIHVzZWQgYnkgdGhlIGFkZC9yZW1vdmUgZnVuY3Rpb25zLlxuICB2YXIgaGFzID0gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XG5cbiAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcmVkaWNhdGUgPSBwcmVkaWNhdGUoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcHJlZGljYXRlID0gIWhhcztcbiAgfVxuXG4gIC8vIElmIHRoZSBuZWNlc3NhcnkgY2xhc3Mgb3BlcmF0aW9uIG1hdGNoZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlXG4gIC8vIGVsZW1lbnQsIG5vIGFjdGlvbiBpcyByZXF1aXJlZC5cbiAgaWYgKHByZWRpY2F0ZSA9PT0gaGFzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByZWRpY2F0ZSkge1xuICAgIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzVG9Ub2dnbGUpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzVG9Ub2dnbGUpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQXBwbHkgYXR0cmlidXRlcyB0byBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgdG8gYWRkIGF0dHJpYnV0ZXMgdG8uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXVxuICogICAgICAgIEF0dHJpYnV0ZXMgdG8gYmUgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbCwgYXR0cmlidXRlcykge1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyaWJ1dGVzW2F0dHJOYW1lXTtcblxuICAgIGlmIChhdHRyVmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIGF0dHJWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXR0clZhbHVlID09PSBmYWxzZSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUgPT09IHRydWUgPyAnJyA6IGF0dHJWYWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZSB2YWx1ZXMsIGFzIGRlZmluZWQgb24gdGhlIEhUTUwgdGFnXG4gKiBBdHRyaWJ1dGVzIGFyZSBub3QgdGhlIHNhbWUgYXMgcHJvcGVydGllcy4gVGhleSdyZSBkZWZpbmVkIG9uIHRoZSB0YWdcbiAqIG9yIHdpdGggc2V0QXR0cmlidXRlICh3aGljaCBzaG91bGRuJ3QgYmUgdXNlZCB3aXRoIEhUTUwpXG4gKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgb3IgZmFsc2UgZm9yIGJvb2xlYW4gYXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhZ1xuICogICAgICAgIEVsZW1lbnQgZnJvbSB3aGljaCB0byBnZXQgdGFnIGF0dHJpYnV0ZXMuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBBbGwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyh0YWcpIHtcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIC8vIGtub3duIGJvb2xlYW4gYXR0cmlidXRlc1xuICAvLyB3ZSBjYW4gY2hlY2sgZm9yIG1hdGNoaW5nIGJvb2xlYW4gcHJvcGVydGllcywgYnV0IG5vdCBhbGwgYnJvd3NlcnNcbiAgLy8gYW5kIG5vdCBhbGwgdGFncyBrbm93IGFib3V0IHRoZXNlIGF0dHJpYnV0ZXMsIHNvLCB3ZSBzdGlsbCB3YW50IHRvIGNoZWNrIHRoZW0gbWFudWFsbHlcbiAgdmFyIGtub3duQm9vbGVhbnMgPSAnLCcgKyAnYXV0b3BsYXksY29udHJvbHMscGxheXNpbmxpbmUsbG9vcCxtdXRlZCxkZWZhdWx0LGRlZmF1bHRNdXRlZCcgKyAnLCc7XG5cbiAgaWYgKHRhZyAmJiB0YWcuYXR0cmlidXRlcyAmJiB0YWcuYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGF0dHJzID0gdGFnLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKHZhciBpID0gYXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhdHRyTmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICB2YXIgYXR0clZhbCA9IGF0dHJzW2ldLnZhbHVlO1xuXG4gICAgICAvLyBjaGVjayBmb3Iga25vd24gYm9vbGVhbnNcbiAgICAgIC8vIHRoZSBtYXRjaGluZyBlbGVtZW50IHByb3BlcnR5IHdpbGwgcmV0dXJuIGEgdmFsdWUgZm9yIHR5cGVvZlxuICAgICAgaWYgKHR5cGVvZiB0YWdbYXR0ck5hbWVdID09PSAnYm9vbGVhbicgfHwga25vd25Cb29sZWFucy5pbmRleE9mKCcsJyArIGF0dHJOYW1lICsgJywnKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gdGhlIHZhbHVlIG9mIGFuIGluY2x1ZGVkIGJvb2xlYW4gYXR0cmlidXRlIGlzIHR5cGljYWxseSBhbiBlbXB0eVxuICAgICAgICAvLyBzdHJpbmcgKCcnKSB3aGljaCB3b3VsZCBlcXVhbCBmYWxzZSBpZiB3ZSBqdXN0IGNoZWNrIGZvciBhIGZhbHNlIHZhbHVlLlxuICAgICAgICAvLyB3ZSBhbHNvIGRvbid0IHdhbnQgc3VwcG9ydCBiYWQgY29kZSBsaWtlIGF1dG9wbGF5PSdmYWxzZSdcbiAgICAgICAgYXR0clZhbCA9IGF0dHJWYWwgIT09IG51bGwgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG9ialthdHRyTmFtZV0gPSBhdHRyVmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhbiBlbGVtZW50J3MgYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEEgRE9NIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiAgICAgICAgQXR0cmlidXRlIHRvIGdldCB0aGUgdmFsdWUgb2ZcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGVsLCBhdHRyaWJ1dGUpIHtcbiAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBBIERPTSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogICAgICAgIEF0dHJpYnV0ZSB0byBzZXRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqICAgICAgICBWYWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZSB0b1xuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZWwsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgZWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbiBlbGVtZW50J3MgYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEEgRE9NIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiAgICAgICAgQXR0cmlidXRlIHRvIHJlbW92ZVxuICovXG5mdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoZWwsIGF0dHJpYnV0ZSkge1xuICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGJsb2NrIHRoZSBhYmlsaXR5IHRvIHNlbGVjdCB0ZXh0IHdoaWxlIGRyYWdnaW5nIGNvbnRyb2xzXG4gKi9cbmZ1bmN0aW9uIGJsb2NrVGV4dFNlbGVjdGlvbigpIHtcbiAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICBkb2N1bWVudC5vbnNlbGVjdHN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJuIG9mZiB0ZXh0IHNlbGVjdGlvbiBibG9ja2luZ1xuICovXG5mdW5jdGlvbiB1bmJsb2NrVGV4dFNlbGVjdGlvbigpIHtcbiAgZG9jdW1lbnQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBJZGVudGljYWwgdG8gdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBmdW5jdGlvbiwgYnV0IGVuc3VyZXMgdGhhdFxuICogdGhlIG1ldGhvZCBpcyBzdXBwb3J0ZWQgYXQgYWxsIChpdCBpcyBpbiBhbGwgYnJvd3NlcnMgd2UgY2xhaW0gdG8gc3VwcG9ydClcbiAqIGFuZCB0aGF0IHRoZSBlbGVtZW50IGlzIGluIHRoZSBET00gYmVmb3JlIGNvbnRpbnVpbmcuXG4gKlxuICogVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGFsc28gc2hpbXMgcHJvcGVydGllcyB3aGljaCBhcmUgbm90IHByb3ZpZGVkIGJ5IHNvbWVcbiAqIG9sZGVyIGJyb3dzZXJzIChuYW1lbHksIElFOCkuXG4gKlxuICogQWRkaXRpb25hbGx5LCBzb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGFkZGluZyBwcm9wZXJ0aWVzIHRvIGFcbiAqIGBDbGllbnRSZWN0YC9gRE9NUmVjdGAgb2JqZWN0OyBzbywgd2Ugc2hhbGxvdy1jb3B5IGl0IHdpdGggdGhlIHN0YW5kYXJkXG4gKiBwcm9wZXJ0aWVzIChleGNlcHQgYHhgIGFuZCBgeWAgd2hpY2ggYXJlIG5vdCB3aWRlbHkgc3VwcG9ydGVkKS4gVGhpcyBoZWxwc1xuICogYXZvaWQgaW1wbGVtZW50YXRpb25zIHdoZXJlIGtleXMgYXJlIG5vbi1lbnVtZXJhYmxlLlxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgIEVsZW1lbnQgd2hvc2UgYENsaWVudFJlY3RgIHdlIHdhbnQgdG8gY2FsY3VsYXRlLlxuICpcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKiAgICAgICAgIEFsd2F5cyByZXR1cm5zIGEgcGxhaW5cbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gIGlmIChlbCAmJiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgZWwucGFyZW50Tm9kZSkge1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgWydib3R0b20nLCAnaGVpZ2h0JywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ3dpZHRoJ10uZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKHJlY3Rba10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHRba10gPSByZWN0W2tdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXN1bHQuaGVpZ2h0KSB7XG4gICAgICByZXN1bHQuaGVpZ2h0ID0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlKGVsLCAnaGVpZ2h0JykpO1xuICAgIH1cblxuICAgIGlmICghcmVzdWx0LndpZHRoKSB7XG4gICAgICByZXN1bHQud2lkdGggPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUoZWwsICd3aWR0aCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogVGhlIHBvc3Rpb24gb2YgYSBET00gZWxlbWVudCBvbiB0aGUgcGFnZS5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6ZG9tflBvc2l0aW9uXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnRcbiAqICAgICAgICAgICBQaXhlbHMgdG8gdGhlIGxlZnRcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gdG9wXG4gKiAgICAgICAgICAgUGl4ZWxzIG9uIHRvcFxuICovXG5cbi8qKlxuICogT2Zmc2V0IExlZnQuXG4gKiBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdGVjaG5pcXVlIGZyb21cbiAqIEpvaG4gUmVzaWdcbiAqXG4gKiBAc2VlIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9nZXRib3VuZGluZ2NsaWVudHJlY3QtaXMtYXdlc29tZS9cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCBmcm9tIHdoaWNoIHRvIGdldCBvZmZzZXRcbiAqXG4gKiBAcmV0dXJuIHttb2R1bGU6ZG9tflBvc2l0aW9ufVxuICogICAgICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIGluLlxuICovXG5mdW5jdGlvbiBmaW5kUG9zaXRpb24oZWwpIHtcbiAgdmFyIGJveCA9IHZvaWQgMDtcblxuICBpZiAoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICBib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuXG4gIGlmICghYm94KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICB9XG5cbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cbiAgdmFyIGNsaWVudExlZnQgPSBkb2NFbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbmRvdyQxLnBhZ2VYT2Zmc2V0IHx8IGJvZHkuc2Nyb2xsTGVmdDtcbiAgdmFyIGxlZnQgPSBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0O1xuXG4gIHZhciBjbGllbnRUb3AgPSBkb2NFbC5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbmRvdyQxLnBhZ2VZT2Zmc2V0IHx8IGJvZHkuc2Nyb2xsVG9wO1xuICB2YXIgdG9wID0gYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcDtcblxuICAvLyBBbmRyb2lkIHNvbWV0aW1lcyByZXR1cm5zIHNsaWdodGx5IG9mZiBkZWNpbWFsIHZhbHVlcywgc28gbmVlZCB0byByb3VuZFxuICByZXR1cm4ge1xuICAgIGxlZnQ6IE1hdGgucm91bmQobGVmdCksXG4gICAgdG9wOiBNYXRoLnJvdW5kKHRvcClcbiAgfTtcbn1cblxuLyoqXG4gKiB4IGFuZCB5IGNvb3JkaW5hdGVzIGZvciBhIGRvbSBlbGVtZW50IG9yIG1vdXNlIHBvaW50ZXJcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEb21+Q29vcmRpbmF0ZXNcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0geFxuICogICAgICAgICAgIHggY29vcmRpbmF0ZSBpbiBwaXhlbHNcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0geVxuICogICAgICAgICAgIHkgY29vcmRpbmF0ZSBpbiBwaXhlbHNcbiAqL1xuXG4vKipcbiAqIEdldCBwb2ludGVyIHBvc2l0aW9uIGluIGVsZW1lbnRcbiAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggeCBhbmQgeSBjb29yZGluYXRlcy5cbiAqIFRoZSBiYXNlIG9uIHRoZSBjb29yZGluYXRlcyBhcmUgdGhlIGJvdHRvbSBsZWZ0IG9mIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBFbGVtZW50IG9uIHdoaWNoIHRvIGdldCB0aGUgcG9pbnRlciBwb3NpdGlvbiBvblxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gKiAgICAgICAgRXZlbnQgb2JqZWN0XG4gKlxuICogQHJldHVybiB7RG9tfkNvb3JkaW5hdGVzfVxuICogICAgICAgICBBIENvb3JkaW5hdGVzIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBtb3VzZSBwb3NpdGlvbi5cbiAqXG4gKi9cbmZ1bmN0aW9uIGdldFBvaW50ZXJQb3NpdGlvbihlbCwgZXZlbnQpIHtcbiAgdmFyIHBvc2l0aW9uID0ge307XG4gIHZhciBib3ggPSBmaW5kUG9zaXRpb24oZWwpO1xuICB2YXIgYm94VyA9IGVsLm9mZnNldFdpZHRoO1xuICB2YXIgYm94SCA9IGVsLm9mZnNldEhlaWdodDtcblxuICB2YXIgYm94WSA9IGJveC50b3A7XG4gIHZhciBib3hYID0gYm94LmxlZnQ7XG4gIHZhciBwYWdlWSA9IGV2ZW50LnBhZ2VZO1xuICB2YXIgcGFnZVggPSBldmVudC5wYWdlWDtcblxuICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICBwYWdlWCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgIHBhZ2VZID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG4gIH1cblxuICBwb3NpdGlvbi55ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKGJveFkgLSBwYWdlWSArIGJveEgpIC8gYm94SCkpO1xuICBwb3NpdGlvbi54ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHBhZ2VYIC0gYm94WCkgLyBib3hXKSk7XG5cbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuXG4vKipcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIHRleHQgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogICAgICAgIENoZWNrIGlmIHRoaXMgdmFsdWUgaXMgYSB0ZXh0IG5vZGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIGl0IGlzIGEgdGV4dCBub2RlXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMztcbn1cblxuLyoqXG4gKiBFbXB0aWVzIHRoZSBjb250ZW50cyBvZiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byBlbXB0eSBjaGlsZHJlbiBmcm9tXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgd2l0aCBubyBjaGlsZHJlblxuICovXG5mdW5jdGlvbiBlbXB0eUVsKGVsKSB7XG4gIHdoaWxlIChlbC5maXJzdENoaWxkKSB7XG4gICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgY29udGVudCBmb3IgZXZlbnR1YWwgaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAqXG4gKiBUaGlzIGFsbG93cyBhIHdpZGUgcmFuZ2Ugb2YgY29udGVudCBkZWZpbml0aW9uIG1ldGhvZHMsIGJ1dCBwcm90ZWN0c1xuICogZnJvbSBmYWxsaW5nIGludG8gdGhlIHRyYXAgb2Ygc2ltcGx5IHdyaXRpbmcgdG8gYGlubmVySFRNTGAsIHdoaWNoIGlzXG4gKiBhbiBYU1MgY29uY2Vybi5cbiAqXG4gKiBUaGUgY29udGVudCBmb3IgYW4gZWxlbWVudCBjYW4gYmUgcGFzc2VkIGluIG11bHRpcGxlIHR5cGVzIGFuZFxuICogY29tYmluYXRpb25zLCB3aG9zZSBiZWhhdmlvciBpcyBhcyBmb2xsb3dzOlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8VGV4dE5vZGV8QXJyYXl8RnVuY3Rpb259IGNvbnRlbnRcbiAqICAgICAgICAtIFN0cmluZzogTm9ybWFsaXplZCBpbnRvIGEgdGV4dCBub2RlLlxuICogICAgICAgIC0gRWxlbWVudC9UZXh0Tm9kZTogUGFzc2VkIHRocm91Z2guXG4gKiAgICAgICAgLSBBcnJheTogQSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2Ygc3RyaW5ncywgZWxlbWVudHMsIG5vZGVzLCBvciBmdW5jdGlvbnNcbiAqICAgICAgICAgICh3aGljaCByZXR1cm4gc2luZ2xlIHN0cmluZ3MsIGVsZW1lbnRzLCBvciBub2RlcykuXG4gKiAgICAgICAgLSBGdW5jdGlvbjogSWYgdGhlIHNvbGUgYXJndW1lbnQsIGlzIGV4cGVjdGVkIHRvIHByb2R1Y2UgYSBzdHJpbmcsIGVsZW1lbnQsXG4gKiAgICAgICAgICBub2RlLCBvciBhcnJheSBhcyBkZWZpbmVkIGFib3ZlLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBBbGwgb2YgdGhlIGNvbnRlbnQgdGhhdCB3YXMgcGFzc2VkIGluIG5vcm1hbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRlbnQoY29udGVudCkge1xuXG4gIC8vIEZpcnN0LCBpbnZva2UgY29udGVudCBpZiBpdCBpcyBhIGZ1bmN0aW9uLiBJZiBpdCBwcm9kdWNlcyBhbiBhcnJheSxcbiAgLy8gdGhhdCBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIG5vcm1hbGl6YXRpb24uXG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnRlbnQgPSBjb250ZW50KCk7XG4gIH1cblxuICAvLyBOZXh0IHVwLCBub3JtYWxpemUgdG8gYW4gYXJyYXksIHNvIG9uZSBvciBtYW55IGl0ZW1zIGNhbiBiZSBub3JtYWxpemVkLFxuICAvLyBmaWx0ZXJlZCwgYW5kIHJldHVybmVkLlxuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICAvLyBGaXJzdCwgaW52b2tlIHZhbHVlIGlmIGl0IGlzIGEgZnVuY3Rpb24gdG8gcHJvZHVjZSBhIG5ldyB2YWx1ZSxcbiAgICAvLyB3aGljaCB3aWxsIGJlIHN1YnNlcXVlbnRseSBub3JtYWxpemVkIHRvIGEgTm9kZSBvZiBzb21lIGtpbmQuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgIH1cblxuICAgIGlmIChpc0VsKHZhbHVlKSB8fCBpc1RleHROb2RlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIC9cXFMvLnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgIH1cbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBhbmQgYXBwZW5kcyBjb250ZW50IHRvIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgdG8gYXBwZW5kIG5vcm1hbGl6ZWQgY29udGVudCB0by5cbiAqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gY29udGVudFxuICogICAgICAgIFNlZSB0aGUgYGNvbnRlbnRgIGFyZ3VtZW50IG9mIHtAbGluayBkb206bm9ybWFsaXplQ29udGVudH1cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIGFwcGVuZGVkIG5vcm1hbGl6ZWQgY29udGVudC5cbiAqL1xuZnVuY3Rpb24gYXBwZW5kQ29udGVudChlbCwgY29udGVudCkge1xuICBub3JtYWxpemVDb250ZW50KGNvbnRlbnQpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gZWwuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIH0pO1xuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBhbmQgaW5zZXJ0cyBjb250ZW50IGludG8gYW4gZWxlbWVudDsgdGhpcyBpcyBpZGVudGljYWwgdG9cbiAqIGBhcHBlbmRDb250ZW50KClgLCBleGNlcHQgaXQgZW1wdGllcyB0aGUgZWxlbWVudCBmaXJzdC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCB0byBpbnNlcnQgbm9ybWFsaXplZCBjb250ZW50IGludG8uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gY29udGVudFxuICogICAgICAgIFNlZSB0aGUgYGNvbnRlbnRgIGFyZ3VtZW50IG9mIHtAbGluayBkb206bm9ybWFsaXplQ29udGVudH1cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIGluc2VydGVkIG5vcm1hbGl6ZWQgY29udGVudC5cbiAqXG4gKi9cbmZ1bmN0aW9uIGluc2VydENvbnRlbnQoZWwsIGNvbnRlbnQpIHtcbiAgcmV0dXJuIGFwcGVuZENvbnRlbnQoZW1wdHlFbChlbCksIGNvbnRlbnQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGV2ZW50IHdhcyBhIHNpbmdsZSBsZWZ0IGNsaWNrXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAqICAgICAgICBFdmVudCBvYmplY3RcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgYSBsZWZ0IGNsaWNrXG4gKiAgICAgICAgIC0gRmFsc2UgaWYgbm90IGEgbGVmdCBjbGlja1xuICovXG5mdW5jdGlvbiBpc1NpbmdsZUxlZnRDbGljayhldmVudCkge1xuICAvLyBOb3RlOiBpZiB5b3UgY3JlYXRlIHNvbWV0aGluZyBkcmFnZ2FibGUsIGJlIHN1cmUgdG9cbiAgLy8gY2FsbCBpdCBvbiBib3RoIGBtb3VzZWRvd25gIGFuZCBgbW91c2Vtb3ZlYCBldmVudCxcbiAgLy8gb3RoZXJ3aXNlIGBtb3VzZWRvd25gIHNob3VsZCBiZSBlbm91Z2ggZm9yIGEgYnV0dG9uXG5cbiAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gdW5kZWZpbmVkICYmIGV2ZW50LmJ1dHRvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdoeSBkbyB3ZSBuZWVkIGBidXR0b25zYCA/XG4gICAgLy8gQmVjYXVzZSwgbWlkZGxlIG1vdXNlIHNvbWV0aW1lcyBoYXZlIHRoaXM6XG4gICAgLy8gZS5idXR0b24gPT09IDAgYW5kIGUuYnV0dG9ucyA9PT0gNFxuICAgIC8vIEZ1cnRoZXJtb3JlLCB3ZSB3YW50IHRvIHByZXZlbnQgY29tYmluYXRpb24gY2xpY2ssIHNvbWV0aGluZyBsaWtlXG4gICAgLy8gSE9MRCBtaWRkbGVtb3VzZSB0aGVuIGxlZnQgY2xpY2ssIHRoYXQgd291bGQgYmVcbiAgICAvLyBlLmJ1dHRvbiA9PT0gMCwgZS5idXR0b25zID09PSA1XG4gICAgLy8ganVzdCBgYnV0dG9uYCBpcyBub3QgZ29ubmEgd29ya1xuXG4gICAgLy8gQWxyaWdodCwgdGhlbiB3aGF0IHRoaXMgYmxvY2sgZG9lcyA/XG4gICAgLy8gdGhpcyBpcyBmb3IgY2hyb21lIGBzaW11bGF0ZSBtb2JpbGUgZGV2aWNlc2BcbiAgICAvLyBJIHdhbnQgdG8gc3VwcG9ydCB0aGlzIGFzIHdlbGxcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiBldmVudC5idXR0b25zID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUb3VjaCBzY3JlZW4sIHNvbWV0aW1lcyBvbiBzb21lIHNwZWNpZmljIGRldmljZSwgYGJ1dHRvbnNgXG4gICAgLy8gZG9lc24ndCBoYXZlIGFueXRoaW5nIChzYWZhcmkgb24gaW9zLCBibGFja2JlcnJ5Li4uKVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmJ1dHRvbnMgIT09IDEpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSByZWFzb24gd2UgaGF2ZSB0aG9zZSBpZiBlbHNlIGJsb2NrIGFib3ZlXG4gICAgLy8gaWYgYW55IHNwZWNpYWwgY2FzZSB3ZSBjYW4gY2F0Y2ggYW5kIGxldCBpdCBzbGlkZVxuICAgIC8vIHdlIGRvIGl0IGFib3ZlLCB3aGVuIGdldCB0byBoZXJlLCB0aGlzIGRlZmluaXRlbHlcbiAgICAvLyBpcy1ub3QtbGVmdC1jbGlja1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRmluZHMgYSBzaW5nbGUgRE9NIGVsZW1lbnQgbWF0Y2hpbmcgYHNlbGVjdG9yYCB3aXRoaW4gdGhlIG9wdGlvbmFsXG4gKiBgY29udGV4dGAgb2YgYW5vdGhlciBET00gZWxlbWVudCAoZGVmYXVsdGluZyB0byBgZG9jdW1lbnRgKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IFtjb250ZXh0PWRvY3VtZW50XVxuICogICAgICAgIEEgRE9NIGVsZW1lbnQgd2l0aGluIHdoaWNoIHRvIHF1ZXJ5LiBDYW4gYWxzbyBiZSBhIHNlbGVjdG9yXG4gKiAgICAgICAgc3RyaW5nIGluIHdoaWNoIGNhc2UgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgd2lsbCBiZSB1c2VkXG4gKiAgICAgICAgYXMgY29udGV4dC4gSWYgbWlzc2luZyAob3Igbm8gZWxlbWVudCBtYXRjaGVzIHNlbGVjdG9yKSwgZmFsbHNcbiAqICAgICAgICBiYWNrIHRvIGBkb2N1bWVudGAuXG4gKlxuICogQHJldHVybiB7RWxlbWVudHxudWxsfVxuICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBmb3VuZCBvciBudWxsLlxuICovXG52YXIgJCA9IGNyZWF0ZVF1ZXJpZXIoJ3F1ZXJ5U2VsZWN0b3InKTtcblxuLyoqXG4gKiBGaW5kcyBhIGFsbCBET00gZWxlbWVudHMgbWF0Y2hpbmcgYHNlbGVjdG9yYCB3aXRoaW4gdGhlIG9wdGlvbmFsXG4gKiBgY29udGV4dGAgb2YgYW5vdGhlciBET00gZWxlbWVudCAoZGVmYXVsdGluZyB0byBgZG9jdW1lbnRgKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqICAgICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JBbGxgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IFtjb250ZXh0PWRvY3VtZW50XVxuICogICAgICAgICAgIEEgRE9NIGVsZW1lbnQgd2l0aGluIHdoaWNoIHRvIHF1ZXJ5LiBDYW4gYWxzbyBiZSBhIHNlbGVjdG9yXG4gKiAgICAgICAgICAgc3RyaW5nIGluIHdoaWNoIGNhc2UgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgd2lsbCBiZSB1c2VkXG4gKiAgICAgICAgICAgYXMgY29udGV4dC4gSWYgbWlzc2luZyAob3Igbm8gZWxlbWVudCBtYXRjaGVzIHNlbGVjdG9yKSwgZmFsbHNcbiAqICAgICAgICAgICBiYWNrIHRvIGBkb2N1bWVudGAuXG4gKlxuICogQHJldHVybiB7Tm9kZUxpc3R9XG4gKiAgICAgICAgIEEgZWxlbWVudCBsaXN0IG9mIGVsZW1lbnRzIHRoYXQgd2VyZSBmb3VuZC4gV2lsbCBiZSBlbXB0eSBpZiBub25lIHdlcmUgZm91bmQuXG4gKlxuICovXG52YXIgJCQgPSBjcmVhdGVRdWVyaWVyKCdxdWVyeVNlbGVjdG9yQWxsJyk7XG5cbnZhciBEb20gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIGlzUmVhbDogaXNSZWFsLFxuICBpc0VsOiBpc0VsLFxuICBpc0luRnJhbWU6IGlzSW5GcmFtZSxcbiAgY3JlYXRlRWw6IGNyZWF0ZUVsLFxuICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnQsXG4gIHByZXBlbmRUbzogcHJlcGVuZFRvLFxuICBoYXNDbGFzczogaGFzQ2xhc3MsXG4gIGFkZENsYXNzOiBhZGRDbGFzcyxcbiAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuICB0b2dnbGVDbGFzczogdG9nZ2xlQ2xhc3MsXG4gIHNldEF0dHJpYnV0ZXM6IHNldEF0dHJpYnV0ZXMsXG4gIGdldEF0dHJpYnV0ZXM6IGdldEF0dHJpYnV0ZXMsXG4gIGdldEF0dHJpYnV0ZTogZ2V0QXR0cmlidXRlLFxuICBzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZSxcbiAgcmVtb3ZlQXR0cmlidXRlOiByZW1vdmVBdHRyaWJ1dGUsXG4gIGJsb2NrVGV4dFNlbGVjdGlvbjogYmxvY2tUZXh0U2VsZWN0aW9uLFxuICB1bmJsb2NrVGV4dFNlbGVjdGlvbjogdW5ibG9ja1RleHRTZWxlY3Rpb24sXG4gIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogZ2V0Qm91bmRpbmdDbGllbnRSZWN0LFxuICBmaW5kUG9zaXRpb246IGZpbmRQb3NpdGlvbixcbiAgZ2V0UG9pbnRlclBvc2l0aW9uOiBnZXRQb2ludGVyUG9zaXRpb24sXG4gIGlzVGV4dE5vZGU6IGlzVGV4dE5vZGUsXG4gIGVtcHR5RWw6IGVtcHR5RWwsXG4gIG5vcm1hbGl6ZUNvbnRlbnQ6IG5vcm1hbGl6ZUNvbnRlbnQsXG4gIGFwcGVuZENvbnRlbnQ6IGFwcGVuZENvbnRlbnQsXG4gIGluc2VydENvbnRlbnQ6IGluc2VydENvbnRlbnQsXG4gIGlzU2luZ2xlTGVmdENsaWNrOiBpc1NpbmdsZUxlZnRDbGljayxcbiAgJDogJCxcbiAgJCQ6ICQkXG59KTtcblxuLyoqXG4gKiBAZmlsZSBndWlkLmpzXG4gKiBAbW9kdWxlIGd1aWRcbiAqL1xuXG4vKipcbiAqIFVuaXF1ZSBJRCBmb3IgYW4gZWxlbWVudCBvciBmdW5jdGlvblxuICogQHR5cGUge051bWJlcn1cbiAqL1xudmFyIF9ndWlkID0gMTtcblxuLyoqXG4gKiBHZXQgYSB1bmlxdWUgYXV0by1pbmNyZW1lbnRpbmcgSUQgYnkgbnVtYmVyIHRoYXQgaGFzIG5vdCBiZWVuIHJldHVybmVkIGJlZm9yZS5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIEEgbmV3IHVuaXF1ZSBJRC5cbiAqL1xuZnVuY3Rpb24gbmV3R1VJRCgpIHtcbiAgcmV0dXJuIF9ndWlkKys7XG59XG5cbi8qKlxuICogQGZpbGUgZG9tLWRhdGEuanNcbiAqIEBtb2R1bGUgZG9tLWRhdGFcbiAqL1xuXG4vKipcbiAqIEVsZW1lbnQgRGF0YSBTdG9yZS5cbiAqXG4gKiBBbGxvd3MgZm9yIGJpbmRpbmcgZGF0YSB0byBhbiBlbGVtZW50IHdpdGhvdXQgcHV0dGluZyBpdCBkaXJlY3RseSBvbiB0aGVcbiAqIGVsZW1lbnQuIEV4LiBFdmVudCBsaXN0ZW5lcnMgYXJlIHN0b3JlZCBoZXJlLlxuICogKGFsc28gZnJvbSBqc25pbmphLmNvbSwgc2xpZ2h0bHkgbW9kaWZpZWQgYW5kIHVwZGF0ZWQgZm9yIGNsb3N1cmUgY29tcGlsZXIpXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBlbERhdGEgPSB7fTtcblxuLypcbiAqIFVuaXF1ZSBhdHRyaWJ1dGUgbmFtZSB0byBzdG9yZSBhbiBlbGVtZW50J3MgZ3VpZCBpblxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAY29uc3RhbnRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBlbElkQXR0ciA9ICd2ZGF0YScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3Qgd2hlcmUgZGF0YSBmb3IgYW4gZWxlbWVudCBpcyBzdG9yZWRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCB0byBzdG9yZSBkYXRhIGZvci5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIFRoZSBjYWNoZSBvYmplY3QgZm9yIHRoYXQgZWwgdGhhdCB3YXMgcGFzc2VkIGluLlxuICovXG5mdW5jdGlvbiBnZXREYXRhKGVsKSB7XG4gIHZhciBpZCA9IGVsW2VsSWRBdHRyXTtcblxuICBpZiAoIWlkKSB7XG4gICAgaWQgPSBlbFtlbElkQXR0cl0gPSBuZXdHVUlEKCk7XG4gIH1cblxuICBpZiAoIWVsRGF0YVtpZF0pIHtcbiAgICBlbERhdGFbaWRdID0ge307XG4gIH1cblxuICByZXR1cm4gZWxEYXRhW2lkXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGVsZW1lbnQgaGFzIGNhY2hlZCBkYXRhXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIENoZWNrIGlmIHRoaXMgZWxlbWVudCBoYXMgY2FjaGVkIGRhdGEuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBET00gZWxlbWVudCBoYXMgY2FjaGVkIGRhdGEuXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBoYXNEYXRhKGVsKSB7XG4gIHZhciBpZCA9IGVsW2VsSWRBdHRyXTtcblxuICBpZiAoIWlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZWxEYXRhW2lkXSkubGVuZ3RoO1xufVxuXG4vKipcbiAqIERlbGV0ZSBkYXRhIGZvciB0aGUgZWxlbWVudCBmcm9tIHRoZSBjYWNoZSBhbmQgdGhlIGd1aWQgYXR0ciBmcm9tIGdldEVsZW1lbnRCeUlkXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFJlbW92ZSBjYWNoZWQgZGF0YSBmb3IgdGhpcyBlbGVtZW50LlxuICovXG5mdW5jdGlvbiByZW1vdmVEYXRhKGVsKSB7XG4gIHZhciBpZCA9IGVsW2VsSWRBdHRyXTtcblxuICBpZiAoIWlkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCBzdG9yZWQgZGF0YVxuICBkZWxldGUgZWxEYXRhW2lkXTtcblxuICAvLyBSZW1vdmUgdGhlIGVsSWRBdHRyIHByb3BlcnR5IGZyb20gdGhlIERPTSBub2RlXG4gIHRyeSB7XG4gICAgZGVsZXRlIGVsW2VsSWRBdHRyXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlbC5yZW1vdmVBdHRyaWJ1dGUpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShlbElkQXR0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElFIGRvZXNuJ3QgYXBwZWFyIHRvIHN1cHBvcnQgcmVtb3ZlQXR0cmlidXRlIG9uIHRoZSBkb2N1bWVudCBlbGVtZW50XG4gICAgICBlbFtlbElkQXR0cl0gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBmaWxlIGV2ZW50cy5qcy4gQW4gRXZlbnQgU3lzdGVtIChKb2huIFJlc2lnIC0gU2VjcmV0cyBvZiBhIEpTIE5pbmphIGh0dHA6Ly9qc25pbmphLmNvbS8pXG4gKiAoT3JpZ2luYWwgYm9vayB2ZXJzaW9uIHdhc24ndCBjb21wbGV0ZWx5IHVzYWJsZSwgc28gZml4ZWQgc29tZSB0aGluZ3MgYW5kIG1hZGUgQ2xvc3VyZSBDb21waWxlciBjb21wYXRpYmxlKVxuICogVGhpcyBzaG91bGQgd29yayB2ZXJ5IHNpbWlsYXJseSB0byBqUXVlcnkncyBldmVudHMsIGhvd2V2ZXIgaXQncyBiYXNlZCBvZmYgdGhlIGJvb2sgdmVyc2lvbiB3aGljaCBpc24ndCBhc1xuICogcm9idXN0IGFzIGpxdWVyeSdzLCBzbyB0aGVyZSdzIHByb2JhYmx5IHNvbWUgZGlmZmVyZW5jZXMuXG4gKlxuICogQG1vZHVsZSBldmVudHNcbiAqL1xuXG4vKipcbiAqIENsZWFuIHVwIHRoZSBsaXN0ZW5lciBjYWNoZSBhbmQgZGlzcGF0Y2hlcnNcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXG4gKiAgICAgICAgRWxlbWVudCB0byBjbGVhbiB1cFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgVHlwZSBvZiBldmVudCB0byBjbGVhbiB1cFxuICovXG5mdW5jdGlvbiBfY2xlYW5VcEV2ZW50cyhlbGVtLCB0eXBlKSB7XG4gIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtKTtcblxuICAvLyBSZW1vdmUgdGhlIGV2ZW50cyBvZiBhIHBhcnRpY3VsYXIgdHlwZSBpZiB0aGVyZSBhcmUgbm9uZSBsZWZ0XG4gIGlmIChkYXRhLmhhbmRsZXJzW3R5cGVdLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSBkYXRhLmhhbmRsZXJzW3R5cGVdO1xuICAgIC8vIGRhdGEuaGFuZGxlcnNbdHlwZV0gPSBudWxsO1xuICAgIC8vIFNldHRpbmcgdG8gbnVsbCB3YXMgY2F1c2luZyBhbiBlcnJvciB3aXRoIGRhdGEuaGFuZGxlcnNcblxuICAgIC8vIFJlbW92ZSB0aGUgbWV0YS1oYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICBpZiAoZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZGF0YS5kaXNwYXRjaGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBkYXRhLmRpc3BhdGNoZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSB0aGUgZXZlbnRzIG9iamVjdCBpZiB0aGVyZSBhcmUgbm8gdHlwZXMgbGVmdFxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGF0YS5oYW5kbGVycykubGVuZ3RoIDw9IDApIHtcbiAgICBkZWxldGUgZGF0YS5oYW5kbGVycztcbiAgICBkZWxldGUgZGF0YS5kaXNwYXRjaGVyO1xuICAgIGRlbGV0ZSBkYXRhLmRpc2FibGVkO1xuICB9XG5cbiAgLy8gRmluYWxseSByZW1vdmUgdGhlIGVsZW1lbnQgZGF0YSBpZiB0aGVyZSBpcyBubyBkYXRhIGxlZnRcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJlbW92ZURhdGEoZWxlbSk7XG4gIH1cbn1cblxuLyoqXG4gKiBMb29wcyB0aHJvdWdoIGFuIGFycmF5IG9mIGV2ZW50IHR5cGVzIGFuZCBjYWxscyB0aGUgcmVxdWVzdGVkIG1ldGhvZCBmb3IgZWFjaCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiAgICAgICAgVGhlIGV2ZW50IG1ldGhvZCB3ZSB3YW50IHRvIHVzZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXG4gKiAgICAgICAgRWxlbWVudCBvciBvYmplY3QgdG8gYmluZCBsaXN0ZW5lcnMgdG9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFR5cGUgb2YgZXZlbnQgdG8gYmluZCB0by5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGNhbGxiYWNrXG4gKiAgICAgICAgRXZlbnQgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhmbiwgZWxlbSwgdHlwZXMsIGNhbGxiYWNrKSB7XG4gIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAvLyBDYWxsIHRoZSBldmVudCBtZXRob2QgZm9yIGVhY2ggb25lIG9mIHRoZSB0eXBlc1xuICAgIGZuKGVsZW0sIHR5cGUsIGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbi8qKlxuICogRml4IGEgbmF0aXZlIGV2ZW50IHRvIGhhdmUgc3RhbmRhcmQgcHJvcGVydHkgdmFsdWVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gKiAgICAgICAgRXZlbnQgb2JqZWN0IHRvIGZpeC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIEZpeGVkIGV2ZW50IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZml4RXZlbnQoZXZlbnQpIHtcblxuICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBpZiBmaXhpbmcgdXAgaXMgbmVlZGVkXG4gIC8vIFVzZWQgdG8gY2hlY2sgaWYgIWV2ZW50LnN0b3BQcm9wYWdhdGlvbiBpbnN0ZWFkIG9mIGlzUHJvcGFnYXRpb25TdG9wcGVkXG4gIC8vIEJ1dCBuYXRpdmUgZXZlbnRzIHJldHVybiB0cnVlIGZvciBzdG9wUHJvcGFnYXRpb24sIGJ1dCBkb24ndCBoYXZlXG4gIC8vIG90aGVyIGV4cGVjdGVkIG1ldGhvZHMgbGlrZSBpc1Byb3BhZ2F0aW9uU3RvcHBlZC4gU2VlbXMgdG8gYmUgYSBwcm9ibGVtXG4gIC8vIHdpdGggdGhlIEphdmFzY3JpcHQgTmluamEgY29kZS4gU28gd2UncmUganVzdCBvdmVycmlkaW5nIGFsbCBldmVudHMgbm93LlxuICBpZiAoIWV2ZW50IHx8ICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgIHZhciBvbGQgPSBldmVudCB8fCB3aW5kb3ckMS5ldmVudDtcblxuICAgIGV2ZW50ID0ge307XG4gICAgLy8gQ2xvbmUgdGhlIG9sZCBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gbW9kaWZ5IHRoZSB2YWx1ZXMgZXZlbnQgPSB7fTtcbiAgICAvLyBJRTggRG9lc24ndCBsaWtlIHdoZW4geW91IG1lc3Mgd2l0aCBuYXRpdmUgZXZlbnQgcHJvcGVydGllc1xuICAgIC8vIEZpcmVmb3ggcmV0dXJucyBmYWxzZSBmb3IgZXZlbnQuaGFzT3duUHJvcGVydHkoJ3R5cGUnKSBhbmQgb3RoZXIgcHJvcHNcbiAgICAvLyAgd2hpY2ggbWFrZXMgY29weWluZyBtb3JlIGRpZmZpY3VsdC5cbiAgICAvLyBUT0RPOiBQcm9iYWJseSBiZXN0IHRvIGNyZWF0ZSBhIHdoaXRlbGlzdCBvZiBldmVudCBwcm9wc1xuICAgIGZvciAodmFyIGtleSBpbiBvbGQpIHtcbiAgICAgIC8vIFNhZmFyaSA2LjAuMyB3YXJucyB5b3UgaWYgeW91IHRyeSB0byBjb3B5IGRlcHJlY2F0ZWQgbGF5ZXJYL1lcbiAgICAgIC8vIENocm9tZSB3YXJucyB5b3UgaWYgeW91IHRyeSB0byBjb3B5IGRlcHJlY2F0ZWQga2V5Ym9hcmRFdmVudC5rZXlMb2NhdGlvblxuICAgICAgLy8gYW5kIHdlYmtpdE1vdmVtZW50WC9ZXG4gICAgICBpZiAoa2V5ICE9PSAnbGF5ZXJYJyAmJiBrZXkgIT09ICdsYXllclknICYmIGtleSAhPT0gJ2tleUxvY2F0aW9uJyAmJiBrZXkgIT09ICd3ZWJraXRNb3ZlbWVudFgnICYmIGtleSAhPT0gJ3dlYmtpdE1vdmVtZW50WScpIHtcbiAgICAgICAgLy8gQ2hyb21lIDMyKyB3YXJucyBpZiB5b3UgdHJ5IHRvIGNvcHkgZGVwcmVjYXRlZCByZXR1cm5WYWx1ZSwgYnV0XG4gICAgICAgIC8vIHdlIHN0aWxsIHdhbnQgdG8gaWYgcHJldmVudERlZmF1bHQgaXNuJ3Qgc3VwcG9ydGVkIChJRTgpLlxuICAgICAgICBpZiAoIShrZXkgPT09ICdyZXR1cm5WYWx1ZScgJiYgb2xkLnByZXZlbnREZWZhdWx0KSkge1xuICAgICAgICAgIGV2ZW50W2tleV0gPSBvbGRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBldmVudCBvY2N1cnJlZCBvbiB0aGlzIGVsZW1lbnRcbiAgICBpZiAoIWV2ZW50LnRhcmdldCkge1xuICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgd2hpY2ggb3RoZXIgZWxlbWVudCB0aGUgZXZlbnQgaXMgcmVsYXRlZCB0b1xuICAgIGlmICghZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgZXZlbnQucmVsYXRlZFRhcmdldCA9IGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC50YXJnZXQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTdG9wIHRoZSBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIG9sZC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIG9sZC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIC8vIFN0b3AgdGhlIGV2ZW50IGZyb20gYnViYmxpbmdcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICBvbGQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgb2xkLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgfTtcblxuICAgIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuRmFsc2U7XG5cbiAgICAvLyBTdG9wIHRoZSBldmVudCBmcm9tIGJ1YmJsaW5nIGFuZCBleGVjdXRpbmcgb3RoZXIgaGFuZGxlcnNcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuICAgICAgICBvbGQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuXG4gICAgZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5GYWxzZTtcblxuICAgIC8vIEhhbmRsZSBtb3VzZSBwb3NpdGlvblxuICAgIGlmIChldmVudC5jbGllbnRYICE9PSBudWxsICYmIGV2ZW50LmNsaWVudFggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcblxuICAgICAgZXZlbnQucGFnZVggPSBldmVudC5jbGllbnRYICsgKGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICBldmVudC5wYWdlWSA9IGV2ZW50LmNsaWVudFkgKyAoZG9jICYmIGRvYy5zY3JvbGxUb3AgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wIHx8IDApO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBrZXkgcHJlc3Nlc1xuICAgIGV2ZW50LndoaWNoID0gZXZlbnQuY2hhckNvZGUgfHwgZXZlbnQua2V5Q29kZTtcblxuICAgIC8vIEZpeCBidXR0b24gZm9yIG1vdXNlIGNsaWNrczpcbiAgICAvLyAwID09IGxlZnQ7IDEgPT0gbWlkZGxlOyAyID09IHJpZ2h0XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gbnVsbCAmJiBldmVudC5idXR0b24gIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGRpc2FibGVkIGJlY2F1c2UgaXQgZG9lcyBub3QgcGFzcyB2aWRlb2pzLXN0YW5kYXJkXG4gICAgICAvLyBhbmQuLi4geWlrZXMuXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgZXZlbnQuYnV0dG9uID0gZXZlbnQuYnV0dG9uICYgMSA/IDAgOiBldmVudC5idXR0b24gJiA0ID8gMSA6IGV2ZW50LmJ1dHRvbiAmIDIgPyAyIDogMDtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGZpeGVkLXVwIGluc3RhbmNlXG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzIGFyZSBzdXBwb3J0ZWRcbiAqL1xudmFyIF9zdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgX3N1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB3aW5kb3ckMS5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gICAgd2luZG93JDEucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZGlzcmVnYXJkXG4gIH1cbn0pKCk7XG5cbi8qKlxuICogVG91Y2ggZXZlbnRzIENocm9tZSBleHBlY3RzIHRvIGJlIHBhc3NpdmVcbiAqL1xudmFyIHBhc3NpdmVFdmVudHMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJ107XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGVsZW1lbnRcbiAqIEl0IHN0b3JlcyB0aGUgaGFuZGxlciBmdW5jdGlvbiBpbiBhIHNlcGFyYXRlIGNhY2hlIG9iamVjdFxuICogYW5kIGFkZHMgYSBnZW5lcmljIGhhbmRsZXIgdG8gdGhlIGVsZW1lbnQncyBldmVudCxcbiAqIGFsb25nIHdpdGggYSB1bmlxdWUgaWQgKGd1aWQpIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IG9yIG9iamVjdCB0byBiaW5kIGxpc3RlbmVycyB0b1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXG4gKiAgICAgICAgVHlwZSBvZiBldmVudCB0byBiaW5kIHRvLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm5cbiAqICAgICAgICBFdmVudCBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gb24oZWxlbSwgdHlwZSwgZm4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICByZXR1cm4gX2hhbmRsZU11bHRpcGxlRXZlbnRzKG9uLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cblxuICB2YXIgZGF0YSA9IGdldERhdGEoZWxlbSk7XG5cbiAgLy8gV2UgbmVlZCBhIHBsYWNlIHRvIHN0b3JlIGFsbCBvdXIgaGFuZGxlciBkYXRhXG4gIGlmICghZGF0YS5oYW5kbGVycykge1xuICAgIGRhdGEuaGFuZGxlcnMgPSB7fTtcbiAgfVxuXG4gIGlmICghZGF0YS5oYW5kbGVyc1t0eXBlXSkge1xuICAgIGRhdGEuaGFuZGxlcnNbdHlwZV0gPSBbXTtcbiAgfVxuXG4gIGlmICghZm4uZ3VpZCkge1xuICAgIGZuLmd1aWQgPSBuZXdHVUlEKCk7XG4gIH1cblxuICBkYXRhLmhhbmRsZXJzW3R5cGVdLnB1c2goZm4pO1xuXG4gIGlmICghZGF0YS5kaXNwYXRjaGVyKSB7XG4gICAgZGF0YS5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgZGF0YS5kaXNwYXRjaGVyID0gZnVuY3Rpb24gKGV2ZW50LCBoYXNoKSB7XG5cbiAgICAgIGlmIChkYXRhLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQgPSBmaXhFdmVudChldmVudCk7XG5cbiAgICAgIHZhciBoYW5kbGVycyA9IGRhdGEuaGFuZGxlcnNbZXZlbnQudHlwZV07XG5cbiAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAvLyBDb3B5IGhhbmRsZXJzIHNvIGlmIGhhbmRsZXJzIGFyZSBhZGRlZC9yZW1vdmVkIGR1cmluZyB0aGUgcHJvY2VzcyBpdCBkb2Vzbid0IHRocm93IGV2ZXJ5dGhpbmcgb2ZmLlxuICAgICAgICB2YXIgaGFuZGxlcnNDb3B5ID0gaGFuZGxlcnMuc2xpY2UoMCk7XG5cbiAgICAgICAgZm9yICh2YXIgbSA9IDAsIG4gPSBoYW5kbGVyc0NvcHkubGVuZ3RoOyBtIDwgbjsgbSsrKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBoYW5kbGVyc0NvcHlbbV0uY2FsbChlbGVtLCBldmVudCwgaGFzaCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGxvZyQxLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAoZGF0YS5oYW5kbGVyc1t0eXBlXS5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhbHNlO1xuXG4gICAgICBpZiAoX3N1cHBvcnRzUGFzc2l2ZSAmJiBwYXNzaXZlRXZlbnRzLmluZGV4T2YodHlwZSkgPiAtMSkge1xuICAgICAgICBvcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gICAgICB9XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZGF0YS5kaXNwYXRjaGVyLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW0uYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGRhdGEuZGlzcGF0Y2hlcik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgZnJvbSBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxuICogICAgICAgIE9iamVjdCB0byByZW1vdmUgbGlzdGVuZXJzIGZyb20uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt0eXBlXVxuICogICAgICAgIFR5cGUgb2YgbGlzdGVuZXIgdG8gcmVtb3ZlLiBEb24ndCBpbmNsdWRlIHRvIHJlbW92ZSBhbGwgZXZlbnRzIGZyb20gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IFtmbl1cbiAqICAgICAgICBTcGVjaWZpYyBsaXN0ZW5lciB0byByZW1vdmUuIERvbid0IGluY2x1ZGUgdG8gcmVtb3ZlIGxpc3RlbmVycyBmb3IgYW4gZXZlbnRcbiAqICAgICAgICB0eXBlLlxuICovXG5mdW5jdGlvbiBvZmYoZWxlbSwgdHlwZSwgZm4pIHtcbiAgLy8gRG9uJ3Qgd2FudCB0byBhZGQgYSBjYWNoZSBvYmplY3QgdGhyb3VnaCBnZXRFbERhdGEgaWYgbm90IG5lZWRlZFxuICBpZiAoIWhhc0RhdGEoZWxlbSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IGdldERhdGEoZWxlbSk7XG5cbiAgLy8gSWYgbm8gZXZlbnRzIGV4aXN0LCBub3RoaW5nIHRvIHVuYmluZFxuICBpZiAoIWRhdGEuaGFuZGxlcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob2ZmLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cblxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uXG4gIHZhciByZW1vdmVUeXBlID0gZnVuY3Rpb24gcmVtb3ZlVHlwZShlbCwgdCkge1xuICAgIGRhdGEuaGFuZGxlcnNbdF0gPSBbXTtcbiAgICBfY2xlYW5VcEV2ZW50cyhlbCwgdCk7XG4gIH07XG5cbiAgLy8gQXJlIHdlIHJlbW92aW5nIGFsbCBib3VuZCBldmVudHM/XG4gIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciB0IGluIGRhdGEuaGFuZGxlcnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YS5oYW5kbGVycyB8fCB7fSwgdCkpIHtcbiAgICAgICAgcmVtb3ZlVHlwZShlbGVtLCB0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZGF0YS5oYW5kbGVyc1t0eXBlXTtcblxuICAvLyBJZiBubyBoYW5kbGVycyBleGlzdCwgbm90aGluZyB0byB1bmJpbmRcbiAgaWYgKCFoYW5kbGVycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIG5vIGxpc3RlbmVyIHdhcyBwcm92aWRlZCwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHR5cGVcbiAgaWYgKCFmbikge1xuICAgIHJlbW92ZVR5cGUoZWxlbSwgdHlwZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV2UncmUgb25seSByZW1vdmluZyBhIHNpbmdsZSBoYW5kbGVyXG4gIGlmIChmbi5ndWlkKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBoYW5kbGVycy5sZW5ndGg7IG4rKykge1xuICAgICAgaWYgKGhhbmRsZXJzW25dLmd1aWQgPT09IGZuLmd1aWQpIHtcbiAgICAgICAgaGFuZGxlcnMuc3BsaWNlKG4tLSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NsZWFuVXBFdmVudHMoZWxlbSwgdHlwZSk7XG59XG5cbi8qKlxuICogVHJpZ2dlciBhbiBldmVudCBmb3IgYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgb25cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fHN0cmluZ30gZXZlbnRcbiAqICAgICAgICBBIHN0cmluZyAodGhlIHR5cGUpIG9yIGFuIGV2ZW50IG9iamVjdCB3aXRoIGEgdHlwZSBhdHRyaWJ1dGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2hhc2hdXG4gKiAgICAgICAgZGF0YSBoYXNoIHRvIHBhc3MgYWxvbmcgd2l0aCB0aGUgZXZlbnRcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAqICAgICAgICAgLSBSZXR1cm5zIHRoZSBvcHBvc2l0ZSBvZiBgZGVmYXVsdFByZXZlbnRlZGAgaWYgZGVmYXVsdCB3YXMgcHJldmVudGVkXG4gKiAgICAgICAgIC0gT3RoZXJ3aXNlIHJldHVybnMgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXIoZWxlbSwgZXZlbnQsIGhhc2gpIHtcbiAgLy8gRmV0Y2hlcyBlbGVtZW50IGRhdGEgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgKGZvciBidWJibGluZykuXG4gIC8vIERvbid0IHdhbnQgdG8gYWRkIGEgZGF0YSBvYmplY3QgdG8gY2FjaGUgZm9yIGV2ZXJ5IHBhcmVudCxcbiAgLy8gc28gY2hlY2tpbmcgaGFzRWxEYXRhIGZpcnN0LlxuICB2YXIgZWxlbURhdGEgPSBoYXNEYXRhKGVsZW0pID8gZ2V0RGF0YShlbGVtKSA6IHt9O1xuICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlIHx8IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgLy8gdHlwZSA9IGV2ZW50LnR5cGUgfHwgZXZlbnQsXG4gIC8vIGhhbmRsZXI7XG5cbiAgLy8gSWYgYW4gZXZlbnQgbmFtZSB3YXMgcGFzc2VkIGFzIGEgc3RyaW5nLCBjcmVhdGVzIGFuIGV2ZW50IG91dCBvZiBpdFxuICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgIGV2ZW50ID0geyB0eXBlOiBldmVudCwgdGFyZ2V0OiBlbGVtIH07XG4gIH0gZWxzZSBpZiAoIWV2ZW50LnRhcmdldCkge1xuICAgIGV2ZW50LnRhcmdldCA9IGVsZW07XG4gIH1cblxuICAvLyBOb3JtYWxpemVzIHRoZSBldmVudCBwcm9wZXJ0aWVzLlxuICBldmVudCA9IGZpeEV2ZW50KGV2ZW50KTtcblxuICAvLyBJZiB0aGUgcGFzc2VkIGVsZW1lbnQgaGFzIGEgZGlzcGF0Y2hlciwgZXhlY3V0ZXMgdGhlIGVzdGFibGlzaGVkIGhhbmRsZXJzLlxuICBpZiAoZWxlbURhdGEuZGlzcGF0Y2hlcikge1xuICAgIGVsZW1EYXRhLmRpc3BhdGNoZXIuY2FsbChlbGVtLCBldmVudCwgaGFzaCk7XG4gIH1cblxuICAvLyBVbmxlc3MgZXhwbGljaXRseSBzdG9wcGVkIG9yIHRoZSBldmVudCBkb2VzIG5vdCBidWJibGUgKGUuZy4gbWVkaWEgZXZlbnRzKVxuICAvLyByZWN1cnNpdmVseSBjYWxscyB0aGlzIGZ1bmN0aW9uIHRvIGJ1YmJsZSB0aGUgZXZlbnQgdXAgdGhlIERPTS5cbiAgaWYgKHBhcmVudCAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSAmJiBldmVudC5idWJibGVzID09PSB0cnVlKSB7XG4gICAgdHJpZ2dlci5jYWxsKG51bGwsIHBhcmVudCwgZXZlbnQsIGhhc2gpO1xuXG4gICAgLy8gSWYgYXQgdGhlIHRvcCBvZiB0aGUgRE9NLCB0cmlnZ2VycyB0aGUgZGVmYXVsdCBhY3Rpb24gdW5sZXNzIGRpc2FibGVkLlxuICB9IGVsc2UgaWYgKCFwYXJlbnQgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IGdldERhdGEoZXZlbnQudGFyZ2V0KTtcblxuICAgIC8vIENoZWNrcyBpZiB0aGUgdGFyZ2V0IGhhcyBhIGRlZmF1bHQgYWN0aW9uIGZvciB0aGlzIGV2ZW50LlxuICAgIGlmIChldmVudC50YXJnZXRbZXZlbnQudHlwZV0pIHtcbiAgICAgIC8vIFRlbXBvcmFyaWx5IGRpc2FibGVzIGV2ZW50IGRpc3BhdGNoaW5nIG9uIHRoZSB0YXJnZXQgYXMgd2UgaGF2ZSBhbHJlYWR5IGV4ZWN1dGVkIHRoZSBoYW5kbGVyLlxuICAgICAgdGFyZ2V0RGF0YS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAvLyBFeGVjdXRlcyB0aGUgZGVmYXVsdCBhY3Rpb24uXG4gICAgICBpZiAodHlwZW9mIGV2ZW50LnRhcmdldFtldmVudC50eXBlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudC50YXJnZXRbZXZlbnQudHlwZV0oKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlLWVuYWJsZXMgZXZlbnQgZGlzcGF0Y2hpbmcuXG4gICAgICB0YXJnZXREYXRhLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5mb3JtIHRoZSB0cmlnZ2VyZXIgaWYgdGhlIGRlZmF1bHQgd2FzIHByZXZlbnRlZCBieSByZXR1cm5pbmcgZmFsc2VcbiAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xufVxuXG4vKipcbiAqIFRyaWdnZXIgYSBsaXN0ZW5lciBvbmx5IG9uY2UgZm9yIGFuIGV2ZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxuICogICAgICAgIEVsZW1lbnQgb3Igb2JqZWN0IHRvIGJpbmQgdG8uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHR5cGVcbiAqICAgICAgICBOYW1lL3R5cGUgb2YgZXZlbnRcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fkV2ZW50TGlzdGVuZXJ9IGZuXG4gKiAgICAgICAgRXZlbnQgTGlzdGVuZXIgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gb25lKGVsZW0sIHR5cGUsIGZuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgcmV0dXJuIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhvbmUsIGVsZW0sIHR5cGUsIGZuKTtcbiAgfVxuICB2YXIgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMoKSB7XG4gICAgb2ZmKGVsZW0sIHR5cGUsIGZ1bmMpO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gY29weSB0aGUgZ3VpZCB0byB0aGUgbmV3IGZ1bmN0aW9uIHNvIGl0IGNhbiByZW1vdmVkIHVzaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbidzIElEXG4gIGZ1bmMuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IG5ld0dVSUQoKTtcbiAgb24oZWxlbSwgdHlwZSwgZnVuYyk7XG59XG5cbnZhciBFdmVudHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIGZpeEV2ZW50OiBmaXhFdmVudCxcbiAgb246IG9uLFxuICBvZmY6IG9mZixcbiAgdHJpZ2dlcjogdHJpZ2dlcixcbiAgb25lOiBvbmVcbn0pO1xuXG4vKipcbiAqIEBmaWxlIHNldHVwLmpzIC0gRnVuY3Rpb25zIGZvciBzZXR0aW5nIHVwIGEgcGxheWVyIHdpdGhvdXRcbiAqIHVzZXIgaW50ZXJhY3Rpb24gYmFzZWQgb24gdGhlIGRhdGEtc2V0dXAgYGF0dHJpYnV0ZWAgb2YgdGhlIHZpZGVvIHRhZy5cbiAqXG4gKiBAbW9kdWxlIHNldHVwXG4gKi9cblxudmFyIF93aW5kb3dMb2FkZWQgPSBmYWxzZTtcbnZhciB2aWRlb2pzID0gdm9pZCAwO1xuXG4vKipcbiAqIFNldCB1cCBhbnkgdGFncyB0aGF0IGhhdmUgYSBkYXRhLXNldHVwIGBhdHRyaWJ1dGVgIHdoZW4gdGhlIHBsYXllciBpcyBzdGFydGVkLlxuICovXG52YXIgYXV0b1NldHVwID0gZnVuY3Rpb24gYXV0b1NldHVwKCkge1xuXG4gIC8vIFByb3RlY3QgYWdhaW5zdCBicmVha2FnZSBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgYW5kIGNoZWNrIGdsb2JhbCBhdXRvU2V0dXAgb3B0aW9uLlxuICBpZiAoIWlzUmVhbCgpIHx8IHZpZGVvanMub3B0aW9ucy5hdXRvU2V0dXAgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHZpZHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKSk7XG4gIHZhciBhdWRpb3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYXVkaW8nKSk7XG4gIHZhciBkaXZzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvLWpzJykpO1xuICB2YXIgbWVkaWFFbHMgPSB2aWRzLmNvbmNhdChhdWRpb3MsIGRpdnMpO1xuXG4gIC8vIENoZWNrIGlmIGFueSBtZWRpYSBlbGVtZW50cyBleGlzdFxuICBpZiAobWVkaWFFbHMgJiYgbWVkaWFFbHMubGVuZ3RoID4gMCkge1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGUgPSBtZWRpYUVscy5sZW5ndGg7IGkgPCBlOyBpKyspIHtcbiAgICAgIHZhciBtZWRpYUVsID0gbWVkaWFFbHNbaV07XG5cbiAgICAgIC8vIENoZWNrIGlmIGVsZW1lbnQgZXhpc3RzLCBoYXMgZ2V0QXR0cmlidXRlIGZ1bmMuXG4gICAgICBpZiAobWVkaWFFbCAmJiBtZWRpYUVsLmdldEF0dHJpYnV0ZSkge1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIHBsYXllciBoYXNuJ3QgYWxyZWFkeSBiZWVuIHNldCB1cC5cbiAgICAgICAgaWYgKG1lZGlhRWwucGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IG1lZGlhRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNldHVwJyk7XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiBkYXRhLXNldHVwIGF0dHIgZXhpc3RzLlxuICAgICAgICAgIC8vIFdlIG9ubHkgYXV0by1zZXR1cCBpZiB0aGV5J3ZlIGFkZGVkIHRoZSBkYXRhLXNldHVwIGF0dHIuXG4gICAgICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdmlkZW8uanMgaW5zdGFuY2UuXG4gICAgICAgICAgICB2aWRlb2pzKG1lZGlhRWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGdldEF0dHJpYnV0ZSBpc24ndCBkZWZpbmVkLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBET00uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdXRvU2V0dXBUaW1lb3V0KDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyB2aWRlb3Mgd2VyZSBmb3VuZCwgc28ga2VlcCBsb29waW5nIHVubGVzcyBwYWdlIGlzIGZpbmlzaGVkIGxvYWRpbmcuXG4gIH0gZWxzZSBpZiAoIV93aW5kb3dMb2FkZWQpIHtcbiAgICBhdXRvU2V0dXBUaW1lb3V0KDEpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhaXQgdW50aWwgdGhlIHBhZ2UgaXMgbG9hZGVkIGJlZm9yZSBydW5uaW5nIGF1dG9TZXR1cC4gVGhpcyB3aWxsIGJlIGNhbGxlZCBpblxuICogYXV0b1NldHVwIGlmIGBoYXNMb2FkZWRgIHJldHVybnMgZmFsc2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdhaXRcbiAqICAgICAgICBIb3cgbG9uZyB0byB3YWl0IGluIG1zXG4gKlxuICogQHBhcmFtIHttb2R1bGU6dmlkZW9qc30gW3Zqc11cbiAqICAgICAgICBUaGUgdmlkZW9qcyBsaWJyYXJ5IGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGF1dG9TZXR1cFRpbWVvdXQod2FpdCwgdmpzKSB7XG4gIGlmICh2anMpIHtcbiAgICB2aWRlb2pzID0gdmpzO1xuICB9XG5cbiAgd2luZG93JDEuc2V0VGltZW91dChhdXRvU2V0dXAsIHdhaXQpO1xufVxuXG5pZiAoaXNSZWFsKCkgJiYgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICBfd2luZG93TG9hZGVkID0gdHJ1ZTtcbn0gZWxzZSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIHRoZSBsb2FkIGV2ZW50IG9uIHdpbmRvdywgYW5kIHNldCBfd2luZG93TG9hZGVkIHRvIHRydWUuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGxvYWRcbiAgICovXG4gIG9uZSh3aW5kb3ckMSwgJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgX3dpbmRvd0xvYWRlZCA9IHRydWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEBmaWxlIHN0eWxlc2hlZXQuanNcbiAqIEBtb2R1bGUgc3R5bGVzaGVldFxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgRE9NIHN5bGUgZWxlbWVudCBnaXZlbiBhIGNsYXNzTmFtZSBmb3IgaXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICogICAgICAgIFRoZSBjbGFzc05hbWUgdG8gYWRkIHRvIHRoZSBjcmVhdGVkIHN0eWxlIGVsZW1lbnQuXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAqL1xudmFyIGNyZWF0ZVN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChjbGFzc05hbWUpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBzdHlsZS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuLyoqXG4gKiBBZGQgdGV4dCB0byBhIERPTSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgRWxlbWVudCB0byBhZGQgdGV4dCBjb250ZW50IHRvLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiAgICAgICAgVGhlIHRleHQgdG8gYWRkIHRvIHRoZSBlbGVtZW50LlxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiBzZXRUZXh0Q29udGVudChlbCwgY29udGVudCkge1xuICBpZiAoZWwuc3R5bGVTaGVldCkge1xuICAgIGVsLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgZWwudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICB9XG59O1xuXG4vKipcbiAqIEBmaWxlIGZuLmpzXG4gKiBAbW9kdWxlIGZuXG4gKi9cblxuLyoqXG4gKiBCaW5kIChhLmsuYSBwcm94eSBvciBDb250ZXh0KS4gQSBzaW1wbGUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgY29udGV4dCBvZiBhIGZ1bmN0aW9uXG4gKiBJdCBhbHNvIHN0b3JlcyBhIHVuaXF1ZSBpZCBvbiB0aGUgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGVhc2lseSByZW1vdmVkIGZyb20gZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHRcbiAqICAgICAgICBUaGUgb2JqZWN0IHRvIGJpbmQgYXMgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gYmUgYm91bmQgdG8gYSBzY29wZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3VpZF1cbiAqICAgICAgICBBbiBvcHRpb25hbCB1bmlxdWUgSUQgZm9yIHRoZSBmdW5jdGlvbiB0byBiZSBzZXRcbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqICAgICAgICAgVGhlIG5ldyBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYm91bmQgaW50byB0aGUgY29udGV4dCBnaXZlblxuICovXG52YXIgYmluZCA9IGZ1bmN0aW9uIGJpbmQoY29udGV4dCwgZm4sIHVpZCkge1xuICAvLyBNYWtlIHN1cmUgdGhlIGZ1bmN0aW9uIGhhcyBhIHVuaXF1ZSBJRFxuICBpZiAoIWZuLmd1aWQpIHtcbiAgICBmbi5ndWlkID0gbmV3R1VJRCgpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIHRoZSBuZXcgZnVuY3Rpb24gdGhhdCBjaGFuZ2VzIHRoZSBjb250ZXh0XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEFsbG93IGZvciB0aGUgYWJpbGl0eSB0byBpbmRpdmlkdWFsaXplIHRoaXMgZnVuY3Rpb25cbiAgLy8gTmVlZGVkIGluIHRoZSBjYXNlIHdoZXJlIG11bHRpcGxlIG9iamVjdHMgbWlnaHQgc2hhcmUgdGhlIHNhbWUgcHJvdG90eXBlXG4gIC8vIElGIGJvdGggaXRlbXMgYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHdpdGggdGhlIHNhbWUgZnVuY3Rpb24sIHRoZW4geW91IHRyeSB0byByZW1vdmUganVzdCBvbmVcbiAgLy8gaXQgd2lsbCByZW1vdmUgYm90aCBiZWNhdXNlIHRoZXkgYm90aCBoYXZlIHRoZSBzYW1lIGd1aWQuXG4gIC8vIHdoZW4gdXNpbmcgdGhpcywgeW91IG5lZWQgdG8gdXNlIHRoZSBiaW5kIG1ldGhvZCB3aGVuIHlvdSByZW1vdmUgdGhlIGxpc3RlbmVyIGFzIHdlbGwuXG4gIC8vIGN1cnJlbnRseSB1c2VkIGluIHRleHQgdHJhY2tzXG4gIGJvdW5kLmd1aWQgPSB1aWQgPyB1aWQgKyAnXycgKyBmbi5ndWlkIDogZm4uZ3VpZDtcblxuICByZXR1cm4gYm91bmQ7XG59O1xuXG4vKipcbiAqIFdyYXBzIHRoZSBnaXZlbiBmdW5jdGlvbiwgYGZuYCwgd2l0aCBhIG5ldyBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZm5gXG4gKiBhdCBtb3N0IG9uY2UgcGVyIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiAgICAgICAgIFRoZSBmdW5jdGlvbiB0byBiZSB0aHJvdHRsZWQuXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSAgIHdhaXRcbiAqICAgICAgICAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYnkgd2hpY2ggdG8gdGhyb3R0bGUuXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnZhciB0aHJvdHRsZSA9IGZ1bmN0aW9uIHRocm90dGxlKGZuLCB3YWl0KSB7XG4gIHZhciBsYXN0ID0gRGF0ZS5ub3coKTtcblxuICB2YXIgdGhyb3R0bGVkID0gZnVuY3Rpb24gdGhyb3R0bGVkKCkge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgaWYgKG5vdyAtIGxhc3QgPj0gd2FpdCkge1xuICAgICAgZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgbGFzdCA9IG5vdztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRocm90dGxlZDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuXG4gKlxuICogSW5zcGlyZWQgYnkgbG9kYXNoIGFuZCB1bmRlcnNjb3JlIGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZnVuY1xuICogICAgICAgICBUaGUgZnVuY3Rpb24gdG8gd3JhcCB3aXRoIGRlYm91bmNlIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gd2FpdFxuICogICAgICAgICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGFmdGVyIHRoZSBsYXN0IGludm9jYXRpb24uXG4gKlxuICogQHBhcmFtICB7Ym9vbGVhbn0gW2ltbWVkaWF0ZV1cbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiBpbW1lZGlhdGVseSB1cG9uIGNyZWF0aW9uLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gW2NvbnRleHQ9d2luZG93XVxuICogICAgICAgICBUaGUgXCJjb250ZXh0XCIgaW4gd2hpY2ggdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBzaG91bGQgZGVib3VuY2UuIEZvclxuICogICAgICAgICBleGFtcGxlLCBpZiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB0aWVkIHRvIGEgVmlkZW8uanMgcGxheWVyLFxuICogICAgICAgICB0aGUgcGxheWVyIGNhbiBiZSBwYXNzZWQgaGVyZS4gQWx0ZXJuYXRpdmVseSwgZGVmYXVsdHMgdG8gdGhlXG4gKiAgICAgICAgIGdsb2JhbCBgd2luZG93YCBvYmplY3QuXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiAgICAgICAgIEEgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICovXG52YXIgZGVib3VuY2UgPSBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHdpbmRvdyQxO1xuXG4gIHZhciB0aW1lb3V0ID0gdm9pZCAwO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtdGhpcyAqL1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICAgIHZhciBfbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgX2xhdGVyID0gbnVsbDtcbiAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgIGZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghdGltZW91dCAmJiBpbW1lZGlhdGUpIHtcbiAgICAgIGZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dChfbGF0ZXIsIHdhaXQpO1xuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlIGNvbnNpc3RlbnQtdGhpcyAqL1xufTtcblxuLyoqXG4gKiBAZmlsZSBzcmMvanMvZXZlbnQtdGFyZ2V0LmpzXG4gKi9cblxuLyoqXG4gKiBgRXZlbnRUYXJnZXRgIGlzIGEgY2xhc3MgdGhhdCBjYW4gaGF2ZSB0aGUgc2FtZSBBUEkgYXMgdGhlIERPTSBgRXZlbnRUYXJnZXRgLiBJdFxuICogYWRkcyBzaG9ydGhhbmQgZnVuY3Rpb25zIHRoYXQgd3JhcCBhcm91bmQgbGVuZ3RoeSBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICogdGhlIGBvbmAgZnVuY3Rpb24gaXMgYSB3cmFwcGVyIGFyb3VuZCBgYWRkRXZlbnRMaXN0ZW5lcmAuXG4gKlxuICogQHNlZSBbRXZlbnRUYXJnZXQgU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXR9XG4gKiBAY2xhc3MgRXZlbnRUYXJnZXRcbiAqL1xudmFyIEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7fTtcblxuLyoqXG4gKiBBIEN1c3RvbSBET00gZXZlbnQuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRXZlbnRUYXJnZXR+RXZlbnRcbiAqIEBzZWUgW1Byb3BlcnRpZXNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudH1cbiAqL1xuXG4vKipcbiAqIEFsbCBldmVudCBsaXN0ZW5lcnMgc2hvdWxkIGZvbGxvdyB0aGUgZm9sbG93aW5nIGZvcm1hdC5cbiAqXG4gKiBAY2FsbGJhY2sgRXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lclxuICogQHRoaXMge0V2ZW50VGFyZ2V0fVxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gKiAgICAgICAgdGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2hhc2hdXG4gKiAgICAgICAgaGFzaCBvZiBkYXRhIHNlbnQgZHVyaW5nIHRoZSBldmVudFxuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgZXZlbnQgbmFtZXMgYXMga2V5cyBhbmQgYm9vbGVhbnMgYXMgdmFsdWVzLlxuICpcbiAqID4gTk9URTogSWYgYW4gZXZlbnQgbmFtZSBpcyBzZXQgdG8gYSB0cnVlIHZhbHVlIGhlcmUge0BsaW5rIEV2ZW50VGFyZ2V0I3RyaWdnZXJ9XG4gKiAgICAgICAgIHdpbGwgaGF2ZSBleHRyYSBmdW5jdGlvbmFsaXR5LiBTZWUgdGhhdCBmdW5jdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcHJvcGVydHkgRXZlbnRUYXJnZXQucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfXG4gKiBAcHJpdmF0ZVxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7fTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudCBsaXN0ZW5lcmAgdG8gYW4gaW5zdGFuY2Ugb2YgYW4gYEV2ZW50VGFyZ2V0YC4gQW4gYGV2ZW50IGxpc3RlbmVyYCBpcyBhXG4gKiBmdW5jdGlvbiB0aGF0IHdpbGwgZ2V0IGNhbGxlZCB3aGVuIGFuIGV2ZW50IHdpdGggYSBjZXJ0YWluIG5hbWUgZ2V0cyB0cmlnZ2VyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHR5cGVcbiAqICAgICAgICBBbiBldmVudCBuYW1lIG9yIGFuIGFycmF5IG9mIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm5cbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIGBFdmVudFRhcmdldGBzXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAvLyBSZW1vdmUgdGhlIGFkZEV2ZW50TGlzdGVuZXIgYWxpYXMgYmVmb3JlIGNhbGxpbmcgRXZlbnRzLm9uXG4gIC8vIHNvIHdlIGRvbid0IGdldCBpbnRvIGFuIGluZmluaXRlIHR5cGUgbG9vcFxuICB2YXIgYWVsID0gdGhpcy5hZGRFdmVudExpc3RlbmVyO1xuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHt9O1xuICBvbih0aGlzLCB0eXBlLCBmbik7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGFlbDtcbn07XG5cbi8qKlxuICogQW4gYWxpYXMgb2Yge0BsaW5rIEV2ZW50VGFyZ2V0I29ufS4gQWxsb3dzIGBFdmVudFRhcmdldGAgdG8gbWltaWNcbiAqIHRoZSBzdGFuZGFyZCBET00gQVBJLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHNlZSB7QGxpbmsgRXZlbnRUYXJnZXQjb259XG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLm9uO1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gYGV2ZW50IGxpc3RlbmVyYCBmb3IgYSBzcGVjaWZpYyBldmVudCBmcm9tIGFuIGluc3RhbmNlIG9mIGBFdmVudFRhcmdldGAuXG4gKiBUaGlzIG1ha2VzIGl0IHNvIHRoYXQgdGhlIGBldmVudCBsaXN0ZW5lcmAgd2lsbCBubyBsb25nZXIgZ2V0IGNhbGxlZCB3aGVuIHRoZVxuICogbmFtZWQgZXZlbnQgaGFwcGVucy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdHlwZVxuICogICAgICAgIEFuIGV2ZW50IG5hbWUgb3IgYW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMuXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmblxuICogICAgICAgIFRoZSBmdW5jdGlvbiB0byByZW1vdmUuXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgb2ZmKHRoaXMsIHR5cGUsIGZuKTtcbn07XG5cbi8qKlxuICogQW4gYWxpYXMgb2Yge0BsaW5rIEV2ZW50VGFyZ2V0I29mZn0uIEFsbG93cyBgRXZlbnRUYXJnZXRgIHRvIG1pbWljXG4gKiB0aGUgc3RhbmRhcmQgRE9NIEFQSS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBzZWUge0BsaW5rIEV2ZW50VGFyZ2V0I29mZn1cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUub2ZmO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhZGQgYW4gYGV2ZW50IGxpc3RlbmVyYCB0aGF0IGdldHMgdHJpZ2dlcmVkIG9ubHkgb25jZS4gQWZ0ZXIgdGhlXG4gKiBmaXJzdCB0cmlnZ2VyIGl0IHdpbGwgZ2V0IHJlbW92ZWQuIFRoaXMgaXMgbGlrZSBhZGRpbmcgYW4gYGV2ZW50IGxpc3RlbmVyYFxuICogd2l0aCB7QGxpbmsgRXZlbnRUYXJnZXQjb259IHRoYXQgY2FsbHMge0BsaW5rIEV2ZW50VGFyZ2V0I29mZn0gb24gaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXG4gKiAgICAgICAgQW4gZXZlbnQgbmFtZSBvciBhbiBhcnJheSBvZiBldmVudCBuYW1lcy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZuXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGV2ZW50IG5hbWUuXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbmUgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgLy8gUmVtb3ZlIHRoZSBhZGRFdmVudExpc3RlbmVyIGFsaWFsaW5nIEV2ZW50cy5vblxuICAvLyBzbyB3ZSBkb24ndCBnZXQgaW50byBhbiBpbmZpbml0ZSB0eXBlIGxvb3BcbiAgdmFyIGFlbCA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcjtcblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgb25lKHRoaXMsIHR5cGUsIGZuKTtcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gYWVsO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhdXNlcyBhbiBldmVudCB0byBoYXBwZW4uIFRoaXMgd2lsbCB0aGVuIGNhdXNlIGFueSBgZXZlbnQgbGlzdGVuZXJzYFxuICogdGhhdCBhcmUgd2FpdGluZyBmb3IgdGhhdCBldmVudCwgdG8gZ2V0IGNhbGxlZC4gSWYgdGhlcmUgYXJlIG5vIGBldmVudCBsaXN0ZW5lcnNgXG4gKiBmb3IgYW4gZXZlbnQgdGhlbiBub3RoaW5nIHdpbGwgaGFwcGVuLlxuICpcbiAqIElmIHRoZSBuYW1lIG9mIHRoZSBgRXZlbnRgIHRoYXQgaXMgYmVpbmcgdHJpZ2dlcmVkIGlzIGluIGBFdmVudFRhcmdldC5hbGxvd2VkRXZlbnRzX2AuXG4gKiBUcmlnZ2VyIHdpbGwgYWxzbyBjYWxsIHRoZSBgb25gICsgYHVwcGVyY2FzZUV2ZW50TmFtZWAgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqICdjbGljaycgaXMgaW4gYEV2ZW50VGFyZ2V0LmFsbG93ZWRFdmVudHNfYCwgc28sIHRyaWdnZXIgd2lsbCBhdHRlbXB0IHRvIGNhbGxcbiAqIGBvbkNsaWNrYCBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8RXZlbnRUYXJnZXR+RXZlbnR8T2JqZWN0fSBldmVudFxuICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBldmVudCwgYW4gYEV2ZW50YCwgb3IgYW4gb2JqZWN0IHdpdGggYSBrZXkgb2YgdHlwZSBzZXQgdG9cbiAqICAgICAgICBhbiBldmVudCBuYW1lLlxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgZXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBldmVudCA9IHsgdHlwZTogdHlwZSB9O1xuICB9XG4gIGV2ZW50ID0gZml4RXZlbnQoZXZlbnQpO1xuXG4gIGlmICh0aGlzLmFsbG93ZWRFdmVudHNfW3R5cGVdICYmIHRoaXNbJ29uJyArIHR5cGVdKSB7XG4gICAgdGhpc1snb24nICsgdHlwZV0oZXZlbnQpO1xuICB9XG5cbiAgdHJpZ2dlcih0aGlzLCBldmVudCk7XG59O1xuXG4vKipcbiAqIEFuIGFsaWFzIG9mIHtAbGluayBFdmVudFRhcmdldCN0cmlnZ2VyfS4gQWxsb3dzIGBFdmVudFRhcmdldGAgdG8gbWltaWNcbiAqIHRoZSBzdGFuZGFyZCBET00gQVBJLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHNlZSB7QGxpbmsgRXZlbnRUYXJnZXQjdHJpZ2dlcn1cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBFdmVudFRhcmdldC5wcm90b3R5cGUudHJpZ2dlcjtcblxuLyoqXG4gKiBAZmlsZSBtaXhpbnMvZXZlbnRlZC5qc1xuICogQG1vZHVsZSBldmVudGVkXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBoYXMgaGFkIHRoZSBldmVudGVkIG1peGluIGFwcGxpZWQuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvYmplY3RcbiAqICAgICAgICAgQW4gb2JqZWN0IHRvIHRlc3QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBhcHBlYXJzIHRvIGJlIGV2ZW50ZWQuXG4gKi9cbnZhciBpc0V2ZW50ZWQgPSBmdW5jdGlvbiBpc0V2ZW50ZWQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBFdmVudFRhcmdldCB8fCAhIW9iamVjdC5ldmVudEJ1c0VsXyAmJiBbJ29uJywgJ29uZScsICdvZmYnLCAndHJpZ2dlciddLmV2ZXJ5KGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3Rba10gPT09ICdmdW5jdGlvbic7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBXaGV0aGVyIGEgdmFsdWUgaXMgYSB2YWxpZCBldmVudCB0eXBlIC0gbm9uLWVtcHR5IHN0cmluZyBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7c3RyaW5nfEFycmF5fSB0eXBlXG4gKiAgICAgICAgIFRoZSB0eXBlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdGhlIHR5cGUgaXMgYSB2YWxpZCBldmVudCB0eXBlLlxuICovXG52YXIgaXNWYWxpZEV2ZW50VHlwZSA9IGZ1bmN0aW9uIGlzVmFsaWRFdmVudFR5cGUodHlwZSkge1xuICByZXR1cm4gKFxuICAgIC8vIFRoZSByZWdleCBoZXJlIHZlcmlmaWVzIHRoYXQgdGhlIGB0eXBlYCBjb250YWlucyBhdCBsZWFzdCBvbmUgbm9uLVxuICAgIC8vIHdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyAmJiAvXFxTLy50ZXN0KHR5cGUpIHx8IEFycmF5LmlzQXJyYXkodHlwZSkgJiYgISF0eXBlLmxlbmd0aFxuICApO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB2YWx1ZSB0byBkZXRlcm1pbmUgaWYgaXQgaXMgYSB2YWxpZCBldmVudCB0YXJnZXQuIFRocm93cyBpZiBub3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogICAgICAgICBJZiB0aGUgdGFyZ2V0IGRvZXMgbm90IGFwcGVhciB0byBiZSBhIHZhbGlkIGV2ZW50IHRhcmdldC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICogICAgICAgICBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKi9cbnZhciB2YWxpZGF0ZVRhcmdldCA9IGZ1bmN0aW9uIHZhbGlkYXRlVGFyZ2V0KHRhcmdldCkge1xuICBpZiAoIXRhcmdldC5ub2RlTmFtZSAmJiAhaXNFdmVudGVkKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFyZ2V0OyBtdXN0IGJlIGEgRE9NIG5vZGUgb3IgZXZlbnRlZCBvYmplY3QuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgdmFsdWUgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGEgdmFsaWQgZXZlbnQgdGFyZ2V0LiBUaHJvd3MgaWYgbm90LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqICAgICAgICAgSWYgdGhlIHR5cGUgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgdmFsaWQgZXZlbnQgdHlwZS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl9IHR5cGVcbiAqICAgICAgICAgVGhlIHR5cGUgdG8gdGVzdC5cbiAqL1xudmFyIHZhbGlkYXRlRXZlbnRUeXBlID0gZnVuY3Rpb24gdmFsaWRhdGVFdmVudFR5cGUodHlwZSkge1xuICBpZiAoIWlzVmFsaWRFdmVudFR5cGUodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZXZlbnQgdHlwZTsgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYXJyYXkuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgdmFsdWUgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGEgdmFsaWQgbGlzdGVuZXIuIFRocm93cyBpZiBub3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogICAgICAgICBJZiB0aGUgbGlzdGVuZXIgaXMgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKiAgICAgICAgIFRoZSBsaXN0ZW5lciB0byB0ZXN0LlxuICovXG52YXIgdmFsaWRhdGVMaXN0ZW5lciA9IGZ1bmN0aW9uIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0ZW5lcjsgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBnaXZlbiB0byBgb24oKWAgb3IgYG9uZSgpYCwgdmFsaWRhdGVzIHRoZW0sIGFuZFxuICogbm9ybWFsaXplcyB0aGVtIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtPYmplY3R9IHNlbGZcbiAqICAgICAgICAgVGhlIGV2ZW50ZWQgb2JqZWN0IG9uIHdoaWNoIGBvbigpYCBvciBgb25lKClgIHdhcyBjYWxsZWQuIFRoaXNcbiAqICAgICAgICAgb2JqZWN0IHdpbGwgYmUgYm91bmQgYXMgdGhlIGB0aGlzYCB2YWx1ZSBmb3IgdGhlIGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBhcmdzXG4gKiAgICAgICAgIEFuIGFycmF5IG9mIGFyZ3VtZW50cyBwYXNzZWQgdG8gYG9uKClgIG9yIGBvbmUoKWAuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyB1c2VmdWwgdmFsdWVzIGZvciBgb24oKWAgb3IgYG9uZSgpYCBjYWxscy5cbiAqL1xudmFyIG5vcm1hbGl6ZUxpc3RlbkFyZ3MgPSBmdW5jdGlvbiBub3JtYWxpemVMaXN0ZW5BcmdzKHNlbGYsIGFyZ3MpIHtcblxuICAvLyBJZiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpcyBsZXNzIHRoYW4gMywgdGhlIHRhcmdldCBpcyBhbHdheXMgdGhlXG4gIC8vIGV2ZW50ZWQgb2JqZWN0IGl0c2VsZi5cbiAgdmFyIGlzVGFyZ2V0aW5nU2VsZiA9IGFyZ3MubGVuZ3RoIDwgMyB8fCBhcmdzWzBdID09PSBzZWxmIHx8IGFyZ3NbMF0gPT09IHNlbGYuZXZlbnRCdXNFbF87XG4gIHZhciB0YXJnZXQgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gdm9pZCAwO1xuICB2YXIgbGlzdGVuZXIgPSB2b2lkIDA7XG5cbiAgaWYgKGlzVGFyZ2V0aW5nU2VsZikge1xuICAgIHRhcmdldCA9IHNlbGYuZXZlbnRCdXNFbF87XG5cbiAgICAvLyBEZWFsIHdpdGggY2FzZXMgd2hlcmUgd2UgZ290IDMgYXJndW1lbnRzLCBidXQgd2UgYXJlIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHRoZSBldmVudGVkIG9iamVjdCBpdHNlbGYuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID49IDMpIHtcbiAgICAgIGFyZ3Muc2hpZnQoKTtcbiAgICB9XG5cbiAgICB0eXBlID0gYXJnc1swXTtcbiAgICBsaXN0ZW5lciA9IGFyZ3NbMV07XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gYXJnc1swXTtcbiAgICB0eXBlID0gYXJnc1sxXTtcbiAgICBsaXN0ZW5lciA9IGFyZ3NbMl07XG4gIH1cblxuICB2YWxpZGF0ZVRhcmdldCh0YXJnZXQpO1xuICB2YWxpZGF0ZUV2ZW50VHlwZSh0eXBlKTtcbiAgdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgbGlzdGVuZXIgPSBiaW5kKHNlbGYsIGxpc3RlbmVyKTtcblxuICByZXR1cm4geyBpc1RhcmdldGluZ1NlbGY6IGlzVGFyZ2V0aW5nU2VsZiwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xufTtcblxuLyoqXG4gKiBBZGRzIHRoZSBsaXN0ZW5lciB0byB0aGUgZXZlbnQgdHlwZShzKSBvbiB0aGUgdGFyZ2V0LCBub3JtYWxpemluZyBmb3JcbiAqIHRoZSB0eXBlIG9mIHRhcmdldC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7RWxlbWVudHxPYmplY3R9IHRhcmdldFxuICogICAgICAgICBBIERPTSBub2RlIG9yIGV2ZW50ZWQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbWV0aG9kXG4gKiAgICAgICAgIFRoZSBldmVudCBiaW5kaW5nIG1ldGhvZCB0byB1c2UgKFwib25cIiBvciBcIm9uZVwiKS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl9IHR5cGVcbiAqICAgICAgICAgT25lIG9yIG1vcmUgZXZlbnQgdHlwZShzKS5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqICAgICAgICAgQSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqL1xudmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIG1ldGhvZCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFsaWRhdGVUYXJnZXQodGFyZ2V0KTtcblxuICBpZiAodGFyZ2V0Lm5vZGVOYW1lKSB7XG4gICAgRXZlbnRzW21ldGhvZF0odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W21ldGhvZF0odHlwZSwgbGlzdGVuZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnRhaW5zIG1ldGhvZHMgdGhhdCBwcm92aWRlIGV2ZW50IGNhcGFiaWxpdGllcyB0byBhbiBvYmplY3Qgd2hpY2ggaXMgcGFzc2VkXG4gKiB0byB7QGxpbmsgbW9kdWxlOmV2ZW50ZWR8ZXZlbnRlZH0uXG4gKlxuICogQG1peGluIEV2ZW50ZWRNaXhpblxuICovXG52YXIgRXZlbnRlZE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byBhbiBldmVudCAob3IgZXZlbnRzKSBvbiB0aGlzIG9iamVjdCBvciBhbm90aGVyIGV2ZW50ZWRcbiAgICogb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RWxlbWVudHxPYmplY3R9IHRhcmdldE9yVHlwZVxuICAgKiAgICAgICAgIElmIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXksIGl0IHJlcHJlc2VudHMgdGhlIGV2ZW50IHR5cGUocylcbiAgICogICAgICAgICB0aGF0IHdpbGwgdHJpZ2dlciB0aGUgbGlzdGVuZXIuXG4gICAqXG4gICAqICAgICAgICAgQW5vdGhlciBldmVudGVkIG9iamVjdCBjYW4gYmUgcGFzc2VkIGhlcmUgaW5zdGVhZCwgd2hpY2ggd2lsbFxuICAgKiAgICAgICAgIGNhdXNlIHRoZSBsaXN0ZW5lciB0byBsaXN0ZW4gZm9yIGV2ZW50cyBvbiBfdGhhdF8gb2JqZWN0LlxuICAgKlxuICAgKiAgICAgICAgIEluIGVpdGhlciBjYXNlLCB0aGUgbGlzdGVuZXIncyBgdGhpc2AgdmFsdWUgd2lsbCBiZSBib3VuZCB0b1xuICAgKiAgICAgICAgIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RnVuY3Rpb259IHR5cGVPckxpc3RlbmVyXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhIHN0cmluZyBvciBhcnJheSwgdGhpcyBzaG91bGQgYmUgdGhlXG4gICAqICAgICAgICAgbGlzdGVuZXIgZnVuY3Rpb24uIE90aGVyd2lzZSwgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSBvZiBldmVudFxuICAgKiAgICAgICAgIHR5cGUocykuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbbGlzdGVuZXJdXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LCB0aGlzIHdpbGwgYmVcbiAgICogICAgICAgICB0aGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gICAqL1xuICBvbjogZnVuY3Rpb24gb24kJDEoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBfbm9ybWFsaXplTGlzdGVuQXJncyA9IG5vcm1hbGl6ZUxpc3RlbkFyZ3ModGhpcywgYXJncyksXG4gICAgICAgIGlzVGFyZ2V0aW5nU2VsZiA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzLmlzVGFyZ2V0aW5nU2VsZixcbiAgICAgICAgdGFyZ2V0ID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MudGFyZ2V0LFxuICAgICAgICB0eXBlID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MudHlwZSxcbiAgICAgICAgbGlzdGVuZXIgPSBfbm9ybWFsaXplTGlzdGVuQXJncy5saXN0ZW5lcjtcblxuICAgIGxpc3Rlbih0YXJnZXQsICdvbicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICAgIC8vIElmIHRoaXMgb2JqZWN0IGlzIGxpc3RlbmluZyB0byBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LlxuICAgIGlmICghaXNUYXJnZXRpbmdTZWxmKSB7XG5cbiAgICAgIC8vIElmIHRoaXMgb2JqZWN0IGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgICAgdmFyIHJlbW92ZUxpc3RlbmVyT25EaXNwb3NlID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJPbkRpc3Bvc2UoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5vZmYodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICB9O1xuXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgZnVuY3Rpb24gSUQgYXMgdGhlIGxpc3RlbmVyIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXIgaXRcbiAgICAgIC8vIHVzaW5nIHRoZSBJRCBvZiB0aGUgb3JpZ2luYWwgbGlzdGVuZXIuXG4gICAgICByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZS5ndWlkID0gbGlzdGVuZXIuZ3VpZDtcblxuICAgICAgLy8gQWRkIGEgbGlzdGVuZXIgdG8gdGhlIHRhcmdldCdzIGRpc3Bvc2UgZXZlbnQgYXMgd2VsbC4gVGhpcyBlbnN1cmVzXG4gICAgICAvLyB0aGF0IGlmIHRoZSB0YXJnZXQgaXMgZGlzcG9zZWQgQkVGT1JFIHRoaXMgb2JqZWN0LCB3ZSByZW1vdmUgdGhlXG4gICAgICAvLyByZW1vdmFsIGxpc3RlbmVyIHRoYXQgd2FzIGp1c3QgYWRkZWQuIE90aGVyd2lzZSwgd2UgY3JlYXRlIGEgbWVtb3J5IGxlYWsuXG4gICAgICB2YXIgcmVtb3ZlUmVtb3Zlck9uVGFyZ2V0RGlzcG9zZSA9IGZ1bmN0aW9uIHJlbW92ZVJlbW92ZXJPblRhcmdldERpc3Bvc2UoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5vZmYoJ2Rpc3Bvc2UnLCByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgZnVuY3Rpb24gSUQgYXMgdGhlIGxpc3RlbmVyIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXJcbiAgICAgIC8vIGl0IHVzaW5nIHRoZSBJRCBvZiB0aGUgb3JpZ2luYWwgbGlzdGVuZXIuXG4gICAgICByZW1vdmVSZW1vdmVyT25UYXJnZXREaXNwb3NlLmd1aWQgPSBsaXN0ZW5lci5ndWlkO1xuXG4gICAgICBsaXN0ZW4odGhpcywgJ29uJywgJ2Rpc3Bvc2UnLCByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZSk7XG4gICAgICBsaXN0ZW4odGFyZ2V0LCAnb24nLCAnZGlzcG9zZScsIHJlbW92ZVJlbW92ZXJPblRhcmdldERpc3Bvc2UpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byBhbiBldmVudCAob3IgZXZlbnRzKSBvbiB0aGlzIG9iamVjdCBvciBhbm90aGVyIGV2ZW50ZWRcbiAgICogb2JqZWN0LiBUaGUgbGlzdGVuZXIgd2lsbCBvbmx5IGJlIGNhbGxlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxFbGVtZW50fE9iamVjdH0gdGFyZ2V0T3JUeXBlXG4gICAqICAgICAgICAgSWYgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSwgaXQgcmVwcmVzZW50cyB0aGUgZXZlbnQgdHlwZShzKVxuICAgKiAgICAgICAgIHRoYXQgd2lsbCB0cmlnZ2VyIHRoZSBsaXN0ZW5lci5cbiAgICpcbiAgICogICAgICAgICBBbm90aGVyIGV2ZW50ZWQgb2JqZWN0IGNhbiBiZSBwYXNzZWQgaGVyZSBpbnN0ZWFkLCB3aGljaCB3aWxsXG4gICAqICAgICAgICAgY2F1c2UgdGhlIGxpc3RlbmVyIHRvIGxpc3RlbiBmb3IgZXZlbnRzIG9uIF90aGF0XyBvYmplY3QuXG4gICAqXG4gICAqICAgICAgICAgSW4gZWl0aGVyIGNhc2UsIHRoZSBsaXN0ZW5lcidzIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIGJvdW5kIHRvXG4gICAqICAgICAgICAgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxGdW5jdGlvbn0gdHlwZU9yTGlzdGVuZXJcbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGEgc3RyaW5nIG9yIGFycmF5LCB0aGlzIHNob3VsZCBiZSB0aGVcbiAgICogICAgICAgICBsaXN0ZW5lciBmdW5jdGlvbi4gT3RoZXJ3aXNlLCB0aGlzIGlzIGEgc3RyaW5nIG9yIGFycmF5IG9mIGV2ZW50XG4gICAqICAgICAgICAgdHlwZShzKS5cbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtsaXN0ZW5lcl1cbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGFub3RoZXIgZXZlbnRlZCBvYmplY3QsIHRoaXMgd2lsbCBiZVxuICAgKiAgICAgICAgIHRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICovXG4gIG9uZTogZnVuY3Rpb24gb25lJCQxKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICB2YXIgX25vcm1hbGl6ZUxpc3RlbkFyZ3MyID0gbm9ybWFsaXplTGlzdGVuQXJncyh0aGlzLCBhcmdzKSxcbiAgICAgICAgaXNUYXJnZXRpbmdTZWxmID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MyLmlzVGFyZ2V0aW5nU2VsZixcbiAgICAgICAgdGFyZ2V0ID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MyLnRhcmdldCxcbiAgICAgICAgdHlwZSA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzMi50eXBlLFxuICAgICAgICBsaXN0ZW5lciA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzMi5saXN0ZW5lcjtcblxuICAgIC8vIFRhcmdldGluZyB0aGlzIGV2ZW50ZWQgb2JqZWN0LlxuXG5cbiAgICBpZiAoaXNUYXJnZXRpbmdTZWxmKSB7XG4gICAgICBsaXN0ZW4odGFyZ2V0LCAnb25lJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gICAgICAvLyBUYXJnZXRpbmcgYW5vdGhlciBldmVudGVkIG9iamVjdC5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGxhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICBsYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLm9mZih0YXJnZXQsIHR5cGUsIHdyYXBwZXIpO1xuICAgICAgICBsaXN0ZW5lci5hcHBseShudWxsLCBsYXJncyk7XG4gICAgICB9O1xuXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgZnVuY3Rpb24gSUQgYXMgdGhlIGxpc3RlbmVyIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXJcbiAgICAgIC8vIGl0IHVzaW5nIHRoZSBJRCBvZiB0aGUgb3JpZ2luYWwgbGlzdGVuZXIuXG4gICAgICB3cmFwcGVyLmd1aWQgPSBsaXN0ZW5lci5ndWlkO1xuICAgICAgbGlzdGVuKHRhcmdldCwgJ29uZScsIHR5cGUsIHdyYXBwZXIpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGxpc3RlbmVyKHMpIGZyb20gZXZlbnQocykgb24gYW4gZXZlbnRlZCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxFbGVtZW50fE9iamVjdH0gW3RhcmdldE9yVHlwZV1cbiAgICogICAgICAgICBJZiB0aGlzIGlzIGEgc3RyaW5nIG9yIGFycmF5LCBpdCByZXByZXNlbnRzIHRoZSBldmVudCB0eXBlKHMpLlxuICAgKlxuICAgKiAgICAgICAgIEFub3RoZXIgZXZlbnRlZCBvYmplY3QgY2FuIGJlIHBhc3NlZCBoZXJlIGluc3RlYWQsIGluIHdoaWNoIGNhc2VcbiAgICogICAgICAgICBBTEwgMyBhcmd1bWVudHMgYXJlIF9yZXF1aXJlZF8uXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxGdW5jdGlvbn0gW3R5cGVPckxpc3RlbmVyXVxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYSBzdHJpbmcgb3IgYXJyYXksIHRoaXMgbWF5IGJlIHRoZVxuICAgKiAgICAgICAgIGxpc3RlbmVyIGZ1bmN0aW9uLiBPdGhlcndpc2UsIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXkgb2YgZXZlbnRcbiAgICogICAgICAgICB0eXBlKHMpLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2xpc3RlbmVyXVxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYW5vdGhlciBldmVudGVkIG9iamVjdCwgdGhpcyB3aWxsIGJlXG4gICAqICAgICAgICAgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uOyBvdGhlcndpc2UsIF9hbGxfIGxpc3RlbmVycyBib3VuZCB0byB0aGVcbiAgICogICAgICAgICBldmVudCB0eXBlKHMpIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmJCQxKHRhcmdldE9yVHlwZSwgdHlwZU9yTGlzdGVuZXIsIGxpc3RlbmVyKSB7XG5cbiAgICAvLyBUYXJnZXRpbmcgdGhpcyBldmVudGVkIG9iamVjdC5cbiAgICBpZiAoIXRhcmdldE9yVHlwZSB8fCBpc1ZhbGlkRXZlbnRUeXBlKHRhcmdldE9yVHlwZSkpIHtcbiAgICAgIG9mZih0aGlzLmV2ZW50QnVzRWxfLCB0YXJnZXRPclR5cGUsIHR5cGVPckxpc3RlbmVyKTtcblxuICAgICAgLy8gVGFyZ2V0aW5nIGFub3RoZXIgZXZlbnRlZCBvYmplY3QuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRPclR5cGU7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVPckxpc3RlbmVyO1xuXG4gICAgICAvLyBGYWlsIGZhc3QgYW5kIGluIGEgbWVhbmluZ2Z1bCB3YXkhXG4gICAgICB2YWxpZGF0ZVRhcmdldCh0YXJnZXQpO1xuICAgICAgdmFsaWRhdGVFdmVudFR5cGUodHlwZSk7XG4gICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgLy8gRW5zdXJlIHRoZXJlJ3MgYXQgbGVhc3QgYSBndWlkLCBldmVuIGlmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgYmVlbiB1c2VkXG4gICAgICBsaXN0ZW5lciA9IGJpbmQodGhpcywgbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZW1vdmUgdGhlIGRpc3Bvc2UgbGlzdGVuZXIgb24gdGhpcyBldmVudGVkIG9iamVjdCwgd2hpY2ggd2FzIGdpdmVuXG4gICAgICAvLyB0aGUgc2FtZSBndWlkIGFzIHRoZSBldmVudCBsaXN0ZW5lciBpbiBvbigpLlxuICAgICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnLCBsaXN0ZW5lcik7XG5cbiAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUpIHtcbiAgICAgICAgb2ZmKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBvZmYodGFyZ2V0LCAnZGlzcG9zZScsIGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNFdmVudGVkKHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0Lm9mZih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIHRhcmdldC5vZmYoJ2Rpc3Bvc2UnLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEZpcmUgYW4gZXZlbnQgb24gdGhpcyBldmVudGVkIG9iamVjdCwgY2F1c2luZyBpdHMgbGlzdGVuZXJzIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ3xPYmplY3R9IGV2ZW50XG4gICAqICAgICAgICAgIEFuIGV2ZW50IHR5cGUgb3IgYW4gb2JqZWN0IHdpdGggYSB0eXBlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSBbaGFzaF1cbiAgICogICAgICAgICAgQW4gYWRkaXRpb25hbCBvYmplY3QgdG8gcGFzcyBhbG9uZyB0byBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiAgICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3YXMgcHJldmVudGVkLlxuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlciQkMShldmVudCwgaGFzaCkge1xuICAgIHJldHVybiB0cmlnZ2VyKHRoaXMuZXZlbnRCdXNFbF8sIGV2ZW50LCBoYXNoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIHtAbGluayBtb2R1bGU6ZXZlbnRlZH5FdmVudGVkTWl4aW58RXZlbnRlZE1peGlufSB0byBhIHRhcmdldCBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAqICAgICAgICAgVGhlIG9iamVjdCB0byB3aGljaCB0byBhZGQgZXZlbnQgbWV0aG9kcy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICogICAgICAgICBPcHRpb25zIGZvciBjdXN0b21pemluZyB0aGUgbWl4aW4gYmVoYXZpb3IuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBbb3B0aW9ucy5ldmVudEJ1c0tleV1cbiAqICAgICAgICAgQnkgZGVmYXVsdCwgYWRkcyBhIGBldmVudEJ1c0VsX2AgRE9NIGVsZW1lbnQgdG8gdGhlIHRhcmdldCBvYmplY3QsXG4gKiAgICAgICAgIHdoaWNoIGlzIHVzZWQgYXMgYW4gZXZlbnQgYnVzLiBJZiB0aGUgdGFyZ2V0IG9iamVjdCBhbHJlYWR5IGhhcyBhXG4gKiAgICAgICAgIERPTSBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQsIHBhc3MgaXRzIGtleSBoZXJlLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgVGhlIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV2ZW50ZWQodGFyZ2V0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIGV2ZW50QnVzS2V5ID0gb3B0aW9ucy5ldmVudEJ1c0tleTtcblxuICAvLyBTZXQgb3IgY3JlYXRlIHRoZSBldmVudEJ1c0VsXy5cblxuICBpZiAoZXZlbnRCdXNLZXkpIHtcbiAgICBpZiAoIXRhcmdldFtldmVudEJ1c0tleV0ubm9kZU5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGV2ZW50QnVzS2V5IFwiJyArIGV2ZW50QnVzS2V5ICsgJ1wiIGRvZXMgbm90IHJlZmVyIHRvIGFuIGVsZW1lbnQuJyk7XG4gICAgfVxuICAgIHRhcmdldC5ldmVudEJ1c0VsXyA9IHRhcmdldFtldmVudEJ1c0tleV07XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmV2ZW50QnVzRWxfID0gY3JlYXRlRWwoJ3NwYW4nLCB7IGNsYXNzTmFtZTogJ3Zqcy1ldmVudC1idXMnIH0pO1xuICB9XG5cbiAgYXNzaWduKHRhcmdldCwgRXZlbnRlZE1peGluKTtcblxuICAvLyBXaGVuIGFueSBldmVudGVkIG9iamVjdCBpcyBkaXNwb3NlZCwgaXQgcmVtb3ZlcyBhbGwgaXRzIGxpc3RlbmVycy5cbiAgdGFyZ2V0Lm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHRhcmdldC5vZmYoKTtcbiAgICB3aW5kb3ckMS5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRhcmdldC5ldmVudEJ1c0VsXyA9IG51bGw7XG4gICAgfSwgMCk7XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQGZpbGUgbWl4aW5zL3N0YXRlZnVsLmpzXG4gKiBAbW9kdWxlIHN0YXRlZnVsXG4gKi9cblxuLyoqXG4gKiBDb250YWlucyBtZXRob2RzIHRoYXQgcHJvdmlkZSBzdGF0ZWZ1bG5lc3MgdG8gYW4gb2JqZWN0IHdoaWNoIGlzIHBhc3NlZFxuICogdG8ge0BsaW5rIG1vZHVsZTpzdGF0ZWZ1bH0uXG4gKlxuICogQG1peGluIFN0YXRlZnVsTWl4aW5cbiAqL1xudmFyIFN0YXRlZnVsTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEEgaGFzaCBjb250YWluaW5nIGFyYml0cmFyeSBrZXlzIGFuZCB2YWx1ZXMgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZlxuICAgKiB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGU6IHt9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0YXRlIG9mIGFuIG9iamVjdCBieSBtdXRhdGluZyBpdHNcbiAgICoge0BsaW5rIG1vZHVsZTpzdGF0ZWZ1bH5TdGF0ZWZ1bE1peGluLnN0YXRlfHN0YXRlfSBvYmplY3QgaW4gcGxhY2UuXG4gICAqXG4gICAqIEBmaXJlcyAgIG1vZHVsZTpzdGF0ZWZ1bH5TdGF0ZWZ1bE1peGluI3N0YXRlY2hhbmdlZFxuICAgKiBAcGFyYW0gICB7T2JqZWN0fEZ1bmN0aW9ufSBzdGF0ZVVwZGF0ZXNcbiAgICogICAgICAgICAgQSBuZXcgc2V0IG9mIHByb3BlcnRpZXMgdG8gc2hhbGxvdy1tZXJnZSBpbnRvIHRoZSBwbHVnaW4gc3RhdGUuXG4gICAqICAgICAgICAgIENhbiBiZSBhIHBsYWluIG9iamVjdCBvciBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHBsYWluIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIGNoYW5nZXMgdGhhdCBvY2N1cnJlZC4gSWYgbm8gY2hhbmdlc1xuICAgKiAgICAgICAgICBvY2N1cnJlZCwgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICovXG4gIHNldFN0YXRlOiBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZVVwZGF0ZXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gU3VwcG9ydCBwcm92aWRpbmcgdGhlIGBzdGF0ZVVwZGF0ZXNgIHN0YXRlIGFzIGEgZnVuY3Rpb24uXG4gICAgaWYgKHR5cGVvZiBzdGF0ZVVwZGF0ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlVXBkYXRlcyA9IHN0YXRlVXBkYXRlcygpO1xuICAgIH1cblxuICAgIHZhciBjaGFuZ2VzID0gdm9pZCAwO1xuXG4gICAgZWFjaChzdGF0ZVVwZGF0ZXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhbmdlIGlmIHRoZSB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSB3aGF0J3MgaW4gdGhlXG4gICAgICAvLyBjdXJyZW50IHN0YXRlLlxuICAgICAgaWYgKF90aGlzLnN0YXRlW2tleV0gIT09IHZhbHVlKSB7XG4gICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzIHx8IHt9O1xuICAgICAgICBjaGFuZ2VzW2tleV0gPSB7XG4gICAgICAgICAgZnJvbTogX3RoaXMuc3RhdGVba2V5XSxcbiAgICAgICAgICB0bzogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc3RhdGVba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgLy8gT25seSB0cmlnZ2VyIFwic3RhdGVjaGFuZ2VcIiBpZiB0aGVyZSB3ZXJlIGNoYW5nZXMgQU5EIHdlIGhhdmUgYSB0cmlnZ2VyXG4gICAgLy8gZnVuY3Rpb24uIFRoaXMgYWxsb3dzIHVzIHRvIG5vdCByZXF1aXJlIHRoYXQgdGhlIHRhcmdldCBvYmplY3QgYmUgYW5cbiAgICAvLyBldmVudGVkIG9iamVjdC5cbiAgICBpZiAoY2hhbmdlcyAmJiBpc0V2ZW50ZWQodGhpcykpIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbiBldmVudCB0cmlnZ2VyZWQgb24gYW4gb2JqZWN0IHRoYXQgaXMgYm90aFxuICAgICAgICoge0BsaW5rIG1vZHVsZTpzdGF0ZWZ1bHxzdGF0ZWZ1bH0gYW5kIHtAbGluayBtb2R1bGU6ZXZlbnRlZHxldmVudGVkfVxuICAgICAgICogaW5kaWNhdGluZyB0aGF0IGl0cyBzdGF0ZSBoYXMgY2hhbmdlZC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgICAgbW9kdWxlOnN0YXRlZnVsflN0YXRlZnVsTWl4aW4jc3RhdGVjaGFuZ2VkXG4gICAgICAgKiBAdHlwZSAgICAge09iamVjdH1cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjaGFuZ2VzXG4gICAgICAgKiAgICAgICAgICAgQSBoYXNoIGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGNoYW5nZWQgYW5kXG4gICAgICAgKiAgICAgICAgICAgdGhlIHZhbHVlcyB0aGV5IHdlcmUgY2hhbmdlZCBgZnJvbWAgYW5kIGB0b2AuXG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcih7XG4gICAgICAgIGNoYW5nZXM6IGNoYW5nZXMsXG4gICAgICAgIHR5cGU6ICdzdGF0ZWNoYW5nZWQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIHtAbGluayBtb2R1bGU6c3RhdGVmdWx+U3RhdGVmdWxNaXhpbnxTdGF0ZWZ1bE1peGlufSB0byBhIHRhcmdldFxuICogb2JqZWN0LlxuICpcbiAqIElmIHRoZSB0YXJnZXQgb2JqZWN0IGlzIHtAbGluayBtb2R1bGU6ZXZlbnRlZHxldmVudGVkfSBhbmQgaGFzIGFcbiAqIGBoYW5kbGVTdGF0ZUNoYW5nZWRgIG1ldGhvZCwgdGhhdCBtZXRob2Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kIHRvIHRoZVxuICogYHN0YXRlY2hhbmdlZGAgZXZlbnQgb24gaXRzZWxmLlxuICpcbiAqIEBwYXJhbSAgIHtPYmplY3R9IHRhcmdldFxuICogICAgICAgICAgVGhlIG9iamVjdCB0byBiZSBtYWRlIHN0YXRlZnVsLlxuICpcbiAqIEBwYXJhbSAgIHtPYmplY3R9IFtkZWZhdWx0U3RhdGVdXG4gKiAgICAgICAgICBBIGRlZmF1bHQgc2V0IG9mIHByb3BlcnRpZXMgdG8gcG9wdWxhdGUgdGhlIG5ld2x5LXN0YXRlZnVsIG9iamVjdCdzXG4gKiAgICAgICAgICBgc3RhdGVgIHByb3BlcnR5LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiAgICAgICAgICBSZXR1cm5zIHRoZSBgdGFyZ2V0YC5cbiAqL1xuZnVuY3Rpb24gc3RhdGVmdWwodGFyZ2V0LCBkZWZhdWx0U3RhdGUpIHtcbiAgYXNzaWduKHRhcmdldCwgU3RhdGVmdWxNaXhpbik7XG5cbiAgLy8gVGhpcyBoYXBwZW5zIGFmdGVyIHRoZSBtaXhpbmctaW4gYmVjYXVzZSB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIGBzdGF0ZWBcbiAgLy8gYWRkZWQgaW4gdGhhdCBzdGVwLlxuICB0YXJnZXQuc3RhdGUgPSBhc3NpZ24oe30sIHRhcmdldC5zdGF0ZSwgZGVmYXVsdFN0YXRlKTtcblxuICAvLyBBdXRvLWJpbmQgdGhlIGBoYW5kbGVTdGF0ZUNoYW5nZWRgIG1ldGhvZCBvZiB0aGUgdGFyZ2V0IG9iamVjdCBpZiBpdCBleGlzdHMuXG4gIGlmICh0eXBlb2YgdGFyZ2V0LmhhbmRsZVN0YXRlQ2hhbmdlZCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0V2ZW50ZWQodGFyZ2V0KSkge1xuICAgIHRhcmdldC5vbignc3RhdGVjaGFuZ2VkJywgdGFyZ2V0LmhhbmRsZVN0YXRlQ2hhbmdlZCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEBmaWxlIHRvLXRpdGxlLWNhc2UuanNcbiAqIEBtb2R1bGUgdG8tdGl0bGUtY2FzZVxuICovXG5cbi8qKlxuICogVXBwZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogICAgICAgIFN0cmluZyB0byBiZSB1cHBlcmNhc2VkXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgc3RyaW5nIHdpdGggYW4gdXBwZXJjYXNlZCBmaXJzdCBsZXR0ZXJcbiAqL1xuZnVuY3Rpb24gdG9UaXRsZUNhc2Uoc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHRoZSBUaXRsZUNhc2UgdmVyc2lvbnMgb2YgdGhlIHR3byBzdHJpbmdzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyMVxuICogICAgICAgIFRoZSBmaXJzdCBzdHJpbmcgdG8gY29tcGFyZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIyXG4gKiAgICAgICAgVGhlIHNlY29uZCBzdHJpbmcgdG8gY29tcGFyZVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgdGhlIFRpdGxlQ2FzZSB2ZXJzaW9ucyBvZiB0aGUgc3RyaW5ncyBhcmUgZXF1YWxcbiAqL1xuZnVuY3Rpb24gdGl0bGVDYXNlRXF1YWxzKHN0cjEsIHN0cjIpIHtcbiAgcmV0dXJuIHRvVGl0bGVDYXNlKHN0cjEpID09PSB0b1RpdGxlQ2FzZShzdHIyKTtcbn1cblxuLyoqXG4gKiBAZmlsZSBtZXJnZS1vcHRpb25zLmpzXG4gKiBAbW9kdWxlIG1lcmdlLW9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIERlZXAtbWVyZ2Ugb25lIG9yIG1vcmUgb3B0aW9ucyBvYmplY3RzLCByZWN1cnNpdmVseSBtZXJnaW5nICoqb25seSoqIHBsYWluXG4gKiBvYmplY3QgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0gICB7T2JqZWN0W119IHNvdXJjZXNcbiAqICAgICAgICAgIE9uZSBvciBtb3JlIG9iamVjdHMgdG8gbWVyZ2UgaW50byBhIG5ldyBvYmplY3QuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqICAgICAgICAgIEEgbmV3IG9iamVjdCB0aGF0IGlzIHRoZSBtZXJnZWQgcmVzdWx0IG9mIGFsbCBzb3VyY2VzLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMoKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNvdXJjZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWFjaChzb3VyY2UsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoIWlzUGxhaW4odmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1BsYWluKHJlc3VsdFtrZXldKSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IHt9O1xuICAgICAgfVxuXG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlT3B0aW9ucyhyZXN1bHRba2V5XSwgdmFsdWUpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFBsYXllciBDb21wb25lbnQgLSBCYXNlIGNsYXNzIGZvciBhbGwgVUkgb2JqZWN0c1xuICpcbiAqIEBmaWxlIGNvbXBvbmVudC5qc1xuICovXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIFVJIENvbXBvbmVudHMuXG4gKiBDb21wb25lbnRzIGFyZSBVSSBvYmplY3RzIHdoaWNoIHJlcHJlc2VudCBib3RoIGEgamF2YXNjcmlwdCBvYmplY3QgYW5kIGFuIGVsZW1lbnRcbiAqIGluIHRoZSBET00uIFRoZXkgY2FuIGJlIGNoaWxkcmVuIG9mIG90aGVyIGNvbXBvbmVudHMsIGFuZCBjYW4gaGF2ZVxuICogY2hpbGRyZW4gdGhlbXNlbHZlcy5cbiAqXG4gKiBDb21wb25lbnRzIGNhbiBhbHNvIHVzZSBtZXRob2RzIGZyb20ge0BsaW5rIEV2ZW50VGFyZ2V0fVxuICovXG5cbnZhciBDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWFkeS4gRG9lcyBub3QgaGF2ZSBhbnlcbiAgICogcGFyYW10ZXJzIGFuZCBhbnkgY2FsbGJhY2sgdmFsdWUgd2lsbCBiZSBpZ25vcmVkLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgQ29tcG9uZW50flJlYWR5Q2FsbGJhY2tcbiAgICogQHRoaXMgQ29tcG9uZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBbb3B0aW9ucy5jaGlsZHJlbl1cbiAgICogICAgICAgIEFuIGFycmF5IG9mIGNoaWxkcmVuIG9iamVjdHMgdG8gaW50aWFsaXplIHRoaXMgY29tcG9uZW50IHdpdGguIENoaWxkcmVuIG9iamVjdHMgaGF2ZVxuICAgKiAgICAgICAgYSBuYW1lIHByb3BlcnR5IHRoYXQgd2lsbCBiZSB1c2VkIGlmIG1vcmUgdGhhbiBvbmUgY29tcG9uZW50IG9mIHRoZSBzYW1lIHR5cGUgbmVlZHMgdG8gYmVcbiAgICogICAgICAgIGFkZGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBGdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIGBDb21wb25lbnRgIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gQ29tcG9uZW50KHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wb25lbnQpO1xuXG5cbiAgICAvLyBUaGUgY29tcG9uZW50IG1pZ2h0IGJlIHRoZSBwbGF5ZXIgaXRzZWxmIGFuZCB3ZSBjYW4ndCBwYXNzIGB0aGlzYCB0byBzdXBlclxuICAgIGlmICghcGxheWVyICYmIHRoaXMucGxheSkge1xuICAgICAgdGhpcy5wbGF5ZXJfID0gcGxheWVyID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsYXllcl8gPSBwbGF5ZXI7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBhIGNvcHkgb2YgcHJvdG90eXBlLm9wdGlvbnNfIHRvIHByb3RlY3QgYWdhaW5zdCBvdmVycmlkaW5nIGRlZmF1bHRzXG4gICAgdGhpcy5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyh7fSwgdGhpcy5vcHRpb25zXyk7XG5cbiAgICAvLyBVcGRhdGVkIG9wdGlvbnMgd2l0aCBzdXBwbGllZCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uc18gPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zXywgb3B0aW9ucyk7XG5cbiAgICAvLyBHZXQgSUQgZnJvbSBvcHRpb25zIG9yIG9wdGlvbnMgZWxlbWVudCBpZiBvbmUgaXMgc3VwcGxpZWRcbiAgICB0aGlzLmlkXyA9IG9wdGlvbnMuaWQgfHwgb3B0aW9ucy5lbCAmJiBvcHRpb25zLmVsLmlkO1xuXG4gICAgLy8gSWYgdGhlcmUgd2FzIG5vIElEIGZyb20gdGhlIG9wdGlvbnMsIGdlbmVyYXRlIG9uZVxuICAgIGlmICghdGhpcy5pZF8pIHtcbiAgICAgIC8vIERvbid0IHJlcXVpcmUgdGhlIHBsYXllciBJRCBmdW5jdGlvbiBpbiB0aGUgY2FzZSBvZiBtb2NrIHBsYXllcnNcbiAgICAgIHZhciBpZCA9IHBsYXllciAmJiBwbGF5ZXIuaWQgJiYgcGxheWVyLmlkKCkgfHwgJ25vX3BsYXllcic7XG5cbiAgICAgIHRoaXMuaWRfID0gaWQgKyAnX2NvbXBvbmVudF8nICsgbmV3R1VJRCgpO1xuICAgIH1cblxuICAgIHRoaXMubmFtZV8gPSBvcHRpb25zLm5hbWUgfHwgbnVsbDtcblxuICAgIC8vIENyZWF0ZSBlbGVtZW50IGlmIG9uZSB3YXNuJ3QgcHJvdmlkZWQgaW4gb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLmVsKSB7XG4gICAgICB0aGlzLmVsXyA9IG9wdGlvbnMuZWw7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmNyZWF0ZUVsICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5lbF8gPSB0aGlzLmNyZWF0ZUVsKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgZXZlbnRlZCBpcyBhbnl0aGluZyBleGNlcHQgZmFsc2UsIHdlIHdhbnQgdG8gbWl4aW4gaW4gZXZlbnRlZFxuICAgIGlmIChvcHRpb25zLmV2ZW50ZWQgIT09IGZhbHNlKSB7XG4gICAgICAvLyBNYWtlIHRoaXMgYW4gZXZlbnRlZCBvYmplY3QgYW5kIHVzZSBgZWxfYCwgaWYgYXZhaWxhYmxlLCBhcyBpdHMgZXZlbnQgYnVzXG4gICAgICBldmVudGVkKHRoaXMsIHsgZXZlbnRCdXNLZXk6IHRoaXMuZWxfID8gJ2VsXycgOiBudWxsIH0pO1xuICAgIH1cbiAgICBzdGF0ZWZ1bCh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRTdGF0ZSk7XG5cbiAgICB0aGlzLmNoaWxkcmVuXyA9IFtdO1xuICAgIHRoaXMuY2hpbGRJbmRleF8gPSB7fTtcbiAgICB0aGlzLmNoaWxkTmFtZUluZGV4XyA9IHt9O1xuXG4gICAgLy8gQWRkIGFueSBjaGlsZCBjb21wb25lbnRzIGluIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5pbml0Q2hpbGRyZW4gIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmluaXRDaGlsZHJlbigpO1xuICAgIH1cblxuICAgIHRoaXMucmVhZHkocmVhZHkpO1xuICAgIC8vIERvbid0IHdhbnQgdG8gdHJpZ2dlciByZWFkeSBoZXJlIG9yIGl0IHdpbGwgYmVmb3JlIGluaXQgaXMgYWN0dWFsbHlcbiAgICAvLyBmaW5pc2hlZCBmb3IgYWxsIGNoaWxkcmVuIHRoYXQgcnVuIHRoaXMgY29uc3RydWN0b3JcblxuICAgIGlmIChvcHRpb25zLnJlcG9ydFRvdWNoQWN0aXZpdHkgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmVuYWJsZVRvdWNoQWN0aXZpdHkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZSBvZiB0aGUgYENvbXBvbmVudGAgYW5kIGFsbCBjaGlsZCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAZmlyZXMgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSBgQ29tcG9uZW50YCBpcyBkaXNwb3NlZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBDb21wb25lbnQjZGlzcG9zZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdXG4gICAgICogICAgICAgICAgIHNldCB0byBmYWxzZSBzbyB0aGF0IHRoZSBjbG9zZSBldmVudCBkb2VzIG5vdFxuICAgICAqICAgICAgICAgICBidWJibGUgdXBcbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoeyB0eXBlOiAnZGlzcG9zZScsIGJ1YmJsZXM6IGZhbHNlIH0pO1xuXG4gICAgLy8gRGlzcG9zZSBhbGwgY2hpbGRyZW4uXG4gICAgaWYgKHRoaXMuY2hpbGRyZW5fKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5jaGlsZHJlbl8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fW2ldLmRpc3Bvc2UpIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuX1tpXS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWxldGUgY2hpbGQgcmVmZXJlbmNlc1xuICAgIHRoaXMuY2hpbGRyZW5fID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkSW5kZXhfID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkTmFtZUluZGV4XyA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5lbF8pIHtcbiAgICAgIC8vIFJlbW92ZSBlbGVtZW50IGZyb20gRE9NXG4gICAgICBpZiAodGhpcy5lbF8ucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmVsXy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWxfKTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlRGF0YSh0aGlzLmVsXyk7XG4gICAgICB0aGlzLmVsXyA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byB0aGUgcGxheWVyIGFmdGVyIGRpc3Bvc2luZyBvZiB0aGUgZWxlbWVudFxuICAgIHRoaXMucGxheWVyXyA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUge0BsaW5rIFBsYXllcn0gdGhhdCB0aGUgYENvbXBvbmVudGAgaGFzIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqICAgICAgICAgVGhlIHBsYXllciB0aGF0IHRoaXMgYENvbXBvbmVudGAgaGFzIGF0dGFjaGVkIHRvLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucGxheWVyID0gZnVuY3Rpb24gcGxheWVyKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXllcl87XG4gIH07XG5cbiAgLyoqXG4gICAqIERlZXAgbWVyZ2Ugb2Ygb3B0aW9ucyBvYmplY3RzIHdpdGggbmV3IG9wdGlvbnMuXG4gICAqID4gTm90ZTogV2hlbiBib3RoIGBvYmpgIGFuZCBgb3B0aW9uc2AgY29udGFpbiBwcm9wZXJ0aWVzIHdob3NlIHZhbHVlcyBhcmUgb2JqZWN0cy5cbiAgICogICAgICAgICBUaGUgdHdvIHByb3BlcnRpZXMgZ2V0IG1lcmdlZCB1c2luZyB7QGxpbmsgbW9kdWxlOm1lcmdlT3B0aW9uc31cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiAgICAgICAgVGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIG5ldyBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgQSBuZXcgb2JqZWN0IG9mIGB0aGlzLm9wdGlvbnNfYCBhbmQgYG9iamAgbWVyZ2VkIHRvZ2V0aGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDVcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbiBvcHRpb25zKG9iaikge1xuICAgIGxvZyQxLndhcm4oJ3RoaXMub3B0aW9ucygpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgbW92ZWQgdG8gdGhlIGNvbnN0cnVjdG9yIGluIDYuMCcpO1xuXG4gICAgaWYgKCFvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNfO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9uc18gPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zXywgb2JqKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBgQ29tcG9uZW50YHMgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgRE9NIGVsZW1lbnQgZm9yIHRoaXMgYENvbXBvbmVudGAuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5lbCA9IGZ1bmN0aW9uIGVsKCkge1xuICAgIHJldHVybiB0aGlzLmVsXztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFnTmFtZV1cbiAgICogICAgICAgIEVsZW1lbnQncyBET00gbm9kZSB0eXBlLiBlLmcuICdkaXYnXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgc2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsKHRhZ05hbWUsIHByb3BlcnRpZXMsIGF0dHJpYnV0ZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2NhbGl6ZSBhIHN0cmluZyBnaXZlbiB0aGUgc3RyaW5nIGluIGVuZ2xpc2guXG4gICAqXG4gICAqIElmIHRva2VucyBhcmUgcHJvdmlkZWQsIGl0J2xsIHRyeSBhbmQgcnVuIGEgc2ltcGxlIHRva2VuIHJlcGxhY2VtZW50IG9uIHRoZSBwcm92aWRlZCBzdHJpbmcuXG4gICAqIFRoZSB0b2tlbnMgaXQgbG9va3MgZm9yIGxvb2sgbGlrZSBgezF9YCB3aXRoIHRoZSBpbmRleCBiZWluZyAxLWluZGV4ZWQgaW50byB0aGUgdG9rZW5zIGFycmF5LlxuICAgKlxuICAgKiBJZiBhIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBpdCdsbCB1c2UgdGhhdCBvdmVyIGBzdHJpbmdgLFxuICAgKiBpZiBhIHZhbHVlIGlzbid0IGZvdW5kIGluIHByb3ZpZGVkIGxhbmd1YWdlIGZpbGVzLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBoYXZlIGEgZGVzY3JpcHRpdmUga2V5IGZvciB0b2tlbiByZXBsYWNlbWVudFxuICAgKiBidXQgaGF2ZSBhIHN1Y2NpbmN0IGxvY2FsaXplZCBzdHJpbmcgYW5kIG5vdCByZXF1aXJlIGBlbi5qc29uYCB0byBiZSBpbmNsdWRlZC5cbiAgICpcbiAgICogQ3VycmVudGx5LCBpdCBpcyB1c2VkIGZvciB0aGUgcHJvZ3Jlc3MgYmFyIHRpbWluZy5cbiAgICogYGBganNcbiAgICoge1xuICAgKiAgIFwicHJvZ3Jlc3MgYmFyIHRpbWluZzogY3VycmVudFRpbWU9ezF9IGR1cmF0aW9uPXsyfVwiOiBcInsxfSBvZiB7Mn1cIlxuICAgKiB9XG4gICAqIGBgYFxuICAgKiBJdCBpcyB0aGVuIHVzZWQgbGlrZSBzbzpcbiAgICogYGBganNcbiAgICogdGhpcy5sb2NhbGl6ZSgncHJvZ3Jlc3MgYmFyIHRpbWluZzogY3VycmVudFRpbWU9ezF9IGR1cmF0aW9uezJ9JyxcbiAgICogICAgICAgICAgICAgICBbdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCksIHRoaXMucGxheWVyXy5kdXJhdGlvbigpXSxcbiAgICogICAgICAgICAgICAgICAnezF9IG9mIHsyfScpO1xuICAgKiBgYGBcbiAgICpcbiAgICogV2hpY2ggb3V0cHV0cyBzb21ldGhpbmcgbGlrZTogYDAxOjIzIG9mIDI0OjU2YC5cbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiAgICAgICAgVGhlIHN0cmluZyB0byBsb2NhbGl6ZSBhbmQgdGhlIGtleSB0byBsb29rdXAgaW4gdGhlIGxhbmd1YWdlIGZpbGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbdG9rZW5zXVxuICAgKiAgICAgICAgSWYgdGhlIGN1cnJlbnQgaXRlbSBoYXMgdG9rZW4gcmVwbGFjZW1lbnRzLCBwcm92aWRlIHRoZSB0b2tlbnMgaGVyZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0VmFsdWVdXG4gICAqICAgICAgICBEZWZhdWx0cyB0byBgc3RyaW5nYC4gQ2FuIGJlIGEgZGVmYXVsdCB2YWx1ZSB0byB1c2UgZm9yIHRva2VuIHJlcGxhY2VtZW50XG4gICAqICAgICAgICBpZiB0aGUgbG9va3VwIGtleSBpcyBuZWVkZWQgdG8gYmUgc2VwYXJhdGUuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgbG9jYWxpemVkIHN0cmluZyBvciBpZiBubyBsb2NhbGl6YXRpb24gZXhpc3RzIHRoZSBlbmdsaXNoIHN0cmluZy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmxvY2FsaXplID0gZnVuY3Rpb24gbG9jYWxpemUoc3RyaW5nLCB0b2tlbnMpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBzdHJpbmc7XG5cbiAgICB2YXIgY29kZSA9IHRoaXMucGxheWVyXy5sYW5ndWFnZSAmJiB0aGlzLnBsYXllcl8ubGFuZ3VhZ2UoKTtcbiAgICB2YXIgbGFuZ3VhZ2VzID0gdGhpcy5wbGF5ZXJfLmxhbmd1YWdlcyAmJiB0aGlzLnBsYXllcl8ubGFuZ3VhZ2VzKCk7XG4gICAgdmFyIGxhbmd1YWdlID0gbGFuZ3VhZ2VzICYmIGxhbmd1YWdlc1tjb2RlXTtcbiAgICB2YXIgcHJpbWFyeUNvZGUgPSBjb2RlICYmIGNvZGUuc3BsaXQoJy0nKVswXTtcbiAgICB2YXIgcHJpbWFyeUxhbmcgPSBsYW5ndWFnZXMgJiYgbGFuZ3VhZ2VzW3ByaW1hcnlDb2RlXTtcblxuICAgIHZhciBsb2NhbGl6ZWRTdHJpbmcgPSBkZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAobGFuZ3VhZ2UgJiYgbGFuZ3VhZ2Vbc3RyaW5nXSkge1xuICAgICAgbG9jYWxpemVkU3RyaW5nID0gbGFuZ3VhZ2Vbc3RyaW5nXTtcbiAgICB9IGVsc2UgaWYgKHByaW1hcnlMYW5nICYmIHByaW1hcnlMYW5nW3N0cmluZ10pIHtcbiAgICAgIGxvY2FsaXplZFN0cmluZyA9IHByaW1hcnlMYW5nW3N0cmluZ107XG4gICAgfVxuXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgbG9jYWxpemVkU3RyaW5nID0gbG9jYWxpemVkU3RyaW5nLnJlcGxhY2UoL1xceyhcXGQrKVxcfS9nLCBmdW5jdGlvbiAobWF0Y2gsIGluZGV4KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRva2Vuc1tpbmRleCAtIDFdO1xuICAgICAgICB2YXIgcmV0ID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXQgPSBtYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYWxpemVkU3RyaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGBDb21wb25lbnRgcyBET00gZWxlbWVudC4gVGhpcyBpcyB3aGVyZSBjaGlsZHJlbiBnZXQgaW5zZXJ0ZWQuXG4gICAqIFRoaXMgd2lsbCB1c3VhbGx5IGJlIHRoZSB0aGUgc2FtZSBhcyB0aGUgZWxlbWVudCByZXR1cm5lZCBpbiB7QGxpbmsgQ29tcG9uZW50I2VsfS5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgY29udGVudCBlbGVtZW50IGZvciB0aGlzIGBDb21wb25lbnRgLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY29udGVudEVsID0gZnVuY3Rpb24gY29udGVudEVsKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRFbF8gfHwgdGhpcy5lbF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGlzIGBDb21wb25lbnRgcyBJRFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGlkIG9mIHRoaXMgYENvbXBvbmVudGBcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGBDb21wb25lbnRgcyBuYW1lLiBUaGUgbmFtZSBnZXRzIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSBgQ29tcG9uZW50YFxuICAgKiBhbmQgaXMgc2V0IGR1cmluZyByZWdpc3RyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgbmFtZSBvZiB0aGlzIGBDb21wb25lbnRgLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhcnJheSBvZiBhbGwgY2hpbGQgY29tcG9uZW50c1xuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogICAgICAgICBUaGUgY2hpbGRyZW5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24gY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBgQ29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBgaWRgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICogICAgICAgIFRoZSBpZCBvZiB0aGUgY2hpbGQgYENvbXBvbmVudGAgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFRoZSBjaGlsZCBgQ29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBgaWRgIG9yIHVuZGVmaW5lZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmdldENoaWxkQnlJZCA9IGZ1bmN0aW9uIGdldENoaWxkQnlJZChpZCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkSW5kZXhfW2lkXTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2hpbGQgYENvbXBvbmVudGAgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGNoaWxkIGBDb21wb25lbnRgIHRvIGdldC5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fHVuZGVmaW5lZH1cbiAgICogICAgICAgICBUaGUgY2hpbGQgYENvbXBvbmVudGAgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgIG9yIHVuZGVmaW5lZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gZ2V0Q2hpbGQobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5hbWUgPSB0b1RpdGxlQ2FzZShuYW1lKTtcblxuICAgIHJldHVybiB0aGlzLmNoaWxkTmFtZUluZGV4X1tuYW1lXTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2hpbGQgYENvbXBvbmVudGAgaW5zaWRlIHRoZSBjdXJyZW50IGBDb21wb25lbnRgLlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xDb21wb25lbnR9IGNoaWxkXG4gICAqICAgICAgICBUaGUgbmFtZSBvciBpbnN0YW5jZSBvZiBhIGNoaWxkIHRvIGFkZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBvcHRpb25zIHRoYXQgd2lsbCBnZXQgcGFzc2VkIHRvIGNoaWxkcmVuIG9mXG4gICAqICAgICAgICB0aGUgY2hpbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9dGhpcy5jaGlsZHJlbl8ubGVuZ3RoXVxuICAgKiAgICAgICAgVGhlIGluZGV4IHRvIGF0dGVtcHQgdG8gYWRkIGEgY2hpbGQgaW50by5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiAgICAgICAgIFRoZSBgQ29tcG9uZW50YCB0aGF0IGdldHMgYWRkZWQgYXMgYSBjaGlsZC4gV2hlbiB1c2luZyBhIHN0cmluZyB0aGVcbiAgICogICAgICAgICBgQ29tcG9uZW50YCB3aWxsIGdldCBjcmVhdGVkIGJ5IHRoaXMgcHJvY2Vzcy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmNoaWxkcmVuXy5sZW5ndGg7XG5cbiAgICB2YXIgY29tcG9uZW50ID0gdm9pZCAwO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gdm9pZCAwO1xuXG4gICAgLy8gSWYgY2hpbGQgaXMgYSBzdHJpbmcsIGNyZWF0ZSBjb21wb25lbnQgd2l0aCBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0b1RpdGxlQ2FzZShjaGlsZCk7XG5cbiAgICAgIHZhciBjb21wb25lbnRDbGFzc05hbWUgPSBvcHRpb25zLmNvbXBvbmVudENsYXNzIHx8IGNvbXBvbmVudE5hbWU7XG5cbiAgICAgIC8vIFNldCBuYW1lIHRocm91Z2ggb3B0aW9uc1xuICAgICAgb3B0aW9ucy5uYW1lID0gY29tcG9uZW50TmFtZTtcblxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCAmIGVsZW1lbnQgZm9yIHRoaXMgY29udHJvbHMgc2V0XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIC5wbGF5ZXJfLCB0aGlzIGlzIGEgcGxheWVyXG4gICAgICB2YXIgQ29tcG9uZW50Q2xhc3MgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KGNvbXBvbmVudENsYXNzTmFtZSk7XG5cbiAgICAgIGlmICghQ29tcG9uZW50Q2xhc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnQgJyArIGNvbXBvbmVudENsYXNzTmFtZSArICcgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgIH1cblxuICAgICAgLy8gZGF0YSBzdG9yZWQgZGlyZWN0bHkgb24gdGhlIHZpZGVvanMgb2JqZWN0IG1heSBiZVxuICAgICAgLy8gbWlzaWRlbnRpZmllZCBhcyBhIGNvbXBvbmVudCB0byByZXRhaW5cbiAgICAgIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdpdGggNC54LiBjaGVjayB0byBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb21wb25lbnQgY2xhc3MgY2FuIGJlIGluc3RhbnRpYXRlZC5cbiAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnRDbGFzcyh0aGlzLnBsYXllcl8gfHwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIGNoaWxkIGlzIGEgY29tcG9uZW50IGluc3RhbmNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudCA9IGNoaWxkO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRyZW5fLnNwbGljZShpbmRleCwgMCwgY29tcG9uZW50KTtcblxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50LmlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNoaWxkSW5kZXhfW2NvbXBvbmVudC5pZCgpXSA9IGNvbXBvbmVudDtcbiAgICB9XG5cbiAgICAvLyBJZiBhIG5hbWUgd2Fzbid0IHVzZWQgdG8gY3JlYXRlIHRoZSBjb21wb25lbnQsIGNoZWNrIGlmIHdlIGNhbiB1c2UgdGhlXG4gICAgLy8gbmFtZSBmdW5jdGlvbiBvZiB0aGUgY29tcG9uZW50XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgY29tcG9uZW50Lm5hbWUgJiYgdG9UaXRsZUNhc2UoY29tcG9uZW50Lm5hbWUoKSk7XG5cbiAgICBpZiAoY29tcG9uZW50TmFtZSkge1xuICAgICAgdGhpcy5jaGlsZE5hbWVJbmRleF9bY29tcG9uZW50TmFtZV0gPSBjb21wb25lbnQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBVSSBvYmplY3QncyBlbGVtZW50IHRvIHRoZSBjb250YWluZXIgZGl2IChib3gpXG4gICAgLy8gSGF2aW5nIGFuIGVsZW1lbnQgaXMgbm90IHJlcXVpcmVkXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQuZWwgPT09ICdmdW5jdGlvbicgJiYgY29tcG9uZW50LmVsKCkpIHtcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5jb250ZW50RWwoKS5jaGlsZHJlbjtcbiAgICAgIHZhciByZWZOb2RlID0gY2hpbGROb2Rlc1tpbmRleF0gfHwgbnVsbDtcblxuICAgICAgdGhpcy5jb250ZW50RWwoKS5pbnNlcnRCZWZvcmUoY29tcG9uZW50LmVsKCksIHJlZk5vZGUpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBzbyBpdCBjYW4gc3RvcmVkIG9uIHBhcmVudCBvYmplY3QgaWYgZGVzaXJlZC5cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjaGlsZCBgQ29tcG9uZW50YCBmcm9tIHRoaXMgYENvbXBvbmVudGBzIGxpc3Qgb2YgY2hpbGRyZW4uIEFsc28gcmVtb3Zlc1xuICAgKiB0aGUgY2hpbGQgYENvbXBvbmVudGBzIGVsZW1lbnQgZnJvbSB0aGlzIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50XG4gICAqICAgICAgICBUaGUgY2hpbGQgYENvbXBvbmVudGAgdG8gcmVtb3ZlLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZChjb21wb25lbnQpIHtcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbXBvbmVudCA9IHRoaXMuZ2V0Q2hpbGQoY29tcG9uZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhdGhpcy5jaGlsZHJlbl8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRGb3VuZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuY2hpbGRyZW5fLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbl9baV0gPT09IGNvbXBvbmVudCkge1xuICAgICAgICBjaGlsZEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbl8uc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkRm91bmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNoaWxkSW5kZXhfW2NvbXBvbmVudC5pZCgpXSA9IG51bGw7XG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF9bY29tcG9uZW50Lm5hbWUoKV0gPSBudWxsO1xuXG4gICAgdmFyIGNvbXBFbCA9IGNvbXBvbmVudC5lbCgpO1xuXG4gICAgaWYgKGNvbXBFbCAmJiBjb21wRWwucGFyZW50Tm9kZSA9PT0gdGhpcy5jb250ZW50RWwoKSkge1xuICAgICAgdGhpcy5jb250ZW50RWwoKS5yZW1vdmVDaGlsZChjb21wb25lbnQuZWwoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYW5kIGluaXRpYWxpemUgZGVmYXVsdCBjaGlsZCBgQ29tcG9uZW50YHMgYmFzZWQgdXBvbiBvcHRpb25zLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaW5pdENoaWxkcmVuID0gZnVuY3Rpb24gaW5pdENoaWxkcmVuKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm9wdGlvbnNfLmNoaWxkcmVuO1xuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAvLyBgdGhpc2AgaXMgYHBhcmVudGBcbiAgICAgIHZhciBwYXJlbnRPcHRpb25zID0gdGhpcy5vcHRpb25zXztcblxuICAgICAgdmFyIGhhbmRsZUFkZCA9IGZ1bmN0aW9uIGhhbmRsZUFkZChjaGlsZCkge1xuICAgICAgICB2YXIgbmFtZSA9IGNoaWxkLm5hbWU7XG4gICAgICAgIHZhciBvcHRzID0gY2hpbGQub3B0cztcblxuICAgICAgICAvLyBBbGxvdyBvcHRpb25zIGZvciBjaGlsZHJlbiB0byBiZSBzZXQgYXQgdGhlIHBhcmVudCBvcHRpb25zXG4gICAgICAgIC8vIGUuZy4gdmlkZW9qcyhpZCwgeyBjb250cm9sQmFyOiBmYWxzZSB9KTtcbiAgICAgICAgLy8gaW5zdGVhZCBvZiB2aWRlb2pzKGlkLCB7IGNoaWxkcmVuOiB7IGNvbnRyb2xCYXI6IGZhbHNlIH0pO1xuICAgICAgICBpZiAocGFyZW50T3B0aW9uc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0cyA9IHBhcmVudE9wdGlvbnNbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvdyBmb3IgZGlzYWJsaW5nIGRlZmF1bHQgY29tcG9uZW50c1xuICAgICAgICAvLyBlLmcuIG9wdGlvbnNbJ2NoaWxkcmVuJ11bJ3Bvc3RlckltYWdlJ10gPSBmYWxzZVxuICAgICAgICBpZiAob3B0cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvdyBvcHRpb25zIHRvIGJlIHBhc3NlZCBhcyBhIHNpbXBsZSBib29sZWFuIGlmIG5vIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgLy8gaXMgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAob3B0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGFsc28gd2FudCB0byBwYXNzIHRoZSBvcmlnaW5hbCBwbGF5ZXIgb3B0aW9uc1xuICAgICAgICAvLyB0byBlYWNoIGNvbXBvbmVudCBhcyB3ZWxsIHNvIHRoZXkgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAvLyByZWFjaCBiYWNrIGludG8gdGhlIHBsYXllciBmb3Igb3B0aW9ucyBsYXRlci5cbiAgICAgICAgb3B0cy5wbGF5ZXJPcHRpb25zID0gX3RoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucztcblxuICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCB0aGUgY2hpbGQgY29tcG9uZW50LlxuICAgICAgICAvLyBBZGQgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBjaGlsZCBieSBuYW1lIG9uIHRoZSBwYXJlbnQgaW5zdGFuY2UuXG4gICAgICAgIC8vIElmIHR3byBvZiB0aGUgc2FtZSBjb21wb25lbnQgYXJlIHVzZWQsIGRpZmZlcmVudCBuYW1lcyBzaG91bGQgYmUgc3VwcGxpZWRcbiAgICAgICAgLy8gZm9yIGVhY2hcbiAgICAgICAgdmFyIG5ld0NoaWxkID0gX3RoaXMuYWRkQ2hpbGQobmFtZSwgb3B0cyk7XG5cbiAgICAgICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICAgICAgX3RoaXNbbmFtZV0gPSBuZXdDaGlsZDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gQWxsb3cgZm9yIGFuIGFycmF5IG9mIGNoaWxkcmVuIGRldGFpbHMgdG8gcGFzc2VkIGluIHRoZSBvcHRpb25zXG4gICAgICB2YXIgd29ya2luZ0NoaWxkcmVuID0gdm9pZCAwO1xuICAgICAgdmFyIFRlY2ggPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdUZWNoJyk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICB3b3JraW5nQ2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmtpbmdDaGlsZHJlbiA9IE9iamVjdC5rZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgd29ya2luZ0NoaWxkcmVuXG4gICAgICAvLyBjaGlsZHJlbiB0aGF0IGFyZSBpbiB0aGlzLm9wdGlvbnNfIGJ1dCBhbHNvIGluIHdvcmtpbmdDaGlsZHJlbiAgd291bGRcbiAgICAgIC8vIGdpdmUgdXMgZXh0cmEgY2hpbGRyZW4gd2UgZG8gbm90IHdhbnQuIFNvLCB3ZSB3YW50IHRvIGZpbHRlciB0aGVtIG91dC5cbiAgICAgIC5jb25jYXQoT2JqZWN0LmtleXModGhpcy5vcHRpb25zXykuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gIXdvcmtpbmdDaGlsZHJlbi5zb21lKGZ1bmN0aW9uICh3Y2hpbGQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gd2NoaWxkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2hpbGQgPT09IHdjaGlsZC5uYW1lO1xuICAgICAgICB9KTtcbiAgICAgIH0pKS5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciBuYW1lID0gdm9pZCAwO1xuICAgICAgICB2YXIgb3B0cyA9IHZvaWQgMDtcblxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG5hbWUgPSBjaGlsZDtcbiAgICAgICAgICBvcHRzID0gY2hpbGRyZW5bbmFtZV0gfHwgX3RoaXMub3B0aW9uc19bbmFtZV0gfHwge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IGNoaWxkLm5hbWU7XG4gICAgICAgICAgb3B0cyA9IGNoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgb3B0czogb3B0cyB9O1xuICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAvLyB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IGNoaWxkLm5hbWUgaXNuJ3QgaW4gdGhlIHRlY2hPcmRlciBzaW5jZVxuICAgICAgICAvLyB0ZWNocyBhcmUgcmVnaXN0ZXJkIGFzIENvbXBvbmVudHMgYnV0IGNhbid0IGFyZW4ndCBjb21wYXRpYmxlXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMjc3MlxuICAgICAgICB2YXIgYyA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoY2hpbGQub3B0cy5jb21wb25lbnRDbGFzcyB8fCB0b1RpdGxlQ2FzZShjaGlsZC5uYW1lKSk7XG5cbiAgICAgICAgcmV0dXJuIGMgJiYgIVRlY2guaXNUZWNoKGMpO1xuICAgICAgfSkuZm9yRWFjaChoYW5kbGVBZGQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBjbGFzcyBuYW1lLiBTaG91bGQgYmUgb3ZlcnJpZGVuIGJ5IHN1Yi1jb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBjbGFzcyBuYW1lIGZvciB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICAvLyBDaGlsZCBjbGFzc2VzIGNhbiBpbmNsdWRlIGEgZnVuY3Rpb24gdGhhdCBkb2VzOlxuICAgIC8vIHJldHVybiAnQ0xBU1MgTkFNRScgKyB0aGlzLl9zdXBlcigpO1xuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQmluZCBhIGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByZWFkeSBzdGF0ZS5cbiAgICogRGlmZmVyZW50IGZyb20gZXZlbnQgbGlzdGVuZXJzIGluIHRoYXQgaWYgdGhlIHJlYWR5IGV2ZW50IGhhcyBhbHJlYWR5IGhhcHBlbmVkXG4gICAqIGl0IHdpbGwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gaW1tZWRpYXRlbHkuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogICAgICAgICBSZXR1cm5zIGl0c2VsZjsgbWV0aG9kIGNhbiBiZSBjaGFpbmVkLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiByZWFkeShmbikge1xuICAgIHZhciBzeW5jID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIGlmICghZm4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNSZWFkeV8pIHtcbiAgICAgIHRoaXMucmVhZHlRdWV1ZV8gPSB0aGlzLnJlYWR5UXVldWVfIHx8IFtdO1xuICAgICAgdGhpcy5yZWFkeVF1ZXVlXy5wdXNoKGZuKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgZm4uY2FsbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FsbCB0aGUgZnVuY3Rpb24gYXN5bmNocm9ub3VzbHkgYnkgZGVmYXVsdCBmb3IgY29uc2lzdGVuY3lcbiAgICAgIHRoaXMuc2V0VGltZW91dChmbiwgMSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFsbCB0aGUgcmVhZHkgbGlzdGVuZXJzIGZvciB0aGlzIGBDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmlyZXMgQ29tcG9uZW50I3JlYWR5XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyUmVhZHkgPSBmdW5jdGlvbiB0cmlnZ2VyUmVhZHkoKSB7XG4gICAgdGhpcy5pc1JlYWR5XyA9IHRydWU7XG5cbiAgICAvLyBFbnN1cmUgcmVhZHkgaXMgdHJpZ2dlcmVkIGFzeW5jaHJvbm91c2x5XG4gICAgdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZWFkeVF1ZXVlID0gdGhpcy5yZWFkeVF1ZXVlXztcblxuICAgICAgLy8gUmVzZXQgUmVhZHkgUXVldWVcbiAgICAgIHRoaXMucmVhZHlRdWV1ZV8gPSBbXTtcblxuICAgICAgaWYgKHJlYWR5UXVldWUgJiYgcmVhZHlRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlYWR5UXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICBmbi5jYWxsKHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgZm9yIHVzaW5nIGV2ZW50IGxpc3RlbmVycyBhbHNvXG4gICAgICAvKipcbiAgICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgYENvbXBvbmVudGAgaXMgcmVhZHkuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IENvbXBvbmVudCNyZWFkeVxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ3JlYWR5Jyk7XG4gICAgfSwgMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgYSBzaW5nbGUgRE9NIGVsZW1lbnQgbWF0Y2hpbmcgYSBgc2VsZWN0b3JgLiBUaGlzIGNhbiBiZSB3aXRoaW4gdGhlIGBDb21wb25lbnRgc1xuICAgKiBgY29udGVudEVsKClgIG9yIGFub3RoZXIgY3VzdG9tIGNvbnRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICAgKiAgICAgICAgQSB2YWxpZCBDU1Mgc2VsZWN0b3IsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGBxdWVyeVNlbGVjdG9yYC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gW2NvbnRleHQ9dGhpcy5jb250ZW50RWwoKV1cbiAgICogICAgICAgIEEgRE9NIGVsZW1lbnQgd2l0aGluIHdoaWNoIHRvIHF1ZXJ5LiBDYW4gYWxzbyBiZSBhIHNlbGVjdG9yIHN0cmluZyBpblxuICAgKiAgICAgICAgd2hpY2ggY2FzZSB0aGUgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudCB3aWxsIGdldCB1c2VkIGFzIGNvbnRleHQuIElmXG4gICAqICAgICAgICBtaXNzaW5nIGB0aGlzLmNvbnRlbnRFbCgpYCBnZXRzIHVzZWQuIElmICBgdGhpcy5jb250ZW50RWwoKWAgcmV0dXJuc1xuICAgKiAgICAgICAgbm90aGluZyBpdCBmYWxscyBiYWNrIHRvIGBkb2N1bWVudGAuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR8bnVsbH1cbiAgICogICAgICAgICB0aGUgZG9tIGVsZW1lbnQgdGhhdCB3YXMgZm91bmQsIG9yIG51bGxcbiAgICpcbiAgICogQHNlZSBbSW5mb3JtYXRpb24gb24gQ1NTIFNlbGVjdG9yc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvQ1NTL0dldHRpbmdfU3RhcnRlZC9TZWxlY3RvcnMpXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS4kID0gZnVuY3Rpb24gJCQkMShzZWxlY3RvciwgY29udGV4dCkge1xuICAgIHJldHVybiAkKHNlbGVjdG9yLCBjb250ZXh0IHx8IHRoaXMuY29udGVudEVsKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgRE9NIGVsZW1lbnQgbWF0Y2hpbmcgYSBgc2VsZWN0b3JgLiBUaGlzIGNhbiBiZSB3aXRoaW4gdGhlIGBDb21wb25lbnRgc1xuICAgKiBgY29udGVudEVsKClgIG9yIGFub3RoZXIgY3VzdG9tIGNvbnRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICAgKiAgICAgICAgQSB2YWxpZCBDU1Mgc2VsZWN0b3IsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGBxdWVyeVNlbGVjdG9yQWxsYC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gW2NvbnRleHQ9dGhpcy5jb250ZW50RWwoKV1cbiAgICogICAgICAgIEEgRE9NIGVsZW1lbnQgd2l0aGluIHdoaWNoIHRvIHF1ZXJ5LiBDYW4gYWxzbyBiZSBhIHNlbGVjdG9yIHN0cmluZyBpblxuICAgKiAgICAgICAgd2hpY2ggY2FzZSB0aGUgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudCB3aWxsIGdldCB1c2VkIGFzIGNvbnRleHQuIElmXG4gICAqICAgICAgICBtaXNzaW5nIGB0aGlzLmNvbnRlbnRFbCgpYCBnZXRzIHVzZWQuIElmICBgdGhpcy5jb250ZW50RWwoKWAgcmV0dXJuc1xuICAgKiAgICAgICAgbm90aGluZyBpdCBmYWxscyBiYWNrIHRvIGBkb2N1bWVudGAuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGVMaXN0fVxuICAgKiAgICAgICAgIGEgbGlzdCBvZiBkb20gZWxlbWVudHMgdGhhdCB3ZXJlIGZvdW5kXG4gICAqXG4gICAqIEBzZWUgW0luZm9ybWF0aW9uIG9uIENTUyBTZWxlY3RvcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0NTUy9HZXR0aW5nX1N0YXJ0ZWQvU2VsZWN0b3JzKVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuJCQgPSBmdW5jdGlvbiAkJCQkMShzZWxlY3RvciwgY29udGV4dCkge1xuICAgIHJldHVybiAkJChzZWxlY3RvciwgY29udGV4dCB8fCB0aGlzLmNvbnRlbnRFbCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBjb21wb25lbnQncyBlbGVtZW50IGhhcyBhIENTUyBjbGFzcyBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb0NoZWNrXG4gICAqICAgICAgICBDU1MgY2xhc3MgbmFtZSB0byBjaGVjay5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIFRydWUgaWYgdGhlIGBDb21wb25lbnRgIGhhcyB0aGUgY2xhc3MuXG4gICAqICAgICAgICAgLSBGYWxzZSBpZiB0aGUgYENvbXBvbmVudGAgZG9lcyBub3QgaGF2ZSB0aGUgY2xhc3NgXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzJCQxKGNsYXNzVG9DaGVjaykge1xuICAgIHJldHVybiBoYXNDbGFzcyh0aGlzLmVsXywgY2xhc3NUb0NoZWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgQ1NTIGNsYXNzIG5hbWUgdG8gdGhlIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb0FkZFxuICAgKiAgICAgICAgQ1NTIGNsYXNzIG5hbWUgdG8gYWRkXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzJCQxKGNsYXNzVG9BZGQpIHtcbiAgICBhZGRDbGFzcyh0aGlzLmVsXywgY2xhc3NUb0FkZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gdGhlIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb1JlbW92ZVxuICAgKiAgICAgICAgQ1NTIGNsYXNzIG5hbWUgdG8gcmVtb3ZlXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzJCQxKGNsYXNzVG9SZW1vdmUpIHtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsXywgY2xhc3NUb1JlbW92ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBvciByZW1vdmUgYSBDU1MgY2xhc3MgbmFtZSBmcm9tIHRoZSBjb21wb25lbnQncyBlbGVtZW50LlxuICAgKiAtIGBjbGFzc1RvVG9nZ2xlYCBnZXRzIGFkZGVkIHdoZW4ge0BsaW5rIENvbXBvbmVudCNoYXNDbGFzc30gd291bGQgcmV0dXJuIGZhbHNlLlxuICAgKiAtIGBjbGFzc1RvVG9nZ2xlYCBnZXRzIHJlbW92ZWQgd2hlbiB7QGxpbmsgQ29tcG9uZW50I2hhc0NsYXNzfSB3b3VsZCByZXR1cm4gdHJ1ZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBjbGFzc1RvVG9nZ2xlXG4gICAqICAgICAgICAgVGhlIGNsYXNzIHRvIGFkZCBvciByZW1vdmUgYmFzZWQgb24gKEBsaW5rIENvbXBvbmVudCNoYXNDbGFzc31cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbnxEb21+cHJlZGljYXRlfSBbcHJlZGljYXRlXVxuICAgKiAgICAgICAgIEFuIHtAbGluayBEb21+cHJlZGljYXRlfSBmdW5jdGlvbiBvciBhIGJvb2xlYW5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnRvZ2dsZUNsYXNzID0gZnVuY3Rpb24gdG9nZ2xlQ2xhc3MkJDEoY2xhc3NUb1RvZ2dsZSwgcHJlZGljYXRlKSB7XG4gICAgdG9nZ2xlQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9Ub2dnbGUsIHByZWRpY2F0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGBDb21wb25lbnRgcyBlbGVtZW50IGlmIGl0IGlzIGhpZGRlbiBieSByZW1vdmluZyB0aGVcbiAgICogJ3Zqcy1oaWRkZW4nIGNsYXNzIG5hbWUgZnJvbSBpdC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogSGlkZSB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQgaWYgaXQgaXMgY3VycmVudGx5IHNob3dpbmcgYnkgYWRkaW5nIHRoZVxuICAgKiAndmpzLWhpZGRlbmAgY2xhc3MgbmFtZSB0byBpdC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9jayBhIGBDb21wb25lbnRgcyBlbGVtZW50IGluIGl0cyB2aXNpYmxlIHN0YXRlIGJ5IGFkZGluZyB0aGUgJ3Zqcy1sb2NrLXNob3dpbmcnXG4gICAqIGNsYXNzIG5hbWUgdG8gaXQuIFVzZWQgZHVyaW5nIGZhZGVJbi9mYWRlT3V0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUubG9ja1Nob3dpbmcgPSBmdW5jdGlvbiBsb2NrU2hvd2luZygpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtbG9jay1zaG93aW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVubG9jayBhIGBDb21wb25lbnRgcyBlbGVtZW50IGZyb20gaXRzIHZpc2libGUgc3RhdGUgYnkgcmVtb3ZpbmcgdGhlICd2anMtbG9jay1zaG93aW5nJ1xuICAgKiBjbGFzcyBuYW1lIGZyb20gaXQuIFVzZWQgZHVyaW5nIGZhZGVJbi9mYWRlT3V0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUudW5sb2NrU2hvd2luZyA9IGZ1bmN0aW9uIHVubG9ja1Nob3dpbmcoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWxvY2stc2hvd2luZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAgICogICAgICAgIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBnZXQgdGhlIHZhbHVlIGZyb20uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICAgKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgdGhhdCB3YXMgYXNrZWQgZm9yLlxuICAgKiAgICAgICAgIC0gQ2FuIGJlIGFuIGVtcHR5IHN0cmluZyBvbiBzb21lIGJyb3dzZXJzIGlmIHRoZSBhdHRyaWJ1dGUgZG9lcyBub3QgZXhpc3RcbiAgICogICAgICAgICAgIG9yIGhhcyBubyB2YWx1ZVxuICAgKiAgICAgICAgIC0gTW9zdCBicm93c2VycyB3aWxsIHJldHVybiBudWxsIGlmIHRoZSBhdHRpYnV0ZSBkb2VzIG5vdCBleGlzdCBvciBoYXNcbiAgICogICAgICAgICAgIG5vIHZhbHVlLlxuICAgKlxuICAgKiBAc2VlIFtET00gQVBJXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRBdHRyaWJ1dGV9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUkJDEoYXR0cmlidXRlKSB7XG4gICAgcmV0dXJuIGdldEF0dHJpYnV0ZSh0aGlzLmVsXywgYXR0cmlidXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gdGhlIGBDb21wb25lbnRgJ3MgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gICAqICAgICAgICBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIFZhbHVlIHRvIHNldCB0aGUgYXR0cmlidXRlIHRvLlxuICAgKlxuICAgKiBAc2VlIFtET00gQVBJXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9zZXRBdHRyaWJ1dGV9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUkJDEoYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIHNldEF0dHJpYnV0ZSh0aGlzLmVsXywgYXR0cmlidXRlLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAgICogICAgICAgIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byByZW1vdmUuXG4gICAqXG4gICAqIEBzZWUgW0RPTSBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L3JlbW92ZUF0dHJpYnV0ZX1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZSQkMShhdHRyaWJ1dGUpIHtcbiAgICByZW1vdmVBdHRyaWJ1dGUodGhpcy5lbF8sIGF0dHJpYnV0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIHdpZHRoIG9mIHRoZSBjb21wb25lbnQgYmFzZWQgdXBvbiB0aGUgQ1NTIHN0eWxlcy5cbiAgICogU2VlIHtAbGluayBDb21wb25lbnQjZGltZW5zaW9ufSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbbnVtXVxuICAgKiAgICAgICAgVGhlIHdpZHRoIHRoYXQgeW91IHdhbnQgdG8gc2V0IHBvc3RmaXhlZCB3aXRoICclJywgJ3B4JyBvciBub3RoaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwTGlzdGVuZXJzXVxuICAgKiAgICAgICAgU2tpcCB0aGUgY29tcG9uZW50cmVzaXplIGV2ZW50IHRyaWdnZXJcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ31cbiAgICogICAgICAgICBUaGUgd2lkdGggd2hlbiBnZXR0aW5nLCB6ZXJvIGlmIHRoZXJlIGlzIG5vIHdpZHRoLiBDYW4gYmUgYSBzdHJpbmdcbiAgICogICAgICAgICAgIHBvc3RwaXhlZCB3aXRoICclJyBvciAncHgnLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbiB3aWR0aChudW0sIHNraXBMaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oJ3dpZHRoJywgbnVtLCBza2lwTGlzdGVuZXJzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgaGVpZ2h0IG9mIHRoZSBjb21wb25lbnQgYmFzZWQgdXBvbiB0aGUgQ1NTIHN0eWxlcy5cbiAgICogU2VlIHtAbGluayBDb21wb25lbnQjZGltZW5zaW9ufSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbbnVtXVxuICAgKiAgICAgICAgVGhlIGhlaWdodCB0aGF0IHlvdSB3YW50IHRvIHNldCBwb3N0Zml4ZWQgd2l0aCAnJScsICdweCcgb3Igbm90aGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcExpc3RlbmVyc11cbiAgICogICAgICAgIFNraXAgdGhlIGNvbXBvbmVudHJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIHdpZHRoIHdoZW4gZ2V0dGluZywgemVybyBpZiB0aGVyZSBpcyBubyB3aWR0aC4gQ2FuIGJlIGEgc3RyaW5nXG4gICAqICAgICAgICAgcG9zdHBpeGVkIHdpdGggJyUnIG9yICdweCcuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiBoZWlnaHQobnVtLCBza2lwTGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCdoZWlnaHQnLCBudW0sIHNraXBMaXN0ZW5lcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYm90aCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgYENvbXBvbmVudGAgZWxlbWVudCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ8c3RyaW5nfSB3aWR0aFxuICAgKiAgICAgICAgIFdpZHRoIHRvIHNldCB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcnxzdHJpbmd9IGhlaWdodFxuICAgKiAgICAgICAgIEhlaWdodCB0byBzZXQgdGhlIGBDb21wb25lbnRgcyBlbGVtZW50IHRvLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZGltZW5zaW9ucyA9IGZ1bmN0aW9uIGRpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuICAgIC8vIFNraXAgY29tcG9uZW50cmVzaXplIGxpc3RlbmVycyBvbiB3aWR0aCBmb3Igb3B0aW1pemF0aW9uXG4gICAgdGhpcy53aWR0aCh3aWR0aCwgdHJ1ZSk7XG4gICAgdGhpcy5oZWlnaHQoaGVpZ2h0KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB3aWR0aCBvciBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgIGVsZW1lbnQuIFRoaXMgaXMgdGhlIHNoYXJlZCBjb2RlXG4gICAqIGZvciB0aGUge0BsaW5rIENvbXBvbmVudCN3aWR0aH0gYW5kIHtAbGluayBDb21wb25lbnQjaGVpZ2h0fS5cbiAgICpcbiAgICogVGhpbmdzIHRvIGtub3c6XG4gICAqIC0gSWYgdGhlIHdpZHRoIG9yIGhlaWdodCBpbiBhbiBudW1iZXIgdGhpcyB3aWxsIHJldHVybiB0aGUgbnVtYmVyIHBvc3RmaXhlZCB3aXRoICdweCcuXG4gICAqIC0gSWYgdGhlIHdpZHRoL2hlaWdodCBpcyBhIHBlcmNlbnQgdGhpcyB3aWxsIHJldHVybiB0aGUgcGVyY2VudCBwb3N0Zml4ZWQgd2l0aCAnJSdcbiAgICogLSBIaWRkZW4gZWxlbWVudHMgaGF2ZSBhIHdpZHRoIG9mIDAgd2l0aCBgd2luZG93LmdldENvbXB1dGVkU3R5bGVgLiBUaGlzIGZ1bmN0aW9uXG4gICAqICAgZGVmYXVsdHMgdG8gdGhlIGBDb21wb25lbnRgcyBgc3R5bGUud2lkdGhgIGFuZCBmYWxscyBiYWNrIHRvIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuXG4gICAqICAgU2VlIFt0aGlzXXtAbGluayBodHRwOi8vd3d3LmZvbGlvdGVrLmNvbS9kZXZibG9nL2dldHRpbmctdGhlLXdpZHRoLW9mLWEtaGlkZGVuLWVsZW1lbnQtd2l0aC1qcXVlcnktdXNpbmctd2lkdGgvfVxuICAgKiAgIGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAqIC0gSWYgeW91IHdhbnQgdGhlIGNvbXB1dGVkIHN0eWxlIG9mIHRoZSBjb21wb25lbnQsIHVzZSB7QGxpbmsgQ29tcG9uZW50I2N1cnJlbnRXaWR0aH1cbiAgICogICBhbmQge0BsaW5rIHtDb21wb25lbnQjY3VycmVudEhlaWdodH1cbiAgICpcbiAgICogQGZpcmVzIENvbXBvbmVudCNjb21wb25lbnRyZXNpemVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHdpZHRoT3JIZWlnaHRcbiAgIDggICAgICAgICd3aWR0aCcgb3IgJ2hlaWdodCdcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ30gW251bV1cbiAgIDggICAgICAgICBOZXcgZGltZW5zaW9uXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFtza2lwTGlzdGVuZXJzXVxuICAgKiAgICAgICAgIFNraXAgY29tcG9uZW50cmVzaXplIGV2ZW50IHRyaWdnZXJcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkaW1lbnNpb24gd2hlbiBnZXR0aW5nIG9yIDAgaWYgdW5zZXRcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmRpbWVuc2lvbiA9IGZ1bmN0aW9uIGRpbWVuc2lvbih3aWR0aE9ySGVpZ2h0LCBudW0sIHNraXBMaXN0ZW5lcnMpIHtcbiAgICBpZiAobnVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFNldCB0byB6ZXJvIGlmIG51bGwgb3IgbGl0ZXJhbGx5IE5hTiAoTmFOICE9PSBOYU4pXG4gICAgICBpZiAobnVtID09PSBudWxsIHx8IG51bSAhPT0gbnVtKSB7XG4gICAgICAgIG51bSA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHVzaW5nIGNzcyB3aWR0aC9oZWlnaHQgKCUgb3IgcHgpIGFuZCBhZGp1c3RcbiAgICAgIGlmICgoJycgKyBudW0pLmluZGV4T2YoJyUnKSAhPT0gLTEgfHwgKCcnICsgbnVtKS5pbmRleE9mKCdweCcpICE9PSAtMSkge1xuICAgICAgICB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XSA9IG51bTtcbiAgICAgIH0gZWxzZSBpZiAobnVtID09PSAnYXV0bycpIHtcbiAgICAgICAgdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF0gPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdID0gbnVtICsgJ3B4JztcbiAgICAgIH1cblxuICAgICAgLy8gc2tpcExpc3RlbmVycyBhbGxvd3MgdXMgdG8gYXZvaWQgdHJpZ2dlcmluZyB0aGUgcmVzaXplIGV2ZW50IHdoZW4gc2V0dGluZyBib3RoIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgIGlmICghc2tpcExpc3RlbmVycykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZ2dlcmVkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVzaXplZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IENvbXBvbmVudCNjb21wb25lbnRyZXNpemVcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjb21wb25lbnRyZXNpemUnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5vdCBzZXR0aW5nIGEgdmFsdWUsIHNvIGdldHRpbmcgaXRcbiAgICAvLyBNYWtlIHN1cmUgZWxlbWVudCBleGlzdHNcbiAgICBpZiAoIXRoaXMuZWxfKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBHZXQgZGltZW5zaW9uIHZhbHVlIGZyb20gc3R5bGVcbiAgICB2YXIgdmFsID0gdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF07XG4gICAgdmFyIHB4SW5kZXggPSB2YWwuaW5kZXhPZigncHgnKTtcblxuICAgIGlmIChweEluZGV4ICE9PSAtMSkge1xuICAgICAgLy8gUmV0dXJuIHRoZSBwaXhlbCB2YWx1ZSB3aXRoIG5vICdweCdcbiAgICAgIHJldHVybiBwYXJzZUludCh2YWwuc2xpY2UoMCwgcHhJbmRleCksIDEwKTtcbiAgICB9XG5cbiAgICAvLyBObyBweCBzbyB1c2luZyAlIG9yIG5vIHN0eWxlIHdhcyBzZXQsIHNvIGZhbGxpbmcgYmFjayB0byBvZmZzZXRXaWR0aC9oZWlnaHRcbiAgICAvLyBJZiBjb21wb25lbnQgaGFzIGRpc3BsYXk6bm9uZSwgb2Zmc2V0IHdpbGwgcmV0dXJuIDBcbiAgICAvLyBUT0RPOiBoYW5kbGUgZGlzcGxheTpub25lIGFuZCBubyBkaW1lbnNpb24gc3R5bGUgdXNpbmcgcHhcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5lbF9bJ29mZnNldCcgKyB0b1RpdGxlQ2FzZSh3aWR0aE9ySGVpZ2h0KV0sIDEwKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB3aWR0aCBvciB0aGUgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YCBlbGVtZW50cyBjb21wdXRlZCBzdHlsZS4gVXNlc1xuICAgKiBgd2luZG93LmdldENvbXB1dGVkU3R5bGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gd2lkdGhPckhlaWdodFxuICAgKiAgICAgICAgQSBzdHJpbmcgY29udGFpbmluZyAnd2lkdGgnIG9yICdoZWlnaHQnLiBXaGljaGV2ZXIgb25lIHlvdSB3YW50IHRvIGdldC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkaW1lbnNpb24gdGhhdCBnZXRzIGFza2VkIGZvciBvciAwIGlmIG5vdGhpbmcgd2FzIHNldFxuICAgKiAgICAgICAgIGZvciB0aGF0IGRpbWVuc2lvbi5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmN1cnJlbnREaW1lbnNpb24gPSBmdW5jdGlvbiBjdXJyZW50RGltZW5zaW9uKHdpZHRoT3JIZWlnaHQpIHtcbiAgICB2YXIgY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID0gMDtcblxuICAgIGlmICh3aWR0aE9ySGVpZ2h0ICE9PSAnd2lkdGgnICYmIHdpZHRoT3JIZWlnaHQgIT09ICdoZWlnaHQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnREaW1lbnNpb24gb25seSBhY2NlcHRzIHdpZHRoIG9yIGhlaWdodCB2YWx1ZScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3ckMS5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxfKTtcblxuICAgICAgY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHdpZHRoT3JIZWlnaHQpIHx8IGNvbXB1dGVkU3R5bGVbd2lkdGhPckhlaWdodF07XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlICdweCcgZnJvbSB2YXJpYWJsZSBhbmQgcGFyc2UgYXMgaW50ZWdlclxuICAgIGNvbXB1dGVkV2lkdGhPckhlaWdodCA9IHBhcnNlRmxvYXQoY29tcHV0ZWRXaWR0aE9ySGVpZ2h0KTtcblxuICAgIC8vIGlmIHRoZSBjb21wdXRlZCB2YWx1ZSBpcyBzdGlsbCAwLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGJyb3dzZXIgaXMgbHlpbmdcbiAgICAvLyBhbmQgd2Ugd2FudCB0byBjaGVjayB0aGUgb2Zmc2V0IHZhbHVlcy5cbiAgICAvLyBUaGlzIGNvZGUgYWxzbyBydW5zIHdoZXJldmVyIGdldENvbXB1dGVkU3R5bGUgZG9lc24ndCBleGlzdC5cbiAgICBpZiAoY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID09PSAwKSB7XG4gICAgICB2YXIgcnVsZSA9ICdvZmZzZXQnICsgdG9UaXRsZUNhc2Uod2lkdGhPckhlaWdodCk7XG5cbiAgICAgIGNvbXB1dGVkV2lkdGhPckhlaWdodCA9IHRoaXMuZWxfW3J1bGVdO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wdXRlZFdpZHRoT3JIZWlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHdpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIG9mIHRoZSBgQ29tcG9uZW50YHNcbiAgICogY29tcHV0ZWQgc3R5bGUuIFVzZXMgYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gQ29tcG9uZW50fkRpbWVuc2lvbk9iamVjdFxuICAgKlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGhcbiAgICogICAgICAgICAgIFRoZSB3aWR0aCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLlxuICAgKlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0XG4gICAqICAgICAgICAgICBUaGUgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgb2YgdGhlIGBDb21wb25lbnRgc1xuICAgKiBjb21wdXRlZCBzdHlsZS5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fkRpbWVuc2lvbk9iamVjdH1cbiAgICogICAgICAgICBUaGUgZGltZW5zaW9ucyBvZiB0aGUgY29tcG9uZW50cyBlbGVtZW50XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jdXJyZW50RGltZW5zaW9ucyA9IGZ1bmN0aW9uIGN1cnJlbnREaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGhpcy5jdXJyZW50RGltZW5zaW9uKCd3aWR0aCcpLFxuICAgICAgaGVpZ2h0OiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ2hlaWdodCcpXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB3aWR0aCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLiBVc2VzIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gd2lkdGhcbiAgICogICAgICAgICAgIFRoZSB3aWR0aCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudFdpZHRoID0gZnVuY3Rpb24gY3VycmVudFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ3dpZHRoJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuIFVzZXMgYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBoZWlnaHRcbiAgICogICAgICAgICAgIFRoZSBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgcyBjb21wdXRlZCBzdHlsZS5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmN1cnJlbnRIZWlnaHQgPSBmdW5jdGlvbiBjdXJyZW50SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ2hlaWdodCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZvY3VzIHRvIHRoaXMgY29tcG9uZW50XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHRoaXMuZWxfLmZvY3VzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZm9jdXMgZnJvbSB0aGlzIGNvbXBvbmVudFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgdGhpcy5lbF8uYmx1cigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbWl0IGEgJ3RhcCcgZXZlbnRzIHdoZW4gdG91Y2ggZXZlbnQgc3VwcG9ydCBnZXRzIGRldGVjdGVkLiBUaGlzIGdldHMgdXNlZCB0b1xuICAgKiBzdXBwb3J0IHRvZ2dsaW5nIHRoZSBjb250cm9scyB0aHJvdWdoIGEgdGFwIG9uIHRoZSB2aWRlby4gVGhleSBnZXQgZW5hYmxlZFxuICAgKiBiZWNhdXNlIGV2ZXJ5IHN1Yi1jb21wb25lbnQgd291bGQgaGF2ZSBleHRyYSBvdmVyaGVhZCBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmaXJlcyBDb21wb25lbnQjdGFwXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaHN0YXJ0XG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaG1vdmVcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNobGVhdmVcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoY2FuY2VsXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaGVuZFxuICAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmVtaXRUYXBFdmVudHMgPSBmdW5jdGlvbiBlbWl0VGFwRXZlbnRzKCkge1xuICAgIC8vIFRyYWNrIHRoZSBzdGFydCB0aW1lIHNvIHdlIGNhbiBkZXRlcm1pbmUgaG93IGxvbmcgdGhlIHRvdWNoIGxhc3RlZFxuICAgIHZhciB0b3VjaFN0YXJ0ID0gMDtcbiAgICB2YXIgZmlyc3RUb3VjaCA9IG51bGw7XG5cbiAgICAvLyBNYXhpbXVtIG1vdmVtZW50IGFsbG93ZWQgZHVyaW5nIGEgdG91Y2ggZXZlbnQgdG8gc3RpbGwgYmUgY29uc2lkZXJlZCBhIHRhcFxuICAgIC8vIE90aGVyIHBvcHVsYXIgbGlicyB1c2UgYW55d2hlcmUgZnJvbSAyIChoYW1tZXIuanMpIHRvIDE1LFxuICAgIC8vIHNvIDEwIHNlZW1zIGxpa2UgYSBuaWNlLCByb3VuZCBudW1iZXIuXG4gICAgdmFyIHRhcE1vdmVtZW50VGhyZXNob2xkID0gMTA7XG5cbiAgICAvLyBUaGUgbWF4aW11bSBsZW5ndGggYSB0b3VjaCBjYW4gYmUgd2hpbGUgc3RpbGwgYmVpbmcgY29uc2lkZXJlZCBhIHRhcFxuICAgIHZhciB0b3VjaFRpbWVUaHJlc2hvbGQgPSAyMDA7XG5cbiAgICB2YXIgY291bGRCZVRhcCA9IHZvaWQgMDtcblxuICAgIHRoaXMub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgZmluZ2VyLCBkb24ndCBjb25zaWRlciB0cmVhdGluZyB0aGlzIGFzIGEgY2xpY2tcbiAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBDb3B5IHBhZ2VYL3BhZ2VZIGZyb20gdGhlIG9iamVjdFxuICAgICAgICBmaXJzdFRvdWNoID0ge1xuICAgICAgICAgIHBhZ2VYOiBldmVudC50b3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgICAgIHBhZ2VZOiBldmVudC50b3VjaGVzWzBdLnBhZ2VZXG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlY29yZCBzdGFydCB0aW1lIHNvIHdlIGNhbiBkZXRlY3QgYSB0YXAgdnMuIFwidG91Y2ggYW5kIGhvbGRcIlxuICAgICAgICB0b3VjaFN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIC8vIFJlc2V0IGNvdWxkQmVUYXAgdHJhY2tpbmdcbiAgICAgICAgY291bGRCZVRhcCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgZmluZ2VyLCBkb24ndCBjb25zaWRlciB0cmVhdGluZyB0aGlzIGFzIGEgY2xpY2tcbiAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY291bGRCZVRhcCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdFRvdWNoKSB7XG4gICAgICAgIC8vIFNvbWUgZGV2aWNlcyB3aWxsIHRocm93IHRvdWNobW92ZXMgZm9yIGFsbCBidXQgdGhlIHNsaWdodGVzdCBvZiB0YXBzLlxuICAgICAgICAvLyBTbywgaWYgd2UgbW92ZWQgb25seSBhIHNtYWxsIGRpc3RhbmNlLCB0aGlzIGNvdWxkIHN0aWxsIGJlIGEgdGFwXG4gICAgICAgIHZhciB4ZGlmZiA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBmaXJzdFRvdWNoLnBhZ2VYO1xuICAgICAgICB2YXIgeWRpZmYgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZmlyc3RUb3VjaC5wYWdlWTtcbiAgICAgICAgdmFyIHRvdWNoRGlzdGFuY2UgPSBNYXRoLnNxcnQoeGRpZmYgKiB4ZGlmZiArIHlkaWZmICogeWRpZmYpO1xuXG4gICAgICAgIGlmICh0b3VjaERpc3RhbmNlID4gdGFwTW92ZW1lbnRUaHJlc2hvbGQpIHtcbiAgICAgICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBub1RhcCA9IGZ1bmN0aW9uIG5vVGFwKCkge1xuICAgICAgY291bGRCZVRhcCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBMaXN0ZW4gdG8gdGhlIG9yaWdpbmFsIHRhcmdldC4gaHR0cDovL3lvdXR1LmJlL0R1amZwWE9LVXA4P3Q9MTNtOHNcbiAgICB0aGlzLm9uKCd0b3VjaGxlYXZlJywgbm9UYXApO1xuICAgIHRoaXMub24oJ3RvdWNoY2FuY2VsJywgbm9UYXApO1xuXG4gICAgLy8gV2hlbiB0aGUgdG91Y2ggZW5kcywgbWVhc3VyZSBob3cgbG9uZyBpdCB0b29rIGFuZCB0cmlnZ2VyIHRoZSBhcHByb3ByaWF0ZVxuICAgIC8vIGV2ZW50XG4gICAgdGhpcy5vbigndG91Y2hlbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGZpcnN0VG91Y2ggPSBudWxsO1xuICAgICAgLy8gUHJvY2VlZCBvbmx5IGlmIHRoZSB0b3VjaG1vdmUvbGVhdmUvY2FuY2VsIGV2ZW50IGRpZG4ndCBoYXBwZW5cbiAgICAgIGlmIChjb3VsZEJlVGFwID09PSB0cnVlKSB7XG4gICAgICAgIC8vIE1lYXN1cmUgaG93IGxvbmcgdGhlIHRvdWNoIGxhc3RlZFxuICAgICAgICB2YXIgdG91Y2hUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0b3VjaFN0YXJ0O1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdG91Y2ggd2FzIGxlc3MgdGhhbiB0aGUgdGhyZXNob2xkIHRvIGJlIGNvbnNpZGVyZWQgYSB0YXBcbiAgICAgICAgaWYgKHRvdWNoVGltZSA8IHRvdWNoVGltZVRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIERvbid0IGxldCBicm93c2VyIHR1cm4gdGhpcyBpbnRvIGEgY2xpY2tcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgYENvbXBvbmVudGAgaXMgdGFwcGVkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGV2ZW50IENvbXBvbmVudCN0YXBcbiAgICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd0YXAnKTtcbiAgICAgICAgICAvLyBJdCBtYXkgYmUgZ29vZCB0byBjb3B5IHRoZSB0b3VjaGVuZCBldmVudCBvYmplY3QgYW5kIGNoYW5nZSB0aGVcbiAgICAgICAgICAvLyB0eXBlIHRvIHRhcCwgaWYgdGhlIG90aGVyIGV2ZW50IHByb3BlcnRpZXMgYXJlbid0IGV4YWN0IGFmdGVyXG4gICAgICAgICAgLy8gRXZlbnRzLmZpeEV2ZW50IHJ1bnMgKGUuZy4gZXZlbnQudGFyZ2V0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gcmVwb3J0cyB1c2VyIGFjdGl2aXR5IHdoZW5ldmVyIHRvdWNoIGV2ZW50cyBoYXBwZW4uIFRoaXMgY2FuIGdldFxuICAgKiB0dXJuZWQgb2ZmIGJ5IGFueSBzdWItY29tcG9uZW50cyB0aGF0IHdhbnRzIHRvdWNoIGV2ZW50cyB0byBhY3QgYW5vdGhlciB3YXkuXG4gICAqXG4gICAqIFJlcG9ydCB1c2VyIHRvdWNoIGFjdGl2aXR5IHdoZW4gdG91Y2ggZXZlbnRzIG9jY3VyLiBVc2VyIGFjdGl2aXR5IGdldHMgdXNlZCB0b1xuICAgKiBkZXRlcm1pbmUgd2hlbiBjb250cm9scyBzaG91bGQgc2hvdy9oaWRlLiBJdCBpcyBzaW1wbGUgd2hlbiBpdCBjb21lcyB0byBtb3VzZVxuICAgKiBldmVudHMsIGJlY2F1c2UgYW55IG1vdXNlIGV2ZW50IHNob3VsZCBzaG93IHRoZSBjb250cm9scy4gU28gd2UgY2FwdHVyZSBtb3VzZVxuICAgKiBldmVudHMgdGhhdCBidWJibGUgdXAgdG8gdGhlIHBsYXllciBhbmQgcmVwb3J0IGFjdGl2aXR5IHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKiBXaXRoIHRvdWNoIGV2ZW50cyBpdCBpc24ndCBhcyBlYXN5IGFzIGB0b3VjaHN0YXJ0YCBhbmQgYHRvdWNoZW5kYCB0b2dnbGUgcGxheWVyXG4gICAqIGNvbnRyb2xzLiBTbyB0b3VjaCBldmVudHMgY2FuJ3QgaGVscCB1cyBhdCB0aGUgcGxheWVyIGxldmVsIGVpdGhlci5cbiAgICpcbiAgICogVXNlciBhY3Rpdml0eSBnZXRzIGNoZWNrZWQgYXN5bmNocm9ub3VzbHkuIFNvIHdoYXQgY291bGQgaGFwcGVuIGlzIGEgdGFwIGV2ZW50XG4gICAqIG9uIHRoZSB2aWRlbyB0dXJucyB0aGUgY29udHJvbHMgb2ZmLiBUaGVuIHRoZSBgdG91Y2hlbmRgIGV2ZW50IGJ1YmJsZXMgdXAgdG9cbiAgICogdGhlIHBsYXllci4gV2hpY2gsIGlmIGl0IHJlcG9ydGVkIHVzZXIgYWN0aXZpdHksIHdvdWxkIHR1cm4gdGhlIGNvbnRyb2xzIHJpZ2h0XG4gICAqIGJhY2sgb24uIFdlIGFsc28gZG9uJ3Qgd2FudCB0byBjb21wbGV0ZWx5IGJsb2NrIHRvdWNoIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHVwLlxuICAgKiBGdXJ0aGVybW9yZSBhIGB0b3VjaG1vdmVgIGV2ZW50IGFuZCBhbnl0aGluZyBvdGhlciB0aGFuIGEgdGFwLCBzaG91bGQgbm90IHR1cm5cbiAgICogY29udHJvbHMgYmFjayBvbi5cbiAgICpcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoc3RhcnRcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNobW92ZVxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hlbmRcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoY2FuY2VsXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5lbmFibGVUb3VjaEFjdGl2aXR5ID0gZnVuY3Rpb24gZW5hYmxlVG91Y2hBY3Rpdml0eSgpIHtcbiAgICAvLyBEb24ndCBjb250aW51ZSBpZiB0aGUgcm9vdCBwbGF5ZXIgZG9lc24ndCBzdXBwb3J0IHJlcG9ydGluZyB1c2VyIGFjdGl2aXR5XG4gICAgaWYgKCF0aGlzLnBsYXllcigpIHx8ICF0aGlzLnBsYXllcigpLnJlcG9ydFVzZXJBY3Rpdml0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGxpc3RlbmVyIGZvciByZXBvcnRpbmcgdGhhdCB0aGUgdXNlciBpcyBhY3RpdmVcbiAgICB2YXIgcmVwb3J0ID0gYmluZCh0aGlzLnBsYXllcigpLCB0aGlzLnBsYXllcigpLnJlcG9ydFVzZXJBY3Rpdml0eSk7XG5cbiAgICB2YXIgdG91Y2hIb2xkaW5nID0gdm9pZCAwO1xuXG4gICAgdGhpcy5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlcG9ydCgpO1xuICAgICAgLy8gRm9yIGFzIGxvbmcgYXMgdGhlIHRoZXkgYXJlIHRvdWNoaW5nIHRoZSBkZXZpY2Ugb3IgaGF2ZSB0aGVpciBtb3VzZSBkb3duLFxuICAgICAgLy8gd2UgY29uc2lkZXIgdGhlbSBhY3RpdmUgZXZlbiBpZiB0aGV5J3JlIG5vdCBtb3ZpbmcgdGhlaXIgZmluZ2VyIG9yIG1vdXNlLlxuICAgICAgLy8gU28gd2Ugd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgdGhhdCB0aGV5IGFyZSBhY3RpdmVcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCh0b3VjaEhvbGRpbmcpO1xuICAgICAgLy8gcmVwb3J0IGF0IHRoZSBzYW1lIGludGVydmFsIGFzIGFjdGl2aXR5Q2hlY2tcbiAgICAgIHRvdWNoSG9sZGluZyA9IHRoaXMuc2V0SW50ZXJ2YWwocmVwb3J0LCAyNTApO1xuICAgIH0pO1xuXG4gICAgdmFyIHRvdWNoRW5kID0gZnVuY3Rpb24gdG91Y2hFbmQoZXZlbnQpIHtcbiAgICAgIHJlcG9ydCgpO1xuICAgICAgLy8gc3RvcCB0aGUgaW50ZXJ2YWwgdGhhdCBtYWludGFpbnMgYWN0aXZpdHkgaWYgdGhlIHRvdWNoIGlzIGhvbGRpbmdcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCh0b3VjaEhvbGRpbmcpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uKCd0b3VjaG1vdmUnLCByZXBvcnQpO1xuICAgIHRoaXMub24oJ3RvdWNoZW5kJywgdG91Y2hFbmQpO1xuICAgIHRoaXMub24oJ3RvdWNoY2FuY2VsJywgdG91Y2hFbmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIHRoYXQgaGFzIG5vIHBhcmFtZXRlcnMgYW5kIGlzIGJvdW5kIGludG8gYENvbXBvbmVudGBzIGNvbnRleHQuXG4gICAqXG4gICAqIEBjYWxsYmFjayBDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrXG4gICAqIEB0aGlzIENvbXBvbmVudFxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcnVucyBhZnRlciBhbiBgeGAgbWlsbGlzZWNvbmQgdGltZW91dC4gVGhpcyBmdW5jdGlvbiBpcyBhXG4gICAqIHdyYXBwZXIgYXJvdW5kIGB3aW5kb3cuc2V0VGltZW91dGAuIFRoZXJlIGFyZSBhIGZldyByZWFzb25zIHRvIHVzZSB0aGlzIG9uZVxuICAgKiBpbnN0ZWFkIHRob3VnaDpcbiAgICogMS4gSXQgZ2V0cyBjbGVhcmVkIHZpYSAge0BsaW5rIENvbXBvbmVudCNjbGVhclRpbWVvdXR9IHdoZW5cbiAgICogICAge0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfSBnZXRzIGNhbGxlZC5cbiAgICogMi4gVGhlIGZ1bmN0aW9uIGNhbGxiYWNrIHdpbGwgZ2V0cyB0dXJuZWQgaW50byBhIHtAbGluayBDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfVxuICAgKlxuICAgKiA+IE5vdGU6IFlvdSBjYW4ndCB1c2UgYHdpbmRvdy5jbGVhclRpbWVvdXRgIG9uIHRoZSBpZCByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uLiBUaGlzXG4gICAqICAgICAgICAgd2lsbCBjYXVzZSBpdHMgZGlzcG9zZSBsaXN0ZW5lciBub3QgdG8gZ2V0IGNsZWFuZWQgdXAhIFBsZWFzZSB1c2VcbiAgICogICAgICAgICB7QGxpbmsgQ29tcG9uZW50I2NsZWFyVGltZW91dH0gb3Ige0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9IGZuXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHJ1biBhZnRlciBgdGltZW91dGAuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gICAqICAgICAgICBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBkZWxheSBiZWZvcmUgZXhlY3V0aW5nIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIGEgdGltZW91dCBJRCB0aGF0IGdldHMgdXNlZCB0byBpZGVudGlmeSB0aGUgdGltZW91dC4gSXQgY2FuIGFsc29cbiAgICogICAgICAgICBnZXQgdXNlZCBpbiB7QGxpbmsgQ29tcG9uZW50I2NsZWFyVGltZW91dH0gdG8gY2xlYXIgdGhlIHRpbWVvdXQgdGhhdFxuICAgKiAgICAgICAgIHdhcyBzZXQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCNkaXNwb3NlXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dUaW1lcnMvc2V0VGltZW91dH1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbiBzZXRUaW1lb3V0KGZuLCB0aW1lb3V0KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBkZWNsYXJlIGFzIHZhcmlhYmxlcyBzbyB0aGV5IGFyZSBwcm9wZXJseSBhdmFpbGFibGUgaW4gdGltZW91dCBmdW5jdGlvblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHZhciB0aW1lb3V0SWQsIGRpc3Bvc2VGbjtcblxuICAgIGZuID0gYmluZCh0aGlzLCBmbik7XG5cbiAgICB0aW1lb3V0SWQgPSB3aW5kb3ckMS5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMi5vZmYoJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuICAgICAgZm4oKTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uIGRpc3Bvc2VGbigpIHtcbiAgICAgIHJldHVybiBfdGhpczIuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy10aW1lb3V0LScgKyB0aW1lb3V0SWQ7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiB0aW1lb3V0SWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFycyBhIHRpbWVvdXQgdGhhdCBnZXRzIGNyZWF0ZWQgdmlhIGB3aW5kb3cuc2V0VGltZW91dGAgb3JcbiAgICoge0BsaW5rIENvbXBvbmVudCNzZXRUaW1lb3V0fS4gSWYgeW91IHNldCBhIHRpbWVvdXQgdmlhIHtAbGluayBDb21wb25lbnQjc2V0VGltZW91dH1cbiAgICogdXNlIHRoaXMgZnVuY3Rpb24gaW5zdGVhZCBvZiBgd2luZG93LmNsZWFyVGltb3V0YC4gSWYgeW91IGRvbid0IHlvdXIgZGlzcG9zZVxuICAgKiBsaXN0ZW5lciB3aWxsIG5vdCBnZXQgY2xlYW5lZCB1cCB1bnRpbCB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dElkXG4gICAqICAgICAgICBUaGUgaWQgb2YgdGhlIHRpbWVvdXQgdG8gY2xlYXIuIFRoZSByZXR1cm4gdmFsdWUgb2ZcbiAgICogICAgICAgIHtAbGluayBDb21wb25lbnQjc2V0VGltZW91dH0gb3IgYHdpbmRvdy5zZXRUaW1lb3V0YC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgdGhlIHRpbWVvdXQgaWQgdGhhdCB3YXMgY2xlYXJlZC5cbiAgICpcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd1RpbWVycy9jbGVhclRpbWVvdXR9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBjbGVhclRpbWVvdXQodGltZW91dElkKSB7XG4gICAgd2luZG93JDEuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cbiAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge307XG5cbiAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtdGltZW91dC0nICsgdGltZW91dElkO1xuXG4gICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgcmV0dXJuIHRpbWVvdXRJZDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyBydW4gZXZlcnkgYHhgIG1pbGxpc2Vjb25kcy4gVGhpcyBmdW5jdGlvbiBpcyBhIHdyYXBwZXJcbiAgICogYXJvdW5kIGB3aW5kb3cuc2V0SW50ZXJ2YWxgLiBUaGVyZSBhcmUgYSBmZXcgcmVhc29ucyB0byB1c2UgdGhpcyBvbmUgaW5zdGVhZCB0aG91Z2guXG4gICAqIDEuIEl0IGdldHMgY2xlYXJlZCB2aWEgIHtAbGluayBDb21wb25lbnQjY2xlYXJJbnRlcnZhbH0gd2hlblxuICAgKiAgICB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IGdldHMgY2FsbGVkLlxuICAgKiAyLiBUaGUgZnVuY3Rpb24gY2FsbGJhY2sgd2lsbCBiZSBhIHtAbGluayBDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfVxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9IGZuXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gcnVuIGV2ZXJ5IGB4YCBzZWNvbmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWxcbiAgICogICAgICAgIEV4ZWN1dGUgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBldmVyeSBgeGAgbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgUmV0dXJucyBhbiBpZCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IHRoZSBpbnRlcnZhbC4gSXQgY2FuIGFsc28gYmUgYmUgdXNlZCBpblxuICAgKiAgICAgICAgIHtAbGluayBDb21wb25lbnQjY2xlYXJJbnRlcnZhbH0gdG8gY2xlYXIgdGhlIGludGVydmFsLlxuICAgKlxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjZGlzcG9zZVxuICAgKiBAc2VlIFtTaW1pbGFyIHRvXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93VGltZXJzL3NldEludGVydmFsfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiBzZXRJbnRlcnZhbChmbiwgaW50ZXJ2YWwpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIGZuID0gYmluZCh0aGlzLCBmbik7XG5cbiAgICB2YXIgaW50ZXJ2YWxJZCA9IHdpbmRvdyQxLnNldEludGVydmFsKGZuLCBpbnRlcnZhbCk7XG5cbiAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge1xuICAgICAgcmV0dXJuIF90aGlzMy5jbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIH07XG5cbiAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtaW50ZXJ2YWwtJyArIGludGVydmFsSWQ7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiBpbnRlcnZhbElkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgYW4gaW50ZXJ2YWwgdGhhdCBnZXRzIGNyZWF0ZWQgdmlhIGB3aW5kb3cuc2V0SW50ZXJ2YWxgIG9yXG4gICAqIHtAbGluayBDb21wb25lbnQjc2V0SW50ZXJ2YWx9LiBJZiB5b3Ugc2V0IGFuIGludGV2YWwgdmlhIHtAbGluayBDb21wb25lbnQjc2V0SW50ZXJ2YWx9XG4gICAqIHVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgYHdpbmRvdy5jbGVhckludGVydmFsYC4gSWYgeW91IGRvbid0IHlvdXIgZGlzcG9zZVxuICAgKiBsaXN0ZW5lciB3aWxsIG5vdCBnZXQgY2xlYW5lZCB1cCB1bnRpbCB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWxJZFxuICAgKiAgICAgICAgVGhlIGlkIG9mIHRoZSBpbnRlcnZhbCB0byBjbGVhci4gVGhlIHJldHVybiB2YWx1ZSBvZlxuICAgKiAgICAgICAge0BsaW5rIENvbXBvbmVudCNzZXRJbnRlcnZhbH0gb3IgYHdpbmRvdy5zZXRJbnRlcnZhbGAuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIHRoZSBpbnRlcnZhbCBpZCB0aGF0IHdhcyBjbGVhcmVkLlxuICAgKlxuICAgKiBAc2VlIFtTaW1pbGFyIHRvXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93VGltZXJzL2NsZWFySW50ZXJ2YWx9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jbGVhckludGVydmFsID0gZnVuY3Rpb24gY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKSB7XG4gICAgd2luZG93JDEuY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcblxuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7fTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy1pbnRlcnZhbC0nICsgaW50ZXJ2YWxJZDtcblxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiBpbnRlcnZhbElkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBRdWV1ZXMgdXAgYSBjYWxsYmFjayB0byBiZSBwYXNzZWQgdG8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChyQUYpLCBidXRcbiAgICogd2l0aCBhIGZldyBleHRyYSBib251c2VzOlxuICAgKlxuICAgKiAtIFN1cHBvcnRzIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgckFGIGJ5IGZhbGxpbmcgYmFjayB0b1xuICAgKiAgIHtAbGluayBDb21wb25lbnQjc2V0VGltZW91dH0uXG4gICAqXG4gICAqIC0gVGhlIGNhbGxiYWNrIGlzIHR1cm5lZCBpbnRvIGEge0BsaW5rIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9IChpLmUuXG4gICAqICAgYm91bmQgdG8gdGhlIGNvbXBvbmVudCkuXG4gICAqXG4gICAqIC0gQXV0b21hdGljIGNhbmNlbGxhdGlvbiBvZiB0aGUgckFGIGNhbGxiYWNrIGlzIGhhbmRsZWQgaWYgdGhlIGNvbXBvbmVudFxuICAgKiAgIGlzIGRpc3Bvc2VkIGJlZm9yZSBpdCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge0NvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9IGZuXG4gICAqICAgICAgICAgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYm91bmQgdG8gdGhpcyBjb21wb25lbnQgYW5kIGV4ZWN1dGVkIGp1c3RcbiAgICogICAgICAgICBiZWZvcmUgdGhlIGJyb3dzZXIncyBuZXh0IHJlcGFpbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIGFuIHJBRiBJRCB0aGF0IGdldHMgdXNlZCB0byBpZGVudGlmeSB0aGUgdGltZW91dC4gSXQgY2FuXG4gICAqICAgICAgICAgYWxzbyBiZSB1c2VkIGluIHtAbGluayBDb21wb25lbnQjY2FuY2VsQW5pbWF0aW9uRnJhbWV9IHRvIGNhbmNlbFxuICAgKiAgICAgICAgIHRoZSBhbmltYXRpb24gZnJhbWUgY2FsbGJhY2suXG4gICAqXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCNkaXNwb3NlXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAvLyBkZWNsYXJlIGFzIHZhcmlhYmxlcyBzbyB0aGV5IGFyZSBwcm9wZXJseSBhdmFpbGFibGUgaW4gckFGIGZ1bmN0aW9uXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgdmFyIGlkLCBkaXNwb3NlRm47XG5cbiAgICBpZiAodGhpcy5zdXBwb3J0c1JhZl8pIHtcbiAgICAgIGZuID0gYmluZCh0aGlzLCBmbik7XG5cbiAgICAgIGlkID0gd2luZG93JDEucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM0Lm9mZignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG4gICAgICAgIGZuKCk7XG4gICAgICB9KTtcblxuICAgICAgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM0LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICAgIH07XG5cbiAgICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy1yYWYtJyArIGlkO1xuICAgICAgdGhpcy5vbignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICAvLyBGYWxsIGJhY2sgdG8gdXNpbmcgYSB0aW1lci5cbiAgICByZXR1cm4gdGhpcy5zZXRUaW1lb3V0KGZuLCAxMDAwIC8gNjApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcXVldWVkIGNhbGxiYWNrIHBhc3NlZCB0byB7QGxpbmsgQ29tcG9uZW50I3JlcXVlc3RBbmltYXRpb25GcmFtZX1cbiAgICogKHJBRikuXG4gICAqXG4gICAqIElmIHlvdSBxdWV1ZSBhbiByQUYgY2FsbGJhY2sgdmlhIHtAbGluayBDb21wb25lbnQjcmVxdWVzdEFuaW1hdGlvbkZyYW1lfSxcbiAgICogdXNlIHRoaXMgZnVuY3Rpb24gaW5zdGVhZCBvZiBgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lYC4gSWYgeW91IGRvbid0LFxuICAgKiB5b3VyIGRpc3Bvc2UgbGlzdGVuZXIgd2lsbCBub3QgZ2V0IGNsZWFuZWQgdXAgdW50aWwge0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfSFcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGlkXG4gICAqICAgICAgICBUaGUgckFGIElEIHRvIGNsZWFyLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHtAbGluayBDb21wb25lbnQjcmVxdWVzdEFuaW1hdGlvbkZyYW1lfS5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgdGhlIHJBRiBJRCB0aGF0IHdhcyBjbGVhcmVkLlxuICAgKlxuICAgKiBAc2VlIFtTaW1pbGFyIHRvXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiBjYW5jZWxBbmltYXRpb25GcmFtZShpZCkge1xuICAgIGlmICh0aGlzLnN1cHBvcnRzUmFmXykge1xuICAgICAgd2luZG93JDEuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuXG4gICAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge307XG5cbiAgICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy1yYWYtJyArIGlkO1xuXG4gICAgICB0aGlzLm9mZignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICAvLyBGYWxsIGJhY2sgdG8gdXNpbmcgYSB0aW1lci5cbiAgICByZXR1cm4gdGhpcy5jbGVhclRpbWVvdXQoaWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGBDb21wb25lbnRgIHdpdGggYHZpZGVvanNgIGdpdmVuIHRoZSBuYW1lIGFuZCB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiA+IE5PVEU6IHtAbGluayBUZWNofXMgc2hvdWxkIG5vdCBiZSByZWdpc3RlcmVkIGFzIGEgYENvbXBvbmVudGAuIHtAbGluayBUZWNofXNcbiAgICogICAgICAgICBzaG91bGQgYmUgcmVnaXN0ZXJlZCB1c2luZyB7QGxpbmsgVGVjaC5yZWdpc3RlclRlY2h9IG9yXG4gICAqICAgICAgICAge0BsaW5rIHZpZGVvanM6dmlkZW9qcy5yZWdpc3RlclRlY2h9LlxuICAgKlxuICAgKiA+IE5PVEU6IFRoaXMgZnVuY3Rpb24gY2FuIGFsc28gYmUgc2VlbiBvbiB2aWRlb2pzIGFzXG4gICAqICAgICAgICAge0BsaW5rIHZpZGVvanM6dmlkZW9qcy5yZWdpc3RlckNvbXBvbmVudH0uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgYENvbXBvbmVudGAgdG8gcmVnaXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBDb21wb25lbnRUb1JlZ2lzdGVyXG4gICAqICAgICAgICBUaGUgYENvbXBvbmVudGAgY2xhc3MgdG8gcmVnaXN0ZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogICAgICAgICBUaGUgYENvbXBvbmVudGAgdGhhdCB3YXMgcmVnaXN0ZXJlZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQgPSBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudChuYW1lLCBDb21wb25lbnRUb1JlZ2lzdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCAhbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNvbXBvbmVudCBuYW1lLCBcIicgKyBuYW1lICsgJ1wiOyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy4nKTtcbiAgICB9XG5cbiAgICB2YXIgVGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoJ1RlY2gnKTtcblxuICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoaXMgY2hlY2sgaXMgb25seSBkb25lIGlmIFRlY2ggaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICB2YXIgaXNUZWNoID0gVGVjaCAmJiBUZWNoLmlzVGVjaChDb21wb25lbnRUb1JlZ2lzdGVyKTtcbiAgICB2YXIgaXNDb21wID0gQ29tcG9uZW50ID09PSBDb21wb25lbnRUb1JlZ2lzdGVyIHx8IENvbXBvbmVudC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihDb21wb25lbnRUb1JlZ2lzdGVyLnByb3RvdHlwZSk7XG5cbiAgICBpZiAoaXNUZWNoIHx8ICFpc0NvbXApIHtcbiAgICAgIHZhciByZWFzb24gPSB2b2lkIDA7XG5cbiAgICAgIGlmIChpc1RlY2gpIHtcbiAgICAgICAgcmVhc29uID0gJ3RlY2hzIG11c3QgYmUgcmVnaXN0ZXJlZCB1c2luZyBUZWNoLnJlZ2lzdGVyVGVjaCgpJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlYXNvbiA9ICdtdXN0IGJlIGEgQ29tcG9uZW50IHN1YmNsYXNzJztcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNvbXBvbmVudCwgXCInICsgbmFtZSArICdcIjsgJyArIHJlYXNvbiArICcuJyk7XG4gICAgfVxuXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xuXG4gICAgaWYgKCFDb21wb25lbnQuY29tcG9uZW50c18pIHtcbiAgICAgIENvbXBvbmVudC5jb21wb25lbnRzXyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBQbGF5ZXIgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdQbGF5ZXInKTtcblxuICAgIGlmIChuYW1lID09PSAnUGxheWVyJyAmJiBQbGF5ZXIgJiYgUGxheWVyLnBsYXllcnMpIHtcbiAgICAgIHZhciBwbGF5ZXJzID0gUGxheWVyLnBsYXllcnM7XG4gICAgICB2YXIgcGxheWVyTmFtZXMgPSBPYmplY3Qua2V5cyhwbGF5ZXJzKTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBwbGF5ZXJzIHRoYXQgd2VyZSBkaXNwb3NlZCwgdGhlbiB0aGVpciBuYW1lIHdpbGwgc3RpbGwgYmVcbiAgICAgIC8vIGluIFBsYXllcnMucGxheWVycy4gU28sIHdlIG11c3QgbG9vcCB0aHJvdWdoIGFuZCB2ZXJpZnkgdGhhdCB0aGUgdmFsdWVcbiAgICAgIC8vIGZvciBlYWNoIGl0ZW0gaXMgbm90IG51bGwuIFRoaXMgYWxsb3dzIHJlZ2lzdHJhdGlvbiBvZiB0aGUgUGxheWVyIGNvbXBvbmVudFxuICAgICAgLy8gYWZ0ZXIgYWxsIHBsYXllcnMgaGF2ZSBiZWVuIGRpc3Bvc2VkIG9yIGJlZm9yZSBhbnkgd2VyZSBjcmVhdGVkLlxuICAgICAgaWYgKHBsYXllcnMgJiYgcGxheWVyTmFtZXMubGVuZ3RoID4gMCAmJiBwbGF5ZXJOYW1lcy5tYXAoZnVuY3Rpb24gKHBuYW1lKSB7XG4gICAgICAgIHJldHVybiBwbGF5ZXJzW3BuYW1lXTtcbiAgICAgIH0pLmV2ZXJ5KEJvb2xlYW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCByZWdpc3RlciBQbGF5ZXIgY29tcG9uZW50IGFmdGVyIHBsYXllciBoYXMgYmVlbiBjcmVhdGVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIENvbXBvbmVudC5jb21wb25lbnRzX1tuYW1lXSA9IENvbXBvbmVudFRvUmVnaXN0ZXI7XG5cbiAgICByZXR1cm4gQ29tcG9uZW50VG9SZWdpc3RlcjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgYENvbXBvbmVudGAgYmFzZWQgb24gdGhlIG5hbWUgaXQgd2FzIHJlZ2lzdGVyZWQgd2l0aC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIFRoZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqICAgICAgICAgVGhlIGBDb21wb25lbnRgIHRoYXQgZ290IHJlZ2lzdGVyZWQgdW5kZXIgdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluIGB2aWRlb2pzYCA2IHRoaXMgd2lsbCBub3QgcmV0dXJuIGBDb21wb25lbnRgcyB0aGF0IHdlcmUgbm90XG4gICAqICAgICAgICAgICAgIHJlZ2lzdGVyZWQgdXNpbmcge0BsaW5rIENvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudH0uIEN1cnJlbnRseSB3ZVxuICAgKiAgICAgICAgICAgICBjaGVjayB0aGUgZ2xvYmFsIGB2aWRlb2pzYCBvYmplY3QgZm9yIGEgYENvbXBvbmVudGAgbmFtZSBhbmRcbiAgICogICAgICAgICAgICAgcmV0dXJuIHRoYXQgaWYgaXQgZXhpc3RzLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5nZXRDb21wb25lbnQgPSBmdW5jdGlvbiBnZXRDb21wb25lbnQobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5hbWUgPSB0b1RpdGxlQ2FzZShuYW1lKTtcblxuICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50c18gJiYgQ29tcG9uZW50LmNvbXBvbmVudHNfW25hbWVdKSB7XG4gICAgICByZXR1cm4gQ29tcG9uZW50LmNvbXBvbmVudHNfW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ29tcG9uZW50O1xufSgpO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9uZW50IHN1cHBvcnRzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICpcbiAqIFRoaXMgaXMgZXhwb3NlZCBwcmltYXJpbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zdXBwb3J0c1JhZl8gPSB0eXBlb2Ygd2luZG93JDEucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB3aW5kb3ckMS5jYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDb21wb25lbnQnLCBDb21wb25lbnQpO1xuXG4vKipcbiAqIEBmaWxlIGJyb3dzZXIuanNcbiAqIEBtb2R1bGUgYnJvd3NlclxuICovXG5cbnZhciBVU0VSX0FHRU5UID0gd2luZG93JDEubmF2aWdhdG9yICYmIHdpbmRvdyQxLm5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG52YXIgd2Via2l0VmVyc2lvbk1hcCA9IC9BcHBsZVdlYktpdFxcLyhbXFxkLl0rKS9pLmV4ZWMoVVNFUl9BR0VOVCk7XG52YXIgYXBwbGVXZWJraXRWZXJzaW9uID0gd2Via2l0VmVyc2lvbk1hcCA/IHBhcnNlRmxvYXQod2Via2l0VmVyc2lvbk1hcC5wb3AoKSkgOiBudWxsO1xuXG4vKlxuICogRGV2aWNlIGlzIGFuIGlQaG9uZVxuICpcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGNvbnN0YW50XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSVNfSVBBRCA9IC9pUGFkL2kudGVzdChVU0VSX0FHRU5UKTtcblxuLy8gVGhlIEZhY2Vib29rIGFwcCdzIFVJV2ViVmlldyBpZGVudGlmaWVzIGFzIGJvdGggYW4gaVBob25lIGFuZCBpUGFkLCBzb1xuLy8gdG8gaWRlbnRpZnkgaVBob25lcywgd2UgbmVlZCB0byBleGNsdWRlIGlQYWRzLlxuLy8gaHR0cDovL2FydHN5LmdpdGh1Yi5pby9ibG9nLzIwMTIvMTAvMTgvdGhlLXBlcmlscy1vZi1pb3MtdXNlci1hZ2VudC1zbmlmZmluZy9cbnZhciBJU19JUEhPTkUgPSAvaVBob25lL2kudGVzdChVU0VSX0FHRU5UKSAmJiAhSVNfSVBBRDtcbnZhciBJU19JUE9EID0gL2lQb2QvaS50ZXN0KFVTRVJfQUdFTlQpO1xudmFyIElTX0lPUyA9IElTX0lQSE9ORSB8fCBJU19JUEFEIHx8IElTX0lQT0Q7XG5cbnZhciBJT1NfVkVSU0lPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1hdGNoID0gVVNFUl9BR0VOVC5tYXRjaCgvT1MgKFxcZCspXy9pKTtcblxuICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcbiAgICByZXR1cm4gbWF0Y2hbMV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KCk7XG5cbnZhciBJU19BTkRST0lEID0gL0FuZHJvaWQvaS50ZXN0KFVTRVJfQUdFTlQpO1xudmFyIEFORFJPSURfVkVSU0lPTiA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhpcyBtYXRjaGVzIEFuZHJvaWQgTWFqb3IuTWlub3IuUGF0Y2ggdmVyc2lvbnNcbiAgLy8gQU5EUk9JRF9WRVJTSU9OIGlzIE1ham9yLk1pbm9yIGFzIGEgTnVtYmVyLCBpZiBNaW5vciBpc24ndCBhdmFpbGFibGUsIHRoZW4gb25seSBNYWpvciBpcyByZXR1cm5lZFxuICB2YXIgbWF0Y2ggPSBVU0VSX0FHRU5ULm1hdGNoKC9BbmRyb2lkIChcXGQrKSg/OlxcLihcXGQrKSk/KD86XFwuKFxcZCspKSovaSk7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1ham9yID0gbWF0Y2hbMV0gJiYgcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciBtaW5vciA9IG1hdGNoWzJdICYmIHBhcnNlRmxvYXQobWF0Y2hbMl0pO1xuXG4gIGlmIChtYWpvciAmJiBtaW5vcikge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoWzFdICsgJy4nICsgbWF0Y2hbMl0pO1xuICB9IGVsc2UgaWYgKG1ham9yKSB7XG4gICAgcmV0dXJuIG1ham9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufSgpO1xuXG52YXIgSVNfTkFUSVZFX0FORFJPSUQgPSBJU19BTkRST0lEICYmIEFORFJPSURfVkVSU0lPTiA8IDUgJiYgYXBwbGVXZWJraXRWZXJzaW9uIDwgNTM3O1xuXG52YXIgSVNfRklSRUZPWCA9IC9GaXJlZm94L2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBJU19FREdFID0gL0VkZ2UvaS50ZXN0KFVTRVJfQUdFTlQpO1xudmFyIElTX0NIUk9NRSA9ICFJU19FREdFICYmICgvQ2hyb21lL2kudGVzdChVU0VSX0FHRU5UKSB8fCAvQ3JpT1MvaS50ZXN0KFVTRVJfQUdFTlQpKTtcbnZhciBDSFJPTUVfVkVSU0lPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1hdGNoID0gVVNFUl9BR0VOVC5tYXRjaCgvKENocm9tZXxDcmlPUylcXC8oXFxkKykvKTtcblxuICBpZiAobWF0Y2ggJiYgbWF0Y2hbMl0pIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsyXSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KCk7XG52YXIgSUVfVkVSU0lPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlc3VsdCA9IC9NU0lFXFxzKFxcZCspXFwuXFxkLy5leGVjKFVTRVJfQUdFTlQpO1xuICB2YXIgdmVyc2lvbiA9IHJlc3VsdCAmJiBwYXJzZUZsb2F0KHJlc3VsdFsxXSk7XG5cbiAgaWYgKCF2ZXJzaW9uICYmIC9UcmlkZW50XFwvNy4wL2kudGVzdChVU0VSX0FHRU5UKSAmJiAvcnY6MTEuMC8udGVzdChVU0VSX0FHRU5UKSkge1xuICAgIC8vIElFIDExIGhhcyBhIGRpZmZlcmVudCB1c2VyIGFnZW50IHN0cmluZyB0aGFuIG90aGVyIElFIHZlcnNpb25zXG4gICAgdmVyc2lvbiA9IDExLjA7XG4gIH1cblxuICByZXR1cm4gdmVyc2lvbjtcbn0oKTtcblxudmFyIElTX1NBRkFSSSA9IC9TYWZhcmkvaS50ZXN0KFVTRVJfQUdFTlQpICYmICFJU19DSFJPTUUgJiYgIUlTX0FORFJPSUQgJiYgIUlTX0VER0U7XG52YXIgSVNfQU5ZX1NBRkFSSSA9IChJU19TQUZBUkkgfHwgSVNfSU9TKSAmJiAhSVNfQ0hST01FO1xuXG52YXIgVE9VQ0hfRU5BQkxFRCA9IGlzUmVhbCgpICYmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3ckMSB8fCB3aW5kb3ckMS5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgd2luZG93JDEuRG9jdW1lbnRUb3VjaCAmJiB3aW5kb3ckMS5kb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdyQxLkRvY3VtZW50VG91Y2gpO1xuXG52YXIgYnJvd3NlciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgSVNfSVBBRDogSVNfSVBBRCxcbiAgSVNfSVBIT05FOiBJU19JUEhPTkUsXG4gIElTX0lQT0Q6IElTX0lQT0QsXG4gIElTX0lPUzogSVNfSU9TLFxuICBJT1NfVkVSU0lPTjogSU9TX1ZFUlNJT04sXG4gIElTX0FORFJPSUQ6IElTX0FORFJPSUQsXG4gIEFORFJPSURfVkVSU0lPTjogQU5EUk9JRF9WRVJTSU9OLFxuICBJU19OQVRJVkVfQU5EUk9JRDogSVNfTkFUSVZFX0FORFJPSUQsXG4gIElTX0ZJUkVGT1g6IElTX0ZJUkVGT1gsXG4gIElTX0VER0U6IElTX0VER0UsXG4gIElTX0NIUk9NRTogSVNfQ0hST01FLFxuICBDSFJPTUVfVkVSU0lPTjogQ0hST01FX1ZFUlNJT04sXG4gIElFX1ZFUlNJT046IElFX1ZFUlNJT04sXG4gIElTX1NBRkFSSTogSVNfU0FGQVJJLFxuICBJU19BTllfU0FGQVJJOiBJU19BTllfU0FGQVJJLFxuICBUT1VDSF9FTkFCTEVEOiBUT1VDSF9FTkFCTEVEXG59KTtcblxuLyoqXG4gKiBAZmlsZSB0aW1lLXJhbmdlcy5qc1xuICogQG1vZHVsZSB0aW1lLXJhbmdlc1xuICovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdGltZSBmb3IgdGhlIHNwZWNpZmllZCBpbmRleCBhdCB0aGUgc3RhcnQgb3IgZW5kXG4gKiBvZiBhIFRpbWVSYW5nZSBvYmplY3QuXG4gKlxuICogQGZ1bmN0aW9uIHRpbWUtcmFuZ2VzOmluZGV4RnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTBdXG4gKiAgICAgICAgVGhlIHJhbmdlIG51bWJlciB0byByZXR1cm4gdGhlIHRpbWUgZm9yLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHRpbWUgdGhhdCBvZmZzZXQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAqXG4gKiBAZGVwcmljYXRlZCBpbmRleCBtdXN0IGJlIHNldCB0byBhIHZhbHVlLCBpbiB0aGUgZnV0dXJlIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHJhbmdlcyBvZiB0aW1lIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVGltZVJhbmdlXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlbmd0aFxuICogICAgICAgICAgIFRoZSBudW1iZXIgb2YgdGltZSByYW5nZXMgcmVwcmVzZW50ZWQgYnkgdGhpcyBPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge3RpbWUtcmFuZ2VzOmluZGV4RnVuY3Rpb259IHN0YXJ0XG4gKiAgICAgICAgICAgUmV0dXJucyB0aGUgdGltZSBvZmZzZXQgYXQgd2hpY2ggYSBzcGVjaWZpZWQgdGltZSByYW5nZSBiZWdpbnMuXG4gKlxuICogQHByb3BlcnR5IHt0aW1lLXJhbmdlczppbmRleEZ1bmN0aW9ufSBlbmRcbiAqICAgICAgICAgICBSZXR1cm5zIHRoZSB0aW1lIG9mZnNldCBhdCB3aGljaCBhIHNwZWNpZmllZCB0aW1lIHJhbmdlIGVuZHMuXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGltZVJhbmdlc1xuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYW55IG9mIHRoZSB0aW1lIHJhbmdlcyBhcmUgb3ZlciB0aGUgbWF4aW11bSBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIG5hbWUgdG8gdXNlIGZvciBsb2dnaW5nXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiAgICAgICAgVGhlIGluZGV4IHRvIGNoZWNrXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEluZGV4XG4gKiAgICAgICAgVGhlIG1heGltdW0gcG9zc2libGUgaW5kZXhcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIHRpbWVSYW5nZXMgcHJvdmlkZWQgYXJlIG92ZXIgdGhlIG1heEluZGV4XG4gKi9cbmZ1bmN0aW9uIHJhbmdlQ2hlY2soZm5OYW1lLCBpbmRleCwgbWF4SW5kZXgpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicgfHwgaW5kZXggPCAwIHx8IGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIFxcJycgKyBmbk5hbWUgKyAnXFwnIG9uIFxcJ1RpbWVSYW5nZXNcXCc6IFRoZSBpbmRleCBwcm92aWRlZCAoJyArIGluZGV4ICsgJykgaXMgbm9uLW51bWVyaWMgb3Igb3V0IG9mIGJvdW5kcyAoMC0nICsgbWF4SW5kZXggKyAnKS4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgdGltZSBmb3IgdGhlIHNwZWNpZmllZCBpbmRleCBhdCB0aGUgc3RhcnQgb3IgZW5kXG4gKiBvZiBhIFRpbWVSYW5nZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICogICAgICAgIFRoZSBmdW5jdGlvbiBuYW1lIHRvIHVzZSBmb3IgbG9nZ2luZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUluZGV4XG4gKiAgICAgICAgVGhlIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2V0IHRoZSB0aW1lLiBzaG91bGQgYmUgJ3N0YXJ0JyBvciAnZW5kJ1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHJhbmdlc1xuICogICAgICAgIEFuIGFycmF5IG9mIHRpbWUgcmFuZ2VzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gW3JhbmdlSW5kZXg9MF1cbiAqICAgICAgICBUaGUgaW5kZXggdG8gc3RhcnQgdGhlIHNlYXJjaCBhdFxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHRpbWUgdGhhdCBvZmZzZXQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAqXG4gKlxuICogQGRlcHJpY2F0ZWQgcmFuZ2VJbmRleCBtdXN0IGJlIHNldCB0byBhIHZhbHVlLCBpbiB0aGUgZnV0dXJlIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiByYW5nZUluZGV4IGlzIG1vcmUgdGhhbiB0aGUgbGVuZ3RoIG9mIHJhbmdlc1xuICovXG5mdW5jdGlvbiBnZXRSYW5nZShmbk5hbWUsIHZhbHVlSW5kZXgsIHJhbmdlcywgcmFuZ2VJbmRleCkge1xuICByYW5nZUNoZWNrKGZuTmFtZSwgcmFuZ2VJbmRleCwgcmFuZ2VzLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gcmFuZ2VzW3JhbmdlSW5kZXhdW3ZhbHVlSW5kZXhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHRpbWUgcmFuZ2Ugb2JqZWN0IGdpdmVuIHJhbmdlcyBvZiB0aW1lLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IFtyYW5nZXNdXG4gKiAgICAgICAgQW4gYXJyYXkgb2YgdGltZSByYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVSYW5nZXNPYmoocmFuZ2VzKSB7XG4gIGlmIChyYW5nZXMgPT09IHVuZGVmaW5lZCB8fCByYW5nZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlbmd0aDogMCxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIFRpbWVSYW5nZXMgb2JqZWN0IGlzIGVtcHR5Jyk7XG4gICAgICB9LFxuICAgICAgZW5kOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBUaW1lUmFuZ2VzIG9iamVjdCBpcyBlbXB0eScpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsZW5ndGg6IHJhbmdlcy5sZW5ndGgsXG4gICAgc3RhcnQ6IGdldFJhbmdlLmJpbmQobnVsbCwgJ3N0YXJ0JywgMCwgcmFuZ2VzKSxcbiAgICBlbmQ6IGdldFJhbmdlLmJpbmQobnVsbCwgJ2VuZCcsIDEsIHJhbmdlcylcbiAgfTtcbn1cblxuLyoqXG4gKiBTaG91bGQgY3JlYXRlIGEgZmFrZSBgVGltZVJhbmdlYCBvYmplY3Qgd2hpY2ggbWltaWNzIGFuIEhUTUw1IHRpbWUgcmFuZ2UgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8QXJyYXl9IHN0YXJ0XG4gKiAgICAgICAgVGhlIHN0YXJ0IG9mIGEgc2luZ2xlIHJhbmdlIG9yIGFuIGFycmF5IG9mIHJhbmdlc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAqICAgICAgICBUaGUgZW5kIG9mIGEgc2luZ2xlIHJhbmdlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVSYW5nZXMoc3RhcnQsIGVuZCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdGFydCkpIHtcbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlc09iaihzdGFydCk7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzT2JqKCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXNPYmooW1tzdGFydCwgZW5kXV0pO1xufVxuXG4vKipcbiAqIEBmaWxlIGJ1ZmZlci5qc1xuICogQG1vZHVsZSBidWZmZXJcbiAqL1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIG1lZGlhIHRoYXQgaGFzIGJlZW4gYnVmZmVyZWQuXG4gKlxuICogQHBhcmFtIHtUaW1lUmFuZ2V9IGJ1ZmZlcmVkXG4gKiAgICAgICAgVGhlIGN1cnJlbnQgYFRpbWVSYW5nZWAgb2JqZWN0IHJlcHJlc2VudGluZyBidWZmZXJlZCB0aW1lIHJhbmdlc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuICogICAgICAgIFRvdGFsIGR1cmF0aW9uIG9mIHRoZSBtZWRpYVxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgUGVyY2VudCBidWZmZXJlZCBvZiB0aGUgdG90YWwgZHVyYXRpb24gaW4gZGVjaW1hbCBmb3JtLlxuICovXG5mdW5jdGlvbiBidWZmZXJlZFBlcmNlbnQoYnVmZmVyZWQsIGR1cmF0aW9uKSB7XG4gIHZhciBidWZmZXJlZER1cmF0aW9uID0gMDtcbiAgdmFyIHN0YXJ0ID0gdm9pZCAwO1xuICB2YXIgZW5kID0gdm9pZCAwO1xuXG4gIGlmICghZHVyYXRpb24pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmICghYnVmZmVyZWQgfHwgIWJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgIGJ1ZmZlcmVkID0gY3JlYXRlVGltZVJhbmdlcygwLCAwKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgIGVuZCA9IGJ1ZmZlcmVkLmVuZChpKTtcblxuICAgIC8vIGJ1ZmZlcmVkIGVuZCBjYW4gYmUgYmlnZ2VyIHRoYW4gZHVyYXRpb24gYnkgYSB2ZXJ5IHNtYWxsIGZyYWN0aW9uXG4gICAgaWYgKGVuZCA+IGR1cmF0aW9uKSB7XG4gICAgICBlbmQgPSBkdXJhdGlvbjtcbiAgICB9XG5cbiAgICBidWZmZXJlZER1cmF0aW9uICs9IGVuZCAtIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcmVkRHVyYXRpb24gLyBkdXJhdGlvbjtcbn1cblxuLyoqXG4gKiBAZmlsZSBmdWxsc2NyZWVuLWFwaS5qc1xuICogQG1vZHVsZSBmdWxsc2NyZWVuLWFwaVxuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIFN0b3JlIHRoZSBicm93c2VyLXNwZWNpZmljIG1ldGhvZHMgZm9yIHRoZSBmdWxsc2NyZWVuIEFQSS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHNlZSBbU3BlY2lmaWNhdGlvbl17QGxpbmsgaHR0cHM6Ly9mdWxsc2NyZWVuLnNwZWMud2hhdHdnLm9yZ31cbiAqIEBzZWUgW01hcCBBcHByb2FjaCBGcm9tIFNjcmVlbmZ1bGwuanNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvc2NyZWVuZnVsbC5qc31cbiAqL1xudmFyIEZ1bGxzY3JlZW5BcGkgPSB7fTtcblxuLy8gYnJvd3NlciBBUEkgbWV0aG9kc1xudmFyIGFwaU1hcCA9IFtbJ3JlcXVlc3RGdWxsc2NyZWVuJywgJ2V4aXRGdWxsc2NyZWVuJywgJ2Z1bGxzY3JlZW5FbGVtZW50JywgJ2Z1bGxzY3JlZW5FbmFibGVkJywgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCAnZnVsbHNjcmVlbmVycm9yJ10sXG4vLyBXZWJLaXRcblsnd2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4nLCAnd2Via2l0RXhpdEZ1bGxzY3JlZW4nLCAnd2Via2l0RnVsbHNjcmVlbkVsZW1lbnQnLCAnd2Via2l0RnVsbHNjcmVlbkVuYWJsZWQnLCAnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsICd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXSxcbi8vIE9sZCBXZWJLaXQgKFNhZmFyaSA1LjEpXG5bJ3dlYmtpdFJlcXVlc3RGdWxsU2NyZWVuJywgJ3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLCAnd2Via2l0Q3VycmVudEZ1bGxTY3JlZW5FbGVtZW50JywgJ3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLCAnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsICd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXSxcbi8vIE1vemlsbGFcblsnbW96UmVxdWVzdEZ1bGxTY3JlZW4nLCAnbW96Q2FuY2VsRnVsbFNjcmVlbicsICdtb3pGdWxsU2NyZWVuRWxlbWVudCcsICdtb3pGdWxsU2NyZWVuRW5hYmxlZCcsICdtb3pmdWxsc2NyZWVuY2hhbmdlJywgJ21vemZ1bGxzY3JlZW5lcnJvciddLFxuLy8gTWljcm9zb2Z0XG5bJ21zUmVxdWVzdEZ1bGxzY3JlZW4nLCAnbXNFeGl0RnVsbHNjcmVlbicsICdtc0Z1bGxzY3JlZW5FbGVtZW50JywgJ21zRnVsbHNjcmVlbkVuYWJsZWQnLCAnTVNGdWxsc2NyZWVuQ2hhbmdlJywgJ01TRnVsbHNjcmVlbkVycm9yJ11dO1xuXG52YXIgc3BlY0FwaSA9IGFwaU1hcFswXTtcbnZhciBicm93c2VyQXBpID0gdm9pZCAwO1xuXG4vLyBkZXRlcm1pbmUgdGhlIHN1cHBvcnRlZCBzZXQgb2YgZnVuY3Rpb25zXG5mb3IgKHZhciBpID0gMDsgaSA8IGFwaU1hcC5sZW5ndGg7IGkrKykge1xuICAvLyBjaGVjayBmb3IgZXhpdEZ1bGxzY3JlZW4gZnVuY3Rpb25cbiAgaWYgKGFwaU1hcFtpXVsxXSBpbiBkb2N1bWVudCkge1xuICAgIGJyb3dzZXJBcGkgPSBhcGlNYXBbaV07XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gbWFwIHRoZSBicm93c2VyIEFQSSBuYW1lcyB0byB0aGUgc3BlYyBBUEkgbmFtZXNcbmlmIChicm93c2VyQXBpKSB7XG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBicm93c2VyQXBpLmxlbmd0aDsgX2krKykge1xuICAgIEZ1bGxzY3JlZW5BcGlbc3BlY0FwaVtfaV1dID0gYnJvd3NlckFwaVtfaV07XG4gIH1cbn1cblxuLyoqXG4gKiBAZmlsZSBtZWRpYS1lcnJvci5qc1xuICovXG5cbi8qKlxuICogQSBDdXN0b20gYE1lZGlhRXJyb3JgIGNsYXNzIHdoaWNoIG1pbWljcyB0aGUgc3RhbmRhcmQgSFRNTDUgYE1lZGlhRXJyb3JgIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xPYmplY3R8TWVkaWFFcnJvcn0gdmFsdWVcbiAqICAgICAgICBUaGlzIGNhbiBiZSBvZiBtdWx0aXBsZSB0eXBlczpcbiAqICAgICAgICAtIG51bWJlcjogc2hvdWxkIGJlIGEgc3RhbmRhcmQgZXJyb3IgY29kZVxuICogICAgICAgIC0gc3RyaW5nOiBhbiBlcnJvciBtZXNzYWdlICh0aGUgY29kZSB3aWxsIGJlIDApXG4gKiAgICAgICAgLSBPYmplY3Q6IGFyYml0cmFyeSBwcm9wZXJ0aWVzXG4gKiAgICAgICAgLSBgTWVkaWFFcnJvcmAgKG5hdGl2ZSk6IHVzZWQgdG8gcG9wdWxhdGUgYSB2aWRlby5qcyBgTWVkaWFFcnJvcmAgb2JqZWN0XG4gKiAgICAgICAgLSBgTWVkaWFFcnJvcmAgKHZpZGVvLmpzKTogd2lsbCByZXR1cm4gaXRzZWxmIGlmIGl0J3MgYWxyZWFkeSBhXG4gKiAgICAgICAgICB2aWRlby5qcyBgTWVkaWFFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzZWUgW01lZGlhRXJyb3IgU3BlY117QGxpbmsgaHR0cHM6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMtYXV0aG9yLXZpZXcvdmlkZW8uaHRtbCNtZWRpYWVycm9yfVxuICogQHNlZSBbRW5jcnlwdGVkIE1lZGlhRXJyb3IgU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtZW5jcnlwdGVkLW1lZGlhLTIwMTMwNTEwLyNlcnJvci1jb2Rlc31cbiAqXG4gKiBAY2xhc3MgTWVkaWFFcnJvclxuICovXG5mdW5jdGlvbiBNZWRpYUVycm9yKHZhbHVlKSB7XG5cbiAgLy8gQWxsb3cgcmVkdW5kYW50IGNhbGxzIHRvIHRoaXMgY29uc3RydWN0b3IgdG8gYXZvaWQgaGF2aW5nIGBpbnN0YW5jZW9mYFxuICAvLyBjaGVja3MgcGVwcGVyZWQgYXJvdW5kIHRoZSBjb2RlLlxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNZWRpYUVycm9yKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLmNvZGUgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZGVmYXVsdCBjb2RlIGlzIHplcm8sIHNvIHRoaXMgaXMgYSBjdXN0b20gZXJyb3JcbiAgICB0aGlzLm1lc3NhZ2UgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcblxuICAgIC8vIFdlIGFzc2lnbiB0aGUgYGNvZGVgIHByb3BlcnR5IG1hbnVhbGx5IGJlY2F1c2UgbmF0aXZlIGBNZWRpYUVycm9yYCBvYmplY3RzXG4gICAgLy8gZG8gbm90IGV4cG9zZSBpdCBhcyBhbiBvd24vZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0LlxuICAgIGlmICh0eXBlb2YgdmFsdWUuY29kZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuY29kZSA9IHZhbHVlLmNvZGU7XG4gICAgfVxuXG4gICAgYXNzaWduKHRoaXMsIHZhbHVlKTtcbiAgfVxuXG4gIGlmICghdGhpcy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gTWVkaWFFcnJvci5kZWZhdWx0TWVzc2FnZXNbdGhpcy5jb2RlXSB8fCAnJztcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBlcnJvciBjb2RlIHRoYXQgcmVmZXJzIHR3byBvbmUgb2YgdGhlIGRlZmluZWQgYE1lZGlhRXJyb3JgIHR5cGVzXG4gKlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuTWVkaWFFcnJvci5wcm90b3R5cGUuY29kZSA9IDA7XG5cbi8qKlxuICogQW4gb3B0aW9uYWwgbWVzc2FnZSB0aGF0IHRvIHNob3cgd2l0aCB0aGUgZXJyb3IuIE1lc3NhZ2UgaXMgbm90IHBhcnQgb2YgdGhlIEhUTUw1XG4gKiB2aWRlbyBzcGVjIGJ1dCBhbGxvd3MgZm9yIG1vcmUgaW5mb3JtYXRpdmUgY3VzdG9tIGVycm9ycy5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5NZWRpYUVycm9yLnByb3RvdHlwZS5tZXNzYWdlID0gJyc7XG5cbi8qKlxuICogQW4gb3B0aW9uYWwgc3RhdHVzIGNvZGUgdGhhdCBjYW4gYmUgc2V0IGJ5IHBsdWdpbnMgdG8gYWxsb3cgZXZlbiBtb3JlIGRldGFpbCBhYm91dFxuICogdGhlIGVycm9yLiBGb3IgZXhhbXBsZSBhIHBsdWdpbiBtaWdodCBwcm92aWRlIGEgc3BlY2lmaWMgSFRUUCBzdGF0dXMgY29kZSBhbmQgYW5cbiAqIGVycm9yIG1lc3NhZ2UgZm9yIHRoYXQgY29kZS4gVGhlbiB3aGVuIHRoZSBwbHVnaW4gZ2V0cyB0aGF0IGVycm9yIHRoaXMgY2xhc3Mgd2lsbFxuICoga25vdyBob3cgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIGZvciBpdC4gVGhpcyBhbGxvd3MgYSBjdXN0b20gbWVzc2FnZSB0byBzaG93XG4gKiB1cCBvbiB0aGUgYFBsYXllcmAgZXJyb3Igb3ZlcmxheS5cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbk1lZGlhRXJyb3IucHJvdG90eXBlLnN0YXR1cyA9IG51bGw7XG5cbi8qKlxuICogRXJyb3JzIGluZGV4ZWQgYnkgdGhlIFczQyBzdGFuZGFyZC4gVGhlIG9yZGVyICoqQ0FOTk9UIENIQU5HRSoqISBTZWUgdGhlXG4gKiBzcGVjaWZpY2F0aW9uIGxpc3RlZCB1bmRlciB7QGxpbmsgTWVkaWFFcnJvcn0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGVudW0ge2FycmF5fVxuICogQHJlYWRvbmx5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gMCAtIE1FRElBX0VSUl9DVVNUT01cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAxIC0gTUVESUFfRVJSX0NVU1RPTVxuICogQHByb3BlcnR5IHtzdHJpbmd9IDIgLSBNRURJQV9FUlJfQUJPUlRFRFxuICogQHByb3BlcnR5IHtzdHJpbmd9IDMgLSBNRURJQV9FUlJfTkVUV09SS1xuICogQHByb3BlcnR5IHtzdHJpbmd9IDQgLSBNRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURURcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSA1IC0gTUVESUFfRVJSX0VOQ1JZUFRFRFxuICovXG5NZWRpYUVycm9yLmVycm9yVHlwZXMgPSBbJ01FRElBX0VSUl9DVVNUT00nLCAnTUVESUFfRVJSX0FCT1JURUQnLCAnTUVESUFfRVJSX05FVFdPUksnLCAnTUVESUFfRVJSX0RFQ09ERScsICdNRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURUQnLCAnTUVESUFfRVJSX0VOQ1JZUFRFRCddO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGBNZWRpYUVycm9yYCBtZXNzYWdlcyBiYXNlZCBvbiB0aGUge0BsaW5rIE1lZGlhRXJyb3IuZXJyb3JUeXBlc30uXG4gKlxuICogQHR5cGUge0FycmF5fVxuICogQGNvbnN0YW50XG4gKi9cbk1lZGlhRXJyb3IuZGVmYXVsdE1lc3NhZ2VzID0ge1xuICAxOiAnWW91IGFib3J0ZWQgdGhlIG1lZGlhIHBsYXliYWNrJyxcbiAgMjogJ0EgbmV0d29yayBlcnJvciBjYXVzZWQgdGhlIG1lZGlhIGRvd25sb2FkIHRvIGZhaWwgcGFydC13YXkuJyxcbiAgMzogJ1RoZSBtZWRpYSBwbGF5YmFjayB3YXMgYWJvcnRlZCBkdWUgdG8gYSBjb3JydXB0aW9uIHByb2JsZW0gb3IgYmVjYXVzZSB0aGUgbWVkaWEgdXNlZCBmZWF0dXJlcyB5b3VyIGJyb3dzZXIgZGlkIG5vdCBzdXBwb3J0LicsXG4gIDQ6ICdUaGUgbWVkaWEgY291bGQgbm90IGJlIGxvYWRlZCwgZWl0aGVyIGJlY2F1c2UgdGhlIHNlcnZlciBvciBuZXR3b3JrIGZhaWxlZCBvciBiZWNhdXNlIHRoZSBmb3JtYXQgaXMgbm90IHN1cHBvcnRlZC4nLFxuICA1OiAnVGhlIG1lZGlhIGlzIGVuY3J5cHRlZCBhbmQgd2UgZG8gbm90IGhhdmUgdGhlIGtleXMgdG8gZGVjcnlwdCBpdC4nXG59O1xuXG4vLyBBZGQgdHlwZXMgYXMgcHJvcGVydGllcyBvbiBNZWRpYUVycm9yXG4vLyBlLmcuIE1lZGlhRXJyb3IuTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEID0gNDtcbmZvciAodmFyIGVyck51bSA9IDA7IGVyck51bSA8IE1lZGlhRXJyb3IuZXJyb3JUeXBlcy5sZW5ndGg7IGVyck51bSsrKSB7XG4gIE1lZGlhRXJyb3JbTWVkaWFFcnJvci5lcnJvclR5cGVzW2Vyck51bV1dID0gZXJyTnVtO1xuICAvLyB2YWx1ZXMgc2hvdWxkIGJlIGFjY2Vzc2libGUgb24gYm90aCB0aGUgY2xhc3MgYW5kIGluc3RhbmNlXG4gIE1lZGlhRXJyb3IucHJvdG90eXBlW01lZGlhRXJyb3IuZXJyb3JUeXBlc1tlcnJOdW1dXSA9IGVyck51bTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGBQcm9taXNlYC1saWtlIChpLmUuIGhhcyBhIGB0aGVuYCBtZXRob2QpLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gIHZhbHVlXG4gKiAgICAgICAgIEFuIG9iamVjdCB0aGF0IG1heSBvciBtYXkgbm90IGJlIGBQcm9taXNlYC1saWtlLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYFByb21pc2VgLWxpa2UuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBTaWxlbmNlIGEgUHJvbWlzZS1saWtlIG9iamVjdC5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmcgbm9uLWhhcm1mdWwsIGJ1dCBwb3RlbnRpYWxseSBjb25mdXNpbmcgXCJ1bmNhdWdodFxuICogcGxheSBwcm9taXNlXCIgcmVqZWN0aW9uIGVycm9yIG1lc3NhZ2VzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdmFsdWVcbiAqICAgICAgICAgQW4gb2JqZWN0IHRoYXQgbWF5IG9yIG1heSBub3QgYmUgYFByb21pc2VgLWxpa2UuXG4gKi9cbmZ1bmN0aW9uIHNpbGVuY2VQcm9taXNlKHZhbHVlKSB7XG4gIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgdmFsdWUudGhlbihudWxsLCBmdW5jdGlvbiAoZSkge30pO1xuICB9XG59XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay1saXN0LWNvbnZlcnRlci5qcyBVdGlsaXRpZXMgZm9yIGNhcHR1cmluZyB0ZXh0IHRyYWNrIHN0YXRlIGFuZFxuICogcmUtY3JlYXRpbmcgdHJhY2tzIGJhc2VkIG9uIGEgY2FwdHVyZS5cbiAqXG4gKiBAbW9kdWxlIHRleHQtdHJhY2stbGlzdC1jb252ZXJ0ZXJcbiAqL1xuXG4vKipcbiAqIEV4YW1pbmUgYSBzaW5nbGUge0BsaW5rIFRleHRUcmFja30gYW5kIHJldHVybiBhIEpTT04tY29tcGF0aWJsZSBqYXZhc2NyaXB0IG9iamVjdCB0aGF0XG4gKiByZXByZXNlbnRzIHRoZSB7QGxpbmsgVGV4dFRyYWNrfSdzIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICogICAgICAgIFRoZSB0ZXh0IHRyYWNrIHRvIHF1ZXJ5LlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgQSBzZXJpYWxpemFibGUgamF2YXNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgVGV4dFRyYWNrLlxuICogQHByaXZhdGVcbiAqL1xudmFyIHRyYWNrVG9Kc29uXyA9IGZ1bmN0aW9uIHRyYWNrVG9Kc29uXyh0cmFjaykge1xuICB2YXIgcmV0ID0gWydraW5kJywgJ2xhYmVsJywgJ2xhbmd1YWdlJywgJ2lkJywgJ2luQmFuZE1ldGFkYXRhVHJhY2tEaXNwYXRjaFR5cGUnLCAnbW9kZScsICdzcmMnXS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcHJvcCwgaSkge1xuXG4gICAgaWYgKHRyYWNrW3Byb3BdKSB7XG4gICAgICBhY2NbcHJvcF0gPSB0cmFja1twcm9wXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7XG4gICAgY3VlczogdHJhY2suY3VlcyAmJiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwodHJhY2suY3VlcywgZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRUaW1lOiBjdWUuc3RhcnRUaW1lLFxuICAgICAgICBlbmRUaW1lOiBjdWUuZW5kVGltZSxcbiAgICAgICAgdGV4dDogY3VlLnRleHQsXG4gICAgICAgIGlkOiBjdWUuaWRcbiAgICAgIH07XG4gICAgfSlcbiAgfSk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogRXhhbWluZSBhIHtAbGluayBUZWNofSBhbmQgcmV0dXJuIGEgSlNPTi1jb21wYXRpYmxlIGphdmFzY3JpcHQgYXJyYXkgdGhhdCByZXByZXNlbnRzIHRoZVxuICogc3RhdGUgb2YgYWxsIHtAbGluayBUZXh0VHJhY2t9cyBjdXJyZW50bHkgY29uZmlndXJlZC4gVGhlIHJldHVybiBhcnJheSBpcyBjb21wYXRpYmxlIHdpdGhcbiAqIHtAbGluayB0ZXh0LXRyYWNrLWxpc3QtY29udmVydGVyOmpzb25Ub1RleHRUcmFja3N9LlxuICpcbiAqIEBwYXJhbSB7VGVjaH0gdGVjaFxuICogICAgICAgIFRoZSB0ZWNoIG9iamVjdCB0byBxdWVyeVxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBBIHNlcmlhbGl6YWJsZSBqYXZhc2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB7QGxpbmsgVGVjaH1zXG4gKiAgICAgICAgIHtAbGluayBUZXh0VHJhY2tMaXN0fS5cbiAqL1xudmFyIHRleHRUcmFja3NUb0pzb24gPSBmdW5jdGlvbiB0ZXh0VHJhY2tzVG9Kc29uKHRlY2gpIHtcblxuICB2YXIgdHJhY2tFbHMgPSB0ZWNoLiQkKCd0cmFjaycpO1xuXG4gIHZhciB0cmFja09ianMgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwodHJhY2tFbHMsIGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQudHJhY2s7XG4gIH0pO1xuICB2YXIgdHJhY2tzID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHRyYWNrRWxzLCBmdW5jdGlvbiAodHJhY2tFbCkge1xuICAgIHZhciBqc29uID0gdHJhY2tUb0pzb25fKHRyYWNrRWwudHJhY2spO1xuXG4gICAgaWYgKHRyYWNrRWwuc3JjKSB7XG4gICAgICBqc29uLnNyYyA9IHRyYWNrRWwuc3JjO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYWNrcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRlY2gudGV4dFRyYWNrcygpLCBmdW5jdGlvbiAodHJhY2spIHtcbiAgICByZXR1cm4gdHJhY2tPYmpzLmluZGV4T2YodHJhY2spID09PSAtMTtcbiAgfSkubWFwKHRyYWNrVG9Kc29uXykpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBzZXQgb2YgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9cyBvbiBhIHtAbGluayBUZWNofSBiYXNlZCBvbiBhbiBhcnJheSBvZiBqYXZhc2NyaXB0XG4gKiBvYmplY3Qge0BsaW5rIFRleHRUcmFja30gcmVwcmVzZW50YXRpb25zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGpzb25cbiAqICAgICAgICBBbiBhcnJheSBvZiBgVGV4dFRyYWNrYCByZXByZXNlbnRhdGlvbiBvYmplY3RzLCBsaWtlIHRob3NlIHRoYXQgd291bGQgYmVcbiAqICAgICAgICBwcm9kdWNlZCBieSBgdGV4dFRyYWNrc1RvSnNvbmAuXG4gKlxuICogQHBhcmFtIHtUZWNofSB0ZWNoXG4gKiAgICAgICAgVGhlIGBUZWNoYCB0byBjcmVhdGUgdGhlIGBUZXh0VHJhY2tgcyBvbi5cbiAqL1xudmFyIGpzb25Ub1RleHRUcmFja3MgPSBmdW5jdGlvbiBqc29uVG9UZXh0VHJhY2tzKGpzb24sIHRlY2gpIHtcbiAganNvbi5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgIHZhciBhZGRlZFRyYWNrID0gdGVjaC5hZGRSZW1vdGVUZXh0VHJhY2sodHJhY2spLnRyYWNrO1xuXG4gICAgaWYgKCF0cmFjay5zcmMgJiYgdHJhY2suY3Vlcykge1xuICAgICAgdHJhY2suY3Vlcy5mb3JFYWNoKGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZGVkVHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0ZWNoLnRleHRUcmFja3MoKTtcbn07XG5cbnZhciB0ZXh0VHJhY2tDb252ZXJ0ZXIgPSB7IHRleHRUcmFja3NUb0pzb246IHRleHRUcmFja3NUb0pzb24sIGpzb25Ub1RleHRUcmFja3M6IGpzb25Ub1RleHRUcmFja3MsIHRyYWNrVG9Kc29uXzogdHJhY2tUb0pzb25fIH07XG5cbi8qKlxuICogQGZpbGUgbW9kYWwtZGlhbG9nLmpzXG4gKi9cblxudmFyIE1PREFMX0NMQVNTX05BTUUgPSAndmpzLW1vZGFsLWRpYWxvZyc7XG52YXIgRVNDID0gMjc7XG5cbi8qKlxuICogVGhlIGBNb2RhbERpYWxvZ2AgZGlzcGxheXMgb3ZlciB0aGUgdmlkZW8gYW5kIGl0cyBjb250cm9scywgd2hpY2ggYmxvY2tzXG4gKiBpbnRlcmFjdGlvbiB3aXRoIHRoZSBwbGF5ZXIgdW50aWwgaXQgaXMgY2xvc2VkLlxuICpcbiAqIE1vZGFsIGRpYWxvZ3MgaW5jbHVkZSBhIFwiQ2xvc2VcIiBidXR0b24gYW5kIHdpbGwgY2xvc2Ugd2hlbiB0aGF0IGJ1dHRvblxuICogaXMgYWN0aXZhdGVkIC0gb3Igd2hlbiBFU0MgaXMgcHJlc3NlZCBhbnl3aGVyZS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTW9kYWxEaWFsb2cgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhNb2RhbERpYWxvZywgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gW29wdGlvbnMuY29udGVudD11bmRlZmluZWRdXG4gICAqICAgICAgICBQcm92aWRlIGN1c3RvbWl6ZWQgY29udGVudCBmb3IgdGhpcyBtb2RhbC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlc2NyaXB0aW9uXVxuICAgKiAgICAgICAgQSB0ZXh0IGRlc2NyaXB0aW9uIGZvciB0aGUgbW9kYWwsIHByaW1hcmlseSBmb3IgYWNjZXNzaWJpbGl0eS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5maWxsQWx3YXlzPWZhbHNlXVxuICAgKiAgICAgICAgTm9ybWFsbHksIG1vZGFscyBhcmUgYXV0b21hdGljYWxseSBmaWxsZWQgb25seSB0aGUgZmlyc3QgdGltZVxuICAgKiAgICAgICAgdGhleSBvcGVuLiBUaGlzIHRlbGxzIHRoZSBtb2RhbCB0byByZWZyZXNoIGl0cyBjb250ZW50XG4gICAqICAgICAgICBldmVyeSB0aW1lIGl0IG9wZW5zLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWxdXG4gICAqICAgICAgICBBIHRleHQgbGFiZWwgZm9yIHRoZSBtb2RhbCwgcHJpbWFyaWx5IGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRlbXBvcmFyeT10cnVlXVxuICAgKiAgICAgICAgSWYgYHRydWVgLCB0aGUgbW9kYWwgY2FuIG9ubHkgYmUgb3BlbmVkIG9uY2U7IGl0IHdpbGwgYmVcbiAgICogICAgICAgIGRpc3Bvc2VkIGFzIHNvb24gYXMgaXQncyBjbG9zZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudW5jbG9zZWFibGU9ZmFsc2VdXG4gICAqICAgICAgICBJZiBgdHJ1ZWAsIHRoZSB1c2VyIHdpbGwgbm90IGJlIGFibGUgdG8gY2xvc2UgdGhlIG1vZGFsXG4gICAqICAgICAgICB0aHJvdWdoIHRoZSBVSSBpbiB0aGUgbm9ybWFsIHdheXMuIFByb2dyYW1tYXRpYyBjbG9zaW5nIGlzXG4gICAqICAgICAgICBzdGlsbCBwb3NzaWJsZS5cbiAgICovXG4gIGZ1bmN0aW9uIE1vZGFsRGlhbG9nKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZGFsRGlhbG9nKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub3BlbmVkXyA9IF90aGlzLmhhc0JlZW5PcGVuZWRfID0gX3RoaXMuaGFzQmVlbkZpbGxlZF8gPSBmYWxzZTtcblxuICAgIF90aGlzLmNsb3NlYWJsZSghX3RoaXMub3B0aW9uc18udW5jbG9zZWFibGUpO1xuICAgIF90aGlzLmNvbnRlbnQoX3RoaXMub3B0aW9uc18uY29udGVudCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnRlbnRFbCBpcyBkZWZpbmVkIEFGVEVSIGFueSBjaGlsZHJlbiBhcmUgaW5pdGlhbGl6ZWRcbiAgICAvLyBiZWNhdXNlIHdlIG9ubHkgd2FudCB0aGUgY29udGVudHMgb2YgdGhlIG1vZGFsIGluIHRoZSBjb250ZW50RWxcbiAgICAvLyAobm90IHRoZSBVSSBlbGVtZW50cyBsaWtlIHRoZSBjbG9zZSBidXR0b24pLlxuICAgIF90aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiBNT0RBTF9DTEFTU19OQU1FICsgJy1jb250ZW50J1xuICAgIH0sIHtcbiAgICAgIHJvbGU6ICdkb2N1bWVudCdcbiAgICB9KTtcblxuICAgIF90aGlzLmRlc2NFbF8gPSBjcmVhdGVFbCgncCcsIHtcbiAgICAgIGNsYXNzTmFtZTogTU9EQUxfQ0xBU1NfTkFNRSArICctZGVzY3JpcHRpb24gdmpzLWNvbnRyb2wtdGV4dCcsXG4gICAgICBpZDogX3RoaXMuZWwoKS5nZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKVxuICAgIH0pO1xuXG4gICAgdGV4dENvbnRlbnQoX3RoaXMuZGVzY0VsXywgX3RoaXMuZGVzY3JpcHRpb24oKSk7XG4gICAgX3RoaXMuZWxfLmFwcGVuZENoaWxkKF90aGlzLmRlc2NFbF8pO1xuICAgIF90aGlzLmVsXy5hcHBlbmRDaGlsZChfdGhpcy5jb250ZW50RWxfKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgTW9kYWxEaWFsb2dgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgRE9NIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKCksXG4gICAgICB0YWJJbmRleDogLTFcbiAgICB9LCB7XG4gICAgICAnYXJpYS1kZXNjcmliZWRieSc6IHRoaXMuaWQoKSArICdfZGVzY3JpcHRpb24nLFxuICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnLFxuICAgICAgJ2FyaWEtbGFiZWwnOiB0aGlzLmxhYmVsKCksXG4gICAgICAncm9sZSc6ICdkaWFsb2cnXG4gICAgfSk7XG4gIH07XG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHRoaXMuY29udGVudEVsXyA9IG51bGw7XG4gICAgdGhpcy5kZXNjRWxfID0gbnVsbDtcbiAgICB0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8gPSBudWxsO1xuXG4gICAgX0NvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiBNT0RBTF9DTEFTU19OQU1FICsgJyB2anMtaGlkZGVuICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYGtleWRvd25gIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQsIGxvb2tpbmcgZm9yIEVTQywgd2hpY2ggY2xvc2VzXG4gICAqIHRoZSBtb2RhbC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZVxuICAgKiAgICAgICAgVGhlIGtleXByZXNzIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhlKSB7XG4gICAgaWYgKGUud2hpY2ggPT09IEVTQyAmJiB0aGlzLmNsb3NlYWJsZSgpKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYWJlbCBzdHJpbmcgZm9yIHRoaXMgbW9kYWwuIFByaW1hcmlseSB1c2VkIGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgdGhlIGxvY2FsaXplZCBvciByYXcgbGFiZWwgb2YgdGhpcyBtb2RhbC5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUubGFiZWwgPSBmdW5jdGlvbiBsYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGl6ZSh0aGlzLm9wdGlvbnNfLmxhYmVsIHx8ICdNb2RhbCBXaW5kb3cnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVzY3JpcHRpb24gc3RyaW5nIGZvciB0aGlzIG1vZGFsLiBQcmltYXJpbHkgdXNlZCBmb3JcbiAgICogYWNjZXNzaWJpbGl0eS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBsb2NhbGl6ZWQgb3IgcmF3IGRlc2NyaXB0aW9uIG9mIHRoaXMgbW9kYWwuXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmRlc2NyaXB0aW9uID0gZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgdmFyIGRlc2MgPSB0aGlzLm9wdGlvbnNfLmRlc2NyaXB0aW9uIHx8IHRoaXMubG9jYWxpemUoJ1RoaXMgaXMgYSBtb2RhbCB3aW5kb3cuJyk7XG5cbiAgICAvLyBBcHBlbmQgYSB1bml2ZXJzYWwgY2xvc2VhYmlsaXR5IG1lc3NhZ2UgaWYgdGhlIG1vZGFsIGlzIGNsb3NlYWJsZS5cbiAgICBpZiAodGhpcy5jbG9zZWFibGUoKSkge1xuICAgICAgZGVzYyArPSAnICcgKyB0aGlzLmxvY2FsaXplKCdUaGlzIG1vZGFsIGNhbiBiZSBjbG9zZWQgYnkgcHJlc3NpbmcgdGhlIEVzY2FwZSBrZXkgb3IgYWN0aXZhdGluZyB0aGUgY2xvc2UgYnV0dG9uLicpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjO1xuICB9O1xuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgbW9kYWwuXG4gICAqXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbG9wZW5cbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI21vZGFsb3BlblxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gb3BlbigpIHtcbiAgICBpZiAoIXRoaXMub3BlbmVkXykge1xuICAgICAgdmFyIHBsYXllciA9IHRoaXMucGxheWVyKCk7XG5cbiAgICAgIC8qKlxuICAgICAgICAqIEZpcmVkIGp1c3QgYmVmb3JlIGEgYE1vZGFsRGlhbG9nYCBpcyBvcGVuZWQuXG4gICAgICAgICpcbiAgICAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxvcGVuXG4gICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdiZWZvcmVtb2RhbG9wZW4nKTtcbiAgICAgIHRoaXMub3BlbmVkXyA9IHRydWU7XG5cbiAgICAgIC8vIEZpbGwgY29udGVudCBpZiB0aGUgbW9kYWwgaGFzIG5ldmVyIG9wZW5lZCBiZWZvcmUgYW5kXG4gICAgICAvLyBuZXZlciBiZWVuIGZpbGxlZC5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmZpbGxBbHdheXMgfHwgIXRoaXMuaGFzQmVlbk9wZW5lZF8gJiYgIXRoaXMuaGFzQmVlbkZpbGxlZF8pIHtcbiAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBwbGF5ZXIgd2FzIHBsYXlpbmcsIHBhdXNlIGl0IGFuZCB0YWtlIG5vdGUgb2YgaXRzIHByZXZpb3VzbHlcbiAgICAgIC8vIHBsYXlpbmcgc3RhdGUuXG4gICAgICB0aGlzLndhc1BsYXlpbmdfID0gIXBsYXllci5wYXVzZWQoKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9uc18ucGF1c2VPbk9wZW4gJiYgdGhpcy53YXNQbGF5aW5nXykge1xuICAgICAgICBwbGF5ZXIucGF1c2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2xvc2VhYmxlKCkpIHtcbiAgICAgICAgdGhpcy5vbih0aGlzLmVsXy5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIGJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICAgICAgfVxuXG4gICAgICAvLyBIaWRlIGNvbnRyb2xzIGFuZCBub3RlIGlmIHRoZXkgd2VyZSBlbmFibGVkLlxuICAgICAgdGhpcy5oYWRDb250cm9sc18gPSBwbGF5ZXIuY29udHJvbHMoKTtcbiAgICAgIHBsYXllci5jb250cm9scyhmYWxzZSk7XG5cbiAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgdGhpcy5jb25kaXRpb25hbEZvY3VzXygpO1xuICAgICAgdGhpcy5lbCgpLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgLyoqXG4gICAgICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgb3BlbmVkLlxuICAgICAgICAqXG4gICAgICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI21vZGFsb3BlblxuICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignbW9kYWxvcGVuJyk7XG4gICAgICB0aGlzLmhhc0JlZW5PcGVuZWRfID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElmIHRoZSBgTW9kYWxEaWFsb2dgIGlzIGN1cnJlbnRseSBvcGVuIG9yIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW3ZhbHVlXVxuICAgKiAgICAgICAgIElmIGdpdmVuLCBpdCB3aWxsIG9wZW4gKGB0cnVlYCkgb3IgY2xvc2UgKGBmYWxzZWApIHRoZSBtb2RhbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICB0aGUgY3VycmVudCBvcGVuIHN0YXRlIG9mIHRoZSBtb2RhbGRpYWxvZ1xuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5vcGVuZWQgPSBmdW5jdGlvbiBvcGVuZWQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXNbdmFsdWUgPyAnb3BlbicgOiAnY2xvc2UnXSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcGVuZWRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG1vZGFsLCBkb2VzIG5vdGhpbmcgaWYgdGhlIGBNb2RhbERpYWxvZ2AgaXNcbiAgICogbm90IG9wZW4uXG4gICAqXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGNsb3NlXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNtb2RhbGNsb3NlXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLm9wZW5lZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBsYXllciA9IHRoaXMucGxheWVyKCk7XG5cbiAgICAvKipcbiAgICAgICogRmlyZWQganVzdCBiZWZvcmUgYSBgTW9kYWxEaWFsb2dgIGlzIGNsb3NlZC5cbiAgICAgICpcbiAgICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsY2xvc2VcbiAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZW1vZGFsY2xvc2UnKTtcbiAgICB0aGlzLm9wZW5lZF8gPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLndhc1BsYXlpbmdfICYmIHRoaXMub3B0aW9uc18ucGF1c2VPbk9wZW4pIHtcbiAgICAgIHBsYXllci5wbGF5KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xvc2VhYmxlKCkpIHtcbiAgICAgIHRoaXMub2ZmKHRoaXMuZWxfLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFkQ29udHJvbHNfKSB7XG4gICAgICBwbGF5ZXIuY29udHJvbHModHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5oaWRlKCk7XG4gICAgdGhpcy5lbCgpLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgLyoqXG4gICAgICAqIEZpcmVkIGp1c3QgYWZ0ZXIgYSBgTW9kYWxEaWFsb2dgIGlzIGNsb3NlZC5cbiAgICAgICpcbiAgICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI21vZGFsY2xvc2VcbiAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ21vZGFsY2xvc2UnKTtcbiAgICB0aGlzLmNvbmRpdGlvbmFsQmx1cl8oKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnNfLnRlbXBvcmFyeSkge1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIGBNb2RhbERpYWxvZ2AgaXMgY2xvc2VhYmxlIHZpYSB0aGUgVUkuXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgICBJZiBnaXZlbiBhcyBhIGJvb2xlYW4sIGl0IHdpbGwgc2V0IHRoZSBgY2xvc2VhYmxlYCBvcHRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgUmV0dXJucyB0aGUgZmluYWwgdmFsdWUgb2YgdGhlIGNsb3NhYmxlIG9wdGlvbi5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuY2xvc2VhYmxlID0gZnVuY3Rpb24gY2xvc2VhYmxlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB2YXIgY2xvc2VhYmxlID0gdGhpcy5jbG9zZWFibGVfID0gISF2YWx1ZTtcbiAgICAgIHZhciBjbG9zZSA9IHRoaXMuZ2V0Q2hpbGQoJ2Nsb3NlQnV0dG9uJyk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYmVpbmcgbWFkZSBjbG9zZWFibGUgYW5kIGhhcyBubyBjbG9zZSBidXR0b24sIGFkZCBvbmUuXG4gICAgICBpZiAoY2xvc2VhYmxlICYmICFjbG9zZSkge1xuXG4gICAgICAgIC8vIFRoZSBjbG9zZSBidXR0b24gc2hvdWxkIGJlIGEgY2hpbGQgb2YgdGhlIG1vZGFsIC0gbm90IGl0c1xuICAgICAgICAvLyBjb250ZW50IGVsZW1lbnQsIHNvIHRlbXBvcmFyaWx5IGNoYW5nZSB0aGUgY29udGVudCBlbGVtZW50LlxuICAgICAgICB2YXIgdGVtcCA9IHRoaXMuY29udGVudEVsXztcblxuICAgICAgICB0aGlzLmNvbnRlbnRFbF8gPSB0aGlzLmVsXztcbiAgICAgICAgY2xvc2UgPSB0aGlzLmFkZENoaWxkKCdjbG9zZUJ1dHRvbicsIHsgY29udHJvbFRleHQ6ICdDbG9zZSBNb2RhbCBEaWFsb2cnIH0pO1xuICAgICAgICB0aGlzLmNvbnRlbnRFbF8gPSB0ZW1wO1xuICAgICAgICB0aGlzLm9uKGNsb3NlLCAnY2xvc2UnLCB0aGlzLmNsb3NlKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhpcyBpcyBiZWluZyBtYWRlIHVuY2xvc2VhYmxlIGFuZCBoYXMgYSBjbG9zZSBidXR0b24sIHJlbW92ZSBpdC5cbiAgICAgIGlmICghY2xvc2VhYmxlICYmIGNsb3NlKSB7XG4gICAgICAgIHRoaXMub2ZmKGNsb3NlLCAnY2xvc2UnLCB0aGlzLmNsb3NlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChjbG9zZSk7XG4gICAgICAgIGNsb3NlLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VhYmxlXztcbiAgfTtcblxuICAvKipcbiAgICogRmlsbCB0aGUgbW9kYWwncyBjb250ZW50IGVsZW1lbnQgd2l0aCB0aGUgbW9kYWwncyBcImNvbnRlbnRcIiBvcHRpb24uXG4gICAqIFRoZSBjb250ZW50IGVsZW1lbnQgd2lsbCBiZSBlbXB0aWVkIGJlZm9yZSB0aGlzIGNoYW5nZSB0YWtlcyBwbGFjZS5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwoKSB7XG4gICAgdGhpcy5maWxsV2l0aCh0aGlzLmNvbnRlbnQoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbGwgdGhlIG1vZGFsJ3MgY29udGVudCBlbGVtZW50IHdpdGggYXJiaXRyYXJ5IGNvbnRlbnQuXG4gICAqIFRoZSBjb250ZW50IGVsZW1lbnQgd2lsbCBiZSBlbXB0aWVkIGJlZm9yZSB0aGlzIGNoYW5nZSB0YWtlcyBwbGFjZS5cbiAgICpcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsZmlsbFxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjbW9kYWxmaWxsXG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFtjb250ZW50XVxuICAgKiAgICAgICAgVGhlIHNhbWUgcnVsZXMgYXBwbHkgdG8gdGhpcyBhcyBhcHBseSB0byB0aGUgYGNvbnRlbnRgIG9wdGlvbi5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZmlsbFdpdGggPSBmdW5jdGlvbiBmaWxsV2l0aChjb250ZW50KSB7XG4gICAgdmFyIGNvbnRlbnRFbCA9IHRoaXMuY29udGVudEVsKCk7XG4gICAgdmFyIHBhcmVudEVsID0gY29udGVudEVsLnBhcmVudE5vZGU7XG4gICAgdmFyIG5leHRTaWJsaW5nRWwgPSBjb250ZW50RWwubmV4dFNpYmxpbmc7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBhIGBNb2RhbERpYWxvZ2AgaXMgZmlsbGVkIHdpdGggY29udGVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGZpbGxcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmVtb2RhbGZpbGwnKTtcbiAgICB0aGlzLmhhc0JlZW5GaWxsZWRfID0gdHJ1ZTtcblxuICAgIC8vIERldGFjaCB0aGUgY29udGVudCBlbGVtZW50IGZyb20gdGhlIERPTSBiZWZvcmUgcGVyZm9ybWluZ1xuICAgIC8vIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBtb2RpZnlpbmcgdGhlIGxpdmUgRE9NIG11bHRpcGxlIHRpbWVzLlxuICAgIHBhcmVudEVsLnJlbW92ZUNoaWxkKGNvbnRlbnRFbCk7XG4gICAgdGhpcy5lbXB0eSgpO1xuICAgIGluc2VydENvbnRlbnQoY29udGVudEVsLCBjb250ZW50KTtcbiAgICAvKipcbiAgICAgKiBGaXJlZCBqdXN0IGFmdGVyIGEgYE1vZGFsRGlhbG9nYCBpcyBmaWxsZWQgd2l0aCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI21vZGFsZmlsbFxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ21vZGFsZmlsbCcpO1xuXG4gICAgLy8gUmUtaW5qZWN0IHRoZSByZS1maWxsZWQgY29udGVudCBlbGVtZW50LlxuICAgIGlmIChuZXh0U2libGluZ0VsKSB7XG4gICAgICBwYXJlbnRFbC5pbnNlcnRCZWZvcmUoY29udGVudEVsLCBuZXh0U2libGluZ0VsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQoY29udGVudEVsKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgY2xvc2UgYnV0dG9uIGlzIGxhc3QgaW4gdGhlIGRpYWxvZyBET01cbiAgICB2YXIgY2xvc2VCdXR0b24gPSB0aGlzLmdldENoaWxkKCdjbG9zZUJ1dHRvbicpO1xuXG4gICAgaWYgKGNsb3NlQnV0dG9uKSB7XG4gICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChjbG9zZUJ1dHRvbi5lbF8pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRW1wdGllcyB0aGUgY29udGVudCBlbGVtZW50LiBUaGlzIGhhcHBlbnMgYW55dGltZSB0aGUgbW9kYWwgaXMgZmlsbGVkLlxuICAgKlxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxlbXB0eVxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjbW9kYWxlbXB0eVxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIC8qKlxuICAgICAqIEZpcmVkIGp1c3QgYmVmb3JlIGEgYE1vZGFsRGlhbG9nYCBpcyBlbXB0aWVkLlxuICAgICAqXG4gICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsZW1wdHlcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmVtb2RhbGVtcHR5Jyk7XG4gICAgZW1wdHlFbCh0aGlzLmNvbnRlbnRFbCgpKTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGp1c3QgYWZ0ZXIgYSBgTW9kYWxEaWFsb2dgIGlzIGVtcHRpZWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjbW9kYWxlbXB0eVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ21vZGFsZW1wdHknKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBtb2RhbCBjb250ZW50LCB3aGljaCBnZXRzIG5vcm1hbGl6ZWQgYmVmb3JlIGJlaW5nXG4gICAqIHJlbmRlcmVkIGludG8gdGhlIERPTS5cbiAgICpcbiAgICogVGhpcyBkb2VzIG5vdCB1cGRhdGUgdGhlIERPTSBvciBmaWxsIHRoZSBtb2RhbCwgYnV0IGl0IGlzIGNhbGxlZCBkdXJpbmdcbiAgICogdGhhdCBwcm9jZXNzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtNaXhlZH0gW3ZhbHVlXVxuICAgKiAgICAgICAgIElmIGRlZmluZWQsIHNldHMgdGhlIGludGVybmFsIGNvbnRlbnQgdmFsdWUgdG8gYmUgdXNlZCBvbiB0aGVcbiAgICogICAgICAgICBuZXh0IGNhbGwocykgdG8gYGZpbGxgLiBUaGlzIHZhbHVlIGlzIG5vcm1hbGl6ZWQgYmVmb3JlIGJlaW5nXG4gICAqICAgICAgICAgaW5zZXJ0ZWQuIFRvIFwiY2xlYXJcIiB0aGUgaW50ZXJuYWwgY29udGVudCB2YWx1ZSwgcGFzcyBgbnVsbGAuXG4gICAqXG4gICAqIEByZXR1cm4ge01peGVkfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGNvbnRlbnQgb2YgdGhlIG1vZGFsIGRpYWxvZ1xuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gY29udGVudCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmNvbnRlbnRfID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBjb25kaXRpb25hbGx5IGZvY3VzIHRoZSBtb2RhbCBkaWFsb2cgaWYgZm9jdXMgd2FzIHByZXZpb3VzbHkgb24gdGhlIHBsYXllci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuY29uZGl0aW9uYWxGb2N1c18gPSBmdW5jdGlvbiBjb25kaXRpb25hbEZvY3VzXygpIHtcbiAgICB2YXIgYWN0aXZlRWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIHZhciBwbGF5ZXJFbCA9IHRoaXMucGxheWVyXy5lbF87XG5cbiAgICB0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8gPSBudWxsO1xuXG4gICAgaWYgKHBsYXllckVsLmNvbnRhaW5zKGFjdGl2ZUVsKSB8fCBwbGF5ZXJFbCA9PT0gYWN0aXZlRWwpIHtcbiAgICAgIHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXyA9IGFjdGl2ZUVsO1xuXG4gICAgICB0aGlzLmZvY3VzKCk7XG5cbiAgICAgIHRoaXMub24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGNvbmRpdGlvbmFsbHkgYmx1ciB0aGUgZWxlbWVudCBhbmQgcmVmb2N1cyB0aGUgbGFzdCBmb2N1c2VkIGVsZW1lbnRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuY29uZGl0aW9uYWxCbHVyXyA9IGZ1bmN0aW9uIGNvbmRpdGlvbmFsQmx1cl8oKSB7XG4gICAgaWYgKHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXykge1xuICAgICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfLmZvY3VzKCk7XG4gICAgICB0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMub2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEtleWRvd24gaGFuZGxlci4gQXR0YWNoZWQgd2hlbiBtb2RhbCBpcyBmb2N1c2VkLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmhhbmRsZUtleURvd24gPSBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgLy8gZXhpdCBlYXJseSBpZiBpdCBpc24ndCBhIHRhYiBrZXlcbiAgICBpZiAoZXZlbnQud2hpY2ggIT09IDkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZm9jdXNhYmxlRWxzID0gdGhpcy5mb2N1c2FibGVFbHNfKCk7XG4gICAgdmFyIGFjdGl2ZUVsID0gdGhpcy5lbF8ucXVlcnlTZWxlY3RvcignOmZvY3VzJyk7XG4gICAgdmFyIGZvY3VzSW5kZXggPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvY3VzYWJsZUVscy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdGl2ZUVsID09PSBmb2N1c2FibGVFbHNbaV0pIHtcbiAgICAgICAgZm9jdXNJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLmVsXykge1xuICAgICAgZm9jdXNJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIGZvY3VzSW5kZXggPT09IDApIHtcbiAgICAgIGZvY3VzYWJsZUVsc1tmb2N1c2FibGVFbHMubGVuZ3RoIC0gMV0uZm9jdXMoKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICghZXZlbnQuc2hpZnRLZXkgJiYgZm9jdXNJbmRleCA9PT0gZm9jdXNhYmxlRWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGZvY3VzYWJsZUVsc1swXS5mb2N1cygpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGdldCBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmZvY3VzYWJsZUVsc18gPSBmdW5jdGlvbiBmb2N1c2FibGVFbHNfKCkge1xuICAgIHZhciBhbGxDaGlsZHJlbiA9IHRoaXMuZWxfLnF1ZXJ5U2VsZWN0b3JBbGwoJyonKTtcblxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoYWxsQ2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIChjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdyQxLkhUTUxBbmNob3JFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93JDEuSFRNTEFyZWFFbGVtZW50KSAmJiBjaGlsZC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKSB8fCAoY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3ckMS5IVE1MSW5wdXRFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93JDEuSFRNTFNlbGVjdEVsZW1lbnQgfHwgY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3ckMS5IVE1MVGV4dEFyZWFFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93JDEuSFRNTEJ1dHRvbkVsZW1lbnQpICYmICFjaGlsZC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3ckMS5IVE1MSUZyYW1lRWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdyQxLkhUTUxPYmplY3RFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93JDEuSFRNTEVtYmVkRWxlbWVudCB8fCBjaGlsZC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykgJiYgY2hpbGQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpICE9PSAtMSB8fCBjaGlsZC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBNb2RhbERpYWxvZztcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBNb2RhbERpYWxvZ2AgZGVmYXVsdCBvcHRpb25zLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuTW9kYWxEaWFsb2cucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBwYXVzZU9uT3BlbjogdHJ1ZSxcbiAgdGVtcG9yYXJ5OiB0cnVlXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01vZGFsRGlhbG9nJywgTW9kYWxEaWFsb2cpO1xuXG4vKipcbiAqIEBmaWxlIHRyYWNrLWxpc3QuanNcbiAqL1xuXG4vKipcbiAqIENvbW1vbiBmdW5jdGlvbmFsaXkgYmV0d2VlbiB7QGxpbmsgVGV4dFRyYWNrTGlzdH0sIHtAbGluayBBdWRpb1RyYWNrTGlzdH0sIGFuZFxuICoge0BsaW5rIFZpZGVvVHJhY2tMaXN0fVxuICpcbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gKi9cblxudmFyIFRyYWNrTGlzdCA9IGZ1bmN0aW9uIChfRXZlbnRUYXJnZXQpIHtcbiAgaW5oZXJpdHMoVHJhY2tMaXN0LCBfRXZlbnRUYXJnZXQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge1RyYWNrW119IHRyYWNrc1xuICAgKiAgICAgICAgQSBsaXN0IG9mIHRyYWNrcyB0byBpbml0aWFsaXplIHRoZSBsaXN0IHdpdGguXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZnVuY3Rpb24gVHJhY2tMaXN0KCkge1xuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNrTGlzdCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudFRhcmdldC5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLnRyYWNrc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUcmFja0xpc3RcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGxlbmd0aFxuICAgICAqICAgICAgICAgVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGBUcmFja2BzIGluIHRoZSB0aGlzIFRyYWNraXN0LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgJ2xlbmd0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFja3NfLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBfdGhpcy5hZGRUcmFjayh0cmFja3NbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEge0BsaW5rIFRyYWNrfSB0byB0aGUgYFRyYWNrTGlzdGBcbiAgICpcbiAgICogQHBhcmFtIHtUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSBhdWRpbywgdmlkZW8sIG9yIHRleHQgdHJhY2sgdG8gYWRkIHRvIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I2FkZHRyYWNrXG4gICAqL1xuXG5cbiAgVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy50cmFja3NfLmxlbmd0aDtcblxuICAgIGlmICghKCcnICsgaW5kZXggaW4gdGhpcykpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbmRleCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFja3NfW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGFkZCBkdXBsaWNhdGUgdHJhY2tzXG4gICAgaWYgKHRoaXMudHJhY2tzXy5pbmRleE9mKHRyYWNrKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudHJhY2tzXy5wdXNoKHRyYWNrKTtcbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlcmVkIHdoZW4gYSB0cmFjayBpcyBhZGRlZCB0byBhIHRyYWNrIGxpc3QuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IFRyYWNrTGlzdCNhZGR0cmFja1xuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICogQHByb3BlcnR5IHtUcmFja30gdHJhY2tcbiAgICAgICAqICAgICAgICAgICBBIHJlZmVyZW5jZSB0byB0cmFjayB0aGF0IHdhcyBhZGRlZC5cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKHtcbiAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICB0eXBlOiAnYWRkdHJhY2snXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHtAbGluayBUcmFja30gZnJvbSB0aGUgYFRyYWNrTGlzdGBcbiAgICpcbiAgICogQHBhcmFtIHtUcmFja30gcnRyYWNrXG4gICAqICAgICAgICBUaGUgYXVkaW8sIHZpZGVvLCBvciB0ZXh0IHRyYWNrIHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I3JlbW92ZXRyYWNrXG4gICAqL1xuXG5cbiAgVHJhY2tMaXN0LnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHJ0cmFjaykge1xuICAgIHZhciB0cmFjayA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0aGlzW2ldID09PSBydHJhY2spIHtcbiAgICAgICAgdHJhY2sgPSB0aGlzW2ldO1xuICAgICAgICBpZiAodHJhY2sub2ZmKSB7XG4gICAgICAgICAgdHJhY2sub2ZmKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyYWNrc18uc3BsaWNlKGksIDEpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRyYWNrIGlzIHJlbW92ZWQgZnJvbSB0cmFjayBsaXN0LlxuICAgICAqXG4gICAgICogQGV2ZW50IFRyYWNrTGlzdCNyZW1vdmV0cmFja1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKiBAcHJvcGVydHkge1RyYWNrfSB0cmFja1xuICAgICAqICAgICAgICAgICBBIHJlZmVyZW5jZSB0byB0cmFjayB0aGF0IHdhcyByZW1vdmVkLlxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcih7XG4gICAgICB0cmFjazogdHJhY2ssXG4gICAgICB0eXBlOiAncmVtb3ZldHJhY2snXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIFRyYWNrIGZyb20gdGhlIFRyYWNrTGlzdCBieSBhIHRyYWNrcyBpZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSB0aGUgaWQgb2YgdGhlIHRyYWNrIHRvIGdldFxuICAgKiBAbWV0aG9kIGdldFRyYWNrQnlJZFxuICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUcmFja0xpc3QucHJvdG90eXBlLmdldFRyYWNrQnlJZCA9IGZ1bmN0aW9uIGdldFRyYWNrQnlJZChpZCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdGhpc1tpXTtcblxuICAgICAgaWYgKHRyYWNrLmlkID09PSBpZCkge1xuICAgICAgICByZXN1bHQgPSB0cmFjaztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gVHJhY2tMaXN0O1xufShFdmVudFRhcmdldCk7XG5cbi8qKlxuICogVHJpZ2dlcmVkIHdoZW4gYSBkaWZmZXJlbnQgdHJhY2sgaXMgc2VsZWN0ZWQvZW5hYmxlZC5cbiAqXG4gKiBAZXZlbnQgVHJhY2tMaXN0I2NoYW5nZVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogRXZlbnRzIHRoYXQgY2FuIGJlIGNhbGxlZCB3aXRoIG9uICsgZXZlbnROYW1lLiBTZWUge0BsaW5rIEV2ZW50SGFuZGxlcn0uXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFRyYWNrTGlzdCNhbGxvd2VkRXZlbnRzX1xuICogQHByaXZhdGVcbiAqL1xuXG5cblRyYWNrTGlzdC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7XG4gIGNoYW5nZTogJ2NoYW5nZScsXG4gIGFkZHRyYWNrOiAnYWRkdHJhY2snLFxuICByZW1vdmV0cmFjazogJ3JlbW92ZXRyYWNrJ1xufTtcblxuLy8gZW11bGF0ZSBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIHN1cHBvcnQgdG8gYWxsb3cgZm9yIGZlYXR1cmUgZGV0ZWN0aW9uXG5mb3IgKHZhciBldmVudCBpbiBUcmFja0xpc3QucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfKSB7XG4gIFRyYWNrTGlzdC5wcm90b3R5cGVbJ29uJyArIGV2ZW50XSA9IG51bGw7XG59XG5cbi8qKlxuICogQGZpbGUgYXVkaW8tdHJhY2stbGlzdC5qc1xuICovXG5cbi8qKlxuICogQW55d2hlcmUgd2UgY2FsbCB0aGlzIGZ1bmN0aW9uIHdlIGRpdmVyZ2UgZnJvbSB0aGUgc3BlY1xuICogYXMgd2Ugb25seSBzdXBwb3J0IG9uZSBlbmFibGVkIGF1ZGlvdHJhY2sgYXQgYSB0aW1lXG4gKlxuICogQHBhcmFtIHtBdWRpb1RyYWNrTGlzdH0gbGlzdFxuICogICAgICAgIGxpc3QgdG8gd29yayBvblxuICpcbiAqIEBwYXJhbSB7QXVkaW9UcmFja30gdHJhY2tcbiAqICAgICAgICBUaGUgdHJhY2sgdG8gc2tpcFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBkaXNhYmxlT3RoZXJzID0gZnVuY3Rpb24gZGlzYWJsZU90aGVycyhsaXN0LCB0cmFjaykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5rZXlzKGxpc3RbaV0pLmxlbmd0aCB8fCB0cmFjay5pZCA9PT0gbGlzdFtpXS5pZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGFub3RoZXIgYXVkaW8gdHJhY2sgaXMgZW5hYmxlZCwgZGlzYWJsZSBpdFxuICAgIGxpc3RbaV0uZW5hYmxlZCA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIEF1ZGlvVHJhY2t9IGZvciBhIG1lZGlhIGZpbGUuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2F1ZGlvdHJhY2tsaXN0fVxuICogQGV4dGVuZHMgVHJhY2tMaXN0XG4gKi9cblxudmFyIEF1ZGlvVHJhY2tMaXN0ID0gZnVuY3Rpb24gKF9UcmFja0xpc3QpIHtcbiAgaW5oZXJpdHMoQXVkaW9UcmFja0xpc3QsIF9UcmFja0xpc3QpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtBdWRpb1RyYWNrW119IFt0cmFja3M9W11dXG4gICAqICAgICAgICBBIGxpc3Qgb2YgYEF1ZGlvVHJhY2tgIHRvIGluc3RhbnRpYXRlIHRoZSBsaXN0IHdpdGguXG4gICAqL1xuICBmdW5jdGlvbiBBdWRpb1RyYWNrTGlzdCgpIHtcbiAgICB2YXIgdHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1RyYWNrTGlzdCk7XG5cbiAgICAvLyBtYWtlIHN1cmUgb25seSAxIHRyYWNrIGlzIGVuYWJsZWRcbiAgICAvLyBzb3J0ZWQgZnJvbSBsYXN0IGluZGV4IHRvIGZpcnN0IGluZGV4XG4gICAgZm9yICh2YXIgaSA9IHRyYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRyYWNrc1tpXS5lbmFibGVkKSB7XG4gICAgICAgIGRpc2FibGVPdGhlcnModHJhY2tzLCB0cmFja3NbaV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0xpc3QuY2FsbCh0aGlzLCB0cmFja3MpKTtcblxuICAgIF90aGlzLmNoYW5naW5nXyA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4ge0BsaW5rIEF1ZGlvVHJhY2t9IHRvIHRoZSBgQXVkaW9UcmFja0xpc3RgLlxuICAgKlxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgQXVkaW9UcmFjayB0byBhZGQgdG8gdGhlIGxpc3RcbiAgICpcbiAgICogQGZpcmVzIFRyYWNrTGlzdCNhZGR0cmFja1xuICAgKi9cblxuXG4gIEF1ZGlvVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAodHJhY2suZW5hYmxlZCkge1xuICAgICAgZGlzYWJsZU90aGVycyh0aGlzLCB0cmFjayk7XG4gICAgfVxuXG4gICAgX1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjayk7XG4gICAgLy8gbmF0aXZlIHRyYWNrcyBkb24ndCBoYXZlIHRoaXNcbiAgICBpZiAoIXRyYWNrLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGlzdGVucyBBdWRpb1RyYWNrI2VuYWJsZWRjaGFuZ2VcbiAgICAgKiBAZmlyZXMgVHJhY2tMaXN0I2NoYW5nZVxuICAgICAqL1xuICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuYWJsZWRjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB3aGVuIHdlIGFyZSBkaXNhYmxpbmcgb3RoZXIgdHJhY2tzIChzaW5jZSB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtb3JlIHRoYW4gb25lIHRyYWNrIGF0IGEgdGltZSkgd2Ugd2lsbCBzZXQgY2hhbmdpbmdfXG4gICAgICAvLyB0byB0cnVlIHNvIHRoYXQgd2UgZG9uJ3QgdHJpZ2dlciBhZGRpdGlvbmFsIGNoYW5nZSBldmVudHNcbiAgICAgIGlmIChfdGhpczIuY2hhbmdpbmdfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF90aGlzMi5jaGFuZ2luZ18gPSB0cnVlO1xuICAgICAgZGlzYWJsZU90aGVycyhfdGhpczIsIHRyYWNrKTtcbiAgICAgIF90aGlzMi5jaGFuZ2luZ18gPSBmYWxzZTtcbiAgICAgIF90aGlzMi50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQXVkaW9UcmFja0xpc3Q7XG59KFRyYWNrTGlzdCk7XG5cbi8qKlxuICogQGZpbGUgdmlkZW8tdHJhY2stbGlzdC5qc1xuICovXG5cbi8qKlxuICogVW4tc2VsZWN0IGFsbCBvdGhlciB7QGxpbmsgVmlkZW9UcmFja31zIHRoYXQgYXJlIHNlbGVjdGVkLlxuICpcbiAqIEBwYXJhbSB7VmlkZW9UcmFja0xpc3R9IGxpc3RcbiAqICAgICAgICBsaXN0IHRvIHdvcmsgb25cbiAqXG4gKiBAcGFyYW0ge1ZpZGVvVHJhY2t9IHRyYWNrXG4gKiAgICAgICAgVGhlIHRyYWNrIHRvIHNraXBcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZGlzYWJsZU90aGVycyQxID0gZnVuY3Rpb24gZGlzYWJsZU90aGVycyhsaXN0LCB0cmFjaykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5rZXlzKGxpc3RbaV0pLmxlbmd0aCB8fCB0cmFjay5pZCA9PT0gbGlzdFtpXS5pZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGFub3RoZXIgdmlkZW8gdHJhY2sgaXMgZW5hYmxlZCwgZGlzYWJsZSBpdFxuICAgIGxpc3RbaV0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBWaWRlb1RyYWNrfSBmb3IgYSB2aWRlby5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdmlkZW90cmFja2xpc3R9XG4gKiBAZXh0ZW5kcyBUcmFja0xpc3RcbiAqL1xuXG52YXIgVmlkZW9UcmFja0xpc3QgPSBmdW5jdGlvbiAoX1RyYWNrTGlzdCkge1xuICBpbmhlcml0cyhWaWRlb1RyYWNrTGlzdCwgX1RyYWNrTGlzdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1ZpZGVvVHJhY2tbXX0gW3RyYWNrcz1bXV1cbiAgICogICAgICAgIEEgbGlzdCBvZiBgVmlkZW9UcmFja2AgdG8gaW5zdGFudGlhdGUgdGhlIGxpc3Qgd2l0aC5cbiAgICovXG4gIGZ1bmN0aW9uIFZpZGVvVHJhY2tMaXN0KCkge1xuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvVHJhY2tMaXN0KTtcblxuICAgIC8vIG1ha2Ugc3VyZSBvbmx5IDEgdHJhY2sgaXMgZW5hYmxlZFxuICAgIC8vIHNvcnRlZCBmcm9tIGxhc3QgaW5kZXggdG8gZmlyc3QgaW5kZXhcbiAgICBmb3IgKHZhciBpID0gdHJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodHJhY2tzW2ldLnNlbGVjdGVkKSB7XG4gICAgICAgIGRpc2FibGVPdGhlcnMkMSh0cmFja3MsIHRyYWNrc1tpXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrTGlzdC5jYWxsKHRoaXMsIHRyYWNrcykpO1xuXG4gICAgX3RoaXMuY2hhbmdpbmdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFZpZGVvVHJhY2tMaXN0I3NlbGVjdGVkSW5kZXhcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBzZWxlY3RlZCB7QGxpbmsgVmlkZW9UcmFja2B9LlxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgJ3NlbGVjdGVkSW5kZXgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXNbX2ldLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gX2k7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHtAbGluayBWaWRlb1RyYWNrfSB0byB0aGUgYFZpZGVvVHJhY2tMaXN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtWaWRlb1RyYWNrfSB0cmFja1xuICAgKiAgICAgICAgVGhlIFZpZGVvVHJhY2sgdG8gYWRkIHRvIHRoZSBsaXN0XG4gICAqXG4gICAqIEBmaXJlcyBUcmFja0xpc3QjYWRkdHJhY2tcbiAgICovXG5cblxuICBWaWRlb1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKHRyYWNrLnNlbGVjdGVkKSB7XG4gICAgICBkaXNhYmxlT3RoZXJzJDEodGhpcywgdHJhY2spO1xuICAgIH1cblxuICAgIF9UcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrLmNhbGwodGhpcywgdHJhY2spO1xuICAgIC8vIG5hdGl2ZSB0cmFja3MgZG9uJ3QgaGF2ZSB0aGlzXG4gICAgaWYgKCF0cmFjay5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpc3RlbnMgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZVxuICAgICAqIEBmaXJlcyBUcmFja0xpc3QjY2hhbmdlXG4gICAgICovXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0ZWRjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMyLmNoYW5naW5nXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfdGhpczIuY2hhbmdpbmdfID0gdHJ1ZTtcbiAgICAgIGRpc2FibGVPdGhlcnMkMShfdGhpczIsIHRyYWNrKTtcbiAgICAgIF90aGlzMi5jaGFuZ2luZ18gPSBmYWxzZTtcbiAgICAgIF90aGlzMi50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVmlkZW9UcmFja0xpc3Q7XG59KFRyYWNrTGlzdCk7XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay1saXN0LmpzXG4gKi9cblxuLyoqXG4gKiBUaGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBUZXh0VHJhY2t9IGZvciBhIG1lZGlhIGZpbGUuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja2xpc3R9XG4gKiBAZXh0ZW5kcyBUcmFja0xpc3RcbiAqL1xuXG52YXIgVGV4dFRyYWNrTGlzdCA9IGZ1bmN0aW9uIChfVHJhY2tMaXN0KSB7XG4gIGluaGVyaXRzKFRleHRUcmFja0xpc3QsIF9UcmFja0xpc3QpO1xuXG4gIGZ1bmN0aW9uIFRleHRUcmFja0xpc3QoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrTGlzdCk7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrTGlzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB7QGxpbmsgVGV4dFRyYWNrfSB0byB0aGUgYFRleHRUcmFja0xpc3RgXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICAgKiAgICAgICAgVGhlIHRleHQgdHJhY2sgdG8gYWRkIHRvIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I2FkZHRyYWNrXG4gICAqL1xuICBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgX1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjayk7XG5cbiAgICAvKipcbiAgICAgKiBAbGlzdGVucyBUZXh0VHJhY2sjbW9kZWNoYW5nZVxuICAgICAqIEBmaXJlcyBUcmFja0xpc3QjY2hhbmdlXG4gICAgICovXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIGJpbmQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICB9KSk7XG5cbiAgICB2YXIgbm9uTGFuZ3VhZ2VUZXh0VHJhY2tLaW5kID0gWydtZXRhZGF0YScsICdjaGFwdGVycyddO1xuXG4gICAgaWYgKG5vbkxhbmd1YWdlVGV4dFRyYWNrS2luZC5pbmRleE9mKHRyYWNrLmtpbmQpID09PSAtMSkge1xuICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIGJpbmQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdGVkbGFuZ3VhZ2VjaGFuZ2UnKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja0xpc3Q7XG59KFRyYWNrTGlzdCk7XG5cbi8qKlxuICogQGZpbGUgaHRtbC10cmFjay1lbGVtZW50LWxpc3QuanNcbiAqL1xuXG4vKipcbiAqIFRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIEh0bWxUcmFja0VsZW1lbnR9cy5cbiAqL1xudmFyIEh0bWxUcmFja0VsZW1lbnRMaXN0ID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtIdG1sVHJhY2tFbGVtZW50W119IFt0cmFja3M9W11dXG4gICAqICAgICAgICBBIGxpc3Qgb2YgYEh0bWxUcmFja0VsZW1lbnRgIHRvIGluc3RhbnRpYXRlIHRoZSBsaXN0IHdpdGguXG4gICAqL1xuICBmdW5jdGlvbiBIdG1sVHJhY2tFbGVtZW50TGlzdCgpIHtcbiAgICB2YXIgdHJhY2tFbGVtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSHRtbFRyYWNrRWxlbWVudExpc3QpO1xuXG4gICAgdGhpcy50cmFja0VsZW1lbnRzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIEh0bWxUcmFja0VsZW1lbnRMaXN0XG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IG51bWJlciBvZiBgVHJhY2tgcyBpbiB0aGUgdGhpcyBUcmFja2lzdC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2xlbmd0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFja0VsZW1lbnRzXy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdHJhY2tFbGVtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hZGRUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudHNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4ge0BsaW5rIEh0bWxUcmFja0VsZW1lbnR9IHRvIHRoZSBgSHRtbFRyYWNrRWxlbWVudExpc3RgXG4gICAqXG4gICAqIEBwYXJhbSB7SHRtbFRyYWNrRWxlbWVudH0gdHJhY2tFbGVtZW50XG4gICAqICAgICAgICBUaGUgdHJhY2sgZWxlbWVudCB0byBhZGQgdG8gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlLmFkZFRyYWNrRWxlbWVudF8gPSBmdW5jdGlvbiBhZGRUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudHJhY2tFbGVtZW50c18ubGVuZ3RoO1xuXG4gICAgaWYgKCEoJycgKyBpbmRleCBpbiB0aGlzKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrRWxlbWVudHNfW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGFkZCBkdXBsaWNhdGUgZWxlbWVudHNcbiAgICBpZiAodGhpcy50cmFja0VsZW1lbnRzXy5pbmRleE9mKHRyYWNrRWxlbWVudCkgPT09IC0xKSB7XG4gICAgICB0aGlzLnRyYWNrRWxlbWVudHNfLnB1c2godHJhY2tFbGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH0gZnJvbSB0aGUgYEh0bWxUcmFja0VsZW1lbnRMaXN0YCBnaXZlbiBhblxuICAgKiB7QGxpbmsgVGV4dFRyYWNrfS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgdHJhY2sgYXNzb2NpYXRlZCB3aXRoIGEgdHJhY2sgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7SHRtbFRyYWNrRWxlbWVudHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgVGhlIHRyYWNrIGVsZW1lbnQgdGhhdCB3YXMgZm91bmQgb3IgdW5kZWZpbmVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIEh0bWxUcmFja0VsZW1lbnRMaXN0LnByb3RvdHlwZS5nZXRUcmFja0VsZW1lbnRCeVRyYWNrXyA9IGZ1bmN0aW9uIGdldFRyYWNrRWxlbWVudEJ5VHJhY2tfKHRyYWNrKSB7XG4gICAgdmFyIHRyYWNrRWxlbWVudF8gPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy50cmFja0VsZW1lbnRzXy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyYWNrID09PSB0aGlzLnRyYWNrRWxlbWVudHNfW2ldLnRyYWNrKSB7XG4gICAgICAgIHRyYWNrRWxlbWVudF8gPSB0aGlzLnRyYWNrRWxlbWVudHNfW2ldO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cmFja0VsZW1lbnRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH0gZnJvbSB0aGUgYEh0bWxUcmFja0VsZW1lbnRMaXN0YFxuICAgKlxuICAgKiBAcGFyYW0ge0h0bWxUcmFja0VsZW1lbnR9IHRyYWNrRWxlbWVudFxuICAgKiAgICAgICAgVGhlIHRyYWNrIGVsZW1lbnQgdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlLnJlbW92ZVRyYWNrRWxlbWVudF8gPSBmdW5jdGlvbiByZW1vdmVUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnRyYWNrRWxlbWVudHNfLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJhY2tFbGVtZW50ID09PSB0aGlzLnRyYWNrRWxlbWVudHNfW2ldKSB7XG4gICAgICAgIHRoaXMudHJhY2tFbGVtZW50c18uc3BsaWNlKGksIDEpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gSHRtbFRyYWNrRWxlbWVudExpc3Q7XG59KCk7XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay1jdWUtbGlzdC5qc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGV4dFRyYWNrQ3VlTGlzdH5UZXh0VHJhY2tDdWVcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWRcbiAqICAgICAgICAgICBUaGUgdW5pcXVlIGlkIGZvciB0aGlzIHRleHQgdHJhY2sgY3VlXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0VGltZVxuICogICAgICAgICAgIFRoZSBzdGFydCB0aW1lIGZvciB0aGlzIHRleHQgdHJhY2sgY3VlXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZFRpbWVcbiAqICAgICAgICAgICBUaGUgZW5kIHRpbWUgZm9yIHRoaXMgdGV4dCB0cmFjayBjdWVcbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhdXNlT25FeGl0XG4gKiAgICAgICAgICAgUGF1c2Ugd2hlbiB0aGUgZW5kIHRpbWUgaXMgcmVhY2hlZCBpZiB0cnVlLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2tjdWV9XG4gKi9cblxuLyoqXG4gKiBBIExpc3Qgb2YgVGV4dFRyYWNrQ3Vlcy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrY3VlbGlzdH1cbiAqL1xudmFyIFRleHRUcmFja0N1ZUxpc3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY3Vlc1xuICAgKiAgICAgICAgQSBsaXN0IG9mIGN1ZXMgdG8gYmUgaW5pdGlhbGl6ZWQgd2l0aFxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrQ3VlTGlzdChjdWVzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrQ3VlTGlzdCk7XG5cbiAgICBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZS5zZXRDdWVzXy5jYWxsKHRoaXMsIGN1ZXMpO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRleHRUcmFja0N1ZUxpc3RcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGxlbmd0aFxuICAgICAqICAgICAgICAgVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGBUZXh0VHJhY2tDdWVgcyBpbiB0aGUgVGV4dFRyYWNrQ3VlTGlzdC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2xlbmd0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGhfO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2V0dGVyIGZvciBjdWVzIGluIHRoaXMgbGlzdC4gQ3JlYXRlcyBnZXR0ZXJzXG4gICAqIGFuIGFuIGluZGV4IGZvciB0aGUgY3Vlcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY3Vlc1xuICAgKiAgICAgICAgQW4gYXJyYXkgb2YgY3VlcyB0byBzZXRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZS5zZXRDdWVzXyA9IGZ1bmN0aW9uIHNldEN1ZXNfKGN1ZXMpIHtcbiAgICB2YXIgb2xkTGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGwgPSBjdWVzLmxlbmd0aDtcblxuICAgIHRoaXMuY3Vlc18gPSBjdWVzO1xuICAgIHRoaXMubGVuZ3RoXyA9IGN1ZXMubGVuZ3RoO1xuXG4gICAgdmFyIGRlZmluZVByb3AgPSBmdW5jdGlvbiBkZWZpbmVQcm9wKGluZGV4KSB7XG4gICAgICBpZiAoISgnJyArIGluZGV4IGluIHRoaXMpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnJyArIGluZGV4LCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdWVzX1tpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG9sZExlbmd0aCA8IGwpIHtcbiAgICAgIGkgPSBvbGRMZW5ndGg7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGRlZmluZVByb3AuY2FsbCh0aGlzLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIGBUZXh0VHJhY2tDdWVgIHRoYXQgaXMgY3VycmVudGx5IGluIHRoZSBgVGV4dFRyYWNrQ3VlTGlzdGAgYnkgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKiAgICAgICAgVGhlIGlkIG9mIHRoZSBjdWUgdGhhdCBzaG91bGQgYmUgc2VhcmNoZWQgZm9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2tDdWVMaXN0flRleHRUcmFja0N1ZXxudWxsfVxuICAgKiAgICAgICAgIEEgc2luZ2xlIGN1ZSBvciBudWxsIGlmIG5vbmUgd2FzIGZvdW5kLlxuICAgKi9cblxuXG4gIFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlLmdldEN1ZUJ5SWQgPSBmdW5jdGlvbiBnZXRDdWVCeUlkKGlkKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY3VlID0gdGhpc1tpXTtcblxuICAgICAgaWYgKGN1ZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgcmVzdWx0ID0gY3VlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2tDdWVMaXN0O1xufSgpO1xuXG4vKipcbiAqIEBmaWxlIHRyYWNrLWtpbmRzLmpzXG4gKi9cblxuLyoqXG4gKiBBbGwgcG9zc2libGUgYFZpZGVvVHJhY2tLaW5kYHNcbiAqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tdmlkZW90cmFjay1raW5kXG4gKiBAdHlwZWRlZiBWaWRlb1RyYWNrfktpbmRcbiAqIEBlbnVtXG4gKi9cbnZhciBWaWRlb1RyYWNrS2luZCA9IHtcbiAgYWx0ZXJuYXRpdmU6ICdhbHRlcm5hdGl2ZScsXG4gIGNhcHRpb25zOiAnY2FwdGlvbnMnLFxuICBtYWluOiAnbWFpbicsXG4gIHNpZ246ICdzaWduJyxcbiAgc3VidGl0bGVzOiAnc3VidGl0bGVzJyxcbiAgY29tbWVudGFyeTogJ2NvbW1lbnRhcnknXG59O1xuXG4vKipcbiAqIEFsbCBwb3NzaWJsZSBgQXVkaW9UcmFja0tpbmRgc1xuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS1hdWRpb3RyYWNrLWtpbmRcbiAqIEB0eXBlZGVmIEF1ZGlvVHJhY2t+S2luZFxuICogQGVudW1cbiAqL1xudmFyIEF1ZGlvVHJhY2tLaW5kID0ge1xuICAnYWx0ZXJuYXRpdmUnOiAnYWx0ZXJuYXRpdmUnLFxuICAnZGVzY3JpcHRpb25zJzogJ2Rlc2NyaXB0aW9ucycsXG4gICdtYWluJzogJ21haW4nLFxuICAnbWFpbi1kZXNjJzogJ21haW4tZGVzYycsXG4gICd0cmFuc2xhdGlvbic6ICd0cmFuc2xhdGlvbicsXG4gICdjb21tZW50YXJ5JzogJ2NvbW1lbnRhcnknXG59O1xuXG4vKipcbiAqIEFsbCBwb3NzaWJsZSBgVGV4dFRyYWNrS2luZGBzXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLXRleHR0cmFjay1raW5kXG4gKiBAdHlwZWRlZiBUZXh0VHJhY2t+S2luZFxuICogQGVudW1cbiAqL1xudmFyIFRleHRUcmFja0tpbmQgPSB7XG4gIHN1YnRpdGxlczogJ3N1YnRpdGxlcycsXG4gIGNhcHRpb25zOiAnY2FwdGlvbnMnLFxuICBkZXNjcmlwdGlvbnM6ICdkZXNjcmlwdGlvbnMnLFxuICBjaGFwdGVyczogJ2NoYXB0ZXJzJyxcbiAgbWV0YWRhdGE6ICdtZXRhZGF0YSdcbn07XG5cbi8qKlxuICogQWxsIHBvc3NpYmxlIGBUZXh0VHJhY2tNb2RlYHNcbiAqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2ttb2RlXG4gKiBAdHlwZWRlZiBUZXh0VHJhY2t+TW9kZVxuICogQGVudW1cbiAqL1xudmFyIFRleHRUcmFja01vZGUgPSB7XG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBzaG93aW5nOiAnc2hvd2luZydcbn07XG5cbi8qKlxuICogQGZpbGUgdHJhY2suanNcbiAqL1xuXG4vKipcbiAqIEEgVHJhY2sgY2xhc3MgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciB7QGxpbmsgQXVkaW9UcmFja30sXG4gKiB7QGxpbmsgVmlkZW9UcmFja30sIGFuZCB7QGxpbmsgVGV4dFRyYWNrfS5cbiAqXG4gKiA+IE5vdGU6IFRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5XG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sfVxuICogQGV4dGVuZHMgRXZlbnRUYXJnZXRcbiAqIEBhYnN0cmFjdFxuICovXG5cbnZhciBUcmFjayA9IGZ1bmN0aW9uIChfRXZlbnRUYXJnZXQpIHtcbiAgaW5oZXJpdHMoVHJhY2ssIF9FdmVudFRhcmdldCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmtpbmQ9JyddXG4gICAqICAgICAgICBBIHZhbGlkIGtpbmQgZm9yIHRoZSB0cmFjayB0eXBlIHlvdSBhcmUgY3JlYXRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZD0ndmpzX3RyYWNrXycgKyBHdWlkLm5ld0dVSUQoKV1cbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIEF1ZGlvVHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbD0nJ11cbiAgICogICAgICAgIFRoZSBtZW51IGxhYmVsIGZvciB0aGlzIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2U9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBmdW5jdGlvbiBUcmFjaygpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhY2spO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRUYXJnZXQuY2FsbCh0aGlzKSk7XG5cbiAgICB2YXIgdHJhY2tQcm9wcyA9IHtcbiAgICAgIGlkOiBvcHRpb25zLmlkIHx8ICd2anNfdHJhY2tfJyArIG5ld0dVSUQoKSxcbiAgICAgIGtpbmQ6IG9wdGlvbnMua2luZCB8fCAnJyxcbiAgICAgIGxhYmVsOiBvcHRpb25zLmxhYmVsIHx8ICcnLFxuICAgICAgbGFuZ3VhZ2U6IG9wdGlvbnMubGFuZ3VhZ2UgfHwgJydcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRyYWNrXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBpZFxuICAgICAqICAgICAgICAgVGhlIGlkIG9mIHRoaXMgdHJhY2suIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyIGNyZWF0aW9uLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGtpbmRcbiAgICAgKiAgICAgICAgIFRoZSBraW5kIG9mIHRyYWNrIHRoYXQgdGhpcyBpcy4gQ2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXIgY3JlYXRpb24uXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUcmFja1xuICAgICAqIEBtZW1iZXIge3N0cmluZ30gbGFiZWxcbiAgICAgKiAgICAgICAgIFRoZSBsYWJlbCBvZiB0aGlzIHRyYWNrLiBDYW5ub3QgYmUgY2hhbmdlZCBhZnRlciBjcmVhdGlvbi5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRyYWNrXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBsYW5ndWFnZVxuICAgICAqICAgICAgICAgVGhlIHR3byBsZXR0ZXIgbGFuZ3VhZ2UgY29kZSBmb3IgdGhpcyB0cmFjay4gQ2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXJcbiAgICAgKiAgICAgICAgIGNyZWF0aW9uLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywga2V5LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgIHJldHVybiB0cmFja1Byb3BzW2tleV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKCkge31cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdHJhY2tQcm9wcykge1xuICAgICAgX2xvb3Aoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFRyYWNrO1xufShFdmVudFRhcmdldCk7XG5cbi8qKlxuICogQGZpbGUgdXJsLmpzXG4gKiBAbW9kdWxlIHVybFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gdXJsOlVSTE9iamVjdFxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm90b2NvbFxuICogICAgICAgICAgIFRoZSBwcm90b2NvbCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaG9zdG5hbWVcbiAqICAgICAgICAgICBUaGUgaG9zdG5hbWUgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBvcnRcbiAqICAgICAgICAgICBUaGUgcG9ydCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF0aG5hbWVcbiAqICAgICAgICAgICBUaGUgcGF0aG5hbWUgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNlYXJjaFxuICogICAgICAgICAgIFRoZSBzZWFyY2ggcXVlcnkgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhhc2hcbiAqICAgICAgICAgICBUaGUgaGFzaCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaG9zdFxuICogICAgICAgICAgIFRoZSBob3N0IG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxuICovXG5cbi8qKlxuICogUmVzb2x2ZSBhbmQgcGFyc2UgdGhlIGVsZW1lbnRzIG9mIGEgVVJMLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdXJsXG4gKiAgICAgICAgIFRoZSB1cmwgdG8gcGFyc2VcbiAqXG4gKiBAcmV0dXJuIHt1cmw6VVJMT2JqZWN0fVxuICogICAgICAgICBBbiBvYmplY3Qgb2YgdXJsIGRldGFpbHNcbiAqL1xudmFyIHBhcnNlVXJsID0gZnVuY3Rpb24gcGFyc2VVcmwodXJsKSB7XG4gIHZhciBwcm9wcyA9IFsncHJvdG9jb2wnLCAnaG9zdG5hbWUnLCAncG9ydCcsICdwYXRobmFtZScsICdzZWFyY2gnLCAnaGFzaCcsICdob3N0J107XG5cbiAgLy8gYWRkIHRoZSB1cmwgdG8gYW4gYW5jaG9yIGFuZCBsZXQgdGhlIGJyb3dzZXIgcGFyc2UgdGhlIFVSTFxuICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICBhLmhyZWYgPSB1cmw7XG5cbiAgLy8gSUU4IChhbmQgOT8pIEZpeFxuICAvLyBpZTggZG9lc24ndCBwYXJzZSB0aGUgVVJMIGNvcnJlY3RseSB1bnRpbCB0aGUgYW5jaG9yIGlzIGFjdHVhbGx5XG4gIC8vIGFkZGVkIHRvIHRoZSBib2R5LCBhbmQgYW4gaW5uZXJIVE1MIGlzIG5lZWRlZCB0byB0cmlnZ2VyIHRoZSBwYXJzaW5nXG4gIHZhciBhZGRUb0JvZHkgPSBhLmhvc3QgPT09ICcnICYmIGEucHJvdG9jb2wgIT09ICdmaWxlOic7XG4gIHZhciBkaXYgPSB2b2lkIDA7XG5cbiAgaWYgKGFkZFRvQm9keSkge1xuICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5pbm5lckhUTUwgPSAnPGEgaHJlZj1cIicgKyB1cmwgKyAnXCI+PC9hPic7XG4gICAgYSA9IGRpdi5maXJzdENoaWxkO1xuICAgIC8vIHByZXZlbnQgdGhlIGRpdiBmcm9tIGFmZmVjdGluZyBsYXlvdXRcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5Om5vbmU7IHBvc2l0aW9uOmFic29sdXRlOycpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgfVxuXG4gIC8vIENvcHkgdGhlIHNwZWNpZmljIFVSTCBwcm9wZXJ0aWVzIHRvIGEgbmV3IG9iamVjdFxuICAvLyBUaGlzIGlzIGFsc28gbmVlZGVkIGZvciBJRTggYmVjYXVzZSB0aGUgYW5jaG9yIGxvc2VzIGl0c1xuICAvLyBwcm9wZXJ0aWVzIHdoZW4gaXQncyByZW1vdmVkIGZyb20gdGhlIGRvbVxuICB2YXIgZGV0YWlscyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXRhaWxzW3Byb3BzW2ldXSA9IGFbcHJvcHNbaV1dO1xuICB9XG5cbiAgLy8gSUU5IGFkZHMgdGhlIHBvcnQgdG8gdGhlIGhvc3QgcHJvcGVydHkgdW5saWtlIGV2ZXJ5b25lIGVsc2UuIElmXG4gIC8vIGEgcG9ydCBpZGVudGlmaWVyIGlzIGFkZGVkIGZvciBzdGFuZGFyZCBwb3J0cywgc3RyaXAgaXQuXG4gIGlmIChkZXRhaWxzLnByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgZGV0YWlscy5ob3N0ID0gZGV0YWlscy5ob3N0LnJlcGxhY2UoLzo4MCQvLCAnJyk7XG4gIH1cblxuICBpZiAoZGV0YWlscy5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBkZXRhaWxzLmhvc3QgPSBkZXRhaWxzLmhvc3QucmVwbGFjZSgvOjQ0MyQvLCAnJyk7XG4gIH1cblxuICBpZiAoIWRldGFpbHMucHJvdG9jb2wpIHtcbiAgICBkZXRhaWxzLnByb3RvY29sID0gd2luZG93JDEubG9jYXRpb24ucHJvdG9jb2w7XG4gIH1cblxuICBpZiAoYWRkVG9Cb2R5KSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICB9XG5cbiAgcmV0dXJuIGRldGFpbHM7XG59O1xuXG4vKipcbiAqIEdldCBhYnNvbHV0ZSB2ZXJzaW9uIG9mIHJlbGF0aXZlIFVSTC4gVXNlZCB0byB0ZWxsIGZsYXNoIGNvcnJlY3QgVVJMLlxuICpcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybFxuICogICAgICAgICBVUkwgdG8gbWFrZSBhYnNvbHV0ZVxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgQWJzb2x1dGUgVVJMXG4gKlxuICogQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ3MDgzMi9nZXR0aW5nLWFuLWFic29sdXRlLXVybC1mcm9tLWEtcmVsYXRpdmUtb25lLWllNi1pc3N1ZVxuICovXG52YXIgZ2V0QWJzb2x1dGVVUkwgPSBmdW5jdGlvbiBnZXRBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQ2hlY2sgaWYgYWJzb2x1dGUgVVJMXG4gIGlmICghdXJsLm1hdGNoKC9eaHR0cHM/OlxcL1xcLy8pKSB7XG4gICAgLy8gQ29udmVydCB0byBhYnNvbHV0ZSBVUkwuIEZsYXNoIGhvc3RlZCBvZmYtc2l0ZSBuZWVkcyBhbiBhYnNvbHV0ZSBVUkwuXG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgZGl2LmlubmVySFRNTCA9ICc8YSBocmVmPVwiJyArIHVybCArICdcIj54PC9hPic7XG4gICAgdXJsID0gZGl2LmZpcnN0Q2hpbGQuaHJlZjtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBvZiB0aGUgcGFzc2VkIGZpbGUgbmFtZS4gSXQgd2lsbCByZXR1cm4gYW4gZW1wdHkgc3RyaW5nXG4gKiBpZiBwYXNzZWQgYW4gaW52YWxpZCBwYXRoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiAgICAgICAgVGhlIGZpbGVOYW1lIHBhdGggbGlrZSAnL3BhdGgvdG8vZmlsZS5tcDQnXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgICAgICAgIFRoZSBleHRlbnNpb24gaW4gbG93ZXIgY2FzZSBvciBhbiBlbXB0eSBzdHJpbmcgaWYgbm9cbiAqICAgICAgICAgIGV4dGVuc2lvbiBjb3VsZCBiZSBmb3VuZC5cbiAqL1xudmFyIGdldEZpbGVFeHRlbnNpb24gPSBmdW5jdGlvbiBnZXRGaWxlRXh0ZW5zaW9uKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzcGxpdFBhdGhSZSA9IC9eKFxcLz8pKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/KShcXC4oW15cXC5cXC9cXD9dKykpKSg/OltcXC9dKnxbXFw/XS4qKSQvaTtcbiAgICB2YXIgcGF0aFBhcnRzID0gc3BsaXRQYXRoUmUuZXhlYyhwYXRoKTtcblxuICAgIGlmIChwYXRoUGFydHMpIHtcbiAgICAgIHJldHVybiBwYXRoUGFydHMucG9wKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgdXJsIHBhc3NlZCBpcyBhIGNyb3NzIGRvbWFpbiByZXF1ZXN0IG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiAgICAgICAgVGhlIHVybCB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBXaGV0aGVyIGl0IGlzIGEgY3Jvc3MgZG9tYWluIHJlcXVlc3Qgb3Igbm90LlxuICovXG52YXIgaXNDcm9zc09yaWdpbiA9IGZ1bmN0aW9uIGlzQ3Jvc3NPcmlnaW4odXJsKSB7XG4gIHZhciB3aW5Mb2MgPSB3aW5kb3ckMS5sb2NhdGlvbjtcbiAgdmFyIHVybEluZm8gPSBwYXJzZVVybCh1cmwpO1xuXG4gIC8vIElFOCBwcm90b2NvbCByZWxhdGl2ZSB1cmxzIHdpbGwgcmV0dXJuICc6JyBmb3IgcHJvdG9jb2xcbiAgdmFyIHNyY1Byb3RvY29sID0gdXJsSW5mby5wcm90b2NvbCA9PT0gJzonID8gd2luTG9jLnByb3RvY29sIDogdXJsSW5mby5wcm90b2NvbDtcblxuICAvLyBDaGVjayBpZiB1cmwgaXMgZm9yIGFub3RoZXIgZG9tYWluL29yaWdpblxuICAvLyBJRTggZG9lc24ndCBrbm93IGxvY2F0aW9uLm9yaWdpbiwgc28gd2Ugd29uJ3QgcmVseSBvbiBpdCBoZXJlXG4gIHZhciBjcm9zc09yaWdpbiA9IHNyY1Byb3RvY29sICsgdXJsSW5mby5ob3N0ICE9PSB3aW5Mb2MucHJvdG9jb2wgKyB3aW5Mb2MuaG9zdDtcblxuICByZXR1cm4gY3Jvc3NPcmlnaW47XG59O1xuXG52YXIgVXJsID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBwYXJzZVVybDogcGFyc2VVcmwsXG4gIGdldEFic29sdXRlVVJMOiBnZXRBYnNvbHV0ZVVSTCxcbiAgZ2V0RmlsZUV4dGVuc2lvbjogZ2V0RmlsZUV4dGVuc2lvbixcbiAgaXNDcm9zc09yaWdpbjogaXNDcm9zc09yaWdpblxufSk7XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay5qc1xuICovXG5cbi8qKlxuICogVGFrZXMgYSB3ZWJ2dHQgZmlsZSBjb250ZW50cyBhbmQgcGFyc2VzIGl0IGludG8gY3Vlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNDb250ZW50XG4gKiAgICAgICAgd2ViVlRUIGZpbGUgY29udGVudHNcbiAqXG4gKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAqICAgICAgICBUZXh0VHJhY2sgdG8gYWRkIGN1ZXMgdG8uIEN1ZXMgY29tZSBmcm9tIHRoZSBzcmNDb250ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBwYXJzZUN1ZXMgPSBmdW5jdGlvbiBwYXJzZUN1ZXMoc3JjQ29udGVudCwgdHJhY2spIHtcbiAgdmFyIHBhcnNlciA9IG5ldyB3aW5kb3ckMS5XZWJWVFQuUGFyc2VyKHdpbmRvdyQxLCB3aW5kb3ckMS52dHRqcywgd2luZG93JDEuV2ViVlRULlN0cmluZ0RlY29kZXIoKSk7XG4gIHZhciBlcnJvcnMgPSBbXTtcblxuICBwYXJzZXIub25jdWUgPSBmdW5jdGlvbiAoY3VlKSB7XG4gICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gIH07XG5cbiAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICB9O1xuXG4gIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHRyYWNrLnRyaWdnZXIoe1xuICAgICAgdHlwZTogJ2xvYWRlZGRhdGEnLFxuICAgICAgdGFyZ2V0OiB0cmFja1xuICAgIH0pO1xuICB9O1xuXG4gIHBhcnNlci5wYXJzZShzcmNDb250ZW50KTtcbiAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHdpbmRvdyQxLmNvbnNvbGUgJiYgd2luZG93JDEuY29uc29sZS5ncm91cENvbGxhcHNlZCkge1xuICAgICAgd2luZG93JDEuY29uc29sZS5ncm91cENvbGxhcHNlZCgnVGV4dCBUcmFjayBwYXJzaW5nIGVycm9ycyBmb3IgJyArIHRyYWNrLnNyYyk7XG4gICAgfVxuICAgIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIGxvZyQxLmVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgICBpZiAod2luZG93JDEuY29uc29sZSAmJiB3aW5kb3ckMS5jb25zb2xlLmdyb3VwRW5kKSB7XG4gICAgICB3aW5kb3ckMS5jb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VyLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIExvYWQgYSBgVGV4dFRyYWNrYCBmcm9tIGEgc3BlY2lmaWVkIHVybC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjXG4gKiAgICAgICAgVXJsIHRvIGxvYWQgdHJhY2sgZnJvbS5cbiAqXG4gKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAqICAgICAgICBUcmFjayB0byBhZGQgY3VlcyB0by4gQ29tZXMgZnJvbSB0aGUgY29udGVudCBhdCB0aGUgZW5kIG9mIGB1cmxgLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBsb2FkVHJhY2sgPSBmdW5jdGlvbiBsb2FkVHJhY2soc3JjLCB0cmFjaykge1xuICB2YXIgb3B0cyA9IHtcbiAgICB1cmk6IHNyY1xuICB9O1xuICB2YXIgY3Jvc3NPcmlnaW4gPSBpc0Nyb3NzT3JpZ2luKHNyYyk7XG5cbiAgaWYgKGNyb3NzT3JpZ2luKSB7XG4gICAgb3B0cy5jb3JzID0gY3Jvc3NPcmlnaW47XG4gIH1cblxuICB4aHIob3B0cywgYmluZCh0aGlzLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSwgcmVzcG9uc2VCb2R5KSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGxvZyQxLmVycm9yKGVyciwgcmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHRyYWNrLmxvYWRlZF8gPSB0cnVlO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdnR0anMgaGFzIGxvYWRlZCwgb3RoZXJ3aXNlLCB3YWl0IHRpbGwgaXQgZmluaXNoZWQgbG9hZGluZ1xuICAgIC8vIE5PVEU6IHRoaXMgaXMgb25seSB1c2VkIGZvciB0aGUgYWx0L3ZpZGVvLm5vdnR0LmpzIGJ1aWxkXG4gICAgaWYgKHR5cGVvZiB3aW5kb3ckMS5XZWJWVFQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh0cmFjay50ZWNoXykge1xuICAgICAgICB2YXIgbG9hZEhhbmRsZXIgPSBmdW5jdGlvbiBsb2FkSGFuZGxlcigpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VDdWVzKHJlc3BvbnNlQm9keSwgdHJhY2spO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRyYWNrLnRlY2hfLm9uKCd2dHRqc2xvYWRlZCcsIGxvYWRIYW5kbGVyKTtcbiAgICAgICAgdHJhY2sudGVjaF8ub24oJ3Z0dGpzZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbG9nJDEuZXJyb3IoJ3Z0dGpzIGZhaWxlZCB0byBsb2FkLCBzdG9wcGluZyB0cnlpbmcgdG8gcHJvY2VzcyAnICsgdHJhY2suc3JjKTtcbiAgICAgICAgICB0cmFjay50ZWNoXy5vZmYoJ3Z0dGpzbG9hZGVkJywgbG9hZEhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VDdWVzKHJlc3BvbnNlQm9keSwgdHJhY2spO1xuICAgIH1cbiAgfSkpO1xufTtcblxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGBUZXh0VHJhY2tgLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2t9XG4gKiBAZXh0ZW5kcyBUcmFja1xuICovXG5cbnZhciBUZXh0VHJhY2sgPSBmdW5jdGlvbiAoX1RyYWNrKSB7XG4gIGluaGVyaXRzKFRleHRUcmFjaywgX1RyYWNrKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zPXt9XG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtUZWNofSBvcHRpb25zLnRlY2hcbiAgICogICAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0ZWNoIHRoYXQgb3ducyB0aGlzIFRleHRUcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+S2luZH0gW29wdGlvbnMua2luZD0nc3VidGl0bGVzJ11cbiAgICogICAgICAgIEEgdmFsaWQgdGV4dCB0cmFjayBraW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35Nb2RlfSBbb3B0aW9ucy5tb2RlPSdkaXNhYmxlZCddXG4gICAqICAgICAgICBBIHZhbGlkIHRleHQgdHJhY2sgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgVGV4dFRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWw9JyddXG4gICAqICAgICAgICBUaGUgbWVudSBsYWJlbCBmb3IgdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zcmNsYW5nPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuIEFuIGFsdGVybmF0aXZlLCBidXQgZGVwcmlvcml0aXplZFxuICAgKiAgICAgICAgdmVyc2lvbiBvZiBgb3B0aW9ucy5sYW5ndWFnZWBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY11cbiAgICogICAgICAgIEEgdXJsIHRvIFRleHRUcmFjayBjdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmF1bHRdXG4gICAqICAgICAgICBJZiB0aGlzIHRyYWNrIHNob3VsZCBkZWZhdWx0IHRvIG9uIG9yIG9mZi5cbiAgICovXG4gIGZ1bmN0aW9uIFRleHRUcmFjaygpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrKTtcblxuICAgIGlmICghb3B0aW9ucy50ZWNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdGVjaCB3YXMgbm90IHByb3ZpZGVkLicpO1xuICAgIH1cblxuICAgIHZhciBzZXR0aW5ncyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBraW5kOiBUZXh0VHJhY2tLaW5kW29wdGlvbnMua2luZF0gfHwgJ3N1YnRpdGxlcycsXG4gICAgICBsYW5ndWFnZTogb3B0aW9ucy5sYW5ndWFnZSB8fCBvcHRpb25zLnNyY2xhbmcgfHwgJydcbiAgICB9KTtcbiAgICB2YXIgbW9kZSA9IFRleHRUcmFja01vZGVbc2V0dGluZ3MubW9kZV0gfHwgJ2Rpc2FibGVkJztcbiAgICB2YXIgZGVmYXVsdF8gPSBzZXR0aW5ncy5kZWZhdWx0O1xuXG4gICAgaWYgKHNldHRpbmdzLmtpbmQgPT09ICdtZXRhZGF0YScgfHwgc2V0dGluZ3Mua2luZCA9PT0gJ2NoYXB0ZXJzJykge1xuICAgICAgbW9kZSA9ICdoaWRkZW4nO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrLmNhbGwodGhpcywgc2V0dGluZ3MpKTtcblxuICAgIF90aGlzLnRlY2hfID0gc2V0dGluZ3MudGVjaDtcblxuICAgIF90aGlzLmN1ZXNfID0gW107XG4gICAgX3RoaXMuYWN0aXZlQ3Vlc18gPSBbXTtcblxuICAgIHZhciBjdWVzID0gbmV3IFRleHRUcmFja0N1ZUxpc3QoX3RoaXMuY3Vlc18pO1xuICAgIHZhciBhY3RpdmVDdWVzID0gbmV3IFRleHRUcmFja0N1ZUxpc3QoX3RoaXMuYWN0aXZlQ3Vlc18pO1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIHRpbWV1cGRhdGVIYW5kbGVyID0gYmluZChfdGhpcywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBBY2Nlc3NpbmcgdGhpcy5hY3RpdmVDdWVzIGZvciB0aGUgc2lkZS1lZmZlY3RzIG9mIHVwZGF0aW5nIGl0c2VsZlxuICAgICAgLy8gZHVlIHRvIGl0J3MgbmF0dXJlIGFzIGEgZ2V0dGVyIGZ1bmN0aW9uLiBEbyBub3QgcmVtb3ZlIG9yIGN1ZXMgd2lsbFxuICAgICAgLy8gc3RvcCB1cGRhdGluZyFcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgICAgdGhpcy5hY3RpdmVDdWVzO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY3VlY2hhbmdlJyk7XG4gICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChtb2RlICE9PSAnZGlzYWJsZWQnKSB7XG4gICAgICBfdGhpcy50ZWNoXy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnRlY2hfLm9uKCd0aW1ldXBkYXRlJywgdGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIFRleHRUcmFja1xuICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gZGVmYXVsdFxuICAgICAgICogICAgICAgICBJZiB0aGlzIHRyYWNrIHdhcyBzZXQgdG8gYmUgb24gb3Igb2ZmIGJ5IGRlZmF1bHQuIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyXG4gICAgICAgKiAgICAgICAgIGNyZWF0aW9uLlxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKlxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRfO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gbW9kZVxuICAgICAgICogICAgICAgICBTZXQgdGhlIG1vZGUgb2YgdGhpcyBUZXh0VHJhY2sgdG8gYSB2YWxpZCB7QGxpbmsgVGV4dFRyYWNrfk1vZGV9LiBXaWxsXG4gICAgICAgKiAgICAgICAgIG5vdCBiZSBzZXQgaWYgc2V0dGluZyB0byBhbiBpbnZhbGlkIG1vZGUuXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqXG4gICAgICAgKiBAZmlyZXMgVGV4dFRyYWNrI21vZGVjaGFuZ2VcbiAgICAgICAqL1xuICAgICAgbW9kZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEobmV3TW9kZSkge1xuICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgaWYgKCFUZXh0VHJhY2tNb2RlW25ld01vZGVdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZGUgPSBuZXdNb2RlO1xuICAgICAgICAgIGlmIChtb2RlID09PSAnc2hvd2luZycpIHtcblxuICAgICAgICAgICAgdGhpcy50ZWNoXy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMi50ZWNoXy5vbigndGltZXVwZGF0ZScsIHRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBbiBldmVudCB0aGF0IGZpcmVzIHdoZW4gbW9kZSBjaGFuZ2VzIG9uIHRoaXMgdHJhY2suIFRoaXMgYWxsb3dzXG4gICAgICAgICAgICogdGhlIFRleHRUcmFja0xpc3QgdGhhdCBob2xkcyB0aGlzIHRyYWNrIHRvIGFjdCBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqID4gTm90ZTogVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgc3BlYyFcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBldmVudCBUZXh0VHJhY2sjbW9kZWNoYW5nZVxuICAgICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ21vZGVjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrXG4gICAgICAgKiBAbWVtYmVyIHtUZXh0VHJhY2tDdWVMaXN0fSBjdWVzXG4gICAgICAgKiAgICAgICAgIFRoZSB0ZXh0IHRyYWNrIGN1ZSBsaXN0IGZvciB0aGlzIFRleHRUcmFjay5cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBjdWVzOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgIGlmICghdGhpcy5sb2FkZWRfKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY3VlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoKSB7fVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrXG4gICAgICAgKiBAbWVtYmVyIHtUZXh0VHJhY2tDdWVMaXN0fSBhY3RpdmVDdWVzXG4gICAgICAgKiAgICAgICAgIFRoZSBsaXN0IHRleHQgdHJhY2sgY3VlcyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlIGZvciB0aGlzIFRleHRUcmFjay5cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICBhY3RpdmVDdWVzOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgIGlmICghdGhpcy5sb2FkZWRfKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgaWYgKHRoaXMuY3Vlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVDdWVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjdCA9IHRoaXMudGVjaF8uY3VycmVudFRpbWUoKTtcbiAgICAgICAgICB2YXIgYWN0aXZlID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuY3Vlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdWUgPSB0aGlzLmN1ZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChjdWUuc3RhcnRUaW1lIDw9IGN0ICYmIGN1ZS5lbmRUaW1lID49IGN0KSB7XG4gICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKGN1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1ZS5zdGFydFRpbWUgPT09IGN1ZS5lbmRUaW1lICYmIGN1ZS5zdGFydFRpbWUgPD0gY3QgJiYgY3VlLnN0YXJ0VGltZSArIDAuNSA+PSBjdCkge1xuICAgICAgICAgICAgICBhY3RpdmUucHVzaChjdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChhY3RpdmUubGVuZ3RoICE9PSB0aGlzLmFjdGl2ZUN1ZXNfLmxlbmd0aCkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhY3RpdmUubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZUN1ZXNfLmluZGV4T2YoYWN0aXZlW19pXSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmFjdGl2ZUN1ZXNfID0gYWN0aXZlO1xuICAgICAgICAgIGFjdGl2ZUN1ZXMuc2V0Q3Vlc18odGhpcy5hY3RpdmVDdWVzXyk7XG5cbiAgICAgICAgICByZXR1cm4gYWN0aXZlQ3VlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoKSB7fVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHNldHRpbmdzLnNyYykge1xuICAgICAgX3RoaXMuc3JjID0gc2V0dGluZ3Muc3JjO1xuICAgICAgbG9hZFRyYWNrKHNldHRpbmdzLnNyYywgX3RoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5sb2FkZWRfID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGN1ZSB0byB0aGUgaW50ZXJuYWwgbGlzdCBvZiBjdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35DdWV9IGN1ZVxuICAgKiAgICAgICAgVGhlIGN1ZSB0byBhZGQgdG8gb3VyIGludGVybmFsIGxpc3RcbiAgICovXG5cblxuICBUZXh0VHJhY2sucHJvdG90eXBlLmFkZEN1ZSA9IGZ1bmN0aW9uIGFkZEN1ZShvcmlnaW5hbEN1ZSkge1xuICAgIHZhciBjdWUgPSBvcmlnaW5hbEN1ZTtcblxuICAgIGlmICh3aW5kb3ckMS52dHRqcyAmJiAhKG9yaWdpbmFsQ3VlIGluc3RhbmNlb2Ygd2luZG93JDEudnR0anMuVlRUQ3VlKSkge1xuICAgICAgY3VlID0gbmV3IHdpbmRvdyQxLnZ0dGpzLlZUVEN1ZShvcmlnaW5hbEN1ZS5zdGFydFRpbWUsIG9yaWdpbmFsQ3VlLmVuZFRpbWUsIG9yaWdpbmFsQ3VlLnRleHQpO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIG9yaWdpbmFsQ3VlKSB7XG4gICAgICAgIGlmICghKHByb3AgaW4gY3VlKSkge1xuICAgICAgICAgIGN1ZVtwcm9wXSA9IG9yaWdpbmFsQ3VlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGBpZGAgaXMgY29waWVkIG92ZXJcbiAgICAgIGN1ZS5pZCA9IG9yaWdpbmFsQ3VlLmlkO1xuICAgICAgY3VlLm9yaWdpbmFsQ3VlXyA9IG9yaWdpbmFsQ3VlO1xuICAgIH1cblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnRlY2hfLnRleHRUcmFja3MoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJhY2tzW2ldICE9PSB0aGlzKSB7XG4gICAgICAgIHRyYWNrc1tpXS5yZW1vdmVDdWUoY3VlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmN1ZXNfLnB1c2goY3VlKTtcbiAgICB0aGlzLmN1ZXMuc2V0Q3Vlc18odGhpcy5jdWVzXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGN1ZSBmcm9tIG91ciBpbnRlcm5hbCBsaXN0XG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfkN1ZX0gcmVtb3ZlQ3VlXG4gICAqICAgICAgICBUaGUgY3VlIHRvIHJlbW92ZSBmcm9tIG91ciBpbnRlcm5hbCBsaXN0XG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrLnByb3RvdHlwZS5yZW1vdmVDdWUgPSBmdW5jdGlvbiByZW1vdmVDdWUoX3JlbW92ZUN1ZSkge1xuICAgIHZhciBpID0gdGhpcy5jdWVzXy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgY3VlID0gdGhpcy5jdWVzX1tpXTtcblxuICAgICAgaWYgKGN1ZSA9PT0gX3JlbW92ZUN1ZSB8fCBjdWUub3JpZ2luYWxDdWVfICYmIGN1ZS5vcmlnaW5hbEN1ZV8gPT09IF9yZW1vdmVDdWUpIHtcbiAgICAgICAgdGhpcy5jdWVzXy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuY3Vlcy5zZXRDdWVzXyh0aGlzLmN1ZXNfKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2s7XG59KFRyYWNrKTtcblxuLyoqXG4gKiBjdWVjaGFuZ2UgLSBPbmUgb3IgbW9yZSBjdWVzIGluIHRoZSB0cmFjayBoYXZlIGJlY29tZSBhY3RpdmUgb3Igc3RvcHBlZCBiZWluZyBhY3RpdmUuXG4gKi9cblxuXG5UZXh0VHJhY2sucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge1xuICBjdWVjaGFuZ2U6ICdjdWVjaGFuZ2UnXG59O1xuXG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgYEF1ZGlvVHJhY2tgLiBJZiBpdCBpcyBwYXJ0IG9mIGFuIHtAbGluayBBdWRpb1RyYWNrTGlzdH1cbiAqIG9ubHkgb25lIGBBdWRpb1RyYWNrYCBpbiB0aGUgbGlzdCB3aWxsIGJlIGVuYWJsZWQgYXQgYSB0aW1lLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdWRpb3RyYWNrfVxuICogQGV4dGVuZHMgVHJhY2tcbiAqL1xuXG52YXIgQXVkaW9UcmFjayA9IGZ1bmN0aW9uIChfVHJhY2spIHtcbiAgaW5oZXJpdHMoQXVkaW9UcmFjaywgX1RyYWNrKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2t+S2luZH0gW29wdGlvbnMua2luZD0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgYXVkaW8gdHJhY2sga2luZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWQ9J3Zqc190cmFja18nICsgR3VpZC5uZXdHVUlEKCldXG4gICAqICAgICAgICBBIHVuaXF1ZSBpZCBmb3IgdGhpcyBBdWRpb1RyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWw9JyddXG4gICAqICAgICAgICBUaGUgbWVudSBsYWJlbCBmb3IgdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlZF1cbiAgICogICAgICAgIElmIHRoaXMgdHJhY2sgaXMgdGhlIG9uZSB0aGF0IGlzIGN1cnJlbnRseSBwbGF5aW5nLiBJZiB0aGlzIHRyYWNrIGlzIHBhcnQgb2ZcbiAgICogICAgICAgIGFuIHtAbGluayBBdWRpb1RyYWNrTGlzdH0sIG9ubHkgb25lIHtAbGluayBBdWRpb1RyYWNrfSB3aWxsIGJlIGVuYWJsZWQuXG4gICAqL1xuICBmdW5jdGlvbiBBdWRpb1RyYWNrKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1RyYWNrKTtcblxuICAgIHZhciBzZXR0aW5ncyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBraW5kOiBBdWRpb1RyYWNrS2luZFtvcHRpb25zLmtpbmRdIHx8ICcnXG4gICAgfSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFjay5jYWxsKHRoaXMsIHNldHRpbmdzKSk7XG5cbiAgICB2YXIgZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIEF1ZGlvVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBlbmFibGVkXG4gICAgICogICAgICAgICBJZiB0aGlzIGBBdWRpb1RyYWNrYCBpcyBlbmFibGVkIG9yIG5vdC4gV2hlbiBzZXR0aW5nIHRoaXMgd2lsbFxuICAgICAqICAgICAgICAgZmlyZSB7QGxpbmsgQXVkaW9UcmFjayNlbmFibGVkY2hhbmdlfSBpZiB0aGUgc3RhdGUgb2YgZW5hYmxlZCBpcyBjaGFuZ2VkLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGZpcmVzIFZpZGVvVHJhY2sjc2VsZWN0ZWRjaGFuZ2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsICdlbmFibGVkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBlbmFibGVkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKG5ld0VuYWJsZWQpIHtcbiAgICAgICAgLy8gYW4gaW52YWxpZCBvciB1bmNoYW5nZWQgdmFsdWVcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdFbmFibGVkICE9PSAnYm9vbGVhbicgfHwgbmV3RW5hYmxlZCA9PT0gZW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbmFibGVkID0gbmV3RW5hYmxlZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZXZlbnQgdGhhdCBmaXJlcyB3aGVuIGVuYWJsZWQgY2hhbmdlcyBvbiB0aGlzIHRyYWNrLiBUaGlzIGFsbG93c1xuICAgICAgICAgKiB0aGUgQXVkaW9UcmFja0xpc3QgdGhhdCBob2xkcyB0aGlzIHRyYWNrIHRvIGFjdCBhY2NvcmRpbmdseS5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBOb3RlOiBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzcGVjISBOYXRpdmUgdHJhY2tzIHdpbGwgZG9cbiAgICAgICAgICogICAgICAgICB0aGlzIGludGVybmFsbHkgd2l0aG91dCBhbiBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IEF1ZGlvVHJhY2sjZW5hYmxlZGNoYW5nZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2VuYWJsZWRjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIHRoZSB1c2VyIHNldHMgdGhpcyB0cmFjayB0byBzZWxlY3RlZCB0aGVuXG4gICAgLy8gc2V0IHNlbGVjdGVkIHRvIHRoYXQgdHJ1ZSB2YWx1ZSBvdGhlcndpc2VcbiAgICAvLyB3ZSBrZWVwIGl0IGZhbHNlXG4gICAgaWYgKHNldHRpbmdzLmVuYWJsZWQpIHtcbiAgICAgIF90aGlzLmVuYWJsZWQgPSBzZXR0aW5ncy5lbmFibGVkO1xuICAgIH1cbiAgICBfdGhpcy5sb2FkZWRfID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gQXVkaW9UcmFjaztcbn0oVHJhY2spO1xuXG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgYFZpZGVvVHJhY2tgLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN2aWRlb3RyYWNrfVxuICogQGV4dGVuZHMgVHJhY2tcbiAqL1xuXG52YXIgVmlkZW9UcmFjayA9IGZ1bmN0aW9uIChfVHJhY2spIHtcbiAgaW5oZXJpdHMoVmlkZW9UcmFjaywgX1RyYWNrKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2luZD0nJ11cbiAgICogICAgICAgIEEgdmFsaWQge0BsaW5rIFZpZGVvVHJhY2t+S2luZH1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgQXVkaW9UcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsPScnXVxuICAgKiAgICAgICAgVGhlIG1lbnUgbGFiZWwgZm9yIHRoaXMgdHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbGVjdGVkXVxuICAgKiAgICAgICAgSWYgdGhpcyB0cmFjayBpcyB0aGUgb25lIHRoYXQgaXMgY3VycmVudGx5IHBsYXlpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBWaWRlb1RyYWNrKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWaWRlb1RyYWNrKTtcblxuICAgIHZhciBzZXR0aW5ncyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBraW5kOiBWaWRlb1RyYWNrS2luZFtvcHRpb25zLmtpbmRdIHx8ICcnXG4gICAgfSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFjay5jYWxsKHRoaXMsIHNldHRpbmdzKSk7XG5cbiAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBWaWRlb1RyYWNrXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiAgICAgICAgIElmIHRoaXMgYFZpZGVvVHJhY2tgIGlzIHNlbGVjdGVkIG9yIG5vdC4gV2hlbiBzZXR0aW5nIHRoaXMgd2lsbFxuICAgICAqICAgICAgICAgZmlyZSB7QGxpbmsgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZX0gaWYgdGhlIHN0YXRlIG9mIHNlbGVjdGVkIGNoYW5nZWQuXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZmlyZXMgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgJ3NlbGVjdGVkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShuZXdTZWxlY3RlZCkge1xuICAgICAgICAvLyBhbiBpbnZhbGlkIG9yIHVuY2hhbmdlZCB2YWx1ZVxuICAgICAgICBpZiAodHlwZW9mIG5ld1NlbGVjdGVkICE9PSAnYm9vbGVhbicgfHwgbmV3U2VsZWN0ZWQgPT09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGVkID0gbmV3U2VsZWN0ZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV2ZW50IHRoYXQgZmlyZXMgd2hlbiBzZWxlY3RlZCBjaGFuZ2VzIG9uIHRoaXMgdHJhY2suIFRoaXMgYWxsb3dzXG4gICAgICAgICAqIHRoZSBWaWRlb1RyYWNrTGlzdCB0aGF0IGhvbGRzIHRoaXMgdHJhY2sgdG8gYWN0IGFjY29yZGluZ2x5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IE5vdGU6IFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHNwZWMhIE5hdGl2ZSB0cmFja3Mgd2lsbCBkb1xuICAgICAgICAgKiAgICAgICAgIHRoaXMgaW50ZXJuYWxseSB3aXRob3V0IGFuIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdGVkY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBpZiB0aGUgdXNlciBzZXRzIHRoaXMgdHJhY2sgdG8gc2VsZWN0ZWQgdGhlblxuICAgIC8vIHNldCBzZWxlY3RlZCB0byB0aGF0IHRydWUgdmFsdWUgb3RoZXJ3aXNlXG4gICAgLy8gd2Uga2VlcCBpdCBmYWxzZVxuICAgIGlmIChzZXR0aW5ncy5zZWxlY3RlZCkge1xuICAgICAgX3RoaXMuc2VsZWN0ZWQgPSBzZXR0aW5ncy5zZWxlY3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFZpZGVvVHJhY2s7XG59KFRyYWNrKTtcblxuLyoqXG4gKiBAZmlsZSBodG1sLXRyYWNrLWVsZW1lbnQuanNcbiAqL1xuXG4vKipcbiAqIEBtZW1iZXJvZiBIVE1MVHJhY2tFbGVtZW50XG4gKiBAdHlwZWRlZiB7SFRNTFRyYWNrRWxlbWVudH5SZWFkeVN0YXRlfVxuICogQGVudW0ge251bWJlcn1cbiAqL1xudmFyIE5PTkUgPSAwO1xudmFyIExPQURJTkcgPSAxO1xudmFyIExPQURFRCA9IDI7XG52YXIgRVJST1IgPSAzO1xuXG4vKipcbiAqIEEgc2luZ2xlIHRyYWNrIHJlcHJlc2VudGVkIGluIHRoZSBET00uXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2h0bWx0cmFja2VsZW1lbnR9XG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICovXG5cbnZhciBIVE1MVHJhY2tFbGVtZW50ID0gZnVuY3Rpb24gKF9FdmVudFRhcmdldCkge1xuICBpbmhlcml0cyhIVE1MVHJhY2tFbGVtZW50LCBfRXZlbnRUYXJnZXQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnM9e31cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h9IG9wdGlvbnMudGVjaFxuICAgKiAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRlY2ggdGhhdCBvd25zIHRoaXMgSFRNTFRyYWNrRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+S2luZH0gW29wdGlvbnMua2luZD0nc3VidGl0bGVzJ11cbiAgICogICAgICAgIEEgdmFsaWQgdGV4dCB0cmFjayBraW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35Nb2RlfSBbb3B0aW9ucy5tb2RlPSdkaXNhYmxlZCddXG4gICAqICAgICAgICBBIHZhbGlkIHRleHQgdHJhY2sgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgVGV4dFRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWw9JyddXG4gICAqICAgICAgICBUaGUgbWVudSBsYWJlbCBmb3IgdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zcmNsYW5nPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuIEFuIGFsdGVybmF0aXZlLCBidXQgZGVwcmlvcml0aXplZFxuICAgKiAgICAgICAgdmVzaW9uIG9mIGBvcHRpb25zLmxhbmd1YWdlYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3JjXVxuICAgKiAgICAgICAgQSB1cmwgdG8gVGV4dFRyYWNrIGN1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVmYXVsdF1cbiAgICogICAgICAgIElmIHRoaXMgdHJhY2sgc2hvdWxkIGRlZmF1bHQgdG8gb24gb3Igb2ZmLlxuICAgKi9cbiAgZnVuY3Rpb24gSFRNTFRyYWNrRWxlbWVudCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSFRNTFRyYWNrRWxlbWVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudFRhcmdldC5jYWxsKHRoaXMpKTtcblxuICAgIHZhciByZWFkeVN0YXRlID0gdm9pZCAwO1xuXG4gICAgdmFyIHRyYWNrID0gbmV3IFRleHRUcmFjayhvcHRpb25zKTtcblxuICAgIF90aGlzLmtpbmQgPSB0cmFjay5raW5kO1xuICAgIF90aGlzLnNyYyA9IHRyYWNrLnNyYztcbiAgICBfdGhpcy5zcmNsYW5nID0gdHJhY2subGFuZ3VhZ2U7XG4gICAgX3RoaXMubGFiZWwgPSB0cmFjay5sYWJlbDtcbiAgICBfdGhpcy5kZWZhdWx0ID0gdHJhY2suZGVmYXVsdDtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEhUTUxUcmFja0VsZW1lbnRcbiAgICAgICAqIEBtZW1iZXIge0hUTUxUcmFja0VsZW1lbnR+UmVhZHlTdGF0ZX0gcmVhZHlTdGF0ZVxuICAgICAgICogICAgICAgICBUaGUgY3VycmVudCByZWFkeSBzdGF0ZSBvZiB0aGUgdHJhY2sgZWxlbWVudC5cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICByZWFkeVN0YXRlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgIHJldHVybiByZWFkeVN0YXRlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBIVE1MVHJhY2tFbGVtZW50XG4gICAgICAgKiBAbWVtYmVyIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAgICAgKiAgICAgICAgIFRoZSB1bmRlcmx5aW5nIFRleHRUcmFjayBvYmplY3QuXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqXG4gICAgICAgKi9cbiAgICAgIHRyYWNrOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhZHlTdGF0ZSA9IE5PTkU7XG5cbiAgICAvKipcbiAgICAgKiBAbGlzdGVucyBUZXh0VHJhY2sjbG9hZGVkZGF0YVxuICAgICAqIEBmaXJlcyBIVE1MVHJhY2tFbGVtZW50I2xvYWRcbiAgICAgKi9cbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmVhZHlTdGF0ZSA9IExPQURFRDtcblxuICAgICAgX3RoaXMudHJpZ2dlcih7XG4gICAgICAgIHR5cGU6ICdsb2FkJyxcbiAgICAgICAgdGFyZ2V0OiBfdGhpc1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIEhUTUxUcmFja0VsZW1lbnQ7XG59KEV2ZW50VGFyZ2V0KTtcblxuSFRNTFRyYWNrRWxlbWVudC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7XG4gIGxvYWQ6ICdsb2FkJ1xufTtcblxuSFRNTFRyYWNrRWxlbWVudC5OT05FID0gTk9ORTtcbkhUTUxUcmFja0VsZW1lbnQuTE9BRElORyA9IExPQURJTkc7XG5IVE1MVHJhY2tFbGVtZW50LkxPQURFRCA9IExPQURFRDtcbkhUTUxUcmFja0VsZW1lbnQuRVJST1IgPSBFUlJPUjtcblxuLypcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhbGwgdHJhY2sgcHJvcGVydGllcyB0aGF0IGFyZSB1c2VkIGluXG4gKiBwbGF5ZXIuanMsIHRlY2guanMsIGh0bWw1LmpzIGFuZCBwb3NzaWJseSBvdGhlciB0ZWNocyBpbiB0aGUgZnV0dXJlLlxuICovXG5cbnZhciBOT1JNQUwgPSB7XG4gIGF1ZGlvOiB7XG4gICAgTGlzdENsYXNzOiBBdWRpb1RyYWNrTGlzdCxcbiAgICBUcmFja0NsYXNzOiBBdWRpb1RyYWNrLFxuICAgIGNhcGl0YWxOYW1lOiAnQXVkaW8nXG4gIH0sXG4gIHZpZGVvOiB7XG4gICAgTGlzdENsYXNzOiBWaWRlb1RyYWNrTGlzdCxcbiAgICBUcmFja0NsYXNzOiBWaWRlb1RyYWNrLFxuICAgIGNhcGl0YWxOYW1lOiAnVmlkZW8nXG4gIH0sXG4gIHRleHQ6IHtcbiAgICBMaXN0Q2xhc3M6IFRleHRUcmFja0xpc3QsXG4gICAgVHJhY2tDbGFzczogVGV4dFRyYWNrLFxuICAgIGNhcGl0YWxOYW1lOiAnVGV4dCdcbiAgfVxufTtcblxuT2JqZWN0LmtleXMoTk9STUFMKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIE5PUk1BTFt0eXBlXS5nZXR0ZXJOYW1lID0gdHlwZSArICdUcmFja3MnO1xuICBOT1JNQUxbdHlwZV0ucHJpdmF0ZU5hbWUgPSB0eXBlICsgJ1RyYWNrc18nO1xufSk7XG5cbnZhciBSRU1PVEUgPSB7XG4gIHJlbW90ZVRleHQ6IHtcbiAgICBMaXN0Q2xhc3M6IFRleHRUcmFja0xpc3QsXG4gICAgVHJhY2tDbGFzczogVGV4dFRyYWNrLFxuICAgIGNhcGl0YWxOYW1lOiAnUmVtb3RlVGV4dCcsXG4gICAgZ2V0dGVyTmFtZTogJ3JlbW90ZVRleHRUcmFja3MnLFxuICAgIHByaXZhdGVOYW1lOiAncmVtb3RlVGV4dFRyYWNrc18nXG4gIH0sXG4gIHJlbW90ZVRleHRFbDoge1xuICAgIExpc3RDbGFzczogSHRtbFRyYWNrRWxlbWVudExpc3QsXG4gICAgVHJhY2tDbGFzczogSFRNTFRyYWNrRWxlbWVudCxcbiAgICBjYXBpdGFsTmFtZTogJ1JlbW90ZVRleHRUcmFja0VscycsXG4gICAgZ2V0dGVyTmFtZTogJ3JlbW90ZVRleHRUcmFja0VscycsXG4gICAgcHJpdmF0ZU5hbWU6ICdyZW1vdGVUZXh0VHJhY2tFbHNfJ1xuICB9XG59O1xuXG52YXIgQUxMID0gbWVyZ2VPcHRpb25zKE5PUk1BTCwgUkVNT1RFKTtcblxuUkVNT1RFLm5hbWVzID0gT2JqZWN0LmtleXMoUkVNT1RFKTtcbk5PUk1BTC5uYW1lcyA9IE9iamVjdC5rZXlzKE5PUk1BTCk7XG5BTEwubmFtZXMgPSBbXS5jb25jYXQoUkVNT1RFLm5hbWVzKS5jb25jYXQoTk9STUFMLm5hbWVzKTtcblxuLyoqXG4gKiBAZmlsZSB0ZWNoLmpzXG4gKi9cblxuLyoqXG4gKiBBbiBPYmplY3QgY29udGFpbmluZyBhIHN0cnVjdHVyZSBsaWtlOiBge3NyYzogJ3VybCcsIHR5cGU6ICdtaW1ldHlwZSd9YCBvciBzdHJpbmdcbiAqIHRoYXQganVzdCBjb250YWlucyB0aGUgc3JjIHVybCBhbG9uZS5cbiAqICogYHZhciBTb3VyY2VPYmplY3QgPSB7c3JjOiAnaHR0cDovL2V4LmNvbS92aWRlby5tcDQnLCB0eXBlOiAndmlkZW8vbXA0J307YFxuICAgKiBgdmFyIFNvdXJjZVN0cmluZyA9ICdodHRwOi8vZXhhbXBsZS5jb20vc29tZS12aWRlby5tcDQnO2BcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fHN0cmluZ30gVGVjaH5Tb3VyY2VPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3JjXG4gKiAgICAgICAgICAgVGhlIHVybCB0byB0aGUgc291cmNlXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICAgICBUaGUgbWltZSB0eXBlIG9mIHRoZSBzb3VyY2VcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdXNlZCBieSB7QGxpbmsgVGVjaH0gdG8gY3JlYXRlIGEgbmV3IHtAbGluayBUZXh0VHJhY2t9LlxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtUZWNofSBzZWxmXG4gKiAgICAgICAgQW4gaW5zdGFuY2Ugb2YgdGhlIFRlY2ggY2xhc3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAqICAgICAgICBgVGV4dFRyYWNrYCBraW5kIChzdWJ0aXRsZXMsIGNhcHRpb25zLCBkZXNjcmlwdGlvbnMsIGNoYXB0ZXJzLCBvciBtZXRhZGF0YSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXVxuICogICAgICAgIExhYmVsIHRvIGlkZW50aWZ5IHRoZSB0ZXh0IHRyYWNrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV1cbiAqICAgICAgICBUd28gbGV0dGVyIGxhbmd1YWdlIGFiYnJldmlhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAqICAgICAgICBBbiBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIHRleHQgdHJhY2sgb3B0aW9uc1xuICpcbiAqIEByZXR1cm4ge1RleHRUcmFja31cbiAqICAgICAgICAgIFRoZSB0ZXh0IHRyYWNrIHRoYXQgd2FzIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRyYWNrSGVscGVyKHNlbGYsIGtpbmQsIGxhYmVsLCBsYW5ndWFnZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG5cbiAgdmFyIHRyYWNrcyA9IHNlbGYudGV4dFRyYWNrcygpO1xuXG4gIG9wdGlvbnMua2luZCA9IGtpbmQ7XG5cbiAgaWYgKGxhYmVsKSB7XG4gICAgb3B0aW9ucy5sYWJlbCA9IGxhYmVsO1xuICB9XG4gIGlmIChsYW5ndWFnZSkge1xuICAgIG9wdGlvbnMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgfVxuICBvcHRpb25zLnRlY2ggPSBzZWxmO1xuXG4gIHZhciB0cmFjayA9IG5ldyBBTEwudGV4dC5UcmFja0NsYXNzKG9wdGlvbnMpO1xuXG4gIHRyYWNrcy5hZGRUcmFjayh0cmFjayk7XG5cbiAgcmV0dXJuIHRyYWNrO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIG1lZGlhIHBsYXliYWNrIHRlY2hub2xvZ3kgY29udHJvbGxlcnMsIHN1Y2ggYXNcbiAqIHtAbGluayBGbGFzaH0gYW5kIHtAbGluayBIVE1MNX1cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVGVjaCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFRlY2gsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBUZWNoLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSByZWFkeVxuICAgKiAgICAgICAgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBgSFRNTDVgIFRlY2ggaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBUZWNoKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgcmVhZHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRlY2gpO1xuXG4gICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgdGVjaCB0byByZXBvcnQgdXNlciBhY3Rpdml0eSBhdXRvbWF0aWNhbGx5LlxuICAgIC8vIFRoaXMgaXMgZG9uZSBtYW51YWxseSBpbiBhZGRDb250cm9sc0xpc3RlbmVyc1xuICAgIG9wdGlvbnMucmVwb3J0VG91Y2hBY3Rpdml0eSA9IGZhbHNlO1xuXG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZSBjdXJyZW50IHNvdXJjZSBoYXMgcGxheWVkIGF0IGFsbCB0b1xuICAgIC8vIGltcGxlbWVudCBhIHZlcnkgbGltaXRlZCBwbGF5ZWQoKVxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIG51bGwsIG9wdGlvbnMsIHJlYWR5KSk7XG5cbiAgICBfdGhpcy5oYXNTdGFydGVkXyA9IGZhbHNlO1xuICAgIF90aGlzLm9uKCdwbGF5aW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5oYXNTdGFydGVkXyA9IHRydWU7XG4gICAgfSk7XG4gICAgX3RoaXMub24oJ2xvYWRzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaGFzU3RhcnRlZF8gPSBmYWxzZTtcbiAgICB9KTtcblxuICAgIEFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcHJvcHMgPSBBTExbbmFtZV07XG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnNbcHJvcHMuZ2V0dGVyTmFtZV0pIHtcbiAgICAgICAgX3RoaXNbcHJvcHMucHJpdmF0ZU5hbWVdID0gb3B0aW9uc1twcm9wcy5nZXR0ZXJOYW1lXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIE1hbnVhbGx5IHRyYWNrIHByb2dyZXNzIGluIGNhc2VzIHdoZXJlIHRoZSBicm93c2VyL2ZsYXNoIHBsYXllciBkb2Vzbid0IHJlcG9ydCBpdC5cbiAgICBpZiAoIV90aGlzLmZlYXR1cmVzUHJvZ3Jlc3NFdmVudHMpIHtcbiAgICAgIF90aGlzLm1hbnVhbFByb2dyZXNzT24oKTtcbiAgICB9XG5cbiAgICAvLyBNYW51YWxseSB0cmFjayB0aW1ldXBkYXRlcyBpbiBjYXNlcyB3aGVyZSB0aGUgYnJvd3Nlci9mbGFzaCBwbGF5ZXIgZG9lc24ndCByZXBvcnQgaXQuXG4gICAgaWYgKCFfdGhpcy5mZWF0dXJlc1RpbWV1cGRhdGVFdmVudHMpIHtcbiAgICAgIF90aGlzLm1hbnVhbFRpbWVVcGRhdGVzT24oKTtcbiAgICB9XG5cbiAgICBbJ1RleHQnLCAnQXVkaW8nLCAnVmlkZW8nXS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgaWYgKG9wdGlvbnNbJ25hdGl2ZScgKyB0cmFjayArICdUcmFja3MnXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgX3RoaXNbJ2ZlYXR1cmVzTmF0aXZlJyArIHRyYWNrICsgJ1RyYWNrcyddID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5uYXRpdmVDYXB0aW9ucyA9PT0gZmFsc2UgfHwgb3B0aW9ucy5uYXRpdmVUZXh0VHJhY2tzID09PSBmYWxzZSkge1xuICAgICAgX3RoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm5hdGl2ZUNhcHRpb25zID09PSB0cnVlIHx8IG9wdGlvbnMubmF0aXZlVGV4dFRyYWNrcyA9PT0gdHJ1ZSkge1xuICAgICAgX3RoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIV90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgX3RoaXMuZW11bGF0ZVRleHRUcmFja3MoKTtcbiAgICB9XG5cbiAgICBfdGhpcy5hdXRvUmVtb3RlVGV4dFRyYWNrc18gPSBuZXcgQUxMLnRleHQuTGlzdENsYXNzKCk7XG5cbiAgICBfdGhpcy5pbml0VHJhY2tMaXN0ZW5lcnMoKTtcblxuICAgIC8vIFR1cm4gb24gY29tcG9uZW50IHRhcCBldmVudHMgb25seSBpZiBub3QgdXNpbmcgbmF0aXZlIGNvbnRyb2xzXG4gICAgaWYgKCFvcHRpb25zLm5hdGl2ZUNvbnRyb2xzRm9yVG91Y2gpIHtcbiAgICAgIF90aGlzLmVtaXRUYXBFdmVudHMoKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgIF90aGlzLm5hbWVfID0gX3RoaXMuY29uc3RydWN0b3IubmFtZSB8fCAnVW5rbm93biBUZWNoJztcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbCBmdW5jdGlvbiB0byB0cmlnZ2VyIHNvdXJjZSBzZXQgaW4gYSB3YXkgdGhhdCB3aWxsIGFsbG93IHBsYXllclxuICAgKiB0byByZS10cmlnZ2VyIGlmIHRoZSBwbGF5ZXIgb3IgdGVjaCBhcmUgbm90IHJlYWR5IHlldC5cbiAgICpcbiAgICogQGZpcmVzIFRlY2gjc291cmNlc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBzdHJpbmcgYXQgdGhlIHRpbWUgb2YgdGhlIHNvdXJjZSBjaGFuZ2luZy5cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS50cmlnZ2VyU291cmNlc2V0ID0gZnVuY3Rpb24gdHJpZ2dlclNvdXJjZXNldChzcmMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICghdGhpcy5pc1JlYWR5Xykge1xuICAgICAgLy8gb24gaW5pdGlhbCByZWFkeSB3ZSBoYXZlIHRvIHRyaWdnZXIgc291cmNlIHNldFxuICAgICAgLy8gMW1zIGFmdGVyIHJlYWR5IHNvIHRoYXQgcGxheWVyIGNhbiB3YXRjaCBmb3IgaXQuXG4gICAgICB0aGlzLm9uZSgncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi50cmlnZ2VyU291cmNlc2V0KHNyYyk7XG4gICAgICAgIH0sIDEpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgc291cmNlIGlzIHNldCBvbiB0aGUgdGVjaCBjYXVzaW5nIHRoZSBtZWRpYSBlbGVtZW50XG4gICAgICogdG8gcmVsb2FkLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgUGxheWVyI2V2ZW50OnNvdXJjZXNldH1cbiAgICAgKiBAZXZlbnQgVGVjaCNzb3VyY2VzZXRcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKHtcbiAgICAgIHNyYzogc3JjLFxuICAgICAgdHlwZTogJ3NvdXJjZXNldCdcbiAgICB9KTtcbiAgfTtcblxuICAvKiBGYWxsYmFja3MgZm9yIHVuc3VwcG9ydGVkIGV2ZW50IHR5cGVzXG4gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgLyoqXG4gICAqIFBvbHlmaWxsIHRoZSBgcHJvZ3Jlc3NgIGV2ZW50IGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXQgbmF0aXZlbHkuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIFRlY2gjdHJhY2tQcm9ncmVzc31cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5tYW51YWxQcm9ncmVzc09uID0gZnVuY3Rpb24gbWFudWFsUHJvZ3Jlc3NPbigpIHtcbiAgICB0aGlzLm9uKCdkdXJhdGlvbmNoYW5nZScsIHRoaXMub25EdXJhdGlvbkNoYW5nZSk7XG5cbiAgICB0aGlzLm1hbnVhbFByb2dyZXNzID0gdHJ1ZTtcblxuICAgIC8vIFRyaWdnZXIgcHJvZ3Jlc3Mgd2F0Y2hpbmcgd2hlbiBhIHNvdXJjZSBiZWdpbnMgbG9hZGluZ1xuICAgIHRoaXMub25lKCdyZWFkeScsIHRoaXMudHJhY2tQcm9ncmVzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gb2ZmIHRoZSBwb2x5ZmlsbCBmb3IgYHByb2dyZXNzYCBldmVudHMgdGhhdCB3YXMgY3JlYXRlZCBpblxuICAgKiB7QGxpbmsgVGVjaCNtYW51YWxQcm9ncmVzc09ufVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLm1hbnVhbFByb2dyZXNzT2ZmID0gZnVuY3Rpb24gbWFudWFsUHJvZ3Jlc3NPZmYoKSB7XG4gICAgdGhpcy5tYW51YWxQcm9ncmVzcyA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKTtcblxuICAgIHRoaXMub2ZmKCdkdXJhdGlvbmNoYW5nZScsIHRoaXMub25EdXJhdGlvbkNoYW5nZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdXNlZCB0byB0cmlnZ2VyIGEgYHByb2dyZXNzYCBldmVudCB3aGVuIHRoZSBidWZmZXJlZCBwZXJjZW50IGNoYW5nZXMuIEl0XG4gICAqIHNldHMgYW4gaW50ZXJ2YWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBldmVyeSA1MDAgbWlsbGlzZWNvbmRzIHRvIGNoZWNrIGlmIHRoZVxuICAgKiBidWZmZXIgZW5kIHBlcmNlbnQgaGFzIGNoYW5nZWQuXG4gICAqXG4gICAqID4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkge0BsaW5rIFRlY2gjbWFudWFsUHJvZ3Jlc3NPbn1cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgcmVhZHlgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3JlYWR5XG4gICAqIEBmaXJlcyBUZWNoI3Byb2dyZXNzXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUudHJhY2tQcm9ncmVzcyA9IGZ1bmN0aW9uIHRyYWNrUHJvZ3Jlc3MoZXZlbnQpIHtcbiAgICB0aGlzLnN0b3BUcmFja2luZ1Byb2dyZXNzKCk7XG4gICAgdGhpcy5wcm9ncmVzc0ludGVydmFsID0gdGhpcy5zZXRJbnRlcnZhbChiaW5kKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIERvbid0IHRyaWdnZXIgdW5sZXNzIGJ1ZmZlcmVkIGFtb3VudCBpcyBncmVhdGVyIHRoYW4gbGFzdCB0aW1lXG5cbiAgICAgIHZhciBudW1CdWZmZXJlZFBlcmNlbnQgPSB0aGlzLmJ1ZmZlcmVkUGVyY2VudCgpO1xuXG4gICAgICBpZiAodGhpcy5idWZmZXJlZFBlcmNlbnRfICE9PSBudW1CdWZmZXJlZFBlcmNlbnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSB7QGxpbmsgUGxheWVyI3Byb2dyZXNzfVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgVGVjaCNwcm9ncmVzc1xuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Byb2dyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVmZmVyZWRQZXJjZW50XyA9IG51bUJ1ZmZlcmVkUGVyY2VudDtcblxuICAgICAgaWYgKG51bUJ1ZmZlcmVkUGVyY2VudCA9PT0gMSkge1xuICAgICAgICB0aGlzLnN0b3BUcmFja2luZ1Byb2dyZXNzKCk7XG4gICAgICB9XG4gICAgfSksIDUwMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBvdXIgaW50ZXJuYWwgZHVyYXRpb24gb24gYSBgZHVyYXRpb25jaGFuZ2VgIGV2ZW50IGJ5IGNhbGxpbmdcbiAgICoge0BsaW5rIFRlY2gjZHVyYXRpb259LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBkdXJhdGlvbmNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjZHVyYXRpb25jaGFuZ2VcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5vbkR1cmF0aW9uQ2hhbmdlID0gZnVuY3Rpb24gb25EdXJhdGlvbkNoYW5nZShldmVudCkge1xuICAgIHRoaXMuZHVyYXRpb25fID0gdGhpcy5kdXJhdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW5kIGNyZWF0ZSBhIGBUaW1lUmFuZ2VgIG9iamVjdCBmb3IgYnVmZmVyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gICAqICAgICAgICAgVGhlIHRpbWUgcmFuZ2Ugb2JqZWN0IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuYnVmZmVyZWQgPSBmdW5jdGlvbiBidWZmZXJlZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlcygwLCAwKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwZXJjZW50YWdlIG9mIHRoZSBjdXJyZW50IHZpZGVvIHRoYXQgaXMgY3VycmVudGx5IGJ1ZmZlcmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgQSBudW1iZXIgZnJvbSAwIHRvIDEgdGhhdCByZXByZXNlbnRzIHRoZSBkZWNpbWFsIHBlcmNlbnRhZ2Ugb2YgdGhlXG4gICAqICAgICAgICAgdmlkZW8gdGhhdCBpcyBidWZmZXJlZC5cbiAgICpcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5idWZmZXJlZFBlcmNlbnQgPSBmdW5jdGlvbiBidWZmZXJlZFBlcmNlbnQkJDEoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcmVkUGVyY2VudCh0aGlzLmJ1ZmZlcmVkKCksIHRoaXMuZHVyYXRpb25fKTtcbiAgfTtcblxuICAvKipcbiAgICogVHVybiBvZmYgdGhlIHBvbHlmaWxsIGZvciBgcHJvZ3Jlc3NgIGV2ZW50cyB0aGF0IHdhcyBjcmVhdGVkIGluXG4gICAqIHtAbGluayBUZWNoI21hbnVhbFByb2dyZXNzT259XG4gICAqIFN0b3AgbWFudWFsbHkgdHJhY2tpbmcgcHJvZ3Jlc3MgZXZlbnRzIGJ5IGNsZWFyaW5nIHRoZSBpbnRlcnZhbCB0aGF0IHdhcyBzZXQgaW5cbiAgICoge0BsaW5rIFRlY2gjdHJhY2tQcm9ncmVzc30uXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuc3RvcFRyYWNraW5nUHJvZ3Jlc3MgPSBmdW5jdGlvbiBzdG9wVHJhY2tpbmdQcm9ncmVzcygpIHtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwodGhpcy5wcm9ncmVzc0ludGVydmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogUG9seWZpbGwgdGhlIGB0aW1ldXBkYXRlYCBldmVudCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGl0LlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBUZWNoI3RyYWNrQ3VycmVudFRpbWV9XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUubWFudWFsVGltZVVwZGF0ZXNPbiA9IGZ1bmN0aW9uIG1hbnVhbFRpbWVVcGRhdGVzT24oKSB7XG4gICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlcyA9IHRydWU7XG5cbiAgICB0aGlzLm9uKCdwbGF5JywgdGhpcy50cmFja0N1cnJlbnRUaW1lKTtcbiAgICB0aGlzLm9uKCdwYXVzZScsIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUdXJuIG9mZiB0aGUgcG9seWZpbGwgZm9yIGB0aW1ldXBkYXRlYCBldmVudHMgdGhhdCB3YXMgY3JlYXRlZCBpblxuICAgKiB7QGxpbmsgVGVjaCNtYW51YWxUaW1lVXBkYXRlc09ufVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLm1hbnVhbFRpbWVVcGRhdGVzT2ZmID0gZnVuY3Rpb24gbWFudWFsVGltZVVwZGF0ZXNPZmYoKSB7XG4gICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlcyA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUoKTtcbiAgICB0aGlzLm9mZigncGxheScsIHRoaXMudHJhY2tDdXJyZW50VGltZSk7XG4gICAgdGhpcy5vZmYoJ3BhdXNlJywgdGhpcy5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgYW4gaW50ZXJ2YWwgZnVuY3Rpb24gdG8gdHJhY2sgY3VycmVudCB0aW1lIGFuZCB0cmlnZ2VyIGB0aW1ldXBkYXRlYCBldmVyeVxuICAgKiAyNTAgbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3BsYXlcbiAgICogQHRyaWdnZXJzIFRlY2gjdGltZXVwZGF0ZVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnRyYWNrQ3VycmVudFRpbWUgPSBmdW5jdGlvbiB0cmFja0N1cnJlbnRUaW1lKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VGltZUludGVydmFsID0gdGhpcy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRyaWdnZXJlZCBhdCBhbiBpbnRlcnZhbCBvZiAyNTBtcyB0byBpbmRpY2F0ZWQgdGhhdCB0aW1lIGlzIHBhc3NpbmcgaW4gdGhlIHZpZGVvLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBUZWNoI3RpbWV1cGRhdGVcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xuXG4gICAgICAvLyA0MiA9IDI0IGZwcyAvLyAyNTAgaXMgd2hhdCBXZWJraXQgdXNlcyAvLyBGRiB1c2VzIDE1XG4gICAgfSwgMjUwKTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcCB0aGUgaW50ZXJ2YWwgZnVuY3Rpb24gY3JlYXRlZCBpbiB7QGxpbmsgVGVjaCN0cmFja0N1cnJlbnRUaW1lfSBzbyB0aGF0IHRoZVxuICAgKiBgdGltZXVwZGF0ZWAgZXZlbnQgaXMgbm8gbG9uZ2VyIHRyaWdnZXJlZC5cbiAgICpcbiAgICogQGxpc3RlbnMge1RlY2gjcGF1c2V9XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUgPSBmdW5jdGlvbiBzdG9wVHJhY2tpbmdDdXJyZW50VGltZSgpIHtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwodGhpcy5jdXJyZW50VGltZUludGVydmFsKTtcblxuICAgIC8vICMxMDAyIC0gaWYgdGhlIHZpZGVvIGVuZHMgcmlnaHQgYmVmb3JlIHRoZSBuZXh0IHRpbWV1cGRhdGUgd291bGQgaGFwcGVuLFxuICAgIC8vIHRoZSBwcm9ncmVzcyBiYXIgd29uJ3QgbWFrZSBpdCBhbGwgdGhlIHdheSB0byB0aGUgZW5kXG4gICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUdXJuIG9mZiBhbGwgZXZlbnQgcG9seWZpbGxzLCBjbGVhciB0aGUgYFRlY2hgcyB7QGxpbmsgQXVkaW9UcmFja0xpc3R9LFxuICAgKiB7QGxpbmsgVmlkZW9UcmFja0xpc3R9LCBhbmQge0BsaW5rIFRleHRUcmFja0xpc3R9LCBhbmQgZGlzcG9zZSBvZiB0aGlzIFRlY2guXG4gICAqXG4gICAqIEBmaXJlcyBDb21wb25lbnQjZGlzcG9zZVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuXG4gICAgLy8gY2xlYXIgb3V0IGFsbCB0cmFja3MgYmVjYXVzZSB3ZSBjYW4ndCByZXVzZSB0aGVtIGJldHdlZW4gdGVjaHNcbiAgICB0aGlzLmNsZWFyVHJhY2tzKE5PUk1BTC5uYW1lcyk7XG5cbiAgICAvLyBUdXJuIG9mZiBhbnkgbWFudWFsIHByb2dyZXNzIG9yIHRpbWV1cGRhdGUgdHJhY2tpbmdcbiAgICBpZiAodGhpcy5tYW51YWxQcm9ncmVzcykge1xuICAgICAgdGhpcy5tYW51YWxQcm9ncmVzc09mZigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hbnVhbFRpbWVVcGRhdGVzKSB7XG4gICAgICB0aGlzLm1hbnVhbFRpbWVVcGRhdGVzT2ZmKCk7XG4gICAgfVxuXG4gICAgX0NvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciBvdXQgYSBzaW5nbGUgYFRyYWNrTGlzdGAgb3IgYW4gYXJyYXkgb2YgYFRyYWNrTGlzdHNgIGdpdmVuIHRoZWlyIG5hbWVzLlxuICAgKlxuICAgKiA+IE5vdGU6IFRlY2hzIHdpdGhvdXQgc291cmNlIGhhbmRsZXJzIHNob3VsZCBjYWxsIHRoaXMgYmV0d2VlbiBzb3VyY2VzIGZvciBgdmlkZW9gXG4gICAqICAgICAgICAgJiBgYXVkaW9gIHRyYWNrcy4gWW91IGRvbid0IHdhbnQgdG8gdXNlIHRoZW0gYmV0d2VlbiB0cmFja3MhXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nW118c3RyaW5nfSB0eXBlc1xuICAgKiAgICAgICAgVHJhY2tMaXN0IG5hbWVzIHRvIGNsZWFyLCB2YWxpZCBuYW1lcyBhcmUgYHZpZGVvYCwgYGF1ZGlvYCwgYW5kXG4gICAqICAgICAgICBgdGV4dGAuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuY2xlYXJUcmFja3MgPSBmdW5jdGlvbiBjbGVhclRyYWNrcyh0eXBlcykge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdHlwZXMgPSBbXS5jb25jYXQodHlwZXMpO1xuICAgIC8vIGNsZWFyIG91dCBhbGwgdHJhY2tzIGJlY2F1c2Ugd2UgY2FuJ3QgcmV1c2UgdGhlbSBiZXR3ZWVuIHRlY2hzXG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIGxpc3QgPSBfdGhpczNbdHlwZSArICdUcmFja3MnXSgpIHx8IFtdO1xuICAgICAgdmFyIGkgPSBsaXN0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgdHJhY2sgPSBsaXN0W2ldO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBfdGhpczMucmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0LnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFueSBUZXh0VHJhY2tzIGFkZGVkIHZpYSBhZGRSZW1vdGVUZXh0VHJhY2sgdGhhdCBhcmVcbiAgICogZmxhZ2dlZCBmb3IgYXV0b21hdGljIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmNsZWFudXBBdXRvVGV4dFRyYWNrcyA9IGZ1bmN0aW9uIGNsZWFudXBBdXRvVGV4dFRyYWNrcygpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuYXV0b1JlbW90ZVRleHRUcmFja3NfIHx8IFtdO1xuICAgIHZhciBpID0gbGlzdC5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdHJhY2sgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLnJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjayk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgdGVjaCwgd2hpY2ggd2lsbCByZW1vdmVzIGFsbCBzb3VyY2VzIGFuZCByZXNldCB0aGUgaW50ZXJuYWwgcmVhZHlTdGF0ZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHt9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IGFuIGVycm9yIG9uIHRoZSBUZWNoLlxuICAgKlxuICAgKiBAcGFyYW0ge01lZGlhRXJyb3J9IFtlcnJdXG4gICAqICAgICAgICBFcnJvciB0byBzZXQgb24gdGhlIFRlY2hcbiAgICpcbiAgICogQHJldHVybiB7TWVkaWFFcnJvcnxudWxsfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGVycm9yIG9iamVjdCBvbiB0aGUgdGVjaCwgb3IgbnVsbCBpZiB0aGVyZSBpc24ndCBvbmUuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZXJyb3JfID0gbmV3IE1lZGlhRXJyb3IoZXJyKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZXJyb3InKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXJyb3JfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgVGltZVJhbmdlYHMgdGhhdCBoYXZlIGJlZW4gcGxheWVkIHRocm91Z2ggZm9yIHRoZSBjdXJyZW50IHNvdXJjZS5cbiAgICpcbiAgICogPiBOT1RFOiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGluY29tcGxldGUuIEl0IGRvZXMgbm90IHRyYWNrIHRoZSBwbGF5ZWQgYFRpbWVSYW5nZWAuXG4gICAqICAgICAgICAgSXQgb25seSBjaGVja3Mgd2hldGhlciB0aGUgc291cmNlIGhhcyBwbGF5ZWQgYXQgYWxsIG9yIG5vdC5cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIC0gQSBzaW5nbGUgdGltZSByYW5nZSBpZiB0aGlzIHZpZGVvIGhhcyBwbGF5ZWRcbiAgICogICAgICAgICAtIEFuIGVtcHR5IHNldCBvZiByYW5nZXMgaWYgbm90LlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnBsYXllZCA9IGZ1bmN0aW9uIHBsYXllZCgpIHtcbiAgICBpZiAodGhpcy5oYXNTdGFydGVkXykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhdXNlcyBhIG1hbnVhbCB0aW1lIHVwZGF0ZSB0byBvY2N1ciBpZiB7QGxpbmsgVGVjaCNtYW51YWxUaW1lVXBkYXRlc09ufSB3YXNcbiAgICogcHJldmlvdXNseSBjYWxsZWQuXG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI3RpbWV1cGRhdGVcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uIHNldEN1cnJlbnRUaW1lKCkge1xuICAgIC8vIGltcHJvdmUgdGhlIGFjY3VyYWN5IG9mIG1hbnVhbCB0aW1ldXBkYXRlc1xuICAgIGlmICh0aGlzLm1hbnVhbFRpbWVVcGRhdGVzKSB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbWFudWFsIGB0aW1ldXBkYXRlYCBldmVudC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgVGVjaCN0aW1ldXBkYXRlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd0aW1ldXBkYXRlJywgdGFyZ2V0OiB0aGlzLCBtYW51YWxseVRyaWdnZXJlZDogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gb24gbGlzdGVuZXJzIGZvciB7QGxpbmsgVmlkZW9UcmFja0xpc3R9LCB7QGxpbmsge0F1ZGlvVHJhY2tMaXN0fSwgYW5kXG4gICAqIHtAbGluayBUZXh0VHJhY2tMaXN0fSBldmVudHMuXG4gICAqXG4gICAqIFRoaXMgYWRkcyB7QGxpbmsgRXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcnN9IGZvciBgYWRkdHJhY2tgLCBhbmQgIGByZW1vdmV0cmFja2AuXG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI2F1ZGlvdHJhY2tjaGFuZ2VcbiAgICogQGZpcmVzIFRlY2gjdmlkZW90cmFja2NoYW5nZVxuICAgKiBAZmlyZXMgVGVjaCN0ZXh0dHJhY2tjaGFuZ2VcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5pbml0VHJhY2tMaXN0ZW5lcnMgPSBmdW5jdGlvbiBpbml0VHJhY2tMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0cmFja3MgYXJlIGFkZGVkIG9yIHJlbW92ZWQgb24gdGhlIFRlY2gge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fVxuICAgICAqXG4gICAgICogQGV2ZW50IFRlY2gjYXVkaW90cmFja2NoYW5nZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRyYWNrcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZCBvbiB0aGUgVGVjaCB7QGxpbmsgVmlkZW9UcmFja0xpc3R9XG4gICAgICpcbiAgICAgKiBAZXZlbnQgVGVjaCN2aWRlb3RyYWNrY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdHJhY2tzIGFyZSBhZGRlZCBvciByZW1vdmVkIG9uIHRoZSBUZWNoIHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICAgICAqXG4gICAgICogQGV2ZW50IFRlY2gjdGV4dHRyYWNrY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIE5PUk1BTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcHJvcHMgPSBOT1JNQUxbbmFtZV07XG4gICAgICB2YXIgdHJhY2tMaXN0Q2hhbmdlcyA9IGZ1bmN0aW9uIHRyYWNrTGlzdENoYW5nZXMoKSB7XG4gICAgICAgIF90aGlzNC50cmlnZ2VyKG5hbWUgKyAndHJhY2tjaGFuZ2UnKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciB0cmFja3MgPSBfdGhpczRbcHJvcHMuZ2V0dGVyTmFtZV0oKTtcblxuICAgICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdHJhY2tMaXN0Q2hhbmdlcyk7XG4gICAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0cmFja0xpc3RDaGFuZ2VzKTtcblxuICAgICAgX3RoaXM0Lm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0cmFja0xpc3RDaGFuZ2VzKTtcbiAgICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdHJhY2tMaXN0Q2hhbmdlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRW11bGF0ZSBUZXh0VHJhY2tzIHVzaW5nIHZ0dC5qcyBpZiBuZWNlc3NhcnlcbiAgICpcbiAgICogQGZpcmVzIFRlY2gjdnR0anNsb2FkZWRcbiAgICogQGZpcmVzIFRlY2gjdnR0anNlcnJvclxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmFkZFdlYlZ0dFNjcmlwdF8gPSBmdW5jdGlvbiBhZGRXZWJWdHRTY3JpcHRfKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgaWYgKHdpbmRvdyQxLldlYlZUVCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxseSwgVGVjaC5lbF8gaXMgYSBjaGlsZCBvZiBhIGR1bW15LWRpdiB3YWl0IHVudGlsIHRoZSBDb21wb25lbnQgc3lzdGVtXG4gICAgLy8gc2lnbmFscyB0aGF0IHRoZSBUZWNoIGlzIHJlYWR5IGF0IHdoaWNoIHBvaW50IFRlY2guZWxfIGlzIHBhcnQgb2YgdGhlIERPTVxuICAgIC8vIGJlZm9yZSBpbnNlcnRpbmcgdGhlIFdlYlZUVCBzY3JpcHRcbiAgICBpZiAoZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLmVsKCkpKSB7XG5cbiAgICAgIC8vIGxvYWQgdmlhIHJlcXVpcmUgaWYgYXZhaWxhYmxlIGFuZCB2dHQuanMgc2NyaXB0IGxvY2F0aW9uIHdhcyBub3QgcGFzc2VkIGluXG4gICAgICAvLyBhcyBhbiBvcHRpb24uIG5vdnR0IGJ1aWxkcyB3aWxsIHR1cm4gdGhlIGFib3ZlIHJlcXVpcmUgY2FsbCBpbnRvIGFuIGVtcHR5IG9iamVjdFxuICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSB0aGlzIGlmIGNoZWNrIHRvIGFsd2F5cyBmYWlsLlxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnNfWyd2dHQuanMnXSAmJiBpc1BsYWluKHZ0dCkgJiYgT2JqZWN0LmtleXModnR0KS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcigndnR0anNsb2FkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBsb2FkIHZ0dC5qcyB2aWEgdGhlIHNjcmlwdCBsb2NhdGlvbiBvcHRpb24gb3IgdGhlIGNkbiBvZiBubyBsb2NhdGlvbiB3YXNcbiAgICAgIC8vIHBhc3NlZCBpblxuICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gICAgICBzY3JpcHQuc3JjID0gdGhpcy5vcHRpb25zX1sndnR0LmpzJ10gfHwgJ2h0dHBzOi8vdmpzLnplbmNkbi5uZXQvdnR0anMvMC4xNC4xL3Z0dC5taW4uanMnO1xuICAgICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdnR0LmpzIGlzIGxvYWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFRlY2gjdnR0anNsb2FkZWRcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXM1LnRyaWdnZXIoJ3Z0dGpzbG9hZGVkJyk7XG4gICAgICB9O1xuICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIHZ0dC5qcyB3YXMgbm90IGxvYWRlZCBkdWUgdG8gYW4gZXJyb3JcbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFRlY2gjdnR0anNsb2FkZWRcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXM1LnRyaWdnZXIoJ3Z0dGpzZXJyb3InKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzY3JpcHQub25sb2FkID0gbnVsbDtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICAvLyBidXQgaGF2ZSBub3QgbG9hZGVkIHlldCBhbmQgd2Ugc2V0IGl0IHRvIHRydWUgYmVmb3JlIHRoZSBpbmplY3Qgc28gdGhhdFxuICAgICAgLy8gd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSBpbmplY3RlZCB3aW5kb3cuV2ViVlRUIGlmIGl0IGxvYWRzIHJpZ2h0IGF3YXlcbiAgICAgIHdpbmRvdyQxLldlYlZUVCA9IHRydWU7XG4gICAgICB0aGlzLmVsKCkucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlYWR5KHRoaXMuYWRkV2ViVnR0U2NyaXB0Xyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbXVsYXRlIHRleHR0cmFja3NcbiAgICpcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5lbXVsYXRlVGV4dFRyYWNrcyA9IGZ1bmN0aW9uIGVtdWxhdGVUZXh0VHJhY2tzKCkge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgdmFyIHRyYWNrcyA9IHRoaXMudGV4dFRyYWNrcygpO1xuICAgIHZhciByZW1vdGVUcmFja3MgPSB0aGlzLnJlbW90ZVRleHRUcmFja3MoKTtcbiAgICB2YXIgaGFuZGxlQWRkVHJhY2sgPSBmdW5jdGlvbiBoYW5kbGVBZGRUcmFjayhlKSB7XG4gICAgICByZXR1cm4gdHJhY2tzLmFkZFRyYWNrKGUudHJhY2spO1xuICAgIH07XG4gICAgdmFyIGhhbmRsZVJlbW92ZVRyYWNrID0gZnVuY3Rpb24gaGFuZGxlUmVtb3ZlVHJhY2soZSkge1xuICAgICAgcmV0dXJuIHRyYWNrcy5yZW1vdmVUcmFjayhlLnRyYWNrKTtcbiAgICB9O1xuXG4gICAgcmVtb3RlVHJhY2tzLm9uKCdhZGR0cmFjaycsIGhhbmRsZUFkZFRyYWNrKTtcbiAgICByZW1vdGVUcmFja3Mub24oJ3JlbW92ZXRyYWNrJywgaGFuZGxlUmVtb3ZlVHJhY2spO1xuXG4gICAgdGhpcy5hZGRXZWJWdHRTY3JpcHRfKCk7XG5cbiAgICB2YXIgdXBkYXRlRGlzcGxheSA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICByZXR1cm4gX3RoaXM2LnRyaWdnZXIoJ3RleHR0cmFja2NoYW5nZScpO1xuICAgIH07XG5cbiAgICB2YXIgdGV4dFRyYWNrc0NoYW5nZXMgPSBmdW5jdGlvbiB0ZXh0VHJhY2tzQ2hhbmdlcygpIHtcbiAgICAgIHVwZGF0ZURpc3BsYXkoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICAgIHRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIHVwZGF0ZURpc3BsYXkpO1xuICAgICAgICBpZiAodHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgdXBkYXRlRGlzcGxheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGV4dFRyYWNrc0NoYW5nZXMoKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRleHRUcmFja3NDaGFuZ2VzKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmVtb3RlVHJhY2tzLm9mZignYWRkdHJhY2snLCBoYW5kbGVBZGRUcmFjayk7XG4gICAgICByZW1vdGVUcmFja3Mub2ZmKCdyZW1vdmV0cmFjaycsIGhhbmRsZVJlbW92ZVRyYWNrKTtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgICB0cmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdjdWVjaGFuZ2UnLCB1cGRhdGVEaXNwbGF5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZXR1cm5zIGEgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAgICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXVxuICAgKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV1cbiAgICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja31cbiAgICogICAgICAgICBUaGUgVGV4dFRyYWNrIHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmFkZFRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAoIWtpbmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dFRyYWNrIGtpbmQgaXMgcmVxdWlyZWQgYnV0IHdhcyBub3QgcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlVHJhY2tIZWxwZXIodGhpcywga2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGVtdWxhdGVkIFRleHRUcmFjayBmb3IgdXNlIGJ5IGFkZFJlbW90ZVRleHRUcmFja1xuICAgKlxuICAgKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyB0aGF0IGluaGVyaXQgZnJvbVxuICAgKiBUZWNoIGluIG9yZGVyIHRvIGNyZWF0ZSBuYXRpdmUgb3IgY3VzdG9tIFRleHRUcmFja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIHRoZSBvcHRpb25zIHRvIGluaXRpYWxpemUgdGhlIFRleHRUcmFjayB3aXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2luZF1cbiAgICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsXS5cbiAgICogICAgICAgIExhYmVsIHRvIGlkZW50aWZ5IHRoZSB0ZXh0IHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZV1cbiAgICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSB0cmFjayBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmNyZWF0ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGNyZWF0ZVJlbW90ZVRleHRUcmFjayhvcHRpb25zKSB7XG4gICAgdmFyIHRyYWNrID0gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIHRlY2g6IHRoaXNcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgUkVNT1RFLnJlbW90ZVRleHRFbC5UcmFja0NsYXNzKHRyYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlbW90ZSB0ZXh0IHRyYWNrIG9iamVjdCBhbmQgcmV0dXJucyBhbiBodG1sIHRyYWNrIGVsZW1lbnQuXG4gICAqXG4gICAqID4gTm90ZTogVGhpcyBjYW4gYmUgYW4gZW11bGF0ZWQge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9IG9yIGEgbmF0aXZlIG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFNlZSB7QGxpbmsgVGVjaCNjcmVhdGVSZW1vdGVUZXh0VHJhY2t9IGZvciBtb3JlIGRldGFpbGVkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW21hbnVhbENsZWFudXA9dHJ1ZV1cbiAgICogICAgICAgIC0gV2hlbiBmYWxzZTogdGhlIFRleHRUcmFjayB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSB2aWRlb1xuICAgKiAgICAgICAgICBlbGVtZW50IHdoZW5ldmVyIHRoZSBzb3VyY2UgY2hhbmdlc1xuICAgKiAgICAgICAgLSBXaGVuIFRydWU6IFRoZSBUZXh0VHJhY2sgd2lsbCBoYXZlIHRvIGJlIGNsZWFuZWQgdXAgbWFudWFsbHlcbiAgICpcbiAgICogQHJldHVybiB7SFRNTFRyYWNrRWxlbWVudH1cbiAgICogICAgICAgICBBbiBIdG1sIFRyYWNrIEVsZW1lbnQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBkZWZhdWx0IGZ1bmN0aW9uYWxpdHkgZm9yIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBlcXVpdmFsZW50XG4gICAqICAgICAgICAgICAgIHRvIFwibWFudWFsQ2xlYW51cD1mYWxzZVwiIGluIHRoZSBmdXR1cmUuIFRoZSBtYW51YWxDbGVhbnVwIHBhcmFtZXRlciB3aWxsXG4gICAqICAgICAgICAgICAgIGFsc28gYmUgcmVtb3ZlZC5cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5hZGRSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRSZW1vdGVUZXh0VHJhY2soKSB7XG4gICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIG1hbnVhbENsZWFudXAgPSBhcmd1bWVudHNbMV07XG5cbiAgICB2YXIgaHRtbFRyYWNrRWxlbWVudCA9IHRoaXMuY3JlYXRlUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMpO1xuXG4gICAgaWYgKG1hbnVhbENsZWFudXAgIT09IHRydWUgJiYgbWFudWFsQ2xlYW51cCAhPT0gZmFsc2UpIHtcbiAgICAgIC8vIGRlcHJlY2F0aW9uIHdhcm5pbmdcbiAgICAgIGxvZyQxLndhcm4oJ0NhbGxpbmcgYWRkUmVtb3RlVGV4dFRyYWNrIHdpdGhvdXQgZXhwbGljaXRseSBzZXR0aW5nIHRoZSBcIm1hbnVhbENsZWFudXBcIiBwYXJhbWV0ZXIgdG8gYHRydWVgIGlzIGRlcHJlY2F0ZWQgYW5kIGRlZmF1bHQgdG8gYGZhbHNlYCBpbiBmdXR1cmUgdmVyc2lvbiBvZiB2aWRlby5qcycpO1xuICAgICAgbWFudWFsQ2xlYW51cCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gc3RvcmUgSFRNTFRyYWNrRWxlbWVudCBhbmQgVGV4dFRyYWNrIHRvIHJlbW90ZSBsaXN0XG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5hZGRUcmFja0VsZW1lbnRfKGh0bWxUcmFja0VsZW1lbnQpO1xuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrcygpLmFkZFRyYWNrKGh0bWxUcmFja0VsZW1lbnQudHJhY2spO1xuXG4gICAgaWYgKG1hbnVhbENsZWFudXAgIT09IHRydWUpIHtcbiAgICAgIC8vIGNyZWF0ZSB0aGUgVGV4dFRyYWNrTGlzdCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNy5hdXRvUmVtb3RlVGV4dFRyYWNrc18uYWRkVHJhY2soaHRtbFRyYWNrRWxlbWVudC50cmFjayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbFRyYWNrRWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgcmVtb3RlIHRleHQgdHJhY2sgZnJvbSB0aGUgcmVtb3RlIGBUZXh0VHJhY2tMaXN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBgVGV4dFRyYWNrYCB0byByZW1vdmUgZnJvbSB0aGUgYFRleHRUcmFja0xpc3RgXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUucmVtb3ZlUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKSB7XG4gICAgdmFyIHRyYWNrRWxlbWVudCA9IHRoaXMucmVtb3RlVGV4dFRyYWNrRWxzKCkuZ2V0VHJhY2tFbGVtZW50QnlUcmFja18odHJhY2spO1xuXG4gICAgLy8gcmVtb3ZlIEhUTUxUcmFja0VsZW1lbnQgYW5kIFRleHRUcmFjayBmcm9tIHJlbW90ZSBsaXN0XG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5yZW1vdmVUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudCk7XG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgIHRoaXMuYXV0b1JlbW90ZVRleHRUcmFja3NfLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhdmFpbGFibGUgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzIGFzIHNwZWNpZmllZCBieSB0aGUgVzNDJ3MgTWVkaWFcbiAgICogUGxheWJhY2sgUXVhbGl0eSBBUEkuXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vbWVkaWEtcGxheWJhY2stcXVhbGl0eX1cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEFuIG9iamVjdCB3aXRoIHN1cHBvcnRlZCBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3NcbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPSBmdW5jdGlvbiBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpIHtcbiAgICByZXR1cm4ge307XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRvIHNldCBhIHBvc3RlciBmcm9tIGEgYFRlY2hgLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5zZXRQb3N0ZXIgPSBmdW5jdGlvbiBzZXRQb3N0ZXIoKSB7fTtcblxuICAvKipcbiAgICogQSBtZXRob2QgdG8gY2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiB0aGUgJ3BsYXlzaW5saW5lJyA8dmlkZW8+IGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUucGxheXNpbmxpbmUgPSBmdW5jdGlvbiBwbGF5c2lubGluZSgpIHt9O1xuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0byBzZXQgb3IgdW5zZXQgdGhlICdwbGF5c2lubGluZScgPHZpZGVvPiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnNldFBsYXlzaW5saW5lID0gZnVuY3Rpb24gc2V0UGxheXNpbmxpbmUoKSB7fTtcblxuICAvKipcbiAgICogQXR0ZW1wdCB0byBmb3JjZSBvdmVycmlkZSBvZiBuYXRpdmUgYXVkaW8gdHJhY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG92ZXJyaWRlIC0gSWYgc2V0IHRvIHRydWUgbmF0aXZlIGF1ZGlvIHdpbGwgYmUgb3ZlcnJpZGRlbixcbiAgICogb3RoZXJ3aXNlIG5hdGl2ZSBhdWRpbyB3aWxsIHBvdGVudGlhbGx5IGJlIHVzZWQuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLm92ZXJyaWRlTmF0aXZlQXVkaW9UcmFja3MgPSBmdW5jdGlvbiBvdmVycmlkZU5hdGl2ZUF1ZGlvVHJhY2tzKCkge307XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gZm9yY2Ugb3ZlcnJpZGUgb2YgbmF0aXZlIHZpZGVvIHRyYWNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBvdmVycmlkZSAtIElmIHNldCB0byB0cnVlIG5hdGl2ZSB2aWRlbyB3aWxsIGJlIG92ZXJyaWRkZW4sXG4gICAqIG90aGVyd2lzZSBuYXRpdmUgdmlkZW8gd2lsbCBwb3RlbnRpYWxseSBiZSB1c2VkLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5vdmVycmlkZU5hdGl2ZVZpZGVvVHJhY2tzID0gZnVuY3Rpb24gb3ZlcnJpZGVOYXRpdmVWaWRlb1RyYWNrcygpIHt9O1xuXG4gIC8qXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiBtaW1lLXR5cGUuXG4gICAqXG4gICAqIFRoZSBiYXNlIHRlY2ggZG9lcyBub3Qgc3VwcG9ydCBhbnkgdHlwZSwgYnV0IHNvdXJjZSBoYW5kbGVycyBtaWdodFxuICAgKiBvdmVyd3JpdGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0eXBlXG4gICAqICAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrIGZvciBzdXBwb3J0XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciBlbXB0eSBzdHJpbmdcbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvY2FuUGxheVR5cGV9XG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gY2FuUGxheVR5cGUoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyB0ZWNoLlxuICAgKlxuICAgKiBUaGUgYmFzZSB0ZWNoIGRvZXMgbm90IHN1cHBvcnQgYW55IHR5cGUsIGJ1dCBzb3VyY2UgaGFuZGxlcnMgbWlnaHRcbiAgICogb3ZlcndyaXRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBUaGUgbWVkaWEgdHlwZSB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgdGhlIG5hdGl2ZSB2aWRlbyBlbGVtZW50J3MgcmVzcG9uc2VcbiAgICovXG5cblxuICBUZWNoLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gY2FuUGxheVR5cGUoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gc291cmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNPYmpcbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHRlY2hcbiAgICogQHJldHVybiB7c3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cblxuXG4gIFRlY2guY2FuUGxheVNvdXJjZSA9IGZ1bmN0aW9uIGNhblBsYXlTb3VyY2Uoc3JjT2JqLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFRlY2guY2FuUGxheVR5cGUoc3JjT2JqLnR5cGUpO1xuICB9O1xuXG4gIC8qXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBhcmd1bWVudCBpcyBhIFRlY2ggb3Igbm90LlxuICAgKiBDYW4gYmUgcGFzc2VkIGVpdGhlciBhIENsYXNzIGxpa2UgYEh0bWw1YCBvciBhIGluc3RhbmNlIGxpa2UgYHBsYXllci50ZWNoX2BcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudFxuICAgKiAgICAgICAgVGhlIGl0ZW0gdG8gY2hlY2tcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBXaGV0aGVyIGl0IGlzIGEgdGVjaCBvciBub3RcbiAgICogICAgICAgICAtIFRydWUgaWYgaXQgaXMgYSB0ZWNoXG4gICAqICAgICAgICAgLSBGYWxzZSBpZiBpdCBpcyBub3RcbiAgICovXG5cblxuICBUZWNoLmlzVGVjaCA9IGZ1bmN0aW9uIGlzVGVjaChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gY29tcG9uZW50LnByb3RvdHlwZSBpbnN0YW5jZW9mIFRlY2ggfHwgY29tcG9uZW50IGluc3RhbmNlb2YgVGVjaCB8fCBjb21wb25lbnQgPT09IFRlY2g7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGBUZWNoYCBpbnRvIGEgc2hhcmVkIGxpc3QgZm9yIHZpZGVvanMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBOYW1lIG9mIHRoZSBgVGVjaGAgdG8gcmVnaXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0ZWNoXG4gICAqICAgICAgICBUaGUgYFRlY2hgIGNsYXNzIHRvIHJlZ2lzdGVyLlxuICAgKi9cblxuXG4gIFRlY2gucmVnaXN0ZXJUZWNoID0gZnVuY3Rpb24gcmVnaXN0ZXJUZWNoKG5hbWUsIHRlY2gpIHtcbiAgICBpZiAoIVRlY2gudGVjaHNfKSB7XG4gICAgICBUZWNoLnRlY2hzXyA9IHt9O1xuICAgIH1cblxuICAgIGlmICghVGVjaC5pc1RlY2godGVjaCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVjaCAnICsgbmFtZSArICcgbXVzdCBiZSBhIFRlY2gnKTtcbiAgICB9XG5cbiAgICBpZiAoIVRlY2guY2FuUGxheVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVjaHMgbXVzdCBoYXZlIGEgc3RhdGljIGNhblBsYXlUeXBlIG1ldGhvZCBvbiB0aGVtJyk7XG4gICAgfVxuICAgIGlmICghVGVjaC5jYW5QbGF5U291cmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlY2hzIG11c3QgaGF2ZSBhIHN0YXRpYyBjYW5QbGF5U291cmNlIG1ldGhvZCBvbiB0aGVtJyk7XG4gICAgfVxuXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xuXG4gICAgVGVjaC50ZWNoc19bbmFtZV0gPSB0ZWNoO1xuICAgIGlmIChuYW1lICE9PSAnVGVjaCcpIHtcbiAgICAgIC8vIGNhbWVsIGNhc2UgdGhlIHRlY2hOYW1lIGZvciB1c2UgaW4gdGVjaE9yZGVyXG4gICAgICBUZWNoLmRlZmF1bHRUZWNoT3JkZXJfLnB1c2gobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0ZWNoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBgVGVjaGAgZnJvbSB0aGUgc2hhcmVkIGxpc3QgYnkgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIGBjYW1lbENhc2VgIG9yIGBUaXRsZUNhc2VgIG5hbWUgb2YgdGhlIFRlY2ggdG8gZ2V0XG4gICAqXG4gICAqIEByZXR1cm4ge1RlY2h8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFRoZSBgVGVjaGAgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIHdhcyBubyB0ZWNoIHdpdGggdGhlIG5hbWUgcmVxdWVzdGVkLlxuICAgKi9cblxuXG4gIFRlY2guZ2V0VGVjaCA9IGZ1bmN0aW9uIGdldFRlY2gobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5hbWUgPSB0b1RpdGxlQ2FzZShuYW1lKTtcblxuICAgIGlmIChUZWNoLnRlY2hzXyAmJiBUZWNoLnRlY2hzX1tuYW1lXSkge1xuICAgICAgcmV0dXJuIFRlY2gudGVjaHNfW25hbWVdO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3ckMSAmJiB3aW5kb3ckMS52aWRlb2pzICYmIHdpbmRvdyQxLnZpZGVvanNbbmFtZV0pIHtcbiAgICAgIGxvZyQxLndhcm4oJ1RoZSAnICsgbmFtZSArICcgdGVjaCB3YXMgYWRkZWQgdG8gdGhlIHZpZGVvanMgb2JqZWN0IHdoZW4gaXQgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgdXNpbmcgdmlkZW9qcy5yZWdpc3RlclRlY2gobmFtZSwgdGVjaCknKTtcbiAgICAgIHJldHVybiB3aW5kb3ckMS52aWRlb2pzW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGVjaDtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBWaWRlb1RyYWNrTGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7VmlkZW9UcmFja0xpc3R9XG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLnZpZGVvVHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBBdWRpb1RyYWNrTGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7QXVkaW9UcmFja0xpc3R9XG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLmF1ZGlvVHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICpcbiAqIEByZXR1cm5zIHtUZXh0VHJhY2tMaXN0fVxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS50ZXh0VHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHJlbW90ZSBlbGVtZW50IHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICpcbiAqIEByZXR1cm5zIHtUZXh0VHJhY2tMaXN0fVxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS5yZW1vdGVUZXh0VHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHJlbW90ZSBlbGVtZW50IHtAbGluayBIdG1sVHJhY2tFbGVtZW50TGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7SHRtbFRyYWNrRWxlbWVudExpc3R9XG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLnJlbW90ZVRleHRUcmFja0Vsc1xuICovXG5cbkFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwcm9wcyA9IEFMTFtuYW1lXTtcblxuICBUZWNoLnByb3RvdHlwZVtwcm9wcy5nZXR0ZXJOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXSA9IHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdIHx8IG5ldyBwcm9wcy5MaXN0Q2xhc3MoKTtcbiAgICByZXR1cm4gdGhpc1twcm9wcy5wcml2YXRlTmFtZV07XG4gIH07XG59KTtcblxuLyoqXG4gKiBMaXN0IG9mIGFzc29jaWF0ZWQgdGV4dCB0cmFja3NcbiAqXG4gKiBAdHlwZSB7VGV4dFRyYWNrTGlzdH1cbiAqIEBwcml2YXRlXG4gKiBAcHJvcGVydHkgVGVjaCN0ZXh0VHJhY2tzX1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBhc3NvY2lhdGVkIGF1ZGlvIHRyYWNrcy5cbiAqXG4gKiBAdHlwZSB7QXVkaW9UcmFja0xpc3R9XG4gKiBAcHJpdmF0ZVxuICogQHByb3BlcnR5IFRlY2gjYXVkaW9UcmFja3NfXG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIGFzc29jaWF0ZWQgdmlkZW8gdHJhY2tzLlxuICpcbiAqIEB0eXBlIHtWaWRlb1RyYWNrTGlzdH1cbiAqIEBwcml2YXRlXG4gKiBAcHJvcGVydHkgVGVjaCN2aWRlb1RyYWNrc19cbiAqL1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgdm9sdW1lIGNvbnRyb2wuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wgPSB0cnVlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgbXV0aW5nIHZvbHVtZS5cbiAqXG4gKiBAdHlwZSB7Ym9sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNNdXRlQ29udHJvbCA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyBmdWxsc2NyZWVuIHJlc2l6ZSBjb250cm9sLlxuICogUmVzaXppbmcgcGx1Z2lucyB1c2luZyByZXF1ZXN0IGZ1bGxzY3JlZW4gcmVsb2FkcyB0aGUgcGx1Z2luXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc0Z1bGxzY3JlZW5SZXNpemUgPSBmYWxzZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIGNoYW5naW5nIHRoZSBzcGVlZCBhdCB3aGljaCB0aGUgdmlkZW9cbiAqIHBsYXlzLiBFeGFtcGxlczpcbiAqICAgLSBTZXQgcGxheWVyIHRvIHBsYXkgMnggKHR3aWNlKSBhcyBmYXN0XG4gKiAgIC0gU2V0IHBsYXllciB0byBwbGF5IDAuNXggKGhhbGYpIGFzIGZhc3RcbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzUGxheWJhY2tSYXRlID0gZmFsc2U7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB0aGUgYHByb2dyZXNzYCBldmVudC4gVGhpcyBpcyBjdXJyZW50bHlcbiAqIG5vdCB0cmlnZ2VyZWQgYnkgdmlkZW8tanMtc3dmLiBUaGlzIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWZcbiAqIHtAbGluayBUZWNoI21hbnVhbFByb2dyZXNzT259IHNob3VsZCBiZSBjYWxsZWQuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzID0gZmFsc2U7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB0aGUgYHNvdXJjZXNldGAgZXZlbnQuXG4gKlxuICogQSB0ZWNoIHNob3VsZCBzZXQgdGhpcyB0byBgdHJ1ZWAgYW5kIHRoZW4gdXNlIHtAbGluayBUZWNoI3RyaWdnZXJTb3VyY2VzZXR9XG4gKiB0byB0cmlnZ2VyIGEge0BsaW5rIFRlY2gjZXZlbnQ6c291cmNlc2V0fSBhdCB0aGUgZWFybGllc3QgdGltZSBhZnRlciBnZXR0aW5nXG4gKiBhIG5ldyBzb3VyY2UuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1NvdXJjZXNldCA9IGZhbHNlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgdGhlIGB0aW1ldXBkYXRlYCBldmVudC4gVGhpcyBpcyBjdXJyZW50bHlcbiAqIG5vdCB0cmlnZ2VyZWQgYnkgdmlkZW8tanMtc3dmLiBUaGlzIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWZcbiAqIHtAbGluayBUZWNoI21hbnVhbFRpbWVVcGRhdGVzfSBzaG91bGQgYmUgY2FsbGVkLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNUaW1ldXBkYXRlRXZlbnRzID0gZmFsc2U7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB0aGUgbmF0aXZlIGBUZXh0VHJhY2tgcy5cbiAqIFRoaXMgd2lsbCBoZWxwIHVzIGludGVncmF0ZSB3aXRoIG5hdGl2ZSBgVGV4dFRyYWNrYHMgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlbS5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IGZhbHNlO1xuXG4vKipcbiAqIEEgZnVuY3Rpb25hbCBtaXhpbiBmb3IgdGVjaHMgdGhhdCB3YW50IHRvIHVzZSB0aGUgU291cmNlIEhhbmRsZXIgcGF0dGVybi5cbiAqIFNvdXJjZSBoYW5kbGVycyBhcmUgc2NyaXB0cyBmb3IgaGFuZGxpbmcgc3BlY2lmaWMgZm9ybWF0cy5cbiAqIFRoZSBzb3VyY2UgaGFuZGxlciBwYXR0ZXJuIGlzIHVzZWQgZm9yIGFkYXB0aXZlIGZvcm1hdHMgKEhMUywgREFTSCkgdGhhdFxuICogbWFudWFsbHkgbG9hZCB2aWRlbyBkYXRhIGFuZCBmZWVkIGl0IGludG8gYSBTb3VyY2UgQnVmZmVyIChNZWRpYSBTb3VyY2UgRXh0ZW5zaW9ucylcbiAqIEV4YW1wbGU6IGBUZWNoLndpdGhTb3VyY2VIYW5kbGVycy5jYWxsKE15VGVjaCk7YFxuICpcbiAqIEBwYXJhbSB7VGVjaH0gX1RlY2hcbiAqICAgICAgICBUaGUgdGVjaCB0byBhZGQgc291cmNlIGhhbmRsZXIgZnVuY3Rpb25zIHRvLlxuICpcbiAqIEBtaXhlcyBUZWNoflNvdXJjZUhhbmRsZXJBZGRpdGlvbnNcbiAqL1xuVGVjaC53aXRoU291cmNlSGFuZGxlcnMgPSBmdW5jdGlvbiAoX1RlY2gpIHtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBzb3VyY2UgaGFuZGxlclxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqICAgICAgICBUaGUgc291cmNlIGhhbmRsZXIgY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cbiAgICogICAgICAgIFJlZ2lzdGVyIGl0IGF0IHRoZSBmb2xsb3dpbmcgaW5kZXhcbiAgICovXG4gIF9UZWNoLnJlZ2lzdGVyU291cmNlSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyLCBpbmRleCkge1xuICAgIHZhciBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzO1xuXG4gICAgaWYgKCFoYW5kbGVycykge1xuICAgICAgaGFuZGxlcnMgPSBfVGVjaC5zb3VyY2VIYW5kbGVycyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgICAgaW5kZXggPSBoYW5kbGVycy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaGFuZGxlcnMuc3BsaWNlKGluZGV4LCAwLCBoYW5kbGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHR5cGUuIEFsc28gY2hlY2tzIHRoZVxuICAgKiBUZWNocyBzb3VyY2VIYW5kbGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogICAgICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cbiAgX1RlY2guY2FuUGxheVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzIHx8IFtdO1xuICAgIHZhciBjYW4gPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW4gPSBoYW5kbGVyc1tpXS5jYW5QbGF5VHlwZSh0eXBlKTtcblxuICAgICAgaWYgKGNhbikge1xuICAgICAgICByZXR1cm4gY2FuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3Qgc291cmNlIGhhbmRsZXIgdGhhdCBzdXBwb3J0cyB0aGUgc291cmNlLlxuICAgKlxuICAgKiBUT0RPOiBBbnN3ZXIgcXVlc3Rpb246IHNob3VsZCAncHJvYmFibHknIGJlIHByaW9yaXRpemVkIG92ZXIgJ21heWJlJ1xuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHRlY2hcbiAgICpcbiAgICogQHJldHVybiB7U291cmNlSGFuZGxlcnxudWxsfVxuICAgKiAgICAgICAgICBUaGUgZmlyc3Qgc291cmNlIGhhbmRsZXIgdGhhdCBzdXBwb3J0cyB0aGUgc291cmNlIG9yIG51bGwgaWZcbiAgICogICAgICAgICAgbm8gU291cmNlSGFuZGxlciBzdXBwb3J0cyB0aGUgc291cmNlXG4gICAqL1xuICBfVGVjaC5zZWxlY3RTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHZhciBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzIHx8IFtdO1xuICAgIHZhciBjYW4gPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW4gPSBoYW5kbGVyc1tpXS5jYW5IYW5kbGVTb3VyY2Uoc291cmNlLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGNhbikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcnNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNyY09ialxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdGVjaFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAgICovXG4gIF9UZWNoLmNhblBsYXlTb3VyY2UgPSBmdW5jdGlvbiAoc3JjT2JqLCBvcHRpb25zKSB7XG4gICAgdmFyIHNoID0gX1RlY2guc2VsZWN0U291cmNlSGFuZGxlcihzcmNPYmosIG9wdGlvbnMpO1xuXG4gICAgaWYgKHNoKSB7XG4gICAgICByZXR1cm4gc2guY2FuSGFuZGxlU291cmNlKHNyY09iaiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHVzaW5nIGEgc291cmNlIGhhbmRsZXIsIHByZWZlciBpdHMgaW1wbGVtZW50YXRpb24gb2ZcbiAgICogYW55IGZ1bmN0aW9uIG5vcm1hbGx5IHByb3ZpZGVkIGJ5IHRoZSB0ZWNoLlxuICAgKi9cbiAgdmFyIGRlZmVycmFibGUgPSBbJ3NlZWthYmxlJywgJ3NlZWtpbmcnLCAnZHVyYXRpb24nXTtcblxuICAvKipcbiAgICogQSB3cmFwcGVyIGFyb3VuZCB7QGxpbmsgVGVjaCNzZWVrYWJsZX0gdGhhdCB3aWxsIGNhbGwgYSBgU291cmNlSGFuZGxlcmBzIHNlZWthYmxlXG4gICAqIGZ1bmN0aW9uIGlmIGl0IGV4aXN0cywgd2l0aCBhIGZhbGxiYWNrIHRvIHRoZSBUZWNocyBzZWVrYWJsZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQG1ldGhvZCBfVGVjaC5zZWVrYWJsZVxuICAgKi9cblxuICAvKipcbiAgICogQSB3cmFwcGVyIGFyb3VuZCB7QGxpbmsgVGVjaCNkdXJhdGlvbn0gdGhhdCB3aWxsIGNhbGwgYSBgU291cmNlSGFuZGxlcmBzIGR1cmF0aW9uXG4gICAqIGZ1bmN0aW9uIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIGl0IHdpbGwgZmFsbGJhY2sgdG8gdGhlIHRlY2hzIGR1cmF0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbWV0aG9kIF9UZWNoLmR1cmF0aW9uXG4gICAqL1xuXG4gIGRlZmVycmFibGUuZm9yRWFjaChmdW5jdGlvbiAoZm5OYW1lKSB7XG4gICAgdmFyIG9yaWdpbmFsRm4gPSB0aGlzW2ZuTmFtZV07XG5cbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzW2ZuTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXyAmJiB0aGlzLnNvdXJjZUhhbmRsZXJfW2ZuTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlSGFuZGxlcl9bZm5OYW1lXS5hcHBseSh0aGlzLnNvdXJjZUhhbmRsZXJfLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9LCBfVGVjaC5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmdW5jdGlvbiBmb3Igc2V0dGluZyB0aGUgc291cmNlIHVzaW5nIGEgc291cmNlIG9iamVjdFxuICAgKiBhbmQgc291cmNlIGhhbmRsZXJzLlxuICAgKiBTaG91bGQgbmV2ZXIgYmUgY2FsbGVkIHVubGVzcyBhIHNvdXJjZSBoYW5kbGVyIHdhcyBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gICAqICAgICAgICBBIHNvdXJjZSBvYmplY3Qgd2l0aCBzcmMgYW5kIHR5cGUga2V5c1xuICAgKi9cbiAgX1RlY2gucHJvdG90eXBlLnNldFNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICB2YXIgc2ggPSBfVGVjaC5zZWxlY3RTb3VyY2VIYW5kbGVyKHNvdXJjZSwgdGhpcy5vcHRpb25zXyk7XG5cbiAgICBpZiAoIXNoKSB7XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gYSBuYXRpdmUgc291cmNlIGhhbmRlciB3aGVuIHVuc3VwcG9ydGVkIHNvdXJjZXMgYXJlXG4gICAgICAvLyBkZWxpYmVyYXRlbHkgc2V0XG4gICAgICBpZiAoX1RlY2gubmF0aXZlU291cmNlSGFuZGxlcikge1xuICAgICAgICBzaCA9IF9UZWNoLm5hdGl2ZVNvdXJjZUhhbmRsZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2ckMS5lcnJvcignTm8gc291cmNlIGhhbmRsZXIgZm91bmQgZm9yIHRoZSBjdXJyZW50IHNvdXJjZS4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNwb3NlIGFueSBleGlzdGluZyBzb3VyY2UgaGFuZGxlclxuICAgIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIoKTtcbiAgICB0aGlzLm9mZignZGlzcG9zZScsIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIpO1xuXG4gICAgaWYgKHNoICE9PSBfVGVjaC5uYXRpdmVTb3VyY2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTb3VyY2VfID0gc291cmNlO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlSGFuZGxlcl8gPSBzaC5oYW5kbGVTb3VyY2Uoc291cmNlLCB0aGlzLCB0aGlzLm9wdGlvbnNfKTtcbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGFueSBleGlzdGluZyBTb3VyY2VIYW5kbGVycyBhbmQgbGlzdGVuZXJzIHdoZW4gdGhlIFRlY2ggaXMgZGlzcG9zZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjZGlzcG9zZVxuICAgKi9cbiAgX1RlY2gucHJvdG90eXBlLmRpc3Bvc2VTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGlmIHdlIGhhdmUgYSBzb3VyY2UgYW5kIGdldCBhbm90aGVyIG9uZVxuICAgIC8vIHRoZW4gd2UgYXJlIGxvYWRpbmcgc29tZXRoaW5nIG5ld1xuICAgIC8vIHRoYW4gY2xlYXIgYWxsIG9mIG91ciBjdXJyZW50IHRyYWNrc1xuICAgIGlmICh0aGlzLmN1cnJlbnRTb3VyY2VfKSB7XG4gICAgICB0aGlzLmNsZWFyVHJhY2tzKFsnYXVkaW8nLCAndmlkZW8nXSk7XG4gICAgICB0aGlzLmN1cnJlbnRTb3VyY2VfID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBhbHdheXMgY2xlYW4gdXAgYXV0by10ZXh0IHRyYWNrc1xuICAgIHRoaXMuY2xlYW51cEF1dG9UZXh0VHJhY2tzKCk7XG5cbiAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXykge1xuXG4gICAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXy5kaXNwb3NlKSB7XG4gICAgICAgIHRoaXMuc291cmNlSGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNvdXJjZUhhbmRsZXJfID0gbnVsbDtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBUaGUgYmFzZSBUZWNoIGNsYXNzIG5lZWRzIHRvIGJlIHJlZ2lzdGVyZWQgYXMgYSBDb21wb25lbnQuIEl0IGlzIHRoZSBvbmx5XG4vLyBUZWNoIHRoYXQgY2FuIGJlIHJlZ2lzdGVyZWQgYXMgYSBDb21wb25lbnQuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RlY2gnLCBUZWNoKTtcblRlY2gucmVnaXN0ZXJUZWNoKCdUZWNoJywgVGVjaCk7XG5cbi8qKlxuICogQSBsaXN0IG9mIHRlY2hzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRlY2hPcmRlciBvbiBQbGF5ZXJzXG4gKlxuICogQHByaXZhdGVcbiAqL1xuVGVjaC5kZWZhdWx0VGVjaE9yZGVyXyA9IFtdO1xuXG52YXIgbWlkZGxld2FyZXMgPSB7fTtcbnZhciBtaWRkbGV3YXJlSW5zdGFuY2VzID0ge307XG5cbnZhciBURVJNSU5BVE9SID0ge307XG5cbmZ1bmN0aW9uIHVzZSh0eXBlLCBtaWRkbGV3YXJlKSB7XG4gIG1pZGRsZXdhcmVzW3R5cGVdID0gbWlkZGxld2FyZXNbdHlwZV0gfHwgW107XG4gIG1pZGRsZXdhcmVzW3R5cGVdLnB1c2gobWlkZGxld2FyZSk7XG59XG5cbmZ1bmN0aW9uIHNldFNvdXJjZShwbGF5ZXIsIHNyYywgbmV4dCkge1xuICBwbGF5ZXIuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNldFNvdXJjZUhlbHBlcihzcmMsIG1pZGRsZXdhcmVzW3NyYy50eXBlXSwgbmV4dCwgcGxheWVyKTtcbiAgfSwgMSk7XG59XG5cbmZ1bmN0aW9uIHNldFRlY2gobWlkZGxld2FyZSwgdGVjaCkge1xuICBtaWRkbGV3YXJlLmZvckVhY2goZnVuY3Rpb24gKG13KSB7XG4gICAgcmV0dXJuIG13LnNldFRlY2ggJiYgbXcuc2V0VGVjaCh0ZWNoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2FsbHMgYSBnZXR0ZXIgb24gdGhlIHRlY2ggZmlyc3QsIHRocm91Z2ggZWFjaCBtaWRkbGV3YXJlXG4gKiBmcm9tIHJpZ2h0IHRvIGxlZnQgdG8gdGhlIHBsYXllci5cbiAqL1xuZnVuY3Rpb24gZ2V0JDEobWlkZGxld2FyZSwgdGVjaCwgbWV0aG9kKSB7XG4gIHJldHVybiBtaWRkbGV3YXJlLnJlZHVjZVJpZ2h0KG1pZGRsZXdhcmVJdGVyYXRvcihtZXRob2QpLCB0ZWNoW21ldGhvZF0oKSk7XG59XG5cbi8qKlxuICogVGFrZXMgdGhlIGFyZ3VtZW50IGdpdmVuIHRvIHRoZSBwbGF5ZXIgYW5kIGNhbGxzIHRoZSBzZXR0ZXIgbWV0aG9kIG9uIGVhY2hcbiAqIG1pZGRsZXdhcmUgZnJvbSBsZWZ0IHRvIHJpZ2h0IHRvIHRoZSB0ZWNoLlxuICovXG5mdW5jdGlvbiBzZXQkMShtaWRkbGV3YXJlLCB0ZWNoLCBtZXRob2QsIGFyZykge1xuICByZXR1cm4gdGVjaFttZXRob2RdKG1pZGRsZXdhcmUucmVkdWNlKG1pZGRsZXdhcmVJdGVyYXRvcihtZXRob2QpLCBhcmcpKTtcbn1cblxuLyoqXG4gKiBUYWtlcyB0aGUgYXJndW1lbnQgZ2l2ZW4gdG8gdGhlIHBsYXllciBhbmQgY2FsbHMgdGhlIGBjYWxsYCB2ZXJzaW9uIG9mIHRoZSBtZXRob2RcbiAqIG9uIGVhY2ggbWlkZGxld2FyZSBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiBUaGVuLCBjYWxsIHRoZSBwYXNzZWQgaW4gbWV0aG9kIG9uIHRoZSB0ZWNoIGFuZCByZXR1cm4gdGhlIHJlc3VsdCB1bmNoYW5nZWRcbiAqIGJhY2sgdG8gdGhlIHBsYXllciwgdGhyb3VnaCBtaWRkbGV3YXJlLCB0aGlzIHRpbWUgZnJvbSByaWdodCB0byBsZWZ0LlxuICovXG5mdW5jdGlvbiBtZWRpYXRlKG1pZGRsZXdhcmUsIHRlY2gsIG1ldGhvZCkge1xuICB2YXIgYXJnID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHZhciBjYWxsTWV0aG9kID0gJ2NhbGwnICsgdG9UaXRsZUNhc2UobWV0aG9kKTtcbiAgdmFyIG1pZGRsZXdhcmVWYWx1ZSA9IG1pZGRsZXdhcmUucmVkdWNlKG1pZGRsZXdhcmVJdGVyYXRvcihjYWxsTWV0aG9kKSwgYXJnKTtcbiAgdmFyIHRlcm1pbmF0ZWQgPSBtaWRkbGV3YXJlVmFsdWUgPT09IFRFUk1JTkFUT1I7XG4gIHZhciByZXR1cm5WYWx1ZSA9IHRlcm1pbmF0ZWQgPyBudWxsIDogdGVjaFttZXRob2RdKG1pZGRsZXdhcmVWYWx1ZSk7XG5cbiAgZXhlY3V0ZVJpZ2h0KG1pZGRsZXdhcmUsIG1ldGhvZCwgcmV0dXJuVmFsdWUsIHRlcm1pbmF0ZWQpO1xuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxudmFyIGFsbG93ZWRHZXR0ZXJzID0ge1xuICBidWZmZXJlZDogMSxcbiAgY3VycmVudFRpbWU6IDEsXG4gIGR1cmF0aW9uOiAxLFxuICBzZWVrYWJsZTogMSxcbiAgcGxheWVkOiAxLFxuICBwYXVzZWQ6IDFcbn07XG5cbnZhciBhbGxvd2VkU2V0dGVycyA9IHtcbiAgc2V0Q3VycmVudFRpbWU6IDFcbn07XG5cbnZhciBhbGxvd2VkTWVkaWF0b3JzID0ge1xuICBwbGF5OiAxLFxuICBwYXVzZTogMVxufTtcblxuZnVuY3Rpb24gbWlkZGxld2FyZUl0ZXJhdG9yKG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBtdykge1xuICAgIC8vIGlmIHRoZSBwcmV2aW91cyBtaWRkbGV3YXJlIHRlcm1pbmF0ZWQsIHBhc3MgYWxvbmcgdGhlIHRlcm1pbmF0aW9uXG4gICAgaWYgKHZhbHVlID09PSBURVJNSU5BVE9SKSB7XG4gICAgICByZXR1cm4gVEVSTUlOQVRPUjtcbiAgICB9XG5cbiAgICBpZiAobXdbbWV0aG9kXSkge1xuICAgICAgcmV0dXJuIG13W21ldGhvZF0odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhlY3V0ZVJpZ2h0KG13cywgbWV0aG9kLCB2YWx1ZSwgdGVybWluYXRlZCkge1xuICBmb3IgKHZhciBpID0gbXdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIG13ID0gbXdzW2ldO1xuXG4gICAgaWYgKG13W21ldGhvZF0pIHtcbiAgICAgIG13W21ldGhvZF0odGVybWluYXRlZCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhckNhY2hlRm9yUGxheWVyKHBsYXllcikge1xuICBtaWRkbGV3YXJlSW5zdGFuY2VzW3BsYXllci5pZCgpXSA9IG51bGw7XG59XG5cbi8qKlxuICoge1xuICogIFtwbGF5ZXJJZF06IFtbbXdGYWN0b3J5LCBtd0luc3RhbmNlXSwgLi4uXVxuICogfVxuICovXG5mdW5jdGlvbiBnZXRPckNyZWF0ZUZhY3RvcnkocGxheWVyLCBtd0ZhY3RvcnkpIHtcbiAgdmFyIG13cyA9IG1pZGRsZXdhcmVJbnN0YW5jZXNbcGxheWVyLmlkKCldO1xuICB2YXIgbXcgPSBudWxsO1xuXG4gIGlmIChtd3MgPT09IHVuZGVmaW5lZCB8fCBtd3MgPT09IG51bGwpIHtcbiAgICBtdyA9IG13RmFjdG9yeShwbGF5ZXIpO1xuICAgIG1pZGRsZXdhcmVJbnN0YW5jZXNbcGxheWVyLmlkKCldID0gW1ttd0ZhY3RvcnksIG13XV07XG4gICAgcmV0dXJuIG13O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtd3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX213cyRpID0gbXdzW2ldLFxuICAgICAgICBtd2YgPSBfbXdzJGlbMF0sXG4gICAgICAgIG13aSA9IF9td3MkaVsxXTtcblxuXG4gICAgaWYgKG13ZiAhPT0gbXdGYWN0b3J5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBtdyA9IG13aTtcbiAgfVxuXG4gIGlmIChtdyA9PT0gbnVsbCkge1xuICAgIG13ID0gbXdGYWN0b3J5KHBsYXllcik7XG4gICAgbXdzLnB1c2goW213RmFjdG9yeSwgbXddKTtcbiAgfVxuXG4gIHJldHVybiBtdztcbn1cblxuZnVuY3Rpb24gc2V0U291cmNlSGVscGVyKCkge1xuICB2YXIgc3JjID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIG1pZGRsZXdhcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICB2YXIgbmV4dCA9IGFyZ3VtZW50c1syXTtcbiAgdmFyIHBsYXllciA9IGFyZ3VtZW50c1szXTtcbiAgdmFyIGFjYyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogW107XG4gIHZhciBsYXN0UnVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBmYWxzZTtcbiAgdmFyIG13RmFjdG9yeSA9IG1pZGRsZXdhcmVbMF0sXG4gICAgICBtd3Jlc3QgPSBtaWRkbGV3YXJlLnNsaWNlKDEpO1xuXG4gIC8vIGlmIG13RmFjdG9yeSBpcyBhIHN0cmluZywgdGhlbiB3ZSdyZSBhdCBhIGZvcmsgaW4gdGhlIHJvYWRcblxuICBpZiAodHlwZW9mIG13RmFjdG9yeSA9PT0gJ3N0cmluZycpIHtcbiAgICBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtaWRkbGV3YXJlc1ttd0ZhY3RvcnldLCBuZXh0LCBwbGF5ZXIsIGFjYywgbGFzdFJ1bik7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGFuIG13RmFjdG9yeSwgY2FsbCBpdCB3aXRoIHRoZSBwbGF5ZXIgdG8gZ2V0IHRoZSBtdyxcbiAgICAvLyB0aGVuIGNhbGwgdGhlIG13J3Mgc2V0U291cmNlIG1ldGhvZFxuICB9IGVsc2UgaWYgKG13RmFjdG9yeSkge1xuICAgIHZhciBtdyA9IGdldE9yQ3JlYXRlRmFjdG9yeShwbGF5ZXIsIG13RmFjdG9yeSk7XG5cbiAgICAvLyBpZiBzZXRTb3VyY2UgaXNuJ3QgcHJlc2VudCwgaW1wbGljaXRseSBzZWxlY3QgdGhpcyBtaWRkbGV3YXJlXG4gICAgaWYgKCFtdy5zZXRTb3VyY2UpIHtcbiAgICAgIGFjYy5wdXNoKG13KTtcbiAgICAgIHJldHVybiBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtd3Jlc3QsIG5leHQsIHBsYXllciwgYWNjLCBsYXN0UnVuKTtcbiAgICB9XG5cbiAgICBtdy5zZXRTb3VyY2UoYXNzaWduKHt9LCBzcmMpLCBmdW5jdGlvbiAoZXJyLCBfc3JjKSB7XG5cbiAgICAgIC8vIHNvbWV0aGluZyBoYXBwZW5lZCwgdHJ5IHRoZSBuZXh0IG1pZGRsZXdhcmUgb24gdGhlIGN1cnJlbnQgbGV2ZWxcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byB1c2UgdGhlIG9sZCBzcmNcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHNldFNvdXJjZUhlbHBlcihzcmMsIG13cmVzdCwgbmV4dCwgcGxheWVyLCBhY2MsIGxhc3RSdW4pO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSd2ZSBzdWNjZWVkZWQsIG5vdyB3ZSBuZWVkIHRvIGdvIGRlZXBlclxuICAgICAgYWNjLnB1c2gobXcpO1xuXG4gICAgICAvLyBpZiBpdCdzIHRoZSBzYW1lIHR5cGUsIGNvbnRpbnVlIGRvd24gdGhlIGN1cnJlbnQgY2hhaW5cbiAgICAgIC8vIG90aGVyd2lzZSwgd2Ugd2FudCB0byBnbyBkb3duIHRoZSBuZXcgY2hhaW5cbiAgICAgIHNldFNvdXJjZUhlbHBlcihfc3JjLCBzcmMudHlwZSA9PT0gX3NyYy50eXBlID8gbXdyZXN0IDogbWlkZGxld2FyZXNbX3NyYy50eXBlXSwgbmV4dCwgcGxheWVyLCBhY2MsIGxhc3RSdW4pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG13cmVzdC5sZW5ndGgpIHtcbiAgICBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtd3Jlc3QsIG5leHQsIHBsYXllciwgYWNjLCBsYXN0UnVuKTtcbiAgfSBlbHNlIGlmIChsYXN0UnVuKSB7XG4gICAgbmV4dChzcmMsIGFjYyk7XG4gIH0gZWxzZSB7XG4gICAgc2V0U291cmNlSGVscGVyKHNyYywgbWlkZGxld2FyZXNbJyonXSwgbmV4dCwgcGxheWVyLCBhY2MsIHRydWUpO1xuICB9XG59XG5cbi8qKlxuICogTWltZXR5cGVzXG4gKlxuICogQHNlZSBodHRwOi8vaHVsLmhhcnZhcmQuZWR1L29pcy8vLy8vc3lzdGVtcy93YXgvd2F4LXB1YmxpYy1oZWxwL21pbWV0eXBlcy5odG1cbiAqIEB0eXBlZGVmIE1pbWV0eXBlc35LaW5kXG4gKiBAZW51bVxuICovXG52YXIgTWltZXR5cGVzS2luZCA9IHtcbiAgb3B1czogJ3ZpZGVvL29nZycsXG4gIG9ndjogJ3ZpZGVvL29nZycsXG4gIG1wNDogJ3ZpZGVvL21wNCcsXG4gIG1vdjogJ3ZpZGVvL21wNCcsXG4gIG00djogJ3ZpZGVvL21wNCcsXG4gIG1rdjogJ3ZpZGVvL3gtbWF0cm9za2EnLFxuICBtcDM6ICdhdWRpby9tcGVnJyxcbiAgYWFjOiAnYXVkaW8vYWFjJyxcbiAgb2dhOiAnYXVkaW8vb2dnJyxcbiAgbTN1ODogJ2FwcGxpY2F0aW9uL3gtbXBlZ1VSTCdcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtaW1ldHlwZSBvZiBhIGdpdmVuIHNyYyB1cmwgaWYgcG9zc2libGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjXG4gKiAgICAgICAgVGhlIHVybCB0byB0aGUgc3JjXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICByZXR1cm4gdGhlIG1pbWV0eXBlIGlmIGl0IHdhcyBrbm93biBvciBlbXB0eSBzdHJpbmcgb3RoZXJ3aXNlXG4gKi9cbnZhciBnZXRNaW1ldHlwZSA9IGZ1bmN0aW9uIGdldE1pbWV0eXBlKCkge1xuICB2YXIgc3JjID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcblxuICB2YXIgZXh0ID0gZ2V0RmlsZUV4dGVuc2lvbihzcmMpO1xuICB2YXIgbWltZXR5cGUgPSBNaW1ldHlwZXNLaW5kW2V4dC50b0xvd2VyQ2FzZSgpXTtcblxuICByZXR1cm4gbWltZXR5cGUgfHwgJyc7XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIG1pbWUgdHlwZSBvZiBhIGdpdmVuIHNvdXJjZSBzdHJpbmcgaWYgcG9zc2libGUuIFVzZXMgdGhlIHBsYXllclxuICogc291cmNlIGNhY2hlLlxuICpcbiAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAqICAgICAgICBUaGUgcGxheWVyIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNcbiAqICAgICAgICBUaGUgc291cmNlIHN0cmluZ1xuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIHR5cGUgdGhhdCB3YXMgZm91bmRcbiAqL1xudmFyIGZpbmRNaW1ldHlwZSA9IGZ1bmN0aW9uIGZpbmRNaW1ldHlwZShwbGF5ZXIsIHNyYykge1xuICBpZiAoIXNyYykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIDEuIGNoZWNrIGZvciB0aGUgdHlwZSBpbiB0aGUgYHNvdXJjZWAgY2FjaGVcbiAgaWYgKHBsYXllci5jYWNoZV8uc291cmNlLnNyYyA9PT0gc3JjICYmIHBsYXllci5jYWNoZV8uc291cmNlLnR5cGUpIHtcbiAgICByZXR1cm4gcGxheWVyLmNhY2hlXy5zb3VyY2UudHlwZTtcbiAgfVxuXG4gIC8vIDIuIHNlZSBpZiB3ZSBoYXZlIHRoaXMgc291cmNlIGluIG91ciBgY3VycmVudFNvdXJjZXNgIGNhY2hlXG4gIHZhciBtYXRjaGluZ1NvdXJjZXMgPSBwbGF5ZXIuY2FjaGVfLnNvdXJjZXMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMuc3JjID09PSBzcmM7XG4gIH0pO1xuXG4gIGlmIChtYXRjaGluZ1NvdXJjZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG1hdGNoaW5nU291cmNlc1swXS50eXBlO1xuICB9XG5cbiAgLy8gMy4gbG9vayBmb3IgdGhlIHNyYyB1cmwgaW4gc291cmNlIGVsZW1lbnRzIGFuZCB1c2UgdGhlIHR5cGUgdGhlcmVcbiAgdmFyIHNvdXJjZXMgPSBwbGF5ZXIuJCQoJ3NvdXJjZScpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gc291cmNlc1tpXTtcblxuICAgIGlmIChzLnR5cGUgJiYgcy5zcmMgJiYgcy5zcmMgPT09IHNyYykge1xuICAgICAgcmV0dXJuIHMudHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyA0LiBmaW5hbGx5IGZhbGxiYWNrIHRvIG91ciBsaXN0IG9mIG1pbWUgdHlwZXMgYmFzZWQgb24gc3JjIHVybCBleHRlbnNpb25cbiAgcmV0dXJuIGdldE1pbWV0eXBlKHNyYyk7XG59O1xuXG4vKipcbiAqIEBtb2R1bGUgZmlsdGVyLXNvdXJjZVxuICovXG5cbi8qKlxuICogRmlsdGVyIG91dCBzaW5nbGUgYmFkIHNvdXJjZSBvYmplY3RzIG9yIG11bHRpcGxlIHNvdXJjZSBvYmplY3RzIGluIGFuXG4gKiBhcnJheS4gQWxzbyBmbGF0dGVucyBuZXN0ZWQgc291cmNlIG9iamVjdCBhcnJheXMgaW50byBhIDEgZGltZW5zaW9uYWxcbiAqIGFycmF5IG9mIHNvdXJjZSBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R8VGVjaH5Tb3VyY2VPYmplY3RbXX0gc3JjXG4gKiAgICAgICAgVGhlIHNyYyBvYmplY3QgdG8gZmlsdGVyXG4gKlxuICogQHJldHVybiB7VGVjaH5Tb3VyY2VPYmplY3RbXX1cbiAqICAgICAgICAgQW4gYXJyYXkgb2Ygc291cmNlb2JqZWN0cyBjb250YWluaW5nIG9ubHkgdmFsaWQgc291cmNlc1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBmaWx0ZXJTb3VyY2UgPSBmdW5jdGlvbiBmaWx0ZXJTb3VyY2Uoc3JjKSB7XG4gIC8vIHRyYXZlcnNlIGFycmF5XG4gIGlmIChBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICB2YXIgbmV3c3JjID0gW107XG5cbiAgICBzcmMuZm9yRWFjaChmdW5jdGlvbiAoc3Jjb2JqKSB7XG4gICAgICBzcmNvYmogPSBmaWx0ZXJTb3VyY2Uoc3Jjb2JqKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3Jjb2JqKSkge1xuICAgICAgICBuZXdzcmMgPSBuZXdzcmMuY29uY2F0KHNyY29iaik7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNyY29iaikpIHtcbiAgICAgICAgbmV3c3JjLnB1c2goc3Jjb2JqKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHNyYyA9IG5ld3NyYztcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyAmJiBzcmMudHJpbSgpKSB7XG4gICAgLy8gY29udmVydCBzdHJpbmcgaW50byBvYmplY3RcbiAgICBzcmMgPSBbZml4U291cmNlKHsgc3JjOiBzcmMgfSldO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNyYykgJiYgdHlwZW9mIHNyYy5zcmMgPT09ICdzdHJpbmcnICYmIHNyYy5zcmMgJiYgc3JjLnNyYy50cmltKCkpIHtcbiAgICAvLyBzcmMgaXMgYWxyZWFkeSB2YWxpZFxuICAgIHNyYyA9IFtmaXhTb3VyY2Uoc3JjKV07XG4gIH0gZWxzZSB7XG4gICAgLy8gaW52YWxpZCBzb3VyY2UsIHR1cm4gaXQgaW50byBhbiBlbXB0eSBhcnJheVxuICAgIHNyYyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIHNyYztcbn07XG5cbi8qKlxuICogQ2hlY2tzIHNyYyBtaW1ldHlwZSwgYWRkaW5nIGl0IHdoZW4gcG9zc2libGVcbiAqXG4gKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzcmNcbiAqICAgICAgICBUaGUgc3JjIG9iamVjdCB0byBjaGVja1xuICogQHJldHVybiB7VGVjaH5Tb3VyY2VPYmplY3R9XG4gKiAgICAgICAgc3JjIE9iamVjdCB3aXRoIGtub3duIHR5cGVcbiAqL1xuZnVuY3Rpb24gZml4U291cmNlKHNyYykge1xuICB2YXIgbWltZXR5cGUgPSBnZXRNaW1ldHlwZShzcmMuc3JjKTtcblxuICBpZiAoIXNyYy50eXBlICYmIG1pbWV0eXBlKSB7XG4gICAgc3JjLnR5cGUgPSBtaW1ldHlwZTtcbiAgfVxuXG4gIHJldHVybiBzcmM7XG59XG5cbi8qKlxuICogQGZpbGUgbG9hZGVyLmpzXG4gKi9cblxuLyoqXG4gKiBUaGUgYE1lZGlhTG9hZGVyYCBpcyB0aGUgYENvbXBvbmVudGAgdGhhdCBkZWNpZGVzIHdoaWNoIHBsYXliYWNrIHRlY2hub2xvZ3kgdG8gbG9hZFxuICogd2hlbiBhIHBsYXllciBpcyBpbml0aWFsaXplZC5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTWVkaWFMb2FkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhNZWRpYUxvYWRlciwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBhdHRhY2ggdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIHJ1biB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gTWVkaWFMb2FkZXIocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1lZGlhTG9hZGVyKTtcblxuICAgIC8vIE1lZGlhTG9hZGVyIGhhcyBubyBlbGVtZW50XG4gICAgdmFyIG9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKHsgY3JlYXRlRWw6IGZhbHNlIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHNvdXJjZXMgd2hlbiB0aGUgcGxheWVyIGlzIGluaXRpYWxpemVkLFxuICAgIC8vIGxvYWQgdGhlIGZpcnN0IHN1cHBvcnRlZCBwbGF5YmFjayB0ZWNobm9sb2d5LlxuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zXywgcmVhZHkpKTtcblxuICAgIGlmICghb3B0aW9ucy5wbGF5ZXJPcHRpb25zLnNvdXJjZXMgfHwgb3B0aW9ucy5wbGF5ZXJPcHRpb25zLnNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IG9wdGlvbnMucGxheWVyT3B0aW9ucy50ZWNoT3JkZXI7IGkgPCBqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ZWNoTmFtZSA9IHRvVGl0bGVDYXNlKGpbaV0pO1xuICAgICAgICB2YXIgdGVjaCA9IFRlY2guZ2V0VGVjaCh0ZWNoTmFtZSk7XG5cbiAgICAgICAgLy8gU3VwcG9ydCBvbGQgYmVoYXZpb3Igb2YgdGVjaHMgYmVpbmcgcmVnaXN0ZXJlZCBhcyBjb21wb25lbnRzLlxuICAgICAgICAvLyBSZW1vdmUgb25jZSB0aGF0IGRlcHJlY2F0ZWQgYmVoYXZpb3IgaXMgcmVtb3ZlZC5cbiAgICAgICAgaWYgKCF0ZWNoTmFtZSkge1xuICAgICAgICAgIHRlY2ggPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KHRlY2hOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoaXMgdGVjaG5vbG9neVxuICAgICAgICBpZiAodGVjaCAmJiB0ZWNoLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICBwbGF5ZXIubG9hZFRlY2hfKHRlY2hOYW1lKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMb29wIHRocm91Z2ggcGxheWJhY2sgdGVjaG5vbG9naWVzIChIVE1MNSwgRmxhc2gpIGFuZCBjaGVjayBmb3Igc3VwcG9ydC5cbiAgICAgIC8vIFRoZW4gbG9hZCB0aGUgYmVzdCBzb3VyY2UuXG4gICAgICAvLyBBIGZldyBhc3N1bXB0aW9ucyBoZXJlOlxuICAgICAgLy8gICBBbGwgcGxheWJhY2sgdGVjaG5vbG9naWVzIHJlc3BlY3QgcHJlbG9hZCBmYWxzZS5cbiAgICAgIHBsYXllci5zcmMob3B0aW9ucy5wbGF5ZXJPcHRpb25zLnNvdXJjZXMpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gTWVkaWFMb2FkZXI7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVkaWFMb2FkZXInLCBNZWRpYUxvYWRlcik7XG5cbi8qKlxuICogQGZpbGUgY2xpY2thYmxlLWNvbXBvbmVudC5qc1xuICovXG5cbi8qKlxuICogQ2xpY2thYmxlIENvbXBvbmVudCB3aGljaCBpcyBjbGlja2FibGUgb3Iga2V5Ym9hcmQgYWN0aW9uYWJsZSxcbiAqIGJ1dCBpcyBub3QgYSBuYXRpdmUgSFRNTCBidXR0b24uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIENsaWNrYWJsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKENsaWNrYWJsZUNvbXBvbmVudCwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2xpY2thYmxlQ29tcG9uZW50KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENsaWNrYWJsZUNvbXBvbmVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmVtaXRUYXBFdmVudHMoKTtcblxuICAgIF90aGlzLmVuYWJsZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0YWc9ZGl2XVxuICAgKiAgICAgICAgVGhlIGVsZW1lbnQncyBub2RlIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlcz17fV1cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIHRhZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2Rpdic7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBwcm9wcyA9IGFzc2lnbih7XG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInZqcy1pY29uLXBsYWNlaG9sZGVyXCI+PC9zcGFuPicsXG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpLFxuICAgICAgdGFiSW5kZXg6IDBcbiAgICB9LCBwcm9wcyk7XG5cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgbG9nJDEuZXJyb3IoJ0NyZWF0aW5nIGEgQ2xpY2thYmxlQ29tcG9uZW50IHdpdGggYW4gSFRNTCBlbGVtZW50IG9mICcgKyB0YWcgKyAnIGlzIG5vdCBzdXBwb3J0ZWQ7IHVzZSBhIEJ1dHRvbiBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIC8vIEFkZCBBUklBIGF0dHJpYnV0ZXMgZm9yIGNsaWNrYWJsZSBlbGVtZW50IHdoaWNoIGlzIG5vdCBhIG5hdGl2ZSBIVE1MIGJ1dHRvblxuICAgIGF0dHJpYnV0ZXMgPSBhc3NpZ24oe1xuICAgICAgcm9sZTogJ2J1dHRvbidcbiAgICB9LCBhdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMudGFiSW5kZXhfID0gcHJvcHMudGFiSW5kZXg7XG5cbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHRhZywgcHJvcHMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgdGhpcy5jcmVhdGVDb250cm9sVGV4dEVsKGVsKTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIC8vIHJlbW92ZSBjb250cm9sVGV4dEVsXyBvbiBkaXNwb3NlXG4gICAgdGhpcy5jb250cm9sVGV4dEVsXyA9IG51bGw7XG5cbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNvbnRyb2wgdGV4dCBlbGVtZW50IG9uIHRoaXMgYENvbXBvbmVudGBcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBbZWxdXG4gICAqICAgICAgICBQYXJlbnQgZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgdGV4dC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgY29udHJvbCB0ZXh0IGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVDb250cm9sVGV4dEVsID0gZnVuY3Rpb24gY3JlYXRlQ29udHJvbFRleHRFbChlbCkge1xuICAgIHRoaXMuY29udHJvbFRleHRFbF8gPSBjcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLXRleHQnXG4gICAgfSwge1xuICAgICAgLy8gbGV0IHRoZSBzY3JlZW4gcmVhZGVyIHVzZXIga25vdyB0aGF0IHRoZSB0ZXh0IG9mIHRoZSBlbGVtZW50IG1heSBjaGFuZ2VcbiAgICAgICdhcmlhLWxpdmUnOiAncG9saXRlJ1xuICAgIH0pO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRyb2xUZXh0RWxfKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xUZXh0KHRoaXMuY29udHJvbFRleHRfLCBlbCk7XG5cbiAgICByZXR1cm4gdGhpcy5jb250cm9sVGV4dEVsXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgbG9jYWxpemUgdGV4dCB0byB1c2UgZm9yIHRoZSBjb250cm9scyBvbiB0aGUgYENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dF1cbiAgICogICAgICAgIENvbnRyb2wgdGV4dCBmb3IgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBbZWw9dGhpcy5lbCgpXVxuICAgKiAgICAgICAgRWxlbWVudCB0byBzZXQgdGhlIHRpdGxlIG9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgLSBUaGUgY29udHJvbCB0ZXh0IHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuY29udHJvbFRleHQgPSBmdW5jdGlvbiBjb250cm9sVGV4dCh0ZXh0KSB7XG4gICAgdmFyIGVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmVsKCk7XG5cbiAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250cm9sVGV4dF8gfHwgJ05lZWQgVGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsaXplZFRleHQgPSB0aGlzLmxvY2FsaXplKHRleHQpO1xuXG4gICAgdGhpcy5jb250cm9sVGV4dF8gPSB0ZXh0O1xuICAgIHRleHRDb250ZW50KHRoaXMuY29udHJvbFRleHRFbF8sIGxvY2FsaXplZFRleHQpO1xuICAgIGlmICghdGhpcy5ub25JY29uQ29udHJvbCkge1xuICAgICAgLy8gU2V0IHRpdGxlIGF0dHJpYnV0ZSBpZiBvbmx5IGFuIGljb24gaXMgc2hvd25cbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBsb2NhbGl6ZWRUZXh0KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWNvbnRyb2wgdmpzLWJ1dHRvbiAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhpcyBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZF8pIHtcbiAgICAgIHRoaXMuZW5hYmxlZF8gPSB0cnVlO1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWRpc2FibGVkJyk7XG4gICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy50YWJJbmRleF8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCB0aGlzLnRhYkluZGV4Xyk7XG4gICAgICB9XG4gICAgICB0aGlzLm9uKFsndGFwJywgJ2NsaWNrJ10sIHRoaXMuaGFuZGxlQ2xpY2spO1xuICAgICAgdGhpcy5vbignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzKTtcbiAgICAgIHRoaXMub24oJ2JsdXInLCB0aGlzLmhhbmRsZUJsdXIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZSB0aGlzIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgdGhpcy5lbmFibGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1kaXNhYmxlZCcpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnRhYkluZGV4XyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuZWxfLnJlbW92ZUF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICB9XG4gICAgdGhpcy5vZmYoWyd0YXAnLCAnY2xpY2snXSwgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgdGhpcy5vZmYoJ2ZvY3VzJywgdGhpcy5oYW5kbGVGb2N1cyk7XG4gICAgdGhpcy5vZmYoJ2JsdXInLCB0aGlzLmhhbmRsZUJsdXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQ2xpY2thYmxlQ29tcG9uZW50YCBnZXRzOlxuICAgKiAtIENsaWNrZWQgKHZpYSB0aGUgYGNsaWNrYCBldmVudCwgbGlzdGVuaW5nIHN0YXJ0cyBpbiB0aGUgY29uc3RydWN0b3IpXG4gICAqIC0gVGFwcGVkICh2aWEgdGhlIGB0YXBgIGV2ZW50LCBsaXN0ZW5pbmcgc3RhcnRzIGluIHRoZSBjb25zdHJ1Y3RvcilcbiAgICogLSBUaGUgZm9sbG93aW5nIHRoaW5ncyBoYXBwZW4gaW4gb3JkZXI6XG4gICAqICAgMS4ge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVGb2N1c30gaXMgY2FsbGVkIHZpYSBhIGBmb2N1c2AgZXZlbnQgb24gdGhlXG4gICAqICAgICAgYENsaWNrYWJsZUNvbXBvbmVudGAuXG4gICAqICAgMi4ge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVGb2N1c30gYWRkcyBhIGxpc3RlbmVyIGZvciBga2V5ZG93bmAgb24gdXNpbmdcbiAgICogICAgICB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUtleVByZXNzfS5cbiAgICogICAzLiBgQ2xpY2thYmxlQ29tcG9uZW50YCBoYXMgbm90IGhhZCBhIGBibHVyYCBldmVudCAoYGJsdXJgIG1lYW5zIHRoYXQgZm9jdXMgd2FzIGxvc3QpLiBUaGUgdXNlciBwcmVzc2VzXG4gICAqICAgICAgdGhlIHNwYWNlIG9yIGVudGVyIGtleS5cbiAgICogICA0LiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUtleVByZXNzfSBjYWxscyB0aGlzIGZ1bmN0aW9uIHdpdGggdGhlIGBrZXlkb3duYFxuICAgKiAgICAgIGV2ZW50IGFzIGEgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7fTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGEgYENsaWNrYWJsZUNvbXBvbmVudGAgZ2FpbnMgZm9jdXMgdmlhIGEgYGZvY3VzYCBldmVudC5cbiAgICogVHVybnMgb24gbGlzdGVuaW5nIGZvciBga2V5ZG93bmAgZXZlbnRzLiBXaGVuIHRoZXkgaGFwcGVuIGl0XG4gICAqIGNhbGxzIGB0aGlzLmhhbmRsZUtleVByZXNzYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgZm9jdXNgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBmb2N1c1xuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cyhldmVudCkge1xuICAgIG9uKGRvY3VtZW50LCAna2V5ZG93bicsIGJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGlzIENsaWNrYWJsZUNvbXBvbmVudCBoYXMgZm9jdXMgYW5kIGEga2V5IGdldHMgcHJlc3NlZCBkb3duLiBCeVxuICAgKiBkZWZhdWx0IGl0IHdpbGwgY2FsbCBgdGhpcy5oYW5kbGVDbGlja2Agd2hlbiB0aGUga2V5IGlzIHNwYWNlIG9yIGVudGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuXG4gICAgLy8gU3VwcG9ydCBTcGFjZSAoMzIpIG9yIEVudGVyICgxMykga2V5IG9wZXJhdGlvbiB0byBmaXJlIGEgY2xpY2sgZXZlbnRcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDMyIHx8IGV2ZW50LndoaWNoID09PSAxMykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMudHJpZ2dlcignY2xpY2snKTtcbiAgICB9IGVsc2UgaWYgKF9Db21wb25lbnQucHJvdG90eXBlLmhhbmRsZUtleVByZXNzKSB7XG5cbiAgICAgIC8vIFBhc3Mga2V5cHJlc3MgaGFuZGxpbmcgdXAgZm9yIHVuc3VwcG9ydGVkIGtleXNcbiAgICAgIF9Db21wb25lbnQucHJvdG90eXBlLmhhbmRsZUtleVByZXNzLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBgQ2xpY2thYmxlQ29tcG9uZW50YCBsb3NlcyBmb2N1cy4gVHVybnMgb2ZmIHRoZSBsaXN0ZW5lciBmb3JcbiAgICogYGtleWRvd25gIGV2ZW50cy4gV2hpY2ggU3RvcHMgYHRoaXMuaGFuZGxlS2V5UHJlc3NgIGZyb20gZ2V0dGluZyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGJsdXJgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBibHVyXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVCbHVyID0gZnVuY3Rpb24gaGFuZGxlQmx1cihldmVudCkge1xuICAgIG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgfTtcblxuICByZXR1cm4gQ2xpY2thYmxlQ29tcG9uZW50O1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NsaWNrYWJsZUNvbXBvbmVudCcsIENsaWNrYWJsZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGZpbGUgcG9zdGVyLWltYWdlLmpzXG4gKi9cblxuLyoqXG4gKiBBIGBDbGlja2FibGVDb21wb25lbnRgIHRoYXQgaGFuZGxlcyBzaG93aW5nIHRoZSBwb3N0ZXIgaW1hZ2UgZm9yIHRoZSBwbGF5ZXIuXG4gKlxuICogQGV4dGVuZHMgQ2xpY2thYmxlQ29tcG9uZW50XG4gKi9cblxudmFyIFBvc3RlckltYWdlID0gZnVuY3Rpb24gKF9DbGlja2FibGVDb21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUG9zdGVySW1hZ2UsIF9DbGlja2FibGVDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYXR0YWNoIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUG9zdGVySW1hZ2UocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9zdGVySW1hZ2UpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ2xpY2thYmxlQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGUoKTtcbiAgICBwbGF5ZXIub24oJ3Bvc3RlcmNoYW5nZScsIGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZSkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBhbmQgZGlzcG9zZSBvZiB0aGUgYFBvc3RlckltYWdlYC5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5wbGF5ZXIoKS5vZmYoJ3Bvc3RlcmNoYW5nZScsIHRoaXMudXBkYXRlKTtcbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYFBvc3RlckltYWdlYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUG9zdGVySW1hZ2UucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGVsID0gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wb3N0ZXInLFxuXG4gICAgICAvLyBEb24ndCB3YW50IHBvc3RlciB0byBiZSB0YWJiYWJsZS5cbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbiB7QGxpbmsgRXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm9yIHtAbGluayBQbGF5ZXIjcG9zdGVyY2hhbmdlfSBldmVudHMuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNwb3N0ZXJjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXIjcG9zdGVyY2hhbmdlYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICB2YXIgdXJsID0gdGhpcy5wbGF5ZXIoKS5wb3N0ZXIoKTtcblxuICAgIHRoaXMuc2V0U3JjKHVybCk7XG5cbiAgICAvLyBJZiB0aGVyZSdzIG5vIHBvc3RlciBzb3VyY2Ugd2Ugc2hvdWxkIGRpc3BsYXk6bm9uZSBvbiB0aGlzIGNvbXBvbmVudFxuICAgIC8vIHNvIGl0J3Mgbm90IHN0aWxsIGNsaWNrYWJsZSBvciByaWdodC1jbGlja2FibGVcbiAgICBpZiAodXJsKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBvZiB0aGUgYFBvc3RlckltYWdlYCBkZXBlbmRpbmcgb24gdGhlIGRpc3BsYXkgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqICAgICAgICBUaGUgVVJMIHRvIHRoZSBzb3VyY2UgZm9yIHRoZSBgUG9zdGVySW1hZ2VgLlxuICAgKi9cblxuXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS5zZXRTcmMgPSBmdW5jdGlvbiBzZXRTcmModXJsKSB7XG4gICAgdmFyIGJhY2tncm91bmRJbWFnZSA9ICcnO1xuXG4gICAgLy8gQW55IGZhbHN5IHZhbHVlIHNob3VsZCBzdGF5IGFzIGFuIGVtcHR5IHN0cmluZywgb3RoZXJ3aXNlXG4gICAgLy8gdGhpcyB3aWxsIHRocm93IGFuIGV4dHJhIGVycm9yXG4gICAgaWYgKHVybCkge1xuICAgICAgYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicgKyB1cmwgKyAnXCIpJztcbiAgICB9XG5cbiAgICB0aGlzLmVsXy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBiYWNrZ3JvdW5kSW1hZ2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFuIHtAbGluayBFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmb3IgY2xpY2tzIG9uIHRoZSBgUG9zdGVySW1hZ2VgLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVDbGlja30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKyAgICAgICAgVGhlIGBjbGlja2AsIGB0YXBgIG9yIGBrZXlkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgYSBjbGljayB0byB0cmlnZ2VyIHBsYXliYWNrIHdoZW4gY29udHJvbHMgYXJlIGRpc2FibGVkXG4gICAgaWYgKCF0aGlzLnBsYXllcl8uY29udHJvbHMoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcbiAgICAgIHNpbGVuY2VQcm9taXNlKHRoaXMucGxheWVyXy5wbGF5KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsYXllcl8ucGF1c2UoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBvc3RlckltYWdlO1xufShDbGlja2FibGVDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1Bvc3RlckltYWdlJywgUG9zdGVySW1hZ2UpO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stZGlzcGxheS5qc1xuICovXG5cbnZhciBkYXJrR3JheSA9ICcjMjIyJztcbnZhciBsaWdodEdyYXkgPSAnI2NjYyc7XG52YXIgZm9udE1hcCA9IHtcbiAgbW9ub3NwYWNlOiAnbW9ub3NwYWNlJyxcbiAgc2Fuc1NlcmlmOiAnc2Fucy1zZXJpZicsXG4gIHNlcmlmOiAnc2VyaWYnLFxuICBtb25vc3BhY2VTYW5zU2VyaWY6ICdcIkFuZGFsZSBNb25vXCIsIFwiTHVjaWRhIENvbnNvbGVcIiwgbW9ub3NwYWNlJyxcbiAgbW9ub3NwYWNlU2VyaWY6ICdcIkNvdXJpZXIgTmV3XCIsIG1vbm9zcGFjZScsXG4gIHByb3BvcnRpb25hbFNhbnNTZXJpZjogJ3NhbnMtc2VyaWYnLFxuICBwcm9wb3J0aW9uYWxTZXJpZjogJ3NlcmlmJyxcbiAgY2FzdWFsOiAnXCJDb21pYyBTYW5zIE1TXCIsIEltcGFjdCwgZmFudGFzeScsXG4gIHNjcmlwdDogJ1wiTW9ub3R5cGUgQ29yc2l2YVwiLCBjdXJzaXZlJyxcbiAgc21hbGxjYXBzOiAnXCJBbmRhbGUgTW9ub1wiLCBcIkx1Y2lkYSBDb25zb2xlXCIsIG1vbm9zcGFjZSwgc2Fucy1zZXJpZidcbn07XG5cbi8qKlxuICogQ29uc3RydWN0IGFuIHJnYmEgY29sb3IgZnJvbSBhIGdpdmVuIGhleCBjb2xvciBjb2RlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2xvclxuICogICAgICAgIEhleCBudW1iZXIgZm9yIGNvbG9yLCBsaWtlICNmMGUgb3IgI2Y2MDRlMi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eVxuICogICAgICAgIFZhbHVlIGZvciBvcGFjaXR5LCAwLjAgLSAxLjAuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgcmdiYSBjb2xvciB0aGF0IHdhcyBjcmVhdGVkLCBsaWtlICdyZ2JhKDI1NSwgMCwgMCwgMC4zKScuXG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdENvbG9yKGNvbG9yLCBvcGFjaXR5KSB7XG4gIHZhciBoZXggPSB2b2lkIDA7XG5cbiAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgIC8vIGNvbG9yIGxvb2tzIGxpa2UgXCIjZjBlXCJcbiAgICBoZXggPSBjb2xvclsxXSArIGNvbG9yWzFdICsgY29sb3JbMl0gKyBjb2xvclsyXSArIGNvbG9yWzNdICsgY29sb3JbM107XG4gIH0gZWxzZSBpZiAoY29sb3IubGVuZ3RoID09PSA3KSB7XG4gICAgLy8gY29sb3IgbG9va3MgbGlrZSBcIiNmNjA0ZTJcIlxuICAgIGhleCA9IGNvbG9yLnNsaWNlKDEpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2xvciBjb2RlIHByb3ZpZGVkLCAnICsgY29sb3IgKyAnOyBtdXN0IGJlIGZvcm1hdHRlZCBhcyBlLmcuICNmMGUgb3IgI2Y2MDRlMi4nKTtcbiAgfVxuICByZXR1cm4gJ3JnYmEoJyArIHBhcnNlSW50KGhleC5zbGljZSgwLCAyKSwgMTYpICsgJywnICsgcGFyc2VJbnQoaGV4LnNsaWNlKDIsIDQpLCAxNikgKyAnLCcgKyBwYXJzZUludChoZXguc2xpY2UoNCwgNiksIDE2KSArICcsJyArIG9wYWNpdHkgKyAnKSc7XG59XG5cbi8qKlxuICogVHJ5IHRvIHVwZGF0ZSB0aGUgc3R5bGUgb2YgYSBET00gZWxlbWVudC4gU29tZSBzdHlsZSBjaGFuZ2VzIHdpbGwgdGhyb3cgYW4gZXJyb3IsXG4gKiBwYXJ0aWN1bGFybHkgaW4gSUU4LiBUaG9zZSBzaG91bGQgYmUgbm9vcHMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBET00gZWxlbWVudCB0byBiZSBzdHlsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlXG4gKiAgICAgICAgVGhlIENTUyBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBzdHlsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqICAgICAgICBUaGUgc3R5bGUgcnVsZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0cnlVcGRhdGVTdHlsZShlbCwgc3R5bGUsIHJ1bGUpIHtcbiAgdHJ5IHtcbiAgICBlbC5zdHlsZVtzdHlsZV0gPSBydWxlO1xuICB9IGNhdGNoIChlKSB7XG5cbiAgICAvLyBTYXRpc2ZpZXMgbGludGVyLlxuICAgIHJldHVybjtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgdGV4dCB0cmFjayBjdWVzLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUZXh0VHJhY2tEaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGV4dFRyYWNrRGlzcGxheSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYFRleHRUcmFja0Rpc3BsYXlgIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XG5cbiAgICBwbGF5ZXIub24oJ2xvYWRzdGFydCcsIGJpbmQoX3RoaXMsIF90aGlzLnRvZ2dsZURpc3BsYXkpKTtcbiAgICBwbGF5ZXIub24oJ3RleHR0cmFja2NoYW5nZScsIGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBwbGF5ZXIub24oJ2xvYWRzdGFydCcsIGJpbmQoX3RoaXMsIF90aGlzLnByZXNlbGVjdFRyYWNrKSk7XG5cbiAgICAvLyBUaGlzIHVzZWQgdG8gYmUgY2FsbGVkIGR1cmluZyBwbGF5ZXIgaW5pdCwgYnV0IHdhcyBjYXVzaW5nIGFuIGVycm9yXG4gICAgLy8gaWYgYSB0cmFjayBzaG91bGQgc2hvdyBieSBkZWZhdWx0IGFuZCB0aGUgZGlzcGxheSBoYWRuJ3QgbG9hZGVkIHlldC5cbiAgICAvLyBTaG91bGQgcHJvYmFibHkgYmUgbW92ZWQgdG8gYW4gZXh0ZXJuYWwgdHJhY2sgbG9hZGVyIHdoZW4gd2Ugc3VwcG9ydFxuICAgIC8vIHRyYWNrcyB0aGF0IGRvbid0IG5lZWQgYSBkaXNwbGF5LlxuICAgIHBsYXllci5yZWFkeShiaW5kKF90aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGxheWVyLnRlY2hfICYmIHBsYXllci50ZWNoXy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGxheWVyLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcblxuICAgICAgdmFyIHRyYWNrcyA9IHRoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucy50cmFja3MgfHwgW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucGxheWVyXy5hZGRSZW1vdGVUZXh0VHJhY2sodHJhY2tzW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmVzZWxlY3RUcmFjaygpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgKiBQcmVzZWxlY3QgYSB0cmFjayBmb2xsb3dpbmcgdGhpcyBwcmVjZWRlbmNlOlxuICAqIC0gbWF0Y2hlcyB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCB7QGxpbmsgVGV4dFRyYWNrfSdzIGxhbmd1YWdlIGFuZCBraW5kXG4gICogLSBtYXRjaGVzIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIHtAbGluayBUZXh0VHJhY2t9J3MgbGFuZ3VhZ2Ugb25seVxuICAqIC0gaXMgdGhlIGZpcnN0IGRlZmF1bHQgY2FwdGlvbnMgdHJhY2tcbiAgKiAtIGlzIHRoZSBmaXJzdCBkZWZhdWx0IGRlc2NyaXB0aW9ucyB0cmFja1xuICAqXG4gICogQGxpc3RlbnMgUGxheWVyI2xvYWRzdGFydFxuICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUucHJlc2VsZWN0VHJhY2sgPSBmdW5jdGlvbiBwcmVzZWxlY3RUcmFjaygpIHtcbiAgICB2YXIgbW9kZXMgPSB7IGNhcHRpb25zOiAxLCBzdWJ0aXRsZXM6IDEgfTtcbiAgICB2YXIgdHJhY2tMaXN0ID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcbiAgICB2YXIgdXNlclByZWYgPSB0aGlzLnBsYXllcl8uY2FjaGVfLnNlbGVjdGVkTGFuZ3VhZ2U7XG4gICAgdmFyIGZpcnN0RGVzYyA9IHZvaWQgMDtcbiAgICB2YXIgZmlyc3RDYXB0aW9ucyA9IHZvaWQgMDtcbiAgICB2YXIgcHJlZmVycmVkVHJhY2sgPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tMaXN0W2ldO1xuXG4gICAgICBpZiAodXNlclByZWYgJiYgdXNlclByZWYuZW5hYmxlZCAmJiB1c2VyUHJlZi5sYW5ndWFnZSA9PT0gdHJhY2subGFuZ3VhZ2UpIHtcbiAgICAgICAgLy8gQWx3YXlzIGNob29zZSB0aGUgdHJhY2sgdGhhdCBtYXRjaGVzIGJvdGggbGFuZ3VhZ2UgYW5kIGtpbmRcbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IHVzZXJQcmVmLmtpbmQpIHtcbiAgICAgICAgICBwcmVmZXJyZWRUcmFjayA9IHRyYWNrO1xuICAgICAgICAgIC8vIG9yIGNob29zZSB0aGUgZmlyc3QgdHJhY2sgdGhhdCBtYXRjaGVzIGxhbmd1YWdlXG4gICAgICAgIH0gZWxzZSBpZiAoIXByZWZlcnJlZFRyYWNrKSB7XG4gICAgICAgICAgcHJlZmVycmVkVHJhY2sgPSB0cmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIGV2ZXJ5dGhpbmcgaWYgb2ZmVGV4dFRyYWNrTWVudUl0ZW0gd2FzIGNsaWNrZWRcbiAgICAgIH0gZWxzZSBpZiAodXNlclByZWYgJiYgIXVzZXJQcmVmLmVuYWJsZWQpIHtcbiAgICAgICAgcHJlZmVycmVkVHJhY2sgPSBudWxsO1xuICAgICAgICBmaXJzdERlc2MgPSBudWxsO1xuICAgICAgICBmaXJzdENhcHRpb25zID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2suZGVmYXVsdCkge1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ2Rlc2NyaXB0aW9ucycgJiYgIWZpcnN0RGVzYykge1xuICAgICAgICAgIGZpcnN0RGVzYyA9IHRyYWNrO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgaW4gbW9kZXMgJiYgIWZpcnN0Q2FwdGlvbnMpIHtcbiAgICAgICAgICBmaXJzdENhcHRpb25zID0gdHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgcHJlZmVycmVkVHJhY2sgbWF0Y2hlcyB0aGUgdXNlciBwcmVmZXJlbmNlIGFuZCB0YWtlc1xuICAgIC8vIHByZWNlZGVuY2Ugb3ZlciBhbGwgdGhlIG90aGVyIHRyYWNrcy5cbiAgICAvLyBTbywgZGlzcGxheSB0aGUgcHJlZmVycmVkVHJhY2sgYmVmb3JlIHRoZSBmaXJzdCBkZWZhdWx0IHRyYWNrXG4gICAgLy8gYW5kIHRoZSBzdWJ0aXRsZXMvY2FwdGlvbnMgdHJhY2sgYmVmb3JlIHRoZSBkZXNjcmlwdGlvbnMgdHJhY2tcbiAgICBpZiAocHJlZmVycmVkVHJhY2spIHtcbiAgICAgIHByZWZlcnJlZFRyYWNrLm1vZGUgPSAnc2hvd2luZyc7XG4gICAgfSBlbHNlIGlmIChmaXJzdENhcHRpb25zKSB7XG4gICAgICBmaXJzdENhcHRpb25zLm1vZGUgPSAnc2hvd2luZyc7XG4gICAgfSBlbHNlIGlmIChmaXJzdERlc2MpIHtcbiAgICAgIGZpcnN0RGVzYy5tb2RlID0gJ3Nob3dpbmcnO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVHVybiBkaXNwbGF5IG9mIHtAbGluayBUZXh0VHJhY2t9J3MgZnJvbSB0aGUgY3VycmVudCBzdGF0ZSBpbnRvIHRoZSBvdGhlciBzdGF0ZS5cbiAgICogVGhlcmUgYXJlIG9ubHkgdHdvIHN0YXRlczpcbiAgICogLSAnc2hvd24nXG4gICAqIC0gJ2hpZGRlbidcbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRzdGFydFxuICAgKi9cblxuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLnRvZ2dsZURpc3BsYXkgPSBmdW5jdGlvbiB0b2dnbGVEaXNwbGF5KCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8udGVjaF8gJiYgdGhpcy5wbGF5ZXJfLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSB7QGxpbmsgQ29tcG9uZW50fSdzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXRleHQtdHJhY2stZGlzcGxheSdcbiAgICB9LCB7XG4gICAgICAnYXJpYS1saXZlJzogJ29mZicsXG4gICAgICAnYXJpYS1hdG9taWMnOiAndHJ1ZSdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGRpc3BsYXllZCB7QGxpbmsgVGV4dFRyYWNrfXMuXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUuY2xlYXJEaXNwbGF5ID0gZnVuY3Rpb24gY2xlYXJEaXNwbGF5KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93JDEuV2ViVlRUID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3aW5kb3ckMS5XZWJWVFQucHJvY2Vzc0N1ZXMod2luZG93JDEsIFtdLCB0aGlzLmVsXyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGRpc3BsYXllZCBUZXh0VHJhY2sgd2hlbiBhIGVpdGhlciBhIHtAbGluayBQbGF5ZXIjdGV4dHRyYWNrY2hhbmdlfSBvclxuICAgKiBhIHtAbGluayBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZX0gaXMgZmlyZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciN0ZXh0dHJhY2tjaGFuZ2VcbiAgICogQGxpc3RlbnMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVEaXNwbGF5ID0gZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcblxuICAgIHRoaXMuY2xlYXJEaXNwbGF5KCk7XG5cbiAgICAvLyBUcmFjayBkaXNwbGF5IHByaW9yaXRpemF0aW9uIG1vZGVsOiBpZiBtdWx0aXBsZSB0cmFja3MgYXJlICdzaG93aW5nJyxcbiAgICAvLyAgZGlzcGxheSB0aGUgZmlyc3QgJ3N1YnRpdGxlcycgb3IgJ2NhcHRpb25zJyB0cmFjayB3aGljaCBpcyAnc2hvd2luZycsXG4gICAgLy8gIG90aGVyd2lzZSBkaXNwbGF5IHRoZSBmaXJzdCAnZGVzY3JpcHRpb25zJyB0cmFjayB3aGljaCBpcyAnc2hvd2luZydcblxuICAgIHZhciBkZXNjcmlwdGlvbnNUcmFjayA9IG51bGw7XG4gICAgdmFyIGNhcHRpb25zU3VidGl0bGVzVHJhY2sgPSBudWxsO1xuICAgIHZhciBpID0gdHJhY2tzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ2Rlc2NyaXB0aW9ucycpIHtcbiAgICAgICAgICBkZXNjcmlwdGlvbnNUcmFjayA9IHRyYWNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHRpb25zU3VidGl0bGVzVHJhY2sgPSB0cmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYXB0aW9uc1N1YnRpdGxlc1RyYWNrKSB7XG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScpICE9PSAnb2ZmJykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ29mZicpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVGb3JUcmFjayhjYXB0aW9uc1N1YnRpdGxlc1RyYWNrKTtcbiAgICB9IGVsc2UgaWYgKGRlc2NyaXB0aW9uc1RyYWNrKSB7XG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScpICE9PSAnYXNzZXJ0aXZlJykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ2Fzc2VydGl2ZScpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVGb3JUcmFjayhkZXNjcmlwdGlvbnNUcmFjayk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYW4ge0BsaW5rIFRleHRUcmFja30gdG8gdG8gdGhlIHtAbGluayBUZWNofXMge0BsaW5rIFRleHRUcmFja0xpc3R9LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRleHQgdHJhY2sgb2JqZWN0IHRvIGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgKi9cblxuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUZvclRyYWNrID0gZnVuY3Rpb24gdXBkYXRlRm9yVHJhY2sodHJhY2spIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyQxLldlYlZUVCAhPT0gJ2Z1bmN0aW9uJyB8fCAhdHJhY2suYWN0aXZlQ3Vlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdWVzID0gW107XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdHJhY2suYWN0aXZlQ3Vlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGN1ZXMucHVzaCh0cmFjay5hY3RpdmVDdWVzW19pXSk7XG4gICAgfVxuXG4gICAgd2luZG93JDEuV2ViVlRULnByb2Nlc3NDdWVzKHdpbmRvdyQxLCBjdWVzLCB0aGlzLmVsXyk7XG5cbiAgICBpZiAoIXRoaXMucGxheWVyXy50ZXh0VHJhY2tTZXR0aW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvdmVycmlkZXMgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrU2V0dGluZ3MuZ2V0VmFsdWVzKCk7XG5cbiAgICB2YXIgaSA9IGN1ZXMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGN1ZSA9IGN1ZXNbaV07XG5cbiAgICAgIGlmICghY3VlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VlRGl2ID0gY3VlLmRpc3BsYXlTdGF0ZTtcblxuICAgICAgaWYgKG92ZXJyaWRlcy5jb2xvcikge1xuICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS5jb2xvciA9IG92ZXJyaWRlcy5jb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMudGV4dE9wYWNpdHkpIHtcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsICdjb2xvcicsIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy5jb2xvciB8fCAnI2ZmZicsIG92ZXJyaWRlcy50ZXh0T3BhY2l0eSkpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuYmFja2dyb3VuZE9wYWNpdHkpIHtcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsICdiYWNrZ3JvdW5kQ29sb3InLCBjb25zdHJ1Y3RDb2xvcihvdmVycmlkZXMuYmFja2dyb3VuZENvbG9yIHx8ICcjMDAwJywgb3ZlcnJpZGVzLmJhY2tncm91bmRPcGFjaXR5KSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLndpbmRvd0NvbG9yKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMud2luZG93T3BhY2l0eSkge1xuICAgICAgICAgIHRyeVVwZGF0ZVN0eWxlKGN1ZURpdiwgJ2JhY2tncm91bmRDb2xvcicsIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy53aW5kb3dDb2xvciwgb3ZlcnJpZGVzLndpbmRvd09wYWNpdHkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdWVEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLndpbmRvd0NvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSkge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ2Ryb3BzaGFkb3cnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUudGV4dFNoYWRvdyA9ICcycHggMnB4IDNweCAnICsgZGFya0dyYXkgKyAnLCAycHggMnB4IDRweCAnICsgZGFya0dyYXkgKyAnLCAycHggMnB4IDVweCAnICsgZGFya0dyYXk7XG4gICAgICAgIH0gZWxzZSBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ3JhaXNlZCcpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS50ZXh0U2hhZG93ID0gJzFweCAxcHggJyArIGRhcmtHcmF5ICsgJywgMnB4IDJweCAnICsgZGFya0dyYXkgKyAnLCAzcHggM3B4ICcgKyBkYXJrR3JheTtcbiAgICAgICAgfSBlbHNlIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlID09PSAnZGVwcmVzc2VkJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMXB4IDFweCAnICsgbGlnaHRHcmF5ICsgJywgMCAxcHggJyArIGxpZ2h0R3JheSArICcsIC0xcHggLTFweCAnICsgZGFya0dyYXkgKyAnLCAwIC0xcHggJyArIGRhcmtHcmF5O1xuICAgICAgICB9IGVsc2UgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUgPT09ICd1bmlmb3JtJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMCAwIDRweCAnICsgZGFya0dyYXkgKyAnLCAwIDAgNHB4ICcgKyBkYXJrR3JheSArICcsIDAgMCA0cHggJyArIGRhcmtHcmF5ICsgJywgMCAwIDRweCAnICsgZGFya0dyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuZm9udFBlcmNlbnQgJiYgb3ZlcnJpZGVzLmZvbnRQZXJjZW50ICE9PSAxKSB7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IHdpbmRvdyQxLnBhcnNlRmxvYXQoY3VlRGl2LnN0eWxlLmZvbnRTaXplKTtcblxuICAgICAgICBjdWVEaXYuc3R5bGUuZm9udFNpemUgPSBmb250U2l6ZSAqIG92ZXJyaWRlcy5mb250UGVyY2VudCArICdweCc7XG4gICAgICAgIGN1ZURpdi5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgIGN1ZURpdi5zdHlsZS50b3AgPSAnYXV0byc7XG4gICAgICAgIGN1ZURpdi5zdHlsZS5ib3R0b20gPSAnMnB4JztcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuZm9udEZhbWlseSAmJiBvdmVycmlkZXMuZm9udEZhbWlseSAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMuZm9udEZhbWlseSA9PT0gJ3NtYWxsLWNhcHMnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuZm9udFZhcmlhbnQgPSAnc21hbGwtY2Fwcyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuZm9udEZhbWlseSA9IGZvbnRNYXBbb3ZlcnJpZGVzLmZvbnRGYW1pbHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2tEaXNwbGF5O1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RleHRUcmFja0Rpc3BsYXknLCBUZXh0VHJhY2tEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBsb2FkaW5nLXNwaW5uZXIuanNcbiAqL1xuXG4vKipcbiAqIEEgbG9hZGluZyBzcGlubmVyIGZvciB1c2UgZHVyaW5nIHdhaXRpbmcvbG9hZGluZyBldmVudHMuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIExvYWRpbmdTcGlubmVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTG9hZGluZ1NwaW5uZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExvYWRpbmdTcGlubmVyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIExvYWRpbmdTcGlubmVyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYExvYWRpbmdTcGlubmVyYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGRvbSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cbiAgTG9hZGluZ1NwaW5uZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGlzQXVkaW8gPSB0aGlzLnBsYXllcl8uaXNBdWRpbygpO1xuICAgIHZhciBwbGF5ZXJUeXBlID0gdGhpcy5sb2NhbGl6ZShpc0F1ZGlvID8gJ0F1ZGlvIFBsYXllcicgOiAnVmlkZW8gUGxheWVyJyk7XG4gICAgdmFyIGNvbnRyb2xUZXh0ID0gY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC10ZXh0JyxcbiAgICAgIGlubmVySFRNTDogdGhpcy5sb2NhbGl6ZSgnezF9IGlzIGxvYWRpbmcuJywgW3BsYXllclR5cGVdKVxuICAgIH0pO1xuXG4gICAgdmFyIGVsID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxvYWRpbmctc3Bpbm5lcicsXG4gICAgICBkaXI6ICdsdHInXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZChjb250cm9sVGV4dCk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgcmV0dXJuIExvYWRpbmdTcGlubmVyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0xvYWRpbmdTcGlubmVyJywgTG9hZGluZ1NwaW5uZXIpO1xuXG4vKipcbiAqIEBmaWxlIGJ1dHRvbi5qc1xuICovXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGJ1dHRvbnMuXG4gKlxuICogQGV4dGVuZHMgQ2xpY2thYmxlQ29tcG9uZW50XG4gKi9cblxudmFyIEJ1dHRvbiA9IGZ1bmN0aW9uIChfQ2xpY2thYmxlQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKEJ1dHRvbiwgX0NsaWNrYWJsZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQnV0dG9uKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1dHRvbik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NsaWNrYWJsZUNvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBCdXR0b25gcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0YWc9XCJidXR0b25cIl1cbiAgICogICAgICAgIFRoZSBlbGVtZW50J3Mgbm9kZSB0eXBlLiBUaGlzIGFyZ3VtZW50IGlzIElHTk9SRUQ6IG5vIG1hdHRlciB3aGF0XG4gICAqICAgICAgICBpcyBwYXNzZWQsIGl0IHdpbGwgYWx3YXlzIGNyZWF0ZSBhIGBidXR0b25gIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlcz17fV1cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG4gIEJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCh0YWcpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIHRhZyA9ICdidXR0b24nO1xuXG4gICAgcHJvcHMgPSBhc3NpZ24oe1xuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3M9XCJ2anMtaWNvbi1wbGFjZWhvbGRlclwiPjwvc3Bhbj4nLFxuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxuICAgIH0sIHByb3BzKTtcblxuICAgIC8vIEFkZCBhdHRyaWJ1dGVzIGZvciBidXR0b24gZWxlbWVudFxuICAgIGF0dHJpYnV0ZXMgPSBhc3NpZ24oe1xuXG4gICAgICAvLyBOZWNlc3Nhcnkgc2luY2UgdGhlIGRlZmF1bHQgYnV0dG9uIHR5cGUgaXMgXCJzdWJtaXRcIlxuICAgICAgdHlwZTogJ2J1dHRvbidcbiAgICB9LCBhdHRyaWJ1dGVzKTtcblxuICAgIHZhciBlbCA9IENvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB0YWcsIHByb3BzLCBhdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMuY3JlYXRlQ29udHJvbFRleHRFbChlbCk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNoaWxkIGBDb21wb25lbnRgIGluc2lkZSBvZiB0aGlzIGBCdXR0b25gLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xDb21wb25lbnR9IGNoaWxkXG4gICAqICAgICAgICBUaGUgbmFtZSBvciBpbnN0YW5jZSBvZiBhIGNoaWxkIHRvIGFkZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBvcHRpb25zIHRoYXQgd2lsbCBnZXQgcGFzc2VkIHRvIGNoaWxkcmVuIG9mXG4gICAqICAgICAgICB0aGUgY2hpbGQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogICAgICAgICBUaGUgYENvbXBvbmVudGAgdGhhdCBnZXRzIGFkZGVkIGFzIGEgY2hpbGQuIFdoZW4gdXNpbmcgYSBzdHJpbmcgdGhlXG4gICAqICAgICAgICAgYENvbXBvbmVudGAgd2lsbCBnZXQgY3JlYXRlZCBieSB0aGlzIHByb2Nlc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNVxuICAgKi9cblxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZChjaGlsZCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICBsb2ckMS53YXJuKCdBZGRpbmcgYW4gYWN0aW9uYWJsZSAodXNlciBjb250cm9sbGFibGUpIGNoaWxkIHRvIGEgQnV0dG9uICgnICsgY2xhc3NOYW1lICsgJykgaXMgbm90IHN1cHBvcnRlZDsgdXNlIGEgQ2xpY2thYmxlQ29tcG9uZW50IGluc3RlYWQuJyk7XG5cbiAgICAvLyBBdm9pZCB0aGUgZXJyb3IgbWVzc2FnZSBnZW5lcmF0ZWQgYnkgQ2xpY2thYmxlQ29tcG9uZW50J3MgYWRkQ2hpbGQgbWV0aG9kXG4gICAgcmV0dXJuIENvbXBvbmVudC5wcm90b3R5cGUuYWRkQ2hpbGQuY2FsbCh0aGlzLCBjaGlsZCwgb3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGUgYEJ1dHRvbmAgZWxlbWVudCBzbyB0aGF0IGl0IGNhbiBiZSBhY3RpdmF0ZWQgb3IgY2xpY2tlZC4gVXNlIHRoaXMgd2l0aFxuICAgKiB7QGxpbmsgQnV0dG9uI2Rpc2FibGV9LlxuICAgKi9cblxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIF9DbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZWxfLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZSB0aGUgYEJ1dHRvbmAgZWxlbWVudCBzbyB0aGF0IGl0IGNhbm5vdCBiZSBhY3RpdmF0ZWQgb3IgY2xpY2tlZC4gVXNlIHRoaXMgd2l0aFxuICAgKiB7QGxpbmsgQnV0dG9uI2VuYWJsZX0uXG4gICAqL1xuXG5cbiAgQnV0dG9uLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNhYmxlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQnV0dG9uYCBoYXMgZm9jdXMgYW5kIGBrZXlkb3duYCBpcyB0cmlnZ2VyZWQgdmlhIGEga2V5XG4gICAqIHByZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gZ2V0IGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuXG4gICAgLy8gSWdub3JlIFNwYWNlICgzMikgb3IgRW50ZXIgKDEzKSBrZXkgb3BlcmF0aW9uLCB3aGljaCBpcyBoYW5kbGVkIGJ5IHRoZSBicm93c2VyIGZvciBhIGJ1dHRvbi5cbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDMyIHx8IGV2ZW50LndoaWNoID09PSAxMykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFBhc3Mga2V5cHJlc3MgaGFuZGxpbmcgdXAgZm9yIHVuc3VwcG9ydGVkIGtleXNcbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcy5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfTtcblxuICByZXR1cm4gQnV0dG9uO1xufShDbGlja2FibGVDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0J1dHRvbicsIEJ1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgYmlnLXBsYXktYnV0dG9uLmpzXG4gKi9cblxuLyoqXG4gKiBUaGUgaW5pdGlhbCBwbGF5IGJ1dHRvbiB0aGF0IHNob3dzIGJlZm9yZSB0aGUgdmlkZW8gaGFzIHBsYXllZC4gVGhlIGhpZGluZyBvZiB0aGVcbiAqIGBCaWdQbGF5QnV0dG9uYCBnZXQgZG9uZSB2aWEgQ1NTIGFuZCBgUGxheWVyYCBzdGF0ZXMuXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKi9cblxudmFyIEJpZ1BsYXlCdXR0b24gPSBmdW5jdGlvbiAoX0J1dHRvbikge1xuICBpbmhlcml0cyhCaWdQbGF5QnV0dG9uLCBfQnV0dG9uKTtcblxuICBmdW5jdGlvbiBCaWdQbGF5QnV0dG9uKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJpZ1BsYXlCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5tb3VzZXVzZWRfID0gZmFsc2U7XG5cbiAgICBfdGhpcy5vbignbW91c2Vkb3duJywgX3RoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LiBBbHdheXMgcmV0dXJucyAndmpzLWJpZy1wbGF5LWJ1dHRvbicuXG4gICAqL1xuXG5cbiAgQmlnUGxheUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtYmlnLXBsYXktYnV0dG9uJztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGEgYEJpZ1BsYXlCdXR0b25gIFwiY2xpY2tlZFwiLiBTZWUge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH1cbiAgICogZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgQmlnUGxheUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIHZhciBwbGF5UHJvbWlzZSA9IHRoaXMucGxheWVyXy5wbGF5KCk7XG5cbiAgICAvLyBleGl0IGVhcmx5IGlmIGNsaWNrZWQgdmlhIHRoZSBtb3VzZVxuICAgIGlmICh0aGlzLm1vdXNldXNlZF8gJiYgZXZlbnQuY2xpZW50WCAmJiBldmVudC5jbGllbnRZKSB7XG4gICAgICBzaWxlbmNlUHJvbWlzZShwbGF5UHJvbWlzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNiID0gdGhpcy5wbGF5ZXJfLmdldENoaWxkKCdjb250cm9sQmFyJyk7XG4gICAgdmFyIHBsYXlUb2dnbGUgPSBjYiAmJiBjYi5nZXRDaGlsZCgncGxheVRvZ2dsZScpO1xuXG4gICAgaWYgKCFwbGF5VG9nZ2xlKSB7XG4gICAgICB0aGlzLnBsYXllcl8uZm9jdXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGxheUZvY3VzID0gZnVuY3Rpb24gcGxheUZvY3VzKCkge1xuICAgICAgcmV0dXJuIHBsYXlUb2dnbGUuZm9jdXMoKTtcbiAgICB9O1xuXG4gICAgaWYgKGlzUHJvbWlzZShwbGF5UHJvbWlzZSkpIHtcbiAgICAgIHBsYXlQcm9taXNlLnRoZW4ocGxheUZvY3VzLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0VGltZW91dChwbGF5Rm9jdXMsIDEpO1xuICAgIH1cbiAgfTtcblxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG4gICAgdGhpcy5tb3VzZXVzZWRfID0gZmFsc2U7XG5cbiAgICBfQnV0dG9uLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcy5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfTtcblxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICB0aGlzLm1vdXNldXNlZF8gPSB0cnVlO1xuICB9O1xuXG4gIHJldHVybiBCaWdQbGF5QnV0dG9uO1xufShCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEJpZ1BsYXlCdXR0b25gcyBjb250cm9scy4gQWRkZWQgdG8gZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkJpZ1BsYXlCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdQbGF5IFZpZGVvJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdCaWdQbGF5QnV0dG9uJywgQmlnUGxheUJ1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgY2xvc2UtYnV0dG9uLmpzXG4gKi9cblxuLyoqXG4gKiBUaGUgYENsb3NlQnV0dG9uYCBpcyBhIGB7QGxpbmsgQnV0dG9ufWAgdGhhdCBmaXJlcyBhIGBjbG9zZWAgZXZlbnQgd2hlblxuICogaXQgZ2V0cyBjbGlja2VkLlxuICpcbiAqIEBleHRlbmRzIEJ1dHRvblxuICovXG5cbnZhciBDbG9zZUJ1dHRvbiA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKENsb3NlQnV0dG9uLCBfQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2xvc2VCdXR0b24ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xvc2VCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5jb250cm9sVGV4dChvcHRpb25zICYmIG9wdGlvbnMuY29udHJvbFRleHQgfHwgX3RoaXMubG9jYWxpemUoJ0Nsb3NlJykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgQ2xvc2VCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWNsb3NlLWJ1dHRvbiAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQ2xvc2VCdXR0b25gIGdldHMgY2xpY2tlZC4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlQ2xpY2t9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdoZW4gdGhpcyB3aWxsIGJlXG4gICAqIHRyaWdnZXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICogQGZpcmVzIENsb3NlQnV0dG9uI2Nsb3NlXG4gICAqL1xuXG5cbiAgQ2xvc2VCdXR0b24ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBhIGBDbG9zZUJ1dHRvbmAgaXMgY2xpY2tlZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBDbG9zZUJ1dHRvbiNjbG9zZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdXG4gICAgICogICAgICAgICAgIHNldCB0byBmYWxzZSBzbyB0aGF0IHRoZSBjbG9zZSBldmVudCBkb2VzIG5vdFxuICAgICAqICAgICAgICAgICBidWJibGUgdXAgdG8gcGFyZW50cyBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lclxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICdjbG9zZScsIGJ1YmJsZXM6IGZhbHNlIH0pO1xuICB9O1xuXG4gIHJldHVybiBDbG9zZUJ1dHRvbjtcbn0oQnV0dG9uKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDbG9zZUJ1dHRvbicsIENsb3NlQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5LXRvZ2dsZS5qc1xuICovXG5cbi8qKlxuICogQnV0dG9uIHRvIHRvZ2dsZSBiZXR3ZWVuIHBsYXkgYW5kIHBhdXNlLlxuICpcbiAqIEBleHRlbmRzIEJ1dHRvblxuICovXG5cbnZhciBQbGF5VG9nZ2xlID0gZnVuY3Rpb24gKF9CdXR0b24pIHtcbiAgaW5oZXJpdHMoUGxheVRvZ2dsZSwgX0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBQbGF5VG9nZ2xlKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXlUb2dnbGUpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdwbGF5JywgX3RoaXMuaGFuZGxlUGxheSk7XG4gICAgX3RoaXMub24ocGxheWVyLCAncGF1c2UnLCBfdGhpcy5oYW5kbGVQYXVzZSk7XG4gICAgX3RoaXMub24ocGxheWVyLCAnZW5kZWQnLCBfdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBQbGF5VG9nZ2xlLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1wbGF5LWNvbnRyb2wgJyArIF9CdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBQbGF5VG9nZ2xlYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCBvbmNlIGFmdGVyIHRoZSB2aWRlbyBoYXMgZW5kZWQgYW5kIHRoZSB1c2VyIHNlZWtzIHNvIHRoYXRcbiAgICogd2UgY2FuIGNoYW5nZSB0aGUgcmVwbGF5IGJ1dHRvbiBiYWNrIHRvIGEgcGxheSBidXR0b24uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3NlZWtlZFxuICAgKi9cblxuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZVNlZWtlZCA9IGZ1bmN0aW9uIGhhbmRsZVNlZWtlZChldmVudCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuXG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5oYW5kbGVQYXVzZShldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlUGxheShldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIHZqcy1wbGF5aW5nIGNsYXNzIHRvIHRoZSBlbGVtZW50IHNvIGl0IGNhbiBjaGFuZ2UgYXBwZWFyYW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcGxheVxuICAgKi9cblxuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZVBsYXkgPSBmdW5jdGlvbiBoYW5kbGVQbGF5KGV2ZW50KSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgLy8gY2hhbmdlIHRoZSBidXR0b24gdGV4dCB0byBcIlBhdXNlXCJcbiAgICB0aGlzLmNvbnRyb2xUZXh0KCdQYXVzZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIHZqcy1wYXVzZWQgY2xhc3MgdG8gdGhlIGVsZW1lbnQgc28gaXQgY2FuIGNoYW5nZSBhcHBlYXJhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNwYXVzZVxuICAgKi9cblxuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZVBhdXNlID0gZnVuY3Rpb24gaGFuZGxlUGF1c2UoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGxheWluZycpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcbiAgICAvLyBjaGFuZ2UgdGhlIGJ1dHRvbiB0ZXh0IHRvIFwiUGxheVwiXG4gICAgdGhpcy5jb250cm9sVGV4dCgnUGxheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIHZqcy1lbmRlZCBjbGFzcyB0byB0aGUgZWxlbWVudCBzbyBpdCBjYW4gY2hhbmdlIGFwcGVhcmFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZW5kZWRcbiAgICovXG5cblxuICBQbGF5VG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVFbmRlZCA9IGZ1bmN0aW9uIGhhbmRsZUVuZGVkKGV2ZW50KSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBsYXlpbmcnKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtZW5kZWQnKTtcbiAgICAvLyBjaGFuZ2UgdGhlIGJ1dHRvbiB0ZXh0IHRvIFwiUmVwbGF5XCJcbiAgICB0aGlzLmNvbnRyb2xUZXh0KCdSZXBsYXknKTtcblxuICAgIC8vIG9uIHRoZSBuZXh0IHNlZWsgcmVtb3ZlIHRoZSByZXBsYXkgYnV0dG9uXG4gICAgdGhpcy5vbmUodGhpcy5wbGF5ZXJfLCAnc2Vla2VkJywgdGhpcy5oYW5kbGVTZWVrZWQpO1xuICB9O1xuXG4gIHJldHVybiBQbGF5VG9nZ2xlO1xufShCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFBsYXlUb2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cblBsYXlUb2dnbGUucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdQbGF5JztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5VG9nZ2xlJywgUGxheVRvZ2dsZSk7XG5cbi8qKlxuICogQGZpbGUgZm9ybWF0LXRpbWUuanNcbiAqIEBtb2R1bGUgZm9ybWF0LXRpbWVcbiAqL1xuXG4vKipcbiogRm9ybWF0IHNlY29uZHMgYXMgYSB0aW1lIHN0cmluZywgSDpNTTpTUyBvciBNOlNTLiBTdXBwbHlpbmcgYSBndWlkZSAoaW4gc2Vjb25kcylcbiogd2lsbCBmb3JjZSBhIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIHRvIGNvdmVyIHRoZSBsZW5ndGggb2YgdGhlIGd1aWRlLlxuKlxuKiBAcGFyYW0ge251bWJlcn0gc2Vjb25kc1xuKiAgICAgICAgTnVtYmVyIG9mIHNlY29uZHMgdG8gYmUgdHVybmVkIGludG8gYSBzdHJpbmdcbipcbiogQHBhcmFtIHtudW1iZXJ9IGd1aWRlXG4qICAgICAgICBOdW1iZXIgKGluIHNlY29uZHMpIHRvIG1vZGVsIHRoZSBzdHJpbmcgYWZ0ZXJcbipcbiogQHJldHVybiB7c3RyaW5nfVxuKiAgICAgICAgIFRpbWUgZm9ybWF0dGVkIGFzIEg6TU06U1Mgb3IgTTpTU1xuKi9cbnZhciBkZWZhdWx0SW1wbGVtZW50YXRpb24gPSBmdW5jdGlvbiBkZWZhdWx0SW1wbGVtZW50YXRpb24oc2Vjb25kcywgZ3VpZGUpIHtcbiAgc2Vjb25kcyA9IHNlY29uZHMgPCAwID8gMCA6IHNlY29uZHM7XG4gIHZhciBzID0gTWF0aC5mbG9vcihzZWNvbmRzICUgNjApO1xuICB2YXIgbSA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwICUgNjApO1xuICB2YXIgaCA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDM2MDApO1xuICB2YXIgZ20gPSBNYXRoLmZsb29yKGd1aWRlIC8gNjAgJSA2MCk7XG4gIHZhciBnaCA9IE1hdGguZmxvb3IoZ3VpZGUgLyAzNjAwKTtcblxuICAvLyBoYW5kbGUgaW52YWxpZCB0aW1lc1xuICBpZiAoaXNOYU4oc2Vjb25kcykgfHwgc2Vjb25kcyA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyAnLScgaXMgZmFsc2UgZm9yIGFsbCByZWxhdGlvbmFsIG9wZXJhdG9ycyAoZS5nLiA8LCA+PSkgc28gdGhpcyBzZXR0aW5nXG4gICAgLy8gd2lsbCBhZGQgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGZpZWxkcyBzcGVjaWZpZWQgYnkgdGhlIGd1aWRlXG4gICAgaCA9IG0gPSBzID0gJy0nO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBzaG93IGhvdXJzXG4gIGggPSBoID4gMCB8fCBnaCA+IDAgPyBoICsgJzonIDogJyc7XG5cbiAgLy8gSWYgaG91cnMgYXJlIHNob3dpbmcsIHdlIG1heSBuZWVkIHRvIGFkZCBhIGxlYWRpbmcgemVyby5cbiAgLy8gQWx3YXlzIHNob3cgYXQgbGVhc3Qgb25lIGRpZ2l0IG9mIG1pbnV0ZXMuXG4gIG0gPSAoKGggfHwgZ20gPj0gMTApICYmIG0gPCAxMCA/ICcwJyArIG0gOiBtKSArICc6JztcblxuICAvLyBDaGVjayBpZiBsZWFkaW5nIHplcm8gaXMgbmVlZCBmb3Igc2Vjb25kc1xuICBzID0gcyA8IDEwID8gJzAnICsgcyA6IHM7XG5cbiAgcmV0dXJuIGggKyBtICsgcztcbn07XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IGRlZmF1bHRJbXBsZW1lbnRhdGlvbjtcblxuLyoqXG4gKiBSZXBsYWNlcyB0aGUgZGVmYXVsdCBmb3JtYXRUaW1lIGltcGxlbWVudGF0aW9uIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9tSW1wbGVtZW50YXRpb25cbiAqICAgICAgICBBIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgdXNlZCBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBmb3JtYXRUaW1lIGltcGxlbWVudGF0aW9uLlxuICogICAgICAgIFdpbGwgcmVjZWl2ZSB0aGUgY3VycmVudCB0aW1lIGluIHNlY29uZHMgYW5kIHRoZSBndWlkZSAoaW4gc2Vjb25kcykgYXMgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBzZXRGb3JtYXRUaW1lKGN1c3RvbUltcGxlbWVudGF0aW9uKSB7XG4gIGltcGxlbWVudGF0aW9uID0gY3VzdG9tSW1wbGVtZW50YXRpb247XG59XG5cbi8qKlxuICogUmVzZXRzIGZvcm1hdFRpbWUgdG8gdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIHJlc2V0Rm9ybWF0VGltZSgpIHtcbiAgaW1wbGVtZW50YXRpb24gPSBkZWZhdWx0SW1wbGVtZW50YXRpb247XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWUgKHNlY29uZHMpIHtcbiAgdmFyIGd1aWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBzZWNvbmRzO1xuXG4gIHJldHVybiBpbXBsZW1lbnRhdGlvbihzZWNvbmRzLCBndWlkZSk7XG59XG5cbi8qKlxuICogQGZpbGUgdGltZS1kaXNwbGF5LmpzXG4gKi9cblxuLyoqXG4gKiBEaXNwbGF5cyB0aGUgdGltZSBsZWZ0IGluIHRoZSB2aWRlb1xuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUaW1lRGlzcGxheSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFRpbWVEaXNwbGF5LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFRpbWVEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudGhyb3R0bGVkVXBkYXRlQ29udGVudCA9IHRocm90dGxlKGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZUNvbnRlbnQpLCAyNSk7XG4gICAgX3RoaXMub24ocGxheWVyLCAndGltZXVwZGF0ZScsIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFRpbWVEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKHBsYWluTmFtZSkge1xuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKTtcbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSArICcgdmpzLXRpbWUtY29udHJvbCB2anMtY29udHJvbCcsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4nICsgdGhpcy5sb2NhbGl6ZSh0aGlzLmxhYmVsVGV4dF8pICsgJ1xceEEwPC9zcGFuPidcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXyA9IGNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgKyAnLWRpc3BsYXknXG4gICAgfSwge1xuICAgICAgLy8gdGVsbCBzY3JlZW4gcmVhZGVycyBub3QgdG8gYXV0b21hdGljYWxseSByZWFkIHRoZSB0aW1lIGFzIGl0IGNoYW5nZXNcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0pO1xuXG4gICAgdGhpcy51cGRhdGVUZXh0Tm9kZV8oKTtcbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICBUaW1lRGlzcGxheS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5jb250ZW50RWxfID0gbnVsbDtcbiAgICB0aGlzLnRleHROb2RlXyA9IG51bGw7XG5cbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIFwicmVtYWluaW5nIHRpbWVcIiB0ZXh0IG5vZGUgd2l0aCBuZXcgY29udGVudCB1c2luZyB0aGVcbiAgICogY29udGVudHMgb2YgdGhlIGBmb3JtYXR0ZWRUaW1lX2AgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZVRleHROb2RlXyA9IGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlXygpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudEVsXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLmNvbnRlbnRFbF8uZmlyc3RDaGlsZCkge1xuICAgICAgdGhpcy5jb250ZW50RWxfLnJlbW92ZUNoaWxkKHRoaXMuY29udGVudEVsXy5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHROb2RlXyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuZm9ybWF0dGVkVGltZV8gfHwgdGhpcy5mb3JtYXRUaW1lXygwKSk7XG4gICAgdGhpcy5jb250ZW50RWxfLmFwcGVuZENoaWxkKHRoaXMudGV4dE5vZGVfKTtcbiAgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgZm9ybWF0dGVkIHRpbWUgZm9yIHRoaXMgY29tcG9uZW50IHRvIHVzZSBpbiBkaXNwbGF5LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWVcbiAgICogICAgICAgICBBIG51bWVyaWMgdGltZSwgaW4gc2Vjb25kcy5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEEgZm9ybWF0dGVkIHRpbWVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUaW1lRGlzcGxheS5wcm90b3R5cGUuZm9ybWF0VGltZV8gPSBmdW5jdGlvbiBmb3JtYXRUaW1lXyh0aW1lKSB7XG4gICAgcmV0dXJuIGZvcm1hdFRpbWUodGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHRpbWUgZGlzcGxheSB0ZXh0IG5vZGUgaWYgaXQgaGFzIHdoYXQgd2FzIHBhc3NlZCBpbiBjaGFuZ2VkXG4gICAqIHRoZSBmb3JtYXR0ZWQgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAgICogICAgICAgIFRoZSB0aW1lIHRvIHVwZGF0ZSB0b1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVGb3JtYXR0ZWRUaW1lXyA9IGZ1bmN0aW9uIHVwZGF0ZUZvcm1hdHRlZFRpbWVfKHRpbWUpIHtcbiAgICB2YXIgZm9ybWF0dGVkVGltZSA9IHRoaXMuZm9ybWF0VGltZV8odGltZSk7XG5cbiAgICBpZiAoZm9ybWF0dGVkVGltZSA9PT0gdGhpcy5mb3JtYXR0ZWRUaW1lXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZm9ybWF0dGVkVGltZV8gPSBmb3JtYXR0ZWRUaW1lO1xuICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlVGV4dE5vZGVfKTtcbiAgfTtcblxuICAvKipcbiAgICogVG8gYmUgZmlsbGVkIG91dCBpbiB0aGUgY2hpbGQgY2xhc3MsIHNob3VsZCB1cGRhdGUgdGhlIGRpc3BsYXllZCB0aW1lXG4gICAqIGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgZmFjdCB0aGF0IHRoZSBjdXJyZW50IHRpbWUgaGFzIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdGltZXVwZGF0ZWAgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGltZXVwZGF0ZVxuICAgKi9cblxuXG4gIFRpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudChldmVudCkge307XG5cbiAgcmV0dXJuIFRpbWVEaXNwbGF5O1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgaXMgYWRkZWQgdG8gdGhlIGBUaW1lRGlzcGxheWAgZm9yIHNjcmVlbiByZWFkZXIgdXNlcnMuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5UaW1lRGlzcGxheS5wcm90b3R5cGUubGFiZWxUZXh0XyA9ICdUaW1lJztcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBUaW1lRGlzcGxheWBzIGNvbnRyb2xzLiBBZGRlZCB0byBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBkZXByZWNhdGVkIGluIHY3OyBjb250cm9sVGV4dF8gaXMgbm90IHVzZWQgaW4gbm9uLWFjdGl2ZSBkaXNwbGF5IENvbXBvbmVudHNcbiAqL1xuVGltZURpc3BsYXkucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdUaW1lJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUaW1lRGlzcGxheScsIFRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBjdXJyZW50LXRpbWUtZGlzcGxheS5qc1xuICovXG5cbi8qKlxuICogRGlzcGxheXMgdGhlIGN1cnJlbnQgdGltZVxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBDdXJyZW50VGltZURpc3BsYXkgPSBmdW5jdGlvbiAoX1RpbWVEaXNwbGF5KSB7XG4gIGluaGVyaXRzKEN1cnJlbnRUaW1lRGlzcGxheSwgX1RpbWVEaXNwbGF5KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEN1cnJlbnRUaW1lRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDdXJyZW50VGltZURpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGltZURpc3BsYXkuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ2VuZGVkJywgX3RoaXMuaGFuZGxlRW5kZWQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgQ3VycmVudFRpbWVEaXNwbGF5LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jdXJyZW50LXRpbWUnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgY3VycmVudCB0aW1lIGRpc3BsYXlcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGB0aW1ldXBkYXRlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3RpbWV1cGRhdGVcbiAgICovXG5cblxuICBDdXJyZW50VGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiB1cGRhdGVDb250ZW50KGV2ZW50KSB7XG4gICAgLy8gQWxsb3dzIGZvciBzbW9vdGggc2NydWJiaW5nLCB3aGVuIHBsYXllciBjYW4ndCBrZWVwIHVwLlxuICAgIHZhciB0aW1lID0gdGhpcy5wbGF5ZXJfLnNjcnViYmluZygpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgOiB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKTtcblxuICAgIHRoaXMudXBkYXRlRm9ybWF0dGVkVGltZV8odGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHBsYXllciBmaXJlcyBlbmRlZCB0aGVyZSBzaG91bGQgYmUgbm8gdGltZSBsZWZ0LiBTYWRseVxuICAgKiB0aGlzIGlzIG5vdCBhbHdheXMgdGhlIGNhc2UsIGxldHMgbWFrZSBpdCBzZWVtIGxpa2UgdGhhdCBpcyB0aGUgY2FzZVxuICAgKiBmb3IgdXNlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgZW5kZWRgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZW5kZWRcbiAgICovXG5cblxuICBDdXJyZW50VGltZURpc3BsYXkucHJvdG90eXBlLmhhbmRsZUVuZGVkID0gZnVuY3Rpb24gaGFuZGxlRW5kZWQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMucGxheWVyXy5kdXJhdGlvbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRm9ybWF0dGVkVGltZV8odGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpO1xuICB9O1xuXG4gIHJldHVybiBDdXJyZW50VGltZURpc3BsYXk7XG59KFRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IGlzIGFkZGVkIHRvIHRoZSBgQ3VycmVudFRpbWVEaXNwbGF5YCBmb3Igc2NyZWVuIHJlYWRlciB1c2Vycy5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkN1cnJlbnRUaW1lRGlzcGxheS5wcm90b3R5cGUubGFiZWxUZXh0XyA9ICdDdXJyZW50IFRpbWUnO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEN1cnJlbnRUaW1lRGlzcGxheWBzIGNvbnRyb2xzLiBBZGRlZCB0byBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBkZXByZWNhdGVkIGluIHY3OyBjb250cm9sVGV4dF8gaXMgbm90IHVzZWQgaW4gbm9uLWFjdGl2ZSBkaXNwbGF5IENvbXBvbmVudHNcbiAqL1xuQ3VycmVudFRpbWVEaXNwbGF5LnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnQ3VycmVudCBUaW1lJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDdXJyZW50VGltZURpc3BsYXknLCBDdXJyZW50VGltZURpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIGR1cmF0aW9uLWRpc3BsYXkuanNcbiAqL1xuXG4vKipcbiAqIERpc3BsYXlzIHRoZSBkdXJhdGlvblxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBEdXJhdGlvbkRpc3BsYXkgPSBmdW5jdGlvbiAoX1RpbWVEaXNwbGF5KSB7XG4gIGluaGVyaXRzKER1cmF0aW9uRGlzcGxheSwgX1RpbWVEaXNwbGF5KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIER1cmF0aW9uRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBEdXJhdGlvbkRpc3BsYXkpO1xuXG4gICAgLy8gd2UgZG8gbm90IHdhbnQgdG8vbmVlZCB0byB0aHJvdHRsZSBkdXJhdGlvbiBjaGFuZ2VzLFxuICAgIC8vIGFzIHRoZXkgc2hvdWxkIGFsd2F5cyBkaXNwbGF5IHRoZSBjaGFuZ2VkIGR1cmF0aW9uIGFzXG4gICAgLy8gaXQgaGFzIGNoYW5nZWRcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UaW1lRGlzcGxheS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnZHVyYXRpb25jaGFuZ2UnLCBfdGhpcy51cGRhdGVDb250ZW50KTtcblxuICAgIC8vIEFsc28gbGlzdGVuIGZvciB0aW1ldXBkYXRlIChpbiB0aGUgcGFyZW50KSBhbmQgbG9hZGVkbWV0YWRhdGEgYmVjYXVzZSByZW1vdmluZyB0aG9zZVxuICAgIC8vIGxpc3RlbmVycyBjb3VsZCBoYXZlIGJyb2tlbiBkZXBlbmRlbnQgYXBwbGljYXRpb25zL2xpYnJhcmllcy4gVGhlc2VcbiAgICAvLyBjYW4gbGlrZWx5IGJlIHJlbW92ZWQgZm9yIDcuMC5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdsb2FkZWRtZXRhZGF0YScsIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgRHVyYXRpb25EaXNwbGF5LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1kdXJhdGlvbic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBkdXJhdGlvbiB0aW1lIGRpc3BsYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgZHVyYXRpb25jaGFuZ2VgLCBgdGltZXVwZGF0ZWAsIG9yIGBsb2FkZWRtZXRhZGF0YWAgZXZlbnQgdGhhdCBjYXVzZWRcbiAgICogICAgICAgIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICogQGxpc3RlbnMgUGxheWVyI3RpbWV1cGRhdGVcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRlZG1ldGFkYXRhXG4gICAqL1xuXG5cbiAgRHVyYXRpb25EaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudChldmVudCkge1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuXG4gICAgaWYgKGR1cmF0aW9uICYmIHRoaXMuZHVyYXRpb25fICE9PSBkdXJhdGlvbikge1xuICAgICAgdGhpcy5kdXJhdGlvbl8gPSBkdXJhdGlvbjtcbiAgICAgIHRoaXMudXBkYXRlRm9ybWF0dGVkVGltZV8oZHVyYXRpb24pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gRHVyYXRpb25EaXNwbGF5O1xufShUaW1lRGlzcGxheSk7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBpcyBhZGRlZCB0byB0aGUgYER1cmF0aW9uRGlzcGxheWAgZm9yIHNjcmVlbiByZWFkZXIgdXNlcnMuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5EdXJhdGlvbkRpc3BsYXkucHJvdG90eXBlLmxhYmVsVGV4dF8gPSAnRHVyYXRpb24nO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYER1cmF0aW9uRGlzcGxheWBzIGNvbnRyb2xzLiBBZGRlZCB0byBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBkZXByZWNhdGVkIGluIHY3OyBjb250cm9sVGV4dF8gaXMgbm90IHVzZWQgaW4gbm9uLWFjdGl2ZSBkaXNwbGF5IENvbXBvbmVudHNcbiAqL1xuRHVyYXRpb25EaXNwbGF5LnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnRHVyYXRpb24nO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0R1cmF0aW9uRGlzcGxheScsIER1cmF0aW9uRGlzcGxheSk7XG5cbi8qKlxuICogQGZpbGUgdGltZS1kaXZpZGVyLmpzXG4gKi9cblxuLyoqXG4gKiBUaGUgc2VwYXJhdG9yIGJldHdlZW4gdGhlIGN1cnJlbnQgdGltZSBhbmQgZHVyYXRpb24uXG4gKiBDYW4gYmUgaGlkZGVuIGlmIGl0J3Mgbm90IG5lZWRlZCBpbiB0aGUgZGVzaWduLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUaW1lRGl2aWRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFRpbWVEaXZpZGVyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUaW1lRGl2aWRlcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lRGl2aWRlcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIFRpbWVEaXZpZGVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdGltZS1jb250cm9sIHZqcy10aW1lLWRpdmlkZXInLFxuICAgICAgaW5uZXJIVE1MOiAnPGRpdj48c3Bhbj4vPC9zcGFuPjwvZGl2PidcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVGltZURpdmlkZXI7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGltZURpdmlkZXInLCBUaW1lRGl2aWRlcik7XG5cbi8qKlxuICogQGZpbGUgcmVtYWluaW5nLXRpbWUtZGlzcGxheS5qc1xuICovXG4vKipcbiAqIERpc3BsYXlzIHRoZSB0aW1lIGxlZnQgaW4gdGhlIHZpZGVvXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFJlbWFpbmluZ1RpbWVEaXNwbGF5ID0gZnVuY3Rpb24gKF9UaW1lRGlzcGxheSkge1xuICBpbmhlcml0cyhSZW1haW5pbmdUaW1lRGlzcGxheSwgX1RpbWVEaXNwbGF5KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFJlbWFpbmluZ1RpbWVEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbWFpbmluZ1RpbWVEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RpbWVEaXNwbGF5LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdkdXJhdGlvbmNoYW5nZScsIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQpO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ2VuZGVkJywgX3RoaXMuaGFuZGxlRW5kZWQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXJlbWFpbmluZy10aW1lJztcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHJlbWFpbmluZyB0aW1lIGRpc3BsYXkgcHJlZml4ZXMgbnVtYmVycyB3aXRoIGEgXCJtaW51c1wiIGNoYXJhY3Rlci5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lXG4gICAqICAgICAgICAgQSBudW1lcmljIHRpbWUsIGluIHNlY29uZHMuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBBIGZvcm1hdHRlZCB0aW1lXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLmZvcm1hdFRpbWVfID0gZnVuY3Rpb24gZm9ybWF0VGltZV8odGltZSkge1xuICAgIC8vIFRPRE86IFRoZSBcIi1cIiBzaG91bGQgYmUgZGVjb3JhdGl2ZSwgYW5kIG5vdCBhbm5vdW5jZWQgYnkgYSBzY3JlZW4gcmVhZGVyXG4gICAgcmV0dXJuICctJyArIF9UaW1lRGlzcGxheS5wcm90b3R5cGUuZm9ybWF0VGltZV8uY2FsbCh0aGlzLCB0aW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHJlbWFpbmluZyB0aW1lIGRpc3BsYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdGltZXVwZGF0ZWAgb3IgYGR1cmF0aW9uY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3RpbWV1cGRhdGVcbiAgICogQGxpc3RlbnMgUGxheWVyI2R1cmF0aW9uY2hhbmdlXG4gICAqL1xuXG5cbiAgUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiB1cGRhdGVDb250ZW50KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnBsYXllcl8uZHVyYXRpb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEBkZXByZWNhdGVkIFdlIHNob3VsZCBvbmx5IHVzZSByZW1haW5pbmdUaW1lRGlzcGxheVxuICAgIC8vIGFzIG9mIHZpZGVvLmpzIDdcbiAgICBpZiAodGhpcy5wbGF5ZXJfLnJlbWFpbmluZ1RpbWVEaXNwbGF5KSB7XG4gICAgICB0aGlzLnVwZGF0ZUZvcm1hdHRlZFRpbWVfKHRoaXMucGxheWVyXy5yZW1haW5pbmdUaW1lRGlzcGxheSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVGb3JtYXR0ZWRUaW1lXyh0aGlzLnBsYXllcl8ucmVtYWluaW5nVGltZSgpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHBsYXllciBmaXJlcyBlbmRlZCB0aGVyZSBzaG91bGQgYmUgbm8gdGltZSBsZWZ0LiBTYWRseVxuICAgKiB0aGlzIGlzIG5vdCBhbHdheXMgdGhlIGNhc2UsIGxldHMgbWFrZSBpdCBzZWVtIGxpa2UgdGhhdCBpcyB0aGUgY2FzZVxuICAgKiBmb3IgdXNlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgZW5kZWRgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZW5kZWRcbiAgICovXG5cblxuICBSZW1haW5pbmdUaW1lRGlzcGxheS5wcm90b3R5cGUuaGFuZGxlRW5kZWQgPSBmdW5jdGlvbiBoYW5kbGVFbmRlZChldmVudCkge1xuICAgIGlmICghdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVGb3JtYXR0ZWRUaW1lXygwKTtcbiAgfTtcblxuICByZXR1cm4gUmVtYWluaW5nVGltZURpc3BsYXk7XG59KFRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IGlzIGFkZGVkIHRvIHRoZSBgUmVtYWluaW5nVGltZURpc3BsYXlgIGZvciBzY3JlZW4gcmVhZGVyIHVzZXJzLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLmxhYmVsVGV4dF8gPSAnUmVtYWluaW5nIFRpbWUnO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFJlbWFpbmluZ1RpbWVEaXNwbGF5YHMgY29udHJvbHMuIEFkZGVkIHRvIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKlxuICogQGRlcHJlY2F0ZWQgaW4gdjc7IGNvbnRyb2xUZXh0XyBpcyBub3QgdXNlZCBpbiBub24tYWN0aXZlIGRpc3BsYXkgQ29tcG9uZW50c1xuICovXG5SZW1haW5pbmdUaW1lRGlzcGxheS5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1JlbWFpbmluZyBUaW1lJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdSZW1haW5pbmdUaW1lRGlzcGxheScsIFJlbWFpbmluZ1RpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBsaXZlLWRpc3BsYXkuanNcbiAqL1xuXG4vLyBUT0RPIC0gRnV0dXJlIG1ha2UgaXQgY2xpY2sgdG8gc25hcCB0byBsaXZlXG5cbi8qKlxuICogRGlzcGxheXMgdGhlIGxpdmUgaW5kaWNhdG9yIHdoZW4gZHVyYXRpb24gaXMgSW5maW5pdHkuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIExpdmVEaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTGl2ZURpc3BsYXksIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTGl2ZURpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTGl2ZURpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGVTaG93aW5nKCk7XG4gICAgX3RoaXMub24oX3RoaXMucGxheWVyKCksICdkdXJhdGlvbmNoYW5nZScsIF90aGlzLnVwZGF0ZVNob3dpbmcpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIExpdmVEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1saXZlLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxpdmUtZGlzcGxheScsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4nICsgdGhpcy5sb2NhbGl6ZSgnU3RyZWFtIFR5cGUnKSArICdcXHhBMDwvc3Bhbj4nICsgdGhpcy5sb2NhbGl6ZSgnTElWRScpXG4gICAgfSwge1xuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICBMaXZlRGlzcGxheS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5jb250ZW50RWxfID0gbnVsbDtcblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgdGhlIGR1cmF0aW9uIHRvIHNlZSBpZiB0aGUgTGl2ZURpc3BsYXkgc2hvdWxkIGJlIHNob3dpbmcgb3Igbm90LiBUaGVuIHNob3cvaGlkZVxuICAgKiBpdCBhY2NvcmRpbmdseVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUge0BsaW5rIFBsYXllciNkdXJhdGlvbmNoYW5nZX0gZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNkdXJhdGlvbmNoYW5nZVxuICAgKi9cblxuXG4gIExpdmVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVTaG93aW5nID0gZnVuY3Rpb24gdXBkYXRlU2hvd2luZyhldmVudCkge1xuICAgIGlmICh0aGlzLnBsYXllcigpLmR1cmF0aW9uKCkgPT09IEluZmluaXR5KSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBMaXZlRGlzcGxheTtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdMaXZlRGlzcGxheScsIExpdmVEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBzbGlkZXIuanNcbiAqL1xuXG4vKipcbiAqIFRoZSBiYXNlIGZ1bmN0aW9uYWxpdHkgZm9yIGEgc2xpZGVyLiBDYW4gYmUgdmVydGljYWwgb3IgaG9yaXpvbnRhbC5cbiAqIEZvciBpbnN0YW5jZSB0aGUgdm9sdW1lIGJhciBvciB0aGUgc2VlayBiYXIgb24gYSB2aWRlbyBpcyBhIHNsaWRlci5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgU2xpZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoU2xpZGVyLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBTbGlkZXIocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpZGVyKTtcblxuICAgIC8vIFNldCBwcm9wZXJ0eSBuYW1lcyB0byBiYXIgdG8gbWF0Y2ggd2l0aCB0aGUgY2hpbGQgU2xpZGVyIGNsYXNzIGlzIGxvb2tpbmcgZm9yXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5iYXIgPSBfdGhpcy5nZXRDaGlsZChfdGhpcy5vcHRpb25zXy5iYXJOYW1lKTtcblxuICAgIC8vIFNldCBhIGhvcml6b250YWwgb3IgdmVydGljYWwgY2xhc3Mgb24gdGhlIHNsaWRlciBkZXBlbmRpbmcgb24gdGhlIHNsaWRlciB0eXBlXG4gICAgX3RoaXMudmVydGljYWwoISFfdGhpcy5vcHRpb25zXy52ZXJ0aWNhbCk7XG5cbiAgICBfdGhpcy5lbmFibGUoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQXJlIGNvbnRyb2xzIGFyZSBjdXJyZW50bHkgZW5hYmxlZCBmb3IgdGhpcyBzbGlkZXIgb3Igbm90LlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIHRydWUgaWYgY29udHJvbHMgYXJlIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuZW5hYmxlZCA9IGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlZF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBjb250cm9scyBmb3IgdGhpcyBzbGlkZXIgaWYgdGhleSBhcmUgZGlzYWJsZWRcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMpO1xuICAgIHRoaXMub24oJ2JsdXInLCB0aGlzLmhhbmRsZUJsdXIpO1xuICAgIHRoaXMub24oJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGljayk7XG5cbiAgICB0aGlzLm9uKHRoaXMucGxheWVyXywgJ2NvbnRyb2xzdmlzaWJsZScsIHRoaXMudXBkYXRlKTtcblxuICAgIGlmICh0aGlzLnBsYXllckV2ZW50KSB7XG4gICAgICB0aGlzLm9uKHRoaXMucGxheWVyXywgdGhpcy5wbGF5ZXJFdmVudCwgdGhpcy51cGRhdGUpO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG5cbiAgICB0aGlzLmVuYWJsZWRfID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZSBjb250cm9scyBmb3IgdGhpcyBzbGlkZXIgaWYgdGhleSBhcmUgZW5hYmxlZFxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZG9jID0gdGhpcy5iYXIuZWxfLm93bmVyRG9jdW1lbnQ7XG5cbiAgICB0aGlzLm9mZignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub2ZmKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub2ZmKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMpO1xuICAgIHRoaXMub2ZmKCdibHVyJywgdGhpcy5oYW5kbGVCbHVyKTtcbiAgICB0aGlzLm9mZignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrKTtcbiAgICB0aGlzLm9mZih0aGlzLnBsYXllcl8sICdjb250cm9sc3Zpc2libGUnLCB0aGlzLnVwZGF0ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG5cbiAgICB0aGlzLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuXG4gICAgaWYgKHRoaXMucGxheWVyRXZlbnQpIHtcbiAgICAgIHRoaXMub2ZmKHRoaXMucGxheWVyXywgdGhpcy5wbGF5ZXJFdmVudCwgdGhpcy51cGRhdGUpO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYFNsaWRlcmBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgVHlwZSBvZiBlbGVtZW50IHRvIGNyZWF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcz17fV1cbiAgICogICAgICAgIExpc3Qgb2YgcHJvcGVydGllcyBpbiBPYmplY3QgZm9ybS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzPXt9XVxuICAgKiAgICAgICAgbGlzdCBvZiBhdHRyaWJ1dGVzIGluIE9iamVjdCBmb3JtLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSh0eXBlKSB7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAvLyBBZGQgdGhlIHNsaWRlciBlbGVtZW50IGNsYXNzIHRvIGFsbCBzdWIgY2xhc3Nlc1xuICAgIHByb3BzLmNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSArICcgdmpzLXNsaWRlcic7XG4gICAgcHJvcHMgPSBhc3NpZ24oe1xuICAgICAgdGFiSW5kZXg6IDBcbiAgICB9LCBwcm9wcyk7XG5cbiAgICBhdHRyaWJ1dGVzID0gYXNzaWduKHtcbiAgICAgICdyb2xlJzogJ3NsaWRlcicsXG4gICAgICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICAgICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICAgICAnYXJpYS12YWx1ZW1heCc6IDEwMCxcbiAgICAgICd0YWJJbmRleCc6IDBcbiAgICB9LCBhdHRyaWJ1dGVzKTtcblxuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHR5cGUsIHByb3BzLCBhdHRyaWJ1dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudHMgb24gdGhlIGBTbGlkZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqIEBsaXN0ZW5zIHRvdWNoc3RhcnRcbiAgICogQGZpcmVzIFNsaWRlciNzbGlkZXJhY3RpdmVcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmJhci5lbF8ub3duZXJEb2N1bWVudDtcblxuICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgLy8gRG8gbm90IGNhbGwgcHJldmVudERlZmF1bHQoKSBvbiB0b3VjaHN0YXJ0IGluIENocm9tZVxuICAgIC8vIHRvIGF2b2lkIGNvbnNvbGUgd2FybmluZ3MuIFVzZSBhICd0b3VjaC1hY3Rpb246IG5vbmUnIHN0eWxlXG4gICAgLy8gaW5zdGVhZCB0byBwcmV2ZW50IHVuaW50ZW50ZWQgc2Nyb2xsaW5nLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTcvMDEvc2Nyb2xsaW5nLWludGVydmVudGlvblxuICAgIGlmIChldmVudC50eXBlID09PSAndG91Y2hzdGFydCcgJiYgIUlTX0NIUk9NRSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgYmxvY2tUZXh0U2VsZWN0aW9uKCk7XG5cbiAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGluZycpO1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBzbGlkZXIgaXMgaW4gYW4gYWN0aXZlIHN0YXRlXG4gICAgICpcbiAgICAgKiBAZXZlbnQgU2xpZGVyI3NsaWRlcmFjdGl2ZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3NsaWRlcmFjdGl2ZScpO1xuXG4gICAgdGhpcy5vbihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vbihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcblxuICAgIHRoaXMuaGFuZGxlTW91c2VNb3ZlKGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRoZSBgbW91c2Vtb3ZlYCwgYHRvdWNobW92ZWAsIGFuZCBgbW91c2Vkb3duYCBldmVudHMgb24gdGhpcyBgU2xpZGVyYC5cbiAgICogVGhlIGBtb3VzZW1vdmVgIGFuZCBgdG91Y2htb3ZlYCBldmVudHMgd2lsbCBvbmx5IG9ubHkgdHJpZ2dlciB0aGlzIGZ1bmN0aW9uIGR1cmluZ1xuICAgKiBgbW91c2Vkb3duYCBhbmQgYHRvdWNoc3RhcnRgLiBUaGlzIGlzIGR1ZSB0byB7QGxpbmsgU2xpZGVyI2hhbmRsZU1vdXNlRG93bn0gYW5kXG4gICAqIHtAbGluayBTbGlkZXIjaGFuZGxlTW91c2VVcH0uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCwgYG1vdXNlbW92ZWAsIGB0b3VjaHN0YXJ0YCwgb3IgYHRvdWNobW92ZWAgZXZlbnQgdGhhdCB0cmlnZ2VyZWRcbiAgICogICAgICAgIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vtb3ZlXG4gICAqIEBsaXN0ZW5zIHRvdWNobW92ZVxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7fTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50cyBvbiB0aGUgYFNsaWRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbGlzdGVucyB0b3VjaGVuZFxuICAgKiBAbGlzdGVucyBtb3VzZXVwXG4gICAqIEBmaXJlcyBTbGlkZXIjc2xpZGVyaW5hY3RpdmVcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmJhci5lbF8ub3duZXJEb2N1bWVudDtcblxuICAgIHVuYmxvY2tUZXh0U2VsZWN0aW9uKCk7XG5cbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2xpZGluZycpO1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBzbGlkZXIgaXMgbm8gbG9uZ2VyIGluIGFuIGFjdGl2ZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBldmVudCBTbGlkZXIjc2xpZGVyaW5hY3RpdmVcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdzbGlkZXJpbmFjdGl2ZScpO1xuXG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHByb2dyZXNzIGJhciBvZiB0aGUgYFNsaWRlcmAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqICAgICAgICAgIFRoZSBwZXJjZW50YWdlIG9mIHByb2dyZXNzIHRoZSBwcm9ncmVzcyBiYXIgcmVwcmVzZW50cyBhcyBhXG4gICAqICAgICAgICAgIG51bWJlciBmcm9tIDAgdG8gMS5cbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuICAgIC8vIEluIFZvbHVtZUJhciBpbml0IHdlIGhhdmUgYSBzZXRUaW1lb3V0IGZvciB1cGRhdGUgdGhhdCBwb3BzIGFuZCB1cGRhdGVcbiAgICAvLyB0byB0aGUgZW5kIG9mIHRoZSBleGVjdXRpb24gc3RhY2suIFRoZSBwbGF5ZXIgaXMgZGVzdHJveWVkIGJlZm9yZSB0aGVuXG4gICAgLy8gdXBkYXRlIHdpbGwgY2F1c2UgYW4gZXJyb3JcbiAgICBpZiAoIXRoaXMuZWxfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgc2NydWJiaW5nLCB3ZSBjb3VsZCB1c2UgYSBjYWNoZWQgdmFsdWUgdG8gbWFrZSB0aGUgaGFuZGxlIGtlZXAgdXBcbiAgICAvLyB3aXRoIHRoZSB1c2VyJ3MgbW91c2UuIE9uIEhUTUw1IGJyb3dzZXJzIHNjcnViYmluZyBpcyByZWFsbHkgc21vb3RoLCBidXRcbiAgICAvLyBzb21lIGZsYXNoIHBsYXllcnMgYXJlIHNsb3csIHNvIHdlIG1pZ2h0IHdhbnQgdG8gdXRpbGl6ZSB0aGlzIGxhdGVyLlxuICAgIC8vIHZhciBwcm9ncmVzcyA9ICAodGhpcy5wbGF5ZXJfLnNjcnViYmluZygpKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIC8gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkgOiB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKSAvIHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuICAgIHZhciBwcm9ncmVzcyA9IHRoaXMuZ2V0UGVyY2VudCgpO1xuICAgIHZhciBiYXIgPSB0aGlzLmJhcjtcblxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gYmFyLi4uXG4gICAgaWYgKCFiYXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcm90ZWN0IGFnYWluc3Qgbm8gZHVyYXRpb24gYW5kIG90aGVyIGRpdmlzaW9uIGlzc3Vlc1xuICAgIGlmICh0eXBlb2YgcHJvZ3Jlc3MgIT09ICdudW1iZXInIHx8IHByb2dyZXNzICE9PSBwcm9ncmVzcyB8fCBwcm9ncmVzcyA8IDAgfHwgcHJvZ3Jlc3MgPT09IEluZmluaXR5KSB7XG4gICAgICBwcm9ncmVzcyA9IDA7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCB0byBhIHBlcmNlbnRhZ2UgZm9yIHNldHRpbmdcbiAgICB2YXIgcGVyY2VudGFnZSA9IChwcm9ncmVzcyAqIDEwMCkudG9GaXhlZCgyKSArICclJztcbiAgICB2YXIgc3R5bGUgPSBiYXIuZWwoKS5zdHlsZTtcblxuICAgIC8vIFNldCB0aGUgbmV3IGJhciB3aWR0aCBvciBoZWlnaHRcbiAgICBpZiAodGhpcy52ZXJ0aWNhbCgpKSB7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBwZXJjZW50YWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS53aWR0aCA9IHBlcmNlbnRhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyZXNzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgZGlzdGFuY2UgZm9yIHNsaWRlclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIFNsaWRlci5cbiAgICogICAgICAgICAtIHBvc2l0aW9uLnggZm9yIHZlcnRpY2FsIGBTbGlkZXJgc1xuICAgKiAgICAgICAgIC0gcG9zaXRpb24ueSBmb3IgaG9yaXpvbnRhbCBgU2xpZGVyYHNcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmNhbGN1bGF0ZURpc3RhbmNlID0gZnVuY3Rpb24gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRQb2ludGVyUG9zaXRpb24odGhpcy5lbF8sIGV2ZW50KTtcblxuICAgIGlmICh0aGlzLnZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbi55O1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb24ueDtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgYGZvY3VzYCBldmVudCBvbiB0aGlzIGBTbGlkZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBmb2N1c2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIGZvY3VzXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIGhhbmRsZUZvY3VzKCkge1xuICAgIHRoaXMub24odGhpcy5iYXIuZWxfLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlQcmVzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBrZXlkb3duYCBldmVudCBvbiB0aGUgYFNsaWRlcmAuIFdhdGNoZXMgZm9yIGxlZnQsIHJpZ3RoLCB1cCwgYW5kIGRvd25cbiAgICogYXJyb3cga2V5cy4gVGhpcyBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgY2FsbGVkIHdoZW4gdGhlIHNsaWRlciBoYXMgZm9jdXMuIFNlZVxuICAgKiB7QGxpbmsgU2xpZGVyI2hhbmRsZUZvY3VzfSBhbmQge0BsaW5rIFNsaWRlciNoYW5kbGVCbHVyfS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIHRoZSBga2V5ZG93bmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcbiAgICAvLyBMZWZ0IGFuZCBEb3duIEFycm93c1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMzcgfHwgZXZlbnQud2hpY2ggPT09IDQwKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5zdGVwQmFjaygpO1xuXG4gICAgICAvLyBVcCBhbmQgUmlnaHQgQXJyb3dzXG4gICAgfSBlbHNlIGlmIChldmVudC53aGljaCA9PT0gMzggfHwgZXZlbnQud2hpY2ggPT09IDM5KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5zdGVwRm9yd2FyZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgYGJsdXJgIGV2ZW50IG9uIHRoaXMgYFNsaWRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGJsdXJgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBibHVyXG4gICAqL1xuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIGhhbmRsZUJsdXIoKSB7XG4gICAgdGhpcy5vZmYodGhpcy5iYXIuZWxfLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlQcmVzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExpc3RlbmVyIGZvciBjbGljayBldmVudHMgb24gc2xpZGVyLCB1c2VkIHRvIHByZXZlbnQgY2xpY2tzXG4gICAqICAgZnJvbSBidWJibGluZyB1cCB0byBwYXJlbnQgZWxlbWVudHMgbGlrZSBidXR0b24gbWVudXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgICAgICAgRXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBvYmplY3QgdG8gcnVuXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCBpZiBzbGlkZXIgaXMgaG9yaXpvbnRhbCBmb3IgdmVydGljYWxcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cbiAgICogICAgICAgIC0gdHJ1ZSBpZiBzbGlkZXIgaXMgdmVydGljYWwsXG4gICAqICAgICAgICAtIGZhbHNlIGlzIGhvcml6b250YWxcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIHRydWUgaWYgc2xpZGVyIGlzIHZlcnRpY2FsLCBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgdGhlIHNsaWRlciBpcyBob3Jpem9udGFsLCBhbmQgZ2V0dGluZ1xuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUudmVydGljYWwgPSBmdW5jdGlvbiB2ZXJ0aWNhbChib29sKSB7XG4gICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMudmVydGljYWxfIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMudmVydGljYWxfID0gISFib29sO1xuXG4gICAgaWYgKHRoaXMudmVydGljYWxfKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLXZlcnRpY2FsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkZXItaG9yaXpvbnRhbCcpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU2xpZGVyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1NsaWRlcicsIFNsaWRlcik7XG5cbi8qKlxuICogQGZpbGUgbG9hZC1wcm9ncmVzcy1iYXIuanNcbiAqL1xuXG4vKipcbiAqIFNob3dzIGxvYWRpbmcgcHJvZ3Jlc3NcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTG9hZFByb2dyZXNzQmFyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTG9hZFByb2dyZXNzQmFyLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIExvYWRQcm9ncmVzc0JhcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBMb2FkUHJvZ3Jlc3NCYXIpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5wYXJ0RWxzXyA9IFtdO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ3Byb2dyZXNzJywgX3RoaXMudXBkYXRlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBMb2FkUHJvZ3Jlc3NCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1sb2FkLXByb2dyZXNzJyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPjxzcGFuPicgKyB0aGlzLmxvY2FsaXplKCdMb2FkZWQnKSArICc8L3NwYW4+OiAwJTwvc3Bhbj4nXG4gICAgfSk7XG4gIH07XG5cbiAgTG9hZFByb2dyZXNzQmFyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLnBhcnRFbHNfID0gbnVsbDtcblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHByb2dyZXNzIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYHByb2dyZXNzYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3Byb2dyZXNzXG4gICAqL1xuXG5cbiAgTG9hZFByb2dyZXNzQmFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnBsYXllcl8uYnVmZmVyZWQoKTtcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcbiAgICB2YXIgYnVmZmVyZWRFbmQgPSB0aGlzLnBsYXllcl8uYnVmZmVyZWRFbmQoKTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnBhcnRFbHNfO1xuXG4gICAgLy8gZ2V0IHRoZSBwZXJjZW50IHdpZHRoIG9mIGEgdGltZSBjb21wYXJlZCB0byB0aGUgdG90YWwgZW5kXG4gICAgdmFyIHBlcmNlbnRpZnkgPSBmdW5jdGlvbiBwZXJjZW50aWZ5KHRpbWUsIGVuZCkge1xuICAgICAgLy8gbm8gTmFOXG4gICAgICB2YXIgcGVyY2VudCA9IHRpbWUgLyBlbmQgfHwgMDtcblxuICAgICAgcmV0dXJuIChwZXJjZW50ID49IDEgPyAxIDogcGVyY2VudCkgKiAxMDAgKyAnJSc7XG4gICAgfTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgd2lkdGggb2YgdGhlIHByb2dyZXNzIGJhclxuICAgIHRoaXMuZWxfLnN0eWxlLndpZHRoID0gcGVyY2VudGlmeShidWZmZXJlZEVuZCwgZHVyYXRpb24pO1xuXG4gICAgLy8gYWRkIGNoaWxkIGVsZW1lbnRzIHRvIHJlcHJlc2VudCB0aGUgaW5kaXZpZHVhbCBidWZmZXJlZCB0aW1lIHJhbmdlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgICAgdmFyIGVuZCA9IGJ1ZmZlcmVkLmVuZChpKTtcbiAgICAgIHZhciBwYXJ0ID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmICghcGFydCkge1xuICAgICAgICBwYXJ0ID0gdGhpcy5lbF8uYXBwZW5kQ2hpbGQoY3JlYXRlRWwoKSk7XG4gICAgICAgIGNoaWxkcmVuW2ldID0gcGFydDtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHRoZSBwZXJjZW50IGJhc2VkIG9uIHRoZSB3aWR0aCBvZiB0aGUgcHJvZ3Jlc3MgYmFyIChidWZmZXJlZEVuZClcbiAgICAgIHBhcnQuc3R5bGUubGVmdCA9IHBlcmNlbnRpZnkoc3RhcnQsIGJ1ZmZlcmVkRW5kKTtcbiAgICAgIHBhcnQuc3R5bGUud2lkdGggPSBwZXJjZW50aWZ5KGVuZCAtIHN0YXJ0LCBidWZmZXJlZEVuZCk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHVudXNlZCBidWZmZXJlZCByYW5nZSBlbGVtZW50c1xuICAgIGZvciAodmFyIF9pID0gY2hpbGRyZW4ubGVuZ3RoOyBfaSA+IGJ1ZmZlcmVkLmxlbmd0aDsgX2ktLSkge1xuICAgICAgdGhpcy5lbF8ucmVtb3ZlQ2hpbGQoY2hpbGRyZW5bX2kgLSAxXSk7XG4gICAgfVxuICAgIGNoaWxkcmVuLmxlbmd0aCA9IGJ1ZmZlcmVkLmxlbmd0aDtcbiAgfTtcblxuICByZXR1cm4gTG9hZFByb2dyZXNzQmFyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0xvYWRQcm9ncmVzc0JhcicsIExvYWRQcm9ncmVzc0Jhcik7XG5cbi8qKlxuICogQGZpbGUgdGltZS10b29sdGlwLmpzXG4gKi9cblxuLyoqXG4gKiBUaW1lIHRvb2x0aXBzIGRpc3BsYXkgYSB0aW1lIGFib3ZlIHRoZSBwcm9ncmVzcyBiYXIuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFRpbWVUb29sdGlwID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGltZVRvb2x0aXAsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRpbWVUb29sdGlwKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVUb29sdGlwKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgdGltZSB0b29sdGlwIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIFRpbWVUb29sdGlwLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdGltZS10b29sdGlwJ1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgdGltZSB0b29sdGlwIHJlbGF0aXZlIHRvIHRoZSBgU2Vla0JhcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZWVrQmFyUmVjdFxuICAgKiAgICAgICAgVGhlIGBDbGllbnRSZWN0YCBmb3IgdGhlIHtAbGluayBTZWVrQmFyfSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vla0JhclBvaW50XG4gICAqICAgICAgICBBIG51bWJlciBmcm9tIDAgdG8gMSwgcmVwcmVzZW50aW5nIGEgaG9yaXpvbnRhbCByZWZlcmVuY2UgcG9pbnRcbiAgICogICAgICAgIGZyb20gdGhlIGxlZnQgZWRnZSBvZiB0aGUge0BsaW5rIFNlZWtCYXJ9XG4gICAqL1xuXG5cbiAgVGltZVRvb2x0aXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50LCBjb250ZW50KSB7XG4gICAgdmFyIHRvb2x0aXBSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxfKTtcbiAgICB2YXIgcGxheWVyUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLnBsYXllcl8uZWwoKSk7XG4gICAgdmFyIHNlZWtCYXJQb2ludFB4ID0gc2Vla0JhclJlY3Qud2lkdGggKiBzZWVrQmFyUG9pbnQ7XG5cbiAgICAvLyBkbyBub3RoaW5nIGlmIGVpdGhlciByZWN0IGlzbid0IGF2YWlsYWJsZVxuICAgIC8vIGZvciBleGFtcGxlLCBpZiB0aGUgcGxheWVyIGlzbid0IGluIHRoZSBET00gZm9yIHRlc3RpbmdcbiAgICBpZiAoIXBsYXllclJlY3QgfHwgIXRvb2x0aXBSZWN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyB0aGUgc3BhY2UgbGVmdCBvZiB0aGUgYHNlZWtCYXJQb2ludGAgYXZhaWxhYmxlIHdpdGhpbiB0aGUgYm91bmRzXG4gICAgLy8gb2YgdGhlIHBsYXllci4gV2UgY2FsY3VsYXRlIGFueSBnYXAgYmV0d2VlbiB0aGUgbGVmdCBlZGdlIG9mIHRoZSBwbGF5ZXJcbiAgICAvLyBhbmQgdGhlIGxlZnQgZWRnZSBvZiB0aGUgYFNlZWtCYXJgIGFuZCBhZGQgdGhlIG51bWJlciBvZiBwaXhlbHMgaW4gdGhlXG4gICAgLy8gYFNlZWtCYXJgIGJlZm9yZSBoaXR0aW5nIHRoZSBgc2Vla0JhclBvaW50YFxuICAgIHZhciBzcGFjZUxlZnRPZlBvaW50ID0gc2Vla0JhclJlY3QubGVmdCAtIHBsYXllclJlY3QubGVmdCArIHNlZWtCYXJQb2ludFB4O1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgc3BhY2UgcmlnaHQgb2YgdGhlIGBzZWVrQmFyUG9pbnRgIGF2YWlsYWJsZSB3aXRoaW4gdGhlIGJvdW5kc1xuICAgIC8vIG9mIHRoZSBwbGF5ZXIuIFdlIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHBpeGVscyBmcm9tIHRoZSBgc2Vla0JhclBvaW50YFxuICAgIC8vIHRvIHRoZSByaWdodCBlZGdlIG9mIHRoZSBgU2Vla0JhcmAgYW5kIGFkZCB0byB0aGF0IGFueSBnYXAgYmV0d2VlbiB0aGVcbiAgICAvLyByaWdodCBlZGdlIG9mIHRoZSBgU2Vla0JhcmAgYW5kIHRoZSBwbGF5ZXIuXG4gICAgdmFyIHNwYWNlUmlnaHRPZlBvaW50ID0gc2Vla0JhclJlY3Qud2lkdGggLSBzZWVrQmFyUG9pbnRQeCArIChwbGF5ZXJSZWN0LnJpZ2h0IC0gc2Vla0JhclJlY3QucmlnaHQpO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgbnVtYmVyIG9mIHBpeGVscyBieSB3aGljaCB0aGUgdG9vbHRpcCB3aWxsIG5lZWQgdG8gYmUgcHVsbGVkXG4gICAgLy8gZnVydGhlciB0byB0aGUgcmlnaHQgdG8gY2VudGVyIGl0IG92ZXIgdGhlIGBzZWVrQmFyUG9pbnRgLlxuICAgIHZhciBwdWxsVG9vbHRpcEJ5ID0gdG9vbHRpcFJlY3Qud2lkdGggLyAyO1xuXG4gICAgLy8gQWRqdXN0IHRoZSBgcHVsbFRvb2x0aXBCeWAgZGlzdGFuY2UgdG8gdGhlIGxlZnQgb3IgcmlnaHQgZGVwZW5kaW5nIG9uXG4gICAgLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHNwYWNlIGNhbGN1bGF0aW9ucyBhYm92ZS5cbiAgICBpZiAoc3BhY2VMZWZ0T2ZQb2ludCA8IHB1bGxUb29sdGlwQnkpIHtcbiAgICAgIHB1bGxUb29sdGlwQnkgKz0gcHVsbFRvb2x0aXBCeSAtIHNwYWNlTGVmdE9mUG9pbnQ7XG4gICAgfSBlbHNlIGlmIChzcGFjZVJpZ2h0T2ZQb2ludCA8IHB1bGxUb29sdGlwQnkpIHtcbiAgICAgIHB1bGxUb29sdGlwQnkgPSBzcGFjZVJpZ2h0T2ZQb2ludDtcbiAgICB9XG5cbiAgICAvLyBEdWUgdG8gdGhlIGltcHJlY2lzaW9uIG9mIGRlY2ltYWwvcmF0aW8gYmFzZWQgY2FsY3VsYXRpb25zIGFuZCB2YXJ5aW5nXG4gICAgLy8gcm91bmRpbmcgYmVoYXZpb3JzLCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgdGhlIHNwYWNpbmcgYWRqdXN0bWVudCBpcyBvZmZcbiAgICAvLyBieSBhIHBpeGVsIG9yIHR3by4gVGhpcyBhZGRzIGluc3VyYW5jZSB0byB0aGVzZSBjYWxjdWxhdGlvbnMuXG4gICAgaWYgKHB1bGxUb29sdGlwQnkgPCAwKSB7XG4gICAgICBwdWxsVG9vbHRpcEJ5ID0gMDtcbiAgICB9IGVsc2UgaWYgKHB1bGxUb29sdGlwQnkgPiB0b29sdGlwUmVjdC53aWR0aCkge1xuICAgICAgcHVsbFRvb2x0aXBCeSA9IHRvb2x0aXBSZWN0LndpZHRoO1xuICAgIH1cblxuICAgIHRoaXMuZWxfLnN0eWxlLnJpZ2h0ID0gJy0nICsgcHVsbFRvb2x0aXBCeSArICdweCc7XG4gICAgdGV4dENvbnRlbnQodGhpcy5lbF8sIGNvbnRlbnQpO1xuICB9O1xuXG4gIHJldHVybiBUaW1lVG9vbHRpcDtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUaW1lVG9vbHRpcCcsIFRpbWVUb29sdGlwKTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5LXByb2dyZXNzLWJhci5qc1xuICovXG5cbi8qKlxuICogVXNlZCBieSB7QGxpbmsgU2Vla0Jhcn0gdG8gZGlzcGxheSBtZWRpYSBwbGF5YmFjayBwcm9ncmVzcyBhcyBwYXJ0IG9mIHRoZVxuICoge0BsaW5rIFByb2dyZXNzQ29udHJvbH0uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFBsYXlQcm9ncmVzc0JhciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFBsYXlQcm9ncmVzc0JhciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUGxheVByb2dyZXNzQmFyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXlQcm9ncmVzc0Jhcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIHRoZSBET00gZWxlbWVudCBmb3IgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgUGxheVByb2dyZXNzQmFyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcGxheS1wcm9ncmVzcyB2anMtc2xpZGVyLWJhcicsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj48c3Bhbj4nICsgdGhpcy5sb2NhbGl6ZSgnUHJvZ3Jlc3MnKSArICc8L3NwYW4+OiAwJTwvc3Bhbj4nXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIHVwZGF0ZXMgdG8gaXRzIG93biBET00gYXMgd2VsbCBhcyB0aGUgRE9NIG9mIGl0c1xuICAgKiB7QGxpbmsgVGltZVRvb2x0aXB9IGNoaWxkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2Vla0JhclJlY3RcbiAgICogICAgICAgIFRoZSBgQ2xpZW50UmVjdGAgZm9yIHRoZSB7QGxpbmsgU2Vla0Jhcn0gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlZWtCYXJQb2ludFxuICAgKiAgICAgICAgQSBudW1iZXIgZnJvbSAwIHRvIDEsIHJlcHJlc2VudGluZyBhIGhvcml6b250YWwgcmVmZXJlbmNlIHBvaW50XG4gICAqICAgICAgICBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHtAbGluayBTZWVrQmFyfVxuICAgKi9cblxuXG4gIFBsYXlQcm9ncmVzc0Jhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNlZWtCYXJSZWN0LCBzZWVrQmFyUG9pbnQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHJBRiBJRCwgY2FuY2VsIGl0IHNvIHdlIGRvbid0IG92ZXItcXVldWUuXG4gICAgaWYgKHRoaXMucmFmSWRfKSB7XG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWRfKTtcbiAgICB9XG5cbiAgICB0aGlzLnJhZklkXyA9IHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aW1lID0gX3RoaXMyLnBsYXllcl8uc2NydWJiaW5nKCkgPyBfdGhpczIucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogX3RoaXMyLnBsYXllcl8uY3VycmVudFRpbWUoKTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBmb3JtYXRUaW1lKHRpbWUsIF90aGlzMi5wbGF5ZXJfLmR1cmF0aW9uKCkpO1xuICAgICAgdmFyIHRpbWVUb29sdGlwID0gX3RoaXMyLmdldENoaWxkKCd0aW1lVG9vbHRpcCcpO1xuXG4gICAgICBpZiAodGltZVRvb2x0aXApIHtcbiAgICAgICAgdGltZVRvb2x0aXAudXBkYXRlKHNlZWtCYXJSZWN0LCBzZWVrQmFyUG9pbnQsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBQbGF5UHJvZ3Jlc3NCYXI7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB7QGxpbmsgUGxheVByb2dyZXNzQmFyfS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cblBsYXlQcm9ncmVzc0Jhci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbXVxufTtcblxuLy8gVGltZSB0b29sdGlwcyBzaG91bGQgbm90IGJlIGFkZGVkIHRvIGEgcGxheWVyIG9uIG1vYmlsZSBkZXZpY2VzXG5pZiAoIUlTX0lPUyAmJiAhSVNfQU5EUk9JRCkge1xuICBQbGF5UHJvZ3Jlc3NCYXIucHJvdG90eXBlLm9wdGlvbnNfLmNoaWxkcmVuLnB1c2goJ3RpbWVUb29sdGlwJyk7XG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUGxheVByb2dyZXNzQmFyJywgUGxheVByb2dyZXNzQmFyKTtcblxuLyoqXG4gKiBAZmlsZSBtb3VzZS10aW1lLWRpc3BsYXkuanNcbiAqL1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgTW91c2VUaW1lRGlzcGxheX0gY29tcG9uZW50IHRyYWNrcyBtb3VzZSBtb3ZlbWVudCBvdmVyIHRoZVxuICoge0BsaW5rIFByb2dyZXNzQ29udHJvbH0uIEl0IGRpc3BsYXlzIGFuIGluZGljYXRvciBhbmQgYSB7QGxpbmsgVGltZVRvb2x0aXB9XG4gKiBpbmRpY2F0aW5nIHRoZSB0aW1lIHdoaWNoIGlzIHJlcHJlc2VudGVkIGJ5IGEgZ2l2ZW4gcG9pbnQgaW4gdGhlXG4gKiB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sfS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTW91c2VUaW1lRGlzcGxheSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1vdXNlVGltZURpc3BsYXksIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSB7QGxpbmsgUGxheWVyfSB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTW91c2VUaW1lRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNb3VzZVRpbWVEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudXBkYXRlID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMudXBkYXRlKSwgMjUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIERPTSBlbGVtZW50IGZvciB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgTW91c2VUaW1lRGlzcGxheS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLW1vdXNlLWRpc3BsYXknXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIHVwZGF0ZXMgdG8gaXRzIG93biBET00gYXMgd2VsbCBhcyB0aGUgRE9NIG9mIGl0c1xuICAgKiB7QGxpbmsgVGltZVRvb2x0aXB9IGNoaWxkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2Vla0JhclJlY3RcbiAgICogICAgICAgIFRoZSBgQ2xpZW50UmVjdGAgZm9yIHRoZSB7QGxpbmsgU2Vla0Jhcn0gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlZWtCYXJQb2ludFxuICAgKiAgICAgICAgQSBudW1iZXIgZnJvbSAwIHRvIDEsIHJlcHJlc2VudGluZyBhIGhvcml6b250YWwgcmVmZXJlbmNlIHBvaW50XG4gICAqICAgICAgICBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHtAbGluayBTZWVrQmFyfVxuICAgKi9cblxuXG4gIE1vdXNlVGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyByQUYgSUQsIGNhbmNlbCBpdCBzbyB3ZSBkb24ndCBvdmVyLXF1ZXVlLlxuICAgIGlmICh0aGlzLnJhZklkXykge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkXyk7XG4gICAgfVxuXG4gICAgdGhpcy5yYWZJZF8gPSB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZHVyYXRpb24gPSBfdGhpczIucGxheWVyXy5kdXJhdGlvbigpO1xuICAgICAgdmFyIGNvbnRlbnQgPSBmb3JtYXRUaW1lKHNlZWtCYXJQb2ludCAqIGR1cmF0aW9uLCBkdXJhdGlvbik7XG5cbiAgICAgIF90aGlzMi5lbF8uc3R5bGUubGVmdCA9IHNlZWtCYXJSZWN0LndpZHRoICogc2Vla0JhclBvaW50ICsgJ3B4JztcbiAgICAgIF90aGlzMi5nZXRDaGlsZCgndGltZVRvb2x0aXAnKS51cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCwgY29udGVudCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1vdXNlVGltZURpc3BsYXk7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBgTW91c2VUaW1lRGlzcGxheWBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cbk1vdXNlVGltZURpc3BsYXkucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWyd0aW1lVG9vbHRpcCddXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01vdXNlVGltZURpc3BsYXknLCBNb3VzZVRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBzZWVrLWJhci5qc1xuICovXG5cbi8vIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB0aGUgYHN0ZXAqYCBmdW5jdGlvbnMgbW92ZSB0aGUgdGltZWxpbmUuXG52YXIgU1RFUF9TRUNPTkRTID0gNTtcblxuLy8gVGhlIGludGVydmFsIGF0IHdoaWNoIHRoZSBiYXIgc2hvdWxkIHVwZGF0ZSBhcyBpdCBwcm9ncmVzc2VzLlxudmFyIFVQREFURV9SRUZSRVNIX0lOVEVSVkFMID0gMzA7XG5cbi8qKlxuICogU2VlayBiYXIgYW5kIGNvbnRhaW5lciBmb3IgdGhlIHByb2dyZXNzIGJhcnMuIFVzZXMge0BsaW5rIFBsYXlQcm9ncmVzc0Jhcn1cbiAqIGFzIGl0cyBgYmFyYC5cbiAqXG4gKiBAZXh0ZW5kcyBTbGlkZXJcbiAqL1xuXG52YXIgU2Vla0JhciA9IGZ1bmN0aW9uIChfU2xpZGVyKSB7XG4gIGluaGVyaXRzKFNlZWtCYXIsIF9TbGlkZXIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gU2Vla0JhcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTZWVrQmFyKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1NsaWRlci5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuc2V0RXZlbnRIYW5kbGVyc18oKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5zZXRFdmVudEhhbmRsZXJzXyA9IGZ1bmN0aW9uIHNldEV2ZW50SGFuZGxlcnNfKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy51cGRhdGUgPSB0aHJvdHRsZShiaW5kKHRoaXMsIHRoaXMudXBkYXRlKSwgVVBEQVRFX1JFRlJFU0hfSU5URVJWQUwpO1xuXG4gICAgdGhpcy5vbih0aGlzLnBsYXllcl8sICd0aW1ldXBkYXRlJywgdGhpcy51cGRhdGUpO1xuICAgIHRoaXMub24odGhpcy5wbGF5ZXJfLCAnZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcblxuICAgIC8vIHdoZW4gcGxheWluZywgbGV0J3MgZW5zdXJlIHdlIHNtb290aGx5IHVwZGF0ZSB0aGUgcGxheSBwcm9ncmVzcyBiYXJcbiAgICAvLyB2aWEgYW4gaW50ZXJ2YWxcbiAgICB0aGlzLnVwZGF0ZUludGVydmFsID0gbnVsbDtcblxuICAgIHRoaXMub24odGhpcy5wbGF5ZXJfLCBbJ3BsYXlpbmcnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLmNsZWFySW50ZXJ2YWwoX3RoaXMyLnVwZGF0ZUludGVydmFsKTtcblxuICAgICAgX3RoaXMyLnVwZGF0ZUludGVydmFsID0gX3RoaXMyLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIFVQREFURV9SRUZSRVNIX0lOVEVSVkFMKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24odGhpcy5wbGF5ZXJfLCBbJ2VuZGVkJywgJ3BhdXNlJywgJ3dhaXRpbmcnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLmNsZWFySW50ZXJ2YWwoX3RoaXMyLnVwZGF0ZUludGVydmFsKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24odGhpcy5wbGF5ZXJfLCBbJ3RpbWV1cGRhdGUnLCAnZW5kZWQnXSwgdGhpcy51cGRhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgcmV0dXJuIF9TbGlkZXIucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wcm9ncmVzcy1ob2xkZXInXG4gICAgfSwge1xuICAgICAgJ2FyaWEtbGFiZWwnOiB0aGlzLmxvY2FsaXplKCdQcm9ncmVzcyBCYXInKVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHVwZGF0ZXMgdGhlIHBsYXkgcHJvZ3Jlc3MgYmFyIGFuZCBhY2Nlc3NpYmlsaXR5XG4gICAqIGF0dHJpYnV0ZXMgdG8gd2hhdGV2ZXIgaXMgcGFzc2VkIGluLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFRpbWVcbiAgICogICAgICAgIFRoZSBjdXJyZW50VGltZSB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciBhY2Nlc3NpYmlsaXR5XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwZXJjZW50XG4gICAqICAgICAgICBUaGUgcGVyY2VudGFnZSBhcyBhIGRlY2ltYWwgdGhhdCB0aGUgYmFyIHNob3VsZCBiZSBmaWxsZWQgZnJvbSAwLTEuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUudXBkYXRlXyA9IGZ1bmN0aW9uIHVwZGF0ZV8oY3VycmVudFRpbWUsIHBlcmNlbnQpIHtcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcblxuICAgIC8vIG1hY2hpbmUgcmVhZGFibGUgdmFsdWUgb2YgcHJvZ3Jlc3MgYmFyIChwZXJjZW50YWdlIGNvbXBsZXRlKVxuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIChwZXJjZW50ICogMTAwKS50b0ZpeGVkKDIpKTtcblxuICAgIC8vIGh1bWFuIHJlYWRhYmxlIHZhbHVlIG9mIHByb2dyZXNzIGJhciAodGltZSBjb21wbGV0ZSlcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWV0ZXh0JywgdGhpcy5sb2NhbGl6ZSgncHJvZ3Jlc3MgYmFyIHRpbWluZzogY3VycmVudFRpbWU9ezF9IGR1cmF0aW9uPXsyfScsIFtmb3JtYXRUaW1lKGN1cnJlbnRUaW1lLCBkdXJhdGlvbiksIGZvcm1hdFRpbWUoZHVyYXRpb24sIGR1cmF0aW9uKV0sICd7MX0gb2YgezJ9JykpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBgUGxheVByb2dyZXNzQmFyYC5cbiAgICB0aGlzLmJhci51cGRhdGUoZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxfKSwgcGVyY2VudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgc2VlayBiYXIncyBVSS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGB0aW1ldXBkYXRlYCBvciBgZW5kZWRgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGltZXVwZGF0ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKiAgICAgICAgICBUaGUgY3VycmVudCBwZXJjZW50IGF0IGEgbnVtYmVyIGZyb20gMC0xXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgdmFyIHBlcmNlbnQgPSBfU2xpZGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMudXBkYXRlXyh0aGlzLmdldEN1cnJlbnRUaW1lXygpLCBwZXJjZW50KTtcbiAgICByZXR1cm4gcGVyY2VudDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiBjdXJyZW50IHRpbWUgYnV0IGFsbG93cyBmb3Igc21vb3RoIHNjcnViYmluZyxcbiAgICogd2hlbiBwbGF5ZXIgY2FuJ3Qga2VlcCB1cC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHRpbWUgdmFsdWUgdG8gZGlzcGxheVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmdldEN1cnJlbnRUaW1lXyA9IGZ1bmN0aW9uIGdldEN1cnJlbnRUaW1lXygpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJfLnNjcnViYmluZygpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgOiB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogV2Ugd2FudCB0aGUgc2VlayBiYXIgdG8gYmUgZnVsbCBvbiBlbmRlZFxuICAgKiBubyBtYXR0ZXIgd2hhdCB0aGUgYWN0dWFsIGludGVybmFsIHZhbHVlcyBhcmUuIHNvIHdlIGZvcmNlIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYHRpbWV1cGRhdGVgIG9yIGBlbmRlZGAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNlbmRlZFxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZUVuZGVkID0gZnVuY3Rpb24gaGFuZGxlRW5kZWQoZXZlbnQpIHtcbiAgICB0aGlzLnVwZGF0ZV8odGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCksIDEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBlcmNlbnRhZ2Ugb2YgbWVkaWEgcGxheWVkIHNvIGZhci5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwZXJjZW50YWdlIG9mIG1lZGlhIHBsYXllZCBzbyBmYXIgKDAgdG8gMSkuXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuZ2V0UGVyY2VudCA9IGZ1bmN0aW9uIGdldFBlcmNlbnQoKSB7XG4gICAgdmFyIHBlcmNlbnQgPSB0aGlzLmdldEN1cnJlbnRUaW1lXygpIC8gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG5cbiAgICByZXR1cm4gcGVyY2VudCA+PSAxID8gMSA6IHBlcmNlbnQgfHwgMDtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIGRvd24gb24gc2VlayBiYXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgbW91c2Vkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgaWYgKCFpc1NpbmdsZUxlZnRDbGljayhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTdG9wIGV2ZW50IHByb3BhZ2F0aW9uIHRvIHByZXZlbnQgZG91YmxlIGZpcmUgaW4gcHJvZ3Jlc3MtY29udHJvbC5qc1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMucGxheWVyXy5zY3J1YmJpbmcodHJ1ZSk7XG5cbiAgICB0aGlzLnZpZGVvV2FzUGxheWluZyA9ICF0aGlzLnBsYXllcl8ucGF1c2VkKCk7XG4gICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG5cbiAgICBfU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24uY2FsbCh0aGlzLCBldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSBtb3ZlIG9uIHNlZWsgYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYG1vdXNlbW92ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlbW92ZVxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgIGlmICghaXNTaW5nbGVMZWZ0Q2xpY2soZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5ld1RpbWUgPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSAqIHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuXG4gICAgLy8gRG9uJ3QgbGV0IHZpZGVvIGVuZCB3aGlsZSBzY3J1YmJpbmcuXG4gICAgaWYgKG5ld1RpbWUgPT09IHRoaXMucGxheWVyXy5kdXJhdGlvbigpKSB7XG4gICAgICBuZXdUaW1lID0gbmV3VGltZSAtIDAuMTtcbiAgICB9XG5cbiAgICAvLyBTZXQgbmV3IHRpbWUgKHRlbGwgcGxheWVyIHRvIHNlZWsgdG8gbmV3IHRpbWUpXG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKG5ld1RpbWUpO1xuICB9O1xuXG4gIFNlZWtCYXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBfU2xpZGVyLnByb3RvdHlwZS5lbmFibGUuY2FsbCh0aGlzKTtcbiAgICB2YXIgbW91c2VUaW1lRGlzcGxheSA9IHRoaXMuZ2V0Q2hpbGQoJ21vdXNlVGltZURpc3BsYXknKTtcblxuICAgIGlmICghbW91c2VUaW1lRGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1vdXNlVGltZURpc3BsYXkuc2hvdygpO1xuICB9O1xuXG4gIFNlZWtCYXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIF9TbGlkZXIucHJvdG90eXBlLmRpc2FibGUuY2FsbCh0aGlzKTtcbiAgICB2YXIgbW91c2VUaW1lRGlzcGxheSA9IHRoaXMuZ2V0Q2hpbGQoJ21vdXNlVGltZURpc3BsYXknKTtcblxuICAgIGlmICghbW91c2VUaW1lRGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1vdXNlVGltZURpc3BsYXkuaGlkZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgdXAgb24gc2VlayBiYXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgbW91c2V1cGAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNldXBcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldmVudCkge1xuICAgIF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAuY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICAvLyBTdG9wIGV2ZW50IHByb3BhZ2F0aW9uIHRvIHByZXZlbnQgZG91YmxlIGZpcmUgaW4gcHJvZ3Jlc3MtY29udHJvbC5qc1xuICAgIGlmIChldmVudCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMucGxheWVyXy5zY3J1YmJpbmcoZmFsc2UpO1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlciB0aW1ldXBkYXRlIGJlY2F1c2Ugd2UncmUgZG9uZSBzZWVraW5nIGFuZCB0aGUgdGltZSBoYXMgY2hhbmdlZC5cbiAgICAgKiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIGlmIHRoZSBwbGF5ZXIgaXMgcGF1c2VkIHRvIHRpbWUgdGhlIHRpbWUgZGlzcGxheXMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgVGVjaCN0aW1ldXBkYXRlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMucGxheWVyXy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xuICAgIGlmICh0aGlzLnZpZGVvV2FzUGxheWluZykge1xuICAgICAgc2lsZW5jZVByb21pc2UodGhpcy5wbGF5ZXJfLnBsYXkoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIG1vcmUgcXVpY2tseSBmYXN0IGZvcndhcmQgZm9yIGtleWJvYXJkLW9ubHkgdXNlcnNcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5zdGVwRm9yd2FyZCA9IGZ1bmN0aW9uIHN0ZXBGb3J3YXJkKCkge1xuICAgIHRoaXMucGxheWVyXy5jdXJyZW50VGltZSh0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKSArIFNURVBfU0VDT05EUyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgbW9yZSBxdWlja2x5IHJld2luZCBmb3Iga2V5Ym9hcmQtb25seSB1c2Vyc1xuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLnN0ZXBCYWNrID0gZnVuY3Rpb24gc3RlcEJhY2soKSB7XG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpIC0gU1RFUF9TRUNPTkRTKTtcbiAgfTtcblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgcGxheWJhY2sgc3RhdGUgb2YgdGhlIHBsYXllclxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gZW50ZXIgb3Igc3BhY2UgaXMgdXNlZCBvbiB0aGUgc2Vla2JhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgKlxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZUFjdGlvbiA9IGZ1bmN0aW9uIGhhbmRsZUFjdGlvbihldmVudCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhpcyBTZWVrQmFyIGhhcyBmb2N1cyBhbmQgYSBrZXkgZ2V0cyBwcmVzc2VkIGRvd24uIEJ5XG4gICAqIGRlZmF1bHQgaXQgd2lsbCBjYWxsIGB0aGlzLmhhbmRsZUFjdGlvbmAgd2hlbiB0aGUga2V5IGlzIHNwYWNlIG9yIGVudGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcblxuICAgIC8vIFN1cHBvcnQgU3BhY2UgKDMyKSBvciBFbnRlciAoMTMpIGtleSBvcGVyYXRpb24gdG8gZmlyZSBhIGNsaWNrIGV2ZW50XG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzMiB8fCBldmVudC53aGljaCA9PT0gMTMpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmhhbmRsZUFjdGlvbihldmVudCk7XG4gICAgfSBlbHNlIGlmIChfU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcykge1xuXG4gICAgICAvLyBQYXNzIGtleXByZXNzIGhhbmRsaW5nIHVwIGZvciB1bnN1cHBvcnRlZCBrZXlzXG4gICAgICBfU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcy5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNlZWtCYXI7XG59KFNsaWRlcik7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYFNlZWtCYXJgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5TZWVrQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFsnbG9hZFByb2dyZXNzQmFyJywgJ3BsYXlQcm9ncmVzc0JhciddLFxuICBiYXJOYW1lOiAncGxheVByb2dyZXNzQmFyJ1xufTtcblxuLy8gTW91c2VUaW1lRGlzcGxheSB0b29sdGlwcyBzaG91bGQgbm90IGJlIGFkZGVkIHRvIGEgcGxheWVyIG9uIG1vYmlsZSBkZXZpY2VzXG5pZiAoIUlTX0lPUyAmJiAhSVNfQU5EUk9JRCkge1xuICBTZWVrQmFyLnByb3RvdHlwZS5vcHRpb25zXy5jaGlsZHJlbi5zcGxpY2UoMSwgMCwgJ21vdXNlVGltZURpc3BsYXknKTtcbn1cblxuLyoqXG4gKiBDYWxsIHRoZSB1cGRhdGUgZXZlbnQgZm9yIHRoaXMgU2xpZGVyIHdoZW4gdGhpcyBldmVudCBoYXBwZW5zIG9uIHRoZSBwbGF5ZXIuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuU2Vla0Jhci5wcm90b3R5cGUucGxheWVyRXZlbnQgPSAndGltZXVwZGF0ZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU2Vla0JhcicsIFNlZWtCYXIpO1xuXG4vKipcbiAqIEBmaWxlIHByb2dyZXNzLWNvbnRyb2wuanNcbiAqL1xuXG4vKipcbiAqIFRoZSBQcm9ncmVzcyBDb250cm9sIGNvbXBvbmVudCBjb250YWlucyB0aGUgc2VlayBiYXIsIGxvYWQgcHJvZ3Jlc3MsXG4gKiBhbmQgcGxheSBwcm9ncmVzcy5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUHJvZ3Jlc3NDb250cm9sID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUHJvZ3Jlc3NDb250cm9sLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFByb2dyZXNzQ29udHJvbChwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9ncmVzc0NvbnRyb2wpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpLCAyNSk7XG4gICAgX3RoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMuaGFuZGxlTW91c2VTZWVrKSwgMjUpO1xuXG4gICAgX3RoaXMuZW5hYmxlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcHJvZ3Jlc3MtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgYFByb2dyZXNzQ29udHJvbGAsIHRoZSBwb2ludGVyIHBvc2l0aW9uXG4gICAqIGdldHMgcGFzc2VkIGRvd24gdG8gdGhlIGBNb3VzZVRpbWVEaXNwbGF5YCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYG1vdXNlbW92ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW4gbW91c2Vtb3ZlXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIgc2Vla0JhciA9IHRoaXMuZ2V0Q2hpbGQoJ3NlZWtCYXInKTtcblxuICAgIGlmIChzZWVrQmFyKSB7XG4gICAgICB2YXIgbW91c2VUaW1lRGlzcGxheSA9IHNlZWtCYXIuZ2V0Q2hpbGQoJ21vdXNlVGltZURpc3BsYXknKTtcbiAgICAgIHZhciBzZWVrQmFyRWwgPSBzZWVrQmFyLmVsKCk7XG4gICAgICB2YXIgc2Vla0JhclJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc2Vla0JhckVsKTtcbiAgICAgIHZhciBzZWVrQmFyUG9pbnQgPSBnZXRQb2ludGVyUG9zaXRpb24oc2Vla0JhckVsLCBldmVudCkueDtcblxuICAgICAgLy8gVGhlIGRlZmF1bHQgc2tpbiBoYXMgYSBnYXAgb24gZWl0aGVyIHNpZGUgb2YgdGhlIGBTZWVrQmFyYC4gVGhpcyBtZWFuc1xuICAgICAgLy8gdGhhdCBpdCdzIHBvc3NpYmxlIHRvIHRyaWdnZXIgdGhpcyBiZWhhdmlvciBvdXRzaWRlIHRoZSBib3VuZGFyaWVzIG9mXG4gICAgICAvLyB0aGUgYFNlZWtCYXJgLiBUaGlzIGVuc3VyZXMgd2Ugc3RheSB3aXRoaW4gaXQgYXQgYWxsIHRpbWVzLlxuICAgICAgaWYgKHNlZWtCYXJQb2ludCA+IDEpIHtcbiAgICAgICAgc2Vla0JhclBvaW50ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc2Vla0JhclBvaW50IDwgMCkge1xuICAgICAgICBzZWVrQmFyUG9pbnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobW91c2VUaW1lRGlzcGxheSkge1xuICAgICAgICBtb3VzZVRpbWVEaXNwbGF5LnVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgdGhyb3R0bGVkIHZlcnNpb24gb2YgdGhlIHtAbGluayBQcm9ncmVzc0NvbnRyb2wjaGFuZGxlTW91c2VTZWVrfSBsaXN0ZW5lci5cbiAgICpcbiAgICogQG1ldGhvZCBQcm9ncmVzc0NvbnRyb2wjdGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYG1vdXNlbW92ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW4gbW91c2Vtb3ZlXG4gICAqIEBsaXN0ZW4gdG91Y2htb3ZlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNlbW92ZWAgb3IgYHRvdWNobW92ZWAgZXZlbnRzIG9uIHRoZSBgUHJvZ3Jlc3NDb250cm9sYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlbW92ZVxuICAgKiBAbGlzdGVucyB0b3VjaG1vdmVcbiAgICovXG5cblxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlU2VlayA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlU2VlayhldmVudCkge1xuICAgIHZhciBzZWVrQmFyID0gdGhpcy5nZXRDaGlsZCgnc2Vla0JhcicpO1xuXG4gICAgaWYgKHNlZWtCYXIpIHtcbiAgICAgIHNlZWtCYXIuaGFuZGxlTW91c2VNb3ZlKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFyZSBjb250cm9scyBhcmUgY3VycmVudGx5IGVuYWJsZWQgZm9yIHRoaXMgcHJvZ3Jlc3MgY29udHJvbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICB0cnVlIGlmIGNvbnRyb2xzIGFyZSBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG5cblxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmVuYWJsZWQgPSBmdW5jdGlvbiBlbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZWRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIGFsbCBjb250cm9scyBvbiB0aGUgcHJvZ3Jlc3MgY29udHJvbCBhbmQgaXRzIGNoaWxkcmVuXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB0aGlzLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5kaXNhYmxlICYmIGNoaWxkLmRpc2FibGUoKTtcbiAgICB9KTtcblxuICAgIGlmICghdGhpcy5lbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm9mZihbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICB0aGlzLm9mZih0aGlzLmVsXywgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLmhhbmRsZU1vdXNlVXAoKTtcblxuICAgIHRoaXMuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBhbGwgY29udHJvbHMgb24gdGhlIHByb2dyZXNzIGNvbnRyb2wgYW5kIGl0cyBjaGlsZHJlblxuICAgKi9cblxuXG4gIFByb2dyZXNzQ29udHJvbC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIHRoaXMuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLmVuYWJsZSAmJiBjaGlsZC5lbmFibGUoKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub24oWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbih0aGlzLmVsXywgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xuXG4gICAgdGhpcy5lbmFibGVkXyA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnRzIG9uIHRoZSBgUHJvZ3Jlc3NDb250cm9sYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlZG93blxuICAgKiBAbGlzdGVucyB0b3VjaHN0YXJ0XG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICB2YXIgZG9jID0gdGhpcy5lbF8ub3duZXJEb2N1bWVudDtcbiAgICB2YXIgc2Vla0JhciA9IHRoaXMuZ2V0Q2hpbGQoJ3NlZWtCYXInKTtcblxuICAgIGlmIChzZWVrQmFyKSB7XG4gICAgICBzZWVrQmFyLmhhbmRsZU1vdXNlRG93bihldmVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5vbihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2Vlayk7XG4gICAgdGhpcy5vbihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2Vlayk7XG4gICAgdGhpcy5vbihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50cyBvbiB0aGUgYFByb2dyZXNzQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbGlzdGVucyB0b3VjaGVuZFxuICAgKiBAbGlzdGVucyBtb3VzZXVwXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuICAgIHZhciBzZWVrQmFyID0gdGhpcy5nZXRDaGlsZCgnc2Vla0JhcicpO1xuXG4gICAgaWYgKHNlZWtCYXIpIHtcbiAgICAgIHNlZWtCYXIuaGFuZGxlTW91c2VVcChldmVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZVNlZWspO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrKTtcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gIH07XG5cbiAgcmV0dXJuIFByb2dyZXNzQ29udHJvbDtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBQcm9ncmVzc0NvbnRyb2xgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Qcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWydzZWVrQmFyJ11cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUHJvZ3Jlc3NDb250cm9sJywgUHJvZ3Jlc3NDb250cm9sKTtcblxuLyoqXG4gKiBAZmlsZSBmdWxsc2NyZWVuLXRvZ2dsZS5qc1xuICovXG5cbi8qKlxuICogVG9nZ2xlIGZ1bGxzY3JlZW4gdmlkZW9cbiAqXG4gKiBAZXh0ZW5kcyBCdXR0b25cbiAqL1xuXG52YXIgRnVsbHNjcmVlblRvZ2dsZSA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKEZ1bGxzY3JlZW5Ub2dnbGUsIF9CdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gRnVsbHNjcmVlblRvZ2dsZShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBGdWxsc2NyZWVuVG9nZ2xlKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnZnVsbHNjcmVlbmNoYW5nZScsIF90aGlzLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UpO1xuXG4gICAgaWYgKGRvY3VtZW50W0Z1bGxzY3JlZW5BcGkuZnVsbHNjcmVlbkVuYWJsZWRdID09PSBmYWxzZSkge1xuICAgICAgX3RoaXMuZGlzYWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWZ1bGxzY3JlZW4tY29udHJvbCAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGZ1bGxzY3JlZW5jaGFuZ2Ugb24gdGhlIHBsYXllciBhbmQgY2hhbmdlIGNvbnRyb2wgdGV4dCBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZX0gZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgKi9cblxuXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgdGhpcy5jb250cm9sVGV4dCgnTm9uLUZ1bGxzY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250cm9sVGV4dCgnRnVsbHNjcmVlbicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBGdWxsc2NyZWVuVG9nZ2xlYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgRnVsbHNjcmVlblRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGlmICghdGhpcy5wbGF5ZXJfLmlzRnVsbHNjcmVlbigpKSB7XG4gICAgICB0aGlzLnBsYXllcl8ucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBGdWxsc2NyZWVuVG9nZ2xlO1xufShCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEZ1bGxzY3JlZW5Ub2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdGdWxsc2NyZWVuJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdGdWxsc2NyZWVuVG9nZ2xlJywgRnVsbHNjcmVlblRvZ2dsZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgdm9sdW1lIGNvbnRyb2wgaXMgc3VwcG9ydGVkIGFuZCBpZiBpdCBpc24ndCBoaWRlIHRoZVxuICogYENvbXBvbmVudGAgdGhhdCB3YXMgcGFzc2VkICB1c2luZyB0aGUgYHZqcy1oaWRkZW5gIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBzZWxmXG4gKiAgICAgICAgVGhlIGNvbXBvbmVudCB0aGF0IHNob3VsZCBiZSBoaWRkZW4gaWYgdm9sdW1lIGlzIHVuc3VwcG9ydGVkXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICogICAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSBwbGF5ZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY2hlY2tWb2x1bWVTdXBwb3J0ID0gZnVuY3Rpb24gY2hlY2tWb2x1bWVTdXBwb3J0KHNlbGYsIHBsYXllcikge1xuICAvLyBoaWRlIHZvbHVtZSBjb250cm9scyB3aGVuIHRoZXkncmUgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCB0ZWNoXG4gIGlmIChwbGF5ZXIudGVjaF8gJiYgIXBsYXllci50ZWNoXy5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wpIHtcbiAgICBzZWxmLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gIH1cblxuICBzZWxmLm9uKHBsYXllciwgJ2xvYWRzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBsYXllci50ZWNoXy5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wpIHtcbiAgICAgIHNlbGYuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBmaWxlIHZvbHVtZS1sZXZlbC5qc1xuICovXG5cbi8qKlxuICogU2hvd3Mgdm9sdW1lIGxldmVsXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFZvbHVtZUxldmVsID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVm9sdW1lTGV2ZWwsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFZvbHVtZUxldmVsKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZvbHVtZUxldmVsKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBWb2x1bWVMZXZlbC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1sZXZlbCcsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj48L3NwYW4+J1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBWb2x1bWVMZXZlbDtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdWb2x1bWVMZXZlbCcsIFZvbHVtZUxldmVsKTtcblxuLyoqXG4gKiBAZmlsZSB2b2x1bWUtYmFyLmpzXG4gKi9cblxuLyoqXG4gKiBUaGUgYmFyIHRoYXQgY29udGFpbnMgdGhlIHZvbHVtZSBsZXZlbCBhbmQgY2FuIGJlIGNsaWNrZWQgb24gdG8gYWRqdXN0IHRoZSBsZXZlbFxuICpcbiAqIEBleHRlbmRzIFNsaWRlclxuICovXG5cbnZhciBWb2x1bWVCYXIgPSBmdW5jdGlvbiAoX1NsaWRlcikge1xuICBpbmhlcml0cyhWb2x1bWVCYXIsIF9TbGlkZXIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVm9sdW1lQmFyKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZvbHVtZUJhcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9TbGlkZXIuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKCdzbGlkZXJhY3RpdmUnLCBfdGhpcy51cGRhdGVMYXN0Vm9sdW1lXyk7XG4gICAgX3RoaXMub24ocGxheWVyLCAndm9sdW1lY2hhbmdlJywgX3RoaXMudXBkYXRlQVJJQUF0dHJpYnV0ZXMpO1xuICAgIHBsYXllci5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMudXBkYXRlQVJJQUF0dHJpYnV0ZXMoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgcmV0dXJuIF9TbGlkZXIucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtYmFyIHZqcy1zbGlkZXItYmFyJ1xuICAgIH0sIHtcbiAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5sb2NhbGl6ZSgnVm9sdW1lIExldmVsJyksXG4gICAgICAnYXJpYS1saXZlJzogJ3BvbGl0ZSdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIGRvd24gb24gdm9sdW1lIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIGlmICghaXNTaW5nbGVMZWZ0Q2xpY2soZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX1NsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duLmNhbGwodGhpcywgZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW92ZW1lbnQgZXZlbnRzIG9uIHRoZSB7QGxpbmsgVm9sdW1lTWVudUJ1dHRvbn0uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlbW92ZVxuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKCFpc1NpbmdsZUxlZnRDbGljayhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrTXV0ZWQoKTtcbiAgICB0aGlzLnBsYXllcl8udm9sdW1lKHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpKTtcbiAgfTtcblxuICAvKipcbiAgICogSWYgdGhlIHBsYXllciBpcyBtdXRlZCB1bm11dGUgaXQuXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5jaGVja011dGVkID0gZnVuY3Rpb24gY2hlY2tNdXRlZCgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLm11dGVkKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5tdXRlZChmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgcGVyY2VudCBvZiB2b2x1bWUgbGV2ZWxcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFZvbHVtZSBsZXZlbCBwZXJjZW50IGFzIGEgZGVjaW1hbCBudW1iZXIuXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5nZXRQZXJjZW50ID0gZnVuY3Rpb24gZ2V0UGVyY2VudCgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLm11dGVkKCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJfLnZvbHVtZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmNyZWFzZSB2b2x1bWUgbGV2ZWwgZm9yIGtleWJvYXJkIHVzZXJzXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5zdGVwRm9yd2FyZCA9IGZ1bmN0aW9uIHN0ZXBGb3J3YXJkKCkge1xuICAgIHRoaXMuY2hlY2tNdXRlZCgpO1xuICAgIHRoaXMucGxheWVyXy52b2x1bWUodGhpcy5wbGF5ZXJfLnZvbHVtZSgpICsgMC4xKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVjcmVhc2Ugdm9sdW1lIGxldmVsIGZvciBrZXlib2FyZCB1c2Vyc1xuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUuc3RlcEJhY2sgPSBmdW5jdGlvbiBzdGVwQmFjaygpIHtcbiAgICB0aGlzLmNoZWNrTXV0ZWQoKTtcbiAgICB0aGlzLnBsYXllcl8udm9sdW1lKHRoaXMucGxheWVyXy52b2x1bWUoKSAtIDAuMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBBUklBIGFjY2Vzc2liaWxpdHkgYXR0cmlidXRlc1xuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYHZvbHVtZWNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciN2b2x1bWVjaGFuZ2VcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gdXBkYXRlQVJJQUF0dHJpYnV0ZXMoZXZlbnQpIHtcbiAgICB2YXIgYXJpYVZhbHVlID0gdGhpcy5wbGF5ZXJfLm11dGVkKCkgPyAwIDogdGhpcy52b2x1bWVBc1BlcmNlbnRhZ2VfKCk7XG5cbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCBhcmlhVmFsdWUpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZXRleHQnLCBhcmlhVmFsdWUgKyAnJScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBwbGF5ZXIgdm9sdW1lIGFzIGEgcGVyY2VudGFnZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUudm9sdW1lQXNQZXJjZW50YWdlXyA9IGZ1bmN0aW9uIHZvbHVtZUFzUGVyY2VudGFnZV8oKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5wbGF5ZXJfLnZvbHVtZSgpICogMTAwKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgVm9sdW1lQmFyLCBzdG9yZSB0aGUgdm9sdW1lIGFuZCBsaXN0ZW4gZm9yXG4gICAqIHRoZSBlbmQgb2YgdGhlIGRyYWcuIFdoZW4gdGhlIGRyYWcgZW5kcywgaWYgdGhlIHZvbHVtZSB3YXMgc2V0IHRvIHplcm8sXG4gICAqIHNldCBsYXN0Vm9sdW1lIHRvIHRoZSBzdG9yZWQgdm9sdW1lLlxuICAgKlxuICAgKiBAbGlzdGVucyBzbGlkZXJhY3RpdmVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLnVwZGF0ZUxhc3RWb2x1bWVfID0gZnVuY3Rpb24gdXBkYXRlTGFzdFZvbHVtZV8oKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgdm9sdW1lQmVmb3JlRHJhZyA9IHRoaXMucGxheWVyXy52b2x1bWUoKTtcblxuICAgIHRoaXMub25lKCdzbGlkZXJpbmFjdGl2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpczIucGxheWVyXy52b2x1bWUoKSA9PT0gMCkge1xuICAgICAgICBfdGhpczIucGxheWVyXy5sYXN0Vm9sdW1lXyh2b2x1bWVCZWZvcmVEcmFnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lQmFyO1xufShTbGlkZXIpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIGBWb2x1bWVCYXJgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Wb2x1bWVCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWyd2b2x1bWVMZXZlbCddLFxuICBiYXJOYW1lOiAndm9sdW1lTGV2ZWwnXG59O1xuXG4vKipcbiAqIENhbGwgdGhlIHVwZGF0ZSBldmVudCBmb3IgdGhpcyBTbGlkZXIgd2hlbiB0aGlzIGV2ZW50IGhhcHBlbnMgb24gdGhlIHBsYXllci5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5Wb2x1bWVCYXIucHJvdG90eXBlLnBsYXllckV2ZW50ID0gJ3ZvbHVtZWNoYW5nZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lQmFyJywgVm9sdW1lQmFyKTtcblxuLyoqXG4gKiBAZmlsZSB2b2x1bWUtY29udHJvbC5qc1xuICovXG5cbi8qKlxuICogVGhlIGNvbXBvbmVudCBmb3IgY29udHJvbGxpbmcgdGhlIHZvbHVtZSBsZXZlbFxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBWb2x1bWVDb250cm9sID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVm9sdW1lQ29udHJvbCwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBWb2x1bWVDb250cm9sKHBsYXllcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVDb250cm9sKTtcblxuICAgIG9wdGlvbnMudmVydGljYWwgPSBvcHRpb25zLnZlcnRpY2FsIHx8IGZhbHNlO1xuXG4gICAgLy8gUGFzcyB0aGUgdmVydGljYWwgb3B0aW9uIGRvd24gdG8gdGhlIFZvbHVtZUJhciBpZlxuICAgIC8vIHRoZSBWb2x1bWVCYXIgaXMgdHVybmVkIG9uLlxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy52b2x1bWVCYXIgPT09ICd1bmRlZmluZWQnIHx8IGlzUGxhaW4ob3B0aW9ucy52b2x1bWVCYXIpKSB7XG4gICAgICBvcHRpb25zLnZvbHVtZUJhciA9IG9wdGlvbnMudm9sdW1lQmFyIHx8IHt9O1xuICAgICAgb3B0aW9ucy52b2x1bWVCYXIudmVydGljYWwgPSBvcHRpb25zLnZlcnRpY2FsO1xuICAgIH1cblxuICAgIC8vIGhpZGUgdGhpcyBjb250cm9sIGlmIHZvbHVtZSBzdXBwb3J0IGlzIG1pc3NpbmdcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIGNoZWNrVm9sdW1lU3VwcG9ydChfdGhpcywgcGxheWVyKTtcblxuICAgIF90aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlTW92ZSA9IHRocm90dGxlKGJpbmQoX3RoaXMsIF90aGlzLmhhbmRsZU1vdXNlTW92ZSksIDI1KTtcblxuICAgIF90aGlzLm9uKCdtb3VzZWRvd24nLCBfdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIF90aGlzLm9uKCd0b3VjaHN0YXJ0JywgX3RoaXMuaGFuZGxlTW91c2VEb3duKTtcblxuICAgIC8vIHdoaWxlIHRoZSBzbGlkZXIgaXMgYWN0aXZlICh0aGUgbW91c2UgaGFzIGJlZW4gcHJlc3NlZCBkb3duIGFuZFxuICAgIC8vIGlzIGRyYWdnaW5nKSBvciBpbiBmb2N1cyB3ZSBkbyBub3Qgd2FudCB0byBoaWRlIHRoZSBWb2x1bWVCYXJcbiAgICBfdGhpcy5vbihfdGhpcy52b2x1bWVCYXIsIFsnZm9jdXMnLCAnc2xpZGVyYWN0aXZlJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnZvbHVtZUJhci5hZGRDbGFzcygndmpzLXNsaWRlci1hY3RpdmUnKTtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICAgICAgX3RoaXMudHJpZ2dlcignc2xpZGVyYWN0aXZlJyk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5vbihfdGhpcy52b2x1bWVCYXIsIFsnYmx1cicsICdzbGlkZXJpbmFjdGl2ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy52b2x1bWVCYXIucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gICAgICBfdGhpcy5yZW1vdmVDbGFzcygndmpzLXNsaWRlci1hY3RpdmUnKTtcbiAgICAgIF90aGlzLnRyaWdnZXIoJ3NsaWRlcmluYWN0aXZlJyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVm9sdW1lQ29udHJvbC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICB2YXIgb3JpZW50YXRpb25DbGFzcyA9ICd2anMtdm9sdW1lLWhvcml6b250YWwnO1xuXG4gICAgaWYgKHRoaXMub3B0aW9uc18udmVydGljYWwpIHtcbiAgICAgIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS12ZXJ0aWNhbCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtY29udHJvbCB2anMtY29udHJvbCAnICsgb3JpZW50YXRpb25DbGFzc1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50cyBvbiB0aGUgYFZvbHVtZUNvbnRyb2xgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqIEBsaXN0ZW5zIHRvdWNoc3RhcnRcbiAgICovXG5cblxuICBWb2x1bWVDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICB2YXIgZG9jID0gdGhpcy5lbF8ub3duZXJEb2N1bWVudDtcblxuICAgIHRoaXMub24oZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub24oZG9jLCAndG91Y2htb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub24oZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vbihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudHMgb24gdGhlIGBWb2x1bWVDb250cm9sYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRvdWNoZW5kXG4gICAqIEBsaXN0ZW5zIG1vdXNldXBcbiAgICovXG5cblxuICBWb2x1bWVDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnRzIG9uIHRoZSBgVm9sdW1lQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICogQGxpc3RlbnMgdG91Y2hzdGFydFxuICAgKi9cblxuXG4gIFZvbHVtZUNvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgIHRoaXMudm9sdW1lQmFyLmhhbmRsZU1vdXNlTW92ZShldmVudCk7XG4gIH07XG5cbiAgcmV0dXJuIFZvbHVtZUNvbnRyb2w7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYFZvbHVtZUNvbnRyb2xgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Wb2x1bWVDb250cm9sLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFsndm9sdW1lQmFyJ11cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lQ29udHJvbCcsIFZvbHVtZUNvbnRyb2wpO1xuXG4vKipcbiAqIENoZWNrIGlmIG11dGluZyB2b2x1bWUgaXMgc3VwcG9ydGVkIGFuZCBpZiBpdCBpc24ndCBoaWRlIHRoZSBtdXRlIHRvZ2dsZVxuICogYnV0dG9uLlxuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBzZWxmXG4gKiAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIG11dGUgdG9nZ2xlIGJ1dHRvblxuICpcbiAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAqICAgICAgICBBIHJlZmVyZW5jZSB0byB0aGUgcGxheWVyXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGNoZWNrTXV0ZVN1cHBvcnQgPSBmdW5jdGlvbiBjaGVja011dGVTdXBwb3J0KHNlbGYsIHBsYXllcikge1xuICAvLyBoaWRlIG11dGUgdG9nZ2xlIGJ1dHRvbiBpZiBpdCdzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgdGVjaFxuICBpZiAocGxheWVyLnRlY2hfICYmICFwbGF5ZXIudGVjaF8uZmVhdHVyZXNNdXRlQ29udHJvbCkge1xuICAgIHNlbGYuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgfVxuXG4gIHNlbGYub24ocGxheWVyLCAnbG9hZHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGxheWVyLnRlY2hfLmZlYXR1cmVzTXV0ZUNvbnRyb2wpIHtcbiAgICAgIHNlbGYuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBmaWxlIG11dGUtdG9nZ2xlLmpzXG4gKi9cblxuLyoqXG4gKiBBIGJ1dHRvbiBjb21wb25lbnQgZm9yIG11dGluZyB0aGUgYXVkaW8uXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKi9cblxudmFyIE11dGVUb2dnbGUgPSBmdW5jdGlvbiAoX0J1dHRvbikge1xuICBpbmhlcml0cyhNdXRlVG9nZ2xlLCBfQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIE11dGVUb2dnbGUocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTXV0ZVRvZ2dsZSk7XG5cbiAgICAvLyBoaWRlIHRoaXMgY29udHJvbCBpZiB2b2x1bWUgc3VwcG9ydCBpcyBtaXNzaW5nXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBjaGVja011dGVTdXBwb3J0KF90aGlzLCBwbGF5ZXIpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCBbJ2xvYWRzdGFydCcsICd2b2x1bWVjaGFuZ2UnXSwgX3RoaXMudXBkYXRlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIE11dGVUb2dnbGUucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLW11dGUtY29udHJvbCAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYE11dGVUb2dnbGVgIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHZvbCA9IHRoaXMucGxheWVyXy52b2x1bWUoKTtcbiAgICB2YXIgbGFzdFZvbHVtZSA9IHRoaXMucGxheWVyXy5sYXN0Vm9sdW1lXygpO1xuXG4gICAgaWYgKHZvbCA9PT0gMCkge1xuICAgICAgdmFyIHZvbHVtZVRvU2V0ID0gbGFzdFZvbHVtZSA8IDAuMSA/IDAuMSA6IGxhc3RWb2x1bWU7XG5cbiAgICAgIHRoaXMucGxheWVyXy52b2x1bWUodm9sdW1lVG9TZXQpO1xuICAgICAgdGhpcy5wbGF5ZXJfLm11dGVkKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLm11dGVkKHRoaXMucGxheWVyXy5tdXRlZCgpID8gZmFsc2UgOiB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYE11dGVUb2dnbGVgIGJ1dHRvbiBiYXNlZCBvbiB0aGUgc3RhdGUgb2YgYHZvbHVtZWAgYW5kIGBtdXRlZGBcbiAgICogb24gdGhlIHBsYXllci5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBQbGF5ZXIjbG9hZHN0YXJ0fSBldmVudCBpZiB0aGlzIGZ1bmN0aW9uIHdhcyBjYWxsZWRcbiAgICogICAgICAgIHRocm91Z2ggYW4gZXZlbnQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNsb2Fkc3RhcnRcbiAgICogQGxpc3RlbnMgUGxheWVyI3ZvbHVtZWNoYW5nZVxuICAgKi9cblxuXG4gIE11dGVUb2dnbGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIHRoaXMudXBkYXRlSWNvbl8oKTtcbiAgICB0aGlzLnVwZGF0ZUNvbnRyb2xUZXh0XygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGBNdXRlVG9nZ2xlYCBpY29uLlxuICAgKlxuICAgKiBQb3NzaWJsZSBzdGF0ZXMgKGdpdmVuIGBsZXZlbGAgdmFyaWFibGUgYmVsb3cpOlxuICAgKiAtIDA6IGNyb3NzZWQgb3V0XG4gICAqIC0gMTogemVybyBiYXJzIG9mIHZvbHVtZVxuICAgKiAtIDI6IG9uZSBiYXIgb2Ygdm9sdW1lXG4gICAqIC0gMzogdHdvIGJhcnMgb2Ygdm9sdW1lXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUudXBkYXRlSWNvbl8gPSBmdW5jdGlvbiB1cGRhdGVJY29uXygpIHtcbiAgICB2YXIgdm9sID0gdGhpcy5wbGF5ZXJfLnZvbHVtZSgpO1xuICAgIHZhciBsZXZlbCA9IDM7XG5cbiAgICAvLyBpbiBpT1Mgd2hlbiBhIHBsYXllciBpcyBsb2FkZWQgd2l0aCBtdXRlZCBhdHRyaWJ1dGVcbiAgICAvLyBhbmQgdm9sdW1lIGlzIGNoYW5nZWQgd2l0aCBhIG5hdGl2ZSBtdXRlIGJ1dHRvblxuICAgIC8vIHdlIHdhbnQgdG8gbWFrZSBzdXJlIG11dGVkIHN0YXRlIGlzIHVwZGF0ZWRcbiAgICBpZiAoSVNfSU9TKSB7XG4gICAgICB0aGlzLnBsYXllcl8ubXV0ZWQodGhpcy5wbGF5ZXJfLnRlY2hfLmVsXy5tdXRlZCk7XG4gICAgfVxuXG4gICAgaWYgKHZvbCA9PT0gMCB8fCB0aGlzLnBsYXllcl8ubXV0ZWQoKSkge1xuICAgICAgbGV2ZWwgPSAwO1xuICAgIH0gZWxzZSBpZiAodm9sIDwgMC4zMykge1xuICAgICAgbGV2ZWwgPSAxO1xuICAgIH0gZWxzZSBpZiAodm9sIDwgMC42Nykge1xuICAgICAgbGV2ZWwgPSAyO1xuICAgIH1cblxuICAgIC8vIFRPRE8gaW1wcm92ZSBtdXRlZCBpY29uIGNsYXNzZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbF8sICd2anMtdm9sLScgKyBpKTtcbiAgICB9XG4gICAgYWRkQ2xhc3ModGhpcy5lbF8sICd2anMtdm9sLScgKyBsZXZlbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIElmIGBtdXRlZGAgaGFzIGNoYW5nZWQgb24gdGhlIHBsYXllciwgdXBkYXRlIHRoZSBjb250cm9sIHRleHRcbiAgICogKGB0aXRsZWAgYXR0cmlidXRlIG9uIGB2anMtbXV0ZS1jb250cm9sYCBlbGVtZW50IGFuZCBjb250ZW50IG9mXG4gICAqIGB2anMtY29udHJvbC10ZXh0YCBlbGVtZW50KS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS51cGRhdGVDb250cm9sVGV4dF8gPSBmdW5jdGlvbiB1cGRhdGVDb250cm9sVGV4dF8oKSB7XG4gICAgdmFyIHNvdW5kT2ZmID0gdGhpcy5wbGF5ZXJfLm11dGVkKCkgfHwgdGhpcy5wbGF5ZXJfLnZvbHVtZSgpID09PSAwO1xuICAgIHZhciB0ZXh0ID0gc291bmRPZmYgPyAnVW5tdXRlJyA6ICdNdXRlJztcblxuICAgIGlmICh0aGlzLmNvbnRyb2xUZXh0KCkgIT09IHRleHQpIHtcbiAgICAgIHRoaXMuY29udHJvbFRleHQodGV4dCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBNdXRlVG9nZ2xlO1xufShCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYE11dGVUb2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbk11dGVUb2dnbGUucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdNdXRlJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNdXRlVG9nZ2xlJywgTXV0ZVRvZ2dsZSk7XG5cbi8qKlxuICogQGZpbGUgdm9sdW1lLWNvbnRyb2wuanNcbiAqL1xuXG4vKipcbiAqIEEgQ29tcG9uZW50IHRvIGNvbnRhaW4gdGhlIE11dGVUb2dnbGUgYW5kIFZvbHVtZUNvbnRyb2wgc28gdGhhdFxuICogdGhleSBjYW4gd29yayB0b2dldGhlci5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVm9sdW1lUGFuZWwgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhWb2x1bWVQYW5lbCwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBWb2x1bWVQYW5lbChwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVm9sdW1lUGFuZWwpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmlubGluZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMuaW5saW5lID0gb3B0aW9ucy5pbmxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuaW5saW5lID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBwYXNzIHRoZSBpbmxpbmUgb3B0aW9uIGRvd24gdG8gdGhlIFZvbHVtZUNvbnRyb2wgYXMgdmVydGljYWwgaWZcbiAgICAvLyB0aGUgVm9sdW1lQ29udHJvbCBpcyBvbi5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudm9sdW1lQ29udHJvbCA9PT0gJ3VuZGVmaW5lZCcgfHwgaXNQbGFpbihvcHRpb25zLnZvbHVtZUNvbnRyb2wpKSB7XG4gICAgICBvcHRpb25zLnZvbHVtZUNvbnRyb2wgPSBvcHRpb25zLnZvbHVtZUNvbnRyb2wgfHwge307XG4gICAgICBvcHRpb25zLnZvbHVtZUNvbnRyb2wudmVydGljYWwgPSAhb3B0aW9ucy5pbmxpbmU7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsIFsnbG9hZHN0YXJ0J10sIF90aGlzLnZvbHVtZVBhbmVsU3RhdGVfKTtcblxuICAgIC8vIHdoaWxlIHRoZSBzbGlkZXIgaXMgYWN0aXZlICh0aGUgbW91c2UgaGFzIGJlZW4gcHJlc3NlZCBkb3duIGFuZFxuICAgIC8vIGlzIGRyYWdnaW5nKSB3ZSBkbyBub3Qgd2FudCB0byBoaWRlIHRoZSBWb2x1bWVCYXJcbiAgICBfdGhpcy5vbihfdGhpcy52b2x1bWVDb250cm9sLCBbJ3NsaWRlcmFjdGl2ZSddLCBfdGhpcy5zbGlkZXJBY3RpdmVfKTtcblxuICAgIF90aGlzLm9uKF90aGlzLnZvbHVtZUNvbnRyb2wsIFsnc2xpZGVyaW5hY3RpdmUnXSwgX3RoaXMuc2xpZGVySW5hY3RpdmVfKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHZqcy1zbGlkZXItYWN0aXZlIGNsYXNzIHRvIHRoZSBWb2x1bWVQYW5lbFxuICAgKlxuICAgKiBAbGlzdGVucyBWb2x1bWVDb250cm9sI3NsaWRlcmFjdGl2ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFZvbHVtZVBhbmVsLnByb3RvdHlwZS5zbGlkZXJBY3RpdmVfID0gZnVuY3Rpb24gc2xpZGVyQWN0aXZlXygpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHZqcy1zbGlkZXItYWN0aXZlIGNsYXNzIHRvIHRoZSBWb2x1bWVQYW5lbFxuICAgKlxuICAgKiBAbGlzdGVucyBWb2x1bWVDb250cm9sI3NsaWRlcmluYWN0aXZlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVm9sdW1lUGFuZWwucHJvdG90eXBlLnNsaWRlckluYWN0aXZlXyA9IGZ1bmN0aW9uIHNsaWRlckluYWN0aXZlXygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIHZqcy1oaWRkZW4gb3IgdmpzLW11dGUtdG9nZ2xlLW9ubHkgdG8gdGhlIFZvbHVtZVBhbmVsXG4gICAqIGRlcGVuZGluZyBvbiBNdXRlVG9nZ2xlIGFuZCBWb2x1bWVDb250cm9sIHN0YXRlXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNsb2Fkc3RhcnRcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBWb2x1bWVQYW5lbC5wcm90b3R5cGUudm9sdW1lUGFuZWxTdGF0ZV8gPSBmdW5jdGlvbiB2b2x1bWVQYW5lbFN0YXRlXygpIHtcbiAgICAvLyBoaWRlIHZvbHVtZSBwYW5lbCBpZiBuZWl0aGVyIHZvbHVtZSBjb250cm9sIG9yIG11dGUgdG9nZ2xlXG4gICAgLy8gYXJlIGRpc3BsYXllZFxuICAgIGlmICh0aGlzLnZvbHVtZUNvbnRyb2wuaGFzQ2xhc3MoJ3Zqcy1oaWRkZW4nKSAmJiB0aGlzLm11dGVUb2dnbGUuaGFzQ2xhc3MoJ3Zqcy1oaWRkZW4nKSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cblxuICAgIC8vIGlmIG9ubHkgbXV0ZSB0b2dnbGUgaXMgdmlzaWJsZSB3ZSBkb24ndCB3YW50XG4gICAgLy8gdm9sdW1lIHBhbmVsIGV4cGFuZGluZyB3aGVuIGhvdmVyZWQgb3IgYWN0aXZlXG4gICAgaWYgKHRoaXMudm9sdW1lQ29udHJvbC5oYXNDbGFzcygndmpzLWhpZGRlbicpICYmICF0aGlzLm11dGVUb2dnbGUuaGFzQ2xhc3MoJ3Zqcy1oaWRkZW4nKSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLW11dGUtdG9nZ2xlLW9ubHknKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVm9sdW1lUGFuZWwucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS1wYW5lbC1ob3Jpem9udGFsJztcblxuICAgIGlmICghdGhpcy5vcHRpb25zXy5pbmxpbmUpIHtcbiAgICAgIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS1wYW5lbC12ZXJ0aWNhbCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtcGFuZWwgdmpzLWNvbnRyb2wgJyArIG9yaWVudGF0aW9uQ2xhc3NcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lUGFuZWw7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYFZvbHVtZUNvbnRyb2xgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Wb2x1bWVQYW5lbC5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ211dGVUb2dnbGUnLCAndm9sdW1lQ29udHJvbCddXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZVBhbmVsJywgVm9sdW1lUGFuZWwpO1xuXG4vKipcbiAqIEBmaWxlIG1lbnUuanNcbiAqL1xuXG4vKipcbiAqIFRoZSBNZW51IGNvbXBvbmVudCBpcyB1c2VkIHRvIGJ1aWxkIHBvcHVwIG1lbnVzLCBpbmNsdWRpbmcgc3VidGl0bGUgYW5kXG4gKiBjYXB0aW9ucyBzZWxlY3Rpb24gbWVudXMuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIE1lbnUgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhNZW51LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIHRoZSBwbGF5ZXIgdGhhdCB0aGlzIGNvbXBvbmVudCBzaG91bGQgYXR0YWNoIHRvXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gTWVudShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNZW51KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIF90aGlzLm1lbnVCdXR0b25fID0gb3B0aW9ucy5tZW51QnV0dG9uO1xuICAgIH1cblxuICAgIF90aGlzLmZvY3VzZWRDaGlsZF8gPSAtMTtcblxuICAgIF90aGlzLm9uKCdrZXlkb3duJywgX3RoaXMuaGFuZGxlS2V5UHJlc3MpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB7QGxpbmsgTWVudUl0ZW19IHRvIHRoZSBtZW51LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGNvbXBvbmVudFxuICAgKiAgICAgICAgVGhlIG5hbWUgb3IgaW5zdGFuY2Ugb2YgdGhlIGBNZW51SXRlbWAgdG8gYWRkLlxuICAgKlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLmFkZEl0ZW0gPSBmdW5jdGlvbiBhZGRJdGVtKGNvbXBvbmVudCkge1xuICAgIHRoaXMuYWRkQ2hpbGQoY29tcG9uZW50KTtcbiAgICBjb21wb25lbnQub24oJ2NsaWNrJywgYmluZCh0aGlzLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIC8vIFVucHJlc3MgdGhlIGFzc29jaWF0ZWQgTWVudUJ1dHRvbiwgYW5kIG1vdmUgZm9jdXMgYmFjayB0byBpdFxuICAgICAgaWYgKHRoaXMubWVudUJ1dHRvbl8pIHtcbiAgICAgICAgdGhpcy5tZW51QnV0dG9uXy51bnByZXNzQnV0dG9uKCk7XG5cbiAgICAgICAgLy8gZG9uJ3QgZm9jdXMgbWVudSBidXR0b24gaWYgaXRlbSBpcyBhIGNhcHRpb24gc2V0dGluZ3MgaXRlbVxuICAgICAgICAvLyBiZWNhdXNlIGZvY3VzIHdpbGwgbW92ZSBlbHNld2hlcmVcbiAgICAgICAgaWYgKGNvbXBvbmVudC5uYW1lKCkgIT09ICdDYXB0aW9uU2V0dGluZ3NNZW51SXRlbScpIHtcbiAgICAgICAgICB0aGlzLm1lbnVCdXR0b25fLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYE1lbnVgcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICB0aGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICB2YXIgY29udGVudEVsVHlwZSA9IHRoaXMub3B0aW9uc18uY29udGVudEVsVHlwZSB8fCAndWwnO1xuXG4gICAgdGhpcy5jb250ZW50RWxfID0gY3JlYXRlRWwoY29udGVudEVsVHlwZSwge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUtY29udGVudCdcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbWVudScpO1xuXG4gICAgdmFyIGVsID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgYXBwZW5kOiB0aGlzLmNvbnRlbnRFbF8sXG4gICAgICBjbGFzc05hbWU6ICd2anMtbWVudSdcbiAgICB9KTtcblxuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsXyk7XG5cbiAgICAvLyBQcmV2ZW50IGNsaWNrcyBmcm9tIGJ1YmJsaW5nIHVwLiBOZWVkZWQgZm9yIE1lbnUgQnV0dG9ucyxcbiAgICAvLyB3aGVyZSBhIGNsaWNrIG9uIHRoZSBwYXJlbnQgaXMgc2lnbmlmaWNhbnRcbiAgICBvbihlbCwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgTWVudS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5jb250ZW50RWxfID0gbnVsbDtcblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgYGtleWRvd25gIGV2ZW50IG9uIHRoaXMgbWVudS4gVGhpcyBsaXN0ZW5lciBpcyBhZGRlZCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBBIGBrZXlkb3duYCBldmVudCB0aGF0IGhhcHBlbmVkIG9uIHRoZSBtZW51LlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuICAgIC8vIExlZnQgYW5kIERvd24gQXJyb3dzXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzNyB8fCBldmVudC53aGljaCA9PT0gNDApIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnN0ZXBGb3J3YXJkKCk7XG5cbiAgICAgIC8vIFVwIGFuZCBSaWdodCBBcnJvd3NcbiAgICB9IGVsc2UgaWYgKGV2ZW50LndoaWNoID09PSAzOCB8fCBldmVudC53aGljaCA9PT0gMzkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnN0ZXBCYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRvIG5leHQgKGxvd2VyKSBtZW51IGl0ZW0gZm9yIGtleWJvYXJkIHVzZXJzLlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XG4gICAgdmFyIHN0ZXBDaGlsZCA9IDA7XG5cbiAgICBpZiAodGhpcy5mb2N1c2VkQ2hpbGRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0ZXBDaGlsZCA9IHRoaXMuZm9jdXNlZENoaWxkXyArIDE7XG4gICAgfVxuICAgIHRoaXMuZm9jdXMoc3RlcENoaWxkKTtcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSB0byBwcmV2aW91cyAoaGlnaGVyKSBtZW51IGl0ZW0gZm9yIGtleWJvYXJkIHVzZXJzLlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLnN0ZXBCYWNrID0gZnVuY3Rpb24gc3RlcEJhY2soKSB7XG4gICAgdmFyIHN0ZXBDaGlsZCA9IDA7XG5cbiAgICBpZiAodGhpcy5mb2N1c2VkQ2hpbGRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0ZXBDaGlsZCA9IHRoaXMuZm9jdXNlZENoaWxkXyAtIDE7XG4gICAgfVxuICAgIHRoaXMuZm9jdXMoc3RlcENoaWxkKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGZvY3VzIG9uIGEge0BsaW5rIE1lbnVJdGVtfSBpbiB0aGUgYE1lbnVgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtpdGVtPTBdXG4gICAqICAgICAgICBJbmRleCBvZiBjaGlsZCBpdGVtIHNldCBmb2N1cyBvbi5cbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHZhciBpdGVtID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpLnNsaWNlKCk7XG4gICAgdmFyIGhhdmVUaXRsZSA9IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlblswXS5jbGFzc05hbWUgJiYgL3Zqcy1tZW51LXRpdGxlLy50ZXN0KGNoaWxkcmVuWzBdLmNsYXNzTmFtZSk7XG5cbiAgICBpZiAoaGF2ZVRpdGxlKSB7XG4gICAgICBjaGlsZHJlbi5zaGlmdCgpO1xuICAgIH1cblxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoaXRlbSA8IDApIHtcbiAgICAgICAgaXRlbSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0gPj0gY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGl0ZW0gPSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZvY3VzZWRDaGlsZF8gPSBpdGVtO1xuXG4gICAgICBjaGlsZHJlbltpdGVtXS5lbF8uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1lbnU7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVudScsIE1lbnUpO1xuXG4vKipcbiAqIEBmaWxlIG1lbnUtYnV0dG9uLmpzXG4gKi9cblxuLyoqXG4gKiBBIGBNZW51QnV0dG9uYCBjbGFzcyBmb3IgYW55IHBvcHVwIHtAbGluayBNZW51fS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTWVudUJ1dHRvbiA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1lbnVCdXR0b24sIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTWVudUJ1dHRvbihwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudUJ1dHRvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm1lbnVCdXR0b25fID0gbmV3IEJ1dHRvbihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgX3RoaXMubWVudUJ1dHRvbl8uY29udHJvbFRleHQoX3RoaXMuY29udHJvbFRleHRfKTtcbiAgICBfdGhpcy5tZW51QnV0dG9uXy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgJ3RydWUnKTtcblxuICAgIC8vIEFkZCBidWlsZENTU0NsYXNzIHZhbHVlcyB0byB0aGUgYnV0dG9uLCBub3QgdGhlIHdyYXBwZXJcbiAgICB2YXIgYnV0dG9uQ2xhc3MgPSBCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MoKTtcblxuICAgIF90aGlzLm1lbnVCdXR0b25fLmVsXy5jbGFzc05hbWUgPSBfdGhpcy5idWlsZENTU0NsYXNzKCkgKyAnICcgKyBidXR0b25DbGFzcztcbiAgICBfdGhpcy5tZW51QnV0dG9uXy5yZW1vdmVDbGFzcygndmpzLWNvbnRyb2wnKTtcblxuICAgIF90aGlzLmFkZENoaWxkKF90aGlzLm1lbnVCdXR0b25fKTtcblxuICAgIF90aGlzLnVwZGF0ZSgpO1xuXG4gICAgX3RoaXMuZW5hYmxlZF8gPSB0cnVlO1xuXG4gICAgX3RoaXMub24oX3RoaXMubWVudUJ1dHRvbl8sICd0YXAnLCBfdGhpcy5oYW5kbGVDbGljayk7XG4gICAgX3RoaXMub24oX3RoaXMubWVudUJ1dHRvbl8sICdjbGljaycsIF90aGlzLmhhbmRsZUNsaWNrKTtcbiAgICBfdGhpcy5vbihfdGhpcy5tZW51QnV0dG9uXywgJ2ZvY3VzJywgX3RoaXMuaGFuZGxlRm9jdXMpO1xuICAgIF90aGlzLm9uKF90aGlzLm1lbnVCdXR0b25fLCAnYmx1cicsIF90aGlzLmhhbmRsZUJsdXIpO1xuXG4gICAgX3RoaXMub24oJ2tleWRvd24nLCBfdGhpcy5oYW5kbGVTdWJtZW51S2V5UHJlc3MpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIG1lbnUgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgaXRzIGl0ZW1zLlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgbWVudSA9IHRoaXMuY3JlYXRlTWVudSgpO1xuXG4gICAgaWYgKHRoaXMubWVudSkge1xuICAgICAgdGhpcy5tZW51LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5tZW51KTtcbiAgICB9XG5cbiAgICB0aGlzLm1lbnUgPSBtZW51O1xuICAgIHRoaXMuYWRkQ2hpbGQobWVudSk7XG5cbiAgICAvKipcbiAgICAgKiBUcmFjayB0aGUgc3RhdGUgb2YgdGhlIG1lbnUgYnV0dG9uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYnV0dG9uUHJlc3NlZF8gPSBmYWxzZTtcbiAgICB0aGlzLm1lbnVCdXR0b25fLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcblxuICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoIDw9IHRoaXMuaGlkZVRocmVzaG9sZF8pIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbWVudSBhbmQgYWRkIGFsbCBpdGVtcyB0byBpdC5cbiAgICpcbiAgICogQHJldHVybiB7TWVudX1cbiAgICogICAgICAgICBUaGUgY29uc3RydWN0ZWQgbWVudVxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmNyZWF0ZU1lbnUgPSBmdW5jdGlvbiBjcmVhdGVNZW51KCkge1xuICAgIHZhciBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXJfLCB7IG1lbnVCdXR0b246IHRoaXMgfSk7XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBtZW51IGlmIHRoZSBudW1iZXIgb2YgaXRlbXMgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoaXMgdGhyZXNob2xkLiBUaGlzIGRlZmF1bHRzXG4gICAgICogdG8gMCBhbmQgd2hlbmV2ZXIgd2UgYWRkIGl0ZW1zIHdoaWNoIGNhbiBiZSBoaWRkZW4gdG8gdGhlIG1lbnUgd2UnbGwgaW5jcmVtZW50IGl0LiBXZSBsaXN0XG4gICAgICogaXQgaGVyZSBiZWNhdXNlIGV2ZXJ5IHRpbWUgd2UgcnVuIGBjcmVhdGVNZW51YCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gPSAwO1xuXG4gICAgLy8gQWRkIGEgdGl0bGUgbGlzdCBpdGVtIHRvIHRoZSB0b3BcbiAgICBpZiAodGhpcy5vcHRpb25zXy50aXRsZSkge1xuICAgICAgdmFyIHRpdGxlID0gY3JlYXRlRWwoJ2xpJywge1xuICAgICAgICBjbGFzc05hbWU6ICd2anMtbWVudS10aXRsZScsXG4gICAgICAgIGlubmVySFRNTDogdG9UaXRsZUNhc2UodGhpcy5vcHRpb25zXy50aXRsZSksXG4gICAgICAgIHRhYkluZGV4OiAtMVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gKz0gMTtcblxuICAgICAgbWVudS5jaGlsZHJlbl8udW5zaGlmdCh0aXRsZSk7XG4gICAgICBwcmVwZW5kVG8odGl0bGUsIG1lbnUuY29udGVudEVsKCkpO1xuICAgIH1cblxuICAgIHRoaXMuaXRlbXMgPSB0aGlzLmNyZWF0ZUl0ZW1zKCk7XG5cbiAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgLy8gQWRkIG1lbnUgaXRlbXMgdG8gdGhlIG1lbnVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtZW51LmFkZEl0ZW0odGhpcy5pdGVtc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbGlzdCBvZiBtZW51IGl0ZW1zLiBTcGVjaWZpYyB0byBlYWNoIHN1YmNsYXNzLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge307XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYE1lbnVCdXR0b25zYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkV3JhcHBlckNTU0NsYXNzKClcbiAgICB9LCB7fSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsbG93IHN1YiBjb21wb25lbnRzIHRvIHN0YWNrIENTUyBjbGFzcyBuYW1lcyBmb3IgdGhlIHdyYXBwZXIgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGNvbnN0cnVjdGVkIHdyYXBwZXIgRE9NIGBjbGFzc05hbWVgXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICB2YXIgbWVudUJ1dHRvbkNsYXNzID0gJ3Zqcy1tZW51LWJ1dHRvbic7XG5cbiAgICAvLyBJZiB0aGUgaW5saW5lIG9wdGlvbiBpcyBwYXNzZWQsIHdlIHdhbnQgdG8gdXNlIGRpZmZlcmVudCBzdHlsZXMgYWx0b2dldGhlci5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5pbmxpbmUgPT09IHRydWUpIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLWlubGluZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLXBvcHVwJztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBGaXggdGhlIENTUyBzbyB0aGF0IHRoaXMgaXNuJ3QgbmVjZXNzYXJ5XG4gICAgdmFyIGJ1dHRvbkNsYXNzID0gQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzKCk7XG5cbiAgICByZXR1cm4gJ3Zqcy1tZW51LWJ1dHRvbiAnICsgbWVudUJ1dHRvbkNsYXNzICsgJyAnICsgYnV0dG9uQ2xhc3MgKyAnICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICB2YXIgbWVudUJ1dHRvbkNsYXNzID0gJ3Zqcy1tZW51LWJ1dHRvbic7XG5cbiAgICAvLyBJZiB0aGUgaW5saW5lIG9wdGlvbiBpcyBwYXNzZWQsIHdlIHdhbnQgdG8gdXNlIGRpZmZlcmVudCBzdHlsZXMgYWx0b2dldGhlci5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5pbmxpbmUgPT09IHRydWUpIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLWlubGluZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLXBvcHVwJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ3Zqcy1tZW51LWJ1dHRvbiAnICsgbWVudUJ1dHRvbkNsYXNzICsgJyAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBsb2NhbGl6ZWQgY29udHJvbCB0ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiA+IE5PVEU6IFRoaXMgd2lsbCBjb21lIGZyb20gdGhlIGludGVybmFsIGBtZW51QnV0dG9uX2AgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0XVxuICAgKiAgICAgICAgQ29udHJvbCB0ZXh0IGZvciBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtlbD10aGlzLm1lbnVCdXR0b25fLmVsKCldXG4gICAqICAgICAgICBFbGVtZW50IHRvIHNldCB0aGUgdGl0bGUgb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAtIFRoZSBjb250cm9sIHRleHQgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHQgPSBmdW5jdGlvbiBjb250cm9sVGV4dCh0ZXh0KSB7XG4gICAgdmFyIGVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLm1lbnVCdXR0b25fLmVsKCk7XG5cbiAgICByZXR1cm4gdGhpcy5tZW51QnV0dG9uXy5jb250cm9sVGV4dCh0ZXh0LCBlbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGNsaWNrIG9uIGEgYE1lbnVCdXR0b25gLlxuICAgKiBTZWUge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVDbGlja30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIC8vIFdoZW4geW91IGNsaWNrIHRoZSBidXR0b24gaXQgYWRkcyBmb2N1cywgd2hpY2ggd2lsbCBzaG93IHRoZSBtZW51LlxuICAgIC8vIFNvIHdlJ2xsIHJlbW92ZSBmb2N1cyB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGJ1dHRvbi4gRm9jdXMgaXMgbmVlZGVkXG4gICAgLy8gZm9yIHRhYiBuYXZpZ2F0aW9uLlxuXG4gICAgdGhpcy5vbmUodGhpcy5tZW51LmNvbnRlbnRFbCgpLCAnbW91c2VsZWF2ZScsIGJpbmQodGhpcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgdGhpcy5lbF8uYmx1cigpO1xuICAgIH0pKTtcbiAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJlc3NCdXR0b24oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZm9jdXMgdG8gdGhlIGFjdHVhbCBidXR0b24sIG5vdCB0byB0aGlzIGVsZW1lbnRcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHRoaXMubWVudUJ1dHRvbl8uZm9jdXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBmb2N1cyBmcm9tIHRoZSBhY3R1YWwgYnV0dG9uLCBub3QgdGhpcyBlbGVtZW50XG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgdGhpcy5tZW51QnV0dG9uXy5ibHVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhIGBNZW51QnV0dG9uYCBnYWlucyBmb2N1cyB2aWEgYSBgZm9jdXNgIGV2ZW50LlxuICAgKiBUdXJucyBvbiBsaXN0ZW5pbmcgZm9yIGBrZXlkb3duYCBldmVudHMuIFdoZW4gdGhleSBoYXBwZW4gaXRcbiAgICogY2FsbHMgYHRoaXMuaGFuZGxlS2V5UHJlc3NgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBmb2N1c2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGZvY3VzXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cygpIHtcbiAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBgTWVudUJ1dHRvbmAgbG9zZXMgZm9jdXMuIFR1cm5zIG9mZiB0aGUgbGlzdGVuZXIgZm9yXG4gICAqIGBrZXlkb3duYCBldmVudHMuIFdoaWNoIFN0b3BzIGB0aGlzLmhhbmRsZUtleVByZXNzYCBmcm9tIGdldHRpbmcgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBibHVyYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgYmx1clxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICAgIG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRhYiwgZXNjYXBlLCBkb3duIGFycm93LCBhbmQgdXAgYXJyb3cga2V5cyBmb3IgYE1lbnVCdXR0b25gLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVLZXlQcmVzc30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBFc2NhcGUgKDI3KSBrZXkgb3IgVGFiICg5KSBrZXkgdW5wcmVzcyB0aGUgJ2J1dHRvbidcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDI3IHx8IGV2ZW50LndoaWNoID09PSA5KSB7XG4gICAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHByZXZlbnREZWZhdWx0IGZvciBUYWIga2V5IC0gd2Ugc3RpbGwgd2FudCB0byBsb3NlIGZvY3VzXG4gICAgICBpZiAoZXZlbnQud2hpY2ggIT09IDkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gU2V0IGZvY3VzIGJhY2sgdG8gdGhlIG1lbnUgYnV0dG9uJ3MgYnV0dG9uXG4gICAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLmZvY3VzKCk7XG4gICAgICB9XG4gICAgICAvLyBVcCAoMzgpIGtleSBvciBEb3duICg0MCkga2V5IHByZXNzIHRoZSAnYnV0dG9uJ1xuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4IHx8IGV2ZW50LndoaWNoID09PSA0MCkge1xuICAgICAgaWYgKCF0aGlzLmJ1dHRvblByZXNzZWRfKSB7XG4gICAgICAgIHRoaXMucHJlc3NCdXR0b24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBrZXlkb3duYCBldmVudCBvbiBhIHN1Yi1tZW51LiBUaGUgbGlzdGVuZXIgZm9yIHRoaXMgaXMgYWRkZWQgaW5cbiAgICogdGhlIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgS2V5IHByZXNzIGV2ZW50XG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVTdWJtZW51S2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVTdWJtZW51S2V5UHJlc3MoZXZlbnQpIHtcblxuICAgIC8vIEVzY2FwZSAoMjcpIGtleSBvciBUYWIgKDkpIGtleSB1bnByZXNzIHRoZSAnYnV0dG9uJ1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMjcgfHwgZXZlbnQud2hpY2ggPT09IDkpIHtcbiAgICAgIGlmICh0aGlzLmJ1dHRvblByZXNzZWRfKSB7XG4gICAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcHJldmVudERlZmF1bHQgZm9yIFRhYiBrZXkgLSB3ZSBzdGlsbCB3YW50IHRvIGxvc2UgZm9jdXNcbiAgICAgIGlmIChldmVudC53aGljaCAhPT0gOSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBTZXQgZm9jdXMgYmFjayB0byB0aGUgbWVudSBidXR0b24ncyBidXR0b25cbiAgICAgICAgdGhpcy5tZW51QnV0dG9uXy5lbF8uZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1dCB0aGUgY3VycmVudCBgTWVudUJ1dHRvbmAgaW50byBhIHByZXNzZWQgc3RhdGUuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUucHJlc3NCdXR0b24gPSBmdW5jdGlvbiBwcmVzc0J1dHRvbigpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkXykge1xuICAgICAgdGhpcy5idXR0b25QcmVzc2VkXyA9IHRydWU7XG4gICAgICB0aGlzLm1lbnUubG9ja1Nob3dpbmcoKTtcbiAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG5cbiAgICAgIC8vIHNldCB0aGUgZm9jdXMgaW50byB0aGUgc3VibWVudSwgZXhjZXB0IG9uIGlPUyB3aGVyZSBpdCBpcyByZXN1bHRpbmcgaW5cbiAgICAgIC8vIHVuZGVzaXJlZCBzY3JvbGxpbmcgYmVoYXZpb3Igd2hlbiB0aGUgcGxheWVyIGlzIGluIGFuIGlmcmFtZVxuICAgICAgaWYgKElTX0lPUyAmJiBpc0luRnJhbWUoKSkge1xuICAgICAgICAvLyBSZXR1cm4gZWFybHkgc28gdGhhdCB0aGUgbWVudSBpc24ndCBmb2N1c2VkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tZW51LmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUYWtlIHRoZSBjdXJyZW50IGBNZW51QnV0dG9uYCBvdXQgb2YgYSBwcmVzc2VkIHN0YXRlLlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLnVucHJlc3NCdXR0b24gPSBmdW5jdGlvbiB1bnByZXNzQnV0dG9uKCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWRfKSB7XG4gICAgICB0aGlzLmJ1dHRvblByZXNzZWRfID0gZmFsc2U7XG4gICAgICB0aGlzLm1lbnUudW5sb2NrU2hvd2luZygpO1xuICAgICAgdGhpcy5tZW51QnV0dG9uXy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSBgTWVudUJ1dHRvbmAuIERvbid0IGFsbG93IGl0IHRvIGJlIGNsaWNrZWQuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG5cbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWRpc2FibGVkJyk7XG5cbiAgICB0aGlzLm1lbnVCdXR0b25fLmRpc2FibGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIHRoZSBgTWVudUJ1dHRvbmAuIEFsbG93IGl0IHRvIGJlIGNsaWNrZWQuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIHRoaXMuZW5hYmxlZF8gPSB0cnVlO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1kaXNhYmxlZCcpO1xuXG4gICAgdGhpcy5tZW51QnV0dG9uXy5lbmFibGUoKTtcbiAgfTtcblxuICByZXR1cm4gTWVudUJ1dHRvbjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZW51QnV0dG9uJywgTWVudUJ1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgdHJhY2stYnV0dG9uLmpzXG4gKi9cblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYnV0dG9ucyB0aGF0IHRvZ2dsZSBzcGVjaWZpYyAgdHJhY2sgdHlwZXMgKGUuZy4gc3VidGl0bGVzKS5cbiAqXG4gKiBAZXh0ZW5kcyBNZW51QnV0dG9uXG4gKi9cblxudmFyIFRyYWNrQnV0dG9uID0gZnVuY3Rpb24gKF9NZW51QnV0dG9uKSB7XG4gIGluaGVyaXRzKFRyYWNrQnV0dG9uLCBfTWVudUJ1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBUcmFja0J1dHRvbihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFja0J1dHRvbik7XG5cbiAgICB2YXIgdHJhY2tzID0gb3B0aW9ucy50cmFja3M7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9NZW51QnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBpZiAoX3RoaXMuaXRlbXMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIF90aGlzLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRyYWNrcykge1xuICAgICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVIYW5kbGVyID0gYmluZChfdGhpcywgX3RoaXMudXBkYXRlKTtcblxuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHVwZGF0ZUhhbmRsZXIpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHVwZGF0ZUhhbmRsZXIpO1xuICAgIF90aGlzLnBsYXllcl8ub24oJ3JlYWR5JywgdXBkYXRlSGFuZGxlcik7XG5cbiAgICBfdGhpcy5wbGF5ZXJfLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gVHJhY2tCdXR0b247XG59KE1lbnVCdXR0b24pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RyYWNrQnV0dG9uJywgVHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIG1lbnUtaXRlbS5qc1xuICovXG5cbi8qKlxuICogVGhlIGNvbXBvbmVudCBmb3IgYSBtZW51IGl0ZW0uIGA8bGk+YFxuICpcbiAqIEBleHRlbmRzIENsaWNrYWJsZUNvbXBvbmVudFxuICovXG5cbnZhciBNZW51SXRlbSA9IGZ1bmN0aW9uIChfQ2xpY2thYmxlQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1lbnVJdGVtLCBfQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNZW51SXRlbSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9DbGlja2FibGVDb21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnNlbGVjdGFibGUgPSBvcHRpb25zLnNlbGVjdGFibGU7XG4gICAgX3RoaXMuaXNTZWxlY3RlZF8gPSBvcHRpb25zLnNlbGVjdGVkIHx8IGZhbHNlO1xuICAgIF90aGlzLm11bHRpU2VsZWN0YWJsZSA9IG9wdGlvbnMubXVsdGlTZWxlY3RhYmxlO1xuXG4gICAgX3RoaXMuc2VsZWN0ZWQoX3RoaXMuaXNTZWxlY3RlZF8pO1xuXG4gICAgaWYgKF90aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgIGlmIChfdGhpcy5tdWx0aVNlbGVjdGFibGUpIHtcbiAgICAgICAgX3RoaXMuZWxfLnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51aXRlbWNoZWNrYm94Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ21lbnVpdGVtcmFkaW8nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuZWxfLnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51aXRlbScpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgTWVudUl0ZW0ncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9bGldXG4gICAqICAgICAgICBFbGVtZW50J3Mgbm9kZSB0eXBlLCBub3QgYWN0dWFsbHkgdXNlZCwgYWx3YXlzIHNldCB0byBgbGlgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzPXt9XVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cnM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBNZW51SXRlbS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCh0eXBlLCBwcm9wcywgYXR0cnMpIHtcbiAgICAvLyBUaGUgY29udHJvbCBpcyB0ZXh0dWFsLCBub3QganVzdCBhbiBpY29uXG4gICAgdGhpcy5ub25JY29uQ29udHJvbCA9IHRydWU7XG5cbiAgICByZXR1cm4gX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnbGknLCBhc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUtaXRlbScsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1tZW51LWl0ZW0tdGV4dFwiPicgKyB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubGFiZWwpICsgJzwvc3Bhbj4nLFxuICAgICAgdGFiSW5kZXg6IC0xXG4gICAgfSwgcHJvcHMpLCBhdHRycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFueSBjbGljayBvbiBhIGBNZW51SXRlbWAgcHV0cyBpdCBpbnRvIHRoZSBzZWxlY3RlZCBzdGF0ZS5cbiAgICogU2VlIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlQ2xpY2t9IGZvciBpbnN0YW5jZXMgd2hlcmUgdGhpcyBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZCh0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzdGF0ZSBmb3IgdGhpcyBtZW51IGl0ZW0gYXMgc2VsZWN0ZWQgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqICAgICAgICBpZiB0aGUgbWVudSBpdGVtIGlzIHNlbGVjdGVkIG9yIG5vdFxuICAgKi9cblxuXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5zZWxlY3RlZCA9IGZ1bmN0aW9uIHNlbGVjdGVkKF9zZWxlY3RlZCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgIGlmIChfc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNlbGVjdGVkJyk7XG4gICAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJywgJ3RydWUnKTtcbiAgICAgICAgLy8gYXJpYS1jaGVja2VkIGlzbid0IGZ1bGx5IHN1cHBvcnRlZCBieSBicm93c2Vycy9zY3JlZW4gcmVhZGVycyxcbiAgICAgICAgLy8gc28gaW5kaWNhdGUgc2VsZWN0ZWQgc3RhdGUgdG8gc2NyZWVuIHJlYWRlciBpbiB0aGUgY29udHJvbCB0ZXh0LlxuICAgICAgICB0aGlzLmNvbnRyb2xUZXh0KCcsIHNlbGVjdGVkJyk7XG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZF8gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNlbGVjdGVkJyk7XG4gICAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJywgJ2ZhbHNlJyk7XG4gICAgICAgIC8vIEluZGljYXRlIHVuLXNlbGVjdGVkIHN0YXRlIHRvIHNjcmVlbiByZWFkZXJcbiAgICAgICAgdGhpcy5jb250cm9sVGV4dCgnJyk7XG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZF8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1lbnVJdGVtO1xufShDbGlja2FibGVDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01lbnVJdGVtJywgTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stbWVudS1pdGVtLmpzXG4gKi9cblxuLyoqXG4gKiBUaGUgc3BlY2lmaWMgbWVudSBpdGVtIHR5cGUgZm9yIHNlbGVjdGluZyBhIGxhbmd1YWdlIHdpdGhpbiBhIHRleHQgdHJhY2sga2luZFxuICpcbiAqIEBleHRlbmRzIE1lbnVJdGVtXG4gKi9cblxudmFyIFRleHRUcmFja01lbnVJdGVtID0gZnVuY3Rpb24gKF9NZW51SXRlbSkge1xuICBpbmhlcml0cyhUZXh0VHJhY2tNZW51SXRlbSwgX01lbnVJdGVtKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFRleHRUcmFja01lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFja01lbnVJdGVtKTtcblxuICAgIHZhciB0cmFjayA9IG9wdGlvbnMudHJhY2s7XG4gICAgdmFyIHRyYWNrcyA9IHBsYXllci50ZXh0VHJhY2tzKCk7XG5cbiAgICAvLyBNb2RpZnkgb3B0aW9ucyBmb3IgcGFyZW50IE1lbnVJdGVtIGNsYXNzJ3MgaW5pdC5cbiAgICBvcHRpb25zLmxhYmVsID0gdHJhY2subGFiZWwgfHwgdHJhY2subGFuZ3VhZ2UgfHwgJ1Vua25vd24nO1xuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSB0cmFjay5tb2RlID09PSAnc2hvd2luZyc7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9NZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudHJhY2sgPSB0cmFjaztcbiAgICB2YXIgY2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uIGNoYW5nZUhhbmRsZXIoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgdmFyIHNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24gc2VsZWN0ZWRMYW5ndWFnZUNoYW5nZUhhbmRsZXIoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBwbGF5ZXIub24oWydsb2Fkc3RhcnQnLCAndGV4dHRyYWNrY2hhbmdlJ10sIGNoYW5nZUhhbmRsZXIpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0ZWRsYW5ndWFnZWNoYW5nZScsIHNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2VIYW5kbGVyKTtcbiAgICBfdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHBsYXllci5vZmYoWydsb2Fkc3RhcnQnLCAndGV4dHRyYWNrY2hhbmdlJ10sIGNoYW5nZUhhbmRsZXIpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVkbGFuZ3VhZ2VjaGFuZ2UnLCBzZWxlY3RlZExhbmd1YWdlQ2hhbmdlSGFuZGxlcik7XG4gICAgfSk7XG5cbiAgICAvLyBpT1M3IGRvZXNuJ3QgZGlzcGF0Y2ggY2hhbmdlIGV2ZW50cyB0byBUZXh0VHJhY2tMaXN0cyB3aGVuIGFuXG4gICAgLy8gYXNzb2NpYXRlZCB0cmFjaydzIG1vZGUgY2hhbmdlcy4gV2l0aG91dCBzb21ldGhpbmcgbGlrZVxuICAgIC8vIE9iamVjdC5vYnNlcnZlKCkgKGFsc28gbm90IHByZXNlbnQgb24gaU9TNyksIGl0J3Mgbm90XG4gICAgLy8gcG9zc2libGUgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gdGhlIG1vZGUgYXR0cmlidXRlIGFuZCBwb2x5ZmlsbFxuICAgIC8vIHRoZSBjaGFuZ2UgZXZlbnQuIEFzIGEgcG9vciBzdWJzdGl0dXRlLCB3ZSBtYW51YWxseSBkaXNwYXRjaFxuICAgIC8vIGNoYW5nZSBldmVudHMgd2hlbmV2ZXIgdGhlIGNvbnRyb2xzIG1vZGlmeSB0aGUgbW9kZS5cbiAgICBpZiAodHJhY2tzLm9uY2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBldmVudCA9IHZvaWQgMDtcblxuICAgICAgX3RoaXMub24oWyd0YXAnLCAnY2xpY2snXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3R5cGVvZih3aW5kb3ckMS5FdmVudCkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgLy8gQW5kcm9pZCAyLjMgdGhyb3dzIGFuIElsbGVnYWwgQ29uc3RydWN0b3IgZXJyb3IgZm9yIHdpbmRvdy5FdmVudFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldmVudCA9IG5ldyB3aW5kb3ckMS5FdmVudCgnY2hhbmdlJyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KCdjaGFuZ2UnLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNrcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgZGVmYXVsdCBzdGF0ZSBiYXNlZCBvbiBjdXJyZW50IHRyYWNrc1xuICAgIF90aGlzLmhhbmRsZVRyYWNrc0NoYW5nZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYFRleHRUcmFja01lbnVJdGVtYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIFRleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIGtpbmQgPSB0aGlzLnRyYWNrLmtpbmQ7XG4gICAgdmFyIGtpbmRzID0gdGhpcy50cmFjay5raW5kcztcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcblxuICAgIGlmICgha2luZHMpIHtcbiAgICAgIGtpbmRzID0gW2tpbmRdO1xuICAgIH1cblxuICAgIF9NZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICBpZiAoIXRyYWNrcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmICh0cmFjayA9PT0gdGhpcy50cmFjayAmJiBraW5kcy5pbmRleE9mKHRyYWNrLmtpbmQpID4gLTEpIHtcbiAgICAgICAgaWYgKHRyYWNrLm1vZGUgIT09ICdzaG93aW5nJykge1xuICAgICAgICAgIHRyYWNrLm1vZGUgPSAnc2hvd2luZyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHJhY2subW9kZSAhPT0gJ2Rpc2FibGVkJykge1xuICAgICAgICB0cmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0ZXh0IHRyYWNrIGxpc3QgY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFja0xpc3QjY2hhbmdlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xuICAgIHZhciBzaG91bGRCZVNlbGVjdGVkID0gdGhpcy50cmFjay5tb2RlID09PSAnc2hvd2luZyc7XG5cbiAgICAvLyBQcmV2ZW50IHJlZHVuZGFudCBzZWxlY3RlZCgpIGNhbGxzIGJlY2F1c2UgdGhleSBtYXkgY2F1c2VcbiAgICAvLyBzY3JlZW4gcmVhZGVycyB0byByZWFkIHRoZSBhcHBlbmRlZCBjb250cm9sIHRleHQgdW5uZWNlc3NhcmlseVxuICAgIGlmIChzaG91bGRCZVNlbGVjdGVkICE9PSB0aGlzLmlzU2VsZWN0ZWRfKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkKHNob3VsZEJlU2VsZWN0ZWQpO1xuICAgIH1cbiAgfTtcblxuICBUZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlU2VsZWN0ZWRMYW5ndWFnZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UoZXZlbnQpIHtcbiAgICBpZiAodGhpcy50cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgIHZhciBzZWxlY3RlZExhbmd1YWdlID0gdGhpcy5wbGF5ZXJfLmNhY2hlXy5zZWxlY3RlZExhbmd1YWdlO1xuXG4gICAgICAvLyBEb24ndCByZXBsYWNlIHRoZSBraW5kIG9mIHRyYWNrIGFjcm9zcyB0aGUgc2FtZSBsYW5ndWFnZVxuICAgICAgaWYgKHNlbGVjdGVkTGFuZ3VhZ2UgJiYgc2VsZWN0ZWRMYW5ndWFnZS5lbmFibGVkICYmIHNlbGVjdGVkTGFuZ3VhZ2UubGFuZ3VhZ2UgPT09IHRoaXMudHJhY2subGFuZ3VhZ2UgJiYgc2VsZWN0ZWRMYW5ndWFnZS5raW5kICE9PSB0aGlzLnRyYWNrLmtpbmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBsYXllcl8uY2FjaGVfLnNlbGVjdGVkTGFuZ3VhZ2UgPSB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGxhbmd1YWdlOiB0aGlzLnRyYWNrLmxhbmd1YWdlLFxuICAgICAgICBraW5kOiB0aGlzLnRyYWNrLmtpbmRcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIFRleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHRyYWNrIG9iamVjdCBvbiBkaXNwb3NlXG4gICAgdGhpcy50cmFjayA9IG51bGw7XG5cbiAgICBfTWVudUl0ZW0ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrTWVudUl0ZW07XG59KE1lbnVJdGVtKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tNZW51SXRlbScsIFRleHRUcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBvZmYtdGV4dC10cmFjay1tZW51LWl0ZW0uanNcbiAqL1xuXG4vKipcbiAqIEEgc3BlY2lhbCBtZW51IGl0ZW0gZm9yIHR1cm5pbmcgb2YgYSBzcGVjaWZpYyB0eXBlIG9mIHRleHQgdHJhY2tcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tNZW51SXRlbVxuICovXG5cbnZhciBPZmZUZXh0VHJhY2tNZW51SXRlbSA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoT2ZmVGV4dFRyYWNrTWVudUl0ZW0sIF9UZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBPZmZUZXh0VHJhY2tNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBPZmZUZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgICAvLyBDcmVhdGUgcHNldWRvIHRyYWNrIGluZm9cbiAgICAvLyBSZXF1aXJlcyBvcHRpb25zWydraW5kJ11cbiAgICBvcHRpb25zLnRyYWNrID0ge1xuICAgICAgcGxheWVyOiBwbGF5ZXIsXG4gICAgICBraW5kOiBvcHRpb25zLmtpbmQsXG4gICAgICBraW5kczogb3B0aW9ucy5raW5kcyxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgbW9kZTogJ2Rpc2FibGVkJ1xuICAgIH07XG5cbiAgICBpZiAoIW9wdGlvbnMua2luZHMpIHtcbiAgICAgIG9wdGlvbnMua2luZHMgPSBbb3B0aW9ucy5raW5kXTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5sYWJlbCkge1xuICAgICAgb3B0aW9ucy50cmFjay5sYWJlbCA9IG9wdGlvbnMubGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMudHJhY2subGFiZWwgPSBvcHRpb25zLmtpbmRzLmpvaW4oJyBhbmQgJykgKyAnIG9mZic7XG4gICAgfVxuXG4gICAgLy8gTWVudUl0ZW0gaXMgc2VsZWN0YWJsZVxuICAgIG9wdGlvbnMuc2VsZWN0YWJsZSA9IHRydWU7XG4gICAgLy8gTWVudUl0ZW0gaXMgTk9UIG11bHRpU2VsZWN0YWJsZSAoaS5lLiBvbmx5IG9uZSBjYW4gYmUgbWFya2VkIFwic2VsZWN0ZWRcIiBhdCBhIHRpbWUpXG4gICAgb3B0aW9ucy5tdWx0aVNlbGVjdGFibGUgPSBmYWxzZTtcblxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tNZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0ZXh0IHRyYWNrIGNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuXG4gICAqL1xuXG5cbiAgT2ZmVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcigpLnRleHRUcmFja3MoKTtcbiAgICB2YXIgc2hvdWxkQmVTZWxlY3RlZCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRyYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9uc18ua2luZHMuaW5kZXhPZih0cmFjay5raW5kKSA+IC0xICYmIHRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICBzaG91bGRCZVNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByZXZlbnQgcmVkdW5kYW50IHNlbGVjdGVkKCkgY2FsbHMgYmVjYXVzZSB0aGV5IG1heSBjYXVzZVxuICAgIC8vIHNjcmVlbiByZWFkZXJzIHRvIHJlYWQgdGhlIGFwcGVuZGVkIGNvbnRyb2wgdGV4dCB1bm5lY2Vzc2FyaWx5XG4gICAgaWYgKHNob3VsZEJlU2VsZWN0ZWQgIT09IHRoaXMuaXNTZWxlY3RlZF8pIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQoc2hvdWxkQmVTZWxlY3RlZCk7XG4gICAgfVxuICB9O1xuXG4gIE9mZlRleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVTZWxlY3RlZExhbmd1YWdlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlU2VsZWN0ZWRMYW5ndWFnZUNoYW5nZShldmVudCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcigpLnRleHRUcmFja3MoKTtcbiAgICB2YXIgYWxsSGlkZGVuID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdHJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpZiAoWydjYXB0aW9ucycsICdkZXNjcmlwdGlvbnMnLCAnc3VidGl0bGVzJ10uaW5kZXhPZih0cmFjay5raW5kKSA+IC0xICYmIHRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICBhbGxIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFsbEhpZGRlbikge1xuICAgICAgdGhpcy5wbGF5ZXJfLmNhY2hlXy5zZWxlY3RlZExhbmd1YWdlID0ge1xuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE9mZlRleHRUcmFja01lbnVJdGVtO1xufShUZXh0VHJhY2tNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnT2ZmVGV4dFRyYWNrTWVudUl0ZW0nLCBPZmZUZXh0VHJhY2tNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay1idXR0b24uanNcbiAqL1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBidXR0b25zIHRoYXQgdG9nZ2xlIHNwZWNpZmljIHRleHQgdHJhY2sgdHlwZXMgKGUuZy4gc3VidGl0bGVzKVxuICpcbiAqIEBleHRlbmRzIE1lbnVCdXR0b25cbiAqL1xuXG52YXIgVGV4dFRyYWNrQnV0dG9uID0gZnVuY3Rpb24gKF9UcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhUZXh0VHJhY2tCdXR0b24sIF9UcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFja0J1dHRvbik7XG5cbiAgICBvcHRpb25zLnRyYWNrcyA9IHBsYXllci50ZXh0VHJhY2tzKCk7XG5cbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtZW51IGl0ZW0gZm9yIGVhY2ggdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja01lbnVJdGVtW119IFtpdGVtcz1bXV1cbiAgICogICAgICAgIEV4aXN0aW5nIGFycmF5IG9mIGl0ZW1zIHRvIHVzZSBkdXJpbmcgY3JlYXRpb25cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBBcnJheSBvZiBtZW51IGl0ZW1zIHRoYXQgd2VyZSBjcmVhdGVkXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgdmFyIFRyYWNrTWVudUl0ZW0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFRleHRUcmFja01lbnVJdGVtO1xuXG5cbiAgICAvLyBMYWJlbCBpcyBhbiBvdmVycmlkZSBmb3IgdGhlIFt0cmFja10gb2ZmIGxhYmVsXG4gICAgLy8gVVNlZCB0byBsb2NhbGlzZSBjYXB0aW9ucy9zdWJ0aXRsZXNcbiAgICB2YXIgbGFiZWwgPSB2b2lkIDA7XG5cbiAgICBpZiAodGhpcy5sYWJlbF8pIHtcbiAgICAgIGxhYmVsID0gdGhpcy5sYWJlbF8gKyAnIG9mZic7XG4gICAgfVxuICAgIC8vIEFkZCBhbiBPRkYgbWVudSBpdGVtIHRvIHR1cm4gYWxsIHRyYWNrcyBvZmZcbiAgICBpdGVtcy5wdXNoKG5ldyBPZmZUZXh0VHJhY2tNZW51SXRlbSh0aGlzLnBsYXllcl8sIHtcbiAgICAgIGtpbmRzOiB0aGlzLmtpbmRzXyxcbiAgICAgIGtpbmQ6IHRoaXMua2luZF8sXG4gICAgICBsYWJlbDogbGFiZWxcbiAgICB9KSk7XG5cbiAgICB0aGlzLmhpZGVUaHJlc2hvbGRfICs9IDE7XG5cbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmtpbmRzXykpIHtcbiAgICAgIHRoaXMua2luZHNfID0gW3RoaXMua2luZF9dO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIC8vIG9ubHkgYWRkIHRyYWNrcyB0aGF0IGFyZSBvZiBhbiBhcHByb3ByaWF0ZSBraW5kIGFuZCBoYXZlIGEgbGFiZWxcbiAgICAgIGlmICh0aGlzLmtpbmRzXy5pbmRleE9mKHRyYWNrLmtpbmQpID4gLTEpIHtcblxuICAgICAgICB2YXIgaXRlbSA9IG5ldyBUcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywge1xuICAgICAgICAgIHRyYWNrOiB0cmFjayxcbiAgICAgICAgICAvLyBNZW51SXRlbSBpcyBzZWxlY3RhYmxlXG4gICAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAvLyBNZW51SXRlbSBpcyBOT1QgbXVsdGlTZWxlY3RhYmxlIChpLmUuIG9ubHkgb25lIGNhbiBiZSBtYXJrZWQgXCJzZWxlY3RlZFwiIGF0IGEgdGltZSlcbiAgICAgICAgICBtdWx0aVNlbGVjdGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0uYWRkQ2xhc3MoJ3Zqcy0nICsgdHJhY2sua2luZCArICctbWVudS1pdGVtJyk7XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2tCdXR0b247XG59KFRyYWNrQnV0dG9uKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tCdXR0b24nLCBUZXh0VHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGNoYXB0ZXJzLXRyYWNrLW1lbnUtaXRlbS5qc1xuICovXG5cbi8qKlxuICogVGhlIGNoYXB0ZXIgdHJhY2sgbWVudSBpdGVtXG4gKlxuICogQGV4dGVuZHMgTWVudUl0ZW1cbiAqL1xuXG52YXIgQ2hhcHRlcnNUcmFja01lbnVJdGVtID0gZnVuY3Rpb24gKF9NZW51SXRlbSkge1xuICBpbmhlcml0cyhDaGFwdGVyc1RyYWNrTWVudUl0ZW0sIF9NZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDaGFwdGVyc1RyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hhcHRlcnNUcmFja01lbnVJdGVtKTtcblxuICAgIHZhciB0cmFjayA9IG9wdGlvbnMudHJhY2s7XG4gICAgdmFyIGN1ZSA9IG9wdGlvbnMuY3VlO1xuICAgIHZhciBjdXJyZW50VGltZSA9IHBsYXllci5jdXJyZW50VGltZSgpO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9ucy5zZWxlY3RhYmxlID0gdHJ1ZTtcbiAgICBvcHRpb25zLm11bHRpU2VsZWN0YWJsZSA9IGZhbHNlO1xuICAgIG9wdGlvbnMubGFiZWwgPSBjdWUudGV4dDtcbiAgICBvcHRpb25zLnNlbGVjdGVkID0gY3VlLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSAmJiBjdXJyZW50VGltZSA8IGN1ZS5lbmRUaW1lO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnRyYWNrID0gdHJhY2s7XG4gICAgX3RoaXMuY3VlID0gY3VlO1xuICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZSkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYENoYXB0ZXJzVHJhY2tNZW51SXRlbWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIENoYXB0ZXJzVHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIF9NZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2suY2FsbCh0aGlzKTtcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5jdWUuc3RhcnRUaW1lKTtcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLmN1ZS5zdGFydFRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgY2hhcHRlciBtZW51IGl0ZW1cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBjdWVjaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZXh0VHJhY2sjY3VlY2hhbmdlXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNUcmFja01lbnVJdGVtLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICB2YXIgY3VlID0gdGhpcy5jdWU7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG5cbiAgICAvLyB2anMubG9nKGN1cnJlbnRUaW1lLCBjdWUuc3RhcnRUaW1lKTtcbiAgICB0aGlzLnNlbGVjdGVkKGN1ZS5zdGFydFRpbWUgPD0gY3VycmVudFRpbWUgJiYgY3VycmVudFRpbWUgPCBjdWUuZW5kVGltZSk7XG4gIH07XG5cbiAgcmV0dXJuIENoYXB0ZXJzVHJhY2tNZW51SXRlbTtcbn0oTWVudUl0ZW0pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NoYXB0ZXJzVHJhY2tNZW51SXRlbScsIENoYXB0ZXJzVHJhY2tNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgY2hhcHRlcnMtYnV0dG9uLmpzXG4gKi9cblxuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBjaGFwdGVyc1xuICogQ2hhcHRlcnMgYWN0IG11Y2ggZGlmZmVyZW50bHkgdGhhbiBvdGhlciB0ZXh0IHRyYWNrc1xuICogQ3VlcyBhcmUgbmF2aWdhdGlvbiB2cy4gb3RoZXIgdHJhY2tzIG9mIGFsdGVybmF0aXZlIGxhbmd1YWdlc1xuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja0J1dHRvblxuICovXG5cbnZhciBDaGFwdGVyc0J1dHRvbiA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrQnV0dG9uKSB7XG4gIGluaGVyaXRzKENoYXB0ZXJzQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIGZ1bmN0aW9uIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gQ2hhcHRlcnNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENoYXB0ZXJzQnV0dG9uKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2hhcHRlcnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2hhcHRlcnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIG1lbnUgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgaXRzIGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBBbiBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrTGlzdCNhZGR0cmFja1xuICAgKiBAbGlzdGVucyBUZXh0VHJhY2tMaXN0I3JlbW92ZXRyYWNrXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFja0xpc3QjY2hhbmdlXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIGlmICghdGhpcy50cmFja18gfHwgZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdhZGR0cmFjaycgfHwgZXZlbnQudHlwZSA9PT0gJ3JlbW92ZXRyYWNrJykpIHtcbiAgICAgIHRoaXMuc2V0VHJhY2sodGhpcy5maW5kQ2hhcHRlcnNUcmFjaygpKTtcbiAgICB9XG4gICAgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRyYWNrIGZvciB0aGUgY2hhcHRlcnMgYnV0dG9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSBuZXcgdHJhY2sgdG8gc2VsZWN0LiBOb3RoaW5nIHdpbGwgY2hhbmdlIGlmIHRoaXMgaXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgKiAgICAgICAgdHJhY2suXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLnNldFRyYWNrID0gZnVuY3Rpb24gc2V0VHJhY2sodHJhY2spIHtcbiAgICBpZiAodGhpcy50cmFja18gPT09IHRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnVwZGF0ZUhhbmRsZXJfKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhhbmRsZXJfID0gdGhpcy51cGRhdGUuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBoZXJlIHRoaXMudHJhY2tfIHJlZmVycyB0byB0aGUgb2xkIHRyYWNrIGluc3RhbmNlXG4gICAgaWYgKHRoaXMudHJhY2tfKSB7XG4gICAgICB2YXIgcmVtb3RlVGV4dFRyYWNrRWwgPSB0aGlzLnBsYXllcl8ucmVtb3RlVGV4dFRyYWNrRWxzKCkuZ2V0VHJhY2tFbGVtZW50QnlUcmFja18odGhpcy50cmFja18pO1xuXG4gICAgICBpZiAocmVtb3RlVGV4dFRyYWNrRWwpIHtcbiAgICAgICAgcmVtb3RlVGV4dFRyYWNrRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMudXBkYXRlSGFuZGxlcl8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyYWNrXyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy50cmFja18gPSB0cmFjaztcblxuICAgIC8vIGhlcmUgdGhpcy50cmFja18gcmVmZXJzIHRvIHRoZSBuZXcgdHJhY2sgaW5zdGFuY2VcbiAgICBpZiAodGhpcy50cmFja18pIHtcbiAgICAgIHRoaXMudHJhY2tfLm1vZGUgPSAnaGlkZGVuJztcblxuICAgICAgdmFyIF9yZW1vdGVUZXh0VHJhY2tFbCA9IHRoaXMucGxheWVyXy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5nZXRUcmFja0VsZW1lbnRCeVRyYWNrXyh0aGlzLnRyYWNrXyk7XG5cbiAgICAgIGlmIChfcmVtb3RlVGV4dFRyYWNrRWwpIHtcbiAgICAgICAgX3JlbW90ZVRleHRUcmFja0VsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLnVwZGF0ZUhhbmRsZXJfKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHRyYWNrIG9iamVjdCB0aGF0IGlzIGN1cnJlbnRseSBpbiB1c2UgYnkgdGhpcyBDaGFwdGVyc0J1dHRvblxuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2t8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHRyYWNrIG9yIHVuZGVmaW5lZCBpZiBub25lIHdhcyBmb3VuZC5cbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuZmluZENoYXB0ZXJzVHJhY2sgPSBmdW5jdGlvbiBmaW5kQ2hhcHRlcnNUcmFjaygpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKSB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSB0cmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIC8vIFdlIHdpbGwgYWx3YXlzIGNob29zZSB0aGUgbGFzdCB0cmFjayBhcyBvdXIgY2hhcHRlcnNUcmFja1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpZiAodHJhY2sua2luZCA9PT0gdGhpcy5raW5kXykge1xuICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNhcHRpb24gZm9yIHRoZSBDaGFwdGVyc0J1dHRvbiBiYXNlZCBvbiB0aGUgdHJhY2sgbGFiZWwuIFRoaXMgd2lsbCBhbHNvXG4gICAqIHVzZSB0aGUgY3VycmVudCB0cmFja3MgbG9jYWxpemVkIGtpbmQgYXMgYSBmYWxsYmFjayBpZiBhIGxhYmVsIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIHRyYWNrcyBjdXJyZW50IGxhYmVsIG9yIHRoZSBsb2NhbGl6ZWQgdHJhY2sga2luZC5cbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuZ2V0TWVudUNhcHRpb24gPSBmdW5jdGlvbiBnZXRNZW51Q2FwdGlvbigpIHtcbiAgICBpZiAodGhpcy50cmFja18gJiYgdGhpcy50cmFja18ubGFiZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrXy5sYWJlbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9jYWxpemUodG9UaXRsZUNhc2UodGhpcy5raW5kXykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgbWVudSBmcm9tIGNoYXB0ZXIgdHJhY2tcbiAgICpcbiAgICogQHJldHVybiB7TWVudX1cbiAgICogICAgICAgICBOZXcgbWVudSBmb3IgdGhlIGNoYXB0ZXIgYnV0dG9uc1xuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51ID0gZnVuY3Rpb24gY3JlYXRlTWVudSgpIHtcbiAgICB0aGlzLm9wdGlvbnNfLnRpdGxlID0gdGhpcy5nZXRNZW51Q2FwdGlvbigpO1xuICAgIHJldHVybiBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51LmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lbnUgaXRlbSBmb3IgZWFjaCB0ZXh0IHRyYWNrXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja01lbnVJdGVtW119XG4gICAqICAgICAgICAgQXJyYXkgb2YgbWVudSBpdGVtc1xuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKCF0aGlzLnRyYWNrXykge1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIHZhciBjdWVzID0gdGhpcy50cmFja18uY3VlcztcblxuICAgIGlmICghY3Vlcykge1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3Vlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjdWUgPSBjdWVzW2ldO1xuICAgICAgdmFyIG1pID0gbmV3IENoYXB0ZXJzVHJhY2tNZW51SXRlbSh0aGlzLnBsYXllcl8sIHsgdHJhY2s6IHRoaXMudHJhY2tfLCBjdWU6IGN1ZSB9KTtcblxuICAgICAgaXRlbXMucHVzaChtaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIHJldHVybiBDaGFwdGVyc0J1dHRvbjtcbn0oVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBga2luZGAgb2YgVGV4dFRyYWNrIHRvIGxvb2sgZm9yIHRvIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMgbWVudS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkNoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdjaGFwdGVycyc7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgQ2hhcHRlcnNCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdDaGFwdGVycyc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2hhcHRlcnNCdXR0b24nLCBDaGFwdGVyc0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgZGVzY3JpcHRpb25zLWJ1dHRvbi5qc1xuICovXG5cbi8qKlxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3RpbmcgZGVzY3JpcHRpb25zXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKi9cblxudmFyIERlc2NyaXB0aW9uc0J1dHRvbiA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrQnV0dG9uKSB7XG4gIGluaGVyaXRzKERlc2NyaXB0aW9uc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBEZXNjcmlwdGlvbnNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERlc2NyaXB0aW9uc0J1dHRvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XG5cbiAgICB2YXIgdHJhY2tzID0gcGxheWVyLnRleHRUcmFja3MoKTtcbiAgICB2YXIgY2hhbmdlSGFuZGxlciA9IGJpbmQoX3RoaXMsIF90aGlzLmhhbmRsZVRyYWNrc0NoYW5nZSk7XG5cbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgX3RoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0ZXh0IHRyYWNrIGNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFja0xpc3QjY2hhbmdlXG4gICAqL1xuXG5cbiAgRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5oYW5kbGVUcmFja3NDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVUcmFja3NDaGFuZ2UoZXZlbnQpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXIoKS50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayB3aGV0aGVyIGEgdHJhY2sgb2YgYSBkaWZmZXJlbnQga2luZCBpcyBzaG93aW5nXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0cmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmICh0cmFjay5raW5kICE9PSB0aGlzLmtpbmRfICYmIHRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGFub3RoZXIgdHJhY2sgaXMgc2hvd2luZywgZGlzYWJsZSB0aGlzIG1lbnUgYnV0dG9uXG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBEZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWRlc2NyaXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBEZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtZGVzY3JpcHRpb25zLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gRGVzY3JpcHRpb25zQnV0dG9uO1xufShUZXh0VHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIGBraW5kYCBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdkZXNjcmlwdGlvbnMnO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYERlc2NyaXB0aW9uc0J1dHRvbmBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5EZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdEZXNjcmlwdGlvbnMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0Rlc2NyaXB0aW9uc0J1dHRvbicsIERlc2NyaXB0aW9uc0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgc3VidGl0bGVzLWJ1dHRvbi5qc1xuICovXG5cbi8qKlxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3Rpbmcgc3VidGl0bGVzXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKi9cblxudmFyIFN1YnRpdGxlc0J1dHRvbiA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrQnV0dG9uKSB7XG4gIGluaGVyaXRzKFN1YnRpdGxlc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBTdWJ0aXRsZXNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnRpdGxlc0J1dHRvbik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucywgcmVhZHkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1zdWJ0aXRsZXMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXN1YnRpdGxlcy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIFN1YnRpdGxlc0J1dHRvbjtcbn0oVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBga2luZGAgb2YgVGV4dFRyYWNrIHRvIGxvb2sgZm9yIHRvIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMgbWVudS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cblN1YnRpdGxlc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnc3VidGl0bGVzJztcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBTdWJ0aXRsZXNCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnU3VidGl0bGVzJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTdWJ0aXRsZXNCdXR0b24nLCBTdWJ0aXRsZXNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGNhcHRpb24tc2V0dGluZ3MtbWVudS1pdGVtLmpzXG4gKi9cblxuLyoqXG4gKiBUaGUgbWVudSBpdGVtIGZvciBjYXB0aW9uIHRyYWNrIHNldHRpbmdzIG1lbnVcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tNZW51SXRlbVxuICovXG5cbnZhciBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0sIF9UZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSk7XG5cbiAgICBvcHRpb25zLnRyYWNrID0ge1xuICAgICAgcGxheWVyOiBwbGF5ZXIsXG4gICAgICBraW5kOiBvcHRpb25zLmtpbmQsXG4gICAgICBsYWJlbDogb3B0aW9ucy5raW5kICsgJyBzZXR0aW5ncycsXG4gICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgbW9kZTogJ2Rpc2FibGVkJ1xuICAgIH07XG5cbiAgICAvLyBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSBoYXMgbm8gY29uY2VwdCBvZiAnc2VsZWN0ZWQnXG4gICAgb3B0aW9ucy5zZWxlY3RhYmxlID0gZmFsc2U7XG5cbiAgICBvcHRpb25zLm5hbWUgPSAnQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0nO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmFkZENsYXNzKCd2anMtdGV4dHRyYWNrLXNldHRpbmdzJyk7XG4gICAgX3RoaXMuY29udHJvbFRleHQoJywgb3BlbnMgJyArIG9wdGlvbnMua2luZCArICcgc2V0dGluZ3MgZGlhbG9nJyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW1gIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIHRoaXMucGxheWVyKCkuZ2V0Q2hpbGQoJ3RleHRUcmFja1NldHRpbmdzJykub3BlbigpO1xuICB9O1xuXG4gIHJldHVybiBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbTtcbn0oVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NhcHRpb25TZXR0aW5nc01lbnVJdGVtJywgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIGNhcHRpb25zLWJ1dHRvbi5qc1xuICovXG5cbi8qKlxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3RpbmcgY2FwdGlvbnNcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b25cbiAqL1xuXG52YXIgQ2FwdGlvbnNCdXR0b24gPSBmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhDYXB0aW9uc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBDYXB0aW9uc0J1dHRvbihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FwdGlvbnNCdXR0b24pO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIENhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jYXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBDYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jYXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjYXB0aW9uIG1lbnUgaXRlbXNcbiAgICpcbiAgICogQHJldHVybiB7Q2FwdGlvblNldHRpbmdzTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBUaGUgYXJyYXkgb2YgY3VycmVudCBtZW51IGl0ZW1zLlxuICAgKi9cblxuXG4gIENhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKCEodGhpcy5wbGF5ZXIoKS50ZWNoXyAmJiB0aGlzLnBsYXllcigpLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykgJiYgdGhpcy5wbGF5ZXIoKS5nZXRDaGlsZCgndGV4dFRyYWNrU2V0dGluZ3MnKSkge1xuICAgICAgaXRlbXMucHVzaChuZXcgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7IGtpbmQ6IHRoaXMua2luZF8gfSkpO1xuXG4gICAgICB0aGlzLmhpZGVUaHJlc2hvbGRfICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zLmNhbGwodGhpcywgaXRlbXMpO1xuICB9O1xuXG4gIHJldHVybiBDYXB0aW9uc0J1dHRvbjtcbn0oVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBga2luZGAgb2YgVGV4dFRyYWNrIHRvIGxvb2sgZm9yIHRvIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMgbWVudS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkNhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdjYXB0aW9ucyc7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgQ2FwdGlvbnNCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuQ2FwdGlvbnNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdDYXB0aW9ucyc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2FwdGlvbnNCdXR0b24nLCBDYXB0aW9uc0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgc3Vicy1jYXBzLW1lbnUtaXRlbS5qc1xuICovXG5cbi8qKlxuICogU3Vic0NhcHNNZW51SXRlbSBoYXMgYW4gW2NjXSBpY29uIHRvIGRpc3Rpbmd1aXNoIGNhcHRpb25zIGZyb20gc3VidGl0bGVzXG4gKiBpbiB0aGUgU3Vic0NhcHNNZW51LlxuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja01lbnVJdGVtXG4gKi9cblxudmFyIFN1YnNDYXBzTWVudUl0ZW0gPSBmdW5jdGlvbiAoX1RleHRUcmFja01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKFN1YnNDYXBzTWVudUl0ZW0sIF9UZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgZnVuY3Rpb24gU3Vic0NhcHNNZW51SXRlbSgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJzQ2Fwc01lbnVJdGVtKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrTWVudUl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBTdWJzQ2Fwc01lbnVJdGVtLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKHR5cGUsIHByb3BzLCBhdHRycykge1xuICAgIHZhciBpbm5lckhUTUwgPSAnPHNwYW4gY2xhc3M9XCJ2anMtbWVudS1pdGVtLXRleHRcIj4nICsgdGhpcy5sb2NhbGl6ZSh0aGlzLm9wdGlvbnNfLmxhYmVsKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnNfLnRyYWNrLmtpbmQgPT09ICdjYXB0aW9ucycpIHtcbiAgICAgIGlubmVySFRNTCArPSAnXFxuICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInZqcy1pY29uLXBsYWNlaG9sZGVyXCI+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+ICcgKyB0aGlzLmxvY2FsaXplKCdDYXB0aW9ucycpICsgJzwvc3Bhbj5cXG4gICAgICAnO1xuICAgIH1cblxuICAgIGlubmVySFRNTCArPSAnPC9zcGFuPic7XG5cbiAgICB2YXIgZWwgPSBfVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgdHlwZSwgYXNzaWduKHtcbiAgICAgIGlubmVySFRNTDogaW5uZXJIVE1MXG4gICAgfSwgcHJvcHMpLCBhdHRycyk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgcmV0dXJuIFN1YnNDYXBzTWVudUl0ZW07XG59KFRleHRUcmFja01lbnVJdGVtKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTdWJzQ2Fwc01lbnVJdGVtJywgU3Vic0NhcHNNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgc3ViLWNhcHMtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3RpbmcgY2FwdGlvbnMgYW5kL29yIHN1YnRpdGxlc1xuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja0J1dHRvblxuICovXG5cbnZhciBTdWJzQ2Fwc0J1dHRvbiA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrQnV0dG9uKSB7XG4gIGluaGVyaXRzKFN1YnNDYXBzQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICBmdW5jdGlvbiBTdWJzQ2Fwc0J1dHRvbihwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Vic0NhcHNCdXR0b24pO1xuXG4gICAgLy8gQWx0aG91Z2ggTm9ydGggQW1lcmljYSB1c2VzIFwiY2FwdGlvbnNcIiBpbiBtb3N0IGNhc2VzIGZvclxuICAgIC8vIFwiY2FwdGlvbnMgYW5kIHN1YnRpdGxlc1wiIG90aGVyIGxvY2FsZXMgdXNlIFwic3VidGl0bGVzXCJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmxhYmVsXyA9ICdzdWJ0aXRsZXMnO1xuICAgIGlmIChbJ2VuJywgJ2VuLXVzJywgJ2VuLWNhJywgJ2ZyLWNhJ10uaW5kZXhPZihfdGhpcy5wbGF5ZXJfLmxhbmd1YWdlXykgPiAtMSkge1xuICAgICAgX3RoaXMubGFiZWxfID0gJ2NhcHRpb25zJztcbiAgICB9XG4gICAgX3RoaXMubWVudUJ1dHRvbl8uY29udHJvbFRleHQodG9UaXRsZUNhc2UoX3RoaXMubGFiZWxfKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBTdWJzQ2Fwc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtc3Vicy1jYXBzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIFN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXN1YnMtY2Fwcy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjYXB0aW9uL3N1YnRpdGxlcyBtZW51IGl0ZW1zXG4gICAqXG4gICAqIEByZXR1cm4ge0NhcHRpb25TZXR0aW5nc01lbnVJdGVtW119XG4gICAqICAgICAgICAgVGhlIGFycmF5IG9mIGN1cnJlbnQgbWVudSBpdGVtcy5cbiAgICovXG5cblxuICBTdWJzQ2Fwc0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiBjcmVhdGVJdGVtcygpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgIGlmICghKHRoaXMucGxheWVyKCkudGVjaF8gJiYgdGhpcy5wbGF5ZXIoKS50ZWNoXy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpICYmIHRoaXMucGxheWVyKCkuZ2V0Q2hpbGQoJ3RleHRUcmFja1NldHRpbmdzJykpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmV3IENhcHRpb25TZXR0aW5nc01lbnVJdGVtKHRoaXMucGxheWVyXywgeyBraW5kOiB0aGlzLmxhYmVsXyB9KSk7XG5cbiAgICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gKz0gMTtcbiAgICB9XG5cbiAgICBpdGVtcyA9IF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zLmNhbGwodGhpcywgaXRlbXMsIFN1YnNDYXBzTWVudUl0ZW0pO1xuICAgIHJldHVybiBpdGVtcztcbiAgfTtcblxuICByZXR1cm4gU3Vic0NhcHNCdXR0b247XG59KFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogYGtpbmRgcyBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxuICpcbiAqIEB0eXBlIHthcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5TdWJzQ2Fwc0J1dHRvbi5wcm90b3R5cGUua2luZHNfID0gWydjYXB0aW9ucycsICdzdWJ0aXRsZXMnXTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBTdWJzQ2Fwc0J1dHRvbmBzIGNvbnRyb2xzLlxuICpcbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuU3Vic0NhcHNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdTdWJ0aXRsZXMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1N1YnNDYXBzQnV0dG9uJywgU3Vic0NhcHNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGF1ZGlvLXRyYWNrLW1lbnUtaXRlbS5qc1xuICovXG5cbi8qKlxuICogQW4ge0BsaW5rIEF1ZGlvVHJhY2t9IHtAbGluayBNZW51SXRlbX1cbiAqXG4gKiBAZXh0ZW5kcyBNZW51SXRlbVxuICovXG5cbnZhciBBdWRpb1RyYWNrTWVudUl0ZW0gPSBmdW5jdGlvbiAoX01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKEF1ZGlvVHJhY2tNZW51SXRlbSwgX01lbnVJdGVtKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2tNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1RyYWNrTWVudUl0ZW0pO1xuXG4gICAgdmFyIHRyYWNrID0gb3B0aW9ucy50cmFjaztcbiAgICB2YXIgdHJhY2tzID0gcGxheWVyLmF1ZGlvVHJhY2tzKCk7XG5cbiAgICAvLyBNb2RpZnkgb3B0aW9ucyBmb3IgcGFyZW50IE1lbnVJdGVtIGNsYXNzJ3MgaW5pdC5cbiAgICBvcHRpb25zLmxhYmVsID0gdHJhY2subGFiZWwgfHwgdHJhY2subGFuZ3VhZ2UgfHwgJ1Vua25vd24nO1xuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSB0cmFjay5lbmFibGVkO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnRyYWNrID0gdHJhY2s7XG5cbiAgICBfdGhpcy5hZGRDbGFzcygndmpzLScgKyB0cmFjay5raW5kICsgJy1tZW51LWl0ZW0nKTtcblxuICAgIHZhciBjaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24gY2hhbmdlSGFuZGxlcigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmhhbmRsZVRyYWNrc0NoYW5nZS5hcHBseShfdGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICBfdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBBdWRpb1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwodHlwZSwgcHJvcHMsIGF0dHJzKSB7XG4gICAgdmFyIGlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cInZqcy1tZW51LWl0ZW0tdGV4dFwiPicgKyB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubGFiZWwpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9uc18udHJhY2sua2luZCA9PT0gJ21haW4tZGVzYycpIHtcbiAgICAgIGlubmVySFRNTCArPSAnXFxuICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInZqcy1pY29uLXBsYWNlaG9sZGVyXCI+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+ICcgKyB0aGlzLmxvY2FsaXplKCdEZXNjcmlwdGlvbnMnKSArICc8L3NwYW4+XFxuICAgICAgJztcbiAgICB9XG5cbiAgICBpbm5lckhUTUwgKz0gJzwvc3Bhbj4nO1xuXG4gICAgdmFyIGVsID0gX01lbnVJdGVtLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHR5cGUsIGFzc2lnbih7XG4gICAgICBpbm5lckhUTUw6IGlubmVySFRNTFxuICAgIH0sIHByb3BzKSwgYXR0cnMpO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYEF1ZGlvVHJhY2tNZW51SXRlbSBpcyBcImNsaWNrZWRcIi4gU2VlIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9XG4gICAqIGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgQXVkaW9UcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpO1xuXG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIHRyYWNrLmVuYWJsZWQgPSB0cmFjayA9PT0gdGhpcy50cmFjaztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhbnkge0BsaW5rIEF1ZGlvVHJhY2t9IGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBBdWRpb1RyYWNrTGlzdCNjaGFuZ2V9IGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBBdWRpb1RyYWNrTGlzdCNjaGFuZ2VcbiAgICovXG5cblxuICBBdWRpb1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xuICAgIHRoaXMuc2VsZWN0ZWQodGhpcy50cmFjay5lbmFibGVkKTtcbiAgfTtcblxuICByZXR1cm4gQXVkaW9UcmFja01lbnVJdGVtO1xufShNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQXVkaW9UcmFja01lbnVJdGVtJywgQXVkaW9UcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBhdWRpby10cmFjay1idXR0b24uanNcbiAqL1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBidXR0b25zIHRoYXQgdG9nZ2xlIHNwZWNpZmljIHtAbGluayBBdWRpb1RyYWNrfSB0eXBlcy5cbiAqXG4gKiBAZXh0ZW5kcyBUcmFja0J1dHRvblxuICovXG5cbnZhciBBdWRpb1RyYWNrQnV0dG9uID0gZnVuY3Rpb24gKF9UcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhBdWRpb1RyYWNrQnV0dG9uLCBfVHJhY2tCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQXVkaW9UcmFja0J1dHRvbihwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9UcmFja0J1dHRvbik7XG5cbiAgICBvcHRpb25zLnRyYWNrcyA9IHBsYXllci5hdWRpb1RyYWNrcygpO1xuXG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIEF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWF1ZGlvLWJ1dHRvbiAnICsgX1RyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgQXVkaW9UcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1hdWRpby1idXR0b24gJyArIF9UcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbWVudSBpdGVtIGZvciBlYWNoIGF1ZGlvIHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja01lbnVJdGVtW119IFtpdGVtcz1bXV1cbiAgICogICAgICAgIEFuIGFycmF5IG9mIGV4aXN0aW5nIG1lbnUgaXRlbXMgdG8gdXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBdWRpb1RyYWNrTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBBbiBhcnJheSBvZiBtZW51IGl0ZW1zXG4gICAqL1xuXG5cbiAgQXVkaW9UcmFja0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiBjcmVhdGVJdGVtcygpIHtcbiAgICB2YXIgaXRlbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuXG4gICAgLy8gaWYgdGhlcmUncyBvbmx5IG9uZSBhdWRpbyB0cmFjaywgdGhlcmUgbm8gcG9pbnQgaW4gc2hvd2luZyBpdFxuICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gPSAxO1xuXG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaXRlbXMucHVzaChuZXcgQXVkaW9UcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywge1xuICAgICAgICB0cmFjazogdHJhY2ssXG4gICAgICAgIC8vIE1lbnVJdGVtIGlzIHNlbGVjdGFibGVcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgLy8gTWVudUl0ZW0gaXMgTk9UIG11bHRpU2VsZWN0YWJsZSAoaS5lLiBvbmx5IG9uZSBjYW4gYmUgbWFya2VkIFwic2VsZWN0ZWRcIiBhdCBhIHRpbWUpXG4gICAgICAgIG11bHRpU2VsZWN0YWJsZTogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2tCdXR0b247XG59KFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBBdWRpb1RyYWNrQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5BdWRpb1RyYWNrQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnQXVkaW8gVHJhY2snO1xuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdBdWRpb1RyYWNrQnV0dG9uJywgQXVkaW9UcmFja0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgcGxheWJhY2stcmF0ZS1tZW51LWl0ZW0uanNcbiAqL1xuXG4vKipcbiAqIFRoZSBzcGVjaWZpYyBtZW51IGl0ZW0gdHlwZSBmb3Igc2VsZWN0aW5nIGEgcGxheWJhY2sgcmF0ZS5cbiAqXG4gKiBAZXh0ZW5kcyBNZW51SXRlbVxuICovXG5cbnZhciBQbGF5YmFja1JhdGVNZW51SXRlbSA9IGZ1bmN0aW9uIChfTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoUGxheWJhY2tSYXRlTWVudUl0ZW0sIF9NZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBQbGF5YmFja1JhdGVNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5YmFja1JhdGVNZW51SXRlbSk7XG5cbiAgICB2YXIgbGFiZWwgPSBvcHRpb25zLnJhdGU7XG4gICAgdmFyIHJhdGUgPSBwYXJzZUZsb2F0KGxhYmVsLCAxMCk7XG5cbiAgICAvLyBNb2RpZnkgb3B0aW9ucyBmb3IgcGFyZW50IE1lbnVJdGVtIGNsYXNzJ3MgaW5pdC5cbiAgICBvcHRpb25zLmxhYmVsID0gbGFiZWw7XG4gICAgb3B0aW9ucy5zZWxlY3RlZCA9IHJhdGUgPT09IDE7XG4gICAgb3B0aW9ucy5zZWxlY3RhYmxlID0gdHJ1ZTtcbiAgICBvcHRpb25zLm11bHRpU2VsZWN0YWJsZSA9IGZhbHNlO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgX3RoaXMucmF0ZSA9IHJhdGU7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdyYXRlY2hhbmdlJywgX3RoaXMudXBkYXRlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBQbGF5YmFja1JhdGVNZW51SXRlbWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMpO1xuICAgIHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKHRoaXMucmF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgUGxheWJhY2tSYXRlTWVudUl0ZW0gd2hlbiB0aGUgcGxheWJhY2tyYXRlIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgcmF0ZWNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNyYXRlY2hhbmdlXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUl0ZW0ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIHRoaXMuc2VsZWN0ZWQodGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKSA9PT0gdGhpcy5yYXRlKTtcbiAgfTtcblxuICByZXR1cm4gUGxheWJhY2tSYXRlTWVudUl0ZW07XG59KE1lbnVJdGVtKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBQbGF5YmFja1JhdGVNZW51SXRlbWBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuUGxheWJhY2tSYXRlTWVudUl0ZW0ucHJvdG90eXBlLmNvbnRlbnRFbFR5cGUgPSAnYnV0dG9uJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5YmFja1JhdGVNZW51SXRlbScsIFBsYXliYWNrUmF0ZU1lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5YmFjay1yYXRlLW1lbnUtYnV0dG9uLmpzXG4gKi9cblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBjb250cm9sbGluZyB0aGUgcGxheWJhY2sgcmF0ZS5cbiAqXG4gKiBAZXh0ZW5kcyBNZW51QnV0dG9uXG4gKi9cblxudmFyIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24gPSBmdW5jdGlvbiAoX01lbnVCdXR0b24pIHtcbiAgaW5oZXJpdHMoUGxheWJhY2tSYXRlTWVudUJ1dHRvbiwgX01lbnVCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUGxheWJhY2tSYXRlTWVudUJ1dHRvbihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5YmFja1JhdGVNZW51QnV0dG9uKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICBfdGhpcy51cGRhdGVMYWJlbCgpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnbG9hZHN0YXJ0JywgX3RoaXMudXBkYXRlVmlzaWJpbGl0eSk7XG4gICAgX3RoaXMub24ocGxheWVyLCAncmF0ZWNoYW5nZScsIF90aGlzLnVwZGF0ZUxhYmVsKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IF9NZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5sYWJlbEVsXyA9IGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcGxheWJhY2stcmF0ZS12YWx1ZScsXG4gICAgICBpbm5lckhUTUw6ICcxeCdcbiAgICB9KTtcblxuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMubGFiZWxFbF8pO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHRoaXMubGFiZWxFbF8gPSBudWxsO1xuXG4gICAgX01lbnVCdXR0b24ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXBsYXliYWNrLXJhdGUgJyArIF9NZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1wbGF5YmFjay1yYXRlICcgKyBfTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBwbGF5YmFjayByYXRlIG1lbnVcbiAgICpcbiAgICogQHJldHVybiB7TWVudX1cbiAgICogICAgICAgICBNZW51IG9iamVjdCBwb3B1bGF0ZWQgd2l0aCB7QGxpbmsgUGxheWJhY2tSYXRlTWVudUl0ZW19c1xuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmNyZWF0ZU1lbnUgPSBmdW5jdGlvbiBjcmVhdGVNZW51KCkge1xuICAgIHZhciBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXIoKSk7XG4gICAgdmFyIHJhdGVzID0gdGhpcy5wbGF5YmFja1JhdGVzKCk7XG5cbiAgICBpZiAocmF0ZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSByYXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBtZW51LmFkZENoaWxkKG5ldyBQbGF5YmFja1JhdGVNZW51SXRlbSh0aGlzLnBsYXllcigpLCB7IHJhdGU6IHJhdGVzW2ldICsgJ3gnIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWVudTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyBBUklBIGFjY2Vzc2liaWxpdHkgYXR0cmlidXRlc1xuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gdXBkYXRlQVJJQUF0dHJpYnV0ZXMoKSB7XG4gICAgLy8gQ3VycmVudCBwbGF5YmFjayByYXRlXG4gICAgdGhpcy5lbCgpLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYFBsYXliYWNrUmF0ZU1lbnVCdXR0b25gIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgLy8gc2VsZWN0IG5leHQgcmF0ZSBvcHRpb25cbiAgICB2YXIgY3VycmVudFJhdGUgPSB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpO1xuICAgIHZhciByYXRlcyA9IHRoaXMucGxheWJhY2tSYXRlcygpO1xuXG4gICAgLy8gdGhpcyB3aWxsIHNlbGVjdCBmaXJzdCBvbmUgaWYgdGhlIGxhc3Qgb25lIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgIHZhciBuZXdSYXRlID0gcmF0ZXNbMF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmF0ZXNbaV0gPiBjdXJyZW50UmF0ZSkge1xuICAgICAgICBuZXdSYXRlID0gcmF0ZXNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZShuZXdSYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHBvc3NpYmxlIHBsYXliYWNrIHJhdGVzXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiAgICAgICAgIEFsbCBwb3NzaWJsZSBwbGF5YmFjayByYXRlc1xuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnBsYXliYWNrUmF0ZXMgPSBmdW5jdGlvbiBwbGF5YmFja1JhdGVzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnNfLnBsYXliYWNrUmF0ZXMgfHwgdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zICYmIHRoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucy5wbGF5YmFja1JhdGVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciBwbGF5YmFjayByYXRlcyBpcyBzdXBwb3J0ZWQgYnkgdGhlIHRlY2hcbiAgICogYW5kIGFuIGFycmF5IG9mIHBsYXliYWNrIHJhdGVzIGV4aXN0c1xuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFdoZXRoZXIgY2hhbmdpbmcgcGxheWJhY2sgcmF0ZSBpcyBzdXBwb3J0ZWRcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5wbGF5YmFja1JhdGVTdXBwb3J0ZWQgPSBmdW5jdGlvbiBwbGF5YmFja1JhdGVTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyKCkudGVjaF8gJiYgdGhpcy5wbGF5ZXIoKS50ZWNoXy5mZWF0dXJlc1BsYXliYWNrUmF0ZSAmJiB0aGlzLnBsYXliYWNrUmF0ZXMoKSAmJiB0aGlzLnBsYXliYWNrUmF0ZXMoKS5sZW5ndGggPiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlIHBsYXliYWNrIHJhdGUgY29udHJvbHMgd2hlbiB0aGV5J3JlIG5vIHBsYXliYWNrIHJhdGUgb3B0aW9ucyB0byBzZWxlY3RcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjbG9hZHN0YXJ0XG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUudXBkYXRlVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIHVwZGF0ZVZpc2liaWxpdHkoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5YmFja1JhdGVTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgYnV0dG9uIGxhYmVsIHdoZW4gcmF0ZSBjaGFuZ2VkXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3JhdGVjaGFuZ2VcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS51cGRhdGVMYWJlbCA9IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWJhY2tSYXRlU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRoaXMubGFiZWxFbF8uaW5uZXJIVE1MID0gdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKSArICd4JztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBsYXliYWNrUmF0ZU1lbnVCdXR0b247XG59KE1lbnVCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEZ1bGxzY3JlZW5Ub2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cblBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdQbGF5YmFjayBSYXRlJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5YmFja1JhdGVNZW51QnV0dG9uJywgUGxheWJhY2tSYXRlTWVudUJ1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgc3BhY2VyLmpzXG4gKi9cblxuLyoqXG4gKiBKdXN0IGFuIGVtcHR5IHNwYWNlciBlbGVtZW50IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gYXBwZW5kIHBvaW50IGZvciBwbHVnaW5zLCBldGMuXG4gKiBBbHNvIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBzcGFjZSBiZXR3ZWVuIGVsZW1lbnRzIHdoZW4gbmVjZXNzYXJ5LlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBTcGFjZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhTcGFjZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFNwYWNlcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTcGFjZXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cbiAgU3BhY2VyLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1zcGFjZXIgJyArIF9Db21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBTcGFjZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKClcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gU3BhY2VyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1NwYWNlcicsIFNwYWNlcik7XG5cbi8qKlxuICogQGZpbGUgY3VzdG9tLWNvbnRyb2wtc3BhY2VyLmpzXG4gKi9cblxuLyoqXG4gKiBTcGFjZXIgc3BlY2lmaWNhbGx5IG1lYW50IHRvIGJlIHVzZWQgYXMgYW4gaW5zZXJ0aW9uIHBvaW50IGZvciBuZXcgcGx1Z2lucywgZXRjLlxuICpcbiAqIEBleHRlbmRzIFNwYWNlclxuICovXG5cbnZhciBDdXN0b21Db250cm9sU3BhY2VyID0gZnVuY3Rpb24gKF9TcGFjZXIpIHtcbiAgaW5oZXJpdHMoQ3VzdG9tQ29udHJvbFNwYWNlciwgX1NwYWNlcik7XG5cbiAgZnVuY3Rpb24gQ3VzdG9tQ29udHJvbFNwYWNlcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDdXN0b21Db250cm9sU3BhY2VyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU3BhY2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG4gIEN1c3RvbUNvbnRyb2xTcGFjZXIucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWN1c3RvbS1jb250cm9sLXNwYWNlciAnICsgX1NwYWNlci5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIEN1c3RvbUNvbnRyb2xTcGFjZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIGVsID0gX1NwYWNlci5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpXG4gICAgfSk7XG5cbiAgICAvLyBOby1mbGV4L3RhYmxlLWNlbGwgbW9kZSByZXF1aXJlcyB0aGVyZSBiZSBzb21lIGNvbnRlbnRcbiAgICAvLyBpbiB0aGUgY2VsbCB0byBmaWxsIHRoZSByZW1haW5pbmcgc3BhY2Ugb2YgdGhlIHRhYmxlLlxuICAgIGVsLmlubmVySFRNTCA9ICdcXHhBMCc7XG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIHJldHVybiBDdXN0b21Db250cm9sU3BhY2VyO1xufShTcGFjZXIpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0N1c3RvbUNvbnRyb2xTcGFjZXInLCBDdXN0b21Db250cm9sU3BhY2VyKTtcblxuLyoqXG4gKiBAZmlsZSBjb250cm9sLWJhci5qc1xuICovXG5cbi8qKlxuICogQ29udGFpbmVyIG9mIG1haW4gY29udHJvbHMuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIENvbnRyb2xCYXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhDb250cm9sQmFyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBDb250cm9sQmFyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRyb2xCYXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIENvbnRyb2xCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLWJhcicsXG4gICAgICBkaXI6ICdsdHInXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIENvbnRyb2xCYXI7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBgQ29udHJvbEJhcmBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkNvbnRyb2xCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWydwbGF5VG9nZ2xlJywgJ3ZvbHVtZVBhbmVsJywgJ2N1cnJlbnRUaW1lRGlzcGxheScsICd0aW1lRGl2aWRlcicsICdkdXJhdGlvbkRpc3BsYXknLCAncHJvZ3Jlc3NDb250cm9sJywgJ2xpdmVEaXNwbGF5JywgJ3JlbWFpbmluZ1RpbWVEaXNwbGF5JywgJ2N1c3RvbUNvbnRyb2xTcGFjZXInLCAncGxheWJhY2tSYXRlTWVudUJ1dHRvbicsICdjaGFwdGVyc0J1dHRvbicsICdkZXNjcmlwdGlvbnNCdXR0b24nLCAnc3Vic0NhcHNCdXR0b24nLCAnYXVkaW9UcmFja0J1dHRvbicsICdmdWxsc2NyZWVuVG9nZ2xlJ11cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ29udHJvbEJhcicsIENvbnRyb2xCYXIpO1xuXG4vKipcbiAqIEBmaWxlIGVycm9yLWRpc3BsYXkuanNcbiAqL1xuXG4vKipcbiAqIEEgZGlzcGxheSB0aGF0IGluZGljYXRlcyBhbiBlcnJvciBoYXMgb2NjdXJyZWQuIFRoaXMgbWVhbnMgdGhhdCB0aGUgdmlkZW9cbiAqIGlzIHVucGxheWFibGUuXG4gKlxuICogQGV4dGVuZHMgTW9kYWxEaWFsb2dcbiAqL1xuXG52YXIgRXJyb3JEaXNwbGF5ID0gZnVuY3Rpb24gKF9Nb2RhbERpYWxvZykge1xuICBpbmhlcml0cyhFcnJvckRpc3BsYXksIF9Nb2RhbERpYWxvZyk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gRXJyb3JEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEVycm9yRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Nb2RhbERpYWxvZy5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnZXJyb3InLCBfdGhpcy5vcGVuKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2ZXJzaW9uIDUuXG4gICAqL1xuXG5cbiAgRXJyb3JEaXNwbGF5LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1lcnJvci1kaXNwbGF5ICcgKyBfTW9kYWxEaWFsb2cucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbG9jYWxpemVkIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gdGhlIGBQbGF5ZXJgcyBlcnJvci5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBgUGxheWVyYHMgZXJyb3IgbWVzc2FnZSBsb2NhbGl6ZWQgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICAgKi9cblxuXG4gIEVycm9yRGlzcGxheS5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5wbGF5ZXIoKS5lcnJvcigpO1xuXG4gICAgcmV0dXJuIGVycm9yID8gdGhpcy5sb2NhbGl6ZShlcnJvci5tZXNzYWdlKSA6ICcnO1xuICB9O1xuXG4gIHJldHVybiBFcnJvckRpc3BsYXk7XG59KE1vZGFsRGlhbG9nKTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciBhbiBgRXJyb3JEaXNwbGF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuRXJyb3JEaXNwbGF5LnByb3RvdHlwZS5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyhNb2RhbERpYWxvZy5wcm90b3R5cGUub3B0aW9uc18sIHtcbiAgcGF1c2VPbk9wZW46IGZhbHNlLFxuICBmaWxsQWx3YXlzOiB0cnVlLFxuICB0ZW1wb3Jhcnk6IGZhbHNlLFxuICB1bmNsb3NlYWJsZTogdHJ1ZVxufSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRXJyb3JEaXNwbGF5JywgRXJyb3JEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLXNldHRpbmdzLmpzXG4gKi9cblxudmFyIExPQ0FMX1NUT1JBR0VfS0VZID0gJ3Zqcy10ZXh0LXRyYWNrLXNldHRpbmdzJztcblxudmFyIENPTE9SX0JMQUNLID0gWycjMDAwJywgJ0JsYWNrJ107XG52YXIgQ09MT1JfQkxVRSA9IFsnIzAwRicsICdCbHVlJ107XG52YXIgQ09MT1JfQ1lBTiA9IFsnIzBGRicsICdDeWFuJ107XG52YXIgQ09MT1JfR1JFRU4gPSBbJyMwRjAnLCAnR3JlZW4nXTtcbnZhciBDT0xPUl9NQUdFTlRBID0gWycjRjBGJywgJ01hZ2VudGEnXTtcbnZhciBDT0xPUl9SRUQgPSBbJyNGMDAnLCAnUmVkJ107XG52YXIgQ09MT1JfV0hJVEUgPSBbJyNGRkYnLCAnV2hpdGUnXTtcbnZhciBDT0xPUl9ZRUxMT1cgPSBbJyNGRjAnLCAnWWVsbG93J107XG5cbnZhciBPUEFDSVRZX09QQVFVRSA9IFsnMScsICdPcGFxdWUnXTtcbnZhciBPUEFDSVRZX1NFTUkgPSBbJzAuNScsICdTZW1pLVRyYW5zcGFyZW50J107XG52YXIgT1BBQ0lUWV9UUkFOUyA9IFsnMCcsICdUcmFuc3BhcmVudCddO1xuXG4vLyBDb25maWd1cmF0aW9uIGZvciB0aGUgdmFyaW91cyA8c2VsZWN0PiBlbGVtZW50cyBpbiB0aGUgRE9NIG9mIHRoaXMgY29tcG9uZW50LlxuLy9cbi8vIFBvc3NpYmxlIGtleXMgaW5jbHVkZTpcbi8vXG4vLyBgZGVmYXVsdGA6XG4vLyAgIFRoZSBkZWZhdWx0IG9wdGlvbiBpbmRleC4gT25seSBuZWVkcyB0byBiZSBwcm92aWRlZCBpZiBub3QgemVyby5cbi8vIGBwYXJzZXJgOlxuLy8gICBBIGZ1bmN0aW9uIHdoaWNoIGlzIHVzZWQgdG8gcGFyc2UgdGhlIHZhbHVlIGZyb20gdGhlIHNlbGVjdGVkIG9wdGlvbiBpblxuLy8gICBhIGN1c3RvbWl6ZWQgd2F5LlxuLy8gYHNlbGVjdG9yYDpcbi8vICAgVGhlIHNlbGVjdG9yIHVzZWQgdG8gZmluZCB0aGUgYXNzb2NpYXRlZCA8c2VsZWN0PiBlbGVtZW50LlxudmFyIHNlbGVjdENvbmZpZ3MgPSB7XG4gIGJhY2tncm91bmRDb2xvcjoge1xuICAgIHNlbGVjdG9yOiAnLnZqcy1iZy1jb2xvciA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy1iYWNrZ3JvdW5kLWNvbG9yLSVzJyxcbiAgICBsYWJlbDogJ0NvbG9yJyxcbiAgICBvcHRpb25zOiBbQ09MT1JfQkxBQ0ssIENPTE9SX1dISVRFLCBDT0xPUl9SRUQsIENPTE9SX0dSRUVOLCBDT0xPUl9CTFVFLCBDT0xPUl9ZRUxMT1csIENPTE9SX01BR0VOVEEsIENPTE9SX0NZQU5dXG4gIH0sXG5cbiAgYmFja2dyb3VuZE9wYWNpdHk6IHtcbiAgICBzZWxlY3RvcjogJy52anMtYmctb3BhY2l0eSA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy1iYWNrZ3JvdW5kLW9wYWNpdHktJXMnLFxuICAgIGxhYmVsOiAnVHJhbnNwYXJlbmN5JyxcbiAgICBvcHRpb25zOiBbT1BBQ0lUWV9PUEFRVUUsIE9QQUNJVFlfU0VNSSwgT1BBQ0lUWV9UUkFOU11cbiAgfSxcblxuICBjb2xvcjoge1xuICAgIHNlbGVjdG9yOiAnLnZqcy1mZy1jb2xvciA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy1mb3JlZ3JvdW5kLWNvbG9yLSVzJyxcbiAgICBsYWJlbDogJ0NvbG9yJyxcbiAgICBvcHRpb25zOiBbQ09MT1JfV0hJVEUsIENPTE9SX0JMQUNLLCBDT0xPUl9SRUQsIENPTE9SX0dSRUVOLCBDT0xPUl9CTFVFLCBDT0xPUl9ZRUxMT1csIENPTE9SX01BR0VOVEEsIENPTE9SX0NZQU5dXG4gIH0sXG5cbiAgZWRnZVN0eWxlOiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWVkZ2Utc3R5bGUgPiBzZWxlY3QnLFxuICAgIGlkOiAnJXMnLFxuICAgIGxhYmVsOiAnVGV4dCBFZGdlIFN0eWxlJyxcbiAgICBvcHRpb25zOiBbWydub25lJywgJ05vbmUnXSwgWydyYWlzZWQnLCAnUmFpc2VkJ10sIFsnZGVwcmVzc2VkJywgJ0RlcHJlc3NlZCddLCBbJ3VuaWZvcm0nLCAnVW5pZm9ybSddLCBbJ2Ryb3BzaGFkb3cnLCAnRHJvcHNoYWRvdyddXVxuICB9LFxuXG4gIGZvbnRGYW1pbHk6IHtcbiAgICBzZWxlY3RvcjogJy52anMtZm9udC1mYW1pbHkgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtZm9udC1mYW1pbHktJXMnLFxuICAgIGxhYmVsOiAnRm9udCBGYW1pbHknLFxuICAgIG9wdGlvbnM6IFtbJ3Byb3BvcnRpb25hbFNhbnNTZXJpZicsICdQcm9wb3J0aW9uYWwgU2Fucy1TZXJpZiddLCBbJ21vbm9zcGFjZVNhbnNTZXJpZicsICdNb25vc3BhY2UgU2Fucy1TZXJpZiddLCBbJ3Byb3BvcnRpb25hbFNlcmlmJywgJ1Byb3BvcnRpb25hbCBTZXJpZiddLCBbJ21vbm9zcGFjZVNlcmlmJywgJ01vbm9zcGFjZSBTZXJpZiddLCBbJ2Nhc3VhbCcsICdDYXN1YWwnXSwgWydzY3JpcHQnLCAnU2NyaXB0J10sIFsnc21hbGwtY2FwcycsICdTbWFsbCBDYXBzJ11dXG4gIH0sXG5cbiAgZm9udFBlcmNlbnQ6IHtcbiAgICBzZWxlY3RvcjogJy52anMtZm9udC1wZXJjZW50ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLWZvbnQtc2l6ZS0lcycsXG4gICAgbGFiZWw6ICdGb250IFNpemUnLFxuICAgIG9wdGlvbnM6IFtbJzAuNTAnLCAnNTAlJ10sIFsnMC43NScsICc3NSUnXSwgWycxLjAwJywgJzEwMCUnXSwgWycxLjI1JywgJzEyNSUnXSwgWycxLjUwJywgJzE1MCUnXSwgWycxLjc1JywgJzE3NSUnXSwgWycyLjAwJywgJzIwMCUnXSwgWyczLjAwJywgJzMwMCUnXSwgWyc0LjAwJywgJzQwMCUnXV0sXG4gICAgZGVmYXVsdDogMixcbiAgICBwYXJzZXI6IGZ1bmN0aW9uIHBhcnNlcih2KSB7XG4gICAgICByZXR1cm4gdiA9PT0gJzEuMDAnID8gbnVsbCA6IE51bWJlcih2KTtcbiAgICB9XG4gIH0sXG5cbiAgdGV4dE9wYWNpdHk6IHtcbiAgICBzZWxlY3RvcjogJy52anMtdGV4dC1vcGFjaXR5ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLWZvcmVncm91bmQtb3BhY2l0eS0lcycsXG4gICAgbGFiZWw6ICdUcmFuc3BhcmVuY3knLFxuICAgIG9wdGlvbnM6IFtPUEFDSVRZX09QQVFVRSwgT1BBQ0lUWV9TRU1JXVxuICB9LFxuXG4gIC8vIE9wdGlvbnMgZm9yIHRoaXMgb2JqZWN0IGFyZSBkZWZpbmVkIGJlbG93LlxuICB3aW5kb3dDb2xvcjoge1xuICAgIHNlbGVjdG9yOiAnLnZqcy13aW5kb3ctY29sb3IgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtd2luZG93LWNvbG9yLSVzJyxcbiAgICBsYWJlbDogJ0NvbG9yJ1xuICB9LFxuXG4gIC8vIE9wdGlvbnMgZm9yIHRoaXMgb2JqZWN0IGFyZSBkZWZpbmVkIGJlbG93LlxuICB3aW5kb3dPcGFjaXR5OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLXdpbmRvdy1vcGFjaXR5ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLXdpbmRvdy1vcGFjaXR5LSVzJyxcbiAgICBsYWJlbDogJ1RyYW5zcGFyZW5jeScsXG4gICAgb3B0aW9uczogW09QQUNJVFlfVFJBTlMsIE9QQUNJVFlfU0VNSSwgT1BBQ0lUWV9PUEFRVUVdXG4gIH1cbn07XG5cbnNlbGVjdENvbmZpZ3Mud2luZG93Q29sb3Iub3B0aW9ucyA9IHNlbGVjdENvbmZpZ3MuYmFja2dyb3VuZENvbG9yLm9wdGlvbnM7XG5cbi8qKlxuICogR2V0IHRoZSBhY3R1YWwgdmFsdWUgb2YgYW4gb3B0aW9uLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWVcbiAqICAgICAgICAgVGhlIHZhbHVlIHRvIGdldFxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbcGFyc2VyXVxuICogICAgICAgICBPcHRpb25hbCBmdW5jdGlvbiB0byBhZGp1c3QgdGhlIHZhbHVlLlxuICpcbiAqIEByZXR1cm4ge01peGVkfVxuICogICAgICAgICAtIFdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgbm8gdmFsdWUgZXhpc3RzXG4gKiAgICAgICAgIC0gV2lsbCBiZSBgdW5kZWZpbmVkYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgXCJub25lXCIuXG4gKiAgICAgICAgIC0gV2lsbCBiZSB0aGUgYWN0dWFsIHZhbHVlIG90aGVyd2lzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZU9wdGlvblZhbHVlKHZhbHVlLCBwYXJzZXIpIHtcbiAgaWYgKHBhcnNlcikge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNlbGVjdGVkIDxvcHRpb24+IGVsZW1lbnQgd2l0aGluIGEgPHNlbGVjdD4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogICAgICAgICB0aGUgZWxlbWVudCB0byBsb29rIGluXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IFtwYXJzZXJdXG4gKiAgICAgICAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFkanVzdCB0aGUgdmFsdWUuXG4gKlxuICogQHJldHVybiB7TWl4ZWR9XG4gKiAgICAgICAgIC0gV2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBleGlzdHNcbiAqICAgICAgICAgLSBXaWxsIGJlIGB1bmRlZmluZWRgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBcIm5vbmVcIi5cbiAqICAgICAgICAgLSBXaWxsIGJlIHRoZSBhY3R1YWwgdmFsdWUgb3RoZXJ3aXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoZWwsIHBhcnNlcikge1xuICB2YXIgdmFsdWUgPSBlbC5vcHRpb25zW2VsLm9wdGlvbnMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG5cbiAgcmV0dXJuIHBhcnNlT3B0aW9uVmFsdWUodmFsdWUsIHBhcnNlcik7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc2VsZWN0ZWQgPG9wdGlvbj4gZWxlbWVudCB3aXRoaW4gYSA8c2VsZWN0PiBlbGVtZW50IGJhc2VkIG9uIGFcbiAqIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byBsb29rIGluLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogICAgICAgIHRoZSBwcm9wZXJ0eSB0byBsb29rIG9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJzZXJdXG4gKiAgICAgICAgT3B0aW9uYWwgZnVuY3Rpb24gdG8gYWRqdXN0IHRoZSB2YWx1ZSBiZWZvcmUgY29tcGFyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGVkT3B0aW9uKGVsLCB2YWx1ZSwgcGFyc2VyKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFyc2VPcHRpb25WYWx1ZShlbC5vcHRpb25zW2ldLnZhbHVlLCBwYXJzZXIpID09PSB2YWx1ZSkge1xuICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYW5pcHVsYXRlIFRleHQgVHJhY2tzIHNldHRpbmdzLlxuICpcbiAqIEBleHRlbmRzIE1vZGFsRGlhbG9nXG4gKi9cblxudmFyIFRleHRUcmFja1NldHRpbmdzID0gZnVuY3Rpb24gKF9Nb2RhbERpYWxvZykge1xuICBpbmhlcml0cyhUZXh0VHJhY2tTZXR0aW5ncywgX01vZGFsRGlhbG9nKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrU2V0dGluZ3MocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrU2V0dGluZ3MpO1xuXG4gICAgb3B0aW9ucy50ZW1wb3JhcnkgPSBmYWxzZTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01vZGFsRGlhbG9nLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGVEaXNwbGF5ID0gYmluZChfdGhpcywgX3RoaXMudXBkYXRlRGlzcGxheSk7XG5cbiAgICAvLyBmaWxsIHRoZSBtb2RhbCBhbmQgcHJldGVuZCB3ZSBoYXZlIG9wZW5lZCBpdFxuICAgIF90aGlzLmZpbGwoKTtcbiAgICBfdGhpcy5oYXNCZWVuT3BlbmVkXyA9IF90aGlzLmhhc0JlZW5GaWxsZWRfID0gdHJ1ZTtcblxuICAgIF90aGlzLmVuZERpYWxvZyA9IGNyZWF0ZUVsKCdwJywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCcsXG4gICAgICB0ZXh0Q29udGVudDogX3RoaXMubG9jYWxpemUoJ0VuZCBvZiBkaWFsb2cgd2luZG93LicpXG4gICAgfSk7XG4gICAgX3RoaXMuZWwoKS5hcHBlbmRDaGlsZChfdGhpcy5lbmREaWFsb2cpO1xuXG4gICAgX3RoaXMuc2V0RGVmYXVsdHMoKTtcblxuICAgIC8vIEdyYWIgYHBlcnNpc3RUZXh0VHJhY2tTZXR0aW5nc2AgZnJvbSB0aGUgcGxheWVyIG9wdGlvbnMgaWYgbm90IHBhc3NlZCBpbiBjaGlsZCBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMucGVyc2lzdFRleHRUcmFja1NldHRpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIF90aGlzLm9wdGlvbnNfLnBlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncyA9IF90aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMucGVyc2lzdFRleHRUcmFja1NldHRpbmdzO1xuICAgIH1cblxuICAgIF90aGlzLm9uKF90aGlzLiQoJy52anMtZG9uZS1idXR0b24nKSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2F2ZVNldHRpbmdzKCk7XG4gICAgICBfdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMub24oX3RoaXMuJCgnLnZqcy1kZWZhdWx0LWJ1dHRvbicpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXREZWZhdWx0cygpO1xuICAgICAgX3RoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuXG4gICAgZWFjaChzZWxlY3RDb25maWdzLCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICBfdGhpcy5vbihfdGhpcy4kKGNvbmZpZy5zZWxlY3RvciksICdjaGFuZ2UnLCBfdGhpcy51cGRhdGVEaXNwbGF5KTtcbiAgICB9KTtcblxuICAgIGlmIChfdGhpcy5vcHRpb25zXy5wZXJzaXN0VGV4dFRyYWNrU2V0dGluZ3MpIHtcbiAgICAgIF90aGlzLnJlc3RvcmVTZXR0aW5ncygpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5lbmREaWFsb2cgPSBudWxsO1xuXG4gICAgX01vZGFsRGlhbG9nLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIDxzZWxlY3Q+IGVsZW1lbnQgd2l0aCBjb25maWd1cmVkIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogICAgICAgIENvbmZpZ3VyYXRpb24ga2V5IHRvIHVzZSBkdXJpbmcgY3JlYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBBbiBIVE1MIHN0cmluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxTZWxlY3RfID0gZnVuY3Rpb24gY3JlYXRlRWxTZWxlY3RfKGtleSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGxlZ2VuZElkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2xhYmVsJztcblxuICAgIHZhciBjb25maWcgPSBzZWxlY3RDb25maWdzW2tleV07XG4gICAgdmFyIGlkID0gY29uZmlnLmlkLnJlcGxhY2UoJyVzJywgdGhpcy5pZF8pO1xuICAgIHZhciBzZWxlY3RMYWJlbGxlZGJ5SWRzID0gW2xlZ2VuZElkLCBpZF0uam9pbignICcpLnRyaW0oKTtcblxuICAgIHJldHVybiBbJzwnICsgdHlwZSArICcgaWQ9XCInICsgaWQgKyAnXCIgY2xhc3M9XCInICsgKHR5cGUgPT09ICdsYWJlbCcgPyAndmpzLWxhYmVsJyA6ICcnKSArICdcIj4nLCB0aGlzLmxvY2FsaXplKGNvbmZpZy5sYWJlbCksICc8LycgKyB0eXBlICsgJz4nLCAnPHNlbGVjdCBhcmlhLWxhYmVsbGVkYnk9XCInICsgc2VsZWN0TGFiZWxsZWRieUlkcyArICdcIj4nXS5jb25jYXQoY29uZmlnLm9wdGlvbnMubWFwKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgb3B0aW9uSWQgPSBpZCArICctJyArIG9bMV0ucmVwbGFjZSgvXFxXKy9nLCAnJyk7XG5cbiAgICAgIHJldHVybiBbJzxvcHRpb24gaWQ9XCInICsgb3B0aW9uSWQgKyAnXCIgdmFsdWU9XCInICsgb1swXSArICdcIiAnLCAnYXJpYS1sYWJlbGxlZGJ5PVwiJyArIHNlbGVjdExhYmVsbGVkYnlJZHMgKyAnICcgKyBvcHRpb25JZCArICdcIj4nLCBfdGhpczIubG9jYWxpemUob1sxXSksICc8L29wdGlvbj4nXS5qb2luKCcnKTtcbiAgICB9KSkuY29uY2F0KCc8L3NlbGVjdD4nKS5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGZvcmVncm91bmQgY29sb3IgZWxlbWVudCBmb3IgdGhlIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgQW4gSFRNTCBzdHJpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNyZWF0ZUVsRmdDb2xvcl8gPSBmdW5jdGlvbiBjcmVhdGVFbEZnQ29sb3JfKCkge1xuICAgIHZhciBsZWdlbmRJZCA9ICdjYXB0aW9ucy10ZXh0LWxlZ2VuZC0nICsgdGhpcy5pZF87XG5cbiAgICByZXR1cm4gWyc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtZmctY29sb3IgdmpzLXRyYWNrLXNldHRpbmdcIj4nLCAnPGxlZ2VuZCBpZD1cIicgKyBsZWdlbmRJZCArICdcIj4nLCB0aGlzLmxvY2FsaXplKCdUZXh0JyksICc8L2xlZ2VuZD4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygnY29sb3InLCBsZWdlbmRJZCksICc8c3BhbiBjbGFzcz1cInZqcy10ZXh0LW9wYWNpdHkgdmpzLW9wYWNpdHlcIj4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygndGV4dE9wYWNpdHknLCBsZWdlbmRJZCksICc8L3NwYW4+JywgJzwvZmllbGRzZXQ+J10uam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBiYWNrZ3JvdW5kIGNvbG9yIGVsZW1lbnQgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEFuIEhUTUwgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbEJnQ29sb3JfID0gZnVuY3Rpb24gY3JlYXRlRWxCZ0NvbG9yXygpIHtcbiAgICB2YXIgbGVnZW5kSWQgPSAnY2FwdGlvbnMtYmFja2dyb3VuZC0nICsgdGhpcy5pZF87XG5cbiAgICByZXR1cm4gWyc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtYmctY29sb3IgdmpzLXRyYWNrLXNldHRpbmdcIj4nLCAnPGxlZ2VuZCBpZD1cIicgKyBsZWdlbmRJZCArICdcIj4nLCB0aGlzLmxvY2FsaXplKCdCYWNrZ3JvdW5kJyksICc8L2xlZ2VuZD4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygnYmFja2dyb3VuZENvbG9yJywgbGVnZW5kSWQpLCAnPHNwYW4gY2xhc3M9XCJ2anMtYmctb3BhY2l0eSB2anMtb3BhY2l0eVwiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCdiYWNrZ3JvdW5kT3BhY2l0eScsIGxlZ2VuZElkKSwgJzwvc3Bhbj4nLCAnPC9maWVsZHNldD4nXS5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHdpbmRvdyBjb2xvciBlbGVtZW50IGZvciB0aGUgY29tcG9uZW50XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBBbiBIVE1MIHN0cmluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxXaW5Db2xvcl8gPSBmdW5jdGlvbiBjcmVhdGVFbFdpbkNvbG9yXygpIHtcbiAgICB2YXIgbGVnZW5kSWQgPSAnY2FwdGlvbnMtd2luZG93LScgKyB0aGlzLmlkXztcblxuICAgIHJldHVybiBbJzxmaWVsZHNldCBjbGFzcz1cInZqcy13aW5kb3ctY29sb3IgdmpzLXRyYWNrLXNldHRpbmdcIj4nLCAnPGxlZ2VuZCBpZD1cIicgKyBsZWdlbmRJZCArICdcIj4nLCB0aGlzLmxvY2FsaXplKCdXaW5kb3cnKSwgJzwvbGVnZW5kPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCd3aW5kb3dDb2xvcicsIGxlZ2VuZElkKSwgJzxzcGFuIGNsYXNzPVwidmpzLXdpbmRvdy1vcGFjaXR5IHZqcy1vcGFjaXR5XCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ3dpbmRvd09wYWNpdHknLCBsZWdlbmRJZCksICc8L3NwYW4+JywgJzwvZmllbGRzZXQ+J10uam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjb2xvciBlbGVtZW50cyBmb3IgdGhlIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxDb2xvcnNfID0gZnVuY3Rpb24gY3JlYXRlRWxDb2xvcnNfKCkge1xuICAgIHJldHVybiBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXRyYWNrLXNldHRpbmdzLWNvbG9ycycsXG4gICAgICBpbm5lckhUTUw6IFt0aGlzLmNyZWF0ZUVsRmdDb2xvcl8oKSwgdGhpcy5jcmVhdGVFbEJnQ29sb3JfKCksIHRoaXMuY3JlYXRlRWxXaW5Db2xvcl8oKV0uam9pbignJylcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGZvbnQgZWxlbWVudHMgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbEZvbnRfID0gZnVuY3Rpb24gY3JlYXRlRWxGb250XygpIHtcbiAgICByZXR1cm4gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10cmFjay1zZXR0aW5ncy1mb250JyxcbiAgICAgIGlubmVySFRNTDogWyc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtZm9udC1wZXJjZW50IHZqcy10cmFjay1zZXR0aW5nXCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2ZvbnRQZXJjZW50JywgJycsICdsZWdlbmQnKSwgJzwvZmllbGRzZXQ+JywgJzxmaWVsZHNldCBjbGFzcz1cInZqcy1lZGdlLXN0eWxlIHZqcy10cmFjay1zZXR0aW5nXCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2VkZ2VTdHlsZScsICcnLCAnbGVnZW5kJyksICc8L2ZpZWxkc2V0PicsICc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtZm9udC1mYW1pbHkgdmpzLXRyYWNrLXNldHRpbmdcIj4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygnZm9udEZhbWlseScsICcnLCAnbGVnZW5kJyksICc8L2ZpZWxkc2V0PiddLmpvaW4oJycpXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjb250cm9scyBmb3IgdGhlIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNyZWF0ZUVsQ29udHJvbHNfID0gZnVuY3Rpb24gY3JlYXRlRWxDb250cm9sc18oKSB7XG4gICAgdmFyIGRlZmF1bHRzRGVzY3JpcHRpb24gPSB0aGlzLmxvY2FsaXplKCdyZXN0b3JlIGFsbCBzZXR0aW5ncyB0byB0aGUgZGVmYXVsdCB2YWx1ZXMnKTtcblxuICAgIHJldHVybiBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXRyYWNrLXNldHRpbmdzLWNvbnRyb2xzJyxcbiAgICAgIGlubmVySFRNTDogWyc8YnV0dG9uIGNsYXNzPVwidmpzLWRlZmF1bHQtYnV0dG9uXCIgdGl0bGU9XCInICsgZGVmYXVsdHNEZXNjcmlwdGlvbiArICdcIj4nLCB0aGlzLmxvY2FsaXplKCdSZXNldCcpLCAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+ICcgKyBkZWZhdWx0c0Rlc2NyaXB0aW9uICsgJzwvc3Bhbj4nLCAnPC9idXR0b24+JywgJzxidXR0b24gY2xhc3M9XCJ2anMtZG9uZS1idXR0b25cIj4nICsgdGhpcy5sb2NhbGl6ZSgnRG9uZScpICsgJzwvYnV0dG9uPiddLmpvaW4oJycpXG4gICAgfSk7XG4gIH07XG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiBjb250ZW50KCkge1xuICAgIHJldHVybiBbdGhpcy5jcmVhdGVFbENvbG9yc18oKSwgdGhpcy5jcmVhdGVFbEZvbnRfKCksIHRoaXMuY3JlYXRlRWxDb250cm9sc18oKV07XG4gIH07XG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmxhYmVsID0gZnVuY3Rpb24gbGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxpemUoJ0NhcHRpb24gU2V0dGluZ3MgRGlhbG9nJyk7XG4gIH07XG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmRlc2NyaXB0aW9uID0gZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxpemUoJ0JlZ2lubmluZyBvZiBkaWFsb2cgd2luZG93LiBFc2NhcGUgd2lsbCBjYW5jZWwgYW5kIGNsb3NlIHRoZSB3aW5kb3cuJyk7XG4gIH07XG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiBfTW9kYWxEaWFsb2cucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKSArICcgdmpzLXRleHQtdHJhY2stc2V0dGluZ3MnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCBvZiB0ZXh0IHRyYWNrIHNldHRpbmdzIChvciBudWxsKS5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEFuIG9iamVjdCB3aXRoIGNvbmZpZyB2YWx1ZXMgcGFyc2VkIGZyb20gdGhlIERPTSBvciBsb2NhbFN0b3JhZ2UuXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uIGdldFZhbHVlcygpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHJldHVybiByZWR1Y2Uoc2VsZWN0Q29uZmlncywgZnVuY3Rpb24gKGFjY3VtLCBjb25maWcsIGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZShfdGhpczMuJChjb25maWcuc2VsZWN0b3IpLCBjb25maWcucGFyc2VyKTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWNjdW1ba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwge30pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRleHQgdHJhY2sgc2V0dGluZ3MgZnJvbSBhbiBvYmplY3Qgb2YgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzXG4gICAqICAgICAgICBBbiBvYmplY3Qgd2l0aCBjb25maWcgdmFsdWVzIHBhcnNlZCBmcm9tIHRoZSBET00gb3IgbG9jYWxTdG9yYWdlLlxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiBzZXRWYWx1ZXModmFsdWVzKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBlYWNoKHNlbGVjdENvbmZpZ3MsIGZ1bmN0aW9uIChjb25maWcsIGtleSkge1xuICAgICAgc2V0U2VsZWN0ZWRPcHRpb24oX3RoaXM0LiQoY29uZmlnLnNlbGVjdG9yKSwgdmFsdWVzW2tleV0sIGNvbmZpZy5wYXJzZXIpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGFsbCBgPHNlbGVjdD5gIGVsZW1lbnRzIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLlxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIHNldERlZmF1bHRzKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgZWFjaChzZWxlY3RDb25maWdzLCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICB2YXIgaW5kZXggPSBjb25maWcuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSA/IGNvbmZpZy5kZWZhdWx0IDogMDtcblxuICAgICAgX3RoaXM1LiQoY29uZmlnLnNlbGVjdG9yKS5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc3RvcmUgdGV4dHRyYWNrIHNldHRpbmdzIGZyb20gbG9jYWxTdG9yYWdlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLnJlc3RvcmVTZXR0aW5ncyA9IGZ1bmN0aW9uIHJlc3RvcmVTZXR0aW5ncygpIHtcbiAgICB2YXIgdmFsdWVzID0gdm9pZCAwO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlcyA9IEpTT04ucGFyc2Uod2luZG93JDEubG9jYWxTdG9yYWdlLmdldEl0ZW0oTE9DQUxfU1RPUkFHRV9LRVkpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZyQxLndhcm4oZXJyKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzKSB7XG4gICAgICB0aGlzLnNldFZhbHVlcyh2YWx1ZXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2F2ZSB0ZXh0IHRyYWNrIHNldHRpbmdzIHRvIGxvY2FsU3RvcmFnZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5zYXZlU2V0dGluZ3MgPSBmdW5jdGlvbiBzYXZlU2V0dGluZ3MoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnNfLnBlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZXMpLmxlbmd0aCkge1xuICAgICAgICB3aW5kb3ckMS5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkodmFsdWVzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3ckMS5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShMT0NBTF9TVE9SQUdFX0tFWSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2ckMS53YXJuKGVycik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgZGlzcGxheSBvZiB0ZXh0IHRyYWNrIHNldHRpbmdzXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkgPSBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgIHZhciB0dERpc3BsYXkgPSB0aGlzLnBsYXllcl8uZ2V0Q2hpbGQoJ3RleHRUcmFja0Rpc3BsYXknKTtcblxuICAgIGlmICh0dERpc3BsYXkpIHtcbiAgICAgIHR0RGlzcGxheS51cGRhdGVEaXNwbGF5KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBjb25kaXRpb25hbGx5IGJsdXIgdGhlIGVsZW1lbnQgYW5kIHJlZm9jdXMgdGhlIGNhcHRpb25zIGJ1dHRvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jb25kaXRpb25hbEJsdXJfID0gZnVuY3Rpb24gY29uZGl0aW9uYWxCbHVyXygpIHtcbiAgICB0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8gPSBudWxsO1xuICAgIHRoaXMub2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XG5cbiAgICB2YXIgY2IgPSB0aGlzLnBsYXllcl8uY29udHJvbEJhcjtcbiAgICB2YXIgc3Vic0NhcHNCdG4gPSBjYiAmJiBjYi5zdWJzQ2Fwc0J1dHRvbjtcbiAgICB2YXIgY2NCdG4gPSBjYiAmJiBjYi5jYXB0aW9uc0J1dHRvbjtcblxuICAgIGlmIChzdWJzQ2Fwc0J0bikge1xuICAgICAgc3Vic0NhcHNCdG4uZm9jdXMoKTtcbiAgICB9IGVsc2UgaWYgKGNjQnRuKSB7XG4gICAgICBjY0J0bi5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrU2V0dGluZ3M7XG59KE1vZGFsRGlhbG9nKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tTZXR0aW5ncycsIFRleHRUcmFja1NldHRpbmdzKTtcblxuLyoqXG4gKiBAZmlsZSByZXNpemUtbWFuYWdlci5qc1xuICovXG5cbi8qKlxuICogQSBSZXNpemUgTWFuYWdlci4gSXQgaXMgaW4gY2hhcmdlIG9mIHRyaWdnZXJpbmcgYHBsYXllcnJlc2l6ZWAgb24gdGhlIHBsYXllciBpbiB0aGUgcmlnaHQgY29uZGl0aW9ucy5cbiAqXG4gKiBJdCdsbCBlaXRoZXIgY3JlYXRlIGFuIGlmcmFtZSBhbmQgdXNlIGEgZGVib3VuY2VkIHJlc2l6ZSBoYW5kbGVyIG9uIGl0IG9yIHVzZSB0aGUgbmV3IHtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL1Jlc2l6ZU9ic2VydmVyL3xSZXNpemVPYnNlcnZlcn0uXG4gKlxuICogSWYgdGhlIFJlc2l6ZU9ic2VydmVyIGlzIGF2YWlsYWJsZSBuYXRpdmVseSwgaXQgd2lsbCBiZSB1c2VkLiBBIHBvbHlmaWxsIGNhbiBiZSBwYXNzZWQgaW4gYXMgYW4gb3B0aW9uLlxuICogSWYgYSBgcGxheWVycmVzaXplYCBldmVudCBpcyBub3QgbmVlZGVkLCB0aGUgUmVzaXplTWFuYWdlciBjb21wb25lbnQgY2FuIGJlIHJlbW92ZWQgZnJvbSB0aGUgcGxheWVyLCBzZWUgdGhlIGV4YW1wbGUgYmVsb3cuXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ib3cgdG8gZGlzYWJsZSB0aGUgcmVzaXplIG1hbmFnZXI8L2NhcHRpb24+XG4gKiBjb25zdCBwbGF5ZXIgPSB2aWRlb2pzKCcjdmlkJywge1xuICogICByZXNpemVNYW5hZ2VyOiBmYWxzZVxuICogfSk7XG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9SZXNpemVPYnNlcnZlci98UmVzaXplT2JzZXJ2ZXIgc3BlY2lmaWNhdGlvbn1cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUmVzaXplTWFuYWdlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFJlc2l6ZU1hbmFnZXIsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIFJlc2l6ZU1hbmFnZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIFJlc2l6ZU1hbmFnZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLlJlc2l6ZU9ic2VydmVyXVxuICAgKiAgICAgICAgQSBwb2x5ZmlsbCBmb3IgUmVzaXplT2JzZXJ2ZXIgY2FuIGJlIHBhc3NlZCBpbiBoZXJlLlxuICAgKiAgICAgICAgSWYgdGhpcyBpcyBzZXQgdG8gbnVsbCBpdCB3aWxsIGlnbm9yZSB0aGUgbmF0aXZlIFJlc2l6ZU9ic2VydmVyIGFuZCBmYWxsIGJhY2sgdG8gdGhlIGlmcmFtZSBmYWxsYmFjay5cbiAgICovXG4gIGZ1bmN0aW9uIFJlc2l6ZU1hbmFnZXIocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzaXplTWFuYWdlcik7XG5cbiAgICB2YXIgUkVTSVpFX09CU0VSVkVSX0FWQUlMQUJMRSA9IG9wdGlvbnMuUmVzaXplT2JzZXJ2ZXIgfHwgd2luZG93JDEuUmVzaXplT2JzZXJ2ZXI7XG5cbiAgICAvLyBpZiBgbnVsbGAgd2FzIHBhc3NlZCwgd2Ugd2FudCB0byBkaXNhYmxlIHRoZSBSZXNpemVPYnNlcnZlclxuICAgIGlmIChvcHRpb25zLlJlc2l6ZU9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICBSRVNJWkVfT0JTRVJWRVJfQVZBSUxBQkxFID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gT25seSBjcmVhdGUgYW4gZWxlbWVudCB3aGVuIFJlc2l6ZU9ic2VydmVyIGlzbid0IGF2YWlsYWJsZVxuICAgIHZhciBvcHRpb25zXyA9IG1lcmdlT3B0aW9ucyh7IGNyZWF0ZUVsOiAhUkVTSVpFX09CU0VSVkVSX0FWQUlMQUJMRSB9LCBvcHRpb25zKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9uc18pKTtcblxuICAgIF90aGlzLlJlc2l6ZU9ic2VydmVyID0gb3B0aW9ucy5SZXNpemVPYnNlcnZlciB8fCB3aW5kb3ckMS5SZXNpemVPYnNlcnZlcjtcbiAgICBfdGhpcy5sb2FkTGlzdGVuZXJfID0gbnVsbDtcbiAgICBfdGhpcy5yZXNpemVPYnNlcnZlcl8gPSBudWxsO1xuICAgIF90aGlzLmRlYm91bmNlZEhhbmRsZXJfID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucmVzaXplSGFuZGxlcigpO1xuICAgIH0sIDEwMCwgZmFsc2UsIHBsYXllcik7XG5cbiAgICBpZiAoUkVTSVpFX09CU0VSVkVSX0FWQUlMQUJMRSkge1xuICAgICAgX3RoaXMucmVzaXplT2JzZXJ2ZXJfID0gbmV3IF90aGlzLlJlc2l6ZU9ic2VydmVyKF90aGlzLmRlYm91bmNlZEhhbmRsZXJfKTtcbiAgICAgIF90aGlzLnJlc2l6ZU9ic2VydmVyXy5vYnNlcnZlKHBsYXllci5lbCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMubG9hZExpc3RlbmVyXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLmVsXy5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgb24oX3RoaXMuZWxfLmNvbnRlbnRXaW5kb3csICdyZXNpemUnLCBfdGhpcy5kZWJvdW5jZWRIYW5kbGVyXyk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMub2ZmKCdsb2FkJywgX3RoaXMubG9hZExpc3RlbmVyXyk7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5vbignbG9hZCcsIF90aGlzLmxvYWRMaXN0ZW5lcl8pO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBSZXNpemVNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdpZnJhbWUnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcmVzaXplLW1hbmFnZXInXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgcmVzaXplIGlzIHRyaWdnZXJlZCBvbiB0aGUgaWZyYW1lIG9yIGEgcmVzaXplIGlzIG9ic2VydmVkIHZpYSB0aGUgUmVzaXplT2JzZXJ2ZXJcbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNwbGF5ZXJyZXNpemVcbiAgICovXG5cblxuICBSZXNpemVNYW5hZ2VyLnByb3RvdHlwZS5yZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gcmVzaXplSGFuZGxlcigpIHtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcGxheWVyIHNpemUgaGFzIGNoYW5nZWRcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcGxheWVycmVzaXplXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMucGxheWVyXy50cmlnZ2VyKCdwbGF5ZXJyZXNpemUnKTtcbiAgfTtcblxuICBSZXNpemVNYW5hZ2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcl8pIHtcbiAgICAgIGlmICh0aGlzLnBsYXllcl8uZWwoKSkge1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyXy51bm9ic2VydmUodGhpcy5wbGF5ZXJfLmVsKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlcl8uZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsXyAmJiB0aGlzLmVsXy5jb250ZW50V2luZG93KSB7XG4gICAgICBvZmYodGhpcy5lbF8uY29udGVudFdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuZGVib3VuY2VkSGFuZGxlcl8pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxvYWRMaXN0ZW5lcl8pIHtcbiAgICAgIHRoaXMub2ZmKCdsb2FkJywgdGhpcy5sb2FkTGlzdGVuZXJfKTtcbiAgICB9XG5cbiAgICB0aGlzLlJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICB0aGlzLmRlYm91bmNlZEhhbmRsZXJfID0gbnVsbDtcbiAgICB0aGlzLmxvYWRMaXN0ZW5lcl8gPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSZXNpemVNYW5hZ2VyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1Jlc2l6ZU1hbmFnZXInLCBSZXNpemVNYW5hZ2VyKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZmlyZSBhIHNvdXJjZXNldCB3aGVuIHRoZXJlIGlzIHNvbWV0aGluZ1xuICogc2ltaWxhciB0byBgbWVkaWFFbC5sb2FkKClgIGJlaW5nIGNhbGxlZC4gSXQgd2lsbCB0cnkgdG8gZmluZCB0aGUgc291cmNlIHZpYVxuICogdGhlIGBzcmNgIGF0dHJpYnV0ZSBhbmQgdGhlbiB0aGUgYDxzb3VyY2U+YCBlbGVtZW50cy4gSXQgd2lsbCB0aGVuIGZpcmUgYHNvdXJjZXNldGBcbiAqIHdpdGggdGhlIHNvdXJjZSB0aGF0IHdhcyBmb3VuZCBvciBlbXB0eSBzdHJpbmcgaWYgd2UgY2Fubm90IGtub3cuIElmIGl0IGNhbm5vdFxuICogZmluZCBhIHNvdXJjZSB0aGVuIGBzb3VyY2VzZXRgIHdpbGwgbm90IGJlIGZpcmVkLlxuICpcbiAqIEBwYXJhbSB7SHRtbDV9IHRlY2hcbiAqICAgICAgICBUaGUgdGVjaCBvYmplY3QgdGhhdCBzb3VyY2VzZXQgd2FzIHNldHVwIG9uXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgcmV0dXJucyBmYWxzZSBpZiB0aGUgc291cmNlc2V0IHdhcyBub3QgZmlyZWQgYW5kIHRydWUgb3RoZXJ3aXNlLlxuICovXG52YXIgc291cmNlc2V0TG9hZCA9IGZ1bmN0aW9uIHNvdXJjZXNldExvYWQodGVjaCkge1xuICB2YXIgZWwgPSB0ZWNoLmVsKCk7XG5cbiAgLy8gaWYgYGVsLnNyY2AgaXMgc2V0LCB0aGF0IHNvdXJjZSB3aWxsIGJlIGxvYWRlZC5cbiAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnc3JjJykpIHtcbiAgICB0ZWNoLnRyaWdnZXJTb3VyY2VzZXQoZWwuc3JjKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW5jZSB0aGVyZSBpc24ndCBhIHNyYyBwcm9wZXJ0eSBvbiB0aGUgbWVkaWEgZWxlbWVudCwgc291cmNlIGVsZW1lbnRzIHdpbGwgYmUgdXNlZCBmb3JcbiAgICogaW1wbGVtZW50aW5nIHRoZSBzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobS4gVGhpcyBoYXBwZW5zIGFzeW5jaHJvbm91c2x5IGFuZFxuICAgKiBmb3IgbW9zdCBjYXNlcyB3ZXJlIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgc291cmNlIHdlIGNhbm5vdCB0ZWxsIHdoYXQgc291cmNlIHdpbGxcbiAgICogYmUgbG9hZGVkLCB3aXRob3V0IHJlLWltcGxlbWVudGluZyB0aGUgc291cmNlIHNlbGVjdGlvbiBhbGdvcml0aG0uIEF0IHRoaXMgdGltZSB3ZSBhcmUgbm90XG4gICAqIGdvaW5nIHRvIGRvIHRoYXQuIFRoZXJlIGFyZSB0aHJlZSBzcGVjaWFsIGNhc2VzIHRoYXQgd2UgZG8gaGFuZGxlIGhlcmUgdGhvdWdoOlxuICAgKlxuICAgKiAxLiBJZiB0aGVyZSBhcmUgbm8gc291cmNlcywgZG8gbm90IGZpcmUgYHNvdXJjZXNldGAuXG4gICAqIDIuIElmIHRoZXJlIGlzIG9ubHkgb25lIGA8c291cmNlPmAgd2l0aCBhIGBzcmNgIHByb3BlcnR5L2F0dHJpYnV0ZSB0aGF0IGlzIG91ciBgc3JjYFxuICAgKiAzLiBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGA8c291cmNlPmAgYnV0IGFsbCBvZiB0aGVtIGhhdmUgdGhlIHNhbWUgYHNyY2AgdXJsLlxuICAgKiAgICBUaGF0IHdpbGwgYmUgb3VyIHNyYy5cbiAgICovXG4gIHZhciBzb3VyY2VzID0gdGVjaC4kJCgnc291cmNlJyk7XG4gIHZhciBzcmNVcmxzID0gW107XG4gIHZhciBzcmMgPSAnJztcblxuICAvLyBpZiB0aGVyZSBhcmUgbm8gc291cmNlcywgZG8gbm90IGZpcmUgc291cmNlc2V0XG4gIGlmICghc291cmNlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBvbmx5IGNvdW50IHZhbGlkL25vbi1kdXBsaWNhdGUgc291cmNlIGVsZW1lbnRzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB1cmwgPSBzb3VyY2VzW2ldLnNyYztcblxuICAgIGlmICh1cmwgJiYgc3JjVXJscy5pbmRleE9mKHVybCkgPT09IC0xKSB7XG4gICAgICBzcmNVcmxzLnB1c2godXJsKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGVyZSB3ZXJlIG5vIHZhbGlkIHNvdXJjZXNcbiAgaWYgKCFzcmNVcmxzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHRoZXJlIGlzIG9ubHkgb25lIHZhbGlkIHNvdXJjZSBlbGVtZW50IHVybFxuICAvLyB1c2UgdGhhdFxuICBpZiAoc3JjVXJscy5sZW5ndGggPT09IDEpIHtcbiAgICBzcmMgPSBzcmNVcmxzWzBdO1xuICB9XG5cbiAgdGVjaC50cmlnZ2VyU291cmNlc2V0KHNyYyk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBvdXIgaW1wbGVtZW50YXRpb24gb2YgYW4gYGlubmVySFRNTGAgZGVzY3JpcHRvciBmb3IgYnJvd3NlcnNcbiAqIHRoYXQgZG8gbm90IGhhdmUgb25lLlxuICovXG52YXIgaW5uZXJIVE1MRGVzY3JpcHRvclBvbHlmaWxsID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnaW5uZXJIVE1MJywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZU5vZGUodHJ1ZSkuaW5uZXJIVE1MO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2KSB7XG4gICAgLy8gbWFrZSBhIGR1bW15IG5vZGUgdG8gdXNlIGlubmVySFRNTCBvblxuICAgIHZhciBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcblxuICAgIC8vIHNldCBpbm5lckhUTUwgdG8gdGhlIHZhbHVlIHByb3ZpZGVkXG4gICAgZHVtbXkuaW5uZXJIVE1MID0gdjtcblxuICAgIC8vIG1ha2UgYSBkb2N1bWVudCBmcmFnbWVudCB0byBob2xkIHRoZSBub2RlcyBmcm9tIGR1bW15XG4gICAgdmFyIGRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICAvLyBjb3B5IGFsbCBvZiB0aGUgbm9kZXMgY3JlYXRlZCBieSB0aGUgaW5uZXJIVE1MIG9uIGR1bW15XG4gICAgLy8gdG8gdGhlIGRvY3VtZW50IGZyYWdtZW50XG4gICAgd2hpbGUgKGR1bW15LmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBkb2NGcmFnLmFwcGVuZENoaWxkKGR1bW15LmNoaWxkTm9kZXNbMF0pO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBjb250ZW50XG4gICAgdGhpcy5pbm5lclRleHQgPSAnJztcblxuICAgIC8vIG5vdyB3ZSBhZGQgYWxsIG9mIHRoYXQgaHRtbCBpbiBvbmUgYnkgYXBwZW5kaW5nIHRoZVxuICAgIC8vIGRvY3VtZW50IGZyYWdtZW50LiBUaGlzIGlzIGhvdyBpbm5lckhUTUwgZG9lcyBpdC5cbiAgICB3aW5kb3ckMS5FbGVtZW50LnByb3RvdHlwZS5hcHBlbmRDaGlsZC5jYWxsKHRoaXMsIGRvY0ZyYWcpO1xuXG4gICAgLy8gdGhlbiByZXR1cm4gdGhlIHJlc3VsdCB0aGF0IGlubmVySFRNTCdzIHNldHRlciB3b3VsZFxuICAgIHJldHVybiB0aGlzLmlubmVySFRNTDtcbiAgfVxufSk7XG5cbi8qKlxuICogR2V0IGEgcHJvcGVydHkgZGVzY3JpcHRvciBnaXZlbiBhIGxpc3Qgb2YgcHJpb3JpdGllcyBhbmQgdGhlXG4gKiBwcm9wZXJ0eSB0byBnZXQuXG4gKi9cbnZhciBnZXREZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0RGVzY3JpcHRvcihwcmlvcml0eSwgcHJvcCkge1xuICB2YXIgZGVzY3JpcHRvciA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpb3JpdHkubGVuZ3RoOyBpKyspIHtcbiAgICBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcmlvcml0eVtpXSwgcHJvcCk7XG5cbiAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnNldCAmJiBkZXNjcmlwdG9yLmdldCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuXG4gIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxudmFyIGdldElubmVySFRNTERlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRJbm5lckhUTUxEZXNjcmlwdG9yKHRlY2gpIHtcbiAgcmV0dXJuIGdldERlc2NyaXB0b3IoW3RlY2guZWwoKSwgd2luZG93JDEuSFRNTE1lZGlhRWxlbWVudC5wcm90b3R5cGUsIHdpbmRvdyQxLkVsZW1lbnQucHJvdG90eXBlLCBpbm5lckhUTUxEZXNjcmlwdG9yUG9seWZpbGxdLCAnaW5uZXJIVE1MJyk7XG59O1xuXG4vKipcbiAqIFBhdGNoZXMgYnJvd3NlciBpbnRlcm5hbCBmdW5jdGlvbnMgc28gdGhhdCB3ZSBjYW4gdGVsbCBzeW5jaHJvbm91c2x5XG4gKiBpZiBhIGA8c291cmNlPmAgd2FzIGFwcGVuZGVkIHRvIHRoZSBtZWRpYSBlbGVtZW50LiBGb3Igc29tZSByZWFzb24gdGhpc1xuICogY2F1c2VzIGEgYHNvdXJjZXNldGAgaWYgdGhlIHRoZSBtZWRpYSBlbGVtZW50IGlzIHJlYWR5IGFuZCBoYXMgbm8gc291cmNlLlxuICogVGhpcyBoYXBwZW5zIHdoZW46XG4gKiAtIFRoZSBwYWdlIGhhcyBqdXN0IGxvYWRlZCBhbmQgdGhlIG1lZGlhIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhIHNvdXJjZS5cbiAqIC0gVGhlIG1lZGlhIGVsZW1lbnQgd2FzIGVtcHRpZWQgb2YgYWxsIHNvdXJjZXMsIHRoZW4gYGxvYWQoKWAgd2FzIGNhbGxlZC5cbiAqXG4gKiBJdCBkb2VzIHRoaXMgYnkgcGF0Y2hpbmcgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMvcHJvcGVydGllcyB3aGVuIHRoZXkgYXJlIHN1cHBvcnRlZDpcbiAqXG4gKiAtIGBhcHBlbmQoKWAgLSBjYW4gYmUgdXNlZCB0byBhZGQgYSBgPHNvdXJjZT5gIGVsZW1lbnQgdG8gdGhlIG1lZGlhIGVsZW1lbnRcbiAqIC0gYGFwcGVuZENoaWxkKClgIC0gY2FuIGJlIHVzZWQgdG8gYWRkIGEgYDxzb3VyY2U+YCBlbGVtZW50IHRvIHRoZSBtZWRpYSBlbGVtZW50XG4gKiAtIGBpbnNlcnRBZGphY2VudEhUTUwoKWAgLSAgY2FuIGJlIHVzZWQgdG8gYWRkIGEgYDxzb3VyY2U+YCBlbGVtZW50IHRvIHRoZSBtZWRpYSBlbGVtZW50XG4gKiAtIGBpbm5lckhUTUxgIC0gIGNhbiBiZSB1c2VkIHRvIGFkZCBhIGA8c291cmNlPmAgZWxlbWVudCB0byB0aGUgbWVkaWEgZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7SHRtbDV9IHRlY2hcbiAqICAgICAgICBUaGUgdGVjaCBvYmplY3QgdGhhdCBzb3VyY2VzZXQgaXMgYmVpbmcgc2V0dXAgb24uXG4gKi9cbnZhciBmaXJzdFNvdXJjZVdhdGNoID0gZnVuY3Rpb24gZmlyc3RTb3VyY2VXYXRjaCh0ZWNoKSB7XG4gIHZhciBlbCA9IHRlY2guZWwoKTtcblxuICAvLyBtYWtlIHN1cmUgZmlyc3RTb3VyY2VXYXRjaCBpc24ndCBzZXR1cCB0d2ljZS5cbiAgaWYgKGVsLnJlc2V0U291cmNlV2F0Y2hfKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9sZCA9IHt9O1xuICB2YXIgaW5uZXJEZXNjcmlwdG9yID0gZ2V0SW5uZXJIVE1MRGVzY3JpcHRvcih0ZWNoKTtcbiAgdmFyIGFwcGVuZFdyYXBwZXIgPSBmdW5jdGlvbiBhcHBlbmRXcmFwcGVyKGFwcGVuZEZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciByZXR2YWwgPSBhcHBlbmRGbi5hcHBseShlbCwgYXJncyk7XG5cbiAgICAgIHNvdXJjZXNldExvYWQodGVjaCk7XG5cbiAgICAgIHJldHVybiByZXR2YWw7XG4gICAgfTtcbiAgfTtcblxuICBbJ2FwcGVuZCcsICdhcHBlbmRDaGlsZCcsICdpbnNlcnRBZGphY2VudEhUTUwnXS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKCFlbFtrXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN0b3JlIHRoZSBvbGQgZnVuY3Rpb25cbiAgICBvbGRba10gPSBlbFtrXTtcblxuICAgIC8vIGNhbGwgdGhlIG9sZCBmdW5jdGlvbiB3aXRoIGEgc291cmNlc2V0IGlmIGEgc291cmNlXG4gICAgLy8gd2FzIGxvYWRlZFxuICAgIGVsW2tdID0gYXBwZW5kV3JhcHBlcihvbGRba10pO1xuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdpbm5lckhUTUwnLCBtZXJnZU9wdGlvbnMoaW5uZXJEZXNjcmlwdG9yLCB7XG4gICAgc2V0OiBhcHBlbmRXcmFwcGVyKGlubmVyRGVzY3JpcHRvci5zZXQpXG4gIH0pKTtcblxuICBlbC5yZXNldFNvdXJjZVdhdGNoXyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZXNldFNvdXJjZVdhdGNoXyA9IG51bGw7XG4gICAgT2JqZWN0LmtleXMob2xkKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBlbFtrXSA9IG9sZFtrXTtcbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgJ2lubmVySFRNTCcsIGlubmVyRGVzY3JpcHRvcik7XG4gIH07XG5cbiAgLy8gb24gdGhlIGZpcnN0IHNvdXJjZXNldCwgd2UgbmVlZCB0byByZXZlcnQgb3VyIGNoYW5nZXNcbiAgdGVjaC5vbmUoJ3NvdXJjZXNldCcsIGVsLnJlc2V0U291cmNlV2F0Y2hfKTtcbn07XG5cbi8qKlxuICogb3VyIGltcGxlbWVudGF0aW9uIG9mIGEgYHNyY2AgZGVzY3JpcHRvciBmb3IgYnJvd3NlcnNcbiAqIHRoYXQgZG8gbm90IGhhdmUgb25lLlxuICovXG52YXIgc3JjRGVzY3JpcHRvclBvbHlmaWxsID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnc3JjJywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3NyYycpKSB7XG4gICAgICByZXR1cm4gZ2V0QWJzb2x1dGVVUkwod2luZG93JDEuRWxlbWVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgJ3NyYycpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHYpIHtcbiAgICB3aW5kb3ckMS5FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCAnc3JjJywgdik7XG5cbiAgICByZXR1cm4gdjtcbiAgfVxufSk7XG5cbnZhciBnZXRTcmNEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0U3JjRGVzY3JpcHRvcih0ZWNoKSB7XG4gIHJldHVybiBnZXREZXNjcmlwdG9yKFt0ZWNoLmVsKCksIHdpbmRvdyQxLkhUTUxNZWRpYUVsZW1lbnQucHJvdG90eXBlLCBzcmNEZXNjcmlwdG9yUG9seWZpbGxdLCAnc3JjJyk7XG59O1xuXG4vKipcbiAqIHNldHVwIGBzb3VyY2VzZXRgIGhhbmRsaW5nIG9uIHRoZSBgSHRtbDVgIHRlY2guIFRoaXMgZnVuY3Rpb25cbiAqIHBhdGNoZXMgdGhlIGZvbGxvd2luZyBlbGVtZW50IHByb3BlcnRpZXMvZnVuY3Rpb25zOlxuICpcbiAqIC0gYHNyY2AgLSB0byBkZXRlcm1pbmUgd2hlbiBgc3JjYCBpcyBzZXRcbiAqIC0gYHNldEF0dHJpYnV0ZSgpYCAtIHRvIGRldGVybWluZSB3aGVuIGBzcmNgIGlzIHNldFxuICogLSBgbG9hZCgpYCAtIHRoaXMgcmUtdHJpZ2dlcnMgdGhlIHNvdXJjZSBzZWxlY3Rpb24gYWxnb3JpdGhtLCBhbmQgY2FuXG4gKiAgICAgICAgICAgICAgY2F1c2UgYSBzb3VyY2VzZXQuXG4gKlxuICogSWYgdGhlcmUgaXMgbm8gc291cmNlIHdoZW4gd2UgYXJlIGFkZGluZyBgc291cmNlc2V0YCBzdXBwb3J0IG9yIGR1cmluZyBhIGBsb2FkKClgXG4gKiB3ZSBhbHNvIHBhdGNoIHRoZSBmdW5jdGlvbnMgbGlzdGVkIGluIGBmaXJzdFNvdXJjZVdhdGNoYC5cbiAqXG4gKiBAcGFyYW0ge0h0bWw1fSB0ZWNoXG4gKiAgICAgICAgVGhlIHRlY2ggdG8gcGF0Y2hcbiAqL1xudmFyIHNldHVwU291cmNlc2V0ID0gZnVuY3Rpb24gc2V0dXBTb3VyY2VzZXQodGVjaCkge1xuICBpZiAoIXRlY2guZmVhdHVyZXNTb3VyY2VzZXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZWwgPSB0ZWNoLmVsKCk7XG5cbiAgLy8gbWFrZSBzdXJlIHNvdXJjZXNldCBpc24ndCBzZXR1cCB0d2ljZS5cbiAgaWYgKGVsLnJlc2V0U291cmNlc2V0Xykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzcmNEZXNjcmlwdG9yID0gZ2V0U3JjRGVzY3JpcHRvcih0ZWNoKTtcbiAgdmFyIG9sZFNldEF0dHJpYnV0ZSA9IGVsLnNldEF0dHJpYnV0ZTtcbiAgdmFyIG9sZExvYWQgPSBlbC5sb2FkO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgJ3NyYycsIG1lcmdlT3B0aW9ucyhzcmNEZXNjcmlwdG9yLCB7XG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodikge1xuICAgICAgdmFyIHJldHZhbCA9IHNyY0Rlc2NyaXB0b3Iuc2V0LmNhbGwoZWwsIHYpO1xuXG4gICAgICAvLyB3ZSB1c2UgdGhlIGdldHRlciBoZXJlIHRvIGdldCB0aGUgYWN0dWFsIHZhbHVlIHNldCBvbiBzcmNcbiAgICAgIHRlY2gudHJpZ2dlclNvdXJjZXNldChlbC5zcmMpO1xuXG4gICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH1cbiAgfSkpO1xuXG4gIGVsLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuLCB2KSB7XG4gICAgdmFyIHJldHZhbCA9IG9sZFNldEF0dHJpYnV0ZS5jYWxsKGVsLCBuLCB2KTtcblxuICAgIGlmICgvc3JjL2kudGVzdChuKSkge1xuICAgICAgdGVjaC50cmlnZ2VyU291cmNlc2V0KGVsLnNyYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHZhbDtcbiAgfTtcblxuICBlbC5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXR2YWwgPSBvbGRMb2FkLmNhbGwoZWwpO1xuXG4gICAgLy8gaWYgbG9hZCB3YXMgY2FsbGVkLCBidXQgdGhlcmUgd2FzIG5vIHNvdXJjZSB0byBmaXJlXG4gICAgLy8gc291cmNlc2V0IG9uLiBXZSBoYXZlIHRvIHdhdGNoIGZvciBhIHNvdXJjZSBhcHBlbmRcbiAgICAvLyBhcyB0aGF0IGNhbiB0cmlnZ2VyIGEgYHNvdXJjZXNldGAgd2hlbiB0aGUgbWVkaWEgZWxlbWVudFxuICAgIC8vIGhhcyBubyBzb3VyY2VcbiAgICBpZiAoIXNvdXJjZXNldExvYWQodGVjaCkpIHtcbiAgICAgIHRlY2gudHJpZ2dlclNvdXJjZXNldCgnJyk7XG4gICAgICBmaXJzdFNvdXJjZVdhdGNoKHRlY2gpO1xuICAgIH1cblxuICAgIHJldHVybiByZXR2YWw7XG4gIH07XG5cbiAgaWYgKGVsLmN1cnJlbnRTcmMpIHtcbiAgICB0ZWNoLnRyaWdnZXJTb3VyY2VzZXQoZWwuY3VycmVudFNyYyk7XG4gIH0gZWxzZSBpZiAoIXNvdXJjZXNldExvYWQodGVjaCkpIHtcbiAgICBmaXJzdFNvdXJjZVdhdGNoKHRlY2gpO1xuICB9XG5cbiAgZWwucmVzZXRTb3VyY2VzZXRfID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlc2V0U291cmNlc2V0XyA9IG51bGw7XG4gICAgZWwubG9hZCA9IG9sZExvYWQ7XG4gICAgZWwuc2V0QXR0cmlidXRlID0gb2xkU2V0QXR0cmlidXRlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgJ3NyYycsIHNyY0Rlc2NyaXB0b3IpO1xuICAgIGlmIChlbC5yZXNldFNvdXJjZVdhdGNoXykge1xuICAgICAgZWwucmVzZXRTb3VyY2VXYXRjaF8oKTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgX3RlbXBsYXRlT2JqZWN0JDEgPSB0YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZShbJ1RleHQgVHJhY2tzIGFyZSBiZWluZyBsb2FkZWQgZnJvbSBhbm90aGVyIG9yaWdpbiBidXQgdGhlIGNyb3Nzb3JpZ2luIGF0dHJpYnV0ZSBpc25cXCd0IHVzZWQuXFxuICAgICAgICAgICAgVGhpcyBtYXkgcHJldmVudCB0ZXh0IHRyYWNrcyBmcm9tIGxvYWRpbmcuJ10sIFsnVGV4dCBUcmFja3MgYXJlIGJlaW5nIGxvYWRlZCBmcm9tIGFub3RoZXIgb3JpZ2luIGJ1dCB0aGUgY3Jvc3NvcmlnaW4gYXR0cmlidXRlIGlzblxcJ3QgdXNlZC5cXG4gICAgICAgICAgICBUaGlzIG1heSBwcmV2ZW50IHRleHQgdHJhY2tzIGZyb20gbG9hZGluZy4nXSk7XG5cbi8qKlxuICogSFRNTDUgTWVkaWEgQ29udHJvbGxlciAtIFdyYXBwZXIgZm9yIEhUTUw1IE1lZGlhIEFQSVxuICpcbiAqIEBtaXhlcyBUZWNoflNvdXJjZUhhbmRsZXJBZGRpdGlvbnNcbiAqIEBleHRlbmRzIFRlY2hcbiAqL1xuXG52YXIgSHRtbDUgPSBmdW5jdGlvbiAoX1RlY2gpIHtcbiAgaW5oZXJpdHMoSHRtbDUsIF9UZWNoKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgVGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gcmVhZHlcbiAgICogICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgYEhUTUw1YCBUZWNoIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gSHRtbDUob3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sNSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZWNoLmNhbGwodGhpcywgb3B0aW9ucywgcmVhZHkpKTtcblxuICAgIHZhciBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcbiAgICB2YXIgY3Jvc3NvcmlnaW5UcmFja3MgPSBmYWxzZTtcblxuICAgIC8vIFNldCB0aGUgc291cmNlIGlmIG9uZSBpcyBwcm92aWRlZFxuICAgIC8vIDEpIENoZWNrIGlmIHRoZSBzb3VyY2UgaXMgbmV3IChpZiBub3QsIHdlIHdhbnQgdG8ga2VlcCB0aGUgb3JpZ2luYWwgc28gcGxheWJhY2sgaXNuJ3QgaW50ZXJydXB0ZWQpXG4gICAgLy8gMikgQ2hlY2sgdG8gc2VlIGlmIHRoZSBuZXR3b3JrIHN0YXRlIG9mIHRoZSB0YWcgd2FzIGZhaWxlZCBhdCBpbml0LCBhbmQgaWYgc28sIHJlc2V0IHRoZSBzb3VyY2VcbiAgICAvLyBhbnl3YXkgc28gdGhlIGVycm9yIGdldHMgZmlyZWQuXG4gICAgaWYgKHNvdXJjZSAmJiAoX3RoaXMuZWxfLmN1cnJlbnRTcmMgIT09IHNvdXJjZS5zcmMgfHwgb3B0aW9ucy50YWcgJiYgb3B0aW9ucy50YWcuaW5pdE5ldHdvcmtTdGF0ZV8gPT09IDMpKSB7XG4gICAgICBfdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuaGFuZGxlTGF0ZUluaXRfKF90aGlzLmVsXyk7XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgc291cmNlc2V0IGFmdGVyIGxhdGUgc291cmNlc2V0L2luaXRcbiAgICBpZiAob3B0aW9ucy5lbmFibGVTb3VyY2VzZXQpIHtcbiAgICAgIF90aGlzLnNldHVwU291cmNlc2V0SGFuZGxpbmdfKCk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmVsXy5oYXNDaGlsZE5vZGVzKCkpIHtcblxuICAgICAgdmFyIG5vZGVzID0gX3RoaXMuZWxfLmNoaWxkTm9kZXM7XG4gICAgICB2YXIgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgcmVtb3ZlTm9kZXMgPSBbXTtcblxuICAgICAgd2hpbGUgKG5vZGVzTGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tub2Rlc0xlbmd0aF07XG4gICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICd0cmFjaycpIHtcbiAgICAgICAgICBpZiAoIV90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgICAgICAgLy8gRW1wdHkgdmlkZW8gdGFnIHRyYWNrcyBzbyB0aGUgYnVpbHQtaW4gcGxheWVyIGRvZXNuJ3QgdXNlIHRoZW0gYWxzby5cbiAgICAgICAgICAgIC8vIFRoaXMgbWF5IG5vdCBiZSBmYXN0IGVub3VnaCB0byBzdG9wIEhUTUw1IGJyb3dzZXJzIGZyb20gcmVhZGluZyB0aGUgdGFnc1xuICAgICAgICAgICAgLy8gc28gd2UnbGwgbmVlZCB0byB0dXJuIG9mZiBhbnkgZGVmYXVsdCB0cmFja3MgaWYgd2UncmUgbWFudWFsbHkgZG9pbmdcbiAgICAgICAgICAgIC8vIGNhcHRpb25zIGFuZCBzdWJ0aXRsZXMuIHZpZGVvRWxlbWVudC50ZXh0VHJhY2tzXG4gICAgICAgICAgICByZW1vdmVOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzdG9yZSBIVE1MVHJhY2tFbGVtZW50IGFuZCBUZXh0VHJhY2sgdG8gcmVtb3RlIGxpc3RcbiAgICAgICAgICAgIF90aGlzLnJlbW90ZVRleHRUcmFja0VscygpLmFkZFRyYWNrRWxlbWVudF8obm9kZSk7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkuYWRkVHJhY2sobm9kZS50cmFjayk7XG4gICAgICAgICAgICBfdGhpcy50ZXh0VHJhY2tzKCkuYWRkVHJhY2sobm9kZS50cmFjayk7XG4gICAgICAgICAgICBpZiAoIWNyb3Nzb3JpZ2luVHJhY2tzICYmICFfdGhpcy5lbF8uaGFzQXR0cmlidXRlKCdjcm9zc29yaWdpbicpICYmIGlzQ3Jvc3NPcmlnaW4obm9kZS5zcmMpKSB7XG4gICAgICAgICAgICAgIGNyb3Nzb3JpZ2luVHJhY2tzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdmVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfdGhpcy5lbF8ucmVtb3ZlQ2hpbGQocmVtb3ZlTm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzLnByb3h5TmF0aXZlVHJhY2tzXygpO1xuICAgIGlmIChfdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgJiYgY3Jvc3NvcmlnaW5UcmFja3MpIHtcbiAgICAgIGxvZyQxLndhcm4odHNtbChfdGVtcGxhdGVPYmplY3QkMSkpO1xuICAgIH1cblxuICAgIC8vIHByZXZlbnQgaU9TIFNhZmFyaSBmcm9tIGRpc2FibGluZyBtZXRhZGF0YSB0ZXh0IHRyYWNrcyBkdXJpbmcgbmF0aXZlIHBsYXliYWNrXG4gICAgX3RoaXMucmVzdG9yZU1ldGFkYXRhVHJhY2tzSW5JT1NOYXRpdmVQbGF5ZXJfKCk7XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgbmF0aXZlIGNvbnRyb2xzIHNob3VsZCBiZSB1c2VkXG4gICAgLy8gT3VyIGdvYWwgc2hvdWxkIGJlIHRvIGdldCB0aGUgY3VzdG9tIGNvbnRyb2xzIG9uIG1vYmlsZSBzb2xpZCBldmVyeXdoZXJlXG4gICAgLy8gc28gd2UgY2FuIHJlbW92ZSB0aGlzIGFsbCB0b2dldGhlci4gUmlnaHQgbm93IHRoaXMgd2lsbCBibG9jayBjdXN0b21cbiAgICAvLyBjb250cm9scyBvbiB0b3VjaCBlbmFibGVkIGxhcHRvcHMgbGlrZSB0aGUgQ2hyb21lIFBpeGVsXG4gICAgaWYgKChUT1VDSF9FTkFCTEVEIHx8IElTX0lQSE9ORSB8fCBJU19OQVRJVkVfQU5EUk9JRCkgJiYgb3B0aW9ucy5uYXRpdmVDb250cm9sc0ZvclRvdWNoID09PSB0cnVlKSB7XG4gICAgICBfdGhpcy5zZXRDb250cm9scyh0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBvbiBpT1MsIHdlIHdhbnQgdG8gcHJveHkgYHdlYmtpdGJlZ2luZnVsbHNjcmVlbmAgYW5kIGB3ZWJraXRlbmRmdWxsc2NyZWVuYFxuICAgIC8vIGludG8gYSBgZnVsbHNjcmVlbmNoYW5nZWAgZXZlbnRcbiAgICBfdGhpcy5wcm94eVdlYmtpdEZ1bGxzY3JlZW5fKCk7XG5cbiAgICBfdGhpcy50cmlnZ2VyUmVhZHkoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZSBvZiBgSFRNTDVgIG1lZGlhIGVsZW1lbnQgYW5kIHJlbW92ZSBhbGwgdHJhY2tzLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5lbF8gJiYgdGhpcy5lbF8ucmVzZXRTb3VyY2VzZXRfKSB7XG4gICAgICB0aGlzLmVsXy5yZXNldFNvdXJjZXNldF8oKTtcbiAgICB9XG4gICAgSHRtbDUuZGlzcG9zZU1lZGlhRWxlbWVudCh0aGlzLmVsXyk7XG4gICAgdGhpcy5vcHRpb25zXyA9IG51bGw7XG5cbiAgICAvLyB0ZWNoIHdpbGwgaGFuZGxlIGNsZWFyaW5nIG9mIHRoZSBlbXVsYXRlZCB0cmFjayBsaXN0XG4gICAgX1RlY2gucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogTW9kaWZ5IHRoZSBtZWRpYSBlbGVtZW50IHNvIHRoYXQgd2UgY2FuIGRldGVjdCB3aGVuXG4gICAqIHRoZSBzb3VyY2UgaXMgY2hhbmdlZC4gRmlyZXMgYHNvdXJjZXNldGAganVzdCBhZnRlciB0aGUgc291cmNlIGhhcyBjaGFuZ2VkXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnNldHVwU291cmNlc2V0SGFuZGxpbmdfID0gZnVuY3Rpb24gc2V0dXBTb3VyY2VzZXRIYW5kbGluZ18oKSB7XG4gICAgc2V0dXBTb3VyY2VzZXQodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBjYXB0aW9ucyB0cmFjayBpcyBlbmFibGVkIGluIHRoZSBpT1MgU2FmYXJpIG5hdGl2ZSBwbGF5ZXIsIGFsbCBvdGhlclxuICAgKiB0cmFja3MgYXJlIGRpc2FibGVkIChpbmNsdWRpbmcgbWV0YWRhdGEgdHJhY2tzKSwgd2hpY2ggbnVsbHMgYWxsIG9mIHRoZWlyXG4gICAqIGFzc29jaWF0ZWQgY3VlIHBvaW50cy4gVGhpcyB3aWxsIHJlc3RvcmUgbWV0YWRhdGEgdHJhY2tzIHRvIHRoZWlyIHByZS1mdWxsc2NyZWVuXG4gICAqIHN0YXRlIGluIHRob3NlIGNhc2VzIHNvIHRoYXQgY3VlIHBvaW50cyBhcmUgbm90IG5lZWRsZXNzbHkgbG9zdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucmVzdG9yZU1ldGFkYXRhVHJhY2tzSW5JT1NOYXRpdmVQbGF5ZXJfID0gZnVuY3Rpb24gcmVzdG9yZU1ldGFkYXRhVHJhY2tzSW5JT1NOYXRpdmVQbGF5ZXJfKCkge1xuICAgIHZhciB0ZXh0VHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlID0gdm9pZCAwO1xuXG4gICAgLy8gY2FwdHVyZXMgYSBzbmFwc2hvdCBvZiBldmVyeSBtZXRhZGF0YSB0cmFjaydzIGN1cnJlbnQgc3RhdGVcbiAgICB2YXIgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCA9IGZ1bmN0aW9uIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QoKSB7XG4gICAgICBtZXRhZGF0YVRyYWNrc1ByZUZ1bGxzY3JlZW5TdGF0ZSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdGV4dFRyYWNrc1tpXTtcblxuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ21ldGFkYXRhJykge1xuICAgICAgICAgIG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlLnB1c2goe1xuICAgICAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICAgICAgc3RvcmVkTW9kZTogdHJhY2subW9kZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHNuYXBzaG90IGVhY2ggbWV0YWRhdGEgdHJhY2sncyBpbml0aWFsIHN0YXRlLCBhbmQgdXBkYXRlIHRoZSBzbmFwc2hvdFxuICAgIC8vIGVhY2ggdGltZSB0aGVyZSBpcyBhIHRyYWNrICdjaGFuZ2UnIGV2ZW50XG4gICAgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCgpO1xuICAgIHRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCk7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCk7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzdG9yZVRyYWNrTW9kZSA9IGZ1bmN0aW9uIHJlc3RvcmVUcmFja01vZGUoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdG9yZWRUcmFjayA9IG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlW2ldO1xuXG4gICAgICAgIGlmIChzdG9yZWRUcmFjay50cmFjay5tb2RlID09PSAnZGlzYWJsZWQnICYmIHN0b3JlZFRyYWNrLnRyYWNrLm1vZGUgIT09IHN0b3JlZFRyYWNrLnN0b3JlZE1vZGUpIHtcbiAgICAgICAgICBzdG9yZWRUcmFjay50cmFjay5tb2RlID0gc3RvcmVkVHJhY2suc3RvcmVkTW9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gd2Ugb25seSB3YW50IHRoaXMgaGFuZGxlciB0byBiZSBleGVjdXRlZCBvbiB0aGUgZmlyc3QgJ2NoYW5nZScgZXZlbnRcbiAgICAgIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcmVzdG9yZVRyYWNrTW9kZSk7XG4gICAgfTtcblxuICAgIC8vIHdoZW4gd2UgZW50ZXIgZnVsbHNjcmVlbiBwbGF5YmFjaywgc3RvcCB1cGRhdGluZyB0aGUgc25hcHNob3QgYW5kXG4gICAgLy8gcmVzdG9yZSBhbGwgdHJhY2sgbW9kZXMgdG8gdGhlaXIgcHJlLWZ1bGxzY3JlZW4gc3RhdGVcbiAgICB0aGlzLm9uKCd3ZWJraXRiZWdpbmZ1bGxzY3JlZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QpO1xuXG4gICAgICAvLyByZW1vdmUgdGhlIGxpc3RlbmVyIGJlZm9yZSBhZGRpbmcgaXQganVzdCBpbiBjYXNlIGl0IHdhc24ndCBwcmV2aW91c2x5IHJlbW92ZWRcbiAgICAgIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcmVzdG9yZVRyYWNrTW9kZSk7XG4gICAgICB0ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJlc3RvcmVUcmFja01vZGUpO1xuICAgIH0pO1xuXG4gICAgLy8gc3RhcnQgdXBkYXRpbmcgdGhlIHNuYXBzaG90IGFnYWluIGFmdGVyIGxlYXZpbmcgZnVsbHNjcmVlblxuICAgIHRoaXMub24oJ3dlYmtpdGVuZGZ1bGxzY3JlZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyByZW1vdmUgdGhlIGxpc3RlbmVyIGJlZm9yZSBhZGRpbmcgaXQganVzdCBpbiBjYXNlIGl0IHdhc24ndCBwcmV2aW91c2x5IHJlbW92ZWRcbiAgICAgIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCk7XG4gICAgICB0ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QpO1xuXG4gICAgICAvLyByZW1vdmUgdGhlIHJlc3RvcmVUcmFja01vZGUgaGFuZGxlciBpbiBjYXNlIGl0IHdhc24ndCB0cmlnZ2VyZWQgZHVyaW5nIGZ1bGxzY3JlZW4gcGxheWJhY2tcbiAgICAgIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcmVzdG9yZVRyYWNrTW9kZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gZm9yY2Ugb3ZlcnJpZGUgb2YgdHJhY2tzIGZvciB0aGUgZ2l2ZW4gdHlwZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRyYWNrIHR5cGUgdG8gb3ZlcnJpZGUsIHBvc3NpYmxlIHZhbHVlcyBpbmNsdWRlICdBdWRpbycsXG4gICAqICdWaWRlbycsIGFuZCAnVGV4dCcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3ZlcnJpZGUgLSBJZiBzZXQgdG8gdHJ1ZSBuYXRpdmUgYXVkaW8vdmlkZW8gd2lsbCBiZSBvdmVycmlkZGVuLFxuICAgKiBvdGhlcndpc2UgbmF0aXZlIGF1ZGlvL3ZpZGVvIHdpbGwgcG90ZW50aWFsbHkgYmUgdXNlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUub3ZlcnJpZGVOYXRpdmVfID0gZnVuY3Rpb24gb3ZlcnJpZGVOYXRpdmVfKHR5cGUsIG92ZXJyaWRlKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBiZWhhdmlvcmFsIGNoYW5nZSBkb24ndCBhZGQvcmVtb3ZlIGxpc3RlbmVyc1xuICAgIGlmIChvdmVycmlkZSAhPT0gdGhpc1snZmVhdHVyZXNOYXRpdmUnICsgdHlwZSArICdUcmFja3MnXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VUeXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKHRoaXNbbG93ZXJDYXNlVHlwZSArICdUcmFja3NMaXN0ZW5lcnNfJ10pIHtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXNbbG93ZXJDYXNlVHlwZSArICdUcmFja3NMaXN0ZW5lcnNfJ10pLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgZWxUcmFja3MgPSBfdGhpczIuZWwoKVtsb3dlckNhc2VUeXBlICsgJ1RyYWNrcyddO1xuXG4gICAgICAgIGVsVHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBfdGhpczJbbG93ZXJDYXNlVHlwZSArICdUcmFja3NMaXN0ZW5lcnNfJ11bZXZlbnROYW1lXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzWydmZWF0dXJlc05hdGl2ZScgKyB0eXBlICsgJ1RyYWNrcyddID0gIW92ZXJyaWRlO1xuICAgIHRoaXNbbG93ZXJDYXNlVHlwZSArICdUcmFja3NMaXN0ZW5lcnNfJ10gPSBudWxsO1xuXG4gICAgdGhpcy5wcm94eU5hdGl2ZVRyYWNrc0ZvclR5cGVfKGxvd2VyQ2FzZVR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGZvcmNlIG92ZXJyaWRlIG9mIG5hdGl2ZSBhdWRpbyB0cmFja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3ZlcnJpZGUgLSBJZiBzZXQgdG8gdHJ1ZSBuYXRpdmUgYXVkaW8gd2lsbCBiZSBvdmVycmlkZGVuLFxuICAgKiBvdGhlcndpc2UgbmF0aXZlIGF1ZGlvIHdpbGwgcG90ZW50aWFsbHkgYmUgdXNlZC5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUub3ZlcnJpZGVOYXRpdmVBdWRpb1RyYWNrcyA9IGZ1bmN0aW9uIG92ZXJyaWRlTmF0aXZlQXVkaW9UcmFja3Mob3ZlcnJpZGUpIHtcbiAgICB0aGlzLm92ZXJyaWRlTmF0aXZlXygnQXVkaW8nLCBvdmVycmlkZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gZm9yY2Ugb3ZlcnJpZGUgb2YgbmF0aXZlIHZpZGVvIHRyYWNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBvdmVycmlkZSAtIElmIHNldCB0byB0cnVlIG5hdGl2ZSB2aWRlbyB3aWxsIGJlIG92ZXJyaWRkZW4sXG4gICAqIG90aGVyd2lzZSBuYXRpdmUgdmlkZW8gd2lsbCBwb3RlbnRpYWxseSBiZSB1c2VkLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5vdmVycmlkZU5hdGl2ZVZpZGVvVHJhY2tzID0gZnVuY3Rpb24gb3ZlcnJpZGVOYXRpdmVWaWRlb1RyYWNrcyhvdmVycmlkZSkge1xuICAgIHRoaXMub3ZlcnJpZGVOYXRpdmVfKCdWaWRlbycsIG92ZXJyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICAqIFByb3h5IG5hdGl2ZSB0cmFjayBsaXN0IGV2ZW50cyBmb3IgdGhlIGdpdmVuIHR5cGUgdG8gb3VyIHRyYWNrXG4gICAgKiBsaXN0cyBpZiB0aGUgYnJvd3NlciB3ZSBhcmUgcGxheWluZyBpbiBzdXBwb3J0cyB0aGF0IHR5cGUgb2YgdHJhY2sgbGlzdC5cbiAgICAqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRyYWNrIHR5cGU7IHZhbHVlcyBpbmNsdWRlICdhdWRpbycsICd2aWRlbycsIGFuZCAndGV4dCdcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5wcm94eU5hdGl2ZVRyYWNrc0ZvclR5cGVfID0gZnVuY3Rpb24gcHJveHlOYXRpdmVUcmFja3NGb3JUeXBlXyhuYW1lKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgcHJvcHMgPSBOT1JNQUxbbmFtZV07XG4gICAgdmFyIGVsVHJhY2tzID0gdGhpcy5lbCgpW3Byb3BzLmdldHRlck5hbWVdO1xuICAgIHZhciB0ZWNoVHJhY2tzID0gdGhpc1twcm9wcy5nZXR0ZXJOYW1lXSgpO1xuXG4gICAgaWYgKCF0aGlzWydmZWF0dXJlc05hdGl2ZScgKyBwcm9wcy5jYXBpdGFsTmFtZSArICdUcmFja3MnXSB8fCAhZWxUcmFja3MgfHwgIWVsVHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxpc3RlbmVycyA9IHtcbiAgICAgIGNoYW5nZTogZnVuY3Rpb24gY2hhbmdlKGUpIHtcbiAgICAgICAgdGVjaFRyYWNrcy50cmlnZ2VyKHtcbiAgICAgICAgICB0eXBlOiAnY2hhbmdlJyxcbiAgICAgICAgICB0YXJnZXQ6IHRlY2hUcmFja3MsXG4gICAgICAgICAgY3VycmVudFRhcmdldDogdGVjaFRyYWNrcyxcbiAgICAgICAgICBzcmNFbGVtZW50OiB0ZWNoVHJhY2tzXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGFkZHRyYWNrOiBmdW5jdGlvbiBhZGR0cmFjayhlKSB7XG4gICAgICAgIHRlY2hUcmFja3MuYWRkVHJhY2soZS50cmFjayk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZldHJhY2s6IGZ1bmN0aW9uIHJlbW92ZXRyYWNrKGUpIHtcbiAgICAgICAgdGVjaFRyYWNrcy5yZW1vdmVUcmFjayhlLnRyYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZW1vdmVPbGRUcmFja3MgPSBmdW5jdGlvbiByZW1vdmVPbGRUcmFja3MoKSB7XG4gICAgICB2YXIgcmVtb3ZlVHJhY2tzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVjaFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsVHJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKGVsVHJhY2tzW2pdID09PSB0ZWNoVHJhY2tzW2ldKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgcmVtb3ZlVHJhY2tzLnB1c2godGVjaFRyYWNrc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHJlbW92ZVRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgdGVjaFRyYWNrcy5yZW1vdmVUcmFjayhyZW1vdmVUcmFja3Muc2hpZnQoKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXNbcHJvcHMuZ2V0dGVyTmFtZSArICdMaXN0ZW5lcnNfJ10gPSBsaXN0ZW5lcnM7XG5cbiAgICBPYmplY3Qua2V5cyhsaXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgIGVsVHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICBfdGhpczMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZWxUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVtb3ZlIChuYXRpdmUpIHRyYWNrcyB0aGF0IGFyZSBub3QgdXNlZCBhbnltb3JlXG4gICAgdGhpcy5vbignbG9hZHN0YXJ0JywgcmVtb3ZlT2xkVHJhY2tzKTtcbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBfdGhpczMub2ZmKCdsb2Fkc3RhcnQnLCByZW1vdmVPbGRUcmFja3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm94eSBhbGwgbmF0aXZlIHRyYWNrIGxpc3QgZXZlbnRzIHRvIG91ciB0cmFjayBsaXN0cyBpZiB0aGUgYnJvd3NlciB3ZSBhcmUgcGxheWluZ1xuICAgKiBpbiBzdXBwb3J0cyB0aGF0IHR5cGUgb2YgdHJhY2sgbGlzdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucHJveHlOYXRpdmVUcmFja3NfID0gZnVuY3Rpb24gcHJveHlOYXRpdmVUcmFja3NfKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgTk9STUFMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzNC5wcm94eU5hdGl2ZVRyYWNrc0ZvclR5cGVfKG5hbWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBIdG1sNWAgVGVjaCdzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IHRoaXMub3B0aW9uc18udGFnO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBicm93c2VyIHN1cHBvcnRzIG1vdmluZyB0aGUgZWxlbWVudCBpbnRvIHRoZSBib3guXG4gICAgLy8gT24gdGhlIGlQaG9uZSB2aWRlbyB3aWxsIGJyZWFrIGlmIHlvdSBtb3ZlIHRoZSBlbGVtZW50LFxuICAgIC8vIFNvIHdlIGhhdmUgdG8gY3JlYXRlIGEgYnJhbmQgbmV3IGVsZW1lbnQuXG4gICAgLy8gSWYgd2UgaW5nZXN0ZWQgdGhlIHBsYXllciBkaXYsIHdlIGRvIG5vdCBuZWVkIHRvIG1vdmUgdGhlIG1lZGlhIGVsZW1lbnQuXG4gICAgaWYgKCFlbCB8fCAhKHRoaXMub3B0aW9uc18ucGxheWVyRWxJbmdlc3QgfHwgdGhpcy5tb3ZpbmdNZWRpYUVsZW1lbnRJbkRPTSkpIHtcblxuICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIHRhZyBpcyBzdGlsbCB0aGVyZSwgY2xvbmUgYW5kIHJlbW92ZSBpdC5cbiAgICAgIGlmIChlbCkge1xuICAgICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUodHJ1ZSk7XG5cbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjbG9uZSwgZWwpO1xuICAgICAgICB9XG4gICAgICAgIEh0bWw1LmRpc3Bvc2VNZWRpYUVsZW1lbnQoZWwpO1xuICAgICAgICBlbCA9IGNsb25lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSBpZiBuYXRpdmUgY29udHJvbHMgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgdmFyIHRhZ0F0dHJpYnV0ZXMgPSB0aGlzLm9wdGlvbnNfLnRhZyAmJiBnZXRBdHRyaWJ1dGVzKHRoaXMub3B0aW9uc18udGFnKTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBtZXJnZU9wdGlvbnMoe30sIHRhZ0F0dHJpYnV0ZXMpO1xuXG4gICAgICAgIGlmICghVE9VQ0hfRU5BQkxFRCB8fCB0aGlzLm9wdGlvbnNfLm5hdGl2ZUNvbnRyb2xzRm9yVG91Y2ggIT09IHRydWUpIHtcbiAgICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5jb250cm9scztcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEF0dHJpYnV0ZXMoZWwsIGFzc2lnbihhdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgaWQ6IHRoaXMub3B0aW9uc18udGVjaElkLFxuICAgICAgICAgIGNsYXNzOiAndmpzLXRlY2gnXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgZWwucGxheWVySWQgPSB0aGlzLm9wdGlvbnNfLnBsYXllcklkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zXy5wcmVsb2FkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2V0QXR0cmlidXRlKGVsLCAncHJlbG9hZCcsIHRoaXMub3B0aW9uc18ucHJlbG9hZCk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHNwZWNpZmljIHRhZyBzZXR0aW5ncywgaW4gY2FzZSB0aGV5IHdlcmUgb3ZlcnJpZGRlblxuICAgIC8vIGBhdXRvcGxheWAgaGFzIHRvIGJlICpsYXN0KiBzbyB0aGF0IGBtdXRlZGAgYW5kIGBwbGF5c2lubGluZWAgYXJlIHByZXNlbnRcbiAgICAvLyB3aGVuIGlPUy9TYWZhcmkgb3Igb3RoZXIgYnJvd3NlcnMgYXR0ZW1wdCB0byBhdXRvcGxheS5cbiAgICB2YXIgc2V0dGluZ3NBdHRycyA9IFsnbG9vcCcsICdtdXRlZCcsICdwbGF5c2lubGluZScsICdhdXRvcGxheSddO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXR0aW5nc0F0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXR0ciA9IHNldHRpbmdzQXR0cnNbaV07XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLm9wdGlvbnNfW2F0dHJdO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBzZXRBdHRyaWJ1dGUoZWwsIGF0dHIsIGF0dHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZUF0dHJpYnV0ZShlbCwgYXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgZWxbYXR0cl0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCBiZSB0cmlnZ2VyZWQgaWYgdGhlIGxvYWRzdGFydCBldmVudCBoYXMgYWxyZWFkeSBmaXJlZCwgYmVmb3JlIHZpZGVvanMgd2FzXG4gICAqIHJlYWR5LiBUd28ga25vd24gZXhhbXBsZXMgb2Ygd2hlbiB0aGlzIGNhbiBoYXBwZW4gYXJlOlxuICAgKiAxLiBJZiB3ZSdyZSBsb2FkaW5nIHRoZSBwbGF5YmFjayBvYmplY3QgYWZ0ZXIgaXQgaGFzIHN0YXJ0ZWQgbG9hZGluZ1xuICAgKiAyLiBUaGUgbWVkaWEgaXMgYWxyZWFkeSBwbGF5aW5nIHRoZSAob2Z0ZW4gd2l0aCBhdXRvcGxheSBvbikgdGhlblxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgZmlyZSBhbm90aGVyIGxvYWRzdGFydCBzbyB0aGF0IHZpZGVvanMgY2FuIGNhdGNodXAuXG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI2xvYWRzdGFydFxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqICAgICAgICAgcmV0dXJucyBub3RoaW5nLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5oYW5kbGVMYXRlSW5pdF8gPSBmdW5jdGlvbiBoYW5kbGVMYXRlSW5pdF8oZWwpIHtcbiAgICBpZiAoZWwubmV0d29ya1N0YXRlID09PSAwIHx8IGVsLm5ldHdvcmtTdGF0ZSA9PT0gMykge1xuICAgICAgLy8gVGhlIHZpZGVvIGVsZW1lbnQgaGFzbid0IHN0YXJ0ZWQgbG9hZGluZyB0aGUgc291cmNlIHlldFxuICAgICAgLy8gb3IgZGlkbid0IGZpbmQgYSBzb3VyY2VcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwucmVhZHlTdGF0ZSA9PT0gMCkge1xuICAgICAgLy8gTmV0d29ya1N0YXRlIGlzIHNldCBzeW5jaHJvbm91c2x5IEJVVCBsb2Fkc3RhcnQgaXMgZmlyZWQgYXQgdGhlXG4gICAgICAvLyBlbmQgb2YgdGhlIGN1cnJlbnQgc3RhY2ssIHVzdWFsbHkgYmVmb3JlIHNldEludGVydmFsKGZuLCAwKS5cbiAgICAgIC8vIFNvIGF0IHRoaXMgcG9pbnQgd2Uga25vdyBsb2Fkc3RhcnQgbWF5IGhhdmUgYWxyZWFkeSBmaXJlZCBvciBpc1xuICAgICAgLy8gYWJvdXQgdG8gZmlyZSwgYW5kIGVpdGhlciB3YXkgdGhlIHBsYXllciBoYXNuJ3Qgc2VlbiBpdCB5ZXQuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGZpcmUgbG9hZHN0YXJ0IHByZW1hdHVyZWx5IGhlcmUgYW5kIGNhdXNlIGFcbiAgICAgIC8vIGRvdWJsZSBsb2Fkc3RhcnQgc28gd2UnbGwgd2FpdCBhbmQgc2VlIGlmIGl0IGhhcHBlbnMgYmV0d2VlbiBub3dcbiAgICAgIC8vIGFuZCB0aGUgbmV4dCBsb29wLCBhbmQgZmlyZSBpdCBpZiBub3QuXG4gICAgICAvLyBIT1dFVkVSLCB3ZSBhbHNvIHdhbnQgdG8gbWFrZSBzdXJlIGl0IGZpcmVzIGJlZm9yZSBsb2FkZWRtZXRhZGF0YVxuICAgICAgLy8gd2hpY2ggY291bGQgYWxzbyBoYXBwZW4gYmV0d2VlbiBub3cgYW5kIHRoZSBuZXh0IGxvb3AsIHNvIHdlJ2xsXG4gICAgICAvLyB3YXRjaCBmb3IgdGhhdCBhbHNvLlxuICAgICAgdmFyIGxvYWRzdGFydEZpcmVkID0gZmFsc2U7XG4gICAgICB2YXIgc2V0TG9hZHN0YXJ0RmlyZWQgPSBmdW5jdGlvbiBzZXRMb2Fkc3RhcnRGaXJlZCgpIHtcbiAgICAgICAgbG9hZHN0YXJ0RmlyZWQgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5vbignbG9hZHN0YXJ0Jywgc2V0TG9hZHN0YXJ0RmlyZWQpO1xuXG4gICAgICB2YXIgdHJpZ2dlckxvYWRzdGFydCA9IGZ1bmN0aW9uIHRyaWdnZXJMb2Fkc3RhcnQoKSB7XG4gICAgICAgIC8vIFdlIGRpZCBtaXNzIHRoZSBvcmlnaW5hbCBsb2Fkc3RhcnQuIE1ha2Ugc3VyZSB0aGUgcGxheWVyXG4gICAgICAgIC8vIHNlZXMgbG9hZHN0YXJ0IGJlZm9yZSBsb2FkZWRtZXRhZGF0YVxuICAgICAgICBpZiAoIWxvYWRzdGFydEZpcmVkKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vbignbG9hZGVkbWV0YWRhdGEnLCB0cmlnZ2VyTG9hZHN0YXJ0KTtcblxuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2ZmKCdsb2Fkc3RhcnQnLCBzZXRMb2Fkc3RhcnRGaXJlZCk7XG4gICAgICAgIHRoaXMub2ZmKCdsb2FkZWRtZXRhZGF0YScsIHRyaWdnZXJMb2Fkc3RhcnQpO1xuXG4gICAgICAgIGlmICghbG9hZHN0YXJ0RmlyZWQpIHtcbiAgICAgICAgICAvLyBXZSBkaWQgbWlzcyB0aGUgb3JpZ2luYWwgbmF0aXZlIGxvYWRzdGFydC4gRmlyZSBpdCBub3cuXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGcm9tIGhlcmUgb24gd2Uga25vdyB0aGF0IGxvYWRzdGFydCBhbHJlYWR5IGZpcmVkIGFuZCB3ZSBtaXNzZWQgaXQuXG4gICAgLy8gVGhlIG90aGVyIHJlYWR5U3RhdGUgZXZlbnRzIGFyZW4ndCBhcyBtdWNoIG9mIGEgcHJvYmxlbSBpZiB3ZSBkb3VibGVcbiAgICAvLyB0aGVtLCBzbyBub3QgZ29pbmcgdG8gZ28gdG8gYXMgbXVjaCB0cm91YmxlIGFzIGxvYWRzdGFydCB0byBwcmV2ZW50XG4gICAgLy8gdGhhdCB1bmxlc3Mgd2UgZmluZCByZWFzb24gdG8uXG4gICAgdmFyIGV2ZW50c1RvVHJpZ2dlciA9IFsnbG9hZHN0YXJ0J107XG5cbiAgICAvLyBsb2FkZWRtZXRhZGF0YTogbmV3bHkgZXF1YWwgdG8gSEFWRV9NRVRBREFUQSAoMSkgb3IgZ3JlYXRlclxuICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKCdsb2FkZWRtZXRhZGF0YScpO1xuXG4gICAgLy8gbG9hZGVkZGF0YTogbmV3bHkgaW5jcmVhc2VkIHRvIEhBVkVfQ1VSUkVOVF9EQVRBICgyKSBvciBncmVhdGVyXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2goJ2xvYWRlZGRhdGEnKTtcbiAgICB9XG5cbiAgICAvLyBjYW5wbGF5OiBuZXdseSBpbmNyZWFzZWQgdG8gSEFWRV9GVVRVUkVfREFUQSAoMykgb3IgZ3JlYXRlclxuICAgIGlmIChlbC5yZWFkeVN0YXRlID49IDMpIHtcbiAgICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKCdjYW5wbGF5Jyk7XG4gICAgfVxuXG4gICAgLy8gY2FucGxheXRocm91Z2g6IG5ld2x5IGVxdWFsIHRvIEhBVkVfRU5PVUdIX0RBVEEgKDQpXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPj0gNCkge1xuICAgICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2goJ2NhbnBsYXl0aHJvdWdoJyk7XG4gICAgfVxuXG4gICAgLy8gV2Ugc3RpbGwgbmVlZCB0byBnaXZlIHRoZSBwbGF5ZXIgdGltZSB0byBhZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICBldmVudHNUb1RyaWdnZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0aGlzLnRyaWdnZXIodHlwZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGN1cnJlbnQgdGltZSBmb3IgdGhlIGBIVE1MNWAgdGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHNcbiAgICogICAgICAgIFNldCB0aGUgY3VycmVudCB0aW1lIG9mIHRoZSBtZWRpYSB0byB0aGlzLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uIHNldEN1cnJlbnRUaW1lKHNlY29uZHMpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbF8uY3VycmVudFRpbWUgPSBzZWNvbmRzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZyQxKGUsICdWaWRlbyBpcyBub3QgcmVhZHkuIChWaWRlby5qcyknKTtcbiAgICAgIC8vIHRoaXMud2FybmluZyhWaWRlb0pTLndhcm5pbmdzLnZpZGVvTm90UmVhZHkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGR1cmF0aW9uIG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBtZWRpYSBvciAwIGlmIHRoZXJlIGlzIG5vIGR1cmF0aW9uLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgLy8gQW5kcm9pZCBDaHJvbWUgd2lsbCByZXBvcnQgZHVyYXRpb24gYXMgSW5maW5pdHkgZm9yIFZPRCBITFMgdW50aWwgYWZ0ZXJcbiAgICAvLyBwbGF5YmFjayBoYXMgc3RhcnRlZCwgd2hpY2ggdHJpZ2dlcnMgdGhlIGxpdmUgZGlzcGxheSBlcnJvbmVvdXNseS5cbiAgICAvLyBSZXR1cm4gTmFOIGlmIHBsYXliYWNrIGhhcyBub3Qgc3RhcnRlZCBhbmQgdHJpZ2dlciBhIGR1cmF0aW9udXBkYXRlIG9uY2VcbiAgICAvLyB0aGUgZHVyYXRpb24gY2FuIGJlIHJlbGlhYmx5IGtub3duLlxuICAgIGlmICh0aGlzLmVsXy5kdXJhdGlvbiA9PT0gSW5maW5pdHkgJiYgSVNfQU5EUk9JRCAmJiBJU19DSFJPTUUgJiYgdGhpcy5lbF8uY3VycmVudFRpbWUgPT09IDApIHtcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBmaXJzdCBgdGltZXVwZGF0ZWAgd2l0aCBjdXJyZW50VGltZSA+IDAgLSB0aGVyZSBtYXkgYmVcbiAgICAgIC8vIHNldmVyYWwgd2l0aCAwXG4gICAgICB2YXIgY2hlY2tQcm9ncmVzcyA9IGZ1bmN0aW9uIGNoZWNrUHJvZ3Jlc3MoKSB7XG4gICAgICAgIGlmIChfdGhpczUuZWxfLmN1cnJlbnRUaW1lID4gMCkge1xuICAgICAgICAgIC8vIFRyaWdnZXIgZHVyYXRpb25jaGFuZ2UgZm9yIGdlbnVpbmVseSBsaXZlIHZpZGVvXG4gICAgICAgICAgaWYgKF90aGlzNS5lbF8uZHVyYXRpb24gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICBfdGhpczUudHJpZ2dlcignZHVyYXRpb25jaGFuZ2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXM1Lm9mZigndGltZXVwZGF0ZScsIGNoZWNrUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uKCd0aW1ldXBkYXRlJywgY2hlY2tQcm9ncmVzcyk7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbF8uZHVyYXRpb24gfHwgTmFOO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIEhUTUw1IG1lZGlhIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgd2lkdGggb2YgdGhlIEhUTUw1IG1lZGlhIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfLm9mZnNldFdpZHRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGhlaWdodCBvZiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5vZmZzZXRIZWlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3h5IGlPUyBgd2Via2l0YmVnaW5mdWxsc2NyZWVuYCBhbmQgYHdlYmtpdGVuZGZ1bGxzY3JlZW5gIGludG9cbiAgICogYGZ1bGxzY3JlZW5jaGFuZ2VgIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZmlyZXMgZnVsbHNjcmVlbmNoYW5nZVxuICAgKiBAbGlzdGVucyB3ZWJraXRlbmRmdWxsc2NyZWVuXG4gICAqIEBsaXN0ZW5zIHdlYmtpdGJlZ2luZnVsbHNjcmVlblxuICAgKiBAbGlzdGVucyB3ZWJraXRiZWdpbmZ1bGxzY3JlZW5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucHJveHlXZWJraXRGdWxsc2NyZWVuXyA9IGZ1bmN0aW9uIHByb3h5V2Via2l0RnVsbHNjcmVlbl8oKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICBpZiAoISgnd2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW4nIGluIHRoaXMuZWxfKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbmRGbiA9IGZ1bmN0aW9uIGVuZEZuKCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJywgeyBpc0Z1bGxzY3JlZW46IGZhbHNlIH0pO1xuICAgIH07XG5cbiAgICB2YXIgYmVnaW5GbiA9IGZ1bmN0aW9uIGJlZ2luRm4oKSB7XG4gICAgICBpZiAoJ3dlYmtpdFByZXNlbnRhdGlvbk1vZGUnIGluIHRoaXMuZWxfICYmIHRoaXMuZWxfLndlYmtpdFByZXNlbnRhdGlvbk1vZGUgIT09ICdwaWN0dXJlLWluLXBpY3R1cmUnKSB7XG4gICAgICAgIHRoaXMub25lKCd3ZWJraXRlbmRmdWxsc2NyZWVuJywgZW5kRm4pO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScsIHsgaXNGdWxsc2NyZWVuOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uKCd3ZWJraXRiZWdpbmZ1bGxzY3JlZW4nLCBiZWdpbkZuKTtcbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXM2Lm9mZignd2Via2l0YmVnaW5mdWxsc2NyZWVuJywgYmVnaW5Gbik7XG4gICAgICBfdGhpczYub2ZmKCd3ZWJraXRlbmRmdWxsc2NyZWVuJywgZW5kRm4pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBmdWxsc2NyZWVuIGlzIHN1cHBvcnRlZCBvbiB0aGUgY3VycmVudCBwbGF5YmFjayBkZXZpY2UuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSBUcnVlIGlmIGZ1bGxzY3JlZW4gaXMgc3VwcG9ydGVkLlxuICAgKiAgICAgICAgIC0gRmFsc2UgaWYgZnVsbHNjcmVlbiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5zdXBwb3J0c0Z1bGxTY3JlZW4gPSBmdW5jdGlvbiBzdXBwb3J0c0Z1bGxTY3JlZW4oKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmVsXy53ZWJraXRFbnRlckZ1bGxTY3JlZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB1c2VyQWdlbnQgPSB3aW5kb3ckMS5uYXZpZ2F0b3IgJiYgd2luZG93JDEubmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcblxuICAgICAgLy8gU2VlbXMgdG8gYmUgYnJva2VuIGluIENocm9taXVtL0Nocm9tZSAmJiBTYWZhcmkgaW4gTGVvcGFyZFxuICAgICAgaWYgKC9BbmRyb2lkLy50ZXN0KHVzZXJBZ2VudCkgfHwgIS9DaHJvbWV8TWFjIE9TIFggMTAuNS8udGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdGhhdCB0aGUgYEhUTUw1YCBUZWNoIGVudGVyIGZ1bGxzY3JlZW4uXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmVudGVyRnVsbFNjcmVlbiA9IGZ1bmN0aW9uIGVudGVyRnVsbFNjcmVlbigpIHtcbiAgICB2YXIgdmlkZW8gPSB0aGlzLmVsXztcblxuICAgIGlmICh2aWRlby5wYXVzZWQgJiYgdmlkZW8ubmV0d29ya1N0YXRlIDw9IHZpZGVvLkhBVkVfTUVUQURBVEEpIHtcbiAgICAgIC8vIGF0dGVtcHQgdG8gcHJpbWUgdGhlIHZpZGVvIGVsZW1lbnQgZm9yIHByb2dyYW1tYXRpYyBhY2Nlc3NcbiAgICAgIC8vIHRoaXMgaXNuJ3QgbmVjZXNzYXJ5IG9uIHRoZSBkZXNrdG9wIGJ1dCBzaG91bGRuJ3QgaHVydFxuICAgICAgdGhpcy5lbF8ucGxheSgpO1xuXG4gICAgICAvLyBwbGF5aW5nIGFuZCBwYXVzaW5nIHN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZSB0cmFuc2l0aW9uIHRvIGZ1bGxzY3JlZW5cbiAgICAgIC8vIGNhbiBnZXQgaU9TIH42LjEgZGV2aWNlcyBpbnRvIGEgcGxheS9wYXVzZSBsb29wXG4gICAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgICAgICB2aWRlby53ZWJraXRFbnRlckZ1bGxTY3JlZW4oKTtcbiAgICAgIH0sIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlby53ZWJraXRFbnRlckZ1bGxTY3JlZW4oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdGhhdCB0aGUgYEhUTUw1YCBUZWNoIGV4aXQgZnVsbHNjcmVlbi5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuZXhpdEZ1bGxTY3JlZW4gPSBmdW5jdGlvbiBleGl0RnVsbFNjcmVlbigpIHtcbiAgICB0aGlzLmVsXy53ZWJraXRFeGl0RnVsbFNjcmVlbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgSHRtbDVgIFRlY2gncyBzb3VyY2Ugb2JqZWN0LlxuICAgKiA+IE5vdGU6IFBsZWFzZSB1c2Uge0BsaW5rIEh0bWw1I3NldFNvdXJjZX1cbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gW3NyY11cbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0IHlvdSB3YW50IHRvIHNldCBvbiB0aGUgYEhUTUw1YCB0ZWNocyBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgLSBUaGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0IHdoZW4gYSBzb3VyY2UgaXMgbm90IHBhc3NlZCBpbi5cbiAgICogICAgICAgICAtIHVuZGVmaW5lZCB3aGVuIHNldHRpbmdcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgU2luY2UgdmVyc2lvbiA1LlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5zcmMgPSBmdW5jdGlvbiBzcmMoX3NyYykge1xuICAgIGlmIChfc3JjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsXy5zcmM7XG4gICAgfVxuXG4gICAgLy8gU2V0dGluZyBzcmMgdGhyb3VnaCBgc3JjYCBpbnN0ZWFkIG9mIGBzZXRTcmNgIHdpbGwgYmUgZGVwcmVjYXRlZFxuICAgIHRoaXMuc2V0U3JjKF9zcmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgdGVjaCBieSByZW1vdmluZyBhbGwgc291cmNlcyBhbmQgdGhlbiBjYWxsaW5nXG4gICAqIHtAbGluayBIdG1sNS5yZXNldE1lZGlhRWxlbWVudH0uXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgSHRtbDUucmVzZXRNZWRpYUVsZW1lbnQodGhpcy5lbF8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc291cmNlIG9uIHRoZSBgSFRNTDVgIFRlY2guIEZhbGxzIGJhY2sgdG8gcmV0dXJuaW5nIHRoZSBzb3VyY2UgZnJvbVxuICAgKiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7VGVjaH5Tb3VyY2VPYmplY3R9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgc291cmNlIG9iamVjdCBmcm9tIHRoZSBIVE1MNSB0ZWNoLiBXaXRoIGEgZmFsbGJhY2sgdG8gdGhlXG4gICAqICAgICAgICAgZWxlbWVudHMgc291cmNlLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5jdXJyZW50U3JjID0gZnVuY3Rpb24gY3VycmVudFNyYygpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U291cmNlXykge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNvdXJjZV8uc3JjO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbF8uY3VycmVudFNyYztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGNvbnRyb2xzIGF0dHJpYnV0ZSBmb3IgdGhlIEhUTUw1IG1lZGlhIEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAgICogICAgICAgIFZhbHVlIHRvIHNldCB0aGUgY29udHJvbHMgYXR0cmlidXRlIHRvXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnNldENvbnRyb2xzID0gZnVuY3Rpb24gc2V0Q29udHJvbHModmFsKSB7XG4gICAgdGhpcy5lbF8uY29udHJvbHMgPSAhIXZhbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZXR1cm5zIGEgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAgICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXVxuICAgKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV1cbiAgICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja31cbiAgICogICAgICAgICBUaGUgVGV4dFRyYWNrIHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5hZGRUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgcmV0dXJuIF9UZWNoLnByb3RvdHlwZS5hZGRUZXh0VHJhY2suY2FsbCh0aGlzLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsXy5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBlaXRoZXIgbmF0aXZlIFRleHRUcmFjayBvciBhbiBlbXVsYXRlZCBUZXh0VHJhY2sgZGVwZW5kaW5nXG4gICAqIG9uIHRoZSB2YWx1ZSBvZiBgZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzYFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgb3B0aW9ucyB0byBpbml0aWFsaXplIHRoZSBUZXh0VHJhY2sgd2l0aC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmtpbmRdXG4gICAqICAgICAgICBgVGV4dFRyYWNrYCBraW5kIChzdWJ0aXRsZXMsIGNhcHRpb25zLCBkZXNjcmlwdGlvbnMsIGNoYXB0ZXJzLCBvciBtZXRhZGF0YSkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbF1cbiAgICogICAgICAgIExhYmVsIHRvIGlkZW50aWZ5IHRoZSB0ZXh0IHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZV1cbiAgICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmF1bHRdXG4gICAqICAgICAgICBEZWZhdWx0IHRoaXMgdHJhY2sgdG8gb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAgICogICAgICAgIFRoZSBpbnRlcm5hbCBpZCB0byBhc3NpZ24gdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY11cbiAgICogICAgICAgIEEgc291cmNlIHVybCBmb3IgdGhlIHRyYWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSB0cmFjayBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5jcmVhdGVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVSZW1vdGVUZXh0VHJhY2sob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIHJldHVybiBfVGVjaC5wcm90b3R5cGUuY3JlYXRlUmVtb3RlVGV4dFRyYWNrLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHZhciBodG1sVHJhY2tFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhY2snKTtcblxuICAgIGlmIChvcHRpb25zLmtpbmQpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQua2luZCA9IG9wdGlvbnMua2luZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGFiZWwpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQubGFiZWwgPSBvcHRpb25zLmxhYmVsO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sYW5ndWFnZSB8fCBvcHRpb25zLnNyY2xhbmcpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQuc3JjbGFuZyA9IG9wdGlvbnMubGFuZ3VhZ2UgfHwgb3B0aW9ucy5zcmNsYW5nO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kZWZhdWx0KSB7XG4gICAgICBodG1sVHJhY2tFbGVtZW50LmRlZmF1bHQgPSBvcHRpb25zLmRlZmF1bHQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmlkKSB7XG4gICAgICBodG1sVHJhY2tFbGVtZW50LmlkID0gb3B0aW9ucy5pZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3JjKSB7XG4gICAgICBodG1sVHJhY2tFbGVtZW50LnNyYyA9IG9wdGlvbnMuc3JjO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sVHJhY2tFbGVtZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVtb3RlIHRleHQgdHJhY2sgb2JqZWN0IGFuZCByZXR1cm5zIGFuIGh0bWwgdHJhY2sgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiB2YWx1ZXMgZm9yXG4gICAqIGtpbmQsIGxhbmd1YWdlLCBsYWJlbCwgYW5kIHNyYyAobG9jYXRpb24gb2YgdGhlIFdlYlZUVCBmaWxlKVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYW51YWxDbGVhbnVwPXRydWVdIGlmIHNldCB0byBmYWxzZSwgdGhlIFRleHRUcmFjayB3aWxsIGJlXG4gICAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50IHdoZW5ldmVyIHRoZSBzb3VyY2UgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fSBBbiBIdG1sIFRyYWNrIEVsZW1lbnQuXG4gICAqIFRoaXMgY2FuIGJlIGFuIGVtdWxhdGVkIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fSBvciBhIG5hdGl2ZSBvbmUuXG4gICAqIEBkZXByZWNhdGVkIFRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBcIm1hbnVhbENsZWFudXBcIiBwYXJhbWV0ZXIgd2lsbCBkZWZhdWx0XG4gICAqIHRvIFwiZmFsc2VcIiBpbiB1cGNvbWluZyB2ZXJzaW9ucyBvZiBWaWRlby5qc1xuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5hZGRSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRSZW1vdGVUZXh0VHJhY2sob3B0aW9ucywgbWFudWFsQ2xlYW51cCkge1xuICAgIHZhciBodG1sVHJhY2tFbGVtZW50ID0gX1RlY2gucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjay5jYWxsKHRoaXMsIG9wdGlvbnMsIG1hbnVhbENsZWFudXApO1xuXG4gICAgaWYgKHRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICB0aGlzLmVsKCkuYXBwZW5kQ2hpbGQoaHRtbFRyYWNrRWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWxUcmFja0VsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSByZW1vdGUgYFRleHRUcmFja2AgZnJvbSBgVGV4dFRyYWNrTGlzdGAgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICAgKiAgICAgICAgYFRleHRUcmFja2Agb2JqZWN0IHRvIHJlbW92ZVxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5yZW1vdmVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiByZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spIHtcbiAgICBfVGVjaC5wcm90b3R5cGUucmVtb3ZlUmVtb3RlVGV4dFRyYWNrLmNhbGwodGhpcywgdHJhY2spO1xuXG4gICAgaWYgKHRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICB2YXIgdHJhY2tzID0gdGhpcy4kJCgndHJhY2snKTtcblxuICAgICAgdmFyIGkgPSB0cmFja3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmICh0cmFjayA9PT0gdHJhY2tzW2ldIHx8IHRyYWNrID09PSB0cmFja3NbaV0udHJhY2spIHtcbiAgICAgICAgICB0aGlzLmVsKCkucmVtb3ZlQ2hpbGQodHJhY2tzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhdmFpbGFibGUgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzIGFzIHNwZWNpZmllZCBieSB0aGUgVzNDJ3MgTWVkaWFcbiAgICogUGxheWJhY2sgUXVhbGl0eSBBUEkuXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vbWVkaWEtcGxheWJhY2stcXVhbGl0eX1cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEFuIG9iamVjdCB3aXRoIHN1cHBvcnRlZCBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3NcbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPSBmdW5jdGlvbiBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZWwoKS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuZWwoKS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgIH1cblxuICAgIHZhciB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHt9O1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmVsKCkud2Via2l0RHJvcHBlZEZyYW1lQ291bnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGlzLmVsKCkud2Via2l0RGVjb2RlZEZyYW1lQ291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2aWRlb1BsYXliYWNrUXVhbGl0eS5kcm9wcGVkVmlkZW9GcmFtZXMgPSB0aGlzLmVsKCkud2Via2l0RHJvcHBlZEZyYW1lQ291bnQ7XG4gICAgICB2aWRlb1BsYXliYWNrUXVhbGl0eS50b3RhbFZpZGVvRnJhbWVzID0gdGhpcy5lbCgpLndlYmtpdERlY29kZWRGcmFtZUNvdW50O1xuICAgIH1cblxuICAgIGlmICh3aW5kb3ckMS5wZXJmb3JtYW5jZSAmJiB0eXBlb2Ygd2luZG93JDEucGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2aWRlb1BsYXliYWNrUXVhbGl0eS5jcmVhdGlvblRpbWUgPSB3aW5kb3ckMS5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdyQxLnBlcmZvcm1hbmNlICYmIHdpbmRvdyQxLnBlcmZvcm1hbmNlLnRpbWluZyAmJiB0eXBlb2Ygd2luZG93JDEucGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LmNyZWF0aW9uVGltZSA9IHdpbmRvdyQxLkRhdGUubm93KCkgLSB3aW5kb3ckMS5wZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiB2aWRlb1BsYXliYWNrUXVhbGl0eTtcbiAgfTtcblxuICByZXR1cm4gSHRtbDU7XG59KFRlY2gpO1xuXG4vKiBIVE1MNSBTdXBwb3J0IFRlc3RpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5pZiAoaXNSZWFsKCkpIHtcblxuICAvKipcbiAgICogRWxlbWVudCBmb3IgdGVzdGluZyBicm93c2VyIEhUTUw1IG1lZGlhIGNhcGFiaWxpdGllc1xuICAgKlxuICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICogQGNvbnN0YW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBIdG1sNS5URVNUX1ZJRCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gIHZhciB0cmFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyYWNrJyk7XG5cbiAgdHJhY2sua2luZCA9ICdjYXB0aW9ucyc7XG4gIHRyYWNrLnNyY2xhbmcgPSAnZW4nO1xuICB0cmFjay5sYWJlbCA9ICdFbmdsaXNoJztcbiAgSHRtbDUuVEVTVF9WSUQuYXBwZW5kQ2hpbGQodHJhY2spO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIEhUTUw1IG1lZGlhIGlzIHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIvZGV2aWNlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiBIVE1MNSBtZWRpYSBpcyBzdXBwb3J0ZWQuXG4gKiAgICAgICAgIC0gRmFsc2UgaWYgSFRNTDUgbWVkaWEgaXMgbm90IHN1cHBvcnRlZC5cbiAqL1xuSHRtbDUuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIElFIHdpdGggbm8gTWVkaWEgUGxheWVyIGlzIGEgTElBUiEgKCM5ODQpXG4gIHRyeSB7XG4gICAgSHRtbDUuVEVTVF9WSUQudm9sdW1lID0gMC41O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhKEh0bWw1LlRFU1RfVklEICYmIEh0bWw1LlRFU1RfVklELmNhblBsYXlUeXBlKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHR5cGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFRoZSBtaW1ldHlwZSB0byBjaGVja1xuICogQHJldHVybiB7c3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICovXG5IdG1sNS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHJldHVybiBIdG1sNS5URVNUX1ZJRC5jYW5QbGF5VHlwZSh0eXBlKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IHNyY09ialxuICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdGVjaFxuICogQHJldHVybiB7c3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICovXG5IdG1sNS5jYW5QbGF5U291cmNlID0gZnVuY3Rpb24gKHNyY09iaiwgb3B0aW9ucykge1xuICByZXR1cm4gSHRtbDUuY2FuUGxheVR5cGUoc3JjT2JqLnR5cGUpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdm9sdW1lIGNhbiBiZSBjaGFuZ2VkIGluIHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKiBWb2x1bWUgY2Fubm90IGJlIGNoYW5nZWQgaW4gYSBsb3Qgb2YgbW9iaWxlIGRldmljZXMuXG4gKiBTcGVjaWZpY2FsbHksIGl0IGNhbid0IGJlIGNoYW5nZWQgZnJvbSAxIG9uIGlPUy5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgdm9sdW1lIGNhbiBiZSBjb250cm9sbGVkXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LmNhbkNvbnRyb2xWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIElFIHdpbGwgZXJyb3IgaWYgV2luZG93cyBNZWRpYSBQbGF5ZXIgbm90IGluc3RhbGxlZCAjMzMxNVxuICB0cnkge1xuICAgIHZhciB2b2x1bWUgPSBIdG1sNS5URVNUX1ZJRC52b2x1bWU7XG5cbiAgICBIdG1sNS5URVNUX1ZJRC52b2x1bWUgPSB2b2x1bWUgLyAyICsgMC4xO1xuICAgIHJldHVybiB2b2x1bWUgIT09IEh0bWw1LlRFU1RfVklELnZvbHVtZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdm9sdW1lIGNhbiBiZSBtdXRlZCBpbiB0aGlzIGJyb3dzZXIvZGV2aWNlLlxuICogU29tZSBkZXZpY2VzLCBlLmcuIGlPUywgZG9uJ3QgYWxsb3cgY2hhbmdpbmcgdm9sdW1lXG4gKiBidXQgcGVybWl0cyBtdXRpbmcvdW5tdXRpbmcuXG4gKlxuICogQHJldHVybiB7Ym9sZWFufVxuICogICAgICAtIFRydWUgaWYgdm9sdW1lIGNhbiBiZSBtdXRlZFxuICogICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICovXG5IdG1sNS5jYW5NdXRlVm9sdW1lID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBtdXRlZCA9IEh0bWw1LlRFU1RfVklELm11dGVkO1xuXG4gICAgLy8gaW4gc29tZSB2ZXJzaW9ucyBvZiBpT1MgbXV0ZWQgcHJvcGVydHkgZG9lc24ndCBhbHdheXNcbiAgICAvLyB3b3JrLCBzbyB3ZSB3YW50IHRvIHNldCBib3RoIHByb3BlcnR5IGFuZCBhdHRyaWJ1dGVcbiAgICBIdG1sNS5URVNUX1ZJRC5tdXRlZCA9ICFtdXRlZDtcbiAgICBpZiAoSHRtbDUuVEVTVF9WSUQubXV0ZWQpIHtcbiAgICAgIHNldEF0dHJpYnV0ZShIdG1sNS5URVNUX1ZJRCwgJ211dGVkJywgJ211dGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZShIdG1sNS5URVNUX1ZJRCwgJ211dGVkJywgJ211dGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBtdXRlZCAhPT0gSHRtbDUuVEVTVF9WSUQubXV0ZWQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBsYXliYWNrIHJhdGUgY2FuIGJlIGNoYW5nZWQgaW4gdGhpcyBicm93c2VyL2RldmljZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgcGxheWJhY2sgcmF0ZSBjYW4gYmUgY29udHJvbGxlZFxuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICovXG5IdG1sNS5jYW5Db250cm9sUGxheWJhY2tSYXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyBQbGF5YmFjayByYXRlIEFQSSBpcyBpbXBsZW1lbnRlZCBpbiBBbmRyb2lkIENocm9tZSwgYnV0IGRvZXNuJ3QgZG8gYW55dGhpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvaXNzdWVzLzMxODBcbiAgaWYgKElTX0FORFJPSUQgJiYgSVNfQ0hST01FICYmIENIUk9NRV9WRVJTSU9OIDwgNTgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gSUUgd2lsbCBlcnJvciBpZiBXaW5kb3dzIE1lZGlhIFBsYXllciBub3QgaW5zdGFsbGVkICMzMzE1XG4gIHRyeSB7XG4gICAgdmFyIHBsYXliYWNrUmF0ZSA9IEh0bWw1LlRFU1RfVklELnBsYXliYWNrUmF0ZTtcblxuICAgIEh0bWw1LlRFU1RfVklELnBsYXliYWNrUmF0ZSA9IHBsYXliYWNrUmF0ZSAvIDIgKyAwLjE7XG4gICAgcmV0dXJuIHBsYXliYWNrUmF0ZSAhPT0gSHRtbDUuVEVTVF9WSUQucGxheWJhY2tSYXRlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGNhbiBvdmVycmlkZSBhIHZpZGVvL2F1ZGlvIGVsZW1lbnRzIGF0dHJpYnV0ZXMsIHdpdGhcbiAqIE9iamVjdC5kZWZpbmVQcm9wZXJ0eS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgYnVpbHRpbiBhdHRyaWJ1dGVzIGNhbiBiZSBvdmVycmlkZGVuXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LmNhbk92ZXJyaWRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gaWYgd2UgY2Fubm90IG92ZXJ3cml0ZSB0aGUgc3JjL2lubmVySFRNTCBwcm9wZXJ0eSwgdGhlcmUgaXMgbm8gc3VwcG9ydFxuICAvLyBpT1MgNyBzYWZhcmkgZm9yIGluc3RhbmNlIGNhbm5vdCBkbyB0aGlzLlxuICB0cnkge1xuICAgIHZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyksICdzcmMnLCB7IGdldDogbm9vcCwgc2V0OiBub29wIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpLCAnc3JjJywgeyBnZXQ6IG5vb3AsIHNldDogbm9vcCB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKSwgJ2lubmVySFRNTCcsIHsgZ2V0OiBub29wLCBzZXQ6IG5vb3AgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyksICdpbm5lckhUTUwnLCB7IGdldDogbm9vcCwgc2V0OiBub29wIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiBuYXRpdmUgYFRleHRUcmFja2BzIGFyZSBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyL2RldmljZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgbmF0aXZlIGBUZXh0VHJhY2tgcyBhcmUgc3VwcG9ydGVkLlxuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICovXG5IdG1sNS5zdXBwb3J0c05hdGl2ZVRleHRUcmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBJU19BTllfU0FGQVJJIHx8IElTX0lPUyAmJiBJU19DSFJPTUU7XG59O1xuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiBuYXRpdmUgYFZpZGVvVHJhY2tgcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2VcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgIC0gVHJ1ZSBpZiBuYXRpdmUgYFZpZGVvVHJhY2tgcyBhcmUgc3VwcG9ydGVkLlxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LnN1cHBvcnRzTmF0aXZlVmlkZW9UcmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIShIdG1sNS5URVNUX1ZJRCAmJiBIdG1sNS5URVNUX1ZJRC52aWRlb1RyYWNrcyk7XG59O1xuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiBuYXRpdmUgYEF1ZGlvVHJhY2tgcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2VcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgIC0gVHJ1ZSBpZiBuYXRpdmUgYEF1ZGlvVHJhY2tgcyBhcmUgc3VwcG9ydGVkLlxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LnN1cHBvcnRzTmF0aXZlQXVkaW9UcmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIShIdG1sNS5URVNUX1ZJRCAmJiBIdG1sNS5URVNUX1ZJRC5hdWRpb1RyYWNrcyk7XG59O1xuXG4vKipcbiAqIEFuIGFycmF5IG9mIGV2ZW50cyBhdmFpbGFibGUgb24gdGhlIEh0bWw1IHRlY2guXG4gKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuSHRtbDUuRXZlbnRzID0gWydsb2Fkc3RhcnQnLCAnc3VzcGVuZCcsICdhYm9ydCcsICdlcnJvcicsICdlbXB0aWVkJywgJ3N0YWxsZWQnLCAnbG9hZGVkbWV0YWRhdGEnLCAnbG9hZGVkZGF0YScsICdjYW5wbGF5JywgJ2NhbnBsYXl0aHJvdWdoJywgJ3BsYXlpbmcnLCAnd2FpdGluZycsICdzZWVraW5nJywgJ3NlZWtlZCcsICdlbmRlZCcsICdkdXJhdGlvbmNoYW5nZScsICd0aW1ldXBkYXRlJywgJ3Byb2dyZXNzJywgJ3BsYXknLCAncGF1c2UnLCAncmF0ZWNoYW5nZScsICdyZXNpemUnLCAndm9sdW1lY2hhbmdlJ107XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB2b2x1bWUgY29udHJvbC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0IHtAbGluayBIdG1sNS5jYW5Db250cm9sVm9sdW1lfVxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNWb2x1bWVDb250cm9sID0gSHRtbDUuY2FuQ29udHJvbFZvbHVtZSgpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgbXV0aW5nIHZvbHVtZS5cbiAqXG4gKiBAdHlwZSB7Ym9sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LmNhbk11dGVWb2x1bWV9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc011dGVDb250cm9sID0gSHRtbDUuY2FuTXV0ZVZvbHVtZSgpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgY2hhbmdpbmcgdGhlIHNwZWVkIGF0IHdoaWNoIHRoZSBtZWRpYVxuICogcGxheXMuIEV4YW1wbGVzOlxuICogICAtIFNldCBwbGF5ZXIgdG8gcGxheSAyeCAodHdpY2UpIGFzIGZhc3RcbiAqICAgLSBTZXQgcGxheWVyIHRvIHBsYXkgMC41eCAoaGFsZikgYXMgZmFzdFxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LmNhbkNvbnRyb2xQbGF5YmFja1JhdGV9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc1BsYXliYWNrUmF0ZSA9IEh0bWw1LmNhbkNvbnRyb2xQbGF5YmFja1JhdGUoKTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHRoZSBgc291cmNlc2V0YCBldmVudC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc1NvdXJjZXNldCA9IEh0bWw1LmNhbk92ZXJyaWRlQXR0cmlidXRlcygpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIHRoZSBtZWRpYSBlbGVtZW50XG4gKiBtb3ZpbmcgaW4gdGhlIERPTS4gaU9TIGJyZWFrcyBpZiB5b3UgbW92ZSB0aGUgbWVkaWEgZWxlbWVudCwgc28gdGhpcyBpcyBzZXQgdGhpcyB0b1xuICogZmFsc2UgdGhlcmUuIEV2ZXJ5d2hlcmUgZWxzZSB0aGlzIHNob3VsZCBiZSB0cnVlLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuSHRtbDUucHJvdG90eXBlLm1vdmluZ01lZGlhRWxlbWVudEluRE9NID0gIUlTX0lPUztcblxuLy8gVE9ETzogUHJldmlvdXMgY29tbWVudDogTm8gbG9uZ2VyIGFwcGVhcnMgdG8gYmUgdXNlZC4gQ2FuIHByb2JhYmx5IGJlIHJlbW92ZWQuXG4vLyAgICAgICBJcyB0aGlzIHRydWU/XG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIGF1dG9tYXRpYyBtZWRpYSByZXNpemVcbiAqIHdoZW4gZ29pbmcgaW50byBmdWxsc2NyZWVuLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzRnVsbHNjcmVlblJlc2l6ZSA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgdGhlIHByb2dyZXNzIGV2ZW50LlxuICogSWYgdGhpcyBpcyBmYWxzZSwgbWFudWFsIGBwcm9ncmVzc2AgZXZlbnRzIHdpbGwgYmUgdHJpZ2dlcmVkIGluc3RlYWQuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNQcm9ncmVzc0V2ZW50cyA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgdGhlIHRpbWV1cGRhdGUgZXZlbnQuXG4gKiBJZiB0aGlzIGlzIGZhbHNlLCBtYW51YWwgYHRpbWV1cGRhdGVgIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCBpbnN0ZWFkLlxuICpcbiAqIEBkZWZhdWx0XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc1RpbWV1cGRhdGVFdmVudHMgPSB0cnVlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIG5hdGl2ZSBgVGV4dFRyYWNrYHMuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdCB7QGxpbmsgSHRtbDUuc3VwcG9ydHNOYXRpdmVUZXh0VHJhY2tzfVxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzID0gSHRtbDUuc3VwcG9ydHNOYXRpdmVUZXh0VHJhY2tzKCk7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgbmF0aXZlIGBWaWRlb1RyYWNrYHMuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdCB7QGxpbmsgSHRtbDUuc3VwcG9ydHNOYXRpdmVWaWRlb1RyYWNrc31cbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzTmF0aXZlVmlkZW9UcmFja3MgPSBIdG1sNS5zdXBwb3J0c05hdGl2ZVZpZGVvVHJhY2tzKCk7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgbmF0aXZlIGBBdWRpb1RyYWNrYHMuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdCB7QGxpbmsgSHRtbDUuc3VwcG9ydHNOYXRpdmVBdWRpb1RyYWNrc31cbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzTmF0aXZlQXVkaW9UcmFja3MgPSBIdG1sNS5zdXBwb3J0c05hdGl2ZUF1ZGlvVHJhY2tzKCk7XG5cbi8vIEhUTUw1IEZlYXR1cmUgZGV0ZWN0aW9uIGFuZCBEZXZpY2UgRml4ZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG52YXIgY2FuUGxheVR5cGUgPSBIdG1sNS5URVNUX1ZJRCAmJiBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGU7XG52YXIgbXBlZ3VybFJFID0gL15hcHBsaWNhdGlvblxcLyg/OngtfHZuZFxcLmFwcGxlXFwuKW1wZWd1cmwvaTtcblxuSHRtbDUucGF0Y2hDYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICgpIHtcblxuICAvLyBBbmRyb2lkIDQuMCBhbmQgYWJvdmUgY2FuIHBsYXkgSExTIHRvIHNvbWUgZXh0ZW50IGJ1dCBpdCByZXBvcnRzIGJlaW5nIHVuYWJsZSB0byBkbyBzb1xuICAvLyBGaXJlZm94IGFuZCBDaHJvbWUgcmVwb3J0IGNvcnJlY3RseVxuICBpZiAoQU5EUk9JRF9WRVJTSU9OID49IDQuMCAmJiAhSVNfRklSRUZPWCAmJiAhSVNfQ0hST01FKSB7XG4gICAgSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlICYmIG1wZWd1cmxSRS50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiAnbWF5YmUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhblBsYXlUeXBlLmNhbGwodGhpcywgdHlwZSk7XG4gICAgfTtcbiAgfVxufTtcblxuSHRtbDUudW5wYXRjaENhblBsYXlUeXBlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZTtcblxuICBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBjYW5QbGF5VHlwZTtcbiAgcmV0dXJuIHI7XG59O1xuXG4vLyBieSBkZWZhdWx0LCBwYXRjaCB0aGUgbWVkaWEgZWxlbWVudFxuSHRtbDUucGF0Y2hDYW5QbGF5VHlwZSgpO1xuXG5IdG1sNS5kaXNwb3NlTWVkaWFFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gIGlmICghZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBjaGlsZCB0cmFjayBvciBzb3VyY2Ugbm9kZXMgdG8gcHJldmVudCB0aGVpciBsb2FkaW5nXG4gIHdoaWxlIChlbC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBhbnkgc3JjIHJlZmVyZW5jZS4gbm90IHNldHRpbmcgYHNyYz0nJ2AgYmVjYXVzZSB0aGF0IGNhdXNlcyBhIHdhcm5pbmdcbiAgLy8gaW4gZmlyZWZveFxuICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gIC8vIGZvcmNlIHRoZSBtZWRpYSBlbGVtZW50IHRvIHVwZGF0ZSBpdHMgbG9hZGluZyBzdGF0ZSBieSBjYWxsaW5nIGxvYWQoKVxuICAvLyBob3dldmVyIElFIG9uIFdpbmRvd3MgN04gaGFzIGEgYnVnIHRoYXQgdGhyb3dzIGFuIGVycm9yIHNvIG5lZWQgYSB0cnkvY2F0Y2ggKCM3OTMpXG4gIGlmICh0eXBlb2YgZWwubG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHdyYXBwaW5nIGluIGFuIGlpZmUgc28gaXQncyBub3QgZGVvcHRpbWl6ZWQgKCMxMDYwI2Rpc2N1c3Npb25fcjEwMzI0NDczKVxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBlbC5sb2FkKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG59O1xuXG5IdG1sNS5yZXNldE1lZGlhRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNvdXJjZXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdzb3VyY2UnKTtcbiAgdmFyIGkgPSBzb3VyY2VzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgZWwucmVtb3ZlQ2hpbGQoc291cmNlc1tpXSk7XG4gIH1cblxuICAvLyByZW1vdmUgYW55IHNyYyByZWZlcmVuY2UuXG4gIC8vIG5vdCBzZXR0aW5nIGBzcmM9JydgIGJlY2F1c2UgdGhhdCB0aHJvd3MgYW4gZXJyb3JcbiAgZWwucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcblxuICBpZiAodHlwZW9mIGVsLmxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyB3cmFwcGluZyBpbiBhbiBpaWZlIHNvIGl0J3Mgbm90IGRlb3B0aW1pemVkICgjMTA2MCNkaXNjdXNzaW9uX3IxMDMyNDQ3MylcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWwubG9hZCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBzYXRpc2Z5IGxpbnRlclxuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cbn07XG5cbi8qIE5hdGl2ZSBIVE1MNSBlbGVtZW50IHByb3BlcnR5IHdyYXBwaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4vLyBXcmFwIG5hdGl2ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2l0aCBnZXR0ZXJzIHRoYXQgY2hlY2sgYm90aCBwcm9wZXJ0eSBhbmQgYXR0cmlidXRlXG4vLyBUaGUgbGlzdCBpcyBhcyBmb2xsb3dlZDpcbi8vIG11dGVkLCBkZWZhdWx0TXV0ZWQsIGF1dG9wbGF5LCBjb250cm9scywgbG9vcCwgcGxheXNpbmxpbmVcbltcbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgbXV0ZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBtdXRlZGAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSB2b2x1bWUgZm9yIHRoZSBtZWRpYSBzaG91bGQgYmUgc2V0IHRvIHNpbGVudC4gVGhpcyBkb2VzIG5vdCBhY3R1YWxseSBjaGFuZ2VcbiAqIHRoZSBgdm9sdW1lYCBhdHRyaWJ1dGUuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNtdXRlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBzaG91bGQgYmUgaWdub3JlZCBhbmQgdGhlIGF1ZGlvIHNldCB0byBzaWxlbnQuXG4gKiAgICAgICAgIC0gRmFsc2UgaWYgdGhlIHZhbHVlIG9mIGB2b2x1bWVgIHNob3VsZCBiZSB1c2VkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtbXV0ZWR9XG4gKi9cbidtdXRlZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgZGVmYXVsdE11dGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgZGVmYXVsdE11dGVkYCBpbmRpY2F0ZXNcbiAqIHdoZXRoZXIgdGhlIG1lZGlhIHNob3VsZCBzdGFydCBtdXRlZCBvciBub3QuIE9ubHkgY2hhbmdlcyB0aGUgZGVmYXVsdCBzdGF0ZSBvZiB0aGVcbiAqIG1lZGlhLiBgbXV0ZWRgIGFuZCBgZGVmYXVsdE11dGVkYCBjYW4gaGF2ZSBkaWZmZXJlbnQgdmFsdWVzLiB7QGxpbmsgSHRtbDUjbXV0ZWR9IGluZGljYXRlcyB0aGVcbiAqIGN1cnJlbnQgc3RhdGUuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNkZWZhdWx0TXV0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBkZWZhdWx0TXV0ZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IG11dGVkLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgbm90IHN0YXJ0IG11dGVkXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1kZWZhdWx0bXV0ZWR9XG4gKi9cbidkZWZhdWx0TXV0ZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGF1dG9wbGF5YCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgYXV0b3BsYXlgIGluZGljYXRlc1xuICogdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IHRvIHBsYXkgYXMgc29vbiBhcyB0aGUgcGFnZSBpcyByZWFkeS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2F1dG9wbGF5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgYXV0b3BsYXlgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IGFzIHNvb24gYXMgdGhlIHBhZ2UgbG9hZHMuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBub3Qgc3RhcnQgYXMgc29vbiBhcyB0aGUgcGFnZSBsb2Fkcy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1hdXRvcGxheX1cbiAqL1xuJ2F1dG9wbGF5JyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBjb250cm9sc2AgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGNvbnRyb2xzYCBpbmRpY2F0ZXNcbiAqIHdoZXRoZXIgdGhlIG5hdGl2ZSBtZWRpYSBjb250cm9scyBzaG91bGQgYmUgc2hvd24gb3IgaGlkZGVuLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjY29udHJvbHNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBjb250cm9sc2AgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgc2hvd2luZy5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCBuYXRpdmUgY29udHJvbHMgc2hvdWxkIGJlIGhpZGRlbi5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1jb250cm9sc31cbiAqL1xuJ2NvbnRyb2xzJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBsb29wYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgbG9vcGAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBtZWRpYSBzaG91bGQgcmV0dXJuIHRvIHRoZSBzdGFydCBvZiB0aGUgbWVkaWEgYW5kIGNvbnRpbnVlIHBsYXlpbmcgb25jZVxuICogaXQgcmVhY2hlcyB0aGUgZW5kLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjbG9vcFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGxvb3BgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCBwbGF5YmFjayBzaG91bGQgc2VlayBiYWNrIHRvIHN0YXJ0IG9uY2VcbiAqICAgICAgICAgICB0aGUgZW5kIG9mIGEgbWVkaWEgaXMgcmVhY2hlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCBwbGF5YmFjayBzaG91bGQgbm90IGxvb3AgYmFjayB0byB0aGUgc3RhcnQgd2hlbiB0aGVcbiAqICAgICAgICAgICBlbmQgb2YgdGhlIG1lZGlhIGlzIHJlYWNoZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtbG9vcH1cbiAqL1xuJ2xvb3AnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHBsYXlzaW5saW5lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheXNpbmxpbmVgIGluZGljYXRlc1xuICogdG8gdGhlIGJyb3dzZXIgdGhhdCBub24tZnVsbHNjcmVlbiBwbGF5YmFjayBpcyBwcmVmZXJyZWQgd2hlbiBmdWxsc2NyZWVuXG4gKiBwbGF5YmFjayBpcyB0aGUgbmF0aXZlIGRlZmF1bHQsIHN1Y2ggYXMgaW4gaU9TIFNhZmFyaS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3BsYXlzaW5saW5lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgcGxheXNpbmxpbmVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgaW5saW5lLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgbm90IHBsYXkgaW5saW5lLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2F0dHItdmlkZW8tcGxheXNpbmxpbmV9XG4gKi9cbidwbGF5c2lubGluZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgSHRtbDUucHJvdG90eXBlW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsX1twcm9wXSB8fCB0aGlzLmVsXy5oYXNBdHRyaWJ1dGUocHJvcCk7XG4gIH07XG59KTtcblxuLy8gV3JhcCBuYXRpdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdpdGggc2V0dGVycyB0aGF0IHNldCBib3RoIHByb3BlcnR5IGFuZCBhdHRyaWJ1dGVcbi8vIFRoZSBsaXN0IGlzIGFzIGZvbGxvd2VkOlxuLy8gc2V0TXV0ZWQsIHNldERlZmF1bHRNdXRlZCwgc2V0QXV0b3BsYXksIHNldExvb3AsIHNldFBsYXlzaW5saW5lXG4vLyBzZXRDb250cm9scyBpcyBzcGVjaWFsLWNhc2VkIGFib3ZlXG5bXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYG11dGVkYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYG11dGVkYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudFxuICogYXVkaW8gbGV2ZWwgc2hvdWxkIGJlIHNpbGVudC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldE11dGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG11dGVkXG4gKiAgICAgICAgLSBUcnVlIGlmIHRoZSBhdWRpbyBzaG91bGQgYmUgc2V0IHRvIHNpbGVudFxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1tdXRlZH1cbiAqL1xuJ211dGVkJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBkZWZhdWx0TXV0ZWRgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgZGVmYXVsdE11dGVkYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudFxuICogYXVkaW8gbGV2ZWwgc2hvdWxkIGJlIHNpbGVudCwgYnV0IHdpbGwgb25seSBlZmZlY3QgdGhlIG11dGVkIGxldmVsIG9uIGludGlhbCBwbGF5YmFjay4uXG4gKlxuICogQG1ldGhvZCBIdG1sNS5wcm90b3R5cGUuc2V0RGVmYXVsdE11dGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRlZmF1bHRNdXRlZFxuICogICAgICAgIC0gVHJ1ZSBpZiB0aGUgYXVkaW8gc2hvdWxkIGJlIHNldCB0byBzaWxlbnRcbiAqICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZGVmYXVsdG11dGVkfVxuICovXG4nZGVmYXVsdE11dGVkJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBhdXRvcGxheWAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBhdXRvcGxheWAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgdG8gcGxheSBhcyBzb29uIGFzIHRoZSBwYWdlIGlzIHJlYWR5LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0QXV0b3BsYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b3BsYXlcbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgYXMgc29vbiBhcyB0aGUgcGFnZSBsb2Fkcy5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBzdGFydCBhcyBzb29uIGFzIHRoZSBwYWdlIGxvYWRzLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLWF1dG9wbGF5fVxuICovXG4nYXV0b3BsYXknLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYGxvb3BgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgbG9vcGAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBtZWRpYSBzaG91bGQgcmV0dXJuIHRvIHRoZSBzdGFydCBvZiB0aGUgbWVkaWEgYW5kIGNvbnRpbnVlIHBsYXlpbmcgb25jZVxuICogaXQgcmVhY2hlcyB0aGUgZW5kLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0TG9vcFxuICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCBwbGF5YmFjayBzaG91bGQgc2VlayBiYWNrIHRvIHN0YXJ0IG9uY2VcbiAqICAgICAgICAgICB0aGUgZW5kIG9mIGEgbWVkaWEgaXMgcmVhY2hlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCBwbGF5YmFjayBzaG91bGQgbm90IGxvb3AgYmFjayB0byB0aGUgc3RhcnQgd2hlbiB0aGVcbiAqICAgICAgICAgICBlbmQgb2YgdGhlIG1lZGlhIGlzIHJlYWNoZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtbG9vcH1cbiAqL1xuJ2xvb3AnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHBsYXlzaW5saW5lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheXNpbmxpbmVgIGluZGljYXRlc1xuICogdG8gdGhlIGJyb3dzZXIgdGhhdCBub24tZnVsbHNjcmVlbiBwbGF5YmFjayBpcyBwcmVmZXJyZWQgd2hlbiBmdWxsc2NyZWVuXG4gKiBwbGF5YmFjayBpcyB0aGUgbmF0aXZlIGRlZmF1bHQsIHN1Y2ggYXMgaW4gaU9TIFNhZmFyaS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFBsYXlzaW5saW5lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBsYXlzaW5saW5lXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgaW5saW5lLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgbm90IHBsYXkgaW5saW5lLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2F0dHItdmlkZW8tcGxheXNpbmxpbmV9XG4gKi9cbidwbGF5c2lubGluZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgSHRtbDUucHJvdG90eXBlWydzZXQnICsgdG9UaXRsZUNhc2UocHJvcCldID0gZnVuY3Rpb24gKHYpIHtcbiAgICB0aGlzLmVsX1twcm9wXSA9IHY7XG5cbiAgICBpZiAodikge1xuICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKHByb3AsIHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsXy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9O1xufSk7XG5cbi8vIFdyYXAgbmF0aXZlIHByb3BlcnRpZXMgd2l0aCBhIGdldHRlclxuLy8gVGhlIGxpc3QgaXMgYXMgZm9sbG93ZWRcbi8vIHBhdXNlZCwgY3VycmVudFRpbWUsIGJ1ZmZlcmVkLCB2b2x1bWUsIHBvc3RlciwgcHJlbG9hZCwgZXJyb3IsIHNlZWtpbmdcbi8vIHNlZWthYmxlLCBlbmRlZCwgcGxheWJhY2tSYXRlLCBkZWZhdWx0UGxheWJhY2tSYXRlLCBwbGF5ZWQsIG5ldHdvcmtTdGF0ZVxuLy8gcmVhZHlTdGF0ZSwgdmlkZW9XaWR0aCwgdmlkZW9IZWlnaHRcbltcbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcGF1c2VkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGF1c2VkYCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgbWVkaWEgZWxlbWVudFxuICogaXMgY3VycmVudGx5IHBhdXNlZCBvciBub3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwYXVzZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcGF1c2VkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGF1c2VkfVxuICovXG4ncGF1c2VkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBjdXJyZW50VGltZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGN1cnJlbnRUaW1lYCBpbmRpY2F0ZXNcbiAqIHRoZSBjdXJyZW50IHNlY29uZCB0aGF0IHRoZSBtZWRpYSBpcyBhdCBpbiBwbGF5YmFjay5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2N1cnJlbnRUaW1lXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgY3VycmVudFRpbWVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1jdXJyZW50dGltZX1cbiAqL1xuJ2N1cnJlbnRUaW1lJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBidWZmZXJlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGJ1ZmZlcmVkYCBpcyBhIGBUaW1lUmFuZ2VgXG4gKiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXJ0cyBvZiB0aGUgbWVkaWEgdGhhdCBhcmUgYWxyZWFkeSBkb3dubG9hZGVkIGFuZFxuICogYXZhaWxhYmxlIGZvciBwbGF5YmFjay5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2J1ZmZlcmVkXG4gKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgYnVmZmVyZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1idWZmZXJlZH1cbiAqL1xuJ2J1ZmZlcmVkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGB2b2x1bWVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGB2b2x1bWVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgcGxheWJhY2sgdm9sdW1lIG9mIGF1ZGlvIGZvciBhIG1lZGlhLiBgdm9sdW1lYCB3aWxsIGJlIGEgdmFsdWUgZnJvbSAwXG4gKiAoc2lsZW50KSB0byAxIChsb3VkZXN0IGFuZCBkZWZhdWx0KS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3ZvbHVtZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHZvbHVtZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gVmFsdWUgd2lsbCBiZSBiZXR3ZWVuIDAtMS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLWEtdm9sdW1lfVxuICovXG4ndm9sdW1lJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwb3N0ZXJgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwb3N0ZXJgIGluZGljYXRlc1xuICogdGhhdCB0aGUgdXJsIG9mIGFuIGltYWdlIGZpbGUgdGhhdCBjYW4vd2lsbCBiZSBzaG93biB3aGVuIG5vIG1lZGlhIGRhdGEgaXMgYXZhaWxhYmxlLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcG9zdGVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcG9zdGVyYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBWYWx1ZSB3aWxsIGJlIGEgdXJsIHRvIGFuXG4gKiAgICAgICAgIGltYWdlLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLXZpZGVvLXBvc3Rlcn1cbiAqL1xuJ3Bvc3RlcicsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcHJlbG9hZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHByZWxvYWRgIGluZGljYXRlc1xuICogd2hhdCBzaG91bGQgZG93bmxvYWQgYmVmb3JlIHRoZSBtZWRpYSBpcyBpbnRlcmFjdGVkIHdpdGguIEl0IGNhbiBoYXZlIHRoZSBmb2xsb3dpbmdcbiAqIHZhbHVlczpcbiAqIC0gbm9uZTogbm90aGluZyBzaG91bGQgYmUgZG93bmxvYWRlZFxuICogLSBtZXRhZGF0YTogcG9zdGVyIGFuZCB0aGUgZmlyc3QgZmV3IGZyYW1lcyBvZiB0aGUgbWVkaWEgbWF5IGJlIGRvd25sb2FkZWQgdG8gZ2V0XG4gKiAgIG1lZGlhIGRpbWVuc2lvbnMgYW5kIG90aGVyIG1ldGFkYXRhXG4gKiAtIGF1dG86IGFsbG93IHRoZSBtZWRpYSBhbmQgbWV0YWRhdGEgZm9yIHRoZSBtZWRpYSB0byBiZSBkb3dubG9hZGVkIGJlZm9yZVxuICogICAgaW50ZXJhY3Rpb25cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3ByZWxvYWRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwcmVsb2FkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBXaWxsIGJlICdub25lJywgJ21ldGFkYXRhJyxcbiAqICAgICAgICAgb3IgJ2F1dG8nLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLXByZWxvYWR9XG4gKi9cbidwcmVsb2FkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBgZXJyb3JgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBlcnJvcmAgaW5kaWNhdGVzIGFueVxuICogTWVkaWFFcnJvciB0aGF0IG1heSBoYXZlIG9jY3VycmVkIGR1cmluZyBwbGF5YmFjay4gSWYgZXJyb3IgcmV0dXJucyBudWxsIHRoZXJlIGlzIG5vXG4gKiBjdXJyZW50IGVycm9yLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjZXJyb3JcbiAqIEByZXR1cm4ge01lZGlhRXJyb3J8bnVsbH1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBlcnJvcmAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gV2lsbCBiZSBgTWVkaWFFcnJvcmAgaWYgdGhlcmVcbiAqICAgICAgICAgaXMgYSBjdXJyZW50IGVycm9yIGFuZCBudWxsIG90aGVyd2lzZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWVycm9yfVxuICovXG4nZXJyb3InLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHNlZWtpbmdgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBzZWVraW5nYCBpbmRpY2F0ZXMgd2hldGhlciB0aGVcbiAqIG1lZGlhIGlzIGN1cnJlbnRseSBzZWVraW5nIHRvIGEgbmV3IHBvc2l0aW9uIG9yIG5vdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NlZWtpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBzZWVraW5nYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBzZWVraW5nIHRvIGEgbmV3IHBvc2l0aW9uLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBpcyBub3Qgc2Vla2luZyB0byBhIG5ldyBwb3NpdGlvbiBhdCB0aGlzIHRpbWUuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1zZWVraW5nfVxuICovXG4nc2Vla2luZycsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgc2Vla2FibGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBzZWVrYWJsZWAgcmV0dXJucyBhXG4gKiBgVGltZVJhbmdlYCBvYmplY3QgaW5kaWNhdGluZyByYW5nZXMgb2YgdGltZSB0aGF0IGNhbiBjdXJyZW50bHkgYmUgYHNlZWtlZGAgdG8uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZWVrYWJsZVxuICogQHJldHVybiB7VGltZVJhbmdlfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHNlZWthYmxlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIGBUaW1lUmFuZ2VgIG9iamVjdFxuICogICAgICAgICBpbmRpY2F0aW5nIHRoZSBjdXJyZW50IHJhbmdlcyBvZiB0aW1lIHRoYXQgY2FuIGJlIHNlZWtlZCB0by5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXNlZWthYmxlfVxuICovXG4nc2Vla2FibGUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGVuZGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgZW5kZWRgIGluZGljYXRlcyB3aGV0aGVyXG4gKiB0aGUgbWVkaWEgaGFzIHJlYWNoZWQgdGhlIGVuZCBvciBub3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNlbmRlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGVuZGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIGhhcyBlbmRlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgaGFzIG5vdCBlbmRlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWVuZGVkfVxuICovXG4nZW5kZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHBsYXliYWNrUmF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHBsYXliYWNrUmF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgbWVkaWEgaXMgY3VycmVudGx5IHBsYXlpbmcgYmFjay4gRXhhbXBsZXM6XG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAyLCBtZWRpYSB3aWxsIHBsYXkgdHdpY2UgYXMgZmFzdC5cbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDAuNSwgbWVkaWEgd2lsbCBwbGF5IGhhbGYgYXMgZmFzdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3BsYXliYWNrUmF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHBsYXliYWNrUmF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gQSBudW1iZXIgaW5kaWNhdGluZ1xuICogICAgICAgICB0aGUgY3VycmVudCBwbGF5YmFjayBzcGVlZCBvZiB0aGUgbWVkaWEsIHdoZXJlIDEgaXMgbm9ybWFsIHNwZWVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGxheWJhY2tyYXRlfVxuICovXG4ncGxheWJhY2tSYXRlJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgZGVmYXVsdFBsYXliYWNrUmF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgbWVkaWEgaXMgY3VycmVudGx5IHBsYXlpbmcgYmFjay4gVGhpcyB2YWx1ZSB3aWxsIG5vdCBpbmRpY2F0ZSB0aGUgY3VycmVudFxuICogYHBsYXliYWNrUmF0ZWAgYWZ0ZXIgcGxheWJhY2sgaGFzIHN0YXJ0ZWQsIHVzZSB7QGxpbmsgSHRtbDUjcGxheWJhY2tSYXRlfSBmb3IgdGhhdC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqICAgLSBpZiBkZWZhdWx0UGxheWJhY2tSYXRlIGlzIHNldCB0byAyLCBtZWRpYSB3aWxsIHBsYXkgdHdpY2UgYXMgZmFzdC5cbiAqICAgLSBpZiBkZWZhdWx0UGxheWJhY2tSYXRlIGlzIHNldCB0byAwLjUsIG1lZGlhIHdpbGwgcGxheSBoYWxmIGFzIGZhc3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNS5wcm90b3R5cGUuZGVmYXVsdFBsYXliYWNrUmF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgbnVtYmVyIGluZGljYXRpbmdcbiAqICAgICAgICAgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG1lZGlhLCB3aGVyZSAxIGlzIG5vcm1hbCBzcGVlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBsYXliYWNrcmF0ZX1cbiAqL1xuJ2RlZmF1bHRQbGF5YmFja1JhdGUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHBsYXllZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHBsYXllZGAgcmV0dXJucyBhIGBUaW1lUmFuZ2VgXG4gKiBvYmplY3QgcmVwcmVzZW50aW5nIHBvaW50cyBpbiB0aGUgbWVkaWEgdGltZWxpbmUgdGhhdCBoYXZlIGJlZW4gcGxheWVkLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcGxheWVkXG4gKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcGxheWVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIGBUaW1lUmFuZ2VgIG9iamVjdCBpbmRpY2F0aW5nXG4gKiAgICAgICAgIHRoZSByYW5nZXMgb2YgdGltZSB0aGF0IGhhdmUgYmVlbiBwbGF5ZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5ZWR9XG4gKi9cbidwbGF5ZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYG5ldHdvcmtTdGF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYG5ldHdvcmtTdGF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCBuZXR3b3JrIHN0YXRlLiBJdCByZXR1cm5zIGFuIGVudW1lcmF0aW9uIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuICogLSAwOiBORVRXT1JLX0VNUFRZXG4gKiAtIDE6IE5FVFdPUktfSURMRVxuICogLSAyOiBORVRXT1JLX0xPQURJTkdcbiAqIC0gMzogTkVUV09SS19OT19TT1VSQ0VcbiAqXG4gKiBAbWV0aG9kIEh0bWw1I25ldHdvcmtTdGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYG5ldHdvcmtTdGF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyXG4gKiAgICAgICAgIGZyb20gdGhlIGxpc3QgaW4gdGhlIGRlc2NyaXB0aW9uLlxuICpcbiAqIEBzZWUgW1NwZWNdIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLW5ldHdvcmtzdGF0ZX1cbiAqL1xuJ25ldHdvcmtTdGF0ZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcmVhZHlTdGF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHJlYWR5U3RhdGVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIG1lZGlhIGVsZW1lbnQuIEl0IHJldHVybnMgYW4gZW51bWVyYXRpb24gZnJvbSB0aGVcbiAqIGZvbGxvd2luZyBsaXN0OlxuICogLSAwOiBIQVZFX05PVEhJTkdcbiAqIC0gMTogSEFWRV9NRVRBREFUQVxuICogLSAyOiBIQVZFX0NVUlJFTlRfREFUQVxuICogLSAzOiBIQVZFX0ZVVFVSRV9EQVRBXG4gKiAtIDQ6IEhBVkVfRU5PVUdIX0RBVEFcbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3JlYWR5U3RhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGByZWFkeVN0YXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBUaGlzIHdpbGwgYmUgYSBudW1iZXJcbiAqICAgICAgICAgZnJvbSB0aGUgbGlzdCBpbiB0aGUgZGVzY3JpcHRpb24uXG4gKlxuICogQHNlZSBbU3BlY10ge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNyZWFkeS1zdGF0ZXN9XG4gKi9cbidyZWFkeVN0YXRlJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGB2aWRlb1dpZHRoYCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBgdmlkZW9XaWR0aGAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCB3aWR0aCBvZiB0aGUgdmlkZW8gaW4gY3NzIHBpeGVscy5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3ZpZGVvV2lkdGhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGB2aWRlb1dpZHRoYCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBUaGlzIHdpbGwgYmUgYSBudW1iZXJcbiAqICAgICAgICAgaW4gY3NzIHBpeGVscy5cbiAqXG4gKiBAc2VlIFtTcGVjXSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS12aWRlby12aWRlb3dpZHRofVxuICovXG4ndmlkZW9XaWR0aCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgdmlkZW9IZWlnaHRgIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQuIGB2aWRlb0hlaWdodGAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIHZpZGVvIGluIGNzcyBwaXhlbHMuXG4gKlxuICogQG1ldGhvZCBIdG1sNSN2aWRlb0hlaWdodFxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHZpZGVvSGVpZ2h0YCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBUaGlzIHdpbGwgYmUgYSBudW1iZXJcbiAqICAgICAgICAgaW4gY3NzIHBpeGVscy5cbiAqXG4gKiBAc2VlIFtTcGVjXSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS12aWRlby12aWRlb3dpZHRofVxuICovXG4ndmlkZW9IZWlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIEh0bWw1LnByb3RvdHlwZVtwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF9bcHJvcF07XG4gIH07XG59KTtcblxuLy8gV3JhcCBuYXRpdmUgcHJvcGVydGllcyB3aXRoIGEgc2V0dGVyIGluIHRoaXMgZm9ybWF0OlxuLy8gc2V0ICsgdG9UaXRsZUNhc2UobmFtZSlcbi8vIFRoZSBsaXN0IGlzIGFzIGZvbGxvd3M6XG4vLyBzZXRWb2x1bWUsIHNldFNyYywgc2V0UG9zdGVyLCBzZXRQcmVsb2FkLCBzZXRQbGF5YmFja1JhdGUsIHNldERlZmF1bHRQbGF5YmFja1JhdGVcbltcbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYHZvbHVtZWAgaW5kaWNhdGVzIHRoZSBjdXJyZW50XG4gKiBhdWRpbyBsZXZlbCBhcyBhIHBlcmNlbnRhZ2UgaW4gZGVjaW1hbCBmb3JtLiBUaGlzIG1lYW5zIHRoYXQgMSBpcyAxMDAlLCAwLjUgaXMgNTAlLCBhbmRcbiAqIHNvIG9uLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0Vm9sdW1lXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudEFzRGVjaW1hbFxuICogICAgICAgIFRoZSB2b2x1bWUgcGVyY2VudCBhcyBhIGRlY2ltYWwuIFZhbGlkIHJhbmdlIGlzIGZyb20gMC0xLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tYS12b2x1bWV9XG4gKi9cbid2b2x1bWUnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHNyY2Agb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBzcmNgIGluZGljYXRlcyB0aGUgY3VycmVudFxuICoge0BsaW5rIFRlY2h+U291cmNlT2JqZWN0fSBmb3IgdGhlIG1lZGlhLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0U3JjXG4gKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzcmNcbiAqICAgICAgICBUaGUgc291cmNlIG9iamVjdCB0byBzZXQgYXMgdGhlIGN1cnJlbnQgc291cmNlLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtc3JjfVxuICovXG4nc3JjJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBwb3N0ZXJgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgcG9zdGVyYCBpcyB0aGUgdXJsIHRvXG4gKiBhbiBpbWFnZSBmaWxlIHRoYXQgY2FuL3dpbGwgYmUgc2hvd24gd2hlbiBubyBtZWRpYSBkYXRhIGlzIGF2YWlsYWJsZS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFBvc3RlclxuICogQHBhcmFtIHtzdHJpbmd9IHBvc3RlclxuICogICAgICAgIFRoZSB1cmwgdG8gYW4gaW1hZ2UgdGhhdCBzaG91bGQgYmUgdXNlZCBhcyB0aGUgYHBvc3RlcmAgZm9yIHRoZSBtZWRpYVxuICogICAgICAgIGVsZW1lbnQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtcG9zdGVyfVxuICovXG4ncG9zdGVyJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBwcmVsb2FkYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYHByZWxvYWRgIGluZGljYXRlc1xuICogd2hhdCBzaG91bGQgZG93bmxvYWQgYmVmb3JlIHRoZSBtZWRpYSBpcyBpbnRlcmFjdGVkIHdpdGguIEl0IGNhbiBoYXZlIHRoZSBmb2xsb3dpbmdcbiAqIHZhbHVlczpcbiAqIC0gbm9uZTogbm90aGluZyBzaG91bGQgYmUgZG93bmxvYWRlZFxuICogLSBtZXRhZGF0YTogcG9zdGVyIGFuZCB0aGUgZmlyc3QgZmV3IGZyYW1lcyBvZiB0aGUgbWVkaWEgbWF5IGJlIGRvd25sb2FkZWQgdG8gZ2V0XG4gKiAgIG1lZGlhIGRpbWVuc2lvbnMgYW5kIG90aGVyIG1ldGFkYXRhXG4gKiAtIGF1dG86IGFsbG93IHRoZSBtZWRpYSBhbmQgbWV0YWRhdGEgZm9yIHRoZSBtZWRpYSB0byBiZSBkb3dubG9hZGVkIGJlZm9yZVxuICogICAgaW50ZXJhY3Rpb25cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFByZWxvYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVsb2FkXG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcHJlbG9hZGAgdG8gc2V0IG9uIHRoZSBtZWRpYSBlbGVtZW50LiBNdXN0IGJlICdub25lJywgJ21ldGFkYXRhJyxcbiAqICAgICAgICAgb3IgJ2F1dG8nLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLXByZWxvYWR9XG4gKi9cbidwcmVsb2FkJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBwbGF5YmFja1JhdGVgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheWJhY2tSYXRlYCBpbmRpY2F0ZXNcbiAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBtZWRpYSBzaG91bGQgcGxheSBiYWNrLiBFeGFtcGxlczpcbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDIsIG1lZGlhIHdpbGwgcGxheSB0d2ljZSBhcyBmYXN0LlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMC41LCBtZWRpYSB3aWxsIHBsYXkgaGFsZiBhcyBmYXN0LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0UGxheWJhY2tSYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIG51bWJlciBpbmRpY2F0aW5nXG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHBsYXliYWNrIHNwZWVkIG9mIHRoZSBtZWRpYSwgd2hlcmUgMSBpcyBub3JtYWwgc3BlZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5YmFja3JhdGV9XG4gKi9cbidwbGF5YmFja1JhdGUnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgZGVmYXVsdFBsYXliYWNrUmF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgYmFjayB1cG9uIGluaXRpYWwgc3RhcnR1cC4gQ2hhbmdpbmcgdGhpcyB2YWx1ZVxuICogYWZ0ZXIgYSB2aWRlbyBoYXMgc3RhcnRlZCB3aWxsIGRvIG5vdGhpbmcuIEluc3RlYWQgeW91IHNob3VsZCB1c2VkIHtAbGluayBIdG1sNSNzZXRQbGF5YmFja1JhdGV9LlxuICpcbiAqIEV4YW1wbGUgVmFsdWVzOlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMiwgbWVkaWEgd2lsbCBwbGF5IHR3aWNlIGFzIGZhc3QuXG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAwLjUsIG1lZGlhIHdpbGwgcGxheSBoYWxmIGFzIGZhc3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNS5wcm90b3R5cGUuc2V0RGVmYXVsdFBsYXliYWNrUmF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgbnVtYmVyIGluZGljYXRpbmdcbiAqICAgICAgICAgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG1lZGlhLCB3aGVyZSAxIGlzIG5vcm1hbCBzcGVlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWRlZmF1bHRwbGF5YmFja3JhdGV9XG4gKi9cbidkZWZhdWx0UGxheWJhY2tSYXRlJ10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBIdG1sNS5wcm90b3R5cGVbJ3NldCcgKyB0b1RpdGxlQ2FzZShwcm9wKV0gPSBmdW5jdGlvbiAodikge1xuICAgIHRoaXMuZWxfW3Byb3BdID0gdjtcbiAgfTtcbn0pO1xuXG4vLyB3cmFwIG5hdGl2ZSBmdW5jdGlvbnMgd2l0aCBhIGZ1bmN0aW9uXG4vLyBUaGUgbGlzdCBpcyBhcyBmb2xsb3dzOlxuLy8gcGF1c2UsIGxvYWQsIHBsYXlcbltcbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgbWVkaWEgZWxlbWVudHMgYHBhdXNlYCBmdW5jdGlvbi4gVGhpcyB3aWxsIGNhbGwgdGhlIGBIVE1MNWBcbiAqIG1lZGlhIGVsZW1lbnRzIGBwYXVzZWAgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwYXVzZVxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wYXVzZX1cbiAqL1xuJ3BhdXNlJyxcblxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBtZWRpYSBlbGVtZW50cyBgbG9hZGAgZnVuY3Rpb24uIFRoaXMgd2lsbCBjYWxsIHRoZSBgSFRNTDVgc1xuICogbWVkaWEgZWxlbWVudCBgbG9hZGAgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNsb2FkXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWxvYWR9XG4gKi9cbidsb2FkJyxcblxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBtZWRpYSBlbGVtZW50cyBgcGxheWAgZnVuY3Rpb24uIFRoaXMgd2lsbCBjYWxsIHRoZSBgSFRNTDVgc1xuICogbWVkaWEgZWxlbWVudCBgcGxheWAgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwbGF5XG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBsYXl9XG4gKi9cbidwbGF5J10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBIdG1sNS5wcm90b3R5cGVbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfW3Byb3BdKCk7XG4gIH07XG59KTtcblxuVGVjaC53aXRoU291cmNlSGFuZGxlcnMoSHRtbDUpO1xuXG4vKipcbiAqIE5hdGl2ZSBzb3VyY2UgaGFuZGxlciBmb3IgSHRtbDUsIHNpbXBseSBwYXNzZXMgdGhlIHNvdXJjZSB0byB0aGUgbWVkaWEgZWxlbWVudC5cbiAqXG4gKiBAcHJvcGVydHkge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAqICAgICAgICBUaGUgc291cmNlIG9iamVjdFxuICpcbiAqIEBwcm9wZXJ0eSB7SHRtbDV9IHRlY2hcbiAqICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgdGhlIEhUTUw1IHRlY2guXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIgPSB7fTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgbWVkaWEgZWxlbWVudCBjYW4gcGxheSB0aGUgZ2l2ZW4gbWltZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgLy8gSUUgd2l0aG91dCBNZWRpYVBsYXllciB0aHJvd3MgYW4gZXJyb3IgKCM1MTkpXG4gIHRyeSB7XG4gICAgcmV0dXJuIEh0bWw1LlRFU1RfVklELmNhblBsYXlUeXBlKHR5cGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBtZWRpYSBlbGVtZW50IGNhbiBoYW5kbGUgYSBzb3VyY2UgbmF0aXZlbHkuXG4gKlxuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gKiAgICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgICBPcHRpb25zIHRvIGJlIHBhc3NlZCB0byB0aGUgdGVjaC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpLlxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhbkhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAvLyBJZiBhIHR5cGUgd2FzIHByb3ZpZGVkIHdlIHNob3VsZCByZWx5IG9uIHRoYXRcbiAgaWYgKHNvdXJjZS50eXBlKSB7XG4gICAgcmV0dXJuIEh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuY2FuUGxheVR5cGUoc291cmNlLnR5cGUpO1xuXG4gICAgLy8gSWYgbm8gdHlwZSwgZmFsbCBiYWNrIHRvIGNoZWNraW5nICd2aWRlby9bRVhURU5TSU9OXSdcbiAgfSBlbHNlIGlmIChzb3VyY2Uuc3JjKSB7XG4gICAgdmFyIGV4dCA9IGdldEZpbGVFeHRlbnNpb24oc291cmNlLnNyYyk7XG5cbiAgICByZXR1cm4gSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZSgndmlkZW8vJyArIGV4dCk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xuXG4vKipcbiAqIFBhc3MgdGhlIHNvdXJjZSB0byB0aGUgbmF0aXZlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge0h0bWw1fSB0ZWNoXG4gKiAgICAgICAgVGhlIGluc3RhbmNlIG9mIHRoZSBIdG1sNSB0ZWNoXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZVxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRlY2gsIG9wdGlvbnMpIHtcbiAgdGVjaC5zZXRTcmMoc291cmNlLnNyYyk7XG59O1xuXG4vKipcbiAqIEEgbm9vcCBmb3IgdGhlIG5hdGl2ZSBkaXNwb3NlIGZ1bmN0aW9uLCBhcyBjbGVhbnVwIGlzIG5vdCBuZWVkZWQuXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBSZWdpc3RlciB0aGUgbmF0aXZlIHNvdXJjZSBoYW5kbGVyXG5IdG1sNS5yZWdpc3RlclNvdXJjZUhhbmRsZXIoSHRtbDUubmF0aXZlU291cmNlSGFuZGxlcik7XG5cblRlY2gucmVnaXN0ZXJUZWNoKCdIdG1sNScsIEh0bWw1KTtcblxudmFyIF90ZW1wbGF0ZU9iamVjdCQyID0gdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UoWydcXG4gICAgICAgIFVzaW5nIHRoZSB0ZWNoIGRpcmVjdGx5IGNhbiBiZSBkYW5nZXJvdXMuIEkgaG9wZSB5b3Uga25vdyB3aGF0IHlvdVxcJ3JlIGRvaW5nLlxcbiAgICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8yNjE3IGZvciBtb3JlIGluZm8uXFxuICAgICAgJ10sIFsnXFxuICAgICAgICBVc2luZyB0aGUgdGVjaCBkaXJlY3RseSBjYW4gYmUgZGFuZ2Vyb3VzLiBJIGhvcGUgeW91IGtub3cgd2hhdCB5b3VcXCdyZSBkb2luZy5cXG4gICAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMjYxNyBmb3IgbW9yZSBpbmZvLlxcbiAgICAgICddKTtcblxuLy8gVGhlIGZvbGxvd2luZyB0ZWNoIGV2ZW50cyBhcmUgc2ltcGx5IHJlLXRyaWdnZXJlZFxuLy8gb24gdGhlIHBsYXllciB3aGVuIHRoZXkgaGFwcGVuXG52YXIgVEVDSF9FVkVOVFNfUkVUUklHR0VSID0gW1xuLyoqXG4gKiBGaXJlZCB3aGlsZSB0aGUgdXNlciBhZ2VudCBpcyBkb3dubG9hZGluZyBtZWRpYSBkYXRhLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjcHJvZ3Jlc3NcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGBwcm9ncmVzc2AgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hQcm9ncmVzc19cbiAqIEBmaXJlcyBQbGF5ZXIjcHJvZ3Jlc3NcbiAqIEBsaXN0ZW5zIFRlY2gjcHJvZ3Jlc3NcbiAqL1xuJ3Byb2dyZXNzJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBsb2FkaW5nIG9mIGFuIGF1ZGlvL3ZpZGVvIGlzIGFib3J0ZWQuXG4gKlxuICogQGV2ZW50IFBsYXllciNhYm9ydFxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYGFib3J0YCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaEFib3J0X1xuICogQGZpcmVzIFBsYXllciNhYm9ydFxuICogQGxpc3RlbnMgVGVjaCNhYm9ydFxuICovXG4nYWJvcnQnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaXMgaW50ZW50aW9uYWxseSBub3QgZ2V0dGluZyBtZWRpYSBkYXRhLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjc3VzcGVuZFxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHN1c3BlbmRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoU3VzcGVuZF9cbiAqIEBmaXJlcyBQbGF5ZXIjc3VzcGVuZFxuICogQGxpc3RlbnMgVGVjaCNzdXNwZW5kXG4gKi9cbidzdXNwZW5kJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBjdXJyZW50IHBsYXlsaXN0IGlzIGVtcHR5LlxuICpcbiAqIEBldmVudCBQbGF5ZXIjZW1wdGllZFxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYGVtcHRpZWRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoRW1wdGllZF9cbiAqIEBmaXJlcyBQbGF5ZXIjZW1wdGllZFxuICogQGxpc3RlbnMgVGVjaCNlbXB0aWVkXG4gKi9cbidlbXB0aWVkJyxcbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgYnJvd3NlciBpcyB0cnlpbmcgdG8gZ2V0IG1lZGlhIGRhdGEsIGJ1dCBkYXRhIGlzIG5vdCBhdmFpbGFibGUuXG4gKlxuICogQGV2ZW50IFBsYXllciNzdGFsbGVkXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgc3RhbGxlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hTdGFsbGVkX1xuICogQGZpcmVzIFBsYXllciNzdGFsbGVkXG4gKiBAbGlzdGVucyBUZWNoI3N0YWxsZWRcbiAqL1xuJ3N0YWxsZWQnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaGFzIGxvYWRlZCBtZXRhIGRhdGEgZm9yIHRoZSBhdWRpby92aWRlby5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI2xvYWRlZG1ldGFkYXRhXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgc3RhbGxlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hMb2FkZWRtZXRhZGF0YV9cbiAqIEBmaXJlcyBQbGF5ZXIjbG9hZGVkbWV0YWRhdGFcbiAqIEBsaXN0ZW5zIFRlY2gjbG9hZGVkbWV0YWRhdGFcbiAqL1xuJ2xvYWRlZG1ldGFkYXRhJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGhhcyBsb2FkZWQgdGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhlIGF1ZGlvL3ZpZGVvLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjbG9hZGVkZGF0YVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYGxvYWRlZGRhdGFgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoTG9hZGRlZGRhdGFfXG4gKiBAZmlyZXMgUGxheWVyI2xvYWRlZGRhdGFcbiAqIEBsaXN0ZW5zIFRlY2gjbG9hZGVkZGF0YVxuICovXG4nbG9hZGVkZGF0YScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBoYXMgY2hhbmdlZC5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI3RpbWV1cGRhdGVcbiAqIEB0eXBlIHtldmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGB0aW1ldXBkYXRlYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFRpbWVVcGRhdGVfXG4gKiBAZmlyZXMgUGxheWVyI3RpbWV1cGRhdGVcbiAqIEBsaXN0ZW5zIFRlY2gjdGltZXVwZGF0ZVxuICovXG4ndGltZXVwZGF0ZScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgdmlkZW8ncyBpbnRyaW5zaWMgZGltZW5zaW9ucyBjaGFuZ2VcbiAqXG4gKiBAZXZlbnQgUGxheWVyI3Jlc2l6ZVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHJlc2l6ZWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hSZXNpemVfXG4gKiBAZmlyZXMgUGxheWVyI3Jlc2l6ZVxuICogQGxpc3RlbnMgVGVjaCNyZXNpemVcbiAqL1xuJ3Jlc2l6ZScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgdm9sdW1lIGhhcyBiZWVuIGNoYW5nZWRcbiAqXG4gKiBAZXZlbnQgUGxheWVyI3ZvbHVtZWNoYW5nZVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHZvbHVtZWNoYW5nZWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hWb2x1bWVjaGFuZ2VfXG4gKiBAZmlyZXMgUGxheWVyI3ZvbHVtZWNoYW5nZVxuICogQGxpc3RlbnMgVGVjaCN2b2x1bWVjaGFuZ2VcbiAqL1xuJ3ZvbHVtZWNoYW5nZScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgdGV4dCB0cmFjayBoYXMgYmVlbiBjaGFuZ2VkXG4gKlxuICogQGV2ZW50IFBsYXllciN0ZXh0dHJhY2tjaGFuZ2VcbiAqIEB0eXBlIHtldmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGB0ZXh0dHJhY2tjaGFuZ2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoVGV4dHRyYWNrY2hhbmdlX1xuICogQGZpcmVzIFBsYXllciN0ZXh0dHJhY2tjaGFuZ2VcbiAqIEBsaXN0ZW5zIFRlY2gjdGV4dHRyYWNrY2hhbmdlXG4gKi9cbid0ZXh0dHJhY2tjaGFuZ2UnXTtcblxuLy8gZXZlbnRzIHRvIHF1ZXVlIHdoZW4gcGxheWJhY2sgcmF0ZSBpcyB6ZXJvXG4vLyB0aGlzIGlzIGEgaGFzaCBmb3IgdGhlIHNvbGUgcHVycG9zZSBvZiBtYXBwaW5nIG5vbi1jYW1lbC1jYXNlZCBldmVudCBuYW1lc1xuLy8gdG8gY2FtZWwtY2FzZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBURUNIX0VWRU5UU19RVUVVRSA9IHtcbiAgY2FucGxheTogJ0NhblBsYXknLFxuICBjYW5wbGF5dGhyb3VnaDogJ0NhblBsYXlUaHJvdWdoJyxcbiAgcGxheWluZzogJ1BsYXlpbmcnLFxuICBzZWVrZWQ6ICdTZWVrZWQnXG59O1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBgUGxheWVyYCBjbGFzcyBpcyBjcmVhdGVkIHdoZW4gYW55IG9mIHRoZSBWaWRlby5qcyBzZXR1cCBtZXRob2RzXG4gKiBhcmUgdXNlZCB0byBpbml0aWFsaXplIGEgdmlkZW8uXG4gKlxuICogQWZ0ZXIgYW4gaW5zdGFuY2UgaGFzIGJlZW4gY3JlYXRlZCBpdCBjYW4gYmUgYWNjZXNzZWQgZ2xvYmFsbHkgaW4gdHdvIHdheXM6XG4gKiAxLiBCeSBjYWxsaW5nIGB2aWRlb2pzKCdleGFtcGxlX3ZpZGVvXzEnKTtgXG4gKiAyLiBCeSB1c2luZyBpdCBkaXJlY3RseSB2aWEgIGB2aWRlb2pzLnBsYXllcnMuZXhhbXBsZV92aWRlb18xO2BcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUGxheWVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUGxheWVyLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFnXG4gICAqICAgICAgICBUaGUgb3JpZ2luYWwgdmlkZW8gRE9NIGVsZW1lbnQgdXNlZCBmb3IgY29uZmlndXJpbmcgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBSZWFkeSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIFBsYXllcih0YWcsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheWVyKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0YWcgSUQgZXhpc3RzXG4gICAgdGFnLmlkID0gdGFnLmlkIHx8IG9wdGlvbnMuaWQgfHwgJ3Zqc192aWRlb18nICsgbmV3R1VJRCgpO1xuXG4gICAgLy8gU2V0IE9wdGlvbnNcbiAgICAvLyBUaGUgb3B0aW9ucyBhcmd1bWVudCBvdmVycmlkZXMgb3B0aW9ucyBzZXQgaW4gdGhlIHZpZGVvIHRhZ1xuICAgIC8vIHdoaWNoIG92ZXJyaWRlcyBnbG9iYWxseSBzZXQgb3B0aW9ucy5cbiAgICAvLyBUaGlzIGxhdHRlciBwYXJ0IGNvaW5jaWRlcyB3aXRoIHRoZSBsb2FkIG9yZGVyXG4gICAgLy8gKHRhZyBtdXN0IGV4aXN0IGJlZm9yZSBQbGF5ZXIpXG4gICAgb3B0aW9ucyA9IGFzc2lnbihQbGF5ZXIuZ2V0VGFnU2V0dGluZ3ModGFnKSwgb3B0aW9ucyk7XG5cbiAgICAvLyBEZWxheSB0aGUgaW5pdGlhbGl6YXRpb24gb2YgY2hpbGRyZW4gYmVjYXVzZSB3ZSBuZWVkIHRvIHNldCB1cFxuICAgIC8vIHBsYXllciBwcm9wZXJ0aWVzIGZpcnN0LCBhbmQgY2FuJ3QgdXNlIGB0aGlzYCBiZWZvcmUgYHN1cGVyKClgXG4gICAgb3B0aW9ucy5pbml0Q2hpbGRyZW4gPSBmYWxzZTtcblxuICAgIC8vIFNhbWUgd2l0aCBjcmVhdGluZyB0aGUgZWxlbWVudFxuICAgIG9wdGlvbnMuY3JlYXRlRWwgPSBmYWxzZTtcblxuICAgIC8vIGRvbid0IGF1dG8gbWl4aW4gdGhlIGV2ZW50ZWQgbWl4aW5cbiAgICBvcHRpb25zLmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHBsYXllciB0byByZXBvcnQgdG91Y2ggYWN0aXZpdHkgb24gaXRzZWxmXG4gICAgLy8gc2VlIGVuYWJsZVRvdWNoQWN0aXZpdHkgaW4gQ29tcG9uZW50XG4gICAgb3B0aW9ucy5yZXBvcnRUb3VjaEFjdGl2aXR5ID0gZmFsc2U7XG5cbiAgICAvLyBJZiBsYW5ndWFnZSBpcyBub3Qgc2V0LCBnZXQgdGhlIGNsb3Nlc3QgbGFuZyBhdHRyaWJ1dGVcbiAgICBpZiAoIW9wdGlvbnMubGFuZ3VhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnLmNsb3Nlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNsb3Nlc3QgPSB0YWcuY2xvc2VzdCgnW2xhbmddJyk7XG5cbiAgICAgICAgaWYgKGNsb3Nlc3QgJiYgY2xvc2VzdC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICBvcHRpb25zLmxhbmd1YWdlID0gY2xvc2VzdC5nZXRBdHRyaWJ1dGUoJ2xhbmcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0YWc7XG5cbiAgICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIGlmIChnZXRBdHRyaWJ1dGVzKGVsZW1lbnQpLmhhc093blByb3BlcnR5KCdsYW5nJykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubGFuZ3VhZ2UgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbGFuZycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSdW4gYmFzZSBjb21wb25lbnQgaW5pdGlhbGl6aW5nIHdpdGggbmV3IG9wdGlvbnNcblxuICAgIC8vIFRyYWNrcyB3aGVuIGEgdGVjaCBjaGFuZ2VzIHRoZSBwb3N0ZXJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBudWxsLCBvcHRpb25zLCByZWFkeSkpO1xuXG4gICAgX3RoaXMuaXNQb3N0ZXJGcm9tVGVjaF8gPSBmYWxzZTtcblxuICAgIC8vIEhvbGRzIGNhbGxiYWNrIGluZm8gdGhhdCBnZXRzIHF1ZXVlZCB3aGVuIHBsYXliYWNrIHJhdGUgaXMgemVyb1xuICAgIC8vIGFuZCBhIHNlZWsgaXMgaGFwcGVuaW5nXG4gICAgX3RoaXMucXVldWVkQ2FsbGJhY2tzXyA9IFtdO1xuXG4gICAgLy8gVHVybiBvZmYgQVBJIGFjY2VzcyBiZWNhdXNlIHdlJ3JlIGxvYWRpbmcgYSBuZXcgdGVjaCB0aGF0IG1pZ2h0IGxvYWQgYXN5bmNocm9ub3VzbHlcbiAgICBfdGhpcy5pc1JlYWR5XyA9IGZhbHNlO1xuXG4gICAgLy8gSW5pdCBzdGF0ZSBoYXNTdGFydGVkX1xuICAgIF90aGlzLmhhc1N0YXJ0ZWRfID0gZmFsc2U7XG5cbiAgICAvLyBJbml0IHN0YXRlIHVzZXJBY3RpdmVfXG4gICAgX3RoaXMudXNlckFjdGl2ZV8gPSBmYWxzZTtcblxuICAgIC8vIGlmIHRoZSBnbG9iYWwgb3B0aW9uIG9iamVjdCB3YXMgYWNjaWRlbnRhbGx5IGJsb3duIGF3YXkgYnlcbiAgICAvLyBzb21lb25lLCBiYWlsIGVhcmx5IHdpdGggYW4gaW5mb3JtYXRpdmUgZXJyb3JcbiAgICBpZiAoIV90aGlzLm9wdGlvbnNfIHx8ICFfdGhpcy5vcHRpb25zXy50ZWNoT3JkZXIgfHwgIV90aGlzLm9wdGlvbnNfLnRlY2hPcmRlci5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdGVjaE9yZGVyIHNwZWNpZmllZC4gRGlkIHlvdSBvdmVyd3JpdGUgJyArICd2aWRlb2pzLm9wdGlvbnMgaW5zdGVhZCBvZiBqdXN0IGNoYW5naW5nIHRoZSAnICsgJ3Byb3BlcnRpZXMgeW91IHdhbnQgdG8gb3ZlcnJpZGU/Jyk7XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIHRhZyB1c2VkIHRvIHNldCBvcHRpb25zXG4gICAgX3RoaXMudGFnID0gdGFnO1xuXG4gICAgLy8gU3RvcmUgdGhlIHRhZyBhdHRyaWJ1dGVzIHVzZWQgdG8gcmVzdG9yZSBodG1sNSBlbGVtZW50XG4gICAgX3RoaXMudGFnQXR0cmlidXRlcyA9IHRhZyAmJiBnZXRBdHRyaWJ1dGVzKHRhZyk7XG5cbiAgICAvLyBVcGRhdGUgY3VycmVudCBsYW5ndWFnZVxuICAgIF90aGlzLmxhbmd1YWdlKF90aGlzLm9wdGlvbnNfLmxhbmd1YWdlKTtcblxuICAgIC8vIFVwZGF0ZSBTdXBwb3J0ZWQgTGFuZ3VhZ2VzXG4gICAgaWYgKG9wdGlvbnMubGFuZ3VhZ2VzKSB7XG4gICAgICAvLyBOb3JtYWxpc2UgcGxheWVyIG9wdGlvbiBsYW5ndWFnZXMgdG8gbG93ZXJjYXNlXG4gICAgICB2YXIgbGFuZ3VhZ2VzVG9Mb3dlciA9IHt9O1xuXG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvcHRpb25zLmxhbmd1YWdlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSQkMSkge1xuICAgICAgICBsYW5ndWFnZXNUb0xvd2VyW25hbWUkJDEudG9Mb3dlckNhc2UoKV0gPSBvcHRpb25zLmxhbmd1YWdlc1tuYW1lJCQxXTtcbiAgICAgIH0pO1xuICAgICAgX3RoaXMubGFuZ3VhZ2VzXyA9IGxhbmd1YWdlc1RvTG93ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmxhbmd1YWdlc18gPSBQbGF5ZXIucHJvdG90eXBlLm9wdGlvbnNfLmxhbmd1YWdlcztcbiAgICB9XG5cbiAgICAvLyBDYWNoZSBmb3IgdmlkZW8gcHJvcGVydHkgdmFsdWVzLlxuICAgIF90aGlzLmNhY2hlXyA9IHt9O1xuXG4gICAgLy8gU2V0IHBvc3RlclxuICAgIF90aGlzLnBvc3Rlcl8gPSBvcHRpb25zLnBvc3RlciB8fCAnJztcblxuICAgIC8vIFNldCBjb250cm9sc1xuICAgIF90aGlzLmNvbnRyb2xzXyA9ICEhb3B0aW9ucy5jb250cm9scztcblxuICAgIC8vIFNldCBkZWZhdWx0IHZhbHVlcyBmb3IgbGFzdFZvbHVtZVxuICAgIF90aGlzLmNhY2hlXy5sYXN0Vm9sdW1lID0gMTtcblxuICAgIC8vIE9yaWdpbmFsIHRhZyBzZXR0aW5ncyBzdG9yZWQgaW4gb3B0aW9uc1xuICAgIC8vIG5vdyByZW1vdmUgaW1tZWRpYXRlbHkgc28gbmF0aXZlIGNvbnRyb2xzIGRvbid0IGZsYXNoLlxuICAgIC8vIE1heSBiZSB0dXJuZWQgYmFjayBvbiBieSBIVE1MNSB0ZWNoIGlmIG5hdGl2ZUNvbnRyb2xzRm9yVG91Y2ggaXMgdHJ1ZVxuICAgIHRhZy5jb250cm9scyA9IGZhbHNlO1xuICAgIHRhZy5yZW1vdmVBdHRyaWJ1dGUoJ2NvbnRyb2xzJyk7XG5cbiAgICAvLyB0aGUgYXR0cmlidXRlIG92ZXJyaWRlcyB0aGUgb3B0aW9uXG4gICAgaWYgKHRhZy5oYXNBdHRyaWJ1dGUoJ2F1dG9wbGF5JykpIHtcbiAgICAgIF90aGlzLm9wdGlvbnNfLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIHVzZSB0aGUgc2V0dGVyIHRvIHZhbGlkYXRlIGFuZFxuICAgICAgLy8gc2V0IHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgICAgX3RoaXMuYXV0b3BsYXkoX3RoaXMub3B0aW9uc18uYXV0b3BsYXkpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogU3RvcmUgdGhlIGludGVybmFsIHN0YXRlIG9mIHNjcnViYmluZ1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB1c2VyIGlzIHNjcnViYmluZ1xuICAgICAqL1xuICAgIF90aGlzLnNjcnViYmluZ18gPSBmYWxzZTtcblxuICAgIF90aGlzLmVsXyA9IF90aGlzLmNyZWF0ZUVsKCk7XG5cbiAgICAvLyBTZXQgZGVmYXVsdCB2YWx1ZSBmb3IgbGFzdFBsYXliYWNrUmF0ZVxuICAgIF90aGlzLmNhY2hlXy5sYXN0UGxheWJhY2tSYXRlID0gX3RoaXMuZGVmYXVsdFBsYXliYWNrUmF0ZSgpO1xuXG4gICAgLy8gTWFrZSB0aGlzIGFuIGV2ZW50ZWQgb2JqZWN0IGFuZCB1c2UgYGVsX2AgYXMgaXRzIGV2ZW50IGJ1cy5cbiAgICBldmVudGVkKF90aGlzLCB7IGV2ZW50QnVzS2V5OiAnZWxfJyB9KTtcblxuICAgIC8vIFdlIGFsc28gd2FudCB0byBwYXNzIHRoZSBvcmlnaW5hbCBwbGF5ZXIgb3B0aW9ucyB0byBlYWNoIGNvbXBvbmVudCBhbmQgcGx1Z2luXG4gICAgLy8gYXMgd2VsbCBzbyB0aGV5IGRvbid0IG5lZWQgdG8gcmVhY2ggYmFjayBpbnRvIHRoZSBwbGF5ZXIgZm9yIG9wdGlvbnMgbGF0ZXIuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGRvIGFub3RoZXIgY29weSBvZiB0aGlzLm9wdGlvbnNfIHNvIHdlIGRvbid0IGVuZCB1cCB3aXRoXG4gICAgLy8gYW4gaW5maW5pdGUgbG9vcC5cbiAgICB2YXIgcGxheWVyT3B0aW9uc0NvcHkgPSBtZXJnZU9wdGlvbnMoX3RoaXMub3B0aW9uc18pO1xuXG4gICAgLy8gTG9hZCBwbHVnaW5zXG4gICAgaWYgKG9wdGlvbnMucGx1Z2lucykge1xuICAgICAgdmFyIHBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnM7XG5cbiAgICAgIE9iamVjdC5rZXlzKHBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUkJDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW25hbWUkJDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpc1tuYW1lJCQxXShwbHVnaW5zW25hbWUkJDFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BsdWdpbiBcIicgKyBuYW1lJCQxICsgJ1wiIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sIF90aGlzKTtcbiAgICB9XG5cbiAgICBfdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zID0gcGxheWVyT3B0aW9uc0NvcHk7XG5cbiAgICBfdGhpcy5taWRkbGV3YXJlXyA9IFtdO1xuXG4gICAgX3RoaXMuaW5pdENoaWxkcmVuKCk7XG5cbiAgICAvLyBTZXQgaXNBdWRpbyBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBhbiBhdWRpbyB0YWcgd2FzIHVzZWRcbiAgICBfdGhpcy5pc0F1ZGlvKHRhZy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYXVkaW8nKTtcblxuICAgIC8vIFVwZGF0ZSBjb250cm9scyBjbGFzc05hbWUuIENhbid0IGRvIHRoaXMgd2hlbiB0aGUgY29udHJvbHMgYXJlIGluaXRpYWxseVxuICAgIC8vIHNldCBiZWNhdXNlIHRoZSBlbGVtZW50IGRvZXNuJ3QgZXhpc3QgeWV0LlxuICAgIGlmIChfdGhpcy5jb250cm9scygpKSB7XG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWVuYWJsZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1kaXNhYmxlZCcpO1xuICAgIH1cblxuICAgIC8vIFNldCBBUklBIGxhYmVsIGFuZCByZWdpb24gcm9sZSBkZXBlbmRpbmcgb24gcGxheWVyIHR5cGVcbiAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ3JlZ2lvbicpO1xuICAgIGlmIChfdGhpcy5pc0F1ZGlvKCkpIHtcbiAgICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBfdGhpcy5sb2NhbGl6ZSgnQXVkaW8gUGxheWVyJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgX3RoaXMubG9jYWxpemUoJ1ZpZGVvIFBsYXllcicpKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuaXNBdWRpbygpKSB7XG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLWF1ZGlvJyk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmZsZXhOb3RTdXBwb3J0ZWRfKCkpIHtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtbm8tZmxleCcpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IE1ha2UgdGhpcyBzbWFydGVyLiBUb2dnbGUgdXNlciBzdGF0ZSBiZXR3ZWVuIHRvdWNoaW5nL21vdXNpbmdcbiAgICAvLyB1c2luZyBldmVudHMsIHNpbmNlIGRldmljZXMgY2FuIGhhdmUgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzLlxuICAgIC8vIGlmIChicm93c2VyLlRPVUNIX0VOQUJMRUQpIHtcbiAgICAvLyAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy10b3VjaC1lbmFibGVkJyk7XG4gICAgLy8gfVxuXG4gICAgLy8gaU9TIFNhZmFyaSBoYXMgYnJva2VuIGhvdmVyIGhhbmRsaW5nXG4gICAgaWYgKCFJU19JT1MpIHtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtd29ya2luZ2hvdmVyJyk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBwbGF5ZXIgZWFzaWx5IGZpbmRhYmxlIGJ5IElEXG4gICAgUGxheWVyLnBsYXllcnNbX3RoaXMuaWRfXSA9IF90aGlzO1xuXG4gICAgLy8gQWRkIGEgbWFqb3IgdmVyc2lvbiBjbGFzcyB0byBhaWQgY3NzIGluIHBsdWdpbnNcbiAgICB2YXIgbWFqb3JWZXJzaW9uID0gdmVyc2lvbi5zcGxpdCgnLicpWzBdO1xuXG4gICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy12JyArIG1ham9yVmVyc2lvbik7XG5cbiAgICAvLyBXaGVuIHRoZSBwbGF5ZXIgaXMgZmlyc3QgaW5pdGlhbGl6ZWQsIHRyaWdnZXIgYWN0aXZpdHkgc28gY29tcG9uZW50c1xuICAgIC8vIGxpa2UgdGhlIGNvbnRyb2wgYmFyIHNob3cgdGhlbXNlbHZlcyBpZiBuZWVkZWRcbiAgICBfdGhpcy51c2VyQWN0aXZlKHRydWUpO1xuICAgIF90aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSgpO1xuXG4gICAgX3RoaXMub25lKCdwbGF5JywgX3RoaXMubGlzdGVuRm9yVXNlckFjdGl2aXR5Xyk7XG4gICAgX3RoaXMub24oJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBfdGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlXyk7XG4gICAgX3RoaXMub24oJ3N0YWdlY2xpY2snLCBfdGhpcy5oYW5kbGVTdGFnZUNsaWNrXyk7XG5cbiAgICBfdGhpcy5jaGFuZ2luZ1NyY18gPSBmYWxzZTtcbiAgICBfdGhpcy5wbGF5V2FpdGluZ0ZvclJlYWR5XyA9IGZhbHNlO1xuICAgIF90aGlzLnBsYXlPbkxvYWRzdGFydF8gPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgdmlkZW8gcGxheWVyIGFuZCBkb2VzIGFueSBuZWNlc3NhcnkgY2xlYW51cC5cbiAgICpcbiAgICogVGhpcyBpcyBlc3BlY2lhbGx5IGhlbHBmdWwgaWYgeW91IGFyZSBkeW5hbWljYWxseSBhZGRpbmcgYW5kIHJlbW92aW5nIHZpZGVvc1xuICAgKiB0by9mcm9tIHRoZSBET00uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZGlzcG9zZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHBsYXllciBpcyBiZWluZyBkaXNwb3NlZCBvZi5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZGlzcG9zZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2Rpc3Bvc2UnKTtcbiAgICAvLyBwcmV2ZW50IGRpc3Bvc2UgZnJvbSBiZWluZyBjYWxsZWQgdHdpY2VcbiAgICB0aGlzLm9mZignZGlzcG9zZScpO1xuXG4gICAgaWYgKHRoaXMuc3R5bGVFbF8gJiYgdGhpcy5zdHlsZUVsXy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLnN0eWxlRWxfLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zdHlsZUVsXyk7XG4gICAgICB0aGlzLnN0eWxlRWxfID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBLaWxsIHJlZmVyZW5jZSB0byB0aGlzIHBsYXllclxuICAgIFBsYXllci5wbGF5ZXJzW3RoaXMuaWRfXSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy50YWcgJiYgdGhpcy50YWcucGxheWVyKSB7XG4gICAgICB0aGlzLnRhZy5wbGF5ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsXyAmJiB0aGlzLmVsXy5wbGF5ZXIpIHtcbiAgICAgIHRoaXMuZWxfLnBsYXllciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHRoaXMudGVjaF8uZGlzcG9zZSgpO1xuICAgICAgdGhpcy5pc1Bvc3RlckZyb21UZWNoXyA9IGZhbHNlO1xuICAgICAgdGhpcy5wb3N0ZXJfID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGxheWVyRWxJbmdlc3RfKSB7XG4gICAgICB0aGlzLnBsYXllckVsSW5nZXN0XyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICB0aGlzLnRhZyA9IG51bGw7XG4gICAgfVxuXG4gICAgY2xlYXJDYWNoZUZvclBsYXllcih0aGlzKTtcblxuICAgIC8vIHRoZSBhY3R1YWwgLmVsXyBpcyByZW1vdmVkIGhlcmVcbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYFBsYXllcmAncyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgRE9NIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZztcbiAgICB2YXIgZWwgPSB2b2lkIDA7XG4gICAgdmFyIHBsYXllckVsSW5nZXN0ID0gdGhpcy5wbGF5ZXJFbEluZ2VzdF8gPSB0YWcucGFyZW50Tm9kZSAmJiB0YWcucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUgJiYgdGFnLnBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXZqcy1wbGF5ZXInKTtcbiAgICB2YXIgZGl2RW1iZWQgPSB0aGlzLnRhZy50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby1qcyc7XG5cbiAgICBpZiAocGxheWVyRWxJbmdlc3QpIHtcbiAgICAgIGVsID0gdGhpcy5lbF8gPSB0YWcucGFyZW50Tm9kZTtcbiAgICB9IGVsc2UgaWYgKCFkaXZFbWJlZCkge1xuICAgICAgZWwgPSB0aGlzLmVsXyA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicpO1xuICAgIH1cblxuICAgIC8vIENvcHkgb3ZlciBhbGwgdGhlIGF0dHJpYnV0ZXMgZnJvbSB0aGUgdGFnLCBpbmNsdWRpbmcgSUQgYW5kIGNsYXNzXG4gICAgLy8gSUQgd2lsbCBub3cgcmVmZXJlbmNlIHBsYXllciBib3gsIG5vdCB0aGUgdmlkZW8gdGFnXG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cmlidXRlcyh0YWcpO1xuXG4gICAgaWYgKGRpdkVtYmVkKSB7XG4gICAgICBlbCA9IHRoaXMuZWxfID0gdGFnO1xuICAgICAgdGFnID0gdGhpcy50YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgd2hpbGUgKGVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB0YWcuYXBwZW5kQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzQ2xhc3MoZWwsICd2aWRlby1qcycpKSB7XG4gICAgICAgIGFkZENsYXNzKGVsLCAndmlkZW8tanMnKTtcbiAgICAgIH1cblxuICAgICAgZWwuYXBwZW5kQ2hpbGQodGFnKTtcblxuICAgICAgcGxheWVyRWxJbmdlc3QgPSB0aGlzLnBsYXllckVsSW5nZXN0XyA9IGVsO1xuICAgICAgLy8gbW92ZSBwcm9wZXJ0aWVzIG92ZXIgZnJvbSBvdXIgY3VzdG9tIGB2aWRlby1qc2AgZWxlbWVudFxuICAgICAgLy8gdG8gb3VyIG5ldyBgdmlkZW9gIGVsZW1lbnQuIFRoaXMgd2lsbCBtb3ZlIHRoaW5ncyBsaWtlXG4gICAgICAvLyBgc3JjYCBvciBgY29udHJvbHNgIHRoYXQgd2VyZSBzZXQgdmlhIGpzIGJlZm9yZSB0aGUgcGxheWVyXG4gICAgICAvLyB3YXMgaW5pdGlhbGl6ZWQuXG4gICAgICBPYmplY3Qua2V5cyhlbCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICB0YWdba10gPSBlbFtrXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHNldCB0YWJpbmRleCB0byAtMSB0byByZW1vdmUgdGhlIHZpZGVvIGVsZW1lbnQgZnJvbSB0aGUgZm9jdXMgb3JkZXJcbiAgICB0YWcuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgIC8vIFdvcmthcm91bmQgZm9yICM0NTgzIChKQVdTK0lFIGRvZXNuJ3QgYW5ub3VuY2UgQlBCIG9yIHBsYXkgYnV0dG9uKVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRnJlZWRvbVNjaWVudGlmaWMvVkZPLXN0YW5kYXJkcy1zdXBwb3J0L2lzc3Vlcy83OFxuICAgIC8vIE5vdGUgdGhhdCB3ZSBjYW4ndCBkZXRlY3QgaWYgSkFXUyBpcyBiZWluZyB1c2VkLCBidXQgdGhpcyBBUklBIGF0dHJpYnV0ZVxuICAgIC8vICBkb2Vzbid0IGNoYW5nZSBiZWhhdmlvciBvZiBJRTExIGlmIEpBV1MgaXMgbm90IGJlaW5nIHVzZWRcbiAgICBpZiAoSUVfVkVSU0lPTikge1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgncm9sZScsICdhcHBsaWNhdGlvbicpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB3aWR0aC9oZWlnaHQgYXR0cnMgZnJvbSB0YWcgc28gQ1NTIGNhbiBtYWtlIGl0IDEwMCUgd2lkdGgvaGVpZ2h0XG4gICAgdGFnLnJlbW92ZUF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICB0YWcucmVtb3ZlQXR0cmlidXRlKCdoZWlnaHQnKTtcblxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAvLyBkb24ndCBjb3B5IG92ZXIgdGhlIGNsYXNzIGF0dHJpYnV0ZSB0byB0aGUgcGxheWVyIGVsZW1lbnQgd2hlbiB3ZSdyZSBpbiBhIGRpdiBlbWJlZFxuICAgICAgLy8gdGhlIGNsYXNzIGlzIGFscmVhZHkgc2V0IHVwIHByb3Blcmx5IGluIHRoZSBkaXZFbWJlZCBjYXNlXG4gICAgICAvLyBhbmQgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYHZpZGVvLWpzYCBjbGFzcyBkb2Vzbid0IGdldCBsb3N0XG4gICAgICBpZiAoIShkaXZFbWJlZCAmJiBhdHRyID09PSAnY2xhc3MnKSkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGl2RW1iZWQpIHtcbiAgICAgICAgdGFnLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgdGFnIGlkL2NsYXNzIGZvciB1c2UgYXMgSFRNTDUgcGxheWJhY2sgdGVjaFxuICAgIC8vIE1pZ2h0IHRoaW5rIHdlIHNob3VsZCBkbyB0aGlzIGFmdGVyIGVtYmVkZGluZyBpbiBjb250YWluZXIgc28gLnZqcy10ZWNoIGNsYXNzXG4gICAgLy8gZG9lc24ndCBmbGFzaCAxMDAlIHdpZHRoL2hlaWdodCwgYnV0IGNsYXNzIG9ubHkgYXBwbGllcyB3aXRoIC52aWRlby1qcyBwYXJlbnRcbiAgICB0YWcucGxheWVySWQgPSB0YWcuaWQ7XG4gICAgdGFnLmlkICs9ICdfaHRtbDVfYXBpJztcbiAgICB0YWcuY2xhc3NOYW1lID0gJ3Zqcy10ZWNoJztcblxuICAgIC8vIE1ha2UgcGxheWVyIGZpbmRhYmxlIG9uIGVsZW1lbnRzXG4gICAgdGFnLnBsYXllciA9IGVsLnBsYXllciA9IHRoaXM7XG4gICAgLy8gRGVmYXVsdCBzdGF0ZSBvZiB2aWRlbyBpcyBwYXVzZWRcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtcGF1c2VkJyk7XG5cbiAgICAvLyBBZGQgYSBzdHlsZSBlbGVtZW50IGluIHRoZSBwbGF5ZXIgdGhhdCB3ZSdsbCB1c2UgdG8gc2V0IHRoZSB3aWR0aC9oZWlnaHRcbiAgICAvLyBvZiB0aGUgcGxheWVyIGluIGEgd2F5IHRoYXQncyBzdGlsbCBvdmVycmlkZWFibGUgYnkgQ1NTLCBqdXN0IGxpa2UgdGhlXG4gICAgLy8gdmlkZW8gZWxlbWVudFxuICAgIGlmICh3aW5kb3ckMS5WSURFT0pTX05PX0RZTkFNSUNfU1RZTEUgIT09IHRydWUpIHtcbiAgICAgIHRoaXMuc3R5bGVFbF8gPSBjcmVhdGVTdHlsZUVsZW1lbnQoJ3Zqcy1zdHlsZXMtZGltZW5zaW9ucycpO1xuICAgICAgdmFyIGRlZmF1bHRzU3R5bGVFbCA9ICQoJy52anMtc3R5bGVzLWRlZmF1bHRzJyk7XG4gICAgICB2YXIgaGVhZCA9ICQoJ2hlYWQnKTtcblxuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUodGhpcy5zdHlsZUVsXywgZGVmYXVsdHNTdHlsZUVsID8gZGVmYXVsdHNTdHlsZUVsLm5leHRTaWJsaW5nIDogaGVhZC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICAvLyBQYXNzIGluIHRoZSB3aWR0aC9oZWlnaHQvYXNwZWN0UmF0aW8gb3B0aW9ucyB3aGljaCB3aWxsIHVwZGF0ZSB0aGUgc3R5bGUgZWxcbiAgICB0aGlzLndpZHRoKHRoaXMub3B0aW9uc18ud2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0KHRoaXMub3B0aW9uc18uaGVpZ2h0KTtcbiAgICB0aGlzLmZsdWlkKHRoaXMub3B0aW9uc18uZmx1aWQpO1xuICAgIHRoaXMuYXNwZWN0UmF0aW8odGhpcy5vcHRpb25zXy5hc3BlY3RSYXRpbyk7XG5cbiAgICAvLyBIaWRlIGFueSBsaW5rcyB3aXRoaW4gdGhlIHZpZGVvL2F1ZGlvIHRhZyxcbiAgICAvLyBiZWNhdXNlIElFIGRvZXNuJ3QgaGlkZSB0aGVtIGNvbXBsZXRlbHkgZnJvbSBzY3JlZW4gcmVhZGVycy5cbiAgICB2YXIgbGlua3MgPSB0YWcuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5rRWwgPSBsaW5rcy5pdGVtKGkpO1xuXG4gICAgICBhZGRDbGFzcyhsaW5rRWwsICd2anMtaGlkZGVuJyk7XG4gICAgICBsaW5rRWwuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAnaGlkZGVuJyk7XG4gICAgfVxuXG4gICAgLy8gaW5zZXJ0RWxGaXJzdCBzZWVtcyB0byBjYXVzZSB0aGUgbmV0d29ya1N0YXRlIHRvIGZsaWNrZXIgZnJvbSAzIHRvIDIsIHNvXG4gICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgb3JpZ2luYWwgZm9yIGxhdGVyIHNvIHdlIGNhbiBrbm93IGlmIHRoZSBzb3VyY2Ugb3JpZ2luYWxseSBmYWlsZWRcbiAgICB0YWcuaW5pdE5ldHdvcmtTdGF0ZV8gPSB0YWcubmV0d29ya1N0YXRlO1xuXG4gICAgLy8gV3JhcCB2aWRlbyB0YWcgaW4gZGl2IChlbC9ib3gpIGNvbnRhaW5lclxuICAgIGlmICh0YWcucGFyZW50Tm9kZSAmJiAhcGxheWVyRWxJbmdlc3QpIHtcbiAgICAgIHRhZy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgdGFnKTtcbiAgICB9XG5cbiAgICAvLyBpbnNlcnQgdGhlIHRhZyBhcyB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIHBsYXllciBlbGVtZW50XG4gICAgLy8gdGhlbiBtYW51YWxseSBhZGQgaXQgdG8gdGhlIGNoaWxkcmVuIGFycmF5IHNvIHRoYXQgdGhpcy5hZGRDaGlsZFxuICAgIC8vIHdpbGwgd29yayBwcm9wZXJseSBmb3Igb3RoZXIgY29tcG9uZW50c1xuICAgIC8vXG4gICAgLy8gQnJlYWtzIGlQaG9uZSwgZml4ZWQgaW4gSFRNTDUgc2V0dXAuXG4gICAgcHJlcGVuZFRvKHRhZywgZWwpO1xuICAgIHRoaXMuY2hpbGRyZW5fLnVuc2hpZnQodGFnKTtcblxuICAgIC8vIFNldCBsYW5nIGF0dHIgb24gcGxheWVyIHRvIGVuc3VyZSBDU1MgOmxhbmcoKSBpbiBjb25zaXN0ZW50IHdpdGggcGxheWVyXG4gICAgLy8gaWYgaXQncyBiZWVuIHNldCB0byBzb21ldGhpbmcgZGlmZmVyZW50IHRvIHRoZSBkb2NcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2xhbmcnLCB0aGlzLmxhbmd1YWdlXyk7XG5cbiAgICB0aGlzLmVsXyA9IGVsO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgUGxheWVyYCdzIHdpZHRoLiBSZXR1cm5zIHRoZSBwbGF5ZXIncyBjb25maWd1cmVkIHZhbHVlLlxuICAgKiBUbyBnZXQgdGhlIGN1cnJlbnQgd2lkdGggdXNlIGBjdXJyZW50V2lkdGgoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWVdXG4gICAqICAgICAgICBUaGUgdmFsdWUgdG8gc2V0IHRoZSBgUGxheWVyYCdzIHdpZHRoIHRvLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIGBQbGF5ZXJgIHdoZW4gZ2V0dGluZy5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gd2lkdGgodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oJ3dpZHRoJywgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgUGxheWVyYCdzIGhlaWdodC4gUmV0dXJucyB0aGUgcGxheWVyJ3MgY29uZmlndXJlZCB2YWx1ZS5cbiAgICogVG8gZ2V0IHRoZSBjdXJyZW50IGhlaWdodCB1c2UgYGN1cnJlbnRoZWlnaHQoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWVdXG4gICAqICAgICAgICBUaGUgdmFsdWUgdG8gc2V0IHRoZSBgUGxheWVyYCdzIGhlaWd0aCB0by5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgYFBsYXllcmAgd2hlbiBnZXR0aW5nLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gaGVpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCdoZWlnaHQnLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3Mgd2lkdGggJiBoZWlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1lbnNpb25cbiAgICogICAgICAgIFRoaXMgc3RyaW5nIGNhbiBiZTpcbiAgICogICAgICAgIC0gJ3dpZHRoJ1xuICAgKiAgICAgICAgLSAnaGVpZ2h0J1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlXVxuICAgKiAgICAgICAgVmFsdWUgZm9yIGRpbWVuc2lvbiBzcGVjaWZpZWQgaW4gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGRpbWVuc2lvbiBhcmd1bWVudHMgdmFsdWUgd2hlbiBnZXR0aW5nICh3aWR0aC9oZWlnaHQpLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gZGltZW5zaW9uKF9kaW1lbnNpb24sIHZhbHVlKSB7XG4gICAgdmFyIHByaXZEaW1lbnNpb24gPSBfZGltZW5zaW9uICsgJ18nO1xuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzW3ByaXZEaW1lbnNpb25dIHx8IDA7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgLy8gSWYgYW4gZW1wdHkgc3RyaW5nIGlzIGdpdmVuLCByZXNldCB0aGUgZGltZW5zaW9uIHRvIGJlIGF1dG9tYXRpY1xuICAgICAgdGhpc1twcml2RGltZW5zaW9uXSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudXBkYXRlU3R5bGVFbF8oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VkVmFsID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICBpZiAoaXNOYU4ocGFyc2VkVmFsKSkge1xuICAgICAgbG9nJDEuZXJyb3IoJ0ltcHJvcGVyIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIHN1cHBsaWVkIGZvciBmb3IgJyArIF9kaW1lbnNpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXNbcHJpdkRpbWVuc2lvbl0gPSBwYXJzZWRWYWw7XG4gICAgdGhpcy51cGRhdGVTdHlsZUVsXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIvdG9nZ2xlciBmb3IgdGhlIHZqcy1mbHVpZCBgY2xhc3NOYW1lYCBvbiB0aGUgYFBsYXllcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb2xdXG4gICAqICAgICAgICAtIEEgdmFsdWUgb2YgdHJ1ZSBhZGRzIHRoZSBjbGFzcy5cbiAgICogICAgICAgIC0gQSB2YWx1ZSBvZiBmYWxzZSByZW1vdmVzIHRoZSBjbGFzcy5cbiAgICogICAgICAgIC0gTm8gdmFsdWUgd2lsbCB0b2dnbGUgdGhlIGZsdWlkIGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAgICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBmbHVpZCB3aGVuIGdldHRpbmcuXG4gICAqICAgICAgICAgLSBgdW5kZWZpbmVkYCB3aGVuIHNldHRpbmcuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5mbHVpZCA9IGZ1bmN0aW9uIGZsdWlkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmZsdWlkXztcbiAgICB9XG5cbiAgICB0aGlzLmZsdWlkXyA9ICEhYm9vbDtcblxuICAgIGlmIChib29sKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtZmx1aWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWZsdWlkJyk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTdHlsZUVsXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvU2V0IHRoZSBhc3BlY3QgcmF0aW9cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyYXRpb11cbiAgICogICAgICAgIEFzcGVjdCByYXRpbyBmb3IgcGxheWVyXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9XG4gICAqICAgICAgICAgcmV0dXJucyB0aGUgY3VycmVudCBhc3BlY3QgcmF0aW8gd2hlbiBnZXR0aW5nXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgUGxheWVyYCdzIGFzcGVjdCByYXRpby5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyYXRpb11cbiAgICogICAgICAgIFRoZSB2YWx1ZSB0byBzZXQgdGhlIGBQbGF5ZXIncyBhc3BlY3QgcmF0aW8gdG8uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9XG4gICAqICAgICAgICAgLSBUaGUgY3VycmVudCBhc3BlY3QgcmF0aW8gb2YgdGhlIGBQbGF5ZXJgIHdoZW4gZ2V0dGluZy5cbiAgICogICAgICAgICAtIHVuZGVmaW5lZCB3aGVuIHNldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmFzcGVjdFJhdGlvID0gZnVuY3Rpb24gYXNwZWN0UmF0aW8ocmF0aW8pIHtcbiAgICBpZiAocmF0aW8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXNwZWN0UmF0aW9fO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciB3aWR0aDpoZWlnaHQgZm9ybWF0XG4gICAgaWYgKCEvXlxcZCtcXDpcXGQrJC8udGVzdChyYXRpbykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW1wcm9wZXIgdmFsdWUgc3VwcGxpZWQgZm9yIGFzcGVjdCByYXRpby4gVGhlIGZvcm1hdCBzaG91bGQgYmUgd2lkdGg6aGVpZ2h0LCBmb3IgZXhhbXBsZSAxNjo5LicpO1xuICAgIH1cbiAgICB0aGlzLmFzcGVjdFJhdGlvXyA9IHJhdGlvO1xuXG4gICAgLy8gV2UncmUgYXNzdW1pbmcgaWYgeW91IHNldCBhbiBhc3BlY3QgcmF0aW8geW91IHdhbnQgZmx1aWQgbW9kZSxcbiAgICAvLyBiZWNhdXNlIGluIGZpeGVkIG1vZGUgeW91IGNvdWxkIGNhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IHlvdXJzZWxmLlxuICAgIHRoaXMuZmx1aWQodHJ1ZSk7XG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlRWxfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzdHlsZXMgb2YgdGhlIGBQbGF5ZXJgIGVsZW1lbnQgKGhlaWdodCwgd2lkdGggYW5kIGFzcGVjdCByYXRpbykuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBsaXN0ZW5zIFRlY2gjbG9hZGVkbWV0YWRhdGFcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnVwZGF0ZVN0eWxlRWxfID0gZnVuY3Rpb24gdXBkYXRlU3R5bGVFbF8oKSB7XG4gICAgaWYgKHdpbmRvdyQxLlZJREVPSlNfTk9fRFlOQU1JQ19TVFlMRSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIF93aWR0aCA9IHR5cGVvZiB0aGlzLndpZHRoXyA9PT0gJ251bWJlcicgPyB0aGlzLndpZHRoXyA6IHRoaXMub3B0aW9uc18ud2lkdGg7XG4gICAgICB2YXIgX2hlaWdodCA9IHR5cGVvZiB0aGlzLmhlaWdodF8gPT09ICdudW1iZXInID8gdGhpcy5oZWlnaHRfIDogdGhpcy5vcHRpb25zXy5oZWlnaHQ7XG4gICAgICB2YXIgdGVjaEVsID0gdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLmVsKCk7XG5cbiAgICAgIGlmICh0ZWNoRWwpIHtcbiAgICAgICAgaWYgKF93aWR0aCA+PSAwKSB7XG4gICAgICAgICAgdGVjaEVsLndpZHRoID0gX3dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaGVpZ2h0ID49IDApIHtcbiAgICAgICAgICB0ZWNoRWwuaGVpZ2h0ID0gX2hlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoID0gdm9pZCAwO1xuICAgIHZhciBoZWlnaHQgPSB2b2lkIDA7XG4gICAgdmFyIGFzcGVjdFJhdGlvID0gdm9pZCAwO1xuICAgIHZhciBpZENsYXNzID0gdm9pZCAwO1xuXG4gICAgLy8gVGhlIGFzcGVjdCByYXRpbyBpcyBlaXRoZXIgdXNlZCBkaXJlY3RseSBvciB0byBjYWxjdWxhdGUgd2lkdGggYW5kIGhlaWdodC5cbiAgICBpZiAodGhpcy5hc3BlY3RSYXRpb18gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmFzcGVjdFJhdGlvXyAhPT0gJ2F1dG8nKSB7XG4gICAgICAvLyBVc2UgYW55IGFzcGVjdFJhdGlvIHRoYXQncyBiZWVuIHNwZWNpZmljYWxseSBzZXRcbiAgICAgIGFzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpb187XG4gICAgfSBlbHNlIGlmICh0aGlzLnZpZGVvV2lkdGgoKSA+IDApIHtcbiAgICAgIC8vIE90aGVyd2lzZSB0cnkgdG8gZ2V0IHRoZSBhc3BlY3QgcmF0aW8gZnJvbSB0aGUgdmlkZW8gbWV0YWRhdGFcbiAgICAgIGFzcGVjdFJhdGlvID0gdGhpcy52aWRlb1dpZHRoKCkgKyAnOicgKyB0aGlzLnZpZGVvSGVpZ2h0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9yIHVzZSBhIGRlZmF1bHQuIFRoZSB2aWRlbyBlbGVtZW50J3MgaXMgMjoxLCBidXQgMTY6OSBpcyBtb3JlIGNvbW1vbi5cbiAgICAgIGFzcGVjdFJhdGlvID0gJzE2OjknO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgcmF0aW8gYXMgYSBkZWNpbWFsIHdlIGNhbiB1c2UgdG8gY2FsY3VsYXRlIGRpbWVuc2lvbnNcbiAgICB2YXIgcmF0aW9QYXJ0cyA9IGFzcGVjdFJhdGlvLnNwbGl0KCc6Jyk7XG4gICAgdmFyIHJhdGlvTXVsdGlwbGllciA9IHJhdGlvUGFydHNbMV0gLyByYXRpb1BhcnRzWzBdO1xuXG4gICAgaWYgKHRoaXMud2lkdGhfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFVzZSBhbnkgd2lkdGggdGhhdCdzIGJlZW4gc3BlY2lmaWNhbGx5IHNldFxuICAgICAgd2lkdGggPSB0aGlzLndpZHRoXztcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGVpZ2h0XyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBPciBjYWx1bGF0ZSB0aGUgd2lkdGggZnJvbSB0aGUgYXNwZWN0IHJhdGlvIGlmIGEgaGVpZ2h0IGhhcyBiZWVuIHNldFxuICAgICAgd2lkdGggPSB0aGlzLmhlaWdodF8gLyByYXRpb011bHRpcGxpZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9yIHVzZSB0aGUgdmlkZW8ncyBtZXRhZGF0YSwgb3IgdXNlIHRoZSB2aWRlbyBlbCdzIGRlZmF1bHQgb2YgMzAwXG4gICAgICB3aWR0aCA9IHRoaXMudmlkZW9XaWR0aCgpIHx8IDMwMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oZWlnaHRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFVzZSBhbnkgaGVpZ2h0IHRoYXQncyBiZWVuIHNwZWNpZmljYWxseSBzZXRcbiAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0XztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IGZyb20gdGhlIHJhdGlvIGFuZCB0aGUgd2lkdGhcbiAgICAgIGhlaWdodCA9IHdpZHRoICogcmF0aW9NdWx0aXBsaWVyO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGUgQ1NTIGNsYXNzIGlzIHZhbGlkIGJ5IHN0YXJ0aW5nIHdpdGggYW4gYWxwaGEgY2hhcmFjdGVyXG4gICAgaWYgKC9eW15hLXpBLVpdLy50ZXN0KHRoaXMuaWQoKSkpIHtcbiAgICAgIGlkQ2xhc3MgPSAnZGltZW5zaW9ucy0nICsgdGhpcy5pZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZENsYXNzID0gdGhpcy5pZCgpICsgJy1kaW1lbnNpb25zJztcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhlIHJpZ2h0IGNsYXNzIGlzIHN0aWxsIG9uIHRoZSBwbGF5ZXIgZm9yIHRoZSBzdHlsZSBlbGVtZW50XG4gICAgdGhpcy5hZGRDbGFzcyhpZENsYXNzKTtcblxuICAgIHNldFRleHRDb250ZW50KHRoaXMuc3R5bGVFbF8sICdcXG4gICAgICAuJyArIGlkQ2xhc3MgKyAnIHtcXG4gICAgICAgIHdpZHRoOiAnICsgd2lkdGggKyAncHg7XFxuICAgICAgICBoZWlnaHQ6ICcgKyBoZWlnaHQgKyAncHg7XFxuICAgICAgfVxcblxcbiAgICAgIC4nICsgaWRDbGFzcyArICcudmpzLWZsdWlkIHtcXG4gICAgICAgIHBhZGRpbmctdG9wOiAnICsgcmF0aW9NdWx0aXBsaWVyICogMTAwICsgJyU7XFxuICAgICAgfVxcbiAgICAnKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9hZC9DcmVhdGUgYW4gaW5zdGFuY2Ugb2YgcGxheWJhY2sge0BsaW5rIFRlY2h9IGluY2x1ZGluZyBlbGVtZW50XG4gICAqIGFuZCBBUEkgbWV0aG9kcy4gVGhlbiBhcHBlbmQgdGhlIGBUZWNoYCBlbGVtZW50IGluIGBQbGF5ZXJgIGFzIGEgY2hpbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWNoTmFtZVxuICAgKiAgICAgICAgbmFtZSBvZiB0aGUgcGxheWJhY2sgdGVjaG5vbG9neVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlXG4gICAqICAgICAgICB2aWRlbyBzb3VyY2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxvYWRUZWNoXyA9IGZ1bmN0aW9uIGxvYWRUZWNoXyh0ZWNoTmFtZSwgc291cmNlKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBQYXVzZSBhbmQgcmVtb3ZlIGN1cnJlbnQgcGxheWJhY2sgdGVjaG5vbG9neVxuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICB0aGlzLnVubG9hZFRlY2hfKCk7XG4gICAgfVxuXG4gICAgdmFyIHRpdGxlVGVjaE5hbWUgPSB0b1RpdGxlQ2FzZSh0ZWNoTmFtZSk7XG4gICAgdmFyIGNhbWVsVGVjaE5hbWUgPSB0ZWNoTmFtZS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHRlY2hOYW1lLnNsaWNlKDEpO1xuXG4gICAgLy8gZ2V0IHJpZCBvZiB0aGUgSFRNTDUgdmlkZW8gdGFnIGFzIHNvb24gYXMgd2UgYXJlIHVzaW5nIGFub3RoZXIgdGVjaFxuICAgIGlmICh0aXRsZVRlY2hOYW1lICE9PSAnSHRtbDUnICYmIHRoaXMudGFnKSB7XG4gICAgICBUZWNoLmdldFRlY2goJ0h0bWw1JykuZGlzcG9zZU1lZGlhRWxlbWVudCh0aGlzLnRhZyk7XG4gICAgICB0aGlzLnRhZy5wbGF5ZXIgPSBudWxsO1xuICAgICAgdGhpcy50YWcgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMudGVjaE5hbWVfID0gdGl0bGVUZWNoTmFtZTtcblxuICAgIC8vIFR1cm4gb2ZmIEFQSSBhY2Nlc3MgYmVjYXVzZSB3ZSdyZSBsb2FkaW5nIGEgbmV3IHRlY2ggdGhhdCBtaWdodCBsb2FkIGFzeW5jaHJvbm91c2x5XG4gICAgdGhpcy5pc1JlYWR5XyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgYXV0b3BsYXkgaXMgYSBzdHJpbmcgd2UgcGFzcyBmYWxzZSB0byB0aGUgdGVjaFxuICAgIC8vIGJlY2F1c2UgdGhlIHBsYXllciBpcyBnb2luZyB0byBoYW5kbGUgYXV0b3BsYXkgb24gYGxvYWRzdGFydGBcbiAgICB2YXIgYXV0b3BsYXkgPSB0eXBlb2YgdGhpcy5hdXRvcGxheSgpID09PSAnc3RyaW5nJyA/IGZhbHNlIDogdGhpcy5hdXRvcGxheSgpO1xuXG4gICAgLy8gR3JhYiB0ZWNoLXNwZWNpZmljIG9wdGlvbnMgZnJvbSBwbGF5ZXIgb3B0aW9ucyBhbmQgYWRkIHNvdXJjZSBhbmQgcGFyZW50IGVsZW1lbnQgdG8gdXNlLlxuICAgIHZhciB0ZWNoT3B0aW9ucyA9IHtcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgYXV0b3BsYXk6IGF1dG9wbGF5LFxuICAgICAgJ25hdGl2ZUNvbnRyb2xzRm9yVG91Y2gnOiB0aGlzLm9wdGlvbnNfLm5hdGl2ZUNvbnRyb2xzRm9yVG91Y2gsXG4gICAgICAncGxheWVySWQnOiB0aGlzLmlkKCksXG4gICAgICAndGVjaElkJzogdGhpcy5pZCgpICsgJ18nICsgdGl0bGVUZWNoTmFtZSArICdfYXBpJyxcbiAgICAgICdwbGF5c2lubGluZSc6IHRoaXMub3B0aW9uc18ucGxheXNpbmxpbmUsXG4gICAgICAncHJlbG9hZCc6IHRoaXMub3B0aW9uc18ucHJlbG9hZCxcbiAgICAgICdsb29wJzogdGhpcy5vcHRpb25zXy5sb29wLFxuICAgICAgJ211dGVkJzogdGhpcy5vcHRpb25zXy5tdXRlZCxcbiAgICAgICdwb3N0ZXInOiB0aGlzLnBvc3RlcigpLFxuICAgICAgJ2xhbmd1YWdlJzogdGhpcy5sYW5ndWFnZSgpLFxuICAgICAgJ3BsYXllckVsSW5nZXN0JzogdGhpcy5wbGF5ZXJFbEluZ2VzdF8gfHwgZmFsc2UsXG4gICAgICAndnR0LmpzJzogdGhpcy5vcHRpb25zX1sndnR0LmpzJ10sXG4gICAgICAnY2FuT3ZlcnJpZGVQb3N0ZXInOiAhIXRoaXMub3B0aW9uc18udGVjaENhbk92ZXJyaWRlUG9zdGVyLFxuICAgICAgJ2VuYWJsZVNvdXJjZXNldCc6IHRoaXMub3B0aW9uc18uZW5hYmxlU291cmNlc2V0XG4gICAgfTtcblxuICAgIEFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gICAgICB2YXIgcHJvcHMgPSBBTExbbmFtZSQkMV07XG5cbiAgICAgIHRlY2hPcHRpb25zW3Byb3BzLmdldHRlck5hbWVdID0gX3RoaXMyW3Byb3BzLnByaXZhdGVOYW1lXTtcbiAgICB9KTtcblxuICAgIGFzc2lnbih0ZWNoT3B0aW9ucywgdGhpcy5vcHRpb25zX1t0aXRsZVRlY2hOYW1lXSk7XG4gICAgYXNzaWduKHRlY2hPcHRpb25zLCB0aGlzLm9wdGlvbnNfW2NhbWVsVGVjaE5hbWVdKTtcbiAgICBhc3NpZ24odGVjaE9wdGlvbnMsIHRoaXMub3B0aW9uc19bdGVjaE5hbWUudG9Mb3dlckNhc2UoKV0pO1xuXG4gICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICB0ZWNoT3B0aW9ucy50YWcgPSB0aGlzLnRhZztcbiAgICB9XG5cbiAgICBpZiAoc291cmNlICYmIHNvdXJjZS5zcmMgPT09IHRoaXMuY2FjaGVfLnNyYyAmJiB0aGlzLmNhY2hlXy5jdXJyZW50VGltZSA+IDApIHtcbiAgICAgIHRlY2hPcHRpb25zLnN0YXJ0VGltZSA9IHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGVjaCBpbnN0YW5jZVxuICAgIHZhciBUZWNoQ2xhc3MgPSBUZWNoLmdldFRlY2godGVjaE5hbWUpO1xuXG4gICAgaWYgKCFUZWNoQ2xhc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gVGVjaCBuYW1lZCBcXCcnICsgdGl0bGVUZWNoTmFtZSArICdcXCcgZXhpc3RzISBcXCcnICsgdGl0bGVUZWNoTmFtZSArICdcXCcgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgdXNpbmcgdmlkZW9qcy5yZWdpc3RlclRlY2goKVxcJycpO1xuICAgIH1cblxuICAgIHRoaXMudGVjaF8gPSBuZXcgVGVjaENsYXNzKHRlY2hPcHRpb25zKTtcblxuICAgIC8vIHBsYXllci50cmlnZ2VyUmVhZHkgaXMgYWx3YXlzIGFzeW5jLCBzbyBkb24ndCBuZWVkIHRoaXMgdG8gYmUgYXN5bmNcbiAgICB0aGlzLnRlY2hfLnJlYWR5KGJpbmQodGhpcywgdGhpcy5oYW5kbGVUZWNoUmVhZHlfKSwgdHJ1ZSk7XG5cbiAgICB0ZXh0VHJhY2tDb252ZXJ0ZXIuanNvblRvVGV4dFRyYWNrcyh0aGlzLnRleHRUcmFja3NKc29uXyB8fCBbXSwgdGhpcy50ZWNoXyk7XG5cbiAgICAvLyBMaXN0ZW4gdG8gYWxsIEhUTUw1LWRlZmluZWQgZXZlbnRzIGFuZCB0cmlnZ2VyIHRoZW0gb24gdGhlIHBsYXllclxuICAgIFRFQ0hfRVZFTlRTX1JFVFJJR0dFUi5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgX3RoaXMyLm9uKF90aGlzMi50ZWNoXywgZXZlbnQsIF90aGlzMlsnaGFuZGxlVGVjaCcgKyB0b1RpdGxlQ2FzZShldmVudCkgKyAnXyddKTtcbiAgICB9KTtcblxuICAgIE9iamVjdC5rZXlzKFRFQ0hfRVZFTlRTX1FVRVVFKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgX3RoaXMyLm9uKF90aGlzMi50ZWNoXywgZXZlbnQsIGZ1bmN0aW9uIChldmVudE9iaikge1xuICAgICAgICBpZiAoX3RoaXMyLnRlY2hfLnBsYXliYWNrUmF0ZSgpID09PSAwICYmIF90aGlzMi50ZWNoXy5zZWVraW5nKCkpIHtcbiAgICAgICAgICBfdGhpczIucXVldWVkQ2FsbGJhY2tzXy5wdXNoKHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiBfdGhpczJbJ2hhbmRsZVRlY2gnICsgVEVDSF9FVkVOVFNfUVVFVUVbZXZlbnRdICsgJ18nXS5iaW5kKF90aGlzMiksXG4gICAgICAgICAgICBldmVudDogZXZlbnRPYmpcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMyWydoYW5kbGVUZWNoJyArIFRFQ0hfRVZFTlRTX1FVRVVFW2V2ZW50XSArICdfJ10oZXZlbnRPYmopO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdsb2Fkc3RhcnQnLCB0aGlzLmhhbmRsZVRlY2hMb2FkU3RhcnRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdzb3VyY2VzZXQnLCB0aGlzLmhhbmRsZVRlY2hTb3VyY2VzZXRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd3YWl0aW5nJywgdGhpcy5oYW5kbGVUZWNoV2FpdGluZ18pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2VuZGVkJywgdGhpcy5oYW5kbGVUZWNoRW5kZWRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdzZWVraW5nJywgdGhpcy5oYW5kbGVUZWNoU2Vla2luZ18pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3BsYXknLCB0aGlzLmhhbmRsZVRlY2hQbGF5Xyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZmlyc3RwbGF5JywgdGhpcy5oYW5kbGVUZWNoRmlyc3RQbGF5Xyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncGF1c2UnLCB0aGlzLmhhbmRsZVRlY2hQYXVzZV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2R1cmF0aW9uY2hhbmdlJywgdGhpcy5oYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2VfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdmdWxsc2NyZWVuY2hhbmdlJywgdGhpcy5oYW5kbGVUZWNoRnVsbHNjcmVlbkNoYW5nZV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2Vycm9yJywgdGhpcy5oYW5kbGVUZWNoRXJyb3JfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdsb2FkZWRtZXRhZGF0YScsIHRoaXMudXBkYXRlU3R5bGVFbF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3Bvc3RlcmNoYW5nZScsIHRoaXMuaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3RleHRkYXRhJywgdGhpcy5oYW5kbGVUZWNoVGV4dERhdGFfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdyYXRlY2hhbmdlJywgdGhpcy5oYW5kbGVUZWNoUmF0ZUNoYW5nZV8pO1xuXG4gICAgdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKHRoaXMudGVjaEdldF8oJ2NvbnRyb2xzJykpO1xuXG4gICAgaWYgKHRoaXMuY29udHJvbHMoKSAmJiAhdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKCkpIHtcbiAgICAgIHRoaXMuYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgdGVjaCBlbGVtZW50IGluIHRoZSBET00gaWYgaXQgd2FzIG5vdCBhbHJlYWR5IHRoZXJlXG4gICAgLy8gTWFrZSBzdXJlIHRvIG5vdCBpbnNlcnQgdGhlIG9yaWdpbmFsIHZpZGVvIGVsZW1lbnQgaWYgdXNpbmcgSHRtbDVcbiAgICBpZiAodGhpcy50ZWNoXy5lbCgpLnBhcmVudE5vZGUgIT09IHRoaXMuZWwoKSAmJiAodGl0bGVUZWNoTmFtZSAhPT0gJ0h0bWw1JyB8fCAhdGhpcy50YWcpKSB7XG4gICAgICBwcmVwZW5kVG8odGhpcy50ZWNoXy5lbCgpLCB0aGlzLmVsKCkpO1xuICAgIH1cblxuICAgIC8vIEdldCByaWQgb2YgdGhlIG9yaWdpbmFsIHZpZGVvIHRhZyByZWZlcmVuY2UgYWZ0ZXIgdGhlIGZpcnN0IHRlY2ggaXMgbG9hZGVkXG4gICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICB0aGlzLnRhZy5wbGF5ZXIgPSBudWxsO1xuICAgICAgdGhpcy50YWcgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVW5sb2FkIGFuZCBkaXNwb3NlIG9mIHRoZSBjdXJyZW50IHBsYXliYWNrIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnVubG9hZFRlY2hfID0gZnVuY3Rpb24gdW5sb2FkVGVjaF8oKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHRleHQgdHJhY2tzIHNvIHRoYXQgd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRleHQgdHJhY2tzIHdpdGggdGhlIG5leHQgdGVjaFxuICAgIEFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gICAgICB2YXIgcHJvcHMgPSBBTExbbmFtZSQkMV07XG5cbiAgICAgIF90aGlzM1twcm9wcy5wcml2YXRlTmFtZV0gPSBfdGhpczNbcHJvcHMuZ2V0dGVyTmFtZV0oKTtcbiAgICB9KTtcbiAgICB0aGlzLnRleHRUcmFja3NKc29uXyA9IHRleHRUcmFja0NvbnZlcnRlci50ZXh0VHJhY2tzVG9Kc29uKHRoaXMudGVjaF8pO1xuXG4gICAgdGhpcy5pc1JlYWR5XyA9IGZhbHNlO1xuXG4gICAgdGhpcy50ZWNoXy5kaXNwb3NlKCk7XG5cbiAgICB0aGlzLnRlY2hfID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5pc1Bvc3RlckZyb21UZWNoXykge1xuICAgICAgdGhpcy5wb3N0ZXJfID0gJyc7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3Bvc3RlcmNoYW5nZScpO1xuICAgIH1cblxuICAgIHRoaXMuaXNQb3N0ZXJGcm9tVGVjaF8gPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHtAbGluayBUZWNofS5cbiAgICogSXQgd2lsbCBwcmludCBhIHdhcm5pbmcgYnkgZGVmYXVsdCBhYm91dCB0aGUgZGFuZ2VyIG9mIHVzaW5nIHRoZSB0ZWNoIGRpcmVjdGx5XG4gICAqIGJ1dCBhbnkgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgaW4gd2lsbCBzaWxlbmNlIHRoZSB3YXJuaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtzYWZldHldXG4gICAqICAgICAgICBBbnl0aGluZyBwYXNzZWQgaW4gdG8gc2lsZW5jZSB0aGUgd2FybmluZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNofVxuICAgKiAgICAgICAgIFRoZSBUZWNoXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS50ZWNoID0gZnVuY3Rpb24gdGVjaChzYWZldHkpIHtcbiAgICBpZiAoc2FmZXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZyQxLndhcm4odHNtbChfdGVtcGxhdGVPYmplY3QkMikpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRlY2hfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdXAgY2xpY2sgYW5kIHRvdWNoIGxpc3RlbmVycyBmb3IgdGhlIHBsYXliYWNrIGVsZW1lbnRcbiAgICpcbiAgICogLSBPbiBkZXNrdG9wczogYSBjbGljayBvbiB0aGUgdmlkZW8gaXRzZWxmIHdpbGwgdG9nZ2xlIHBsYXliYWNrXG4gICAqIC0gT24gbW9iaWxlIGRldmljZXM6IGEgY2xpY2sgb24gdGhlIHZpZGVvIHRvZ2dsZXMgY29udHJvbHNcbiAgICogICB3aGljaCBpcyBkb25lIGJ5IHRvZ2dsaW5nIHRoZSB1c2VyIHN0YXRlIGJldHdlZW4gYWN0aXZlIGFuZFxuICAgKiAgIGluYWN0aXZlXG4gICAqIC0gQSB0YXAgY2FuIHNpZ25hbCB0aGF0IGEgdXNlciBoYXMgYmVjb21lIGFjdGl2ZSBvciBoYXMgYmVjb21lIGluYWN0aXZlXG4gICAqICAgZS5nLiBhIHF1aWNrIHRhcCBvbiBhbiBpUGhvbmUgbW92aWUgc2hvdWxkIHJldmVhbCB0aGUgY29udHJvbHMuIEFub3RoZXJcbiAgICogICBxdWljayB0YXAgc2hvdWxkIGhpZGUgdGhlbSBhZ2FpbiAoc2lnbmFsaW5nIHRoZSB1c2VyIGlzIGluIGFuIGluYWN0aXZlXG4gICAqICAgdmlld2luZyBzdGF0ZSlcbiAgICogLSBJbiBhZGRpdGlvbiB0byB0aGlzLCB3ZSBzdGlsbCB3YW50IHRoZSB1c2VyIHRvIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmUgYWZ0ZXJcbiAgICogICBhIGZldyBzZWNvbmRzIG9mIGluYWN0aXZpdHkuXG4gICAqXG4gICAqID4gTm90ZTogdGhlIG9ubHkgcGFydCBvZiBpT1MgaW50ZXJhY3Rpb24gd2UgY2FuJ3QgbWltaWMgd2l0aCB0aGlzIHNldHVwXG4gICAqIGlzIGEgdG91Y2ggYW5kIGhvbGQgb24gdGhlIHZpZGVvIGVsZW1lbnQgY291bnRpbmcgYXMgYWN0aXZpdHkgaW4gb3JkZXIgdG9cbiAgICoga2VlcCB0aGUgY29udHJvbHMgc2hvd2luZywgYnV0IHRoYXQgc2hvdWxkbid0IGJlIGFuIGlzc3VlLiBBIHRvdWNoIGFuZCBob2xkXG4gICAqIG9uIGFueSBjb250cm9scyB3aWxsIHN0aWxsIGtlZXAgdGhlIHVzZXIgYWN0aXZlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hZGRUZWNoQ29udHJvbHNMaXN0ZW5lcnNfID0gZnVuY3Rpb24gYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpIHtcbiAgICAvLyBNYWtlIHN1cmUgdG8gcmVtb3ZlIGFsbCB0aGUgcHJldmlvdXMgbGlzdGVuZXJzIGluIGNhc2Ugd2UgYXJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICB0aGlzLnJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcblxuICAgIC8vIFNvbWUgYnJvd3NlcnMgKENocm9tZSAmIElFKSBkb24ndCB0cmlnZ2VyIGEgY2xpY2sgb24gYSBmbGFzaCBzd2YsIGJ1dCBkb1xuICAgIC8vIHRyaWdnZXIgbW91c2Vkb3duL3VwLlxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ0NDU2Mi9qYXZhc2NyaXB0LW9uY2xpY2stZXZlbnQtb3Zlci1mbGFzaC1vYmplY3RcbiAgICAvLyBBbnkgdG91Y2ggZXZlbnRzIGFyZSBzZXQgdG8gYmxvY2sgdGhlIG1vdXNlZG93biBldmVudCBmcm9tIGhhcHBlbmluZ1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlVGVjaENsaWNrXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZGJsY2xpY2snLCB0aGlzLmhhbmRsZVRlY2hEb3VibGVDbGlja18pO1xuXG4gICAgLy8gSWYgdGhlIGNvbnRyb2xzIHdlcmUgaGlkZGVuIHdlIGRvbid0IHdhbnQgdGhhdCB0byBjaGFuZ2Ugd2l0aG91dCBhIHRhcCBldmVudFxuICAgIC8vIHNvIHdlJ2xsIGNoZWNrIGlmIHRoZSBjb250cm9scyB3ZXJlIGFscmVhZHkgc2hvd2luZyBiZWZvcmUgcmVwb3J0aW5nIHVzZXJcbiAgICAvLyBhY3Rpdml0eVxuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaFN0YXJ0Xyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUZWNoVG91Y2hNb3ZlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaEVuZF8pO1xuXG4gICAgLy8gVGhlIHRhcCBsaXN0ZW5lciBuZWVkcyB0byBjb21lIGFmdGVyIHRoZSB0b3VjaGVuZCBsaXN0ZW5lciBiZWNhdXNlIHRoZSB0YXBcbiAgICAvLyBsaXN0ZW5lciBjYW5jZWxzIG91dCBhbnkgcmVwb3J0ZWRVc2VyQWN0aXZpdHkgd2hlbiBzZXR0aW5nIHVzZXJBY3RpdmUoZmFsc2UpXG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndGFwJywgdGhpcy5oYW5kbGVUZWNoVGFwXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIHVzZWQgZm9yIGNsaWNrIGFuZCB0YXAgY29udHJvbHMuIFRoaXMgaXMgbmVlZGVkIGZvclxuICAgKiB0b2dnbGluZyB0byBjb250cm9scyBkaXNhYmxlZCwgd2hlcmUgYSB0YXAvdG91Y2ggc2hvdWxkIGRvIG5vdGhpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZW1vdmVUZWNoQ29udHJvbHNMaXN0ZW5lcnNfID0gZnVuY3Rpb24gcmVtb3ZlVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpIHtcbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIGp1c3QgdXNlIGB0aGlzLm9mZigpYCBiZWNhdXNlIHRoZXJlIG1pZ2h0IGJlIG90aGVyIG5lZWRlZFxuICAgIC8vIGxpc3RlbmVycyBhZGRlZCBieSB0ZWNocyB0aGF0IGV4dGVuZCB0aGlzLlxuICAgIHRoaXMub2ZmKHRoaXMudGVjaF8sICd0YXAnLCB0aGlzLmhhbmRsZVRlY2hUYXBfKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoU3RhcnRfKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUZWNoVG91Y2hNb3ZlXyk7XG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUZWNoVG91Y2hFbmRfKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAnbW91c2Vkb3duJywgdGhpcy5oYW5kbGVUZWNoQ2xpY2tfKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAnZGJsY2xpY2snLCB0aGlzLmhhbmRsZVRlY2hEb3VibGVDbGlja18pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQbGF5ZXIgd2FpdHMgZm9yIHRoZSB0ZWNoIHRvIGJlIHJlYWR5XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUmVhZHlfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFJlYWR5XygpIHtcbiAgICB0aGlzLnRyaWdnZXJSZWFkeSgpO1xuXG4gICAgLy8gS2VlcCB0aGUgc2FtZSB2b2x1bWUgYXMgYmVmb3JlXG4gICAgaWYgKHRoaXMuY2FjaGVfLnZvbHVtZSkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFZvbHVtZScsIHRoaXMuY2FjaGVfLnZvbHVtZSk7XG4gICAgfVxuXG4gICAgLy8gTG9vayBpZiB0aGUgdGVjaCBmb3VuZCBhIGhpZ2hlciByZXNvbHV0aW9uIHBvc3RlciB3aGlsZSBsb2FkaW5nXG4gICAgdGhpcy5oYW5kbGVUZWNoUG9zdGVyQ2hhbmdlXygpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBkdXJhdGlvbiBpZiBhdmFpbGFibGVcbiAgICB0aGlzLmhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZV8oKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgbG9hZHN0YXJ0YCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS4gVGhpc1xuICAgKiBmdW5jdGlvbiB3aWxsIGFsc28gdHJpZ2dlciB7QGxpbmsgUGxheWVyI2ZpcnN0cGxheX0gaWYgaXQgaXMgdGhlIGZpcnN0IGxvYWRzdGFydFxuICAgKiBmb3IgYSB2aWRlby5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNsb2Fkc3RhcnRcbiAgICogQGZpcmVzIFBsYXllciNmaXJzdHBsYXlcbiAgICogQGxpc3RlbnMgVGVjaCNsb2Fkc3RhcnRcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hMb2FkU3RhcnRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaExvYWRTdGFydF8oKSB7XG4gICAgLy8gVE9ETzogVXBkYXRlIHRvIHVzZSBgZW1wdGllZGAgZXZlbnQgaW5zdGVhZC4gU2VlICMxMjc3LlxuXG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNlZWtpbmcnKTtcblxuICAgIC8vIHJlc2V0IHRoZSBlcnJvciBzdGF0ZVxuICAgIHRoaXMuZXJyb3IobnVsbCk7XG5cbiAgICAvLyBJZiBpdCdzIGFscmVhZHkgcGxheWluZyB3ZSB3YW50IHRvIHRyaWdnZXIgYSBmaXJzdHBsYXkgZXZlbnQgbm93LlxuICAgIC8vIFRoZSBmaXJzdHBsYXkgZXZlbnQgcmVsaWVzIG9uIGJvdGggdGhlIHBsYXkgYW5kIGxvYWRzdGFydCBldmVudHNcbiAgICAvLyB3aGljaCBjYW4gaGFwcGVuIGluIGFueSBvcmRlciBmb3IgYSBuZXcgc291cmNlXG4gICAgaWYgKCF0aGlzLnBhdXNlZCgpKSB7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgYWdlbnQgYmVnaW5zIGxvb2tpbmcgZm9yIG1lZGlhIGRhdGFcbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI2xvYWRzdGFydFxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2xvYWRzdGFydCcpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVzZXQgdGhlIGhhc1N0YXJ0ZWQgc3RhdGVcbiAgICAgIHRoaXMuaGFzU3RhcnRlZChmYWxzZSk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2xvYWRzdGFydCcpO1xuICAgIH1cblxuICAgIC8vIGF1dG9wbGF5IGhhcHBlbnMgYWZ0ZXIgbG9hZHN0YXJ0IGZvciB0aGUgYnJvd3NlcixcbiAgICAvLyBzbyB3ZSBtaW1pYyB0aGF0IGJlaGF2aW9yXG4gICAgdGhpcy5tYW51YWxBdXRvcGxheV8odGhpcy5hdXRvcGxheSgpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGF1dG9wbGF5IHN0cmluZyB2YWx1ZXMsIHJhdGhlciB0aGFuIHRoZSB0eXBpY2FsIGJvb2xlYW5cbiAgICogdmFsdWVzIHRoYXQgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhlIHRlY2guIE5vdGUgdGhhdCB0aGlzIGlzIG5vdFxuICAgKiBwYXJ0IG9mIGFueSBzcGVjaWZpY2F0aW9uLiBWYWxpZCB2YWx1ZXMgYW5kIHdoYXQgdGhleSBkbyBjYW4gYmVcbiAgICogZm91bmQgb24gdGhlIGF1dG9wbGF5IGdldHRlciBhdCBQbGF5ZXIjYXV0b3BsYXkoKVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubWFudWFsQXV0b3BsYXlfID0gZnVuY3Rpb24gbWFudWFsQXV0b3BsYXlfKHR5cGUpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmICghdGhpcy50ZWNoXyB8fCB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbXV0ZWQgPSBmdW5jdGlvbiBtdXRlZCgpIHtcbiAgICAgIHZhciBwcmV2aW91c2x5TXV0ZWQgPSBfdGhpczQubXV0ZWQoKTtcblxuICAgICAgX3RoaXM0Lm11dGVkKHRydWUpO1xuXG4gICAgICB2YXIgcGxheVByb21pc2UgPSBfdGhpczQucGxheSgpO1xuXG4gICAgICBpZiAoIXBsYXlQcm9taXNlIHx8ICFwbGF5UHJvbWlzZS50aGVuIHx8ICFwbGF5UHJvbWlzZS5jYXRjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwbGF5UHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyByZXN0b3JlIG9sZCB2YWx1ZSBvZiBtdXRlZCBvbiBmYWlsdXJlXG4gICAgICAgIF90aGlzNC5tdXRlZChwcmV2aW91c2x5TXV0ZWQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBwcm9taXNlID0gdm9pZCAwO1xuXG4gICAgaWYgKHR5cGUgPT09ICdhbnknKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5wbGF5KCk7XG5cbiAgICAgIGlmIChwcm9taXNlICYmIHByb21pc2UudGhlbiAmJiBwcm9taXNlLmNhdGNoKSB7XG4gICAgICAgIHByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBtdXRlZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtdXRlZCcpIHtcbiAgICAgIHByb21pc2UgPSBtdXRlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5wbGF5KCk7XG4gICAgfVxuXG4gICAgaWYgKCFwcm9taXNlIHx8ICFwcm9taXNlLnRoZW4gfHwgIXByb21pc2UuY2F0Y2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzNC50cmlnZ2VyKHsgdHlwZTogJ2F1dG9wbGF5LXN1Y2Nlc3MnLCBhdXRvcGxheTogdHlwZSB9KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgX3RoaXM0LnRyaWdnZXIoeyB0eXBlOiAnYXV0b3BsYXktZmFpbHVyZScsIGF1dG9wbGF5OiB0eXBlIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGludGVybmFsIHNvdXJjZSBjYWNoZXMgc28gdGhhdCB3ZSByZXR1cm4gdGhlIGNvcnJlY3Qgc291cmNlIGZyb21cbiAgICogYHNyYygpYCwgYGN1cnJlbnRTb3VyY2UoKWAsIGFuZCBgY3VycmVudFNvdXJjZXMoKWAuXG4gICAqXG4gICAqID4gTm90ZTogYGN1cnJlbnRTb3VyY2VzYCB3aWxsIG5vdCBiZSB1cGRhdGVkIGlmIHRoZSBzb3VyY2UgdGhhdCBpcyBwYXNzZWQgaW4gZXhpc3RzXG4gICAqICAgICAgICAgaW4gdGhlIGN1cnJlbnQgYGN1cnJlbnRTb3VyY2VzYCBjYWNoZS5cbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc3JjT2JqXG4gICAqICAgICAgICBBIHN0cmluZyBvciBvYmplY3Qgc291cmNlIHRvIHVwZGF0ZSBvdXIgY2FjaGVzIHRvLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudXBkYXRlU291cmNlQ2FjaGVzXyA9IGZ1bmN0aW9uIHVwZGF0ZVNvdXJjZUNhY2hlc18oKSB7XG4gICAgdmFyIHNyY09iaiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG5cblxuICAgIHZhciBzcmMgPSBzcmNPYmo7XG4gICAgdmFyIHR5cGUgPSAnJztcblxuICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgc3JjID0gc3JjT2JqLnNyYztcbiAgICAgIHR5cGUgPSBzcmNPYmoudHlwZTtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIGFsbCB0aGUgY2FjaGVzIGFyZSBzZXQgdG8gZGVmYXVsdCB2YWx1ZXNcbiAgICAvLyB0byBwcmV2ZW50IG51bGwgY2hlY2tpbmdcbiAgICB0aGlzLmNhY2hlXy5zb3VyY2UgPSB0aGlzLmNhY2hlXy5zb3VyY2UgfHwge307XG4gICAgdGhpcy5jYWNoZV8uc291cmNlcyA9IHRoaXMuY2FjaGVfLnNvdXJjZXMgfHwgW107XG5cbiAgICAvLyB0cnkgdG8gZ2V0IHRoZSB0eXBlIG9mIHRoZSBzcmMgdGhhdCB3YXMgcGFzc2VkIGluXG4gICAgaWYgKHNyYyAmJiAhdHlwZSkge1xuICAgICAgdHlwZSA9IGZpbmRNaW1ldHlwZSh0aGlzLCBzcmMpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBgY3VycmVudFNvdXJjZWAgY2FjaGUgYWx3YXlzXG4gICAgdGhpcy5jYWNoZV8uc291cmNlID0gbWVyZ2VPcHRpb25zKHt9LCBzcmNPYmosIHsgc3JjOiBzcmMsIHR5cGU6IHR5cGUgfSk7XG5cbiAgICB2YXIgbWF0Y2hpbmdTb3VyY2VzID0gdGhpcy5jYWNoZV8uc291cmNlcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBzLnNyYyAmJiBzLnNyYyA9PT0gc3JjO1xuICAgIH0pO1xuICAgIHZhciBzb3VyY2VFbFNvdXJjZXMgPSBbXTtcbiAgICB2YXIgc291cmNlRWxzID0gdGhpcy4kJCgnc291cmNlJyk7XG4gICAgdmFyIG1hdGNoaW5nU291cmNlRWxzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZUVscy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZU9iaiA9IGdldEF0dHJpYnV0ZXMoc291cmNlRWxzW2ldKTtcblxuICAgICAgc291cmNlRWxTb3VyY2VzLnB1c2goc291cmNlT2JqKTtcblxuICAgICAgaWYgKHNvdXJjZU9iai5zcmMgJiYgc291cmNlT2JqLnNyYyA9PT0gc3JjKSB7XG4gICAgICAgIG1hdGNoaW5nU291cmNlRWxzLnB1c2goc291cmNlT2JqLnNyYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBtYXRjaGluZyBzb3VyY2UgZWxzIGJ1dCBub3QgbWF0Y2hpbmcgc291cmNlc1xuICAgIC8vIHRoZSBjdXJyZW50IHNvdXJjZSBjYWNoZSBpcyBub3QgdXAgdG8gZGF0ZVxuICAgIGlmIChtYXRjaGluZ1NvdXJjZUVscy5sZW5ndGggJiYgIW1hdGNoaW5nU291cmNlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY2FjaGVfLnNvdXJjZXMgPSBzb3VyY2VFbFNvdXJjZXM7XG4gICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIG1hdGNoaW5nIHNvdXJjZSBvciBzb3VyY2UgZWxzIHNldCB0aGVcbiAgICAgIC8vIHNvdXJjZXMgY2FjaGUgdG8gdGhlIGBjdXJyZW50U291cmNlYCBjYWNoZVxuICAgIH0gZWxzZSBpZiAoIW1hdGNoaW5nU291cmNlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY2FjaGVfLnNvdXJjZXMgPSBbdGhpcy5jYWNoZV8uc291cmNlXTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIHRlY2ggYHNyY2AgY2FjaGVcbiAgICB0aGlzLmNhY2hlXy5zcmMgPSBzcmM7XG4gIH07XG5cbiAgLyoqXG4gICAqICpFWFBFUklNRU5UQUwqIEZpcmVkIHdoZW4gdGhlIHNvdXJjZSBpcyBzZXQgb3IgY2hhbmdlZCBvbiB0aGUge0BsaW5rIFRlY2h9XG4gICAqIGNhdXNpbmcgdGhlIG1lZGlhIGVsZW1lbnQgdG8gcmVsb2FkLlxuICAgKlxuICAgKiBJdCB3aWxsIGZpcmUgZm9yIHRoZSBpbml0aWFsIHNvdXJjZSBhbmQgZWFjaCBzdWJzZXF1ZW50IHNvdXJjZS5cbiAgICogVGhpcyBldmVudCBpcyBhIGN1c3RvbSBldmVudCBmcm9tIFZpZGVvLmpzIGFuZCBpcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogVGhlIGV2ZW50IG9iamVjdCBmb3IgdGhpcyBldmVudCBjb250YWlucyBhIGBzcmNgIHByb3BlcnR5IHRoYXQgd2lsbCBjb250YWluIHRoZSBzb3VyY2VcbiAgICogdGhhdCB3YXMgYXZhaWxhYmxlIHdoZW4gdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQuIFRoaXMgaXMgZ2VuZXJhbGx5IG9ubHkgbmVjZXNzYXJ5IGlmIFZpZGVvLmpzXG4gICAqIGlzIHN3aXRjaGluZyB0ZWNocyB3aGlsZSB0aGUgc291cmNlIHdhcyBiZWluZyBjaGFuZ2VkLlxuICAgKlxuICAgKiBJdCBpcyBhbHNvIGZpcmVkIHdoZW4gYGxvYWRgIGlzIGNhbGxlZCBvbiB0aGUgcGxheWVyIChvciBtZWRpYSBlbGVtZW50KVxuICAgKiBiZWNhdXNlIHRoZSB7QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvbWVkaWEuaHRtbCNkb20tbWVkaWEtbG9hZHxzcGVjaWZpY2F0aW9uIGZvciBgbG9hZGB9XG4gICAqIHNheXMgdGhhdCB0aGUgcmVzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobSBuZWVkcyB0byBiZSBhYm9ydGVkIGFuZCByZXN0YXJ0ZWQuXG4gICAqIEluIHRoaXMgY2FzZSwgaXQgaXMgdmVyeSBsaWtlbHkgdGhhdCB0aGUgYHNyY2AgcHJvcGVydHkgd2lsbCBiZSBzZXQgdG8gdGhlXG4gICAqIGVtcHR5IHN0cmluZyBgXCJcImAgdG8gaW5kaWNhdGUgd2UgZG8gbm90IGtub3cgd2hhdCB0aGUgc291cmNlIHdpbGwgYmUgYnV0XG4gICAqIHRoYXQgaXQgaXMgY2hhbmdpbmcuXG4gICAqXG4gICAqICpUaGlzIGV2ZW50IGlzIGN1cnJlbnRseSBzdGlsbCBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gbWlub3IgcmVsZWFzZXMuKlxuICAgKiBfX1RvIHVzZSB0aGlzLCBwYXNzIGBlbmFibGVTb3VyY2VzZXRgIG9wdGlvbiB0byB0aGUgcGxheWVyLl9fXG4gICAqXG4gICAqIEBldmVudCBQbGF5ZXIjc291cmNlc2V0XG4gICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICogQHByb3Age3N0cmluZ30gc3JjXG4gICAqICAgICAgICAgICAgICAgIFRoZSBzb3VyY2UgdXJsIGF2YWlsYWJsZSB3aGVuIHRoZSBgc291cmNlc2V0YCB3YXMgdHJpZ2dlcmVkLlxuICAgKiAgICAgICAgICAgICAgICBJdCB3aWxsIGJlIGFuIGVtcHR5IHN0cmluZyBpZiB3ZSBjYW5ub3Qga25vdyB3aGF0IHRoZSBzb3VyY2UgaXNcbiAgICogICAgICAgICAgICAgICAgYnV0IGtub3cgdGhhdCB0aGUgc291cmNlIHdpbGwgY2hhbmdlLlxuICAgKi9cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHNvdXJjZXNldGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjc291cmNlc2V0XG4gICAqIEBsaXN0ZW5zIFRlY2gjc291cmNlc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoU291cmNlc2V0XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hTb3VyY2VzZXRfKGV2ZW50KSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAvLyBvbmx5IHVwZGF0ZSB0aGUgc291cmNlIGNhY2hlIHdoZW4gdGhlIHNvdXJjZVxuICAgIC8vIHdhcyBub3QgdXBkYXRlZCB1c2luZyB0aGUgcGxheWVyIGFwaVxuICAgIGlmICghdGhpcy5jaGFuZ2luZ1NyY18pIHtcbiAgICAgIC8vIHVwZGF0ZSB0aGUgc291cmNlIHRvIHRoZSBpbnRpYWwgc291cmNlIHJpZ2h0IGF3YXlcbiAgICAgIC8vIGluIHNvbWUgY2FzZXMgdGhpcyB3aWxsIGJlIGVtcHR5IHN0cmluZ1xuICAgICAgdGhpcy51cGRhdGVTb3VyY2VDYWNoZXNfKGV2ZW50LnNyYyk7XG5cbiAgICAgIC8vIGlmIHRoZSBgc291cmNlc2V0YCBgc3JjYCB3YXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAvLyB3YWl0IGZvciBhIGBsb2Fkc3RhcnRgIHRvIHVwZGF0ZSB0aGUgY2FjaGUgdG8gYGN1cnJlbnRTcmNgLlxuICAgICAgLy8gSWYgYSBzb3VyY2VzZXQgaGFwcGVucyBiZWZvcmUgYSBgbG9hZHN0YXJ0YCwgd2UgcmVzZXQgdGhlIHN0YXRlXG4gICAgICAvLyBhcyB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFnYWluLlxuICAgICAgaWYgKCFldmVudC5zcmMpIHtcbiAgICAgICAgdmFyIHVwZGF0ZUNhY2hlID0gZnVuY3Rpb24gdXBkYXRlQ2FjaGUoZSkge1xuICAgICAgICAgIGlmIChlLnR5cGUgIT09ICdzb3VyY2VzZXQnKSB7XG4gICAgICAgICAgICBfdGhpczUudXBkYXRlU291cmNlQ2FjaGVzXyhfdGhpczUudGVjaEdldF8oJ2N1cnJlbnRTcmMnKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXM1LnRlY2hfLm9mZihbJ3NvdXJjZXNldCcsICdsb2Fkc3RhcnQnXSwgdXBkYXRlQ2FjaGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudGVjaF8ub25lKFsnc291cmNlc2V0JywgJ2xvYWRzdGFydCddLCB1cGRhdGVDYWNoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyKHtcbiAgICAgIHNyYzogZXZlbnQuc3JjLFxuICAgICAgdHlwZTogJ3NvdXJjZXNldCdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkL3JlbW92ZSB0aGUgdmpzLWhhcy1zdGFydGVkIGNsYXNzXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZmlyc3RwbGF5XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWVzdFxuICAgKiAgICAgICAgLSB0cnVlOiBhZGRzIHRoZSBjbGFzc1xuICAgKiAgICAgICAgLSBmYWxzZTogcmVtb3ZlIHRoZSBjbGFzc1xuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIHRoZSBib29sZWFuIHZhbHVlIG9mIGhhc1N0YXJ0ZWRfXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYXNTdGFydGVkID0gZnVuY3Rpb24gaGFzU3RhcnRlZChyZXF1ZXN0KSB7XG4gICAgaWYgKHJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYWN0IGFzIGdldHRlciwgaWYgd2UgaGF2ZSBubyByZXF1ZXN0IHRvIGNoYW5nZVxuICAgICAgcmV0dXJuIHRoaXMuaGFzU3RhcnRlZF87XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QgPT09IHRoaXMuaGFzU3RhcnRlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmhhc1N0YXJ0ZWRfID0gcmVxdWVzdDtcblxuICAgIGlmICh0aGlzLmhhc1N0YXJ0ZWRfKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZmlyc3RwbGF5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oYXMtc3RhcnRlZCcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIG1lZGlhIGJlZ2lucyBvciByZXN1bWVzIHBsYXliYWNrXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtcGxheX1cbiAgICogQGZpcmVzIFBsYXllciNwbGF5XG4gICAqIEBsaXN0ZW5zIFRlY2gjcGxheVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFBsYXlfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFBsYXlfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtcGxheWluZycpO1xuXG4gICAgLy8gaGlkZSB0aGUgcG9zdGVyIHdoZW4gdGhlIHVzZXIgaGl0cyBwbGF5XG4gICAgdGhpcy5oYXNTdGFydGVkKHRydWUpO1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuZXZlciBhbiB7QGxpbmsgVGVjaCNwbGF5fSBldmVudCBoYXBwZW5zLiBJbmRpY2F0ZXMgdGhhdFxuICAgICAqIHBsYXliYWNrIGhhcyBzdGFydGVkIG9yIHJlc3VtZWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3BsYXlcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdwbGF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHJhdGVjaGFuZ2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBJZiB0aGVyZSB3ZXJlIGFueSBldmVudHMgcXVldWVkIHdoaWxlIHRoZSBwbGF5YmFjayByYXRlIHdhcyB6ZXJvLCBmaXJlXG4gICAqIHRob3NlIGV2ZW50cyBub3cuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hSYXRlQ2hhbmdlX1xuICAgKiBAZmlyZXMgUGxheWVyI3JhdGVjaGFuZ2VcbiAgICogQGxpc3RlbnMgVGVjaCNyYXRlY2hhbmdlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUmF0ZUNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUmF0ZUNoYW5nZV8oKSB7XG4gICAgaWYgKHRoaXMudGVjaF8ucGxheWJhY2tSYXRlKCkgPiAwICYmIHRoaXMuY2FjaGVfLmxhc3RQbGF5YmFja1JhdGUgPT09IDApIHtcbiAgICAgIHRoaXMucXVldWVkQ2FsbGJhY2tzXy5mb3JFYWNoKGZ1bmN0aW9uIChxdWV1ZWQpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXVlZC5jYWxsYmFjayhxdWV1ZWQuZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnF1ZXVlZENhbGxiYWNrc18gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5jYWNoZV8ubGFzdFBsYXliYWNrUmF0ZSA9IHRoaXMudGVjaF8ucGxheWJhY2tSYXRlKCk7XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgcGxheWluZyBzcGVlZCBvZiB0aGUgYXVkaW8vdmlkZW8gaXMgY2hhbmdlZFxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNyYXRlY2hhbmdlXG4gICAgICogQHR5cGUge2V2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcigncmF0ZWNoYW5nZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGB3YWl0aW5nYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciN3YWl0aW5nXG4gICAqIEBsaXN0ZW5zIFRlY2gjd2FpdGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFdhaXRpbmdfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFdhaXRpbmdfKCkge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICAvKipcbiAgICAgKiBBIHJlYWR5U3RhdGUgY2hhbmdlIG9uIHRoZSBET00gZWxlbWVudCBoYXMgY2F1c2VkIHBsYXliYWNrIHRvIHN0b3AuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3dhaXRpbmdcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCd3YWl0aW5nJyk7XG4gICAgdGhpcy5vbmUoJ3RpbWV1cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXM2LnJlbW92ZUNsYXNzKCd2anMtd2FpdGluZycpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBjYW5wbGF5YCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICogPiBOb3RlOiBUaGlzIGlzIG5vdCBjb25zaXN0ZW50IGJldHdlZW4gYnJvd3NlcnMuIFNlZSAjMTM1MVxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2NhbnBsYXlcbiAgICogQGxpc3RlbnMgVGVjaCNjYW5wbGF5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoQ2FuUGxheV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoQ2FuUGxheV8oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWVkaWEgaGFzIGEgcmVhZHlTdGF0ZSBvZiBIQVZFX0ZVVFVSRV9EQVRBIG9yIGdyZWF0ZXIuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI2NhbnBsYXlcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdjYW5wbGF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYGNhbnBsYXl0aHJvdWdoYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNjYW5wbGF5dGhyb3VnaFxuICAgKiBAbGlzdGVucyBUZWNoI2NhbnBsYXl0aHJvdWdoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoQ2FuUGxheVRocm91Z2hfID0gZnVuY3Rpb24gaGFuZGxlVGVjaENhblBsYXlUaHJvdWdoXygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtd2FpdGluZycpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtZWRpYSBoYXMgYSByZWFkeVN0YXRlIG9mIEhBVkVfRU5PVUdIX0RBVEEgb3IgZ3JlYXRlci4gVGhpcyBtZWFucyB0aGF0IHRoZVxuICAgICAqIGVudGlyZSBtZWRpYSBmaWxlIGNhbiBiZSBwbGF5ZWQgd2l0aG91dCBidWZmZXJpbmcuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI2NhbnBsYXl0aHJvdWdoXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignY2FucGxheXRocm91Z2gnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgcGxheWluZ2AgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjcGxheWluZ1xuICAgKiBAbGlzdGVucyBUZWNoI3BsYXlpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQbGF5aW5nXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hQbGF5aW5nXygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtd2FpdGluZycpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtZWRpYSBpcyBubyBsb25nZXIgYmxvY2tlZCBmcm9tIHBsYXliYWNrLCBhbmQgaGFzIHN0YXJ0ZWQgcGxheWluZy5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcGxheWluZ1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3BsYXlpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgc2Vla2luZ2AgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjc2Vla2luZ1xuICAgKiBAbGlzdGVucyBUZWNoI3NlZWtpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hTZWVraW5nXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hTZWVraW5nXygpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtc2Vla2luZycpO1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBwbGF5ZXIgaXMganVtcGluZyB0byBhIG5ldyB0aW1lXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3NlZWtpbmdcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdzZWVraW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHNlZWtlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjc2Vla2VkXG4gICAqIEBsaXN0ZW5zIFRlY2gjc2Vla2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoU2Vla2VkXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hTZWVrZWRfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zZWVraW5nJyk7XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBmaW5pc2hlZCBqdW1waW5nIHRvIGEgbmV3IHRpbWVcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjc2Vla2VkXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignc2Vla2VkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYGZpcnN0cGxheWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZmlyc3RwbGF5XG4gICAqIEBsaXN0ZW5zIFRlY2gjZmlyc3RwbGF5XG4gICAqIEBkZXByZWNhdGVkIEFzIG9mIDYuMCBmaXJzdHBsYXkgZXZlbnQgaXMgZGVwcmVjYXRlZC5cbiAgICogQGRlcHJlY2F0ZWQgQXMgb2YgNi4wIHBhc3NpbmcgdGhlIGBzdGFydHRpbWVgIG9wdGlvbiB0byB0aGUgcGxheWVyIGFuZCB0aGUgZmlyc3RwbGF5IGV2ZW50IGFyZSBkZXByZWNhdGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEZpcnN0UGxheV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRmlyc3RQbGF5XygpIHtcbiAgICAvLyBJZiB0aGUgZmlyc3Qgc3RhcnR0aW1lIGF0dHJpYnV0ZSBpcyBzcGVjaWZpZWRcbiAgICAvLyB0aGVuIHdlIHdpbGwgc3RhcnQgYXQgdGhlIGdpdmVuIG9mZnNldCBpbiBzZWNvbmRzXG4gICAgaWYgKHRoaXMub3B0aW9uc18uc3RhcnR0aW1lKSB7XG4gICAgICBsb2ckMS53YXJuKCdQYXNzaW5nIHRoZSBgc3RhcnR0aW1lYCBvcHRpb24gdG8gdGhlIHBsYXllciB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gNi4wJyk7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lKHRoaXMub3B0aW9uc18uc3RhcnR0aW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZENsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB0aGUgZmlyc3QgdGltZSBhIHZpZGVvIGlzIHBsYXllZC4gTm90IHBhcnQgb2YgdGhlIEhMUyBzcGVjLCBhbmQgdGhpcyBpc1xuICAgICAqIHByb2JhYmx5IG5vdCB0aGUgYmVzdCBpbXBsZW1lbnRhdGlvbiB5ZXQsIHNvIHVzZSBzcGFyaW5nbHkuIElmIHlvdSBkb24ndCBoYXZlIGFcbiAgICAgKiByZWFzb24gdG8gcHJldmVudCBwbGF5YmFjaywgdXNlIGBteVBsYXllci5vbmUoJ3BsYXknKTtgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI2ZpcnN0cGxheVxuICAgICAqIEBkZXByZWNhdGVkIEFzIG9mIDYuMCBmaXJzdHBsYXkgZXZlbnQgaXMgZGVwcmVjYXRlZC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgcGF1c2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3BhdXNlXG4gICAqIEBsaXN0ZW5zIFRlY2gjcGF1c2VcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQYXVzZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUGF1c2VfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBtZWRpYSBoYXMgYmVlbiBwYXVzZWRcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcGF1c2VcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdwYXVzZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBlbmRlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZW5kZWRcbiAgICogQGxpc3RlbnMgVGVjaCNlbmRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEVuZGVkXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hFbmRlZF8oKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgaWYgKHRoaXMub3B0aW9uc18ubG9vcCkge1xuICAgICAgdGhpcy5jdXJyZW50VGltZSgwKTtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIG1lZGlhIHJlc291cmNlIGlzIHJlYWNoZWQgKGN1cnJlbnRUaW1lID09IGR1cmF0aW9uKVxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNlbmRlZFxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2VuZGVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIGR1cmF0aW9uIG9mIHRoZSBtZWRpYSByZXNvdXJjZSBpcyBmaXJzdCBrbm93biBvciBjaGFuZ2VkXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjZHVyYXRpb25jaGFuZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2VfKCkge1xuICAgIHRoaXMuZHVyYXRpb24odGhpcy50ZWNoR2V0XygnZHVyYXRpb24nKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGNsaWNrIG9uIHRoZSBtZWRpYSBlbGVtZW50IHRvIHBsYXkvcGF1c2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHRyaWdnZXJcbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCNtb3VzZWRvd25cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hDbGlja18gPSBmdW5jdGlvbiBoYW5kbGVUZWNoQ2xpY2tfKGV2ZW50KSB7XG4gICAgaWYgKCFpc1NpbmdsZUxlZnRDbGljayhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGNvbnRyb2xzIGFyZSBkaXNhYmxlZCBhIGNsaWNrIHNob3VsZCBub3QgdG9nZ2xlIHBsYXliYWNrIGJlY2F1c2VcbiAgICAvLyB0aGUgY2xpY2sgaXMgY29uc2lkZXJlZCBhIGNvbnRyb2xcbiAgICBpZiAoIXRoaXMuY29udHJvbHNfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHNpbGVuY2VQcm9taXNlKHRoaXMucGxheSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgZG91YmxlLWNsaWNrIG9uIHRoZSBtZWRpYSBlbGVtZW50IHRvIGVudGVyL2V4aXQgZnVsbHNjcmVlblxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgdGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gdHJpZ2dlclxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI2RibGNsaWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoRG91YmxlQ2xpY2tfID0gZnVuY3Rpb24gaGFuZGxlVGVjaERvdWJsZUNsaWNrXyhldmVudCkge1xuICAgIGlmICghdGhpcy5jb250cm9sc18pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byB0b2dnbGUgZnVsbHNjcmVlbiBzdGF0ZVxuICAgIC8vIHdoZW4gZG91YmxlLWNsaWNraW5nIGluc2lkZSBhIGNvbnRyb2wgYmFyIG9yIGEgbW9kYWxcbiAgICB2YXIgaW5BbGxvd2VkRWxzID0gQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbCh0aGlzLiQkKCcudmpzLWNvbnRyb2wtYmFyLCAudmpzLW1vZGFsLWRpYWxvZycpLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBlbC5jb250YWlucyhldmVudC50YXJnZXQpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFpbkFsbG93ZWRFbHMpIHtcbiAgICAgIGlmICh0aGlzLmlzRnVsbHNjcmVlbigpKSB7XG4gICAgICAgIHRoaXMuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIHRhcCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gSXQgd2lsbCB0b2dnbGUgdGhlIHVzZXJcbiAgICogYWN0aXZpdHkgc3RhdGUsIHdoaWNoIGhpZGVzIGFuZCBzaG93cyB0aGUgY29udHJvbHMuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjdGFwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVGFwXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUYXBfKCkge1xuICAgIHRoaXMudXNlckFjdGl2ZSghdGhpcy51c2VyQWN0aXZlKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdG91Y2ggdG8gc3RhcnRcbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCN0b3VjaHN0YXJ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVG91Y2hTdGFydF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoVG91Y2hTdGFydF8oKSB7XG4gICAgdGhpcy51c2VyV2FzQWN0aXZlID0gdGhpcy51c2VyQWN0aXZlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0b3VjaCB0byBtb3ZlXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjdG91Y2htb3ZlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVG91Y2hNb3ZlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUb3VjaE1vdmVfKCkge1xuICAgIGlmICh0aGlzLnVzZXJXYXNBY3RpdmUpIHtcbiAgICAgIHRoaXMucmVwb3J0VXNlckFjdGl2aXR5KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdG91Y2ggdG8gZW5kXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICB0aGUgdG91Y2hlbmQgZXZlbnQgdGhhdCB0cmlnZ2VyZWRcbiAgICogICAgICAgIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCN0b3VjaGVuZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFRvdWNoRW5kXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUb3VjaEVuZF8oZXZlbnQpIHtcbiAgICAvLyBTdG9wIHRoZSBtb3VzZSBldmVudHMgZnJvbSBhbHNvIGhhcHBlbmluZ1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBzd2l0Y2hlcyBpbiBvciBvdXQgb2YgZnVsbHNjcmVlbiBtb2RlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBsaXN0ZW5zIFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2VfKCkge1xuICAgIGlmICh0aGlzLmlzRnVsbHNjcmVlbigpKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtZnVsbHNjcmVlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZnVsbHNjcmVlbicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogbmF0aXZlIGNsaWNrIGV2ZW50cyBvbiB0aGUgU1dGIGFyZW4ndCB0cmlnZ2VyZWQgb24gSUUxMSwgV2luOC4xUlRcbiAgICogdXNlIHN0YWdlY2xpY2sgZXZlbnRzIHRyaWdnZXJlZCBmcm9tIGluc2lkZSB0aGUgU1dGIGluc3RlYWRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGxpc3RlbnMgc3RhZ2VjbGlja1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlU3RhZ2VDbGlja18gPSBmdW5jdGlvbiBoYW5kbGVTdGFnZUNsaWNrXygpIHtcbiAgICB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgVGVjaCBGdWxsc2NyZWVuIENoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgdGhlIGZ1bGxzY3JlZW5jaGFuZ2UgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiAgICAgICAgdGhlIGRhdGEgdGhhdCB3YXMgc2VudCB3aXRoIHRoZSBldmVudFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbGlzdGVucyBUZWNoI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICogQGZpcmVzIFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoRnVsbHNjcmVlbkNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRnVsbHNjcmVlbkNoYW5nZV8oZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5pc0Z1bGxzY3JlZW4oZGF0YS5pc0Z1bGxzY3JlZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGdvaW5nIGluIGFuZCBvdXQgb2YgZnVsbHNjcmVlbi5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZXMgd2hlbiBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIGxvYWRpbmcgb2YgYW4gYXVkaW8vdmlkZW8uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBsaXN0ZW5zIFRlY2gjZXJyb3JcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hFcnJvcl8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRXJyb3JfKCkge1xuICAgIHZhciBlcnJvciA9IHRoaXMudGVjaF8uZXJyb3IoKTtcblxuICAgIHRoaXMuZXJyb3IoZXJyb3IpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGB0ZXh0ZGF0YWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjdGV4dGRhdGFcbiAgICogQGxpc3RlbnMgVGVjaCN0ZXh0ZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFRleHREYXRhXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUZXh0RGF0YV8oKSB7XG4gICAgdmFyIGRhdGEgPSBudWxsO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBkYXRhID0gYXJndW1lbnRzWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gd2UgZ2V0IGEgdGV4dGRhdGEgZXZlbnQgZnJvbSB0ZWNoXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3RleHRkYXRhXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcigndGV4dGRhdGEnLCBkYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9iamVjdCBmb3IgY2FjaGVkIHZhbHVlcy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIGdldCB0aGUgY3VycmVudCBvYmplY3QgY2FjaGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmdldENhY2hlID0gZnVuY3Rpb24gZ2V0Q2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXNzIHZhbHVlcyB0byB0aGUgcGxheWJhY2sgdGVjaFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZF1cbiAgICogICAgICAgIHRoZSBtZXRob2QgdG8gY2FsbFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJnXG4gICAqICAgICAgICB0aGUgYXJndW1lbnQgdG8gcGFzc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudGVjaENhbGxfID0gZnVuY3Rpb24gdGVjaENhbGxfKG1ldGhvZCwgYXJnKSB7XG4gICAgLy8gSWYgaXQncyBub3QgcmVhZHkgeWV0LCBjYWxsIG1ldGhvZCB3aGVuIGl0IGlzXG5cbiAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChtZXRob2QgaW4gYWxsb3dlZFNldHRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHNldCQxKHRoaXMubWlkZGxld2FyZV8sIHRoaXMudGVjaF8sIG1ldGhvZCwgYXJnKTtcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kIGluIGFsbG93ZWRNZWRpYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIG1lZGlhdGUodGhpcy5taWRkbGV3YXJlXywgdGhpcy50ZWNoXywgbWV0aG9kLCBhcmcpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgICAgIHRoaXMudGVjaF9bbWV0aG9kXShhcmcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZyQxKGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0sIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgY2FsbHMgY2FuJ3Qgd2FpdCBmb3IgdGhlIHRlY2gsIGFuZCBzb21ldGltZXMgZG9uJ3QgbmVlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICAgKiAgICAgICAgVGVjaCBtZXRob2RcbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIHRoZSBtZXRob2Qgb3IgdW5kZWZpbmVkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS50ZWNoR2V0XyA9IGZ1bmN0aW9uIHRlY2hHZXRfKG1ldGhvZCkge1xuICAgIGlmICghdGhpcy50ZWNoXyB8fCAhdGhpcy50ZWNoXy5pc1JlYWR5Xykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtZXRob2QgaW4gYWxsb3dlZEdldHRlcnMpIHtcbiAgICAgIHJldHVybiBnZXQkMSh0aGlzLm1pZGRsZXdhcmVfLCB0aGlzLnRlY2hfLCBtZXRob2QpO1xuICAgIH0gZWxzZSBpZiAobWV0aG9kIGluIGFsbG93ZWRNZWRpYXRvcnMpIHtcbiAgICAgIHJldHVybiBtZWRpYXRlKHRoaXMubWlkZGxld2FyZV8sIHRoaXMudGVjaF8sIG1ldGhvZCk7XG4gICAgfVxuXG4gICAgLy8gRmxhc2ggbGlrZXMgdG8gZGllIGFuZCByZWxvYWQgd2hlbiB5b3UgaGlkZSBvciByZXBvc2l0aW9uIGl0LlxuICAgIC8vIEluIHRoZXNlIGNhc2VzIHRoZSBvYmplY3QgbWV0aG9kcyBnbyBhd2F5IGFuZCB3ZSBnZXQgZXJyb3JzLlxuICAgIC8vIFdoZW4gdGhhdCBoYXBwZW5zIHdlJ2xsIGNhdGNoIHRoZSBlcnJvcnMgYW5kIGluZm9ybSB0ZWNoIHRoYXQgaXQncyBub3QgcmVhZHkgYW55IG1vcmUuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hfW21ldGhvZF0oKTtcbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgIC8vIFdoZW4gYnVpbGRpbmcgYWRkaXRpb25hbCB0ZWNoIGxpYnMsIGFuIGV4cGVjdGVkIG1ldGhvZCBtYXkgbm90IGJlIGRlZmluZWQgeWV0XG4gICAgICBpZiAodGhpcy50ZWNoX1ttZXRob2RdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9nJDEoJ1ZpZGVvLmpzOiAnICsgbWV0aG9kICsgJyBtZXRob2Qgbm90IGRlZmluZWQgZm9yICcgKyB0aGlzLnRlY2hOYW1lXyArICcgcGxheWJhY2sgdGVjaG5vbG9neS4nLCBlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2hlbiBhIG1ldGhvZCBpc24ndCBhdmFpbGFibGUgb24gdGhlIG9iamVjdCBpdCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAgICAgIGlmIChlLm5hbWUgPT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgIGxvZyQxKCdWaWRlby5qczogJyArIG1ldGhvZCArICcgdW5hdmFpbGFibGUgb24gJyArIHRoaXMudGVjaE5hbWVfICsgJyBwbGF5YmFjayB0ZWNobm9sb2d5IGVsZW1lbnQuJywgZSk7XG4gICAgICAgIHRoaXMudGVjaF8uaXNSZWFkeV8gPSBmYWxzZTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZXJyb3IgdW5rbm93biwganVzdCBsb2cgYW5kIHRocm93XG4gICAgICBsb2ckMShlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGJlZ2luIHBsYXliYWNrIGF0IHRoZSBmaXJzdCBvcHBvcnR1bml0eS5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9XG4gICAqICAgICAgICAgUmV0dXJucyBhIGBQcm9taXNlYCBvbmx5IGlmIHRoZSBicm93c2VyIHJldHVybnMgb25lIGFuZCB0aGUgcGxheWVyXG4gICAqICAgICAgICAgaXMgcmVhZHkgdG8gYmVnaW4gcGxheWJhY2suIEZvciBzb21lIGJyb3dzZXJzIGFuZCBhbGwgbm9uLXJlYWR5XG4gICAqICAgICAgICAgc2l0dWF0aW9ucywgdGhpcyB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiBwbGF5KCkge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBjYWxsZWQgd2hpbGUgd2UgaGF2ZSBhIHBsYXkgcXVldWVkIHVwIG9uIGEgbG9hZHN0YXJ0LCByZW1vdmVcbiAgICAvLyB0aGF0IGxpc3RlbmVyIHRvIGF2b2lkIGdldHRpbmcgaW4gYSBwb3RlbnRpYWxseSBiYWQgc3RhdGUuXG4gICAgaWYgKHRoaXMucGxheU9uTG9hZHN0YXJ0Xykge1xuICAgICAgdGhpcy5vZmYoJ2xvYWRzdGFydCcsIHRoaXMucGxheU9uTG9hZHN0YXJ0Xyk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHBsYXllci90ZWNoIGlzIG5vdCByZWFkeSwgcXVldWUgdXAgYW5vdGhlciBjYWxsIHRvIGBwbGF5KClgIGZvclxuICAgIC8vIHdoZW4gaXQgaXMuIFRoaXMgd2lsbCBsb29wIGJhY2sgaW50byB0aGlzIG1ldGhvZCBmb3IgYW5vdGhlciBhdHRlbXB0IGF0XG4gICAgLy8gcGxheWJhY2sgd2hlbiB0aGUgdGVjaCBpcyByZWFkeS5cbiAgICBpZiAoIXRoaXMuaXNSZWFkeV8pIHtcblxuICAgICAgLy8gQmFpbCBvdXQgaWYgd2UncmUgYWxyZWFkeSB3YWl0aW5nIGZvciBgcmVhZHlgIVxuICAgICAgaWYgKHRoaXMucGxheVdhaXRpbmdGb3JSZWFkeV8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBsYXlXYWl0aW5nRm9yUmVhZHlfID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczcucGxheVdhaXRpbmdGb3JSZWFkeV8gPSBmYWxzZTtcbiAgICAgICAgc2lsZW5jZVByb21pc2UoX3RoaXM3LnBsYXkoKSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgdGhlIHBsYXllci90ZWNoIGlzIHJlYWR5IGFuZCB3ZSBoYXZlIGEgc291cmNlLCB3ZSBjYW4gYXR0ZW1wdCBwbGF5YmFjay5cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmNoYW5naW5nU3JjXyAmJiAodGhpcy5zcmMoKSB8fCB0aGlzLmN1cnJlbnRTcmMoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwbGF5Jyk7XG5cbiAgICAgIC8vIElmIHRoZSB0ZWNoIGlzIHJlYWR5LCBidXQgd2UgZG8gbm90IGhhdmUgYSBzb3VyY2UsIHdlJ2xsIG5lZWQgdG8gd2FpdFxuICAgICAgLy8gZm9yIGJvdGggdGhlIGByZWFkeWAgYW5kIGEgYGxvYWRzdGFydGAgd2hlbiB0aGUgc291cmNlIGlzIGZpbmFsbHlcbiAgICAgIC8vIHJlc29sdmVkIGJ5IG1pZGRsZXdhcmUgYW5kIHNldCBvbiB0aGUgcGxheWVyLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBgcGxheSgpYCBpcyBjYWxsZWQgd2hpbGUgY2hhbmdpbmcgc291cmNlcyBvciBiZWZvcmVcbiAgICAgIC8vIG9uZSBoYXMgYmVlbiBzZXQgb24gdGhlIHBsYXllci5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLnBsYXlPbkxvYWRzdGFydF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNy5wbGF5T25Mb2Fkc3RhcnRfID0gbnVsbDtcbiAgICAgICAgc2lsZW5jZVByb21pc2UoX3RoaXM3LnBsYXkoKSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uZSgnbG9hZHN0YXJ0JywgdGhpcy5wbGF5T25Mb2Fkc3RhcnRfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSB2aWRlbyBwbGF5YmFja1xuICAgKlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqICAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHBsYXllciBvYmplY3QgdGhpcyBmdW5jdGlvbiB3YXMgY2FsbGVkIG9uXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIHRoaXMudGVjaENhbGxfKCdwYXVzZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcGxheWVyIGlzIHBhdXNlZCBvciBoYXMgeWV0IHRvIHBsYXlcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIGZhbHNlOiBpZiB0aGUgbWVkaWEgaXMgY3VycmVudGx5IHBsYXlpbmdcbiAgICogICAgICAgICAtIHRydWU6IGlmIG1lZGlhIGlzIG5vdCBjdXJyZW50bHkgcGxheWluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGF1c2VkID0gZnVuY3Rpb24gcGF1c2VkKCkge1xuICAgIC8vIFRoZSBpbml0aWFsIHN0YXRlIG9mIHBhdXNlZCBzaG91bGQgYmUgdHJ1ZSAoaW4gU2FmYXJpIGl0J3MgYWN0dWFsbHkgZmFsc2UpXG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BhdXNlZCcpID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgVGltZVJhbmdlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcmFuZ2VzIG9mIHRpbWUgdGhhdCB0aGUgdXNlclxuICAgKiBoYXMgcGxheWVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gICAqICAgICAgICAgQSB0aW1lIHJhbmdlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYWxsIHRoZSBpbmNyZW1lbnRzIG9mIHRpbWUgdGhhdCBoYXZlXG4gICAqICAgICAgICAgYmVlbiBwbGF5ZWQuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wbGF5ZWQgPSBmdW5jdGlvbiBwbGF5ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BsYXllZCcpIHx8IGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHVzZXIgaXMgXCJzY3J1YmJpbmdcIi4gU2NydWJiaW5nIGlzXG4gICAqIHdoZW4gdGhlIHVzZXIgaGFzIGNsaWNrZWQgdGhlIHByb2dyZXNzIGJhciBoYW5kbGUgYW5kIGlzXG4gICAqIGRyYWdnaW5nIGl0IGFsb25nIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2NydWJiaW5nXVxuICAgKiAgICAgICAgd2hldGhlciB0aGUgdXNlciBpcyBvciBpcyBub3Qgc2NydWJiaW5nXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgVGhlIHZhbHVlIG9mIHNjcnViYmluZyB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnNjcnViYmluZyA9IGZ1bmN0aW9uIHNjcnViYmluZyhpc1NjcnViYmluZykge1xuICAgIGlmICh0eXBlb2YgaXNTY3J1YmJpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3J1YmJpbmdfO1xuICAgIH1cbiAgICB0aGlzLnNjcnViYmluZ18gPSAhIWlzU2NydWJiaW5nO1xuXG4gICAgaWYgKGlzU2NydWJiaW5nKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2NydWJiaW5nJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zY3J1YmJpbmcnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGN1cnJlbnQgdGltZSAoaW4gc2Vjb25kcylcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbc2Vjb25kc11cbiAgICogICAgICAgIFRoZSB0aW1lIHRvIHNlZWsgdG8gaW4gc2Vjb25kc1xuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgLSB0aGUgY3VycmVudCB0aW1lIGluIHNlY29uZHMgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50VGltZSA9IGZ1bmN0aW9uIGN1cnJlbnRUaW1lKHNlY29uZHMpIHtcbiAgICBpZiAodHlwZW9mIHNlY29uZHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoc2Vjb25kcyA8IDApIHtcbiAgICAgICAgc2Vjb25kcyA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0Q3VycmVudFRpbWUnLCBzZWNvbmRzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjYWNoZSBsYXN0IGN1cnJlbnRUaW1lIGFuZCByZXR1cm4uIGRlZmF1bHQgdG8gMCBzZWNvbmRzXG4gICAgLy9cbiAgICAvLyBDYWNoaW5nIHRoZSBjdXJyZW50VGltZSBpcyBtZWFudCB0byBwcmV2ZW50IGEgbWFzc2l2ZSBhbW91bnQgb2YgcmVhZHMgb24gdGhlIHRlY2gnc1xuICAgIC8vIGN1cnJlbnRUaW1lIHdoZW4gc2NydWJiaW5nLCBidXQgbWF5IG5vdCBwcm92aWRlIG11Y2ggcGVyZm9ybWFuY2UgYmVuZWZpdCBhZnRlcmFsbC5cbiAgICAvLyBTaG91bGQgYmUgdGVzdGVkLiBBbHNvIHNvbWV0aGluZyBoYXMgdG8gcmVhZCB0aGUgYWN0dWFsIGN1cnJlbnQgdGltZSBvciB0aGUgY2FjaGUgd2lsbFxuICAgIC8vIG5ldmVyIGdldCB1cGRhdGVkLlxuICAgIHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lID0gdGhpcy50ZWNoR2V0XygnY3VycmVudFRpbWUnKSB8fCAwO1xuICAgIHJldHVybiB0aGlzLmNhY2hlXy5jdXJyZW50VGltZTtcbiAgfTtcblxuICAvKipcbiAgICogTm9ybWFsbHkgZ2V0cyB0aGUgbGVuZ3RoIGluIHRpbWUgb2YgdGhlIHZpZGVvIGluIHNlY29uZHM7XG4gICAqIGluIGFsbCBidXQgdGhlIHJhcmVzdCB1c2UgY2FzZXMgYW4gYXJndW1lbnQgd2lsbCBOT1QgYmUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICpcbiAgICogPiAqKk5PVEUqKjogVGhlIHZpZGVvIG11c3QgaGF2ZSBzdGFydGVkIGxvYWRpbmcgYmVmb3JlIHRoZSBkdXJhdGlvbiBjYW4gYmVcbiAgICoga25vd24sIGFuZCBpbiB0aGUgY2FzZSBvZiBGbGFzaCwgbWF5IG5vdCBiZSBrbm93biB1bnRpbCB0aGUgdmlkZW8gc3RhcnRzXG4gICAqIHBsYXlpbmcuXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmRzXVxuICAgKiAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSB2aWRlbyB0byBzZXQgaW4gc2Vjb25kc1xuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgLSBUaGUgZHVyYXRpb24gb2YgdGhlIHZpZGVvIGluIHNlY29uZHMgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKHNlY29uZHMpIHtcbiAgICBpZiAoc2Vjb25kcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gTmFOIGlmIHRoZSBkdXJhdGlvbiBpcyBub3Qga25vd25cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlXy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5jYWNoZV8uZHVyYXRpb24gOiBOYU47XG4gICAgfVxuXG4gICAgc2Vjb25kcyA9IHBhcnNlRmxvYXQoc2Vjb25kcyk7XG5cbiAgICAvLyBTdGFuZGFyZGl6ZSBvbiBJbmZpbml0eSBmb3Igc2lnbmFsaW5nIHZpZGVvIGlzIGxpdmVcbiAgICBpZiAoc2Vjb25kcyA8IDApIHtcbiAgICAgIHNlY29uZHMgPSBJbmZpbml0eTtcbiAgICB9XG5cbiAgICBpZiAoc2Vjb25kcyAhPT0gdGhpcy5jYWNoZV8uZHVyYXRpb24pIHtcbiAgICAgIC8vIENhY2hlIHRoZSBsYXN0IHNldCB2YWx1ZSBmb3Igb3B0aW1pemVkIHNjcnViYmluZyAoZXNwLiBGbGFzaClcbiAgICAgIHRoaXMuY2FjaGVfLmR1cmF0aW9uID0gc2Vjb25kcztcblxuICAgICAgaWYgKHNlY29uZHMgPT09IEluZmluaXR5KSB7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1saXZlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtbGl2ZScpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI2R1cmF0aW9uY2hhbmdlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignZHVyYXRpb25jaGFuZ2UnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgaG93IG11Y2ggdGltZSBpcyBsZWZ0IGluIHRoZSB2aWRlby4gTm90IHBhcnRcbiAgICogb2YgdGhlIG5hdGl2ZSB2aWRlbyBBUEkuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgdGltZSByZW1haW5pbmcgaW4gc2Vjb25kc1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVtYWluaW5nVGltZSA9IGZ1bmN0aW9uIHJlbWFpbmluZ1RpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHVyYXRpb24oKSAtIHRoaXMuY3VycmVudFRpbWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQSByZW1haW5pbmcgdGltZSBmdW5jdGlvbiB0aGF0IGlzIGludGVudGVkIHRvIGJlIHVzZWQgd2hlblxuICAgKiB0aGUgdGltZSBpcyB0byBiZSBkaXNwbGF5ZWQgZGlyZWN0bHkgdG8gdGhlIHVzZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcm91bmRlZCB0aW1lIHJlbWFpbmluZyBpbiBzZWNvbmRzXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZW1haW5pbmdUaW1lRGlzcGxheSA9IGZ1bmN0aW9uIHJlbWFpbmluZ1RpbWVEaXNwbGF5KCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuZHVyYXRpb24oKSkgLSBNYXRoLmZsb29yKHRoaXMuY3VycmVudFRpbWUoKSk7XG4gIH07XG5cbiAgLy9cbiAgLy8gS2luZCBvZiBsaWtlIGFuIGFycmF5IG9mIHBvcnRpb25zIG9mIHRoZSB2aWRlbyB0aGF0IGhhdmUgYmVlbiBkb3dubG9hZGVkLlxuXG4gIC8qKlxuICAgKiBHZXQgYSBUaW1lUmFuZ2Ugb2JqZWN0IHdpdGggYW4gYXJyYXkgb2YgdGhlIHRpbWVzIG9mIHRoZSB2aWRlb1xuICAgKiB0aGF0IGhhdmUgYmVlbiBkb3dubG9hZGVkLiBJZiB5b3UganVzdCB3YW50IHRoZSBwZXJjZW50IG9mIHRoZVxuICAgKiB2aWRlbyB0aGF0J3MgYmVlbiBkb3dubG9hZGVkLCB1c2UgYnVmZmVyZWRQZXJjZW50LlxuICAgKlxuICAgKiBAc2VlIFtCdWZmZXJlZCBTcGVjXXtAbGluayBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL3ZpZGVvLmh0bWwjZG9tLW1lZGlhLWJ1ZmZlcmVkfVxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gICAqICAgICAgICAgQSBtb2NrIFRpbWVSYW5nZSBvYmplY3QgKGZvbGxvd2luZyBIVE1MIHNwZWMpXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5idWZmZXJlZCA9IGZ1bmN0aW9uIGJ1ZmZlcmVkKCkge1xuICAgIHZhciBidWZmZXJlZCA9IHRoaXMudGVjaEdldF8oJ2J1ZmZlcmVkJyk7XG5cbiAgICBpZiAoIWJ1ZmZlcmVkIHx8ICFidWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgIGJ1ZmZlcmVkID0gY3JlYXRlVGltZVJhbmdlcygwLCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGVyY2VudCAoYXMgYSBkZWNpbWFsKSBvZiB0aGUgdmlkZW8gdGhhdCdzIGJlZW4gZG93bmxvYWRlZC5cbiAgICogVGhpcyBtZXRob2QgaXMgbm90IGEgcGFydCBvZiB0aGUgbmF0aXZlIEhUTUwgdmlkZW8gQVBJLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgQSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHBlcmNlbnRcbiAgICogICAgICAgICB0aGF0IGlzIGJ1ZmZlcmVkIDAgYmVpbmcgMCUgYW5kIDEgYmVpbmcgMTAwJVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYnVmZmVyZWRQZXJjZW50ID0gZnVuY3Rpb24gYnVmZmVyZWRQZXJjZW50JCQxKCkge1xuICAgIHJldHVybiBidWZmZXJlZFBlcmNlbnQodGhpcy5idWZmZXJlZCgpLCB0aGlzLmR1cmF0aW9uKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVuZGluZyB0aW1lIG9mIHRoZSBsYXN0IGJ1ZmZlcmVkIHRpbWUgcmFuZ2VcbiAgICogVGhpcyBpcyB1c2VkIGluIHRoZSBwcm9ncmVzcyBiYXIgdG8gZW5jYXBzdWxhdGUgYWxsIHRpbWUgcmFuZ2VzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGVuZCBvZiB0aGUgbGFzdCBidWZmZXJlZCB0aW1lIHJhbmdlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5idWZmZXJlZEVuZCA9IGZ1bmN0aW9uIGJ1ZmZlcmVkRW5kKCkge1xuICAgIHZhciBidWZmZXJlZCA9IHRoaXMuYnVmZmVyZWQoKTtcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKCk7XG4gICAgdmFyIGVuZCA9IGJ1ZmZlcmVkLmVuZChidWZmZXJlZC5sZW5ndGggLSAxKTtcblxuICAgIGlmIChlbmQgPiBkdXJhdGlvbikge1xuICAgICAgZW5kID0gZHVyYXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuZDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgY3VycmVudCB2b2x1bWUgb2YgdGhlIG1lZGlhXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gW3BlcmNlbnRBc0RlY2ltYWxdXG4gICAqICAgICAgICAgVGhlIG5ldyB2b2x1bWUgYXMgYSBkZWNpbWFsIHBlcmNlbnQ6XG4gICAqICAgICAgICAgLSAwIGlzIG11dGVkLzAlL29mZlxuICAgKiAgICAgICAgIC0gMS4wIGlzIDEwMCUvZnVsbFxuICAgKiAgICAgICAgIC0gMC41IGlzIGhhbGYgdm9sdW1lIG9yIDUwJVxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdm9sdW1lIGFzIGEgcGVyY2VudCB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uIHZvbHVtZShwZXJjZW50QXNEZWNpbWFsKSB7XG4gICAgdmFyIHZvbCA9IHZvaWQgMDtcblxuICAgIGlmIChwZXJjZW50QXNEZWNpbWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEZvcmNlIHZhbHVlIHRvIGJldHdlZW4gMCBhbmQgMVxuICAgICAgdm9sID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgcGFyc2VGbG9hdChwZXJjZW50QXNEZWNpbWFsKSkpO1xuICAgICAgdGhpcy5jYWNoZV8udm9sdW1lID0gdm9sO1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFZvbHVtZScsIHZvbCk7XG5cbiAgICAgIGlmICh2b2wgPiAwKSB7XG4gICAgICAgIHRoaXMubGFzdFZvbHVtZV8odm9sKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gMSB3aGVuIHJldHVybmluZyBjdXJyZW50IHZvbHVtZS5cbiAgICB2b2wgPSBwYXJzZUZsb2F0KHRoaXMudGVjaEdldF8oJ3ZvbHVtZScpKTtcbiAgICByZXR1cm4gaXNOYU4odm9sKSA/IDEgOiB2b2w7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBtdXRlZCBzdGF0ZSwgb3IgdHVybiBtdXRlIG9uIG9yIG9mZlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttdXRlZF1cbiAgICogICAgICAgIC0gdHJ1ZSB0byBtdXRlXG4gICAqICAgICAgICAtIGZhbHNlIHRvIHVubXV0ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIC0gdHJ1ZSBpZiBtdXRlIGlzIG9uIGFuZCBnZXR0aW5nXG4gICAqICAgICAgICAgLSBmYWxzZSBpZiBtdXRlIGlzIG9mZiBhbmQgZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubXV0ZWQgPSBmdW5jdGlvbiBtdXRlZChfbXV0ZWQpIHtcbiAgICBpZiAoX211dGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRNdXRlZCcsIF9tdXRlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdtdXRlZCcpIHx8IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgZGVmYXVsdE11dGVkIHN0YXRlLCBvciB0dXJuIGRlZmF1bHRNdXRlZCBvbiBvciBvZmYuIGRlZmF1bHRNdXRlZFxuICAgKiBpbmRpY2F0ZXMgdGhlIHN0YXRlIG9mIG11dGVkIG9uIGluaXRpYWwgcGxheWJhY2suXG4gICAqXG4gICAqIGBgYGpzXG4gICAqICAgdmFyIG15UGxheWVyID0gdmlkZW9qcygnc29tZS1wbGF5ZXItaWQnKTtcbiAgICpcbiAgICogICBteVBsYXllci5zcmMoXCJodHRwOi8vd3d3LmV4YW1wbGUuY29tL3BhdGgvdG8vdmlkZW8ubXA0XCIpO1xuICAgKlxuICAgKiAgIC8vIGdldCwgc2hvdWxkIGJlIGZhbHNlXG4gICAqICAgY29uc29sZS5sb2cobXlQbGF5ZXIuZGVmYXVsdE11dGVkKCkpO1xuICAgKiAgIC8vIHNldCB0byB0cnVlXG4gICAqICAgbXlQbGF5ZXIuZGVmYXVsdE11dGVkKHRydWUpO1xuICAgKiAgIC8vIGdldCBzaG91bGQgYmUgdHJ1ZVxuICAgKiAgIGNvbnNvbGUubG9nKG15UGxheWVyLmRlZmF1bHRNdXRlZCgpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZmF1bHRNdXRlZF1cbiAgICogICAgICAgIC0gdHJ1ZSB0byBtdXRlXG4gICAqICAgICAgICAtIGZhbHNlIHRvIHVubXV0ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufFBsYXllcn1cbiAgICogICAgICAgICAtIHRydWUgaWYgZGVmYXVsdE11dGVkIGlzIG9uIGFuZCBnZXR0aW5nXG4gICAqICAgICAgICAgLSBmYWxzZSBpZiBkZWZhdWx0TXV0ZWQgaXMgb2ZmIGFuZCBnZXR0aW5nXG4gICAqICAgICAgICAgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBwbGF5ZXIgd2hlbiBzZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5kZWZhdWx0TXV0ZWQgPSBmdW5jdGlvbiBkZWZhdWx0TXV0ZWQoX2RlZmF1bHRNdXRlZCkge1xuICAgIGlmIChfZGVmYXVsdE11dGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hDYWxsXygnc2V0RGVmYXVsdE11dGVkJywgX2RlZmF1bHRNdXRlZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdkZWZhdWx0TXV0ZWQnKSB8fCBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBsYXN0IHZvbHVtZSwgb3Igc2V0IGl0XG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gW3BlcmNlbnRBc0RlY2ltYWxdXG4gICAqICAgICAgICAgVGhlIG5ldyBsYXN0IHZvbHVtZSBhcyBhIGRlY2ltYWwgcGVyY2VudDpcbiAgICogICAgICAgICAtIDAgaXMgbXV0ZWQvMCUvb2ZmXG4gICAqICAgICAgICAgLSAxLjAgaXMgMTAwJS9mdWxsXG4gICAqICAgICAgICAgLSAwLjUgaXMgaGFsZiB2b2x1bWUgb3IgNTAlXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICB0aGUgY3VycmVudCB2YWx1ZSBvZiBsYXN0Vm9sdW1lIGFzIGEgcGVyY2VudCB3aGVuIGdldHRpbmdcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxhc3RWb2x1bWVfID0gZnVuY3Rpb24gbGFzdFZvbHVtZV8ocGVyY2VudEFzRGVjaW1hbCkge1xuICAgIGlmIChwZXJjZW50QXNEZWNpbWFsICE9PSB1bmRlZmluZWQgJiYgcGVyY2VudEFzRGVjaW1hbCAhPT0gMCkge1xuICAgICAgdGhpcy5jYWNoZV8ubGFzdFZvbHVtZSA9IHBlcmNlbnRBc0RlY2ltYWw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlXy5sYXN0Vm9sdW1lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBjdXJyZW50IHRlY2ggY2FuIHN1cHBvcnQgbmF0aXZlIGZ1bGxzY3JlZW5cbiAgICogKGUuZy4gd2l0aCBidWlsdCBpbiBjb250cm9scyBsaWtlIGlPUywgc28gbm90IG91ciBmbGFzaCBzd2YpXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgaWYgbmF0aXZlIGZ1bGxzY3JlZW4gaXMgc3VwcG9ydGVkXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5zdXBwb3J0c0Z1bGxTY3JlZW4gPSBmdW5jdGlvbiBzdXBwb3J0c0Z1bGxTY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3N1cHBvcnRzRnVsbFNjcmVlbicpIHx8IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcGxheWVyIGlzIGluIGZ1bGxzY3JlZW4gbW9kZSBvciB0ZWxsIHRoZSBwbGF5ZXIgdGhhdCBpdFxuICAgKiBpcyBvciBpcyBub3QgaW4gZnVsbHNjcmVlbiBtb2RlLlxuICAgKlxuICAgKiA+IE5PVEU6IEFzIG9mIHRoZSBsYXRlc3QgSFRNTDUgc3BlYywgaXNGdWxsc2NyZWVuIGlzIG5vIGxvbmdlciBhbiBvZmZpY2lhbFxuICAgKiBwcm9wZXJ0eSBhbmQgaW5zdGVhZCBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCBpcyB1c2VkLiBCdXQgaXNGdWxsc2NyZWVuIGlzXG4gICAqIHN0aWxsIGEgdmFsdWFibGUgcHJvcGVydHkgZm9yIGludGVybmFsIHBsYXllciB3b3JraW5ncy5cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW2lzRlNdXG4gICAqICAgICAgICAgU2V0IHRoZSBwbGF5ZXJzIGN1cnJlbnQgZnVsbHNjcmVlbiBzdGF0ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIC0gdHJ1ZSBpZiBmdWxsc2NyZWVuIGlzIG9uIGFuZCBnZXR0aW5nXG4gICAqICAgICAgICAgLSBmYWxzZSBpZiBmdWxsc2NyZWVuIGlzIG9mZiBhbmQgZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaXNGdWxsc2NyZWVuID0gZnVuY3Rpb24gaXNGdWxsc2NyZWVuKGlzRlMpIHtcbiAgICBpZiAoaXNGUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmlzRnVsbHNjcmVlbl8gPSAhIWlzRlM7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuaXNGdWxsc2NyZWVuXztcbiAgfTtcblxuICAvKipcbiAgICogSW5jcmVhc2UgdGhlIHNpemUgb2YgdGhlIHZpZGVvIHRvIGZ1bGwgc2NyZWVuXG4gICAqIEluIHNvbWUgYnJvd3NlcnMsIGZ1bGwgc2NyZWVuIGlzIG5vdCBzdXBwb3J0ZWQgbmF0aXZlbHksIHNvIGl0IGVudGVyc1xuICAgKiBcImZ1bGwgd2luZG93IG1vZGVcIiwgd2hlcmUgdGhlIHZpZGVvIGZpbGxzIHRoZSBicm93c2VyIHdpbmRvdy5cbiAgICogSW4gYnJvd3NlcnMgYW5kIGRldmljZXMgdGhhdCBzdXBwb3J0IG5hdGl2ZSBmdWxsIHNjcmVlbiwgc29tZXRpbWVzIHRoZVxuICAgKiBicm93c2VyJ3MgZGVmYXVsdCBjb250cm9scyB3aWxsIGJlIHNob3duLCBhbmQgbm90IHRoZSBWaWRlby5qcyBjdXN0b20gc2tpbi5cbiAgICogVGhpcyBpbmNsdWRlcyBtb3N0IG1vYmlsZSBkZXZpY2VzIChpT1MsIEFuZHJvaWQpIGFuZCBvbGRlciB2ZXJzaW9ucyBvZlxuICAgKiBTYWZhcmkuXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVxdWVzdEZ1bGxzY3JlZW4gPSBmdW5jdGlvbiByZXF1ZXN0RnVsbHNjcmVlbigpIHtcbiAgICB2YXIgZnNBcGkgPSBGdWxsc2NyZWVuQXBpO1xuXG4gICAgdGhpcy5pc0Z1bGxzY3JlZW4odHJ1ZSk7XG5cbiAgICBpZiAoZnNBcGkucmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgIC8vIHRoZSBicm93c2VyIHN1cHBvcnRzIGdvaW5nIGZ1bGxzY3JlZW4gYXQgdGhlIGVsZW1lbnQgbGV2ZWwgc28gd2UgY2FuXG4gICAgICAvLyB0YWtlIHRoZSBjb250cm9scyBmdWxsc2NyZWVuIGFzIHdlbGwgYXMgdGhlIHZpZGVvXG5cbiAgICAgIC8vIFRyaWdnZXIgZnVsbHNjcmVlbmNoYW5nZSBldmVudCBhZnRlciBjaGFuZ2VcbiAgICAgIC8vIFdlIGhhdmUgdG8gc3BlY2lmaWNhbGx5IGFkZCB0aGlzIGVhY2ggdGltZSwgYW5kIHJlbW92ZVxuICAgICAgLy8gd2hlbiBjYW5jZWxpbmcgZnVsbHNjcmVlbi4gT3RoZXJ3aXNlIGlmIHRoZXJlJ3MgbXVsdGlwbGVcbiAgICAgIC8vIHBsYXllcnMgb24gYSBwYWdlLCB0aGV5IHdvdWxkIGFsbCBiZSByZWFjdGluZyB0byB0aGUgc2FtZSBmdWxsc2NyZWVuXG4gICAgICAvLyBldmVudHNcbiAgICAgIG9uKGRvY3VtZW50LCBmc0FwaS5mdWxsc2NyZWVuY2hhbmdlLCBiaW5kKHRoaXMsIGZ1bmN0aW9uIGRvY3VtZW50RnVsbHNjcmVlbkNoYW5nZShlKSB7XG4gICAgICAgIHRoaXMuaXNGdWxsc2NyZWVuKGRvY3VtZW50W2ZzQXBpLmZ1bGxzY3JlZW5FbGVtZW50XSk7XG5cbiAgICAgICAgLy8gSWYgY2FuY2VsbGluZyBmdWxsc2NyZWVuLCByZW1vdmUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICAgIGlmICh0aGlzLmlzRnVsbHNjcmVlbigpID09PSBmYWxzZSkge1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgZnNBcGkuZnVsbHNjcmVlbmNoYW5nZSwgZG9jdW1lbnRGdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgICAgfSkpO1xuXG4gICAgICB0aGlzLmVsX1tmc0FwaS5yZXF1ZXN0RnVsbHNjcmVlbl0oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudGVjaF8uc3VwcG9ydHNGdWxsU2NyZWVuKCkpIHtcbiAgICAgIC8vIHdlIGNhbid0IHRha2UgdGhlIHZpZGVvLmpzIGNvbnRyb2xzIGZ1bGxzY3JlZW4gYnV0IHdlIGNhbiBnbyBmdWxsc2NyZWVuXG4gICAgICAvLyB3aXRoIG5hdGl2ZSBjb250cm9sc1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ2VudGVyRnVsbFNjcmVlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmdWxsc2NyZWVuIGlzbid0IHN1cHBvcnRlZCBzbyB3ZSdsbCBqdXN0IHN0cmV0Y2ggdGhlIHZpZGVvIGVsZW1lbnQgdG9cbiAgICAgIC8vIGZpbGwgdGhlIHZpZXdwb3J0XG4gICAgICB0aGlzLmVudGVyRnVsbFdpbmRvdygpO1xuICAgICAgLyoqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHZpZGVvIHRvIGl0cyBub3JtYWwgc2l6ZSBhZnRlciBoYXZpbmcgYmVlbiBpbiBmdWxsIHNjcmVlbiBtb2RlXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZXhpdEZ1bGxzY3JlZW4gPSBmdW5jdGlvbiBleGl0RnVsbHNjcmVlbigpIHtcbiAgICB2YXIgZnNBcGkgPSBGdWxsc2NyZWVuQXBpO1xuXG4gICAgdGhpcy5pc0Z1bGxzY3JlZW4oZmFsc2UpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGJyb3dzZXIgZWxlbWVudCBmdWxsc2NyZWVuIHN1cHBvcnRcbiAgICBpZiAoZnNBcGkucmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgIGRvY3VtZW50W2ZzQXBpLmV4aXRGdWxsc2NyZWVuXSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50ZWNoXy5zdXBwb3J0c0Z1bGxTY3JlZW4oKSkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ2V4aXRGdWxsU2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhpdEZ1bGxXaW5kb3coKTtcbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiBmdWxsc2NyZWVuIGlzbid0IHN1cHBvcnRlZCB3ZSBjYW4gc3RyZXRjaCB0aGVcbiAgICogdmlkZW8gY29udGFpbmVyIHRvIGFzIHdpZGUgYXMgdGhlIGJyb3dzZXIgd2lsbCBsZXQgdXMuXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZW50ZXJGdWxsV2luZG93XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5lbnRlckZ1bGxXaW5kb3cgPSBmdW5jdGlvbiBlbnRlckZ1bGxXaW5kb3coKSB7XG4gICAgdGhpcy5pc0Z1bGxXaW5kb3cgPSB0cnVlO1xuXG4gICAgLy8gU3RvcmluZyBvcmlnaW5hbCBkb2Mgb3ZlcmZsb3cgdmFsdWUgdG8gcmV0dXJuIHRvIHdoZW4gZnVsbHNjcmVlbiBpcyBvZmZcbiAgICB0aGlzLmRvY09yaWdPdmVyZmxvdyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdztcblxuICAgIC8vIEFkZCBsaXN0ZW5lciBmb3IgZXNjIGtleSB0byBleGl0IGZ1bGxzY3JlZW5cbiAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuZnVsbFdpbmRvd09uRXNjS2V5KSk7XG5cbiAgICAvLyBIaWRlIGFueSBzY3JvbGwgYmFyc1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG4gICAgLy8gQXBwbHkgZnVsbHNjcmVlbiBzdHlsZXNcbiAgICBhZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAndmpzLWZ1bGwtd2luZG93Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgUGxheWVyI2VudGVyRnVsbFdpbmRvd1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2VudGVyRnVsbFdpbmRvdycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBmb3IgY2FsbCB0byBlaXRoZXIgZXhpdCBmdWxsIHdpbmRvdyBvclxuICAgKiBmdWxsIHNjcmVlbiBvbiBFU0Mga2V5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiAgICAgICAgRXZlbnQgdG8gY2hlY2sgZm9yIGtleSBwcmVzc1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZnVsbFdpbmRvd09uRXNjS2V5ID0gZnVuY3Rpb24gZnVsbFdpbmRvd09uRXNjS2V5KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4oKSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4aXRGdWxsV2luZG93KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFeGl0IGZ1bGwgd2luZG93XG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZXhpdEZ1bGxXaW5kb3dcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmV4aXRGdWxsV2luZG93ID0gZnVuY3Rpb24gZXhpdEZ1bGxXaW5kb3coKSB7XG4gICAgdGhpcy5pc0Z1bGxXaW5kb3cgPSBmYWxzZTtcbiAgICBvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5mdWxsV2luZG93T25Fc2NLZXkpO1xuXG4gICAgLy8gVW5oaWRlIHNjcm9sbCBiYXJzLlxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IHRoaXMuZG9jT3JpZ092ZXJmbG93O1xuXG4gICAgLy8gUmVtb3ZlIGZ1bGxzY3JlZW4gc3R5bGVzXG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3Zqcy1mdWxsLXdpbmRvdycpO1xuXG4gICAgLy8gUmVzaXplIHRoZSBib3gsIGNvbnRyb2xsZXIsIGFuZCBwb3N0ZXIgdG8gb3JpZ2luYWwgc2l6ZXNcbiAgICAvLyB0aGlzLnBvc2l0aW9uQWxsKCk7XG4gICAgLyoqXG4gICAgICogQGV2ZW50IFBsYXllciNleGl0RnVsbFdpbmRvd1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2V4aXRGdWxsV2luZG93Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIHBsYXllciBjYW4gcGxheSBhIGdpdmVuIG1pbWV0eXBlXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTAxMTMvdmlkZW8uaHRtbCNkb20tbmF2aWdhdG9yLWNhbnBsYXl0eXBlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2tcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uIGNhblBsYXlUeXBlKHR5cGUpIHtcbiAgICB2YXIgY2FuID0gdm9pZCAwO1xuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggcGxheWJhY2sgdGVjaG5vbG9neSBpbiB0aGUgb3B0aW9ucyBvcmRlclxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5vcHRpb25zXy50ZWNoT3JkZXI7IGkgPCBqLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGVjaE5hbWUgPSBqW2ldO1xuICAgICAgdmFyIHRlY2ggPSBUZWNoLmdldFRlY2godGVjaE5hbWUpO1xuXG4gICAgICAvLyBTdXBwb3J0IG9sZCBiZWhhdmlvciBvZiB0ZWNocyBiZWluZyByZWdpc3RlcmVkIGFzIGNvbXBvbmVudHMuXG4gICAgICAvLyBSZW1vdmUgb25jZSB0aGF0IGRlcHJlY2F0ZWQgYmVoYXZpb3IgaXMgcmVtb3ZlZC5cbiAgICAgIGlmICghdGVjaCkge1xuICAgICAgICB0ZWNoID0gQ29tcG9uZW50LmdldENvbXBvbmVudCh0ZWNoTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHRlY2ggaXMgZGVmaW5lZCBiZWZvcmUgY29udGludWluZ1xuICAgICAgaWYgKCF0ZWNoKSB7XG4gICAgICAgIGxvZyQxLmVycm9yKCdUaGUgXCInICsgdGVjaE5hbWUgKyAnXCIgdGVjaCBpcyB1bmRlZmluZWQuIFNraXBwZWQgYnJvd3NlciBzdXBwb3J0IGNoZWNrIGZvciB0aGF0IHRlY2guJyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGlzIHRlY2hub2xvZ3lcbiAgICAgIGlmICh0ZWNoLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgY2FuID0gdGVjaC5jYW5QbGF5VHlwZSh0eXBlKTtcblxuICAgICAgICBpZiAoY2FuKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogU2VsZWN0IHNvdXJjZSBiYXNlZCBvbiB0ZWNoLW9yZGVyIG9yIHNvdXJjZS1vcmRlclxuICAgKiBVc2VzIHNvdXJjZS1vcmRlciBzZWxlY3Rpb24gaWYgYG9wdGlvbnMuc291cmNlT3JkZXJgIGlzIHRydXRoeS4gT3RoZXJ3aXNlLFxuICAgKiBkZWZhdWx0cyB0byB0ZWNoLW9yZGVyIHNlbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VzXG4gICAqICAgICAgICBUaGUgc291cmNlcyBmb3IgYSBtZWRpYSBhc3NldFxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R8Ym9vbGVhbn1cbiAgICogICAgICAgICBPYmplY3Qgb2Ygc291cmNlIGFuZCB0ZWNoIG9yZGVyIG9yIGZhbHNlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5zZWxlY3RTb3VyY2UgPSBmdW5jdGlvbiBzZWxlY3RTb3VyY2Uoc291cmNlcykge1xuICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgLy8gR2V0IG9ubHkgdGhlIHRlY2hzIHNwZWNpZmllZCBpbiBgdGVjaE9yZGVyYCB0aGF0IGV4aXN0IGFuZCBhcmUgc3VwcG9ydGVkIGJ5IHRoZVxuICAgIC8vIGN1cnJlbnQgcGxhdGZvcm1cbiAgICB2YXIgdGVjaHMgPSB0aGlzLm9wdGlvbnNfLnRlY2hPcmRlci5tYXAoZnVuY3Rpb24gKHRlY2hOYW1lKSB7XG4gICAgICByZXR1cm4gW3RlY2hOYW1lLCBUZWNoLmdldFRlY2godGVjaE5hbWUpXTtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciB0ZWNoTmFtZSA9IF9yZWZbMF0sXG4gICAgICAgICAgdGVjaCA9IF9yZWZbMV07XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHRlY2ggaXMgZGVmaW5lZCBiZWZvcmUgY29udGludWluZ1xuICAgICAgaWYgKHRlY2gpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyB0ZWNobm9sb2d5XG4gICAgICAgIHJldHVybiB0ZWNoLmlzU3VwcG9ydGVkKCk7XG4gICAgICB9XG5cbiAgICAgIGxvZyQxLmVycm9yKCdUaGUgXCInICsgdGVjaE5hbWUgKyAnXCIgdGVjaCBpcyB1bmRlZmluZWQuIFNraXBwZWQgYnJvd3NlciBzdXBwb3J0IGNoZWNrIGZvciB0aGF0IHRlY2guJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZWFjaCBgaW5uZXJBcnJheWAgZWxlbWVudCBvbmNlIHBlciBgb3V0ZXJBcnJheWAgZWxlbWVudCBhbmQgZXhlY3V0ZVxuICAgIC8vIGB0ZXN0ZXJgIHdpdGggYm90aC4gSWYgYHRlc3RlcmAgcmV0dXJucyBhIG5vbi1mYWxzeSB2YWx1ZSwgZXhpdCBlYXJseSBhbmQgcmV0dXJuXG4gICAgLy8gdGhhdCB2YWx1ZS5cbiAgICB2YXIgZmluZEZpcnN0UGFzc2luZ1RlY2hTb3VyY2VQYWlyID0gZnVuY3Rpb24gZmluZEZpcnN0UGFzc2luZ1RlY2hTb3VyY2VQYWlyKG91dGVyQXJyYXksIGlubmVyQXJyYXksIHRlc3Rlcikge1xuICAgICAgdmFyIGZvdW5kID0gdm9pZCAwO1xuXG4gICAgICBvdXRlckFycmF5LnNvbWUoZnVuY3Rpb24gKG91dGVyQ2hvaWNlKSB7XG4gICAgICAgIHJldHVybiBpbm5lckFycmF5LnNvbWUoZnVuY3Rpb24gKGlubmVyQ2hvaWNlKSB7XG4gICAgICAgICAgZm91bmQgPSB0ZXN0ZXIob3V0ZXJDaG9pY2UsIGlubmVyQ2hvaWNlKTtcblxuICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfTtcblxuICAgIHZhciBmb3VuZFNvdXJjZUFuZFRlY2ggPSB2b2lkIDA7XG4gICAgdmFyIGZsaXAgPSBmdW5jdGlvbiBmbGlwKGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGZuKGIsIGEpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBmaW5kZXIgPSBmdW5jdGlvbiBmaW5kZXIoX3JlZjIsIHNvdXJjZSkge1xuICAgICAgdmFyIHRlY2hOYW1lID0gX3JlZjJbMF0sXG4gICAgICAgICAgdGVjaCA9IF9yZWYyWzFdO1xuXG4gICAgICBpZiAodGVjaC5jYW5QbGF5U291cmNlKHNvdXJjZSwgX3RoaXM4Lm9wdGlvbnNfW3RlY2hOYW1lLnRvTG93ZXJDYXNlKCldKSkge1xuICAgICAgICByZXR1cm4geyBzb3VyY2U6IHNvdXJjZSwgdGVjaDogdGVjaE5hbWUgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRGVwZW5kaW5nIG9uIHRoZSB0cnV0aGluZXNzIG9mIGBvcHRpb25zLnNvdXJjZU9yZGVyYCwgd2Ugc3dhcCB0aGUgb3JkZXIgb2YgdGVjaHMgYW5kIHNvdXJjZXNcbiAgICAvLyB0byBzZWxlY3QgZnJvbSB0aGVtIGJhc2VkIG9uIHRoZWlyIHByaW9yaXR5LlxuICAgIGlmICh0aGlzLm9wdGlvbnNfLnNvdXJjZU9yZGVyKSB7XG4gICAgICAvLyBTb3VyY2UtZmlyc3Qgb3JkZXJpbmdcbiAgICAgIGZvdW5kU291cmNlQW5kVGVjaCA9IGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpcihzb3VyY2VzLCB0ZWNocywgZmxpcChmaW5kZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGVjaC1maXJzdCBvcmRlcmluZ1xuICAgICAgZm91bmRTb3VyY2VBbmRUZWNoID0gZmluZEZpcnN0UGFzc2luZ1RlY2hTb3VyY2VQYWlyKHRlY2hzLCBzb3VyY2VzLCBmaW5kZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3VuZFNvdXJjZUFuZFRlY2ggfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIHZpZGVvIHNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdHxUZWNoflNvdXJjZU9iamVjdFtdfHN0cmluZ30gW3NvdXJjZV1cbiAgICogICAgICAgIEEgU291cmNlT2JqZWN0LCBhbiBhcnJheSBvZiBTb3VyY2VPYmplY3RzLCBvciBhIHN0cmluZyByZWZlcmVuY2luZ1xuICAgKiAgICAgICAgYSBVUkwgdG8gYSBtZWRpYSBzb3VyY2UuIEl0IGlzIF9oaWdobHkgcmVjb21tZW5kZWRfIHRoYXQgYW4gb2JqZWN0XG4gICAqICAgICAgICBvciBhcnJheSBvZiBvYmplY3RzIGlzIHVzZWQgaGVyZSwgc28gdGhhdCBzb3VyY2Ugc2VsZWN0aW9uXG4gICAqICAgICAgICBhbGdvcml0aG1zIGNhbiB0YWtlIHRoZSBgdHlwZWAgaW50byBhY2NvdW50LlxuICAgKlxuICAgKiAgICAgICAgSWYgbm90IHByb3ZpZGVkLCB0aGlzIG1ldGhvZCBhY3RzIGFzIGEgZ2V0dGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIElmIHRoZSBgc291cmNlYCBhcmd1bWVudCBpcyBtaXNzaW5nLCByZXR1cm5zIHRoZSBjdXJyZW50IHNvdXJjZVxuICAgKiAgICAgICAgIFVSTC4gT3RoZXJ3aXNlLCByZXR1cm5zIG5vdGhpbmcvdW5kZWZpbmVkLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24gc3JjKHNvdXJjZSkge1xuICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgLy8gZ2V0dGVyIHVzYWdlXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZV8uc3JjIHx8ICcnO1xuICAgIH1cbiAgICAvLyBmaWx0ZXIgb3V0IGludmFsaWQgc291cmNlcyBhbmQgdHVybiBvdXIgc291cmNlIGludG9cbiAgICAvLyBhbiBhcnJheSBvZiBzb3VyY2Ugb2JqZWN0c1xuICAgIHZhciBzb3VyY2VzID0gZmlsdGVyU291cmNlKHNvdXJjZSk7XG5cbiAgICAvLyBpZiBhIHNvdXJjZSB3YXMgcGFzc2VkIGluIHRoZW4gaXQgaXMgaW52YWxpZCBiZWNhdXNlXG4gICAgLy8gaXQgd2FzIGZpbHRlcmVkIHRvIGEgemVybyBsZW5ndGggQXJyYXkuIFNvIHdlIGhhdmUgdG9cbiAgICAvLyBzaG93IGFuIGVycm9yXG4gICAgaWYgKCFzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lcnJvcih7IGNvZGU6IDQsIG1lc3NhZ2U6IHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5ub3RTdXBwb3J0ZWRNZXNzYWdlKSB9KTtcbiAgICAgIH0sIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGludGlhbCBzb3VyY2VzXG4gICAgdGhpcy5jaGFuZ2luZ1NyY18gPSB0cnVlO1xuXG4gICAgdGhpcy5jYWNoZV8uc291cmNlcyA9IHNvdXJjZXM7XG4gICAgdGhpcy51cGRhdGVTb3VyY2VDYWNoZXNfKHNvdXJjZXNbMF0pO1xuXG4gICAgLy8gbWlkZGxld2FyZVNvdXJjZSBpcyB0aGUgc291cmNlIGFmdGVyIGl0IGhhcyBiZWVuIGNoYW5nZWQgYnkgbWlkZGxld2FyZVxuICAgIHNldFNvdXJjZSh0aGlzLCBzb3VyY2VzWzBdLCBmdW5jdGlvbiAobWlkZGxld2FyZVNvdXJjZSwgbXdzKSB7XG4gICAgICBfdGhpczkubWlkZGxld2FyZV8gPSBtd3M7XG5cbiAgICAgIC8vIHNpbmNlIHNvdXJjZVNldCBpcyBhc3luYyB3ZSBoYXZlIHRvIHVwZGF0ZSB0aGUgY2FjaGUgYWdhaW4gYWZ0ZXIgd2Ugc2VsZWN0IGEgc291cmNlIHNpbmNlXG4gICAgICAvLyB0aGUgc291cmNlIHRoYXQgaXMgc2VsZWN0ZWQgY291bGQgYmUgb3V0IG9mIG9yZGVyIGZyb20gdGhlIGNhY2hlIHVwZGF0ZSBhYm92ZSB0aGlzIGNhbGxiYWNrLlxuICAgICAgX3RoaXM5LmNhY2hlXy5zb3VyY2VzID0gc291cmNlcztcbiAgICAgIF90aGlzOS51cGRhdGVTb3VyY2VDYWNoZXNfKG1pZGRsZXdhcmVTb3VyY2UpO1xuXG4gICAgICB2YXIgZXJyID0gX3RoaXM5LnNyY18obWlkZGxld2FyZVNvdXJjZSk7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKHNvdXJjZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczkuc3JjKHNvdXJjZXMuc2xpY2UoMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM5LmNoYW5naW5nU3JjXyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIGEgdGltZW91dCB0byBnaXZlIGZvbGtzIGEgY2hhbmNlIHRvIGFkZCBlcnJvciBldmVudCBoYW5kbGVyc1xuICAgICAgICBfdGhpczkuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcih7IGNvZGU6IDQsIG1lc3NhZ2U6IHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5ub3RTdXBwb3J0ZWRNZXNzYWdlKSB9KTtcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgLy8gd2UgY291bGQgbm90IGZpbmQgYW4gYXBwcm9wcmlhdGUgdGVjaCwgYnV0IGxldCdzIHN0aWxsIG5vdGlmeSB0aGUgZGVsZWdhdGUgdGhhdCB0aGlzIGlzIGl0XG4gICAgICAgIC8vIHRoaXMgbmVlZHMgYSBiZXR0ZXIgY29tbWVudCBhYm91dCB3aHkgdGhpcyBpcyBuZWVkZWRcbiAgICAgICAgX3RoaXM5LnRyaWdnZXJSZWFkeSgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2V0VGVjaChtd3MsIF90aGlzOS50ZWNoXyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIG9iamVjdCBvbiB0aGUgdGVjaCwgcmV0dXJucyBhIGJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgd2hldGhlclxuICAgKiB0aGVyZSBpcyBhIHRlY2ggdGhhdCBjYW4gcGxheSB0aGUgc291cmNlIG9yIG5vdFxuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0IHRvIHNldCBvbiB0aGUgVGVjaFxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGVyZSBpcyBubyBUZWNoIHRvIHBsYXliYWNrIHRoaXMgc291cmNlXG4gICAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnNyY18gPSBmdW5jdGlvbiBzcmNfKHNvdXJjZSkge1xuICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgIHZhciBzb3VyY2VUZWNoID0gdGhpcy5zZWxlY3RTb3VyY2UoW3NvdXJjZV0pO1xuXG4gICAgaWYgKCFzb3VyY2VUZWNoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRpdGxlQ2FzZUVxdWFscyhzb3VyY2VUZWNoLnRlY2gsIHRoaXMudGVjaE5hbWVfKSkge1xuICAgICAgdGhpcy5jaGFuZ2luZ1NyY18gPSB0cnVlO1xuICAgICAgLy8gbG9hZCB0aGlzIHRlY2hub2xvZ3kgd2l0aCB0aGUgY2hvc2VuIHNvdXJjZVxuICAgICAgdGhpcy5sb2FkVGVjaF8oc291cmNlVGVjaC50ZWNoLCBzb3VyY2VUZWNoLnNvdXJjZSk7XG4gICAgICB0aGlzLnRlY2hfLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMxMC5jaGFuZ2luZ1NyY18gPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHdhaXQgdW50aWwgdGhlIHRlY2ggaXMgcmVhZHkgdG8gc2V0IHRoZSBzb3VyY2VcbiAgICAvLyBhbmQgc2V0IGl0IHN5bmNocm9ub3VzbHkgaWYgcG9zc2libGUgKCMyMzI2KVxuICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBUaGUgc2V0U291cmNlIHRlY2ggbWV0aG9kIHdhcyBhZGRlZCB3aXRoIHNvdXJjZSBoYW5kbGVyc1xuICAgICAgLy8gc28gb2xkZXIgdGVjaHMgd29uJ3Qgc3VwcG9ydCBpdFxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayB0aGUgZGlyZWN0IHByb3RvdHlwZSBmb3IgdGhlIGNhc2Ugd2hlcmUgc3ViY2xhc3Nlc1xuICAgICAgLy8gb2YgdGhlIHRlY2ggZG8gbm90IHN1cHBvcnQgc291cmNlIGhhbmRsZXJzXG4gICAgICBpZiAodGhpcy50ZWNoXy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3NldFNvdXJjZScpKSB7XG4gICAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRTb3VyY2UnLCBzb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NyYycsIHNvdXJjZS5zcmMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoYW5naW5nU3JjXyA9IGZhbHNlO1xuICAgIH0sIHRydWUpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCZWdpbiBsb2FkaW5nIHRoZSBzcmMgZGF0YS5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkKCkge1xuICAgIHRoaXMudGVjaENhbGxfKCdsb2FkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBwbGF5ZXIuIExvYWRzIHRoZSBmaXJzdCB0ZWNoIGluIHRoZSB0ZWNoT3JkZXIsXG4gICAqIGFuZCBjYWxscyBgcmVzZXRgIG9uIHRoZSB0ZWNoYC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5sb2FkVGVjaF8odGhpcy5vcHRpb25zXy50ZWNoT3JkZXJbMF0sIG51bGwpO1xuICAgIHRoaXMudGVjaENhbGxfKCdyZXNldCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBvZiB0aGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0cy5cbiAgICpcbiAgICogQHJldHVybiB7VGVjaH5Tb3VyY2VPYmplY3RbXX1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0c1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudFNvdXJjZXMgPSBmdW5jdGlvbiBjdXJyZW50U291cmNlcygpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcy5jdXJyZW50U291cmNlKCk7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcblxuICAgIC8vIGFzc3VtZSBge31gIG9yIGB7IHNyYyB9YFxuICAgIGlmIChPYmplY3Qua2V5cyhzb3VyY2UpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfLnNvdXJjZXMgfHwgc291cmNlcztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50U291cmNlID0gZnVuY3Rpb24gY3VycmVudFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZV8uc291cmNlIHx8IHt9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmdWxseSBxdWFsaWZpZWQgVVJMIG9mIHRoZSBjdXJyZW50IHNvdXJjZSB2YWx1ZSBlLmcuIGh0dHA6Ly9teXNpdGUuY29tL3ZpZGVvLm1wNFxuICAgKiBDYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBjdXJyZW50VHlwZWAgdG8gYXNzaXN0IGluIHJlYnVpbGRpbmcgdGhlIGN1cnJlbnQgc291cmNlIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHNvdXJjZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudFNyYyA9IGZ1bmN0aW9uIGN1cnJlbnRTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNvdXJjZSgpICYmIHRoaXMuY3VycmVudFNvdXJjZSgpLnNyYyB8fCAnJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHNvdXJjZSB0eXBlIGUuZy4gdmlkZW8vbXA0XG4gICAqIFRoaXMgY2FuIGFsbG93IHlvdSByZWJ1aWxkIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3Qgc28gdGhhdCB5b3UgY291bGQgbG9hZCB0aGUgc2FtZVxuICAgKiBzb3VyY2UgYW5kIHRlY2ggbGF0ZXJcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBzb3VyY2UgTUlNRSB0eXBlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50VHlwZSA9IGZ1bmN0aW9uIGN1cnJlbnRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTb3VyY2UoKSAmJiB0aGlzLmN1cnJlbnRTb3VyY2UoKS50eXBlIHx8ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBwcmVsb2FkIGF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgIC0gdHJ1ZSBtZWFucyB0aGF0IHdlIHNob3VsZCBwcmVsb2FkXG4gICAqICAgICAgICAtIGZhbHNlIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBwcmVsb2FkXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgcHJlbG9hZCBhdHRyaWJ1dGUgdmFsdWUgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gcHJlbG9hZCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0UHJlbG9hZCcsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc18ucHJlbG9hZCA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygncHJlbG9hZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBhdXRvcGxheSBvcHRpb24uIFdoZW4gdGhpcyBpcyBhIGJvb2xlYW4gaXQgd2lsbFxuICAgKiBtb2RpZnkgdGhlIGF0dHJpYnV0ZSBvbiB0aGUgdGVjaC4gV2hlbiB0aGlzIGlzIGEgc3RyaW5nIHRoZSBhdHRyaWJ1dGUgb25cbiAgICogdGhlIHRlY2ggd2lsbCBiZSByZW1vdmVkIGFuZCBgUGxheWVyYCB3aWxsIGhhbmRsZSBhdXRvcGxheSBvbiBsb2Fkc3RhcnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfSBbdmFsdWVdXG4gICAqICAgICAgICAtIHRydWU6IGF1dG9wbGF5IHVzaW5nIHRoZSBicm93c2VyIGJlaGF2aW9yXG4gICAqICAgICAgICAtIGZhbHNlOiBkbyBub3QgYXV0b3BsYXlcbiAgICogICAgICAgIC0gJ3BsYXknOiBjYWxsIHBsYXkoKSBvbiBldmVyeSBsb2Fkc3RhcnRcbiAgICogICAgICAgIC0gJ211dGVkJzogY2FsbCBtdXRlZCgpIHRoZW4gcGxheSgpIG9uIGV2ZXJ5IGxvYWRzdGFydFxuICAgKiAgICAgICAgLSAnYW55JzogY2FsbCBwbGF5KCkgb24gZXZlcnkgbG9hZHN0YXJ0LiBpZiB0aGF0IGZhaWxzIGNhbGwgbXV0ZWQoKSB0aGVuIHBsYXkoKS5cbiAgICogICAgICAgIC0gKjogdmFsdWVzIG90aGVyIHRoYW4gdGhvc2UgbGlzdGVkIGhlcmUgd2lsbCBiZSBzZXQgYGF1dG9wbGF5YCB0byB0cnVlXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW58c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGF1dG9wbGF5IHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYXV0b3BsYXkgPSBmdW5jdGlvbiBhdXRvcGxheSh2YWx1ZSkge1xuICAgIC8vIGdldHRlciB1c2FnZVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zXy5hdXRvcGxheSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdGVjaEF1dG9wbGF5ID0gdm9pZCAwO1xuXG4gICAgLy8gaWYgdGhlIHZhbHVlIGlzIGEgdmFsaWQgc3RyaW5nIHNldCBpdCB0byB0aGF0XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgLyhhbnl8cGxheXxtdXRlZCkvLnRlc3QodmFsdWUpKSB7XG4gICAgICB0aGlzLm9wdGlvbnNfLmF1dG9wbGF5ID0gdmFsdWU7XG4gICAgICB0aGlzLm1hbnVhbEF1dG9wbGF5Xyh2YWx1ZSk7XG4gICAgICB0ZWNoQXV0b3BsYXkgPSBmYWxzZTtcblxuICAgICAgLy8gYW55IGZhbHN5IHZhbHVlIHNldHMgYXV0b3BsYXkgdG8gZmFsc2UgaW4gdGhlIGJyb3dzZXIsXG4gICAgICAvLyBsZXRzIGRvIHRoZSBzYW1lXG4gICAgfSBlbHNlIGlmICghdmFsdWUpIHtcbiAgICAgIHRoaXMub3B0aW9uc18uYXV0b3BsYXkgPSBmYWxzZTtcblxuICAgICAgLy8gYW55IG90aGVyIHZhbHVlIChpZSB0cnV0aHkpIHNldHMgYXV0b3BsYXkgdG8gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnNfLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0ZWNoQXV0b3BsYXkgPSB0ZWNoQXV0b3BsYXkgfHwgdGhpcy5vcHRpb25zXy5hdXRvcGxheTtcblxuICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYSB0ZWNoIHRoZW4gd2UgZG8gbm90IHF1ZXVlIHVwXG4gICAgLy8gYSBzZXRBdXRvcGxheSBjYWxsIG9uIHRlY2ggcmVhZHkuIFdlIGRvIHRoaXMgYmVjYXVzZSB0aGVcbiAgICAvLyBhdXRvcGxheSBvcHRpb24gd2lsbCBiZSBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGFuZCB3ZVxuICAgIC8vIGRvIG5vdCBuZWVkIHRvIHNldCBpdCB0d2ljZVxuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0QXV0b3BsYXknLCB0ZWNoQXV0b3BsYXkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IG9yIHVuc2V0IHRoZSBwbGF5c2lubGluZSBhdHRyaWJ1dGUuXG4gICAqIFBsYXlzaW5saW5lIHRlbGxzIHRoZSBicm93c2VyIHRoYXQgbm9uLWZ1bGxzY3JlZW4gcGxheWJhY2sgaXMgcHJlZmVycmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgIC0gdHJ1ZSBtZWFucyB0aGF0IHdlIHNob3VsZCB0cnkgdG8gcGxheSBpbmxpbmUgYnkgZGVmYXVsdFxuICAgKiAgICAgICAgLSBmYWxzZSBtZWFucyB0aGF0IHdlIHNob3VsZCB1c2UgdGhlIGJyb3dzZXIncyBkZWZhdWx0IHBsYXliYWNrIG1vZGUsXG4gICAqICAgICAgICAgIHdoaWNoIGluIG1vc3QgY2FzZXMgaXMgaW5saW5lLiBpT1MgU2FmYXJpIGlzIGEgbm90YWJsZSBleGNlcHRpb25cbiAgICogICAgICAgICAgYW5kIHBsYXlzIGZ1bGxzY3JlZW4gYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfFBsYXllcn1cbiAgICogICAgICAgICAtIHRoZSBjdXJyZW50IHZhbHVlIG9mIHBsYXlzaW5saW5lXG4gICAqICAgICAgICAgLSB0aGUgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKlxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNhdHRyLXZpZGVvLXBsYXlzaW5saW5lfVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGxheXNpbmxpbmUgPSBmdW5jdGlvbiBwbGF5c2lubGluZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0UGxheXNpbmxpbmUnLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfLnBsYXlzaW5saW5lID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BsYXlzaW5saW5lJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGxvb3AgYXR0cmlidXRlIG9uIHRoZSB2aWRlbyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgIC0gdHJ1ZSBtZWFucyB0aGF0IHdlIHNob3VsZCBsb29wIHRoZSB2aWRlb1xuICAgKiAgICAgICAgLSBmYWxzZSBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbG9vcCB0aGUgdmlkZW9cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGxvb3Agd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sb29wID0gZnVuY3Rpb24gbG9vcCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0TG9vcCcsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc18ubG9vcCA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnbG9vcCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBwb3N0ZXIgaW1hZ2Ugc291cmNlIHVybFxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3Bvc3RlcmNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NyY11cbiAgICogICAgICAgIFBvc3RlciBpbWFnZSBzb3VyY2UgVVJMXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBwb3N0ZXIgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wb3N0ZXIgPSBmdW5jdGlvbiBwb3N0ZXIoc3JjKSB7XG4gICAgaWYgKHNyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3N0ZXJfO1xuICAgIH1cblxuICAgIC8vIFRoZSBjb3JyZWN0IHdheSB0byByZW1vdmUgYSBwb3N0ZXIgaXMgdG8gc2V0IGFzIGFuIGVtcHR5IHN0cmluZ1xuICAgIC8vIG90aGVyIGZhbHNleSB2YWx1ZXMgd2lsbCB0aHJvdyBlcnJvcnNcbiAgICBpZiAoIXNyYykge1xuICAgICAgc3JjID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHNyYyA9PT0gdGhpcy5wb3N0ZXJfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRoZSBpbnRlcm5hbCBwb3N0ZXIgdmFyaWFibGVcbiAgICB0aGlzLnBvc3Rlcl8gPSBzcmM7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHRlY2gncyBwb3N0ZXJcbiAgICB0aGlzLnRlY2hDYWxsXygnc2V0UG9zdGVyJywgc3JjKTtcblxuICAgIHRoaXMuaXNQb3N0ZXJGcm9tVGVjaF8gPSBmYWxzZTtcblxuICAgIC8vIGFsZXJ0IGNvbXBvbmVudHMgdGhhdCB0aGUgcG9zdGVyIGhhcyBiZWVuIHNldFxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgZmlyZXMgd2hlbiB0aGUgcG9zdGVyIGltYWdlIGlzIGNoYW5nZWQgb24gdGhlIHBsYXllci5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcG9zdGVyY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcigncG9zdGVyY2hhbmdlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNvbWUgdGVjaHMgKGUuZy4gWW91VHViZSkgY2FuIHByb3ZpZGUgYSBwb3N0ZXIgc291cmNlIGluIGFuXG4gICAqIGFzeW5jaHJvbm91cyB3YXkuIFdlIHdhbnQgdGhlIHBvc3RlciBjb21wb25lbnQgdG8gdXNlIHRoaXNcbiAgICogcG9zdGVyIHNvdXJjZSBzbyB0aGF0IGl0IGNvdmVycyB1cCB0aGUgdGVjaCdzIGNvbnRyb2xzLlxuICAgKiAoWW91VHViZSdzIHBsYXkgYnV0dG9uKS4gSG93ZXZlciB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXNcbiAgICogc291cmNlIGlmIHRoZSBwbGF5ZXIgdXNlciBoYXNuJ3Qgc2V0IGEgcG9zdGVyIHRocm91Z2hcbiAgICogdGhlIG5vcm1hbCBBUElzLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3Bvc3RlcmNoYW5nZVxuICAgKiBAbGlzdGVucyBUZWNoI3Bvc3RlcmNoYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUG9zdGVyQ2hhbmdlXygpIHtcbiAgICBpZiAoKCF0aGlzLnBvc3Rlcl8gfHwgdGhpcy5vcHRpb25zXy50ZWNoQ2FuT3ZlcnJpZGVQb3N0ZXIpICYmIHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy5wb3N0ZXIpIHtcbiAgICAgIHZhciBuZXdQb3N0ZXIgPSB0aGlzLnRlY2hfLnBvc3RlcigpIHx8ICcnO1xuXG4gICAgICBpZiAobmV3UG9zdGVyICE9PSB0aGlzLnBvc3Rlcl8pIHtcbiAgICAgICAgdGhpcy5wb3N0ZXJfID0gbmV3UG9zdGVyO1xuICAgICAgICB0aGlzLmlzUG9zdGVyRnJvbVRlY2hfID0gdHJ1ZTtcblxuICAgICAgICAvLyBMZXQgY29tcG9uZW50cyBrbm93IHRoZSBwb3N0ZXIgaGFzIGNoYW5nZWRcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwb3N0ZXJjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgd2hldGhlciBvciBub3QgdGhlIGNvbnRyb2xzIGFyZSBzaG93aW5nLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2NvbnRyb2xzZW5hYmxlZFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib29sXVxuICAgKiAgICAgICAgLSB0cnVlIHRvIHR1cm4gY29udHJvbHMgb25cbiAgICogICAgICAgIC0gZmFsc2UgdG8gdHVybiBjb250cm9scyBvZmZcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBjb250cm9scyB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmNvbnRyb2xzID0gZnVuY3Rpb24gY29udHJvbHMoYm9vbCkge1xuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuY29udHJvbHNfO1xuICAgIH1cblxuICAgIGJvb2wgPSAhIWJvb2w7XG5cbiAgICAvLyBEb24ndCB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IHVubGVzcyBpdCBhY3R1YWxseSBjaGFuZ2VkXG4gICAgaWYgKHRoaXMuY29udHJvbHNfID09PSBib29sKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sc18gPSBib29sO1xuXG4gICAgaWYgKHRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0Q29udHJvbHMnLCBib29sKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb250cm9sc18pIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1jb250cm9scy1kaXNhYmxlZCcpO1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWVuYWJsZWQnKTtcbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciNjb250cm9sc2VuYWJsZWRcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdjb250cm9sc2VuYWJsZWQnKTtcbiAgICAgIGlmICghdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKCkpIHtcbiAgICAgICAgdGhpcy5hZGRUZWNoQ29udHJvbHNMaXN0ZW5lcnNfKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1jb250cm9scy1lbmFibGVkJyk7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZGlzYWJsZWQnKTtcbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciNjb250cm9sc2Rpc2FibGVkXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignY29udHJvbHNkaXNhYmxlZCcpO1xuICAgICAgaWYgKCF0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHMoKSkge1xuICAgICAgICB0aGlzLnJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSBuYXRpdmUgY29udHJvbHMgb24vb2ZmLiBOYXRpdmUgY29udHJvbHMgYXJlIHRoZSBjb250cm9scyBidWlsdCBpbnRvXG4gICAqIGRldmljZXMgKGUuZy4gZGVmYXVsdCBpUGhvbmUgY29udHJvbHMpLCBGbGFzaCwgb3Igb3RoZXIgdGVjaHNcbiAgICogKGUuZy4gVmltZW8gQ29udHJvbHMpXG4gICAqICoqVGhpcyBzaG91bGQgb25seSBiZSBzZXQgYnkgdGhlIGN1cnJlbnQgdGVjaCwgYmVjYXVzZSBvbmx5IHRoZSB0ZWNoIGtub3dzXG4gICAqIGlmIGl0IGNhbiBzdXBwb3J0IG5hdGl2ZSBjb250cm9scyoqXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjdXNpbmduYXRpdmVjb250cm9sc1xuICAgKiBAZmlyZXMgUGxheWVyI3VzaW5nY3VzdG9tY29udHJvbHNcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cbiAgICogICAgICAgIC0gdHJ1ZSB0byB0dXJuIG5hdGl2ZSBjb250cm9scyBvblxuICAgKiAgICAgICAgLSBmYWxzZSB0byB0dXJuIG5hdGl2ZSBjb250cm9scyBvZmZcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBuYXRpdmUgY29udHJvbHMgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS51c2luZ05hdGl2ZUNvbnRyb2xzID0gZnVuY3Rpb24gdXNpbmdOYXRpdmVDb250cm9scyhib29sKSB7XG4gICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICEhdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzXztcbiAgICB9XG5cbiAgICBib29sID0gISFib29sO1xuXG4gICAgLy8gRG9uJ3QgdHJpZ2dlciBhIGNoYW5nZSBldmVudCB1bmxlc3MgaXQgYWN0dWFsbHkgY2hhbmdlZFxuICAgIGlmICh0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHNfID09PSBib29sKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzXyA9IGJvb2w7XG5cbiAgICBpZiAodGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzXykge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXVzaW5nLW5hdGl2ZS1jb250cm9scycpO1xuXG4gICAgICAvKipcbiAgICAgICAqIHBsYXllciBpcyB1c2luZyB0aGUgbmF0aXZlIGRldmljZSBjb250cm9sc1xuICAgICAgICpcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjdXNpbmduYXRpdmVjb250cm9sc1xuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ3VzaW5nbmF0aXZlY29udHJvbHMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXVzaW5nLW5hdGl2ZS1jb250cm9scycpO1xuXG4gICAgICAvKipcbiAgICAgICAqIHBsYXllciBpcyB1c2luZyB0aGUgY3VzdG9tIEhUTUwgY29udHJvbHNcbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI3VzaW5nY3VzdG9tY29udHJvbHNcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCd1c2luZ2N1c3RvbWNvbnRyb2xzJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgb3IgZ2V0IHRoZSBjdXJyZW50IE1lZGlhRXJyb3JcbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNlcnJvclxuICAgKlxuICAgKiBAcGFyYW0gIHtNZWRpYUVycm9yfHN0cmluZ3xudW1iZXJ9IFtlcnJdXG4gICAqICAgICAgICAgQSBNZWRpYUVycm9yIG9yIGEgc3RyaW5nL251bWJlciB0byBiZSB0dXJuZWRcbiAgICogICAgICAgICBpbnRvIGEgTWVkaWFFcnJvclxuICAgKlxuICAgKiBAcmV0dXJuIHtNZWRpYUVycm9yfG51bGx9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgTWVkaWFFcnJvciB3aGVuIGdldHRpbmcgKG9yIG51bGwpXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgIGlmIChlcnIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXJyb3JfIHx8IG51bGw7XG4gICAgfVxuXG4gICAgLy8gcmVzdG9yaW5nIHRvIGRlZmF1bHRcbiAgICBpZiAoZXJyID09PSBudWxsKSB7XG4gICAgICB0aGlzLmVycm9yXyA9IGVycjtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lcnJvcicpO1xuICAgICAgaWYgKHRoaXMuZXJyb3JEaXNwbGF5KSB7XG4gICAgICAgIHRoaXMuZXJyb3JEaXNwbGF5LmNsb3NlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5lcnJvcl8gPSBuZXcgTWVkaWFFcnJvcihlcnIpO1xuXG4gICAgLy8gYWRkIHRoZSB2anMtZXJyb3IgY2xhc3NuYW1lIHRvIHRoZSBwbGF5ZXJcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtZXJyb3InKTtcblxuICAgIC8vIGxvZyB0aGUgbmFtZSBvZiB0aGUgZXJyb3IgdHlwZSBhbmQgYW55IG1lc3NhZ2VcbiAgICAvLyBJRTExIGxvZ3MgXCJbb2JqZWN0IG9iamVjdF1cIiBhbmQgcmVxdWlyZWQgeW91IHRvIGV4cGFuZCBtZXNzYWdlIHRvIHNlZSBlcnJvciBvYmplY3RcbiAgICBsb2ckMS5lcnJvcignKENPREU6JyArIHRoaXMuZXJyb3JfLmNvZGUgKyAnICcgKyBNZWRpYUVycm9yLmVycm9yVHlwZXNbdGhpcy5lcnJvcl8uY29kZV0gKyAnKScsIHRoaXMuZXJyb3JfLm1lc3NhZ2UsIHRoaXMuZXJyb3JfKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZXJyb3JcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdlcnJvcicpO1xuXG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBvcnQgdXNlciBhY3Rpdml0eVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICAgICAgIEV2ZW50IG9iamVjdFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVwb3J0VXNlckFjdGl2aXR5ID0gZnVuY3Rpb24gcmVwb3J0VXNlckFjdGl2aXR5KGV2ZW50KSB7XG4gICAgdGhpcy51c2VyQWN0aXZpdHlfID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCBpZiB1c2VyIGlzIGFjdGl2ZVxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3VzZXJhY3RpdmVcbiAgICogQGZpcmVzIFBsYXllciN1c2VyaW5hY3RpdmVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cbiAgICogICAgICAgIC0gdHJ1ZSBpZiB0aGUgdXNlciBpcyBhY3RpdmVcbiAgICogICAgICAgIC0gZmFsc2UgaWYgdGhlIHVzZXIgaXMgaW5hY3RpdmVcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiB1c2VyQWN0aXZlIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudXNlckFjdGl2ZSA9IGZ1bmN0aW9uIHVzZXJBY3RpdmUoYm9vbCkge1xuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnVzZXJBY3RpdmVfO1xuICAgIH1cblxuICAgIGJvb2wgPSAhIWJvb2w7XG5cbiAgICBpZiAoYm9vbCA9PT0gdGhpcy51c2VyQWN0aXZlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudXNlckFjdGl2ZV8gPSBib29sO1xuXG4gICAgaWYgKHRoaXMudXNlckFjdGl2ZV8pIHtcbiAgICAgIHRoaXMudXNlckFjdGl2aXR5XyA9IHRydWU7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtdXNlci1pbmFjdGl2ZScpO1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXVzZXItYWN0aXZlJyk7XG4gICAgICAvKipcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjdXNlcmFjdGl2ZVxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ3VzZXJhY3RpdmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaHJvbWUvU2FmYXJpL0lFIGhhdmUgYnVncyB3aGVyZSB3aGVuIHlvdSBjaGFuZ2UgdGhlIGN1cnNvciBpdCBjYW5cbiAgICAvLyB0cmlnZ2VyIGEgbW91c2Vtb3ZlIGV2ZW50LiBUaGlzIGNhdXNlcyBhbiBpc3N1ZSB3aGVuIHlvdSdyZSBoaWRpbmdcbiAgICAvLyB0aGUgY3Vyc29yIHdoZW4gdGhlIHVzZXIgaXMgaW5hY3RpdmUsIGFuZCBhIG1vdXNlbW92ZSBzaWduYWxzIHVzZXJcbiAgICAvLyBhY3Rpdml0eS4gTWFraW5nIGl0IGltcG9zc2libGUgdG8gZ28gaW50byBpbmFjdGl2ZSBtb2RlLiBTcGVjaWZpY2FsbHlcbiAgICAvLyB0aGlzIGhhcHBlbnMgaW4gZnVsbHNjcmVlbiB3aGVuIHdlIHJlYWxseSBuZWVkIHRvIGhpZGUgdGhlIGN1cnNvci5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhpcyBnZXRzIHJlc29sdmVkIGluIEFMTCBicm93c2VycyBpdCBjYW4gYmUgcmVtb3ZlZFxuICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDMwNDFcbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgdGhpcy50ZWNoXy5vbmUoJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMudXNlckFjdGl2aXR5XyA9IGZhbHNlO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2VyLWFjdGl2ZScpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy11c2VyLWluYWN0aXZlJyk7XG4gICAgLyoqXG4gICAgICogQGV2ZW50IFBsYXllciN1c2VyaW5hY3RpdmVcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCd1c2VyaW5hY3RpdmUnKTtcbiAgfTtcblxuICAvKipcbiAgICogTGlzdGVuIGZvciB1c2VyIGFjdGl2aXR5IGJhc2VkIG9uIHRpbWVvdXQgdmFsdWVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxpc3RlbkZvclVzZXJBY3Rpdml0eV8gPSBmdW5jdGlvbiBsaXN0ZW5Gb3JVc2VyQWN0aXZpdHlfKCkge1xuICAgIHZhciBtb3VzZUluUHJvZ3Jlc3MgPSB2b2lkIDA7XG4gICAgdmFyIGxhc3RNb3ZlWCA9IHZvaWQgMDtcbiAgICB2YXIgbGFzdE1vdmVZID0gdm9pZCAwO1xuICAgIHZhciBoYW5kbGVBY3Rpdml0eSA9IGJpbmQodGhpcywgdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHkpO1xuXG4gICAgdmFyIGhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShlKSB7XG4gICAgICAvLyAjMTA2OCAtIFByZXZlbnQgbW91c2Vtb3ZlIHNwYW1taW5nXG4gICAgICAvLyBDaHJvbWUgQnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzY2OTcwXG4gICAgICBpZiAoZS5zY3JlZW5YICE9PSBsYXN0TW92ZVggfHwgZS5zY3JlZW5ZICE9PSBsYXN0TW92ZVkpIHtcbiAgICAgICAgbGFzdE1vdmVYID0gZS5zY3JlZW5YO1xuICAgICAgICBsYXN0TW92ZVkgPSBlLnNjcmVlblk7XG4gICAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBoYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oKSB7XG4gICAgICBoYW5kbGVBY3Rpdml0eSgpO1xuICAgICAgLy8gRm9yIGFzIGxvbmcgYXMgdGhlIHRoZXkgYXJlIHRvdWNoaW5nIHRoZSBkZXZpY2Ugb3IgaGF2ZSB0aGVpciBtb3VzZSBkb3duLFxuICAgICAgLy8gd2UgY29uc2lkZXIgdGhlbSBhY3RpdmUgZXZlbiBpZiB0aGV5J3JlIG5vdCBtb3ZpbmcgdGhlaXIgZmluZ2VyIG9yIG1vdXNlLlxuICAgICAgLy8gU28gd2Ugd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgdGhhdCB0aGV5IGFyZSBhY3RpdmVcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbChtb3VzZUluUHJvZ3Jlc3MpO1xuICAgICAgLy8gU2V0dGluZyB1c2VyQWN0aXZpdHk9dHJ1ZSBub3cgYW5kIHNldHRpbmcgdGhlIGludGVydmFsIHRvIHRoZSBzYW1lIHRpbWVcbiAgICAgIC8vIGFzIHRoZSBhY3Rpdml0eUNoZWNrIGludGVydmFsICgyNTApIHNob3VsZCBlbnN1cmUgd2UgbmV2ZXIgbWlzcyB0aGVcbiAgICAgIC8vIG5leHQgYWN0aXZpdHlDaGVja1xuICAgICAgbW91c2VJblByb2dyZXNzID0gdGhpcy5zZXRJbnRlcnZhbChoYW5kbGVBY3Rpdml0eSwgMjUwKTtcbiAgICB9O1xuXG4gICAgdmFyIGhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgICBoYW5kbGVBY3Rpdml0eSgpO1xuICAgICAgLy8gU3RvcCB0aGUgaW50ZXJ2YWwgdGhhdCBtYWludGFpbnMgYWN0aXZpdHkgaWYgdGhlIG1vdXNlL3RvdWNoIGlzIGRvd25cbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbChtb3VzZUluUHJvZ3Jlc3MpO1xuICAgIH07XG5cbiAgICAvLyBBbnkgbW91c2UgbW92ZW1lbnQgd2lsbCBiZSBjb25zaWRlcmVkIHVzZXIgYWN0aXZpdHlcbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCBoYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub24oJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vbignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXApO1xuXG4gICAgLy8gTGlzdGVuIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uXG4gICAgLy8gU2hvdWxkbid0IG5lZWQgdG8gdXNlIGluUHJvZ3Jlc3MgaW50ZXJ2YWwgYmVjYXVzZSBvZiBrZXkgcmVwZWF0XG4gICAgdGhpcy5vbigna2V5ZG93bicsIGhhbmRsZUFjdGl2aXR5KTtcbiAgICB0aGlzLm9uKCdrZXl1cCcsIGhhbmRsZUFjdGl2aXR5KTtcblxuICAgIC8vIFJ1biBhbiBpbnRlcnZhbCBldmVyeSAyNTAgbWlsbGlzZWNvbmRzIGluc3RlYWQgb2Ygc3R1ZmZpbmcgZXZlcnl0aGluZyBpbnRvXG4gICAgLy8gdGhlIG1vdXNlbW92ZS90b3VjaG1vdmUgZnVuY3Rpb24gaXRzZWxmLCB0byBwcmV2ZW50IHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uLlxuICAgIC8vIGB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eWAgc2ltcGx5IHNldHMgdGhpcy51c2VyQWN0aXZpdHlfIHRvIHRydWUsIHdoaWNoXG4gICAgLy8gdGhlbiBnZXRzIHBpY2tlZCB1cCBieSB0aGlzIGxvb3BcbiAgICAvLyBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvbGVhcm5pbmctZnJvbS10d2l0dGVyL1xuICAgIHZhciBpbmFjdGl2aXR5VGltZW91dCA9IHZvaWQgMDtcblxuICAgIHRoaXMuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIG1vdXNlL3RvdWNoIGFjdGl2aXR5IGhhcyBoYXBwZW5lZFxuICAgICAgaWYgKCF0aGlzLnVzZXJBY3Rpdml0eV8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXNldCB0aGUgYWN0aXZpdHkgdHJhY2tlclxuICAgICAgdGhpcy51c2VyQWN0aXZpdHlfID0gZmFsc2U7XG5cbiAgICAgIC8vIElmIHRoZSB1c2VyIHN0YXRlIHdhcyBpbmFjdGl2ZSwgc2V0IHRoZSBzdGF0ZSB0byBhY3RpdmVcbiAgICAgIHRoaXMudXNlckFjdGl2ZSh0cnVlKTtcblxuICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIGluYWN0aXZpdHkgdGltZW91dCB0byBzdGFydCB0aGUgdGltZXIgb3ZlclxuICAgICAgdGhpcy5jbGVhclRpbWVvdXQoaW5hY3Rpdml0eVRpbWVvdXQpO1xuXG4gICAgICB2YXIgdGltZW91dCA9IHRoaXMub3B0aW9uc18uaW5hY3Rpdml0eVRpbWVvdXQ7XG5cbiAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJbiA8dGltZW91dD4gbWlsbGlzZWNvbmRzLCBpZiBubyBtb3JlIGFjdGl2aXR5IGhhcyBvY2N1cnJlZCB0aGVcbiAgICAgIC8vIHVzZXIgd2lsbCBiZSBjb25zaWRlcmVkIGluYWN0aXZlXG4gICAgICBpbmFjdGl2aXR5VGltZW91dCA9IHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFByb3RlY3QgYWdhaW5zdCB0aGUgY2FzZSB3aGVyZSB0aGUgaW5hY3Rpdml0eVRpbWVvdXQgY2FuIHRyaWdnZXIganVzdFxuICAgICAgICAvLyBiZWZvcmUgdGhlIG5leHQgdXNlciBhY3Rpdml0eSBpcyBwaWNrZWQgdXAgYnkgdGhlIGFjdGl2aXR5IGNoZWNrIGxvb3BcbiAgICAgICAgLy8gY2F1c2luZyBhIGZsaWNrZXJcbiAgICAgICAgaWYgKCF0aGlzLnVzZXJBY3Rpdml0eV8pIHtcbiAgICAgICAgICB0aGlzLnVzZXJBY3RpdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9LCAyNTApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZS4gQSBwbGF5YmFjayByYXRlIG9mXG4gICAqIDEuMCByZXByZXNlbnRzIG5vcm1hbCBzcGVlZCBhbmQgMC41IHdvdWxkIGluZGljYXRlIGhhbGYtc3BlZWRcbiAgICogcGxheWJhY2ssIGZvciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXBsYXliYWNrcmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JhdGVdXG4gICAqICAgICAgIE5ldyBwbGF5YmFjayByYXRlIHRvIHNldC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUgd2hlbiBnZXR0aW5nIG9yIDEuMFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGxheWJhY2tSYXRlID0gZnVuY3Rpb24gcGxheWJhY2tSYXRlKHJhdGUpIHtcbiAgICBpZiAocmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBOT1RFOiB0aGlzLmNhY2hlXy5sYXN0UGxheWJhY2tSYXRlIGlzIHNldCBmcm9tIHRoZSB0ZWNoIGhhbmRsZXJcbiAgICAgIC8vIHRoYXQgaXMgcmVnaXN0ZXJlZCBhYm92ZVxuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFBsYXliYWNrUmF0ZScsIHJhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8uZmVhdHVyZXNQbGF5YmFja1JhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlXy5sYXN0UGxheWJhY2tSYXRlIHx8IHRoaXMudGVjaEdldF8oJ3BsYXliYWNrUmF0ZScpO1xuICAgIH1cbiAgICByZXR1cm4gMS4wO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgZGVmYXVsdCBwbGF5YmFjayByYXRlLiBBIGRlZmF1bHQgcGxheWJhY2sgcmF0ZSBvZlxuICAgKiAxLjAgcmVwcmVzZW50cyBub3JtYWwgc3BlZWQgYW5kIDAuNSB3b3VsZCBpbmRpY2F0ZSBoYWxmLXNwZWVkIHBsYXliYWNrLCBmb3IgaW5zdGFuY2UuXG4gICAqIGRlZmF1bHRQbGF5YmFja1JhdGUgd2lsbCBvbmx5IHJlcHJlc2VudCB3aGF0IHRoZSBpbml0aWFsIHBsYXliYWNrUmF0ZSBvZiBhIHZpZGVvIHdhcywgbm90XG4gICAqIG5vdCB0aGUgY3VycmVudCBwbGF5YmFja1JhdGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS1tZWRpYS1kZWZhdWx0cGxheWJhY2tyYXRlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmF0ZV1cbiAgICogICAgICAgTmV3IGRlZmF1bHQgcGxheWJhY2sgcmF0ZSB0byBzZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcnxQbGF5ZXJ9XG4gICAqICAgICAgICAgLSBUaGUgZGVmYXVsdCBwbGF5YmFjayByYXRlIHdoZW4gZ2V0dGluZyBvciAxLjBcbiAgICogICAgICAgICAtIHRoZSBwbGF5ZXIgd2hlbiBzZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5kZWZhdWx0UGxheWJhY2tSYXRlID0gZnVuY3Rpb24gZGVmYXVsdFBsYXliYWNrUmF0ZShyYXRlKSB7XG4gICAgaWYgKHJhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaENhbGxfKCdzZXREZWZhdWx0UGxheWJhY2tSYXRlJywgcmF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy5mZWF0dXJlc1BsYXliYWNrUmF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ2RlZmF1bHRQbGF5YmFja1JhdGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIDEuMDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBhdWRpbyBmbGFnXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYm9vbFxuICAgKiAgICAgICAgLSB0cnVlIHNpZ25hbHMgdGhhdCB0aGlzIGlzIGFuIGF1ZGlvIHBsYXllclxuICAgKiAgICAgICAgLSBmYWxzZSBzaWduYWxzIHRoYXQgdGhpcyBpcyBub3QgYW4gYXVkaW8gcGxheWVyXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgaXNBdWRpbyB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmlzQXVkaW8gPSBmdW5jdGlvbiBpc0F1ZGlvKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmlzQXVkaW9fID0gISFib29sO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiAhIXRoaXMuaXNBdWRpb187XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCBmb3IgYWRkaW5nIGEge0BsaW5rIFRleHRUcmFja30gdG8gb3VyXG4gICAqIHtAbGluayBUZXh0VHJhY2tMaXN0fS5cbiAgICpcbiAgICogSW4gYWRkaXRpb24gdG8gdGhlIFczQyBzZXR0aW5ncyB3ZSBhbGxvdyBhZGRpbmcgYWRkaXRpb25hbCBpbmZvIHRocm91Z2ggb3B0aW9ucy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9odG1sL3dnL2RyYWZ0cy9odG1sL21hc3Rlci9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtYWRkdGV4dHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBba2luZF1cbiAgICogICAgICAgIHRoZSBraW5kIG9mIFRleHRUcmFjayB5b3UgYXJlIGFkZGluZ1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXVxuICAgKiAgICAgICAgdGhlIGxhYmVsIHRvIGdpdmUgdGhlIFRleHRUcmFjayBsYWJlbFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlXVxuICAgKiAgICAgICAgdGhlIGxhbmd1YWdlIHRvIHNldCBvbiB0aGUgVGV4dFRyYWNrXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja3x1bmRlZmluZWR9XG4gICAqICAgICAgICAgdGhlIFRleHRUcmFjayB0aGF0IHdhcyBhZGRlZCBvciB1bmRlZmluZWRcbiAgICogICAgICAgICBpZiB0aGVyZSBpcyBubyB0ZWNoXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hZGRUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKSB7XG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hfLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9IGFuZCBhbiB7QGxpbmsgSFRNTFRyYWNrRWxlbWVudH0uIEl0IHdpbGxcbiAgICogYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQgd2hlbmV2ZXIgdGhlIHNvdXJjZSBjaGFuZ2VzLCB1bmxlc3NcbiAgICogbWFudWFsQ2xlYW51cCBpcyBzZXQgdG8gZmFsc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBPcHRpb25zIHRvIHBhc3MgdG8ge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9IGR1cmluZyBjcmVhdGlvbi4gU2VlXG4gICAqICAgICAgICB7QGxpbmsgSFRNTFRyYWNrRWxlbWVudH0gZm9yIG9iamVjdCBwcm9wZXJ0aWVzIHRoYXQgeW91IHNob3VsZCB1c2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW21hbnVhbENsZWFudXA9dHJ1ZV0gaWYgc2V0IHRvIGZhbHNlLCB0aGUgVGV4dFRyYWNrIHdpbGwgYmVcbiAgICpcbiAgICogQHJldHVybiB7SHRtbFRyYWNrRWxlbWVudH1cbiAgICogICAgICAgICB0aGUgSFRNTFRyYWNrRWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkIGFuZCBhZGRlZFxuICAgKiAgICAgICAgIHRvIHRoZSBIdG1sVHJhY2tFbGVtZW50TGlzdCBhbmQgdGhlIHJlbW90ZVxuICAgKiAgICAgICAgIFRleHRUcmFja0xpc3RcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIFwibWFudWFsQ2xlYW51cFwiIHBhcmFtZXRlciB3aWxsIGRlZmF1bHRcbiAgICogICAgICAgICAgICAgdG8gXCJmYWxzZVwiIGluIHVwY29taW5nIHZlcnNpb25zIG9mIFZpZGVvLmpzXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hZGRSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRSZW1vdGVUZXh0VHJhY2sob3B0aW9ucywgbWFudWFsQ2xlYW51cCkge1xuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoXy5hZGRSZW1vdGVUZXh0VHJhY2sob3B0aW9ucywgbWFudWFsQ2xlYW51cCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSByZW1vdGUge0BsaW5rIFRleHRUcmFja30gZnJvbSB0aGUgcmVzcGVjdGl2ZVxuICAgKiB7QGxpbmsgVGV4dFRyYWNrTGlzdH0gYW5kIHtAbGluayBIdG1sVHJhY2tFbGVtZW50TGlzdH0uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFja1xuICAgKiAgICAgICAgUmVtb3RlIHtAbGluayBUZXh0VHJhY2t9IHRvIHJlbW92ZVxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqICAgICAgICAgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZW1vdmVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiByZW1vdmVSZW1vdGVUZXh0VHJhY2soKSB7XG4gICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZjMkdHJhY2sgPSBfcmVmMy50cmFjayxcbiAgICAgICAgdHJhY2sgPSBfcmVmMyR0cmFjayA9PT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogX3JlZjMkdHJhY2s7XG5cbiAgICAvLyBkZXN0cnVjdHVyZSB0aGUgaW5wdXQgaW50byBhbiBvYmplY3Qgd2l0aCBhIHRyYWNrIGFyZ3VtZW50LCBkZWZhdWx0aW5nIHRvIGFyZ3VtZW50c1swXVxuICAgIC8vIGRlZmF1bHQgdGhlIHdob2xlIGFyZ3VtZW50IHRvIGFuIGVtcHR5IG9iamVjdCBpZiBub3RoaW5nIHdhcyBwYXNzZWQgaW5cblxuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoXy5yZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhdmFpbGFibGUgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzIGFzIHNwZWNpZmllZCBieSB0aGUgVzNDJ3MgTWVkaWFcbiAgICogUGxheWJhY2sgUXVhbGl0eSBBUEkuXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vbWVkaWEtcGxheWJhY2stcXVhbGl0eX1cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAgICogICAgICAgICBBbiBvYmplY3Qgd2l0aCBzdXBwb3J0ZWQgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzIG9yIHVuZGVmaW5lZCBpZiB0aGVyZVxuICAgKiAgICAgICAgIGlzIG5vIHRlY2ggb3IgdGhlIHRlY2ggZG9lcyBub3Qgc3VwcG9ydCBpdC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID0gZnVuY3Rpb24gZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ2dldFZpZGVvUGxheWJhY2tRdWFsaXR5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB2aWRlbyB3aWR0aFxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgY3VycmVudCB2aWRlbyB3aWR0aFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudmlkZW9XaWR0aCA9IGZ1bmN0aW9uIHZpZGVvV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy52aWRlb1dpZHRoICYmIHRoaXMudGVjaF8udmlkZW9XaWR0aCgpIHx8IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB2aWRlbyBoZWlnaHRcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIGN1cnJlbnQgdmlkZW8gaGVpZ2h0XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS52aWRlb0hlaWdodCA9IGZ1bmN0aW9uIHZpZGVvSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8udmlkZW9IZWlnaHQgJiYgdGhpcy50ZWNoXy52aWRlb0hlaWdodCgpIHx8IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBwbGF5ZXIncyBsYW5ndWFnZSBjb2RlXG4gICAqIE5PVEU6IFRoZSBsYW5ndWFnZSBzaG91bGQgYmUgc2V0IGluIHRoZSBwbGF5ZXIgb3B0aW9ucyBpZiB5b3Ugd2FudCB0aGVcbiAgICogdGhlIGNvbnRyb2xzIHRvIGJlIGJ1aWx0IHdpdGggYSBzcGVjaWZpYyBsYW5ndWFnZS4gQ2hhbmdpbmcgdGhlIGxhbmd1YWdlXG4gICAqIGxhdGVyIHdpbGwgbm90IHVwZGF0ZSBjb250cm9scyB0ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdXG4gICAqICAgICAgICB0aGUgbGFuZ3VhZ2UgY29kZSB0byBzZXQgdGhlIHBsYXllciB0b1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgbGFuZ3VhZ2UgY29kZSB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxhbmd1YWdlID0gZnVuY3Rpb24gbGFuZ3VhZ2UoY29kZSkge1xuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhbmd1YWdlXztcbiAgICB9XG5cbiAgICB0aGlzLmxhbmd1YWdlXyA9IFN0cmluZyhjb2RlKS50b0xvd2VyQ2FzZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBsYXllcidzIGxhbmd1YWdlIGRpY3Rpb25hcnlcbiAgICogTWVyZ2UgZXZlcnkgdGltZSwgYmVjYXVzZSBhIG5ld2x5IGFkZGVkIHBsdWdpbiBtaWdodCBjYWxsIHZpZGVvanMuYWRkTGFuZ3VhZ2UoKSBhdCBhbnkgdGltZVxuICAgKiBMYW5ndWFnZXMgc3BlY2lmaWVkIGRpcmVjdGx5IGluIHRoZSBwbGF5ZXIgb3B0aW9ucyBoYXZlIHByZWNlZGVuY2VcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqICAgICAgICAgQW4gYXJyYXkgb2Ygb2Ygc3VwcG9ydGVkIGxhbmd1YWdlc1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubGFuZ3VhZ2VzID0gZnVuY3Rpb24gbGFuZ3VhZ2VzKCkge1xuICAgIHJldHVybiBtZXJnZU9wdGlvbnMoUGxheWVyLnByb3RvdHlwZS5vcHRpb25zXy5sYW5ndWFnZXMsIHRoaXMubGFuZ3VhZ2VzXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCByZXBlcmVzZW50aW5nIHRoZSBjdXJyZW50IHRyYWNrXG4gICAqIGluZm9ybWF0aW9uLiAqKkRPRVMgbm90IHJldHVybiBpdCBhcyBKU09OKipcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIE9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgb2YgdHJhY2sgaW5mb1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHZhciBvcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9uc18pO1xuICAgIHZhciB0cmFja3MgPSBvcHRpb25zLnRyYWNrcztcblxuICAgIG9wdGlvbnMudHJhY2tzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICAvLyBkZWVwIG1lcmdlIHRyYWNrcyBhbmQgbnVsbCBvdXQgcGxheWVyIHNvIG5vIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgIHRyYWNrID0gbWVyZ2VPcHRpb25zKHRyYWNrKTtcbiAgICAgIHRyYWNrLnBsYXllciA9IHVuZGVmaW5lZDtcbiAgICAgIG9wdGlvbnMudHJhY2tzW2ldID0gdHJhY2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaW1wbGUgbW9kYWwgZGlhbG9nIChhbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIE1vZGFsRGlhbG9nfVxuICAgKiBjb21wb25lbnQpIHRoYXQgaW1tZWRpYXRlbHkgb3ZlcmxheXMgdGhlIHBsYXllciB3aXRoIGFyYml0cmFyeVxuICAgKiBjb250ZW50IGFuZCByZW1vdmVzIGl0c2VsZiB3aGVuIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb258RWxlbWVudHxBcnJheXxudWxsfSBjb250ZW50XG4gICAqICAgICAgICBTYW1lIGFzIHtAbGluayBNb2RhbERpYWxvZyNjb250ZW50fSdzIHBhcmFtIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAqICAgICAgICBUaGUgbW9zdCBzdHJhaWdodC1mb3J3YXJkIHVzYWdlIGlzIHRvIHByb3ZpZGUgYSBzdHJpbmcgb3IgRE9NXG4gICAqICAgICAgICBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBFeHRyYSBvcHRpb25zIHdoaWNoIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7QGxpbmsgTW9kYWxEaWFsb2d9LlxuICAgKlxuICAgKiBAcmV0dXJuIHtNb2RhbERpYWxvZ31cbiAgICogICAgICAgICB0aGUge0BsaW5rIE1vZGFsRGlhbG9nfSB0aGF0IHdhcyBjcmVhdGVkXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jcmVhdGVNb2RhbCA9IGZ1bmN0aW9uIGNyZWF0ZU1vZGFsKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNvbnRlbnQgPSBjb250ZW50IHx8ICcnO1xuXG4gICAgdmFyIG1vZGFsID0gbmV3IE1vZGFsRGlhbG9nKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5hZGRDaGlsZChtb2RhbCk7XG4gICAgbW9kYWwub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczExLnJlbW92ZUNoaWxkKG1vZGFsKTtcbiAgICB9KTtcblxuICAgIG1vZGFsLm9wZW4oKTtcbiAgICByZXR1cm4gbW9kYWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgdGFnIHNldHRpbmdzXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFnXG4gICAqICAgICAgICBUaGUgcGxheWVyIHRhZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBzZXR0aW5nc1xuICAgKiAgICAgICAgIGZvciBhIHBsYXllciB0YWdcbiAgICovXG5cblxuICBQbGF5ZXIuZ2V0VGFnU2V0dGluZ3MgPSBmdW5jdGlvbiBnZXRUYWdTZXR0aW5ncyh0YWcpIHtcbiAgICB2YXIgYmFzZU9wdGlvbnMgPSB7XG4gICAgICBzb3VyY2VzOiBbXSxcbiAgICAgIHRyYWNrczogW11cbiAgICB9O1xuXG4gICAgdmFyIHRhZ09wdGlvbnMgPSBnZXRBdHRyaWJ1dGVzKHRhZyk7XG4gICAgdmFyIGRhdGFTZXR1cCA9IHRhZ09wdGlvbnNbJ2RhdGEtc2V0dXAnXTtcblxuICAgIGlmIChoYXNDbGFzcyh0YWcsICd2anMtZmx1aWQnKSkge1xuICAgICAgdGFnT3B0aW9ucy5mbHVpZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgZGF0YS1zZXR1cCBhdHRyIGV4aXN0cy5cbiAgICBpZiAoZGF0YVNldHVwICE9PSBudWxsKSB7XG4gICAgICAvLyBQYXJzZSBvcHRpb25zIEpTT05cbiAgICAgIC8vIElmIGVtcHR5IHN0cmluZywgbWFrZSBpdCBhIHBhcnNhYmxlIGpzb24gb2JqZWN0LlxuICAgICAgdmFyIF9zYWZlUGFyc2VUdXBsZSA9IHNhZmVQYXJzZVR1cGxlKGRhdGFTZXR1cCB8fCAne30nKSxcbiAgICAgICAgICBlcnIgPSBfc2FmZVBhcnNlVHVwbGVbMF0sXG4gICAgICAgICAgZGF0YSA9IF9zYWZlUGFyc2VUdXBsZVsxXTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2ckMS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgYXNzaWduKHRhZ09wdGlvbnMsIGRhdGEpO1xuICAgIH1cblxuICAgIGFzc2lnbihiYXNlT3B0aW9ucywgdGFnT3B0aW9ucyk7XG5cbiAgICAvLyBHZXQgdGFnIGNoaWxkcmVuIHNldHRpbmdzXG4gICAgaWYgKHRhZy5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRhZy5jaGlsZE5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgLy8gQ2hhbmdlIGNhc2UgbmVlZGVkOiBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvbm9kZW5hbWUtY2FzZS1zZW5zaXRpdml0eS9cbiAgICAgICAgdmFyIGNoaWxkTmFtZSA9IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJ3NvdXJjZScpIHtcbiAgICAgICAgICBiYXNlT3B0aW9ucy5zb3VyY2VzLnB1c2goZ2V0QXR0cmlidXRlcyhjaGlsZCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkTmFtZSA9PT0gJ3RyYWNrJykge1xuICAgICAgICAgIGJhc2VPcHRpb25zLnRyYWNrcy5wdXNoKGdldEF0dHJpYnV0ZXMoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiYXNlT3B0aW9ucztcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGZsZXhib3ggaXMgc3VwcG9ydGVkXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSB0cnVlIGlmIGZsZXhib3ggaXMgc3VwcG9ydGVkXG4gICAqICAgICAgICAgLSBmYWxzZSBpZiBmbGV4Ym94IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmZsZXhOb3RTdXBwb3J0ZWRfID0gZnVuY3Rpb24gZmxleE5vdFN1cHBvcnRlZF8oKSB7XG4gICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJyk7XG5cbiAgICAvLyBOb3RlOiBXZSBkb24ndCBhY3R1YWxseSB1c2UgZmxleEJhc2lzIChvciBmbGV4T3JkZXIpLCBidXQgaXQncyBvbmUgb2YgdGhlIG1vcmVcbiAgICAvLyBjb21tb24gZmxleCBmZWF0dXJlcyB0aGF0IHdlIGNhbiByZWx5IG9uIHdoZW4gY2hlY2tpbmcgZm9yIGZsZXggc3VwcG9ydC5cbiAgICByZXR1cm4gISgnZmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8ICd3ZWJraXRGbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUgfHwgJ21vekZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fCAnbXNGbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUgfHxcbiAgICAvLyBJRTEwLXNwZWNpZmljICgyMDEyIGZsZXggc3BlYyksIGF2YWlsYWJsZSBmb3IgY29tcGxldGVuZXNzXG4gICAgJ21zRmxleE9yZGVyJyBpbiBlbGVtLnN0eWxlKTtcbiAgfTtcblxuICByZXR1cm4gUGxheWVyO1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIEdldCB0aGUge0BsaW5rIFZpZGVvVHJhY2tMaXN0fVxuICogQGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3ZpZGVvdHJhY2tsaXN0XG4gKlxuICogQHJldHVybiB7VmlkZW9UcmFja0xpc3R9XG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHZpZGVvIHRyYWNrIGxpc3RcbiAqXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUudmlkZW9UcmFja3NcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fVxuICogQGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2F1ZGlvdHJhY2tsaXN0XG4gKlxuICogQHJldHVybiB7QXVkaW9UcmFja0xpc3R9XG4gKiAgICAgICAgIHRoZSBjdXJyZW50IGF1ZGlvIHRyYWNrIGxpc3RcbiAqXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUuYXVkaW9UcmFja3NcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUge0BsaW5rIFRleHRUcmFja0xpc3R9XG4gKlxuICogQGxpbmsgaHR0cDovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXRleHR0cmFja3NcbiAqXG4gKiBAcmV0dXJuIHtUZXh0VHJhY2tMaXN0fVxuICogICAgICAgICB0aGUgY3VycmVudCB0ZXh0IHRyYWNrIGxpc3RcbiAqXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUudGV4dFRyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSByZW1vdGUge0BsaW5rIFRleHRUcmFja0xpc3R9XG4gKlxuICogQHJldHVybiB7VGV4dFRyYWNrTGlzdH1cbiAqICAgICAgICAgVGhlIGN1cnJlbnQgcmVtb3RlIHRleHQgdHJhY2sgbGlzdFxuICpcbiAqIEBtZXRob2QgUGxheWVyLnByb3RvdHlwZS5yZW1vdGVUZXh0VHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHJlbW90ZSB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudExpc3R9IHRyYWNrcy5cbiAqXG4gKiBAcmV0dXJuIHtIdG1sVHJhY2tFbGVtZW50TGlzdH1cbiAqICAgICAgICAgVGhlIGN1cnJlbnQgcmVtb3RlIHRleHQgdHJhY2sgZWxlbWVudCBsaXN0XG4gKlxuICogQG1ldGhvZCBQbGF5ZXIucHJvdG90eXBlLnJlbW90ZVRleHRUcmFja0Vsc1xuICovXG5cbkFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gIHZhciBwcm9wcyA9IEFMTFtuYW1lJCQxXTtcblxuICBQbGF5ZXIucHJvdG90eXBlW3Byb3BzLmdldHRlck5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoX1twcm9wcy5nZXR0ZXJOYW1lXSgpO1xuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkVGVjaF8sIHdlIGNyZWF0ZSB7dmlkZW8sYXVkaW8sdGV4dH1UcmFja3NfXG4gICAgLy8gdGhlc2Ugd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHRlY2ggZHVyaW5nIGxvYWRpbmdcbiAgICB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXSA9IHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdIHx8IG5ldyBwcm9wcy5MaXN0Q2xhc3MoKTtcbiAgICByZXR1cm4gdGhpc1twcm9wcy5wcml2YXRlTmFtZV07XG4gIH07XG59KTtcblxuLyoqXG4gKiBHbG9iYWwgcGxheWVyIGxpc3RcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5QbGF5ZXIucGxheWVycyA9IHt9O1xuXG52YXIgbmF2aWdhdG9yID0gd2luZG93JDEubmF2aWdhdG9yO1xuXG4vKlxuICogUGxheWVyIGluc3RhbmNlIG9wdGlvbnMsIHN1cmZhY2VkIHVzaW5nIG9wdGlvbnNcbiAqIG9wdGlvbnMgPSBQbGF5ZXIucHJvdG90eXBlLm9wdGlvbnNfXG4gKiBNYWtlIGNoYW5nZXMgaW4gb3B0aW9ucywgbm90IGhlcmUuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblBsYXllci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIC8vIERlZmF1bHQgb3JkZXIgb2YgZmFsbGJhY2sgdGVjaG5vbG9neVxuICB0ZWNoT3JkZXI6IFRlY2guZGVmYXVsdFRlY2hPcmRlcl8sXG5cbiAgaHRtbDU6IHt9LFxuICBmbGFzaDoge30sXG5cbiAgLy8gZGVmYXVsdCBpbmFjdGl2aXR5IHRpbWVvdXRcbiAgaW5hY3Rpdml0eVRpbWVvdXQ6IDIwMDAsXG5cbiAgLy8gZGVmYXVsdCBwbGF5YmFjayByYXRlc1xuICBwbGF5YmFja1JhdGVzOiBbXSxcbiAgLy8gQWRkIHBsYXliYWNrIHJhdGUgc2VsZWN0aW9uIGJ5IGFkZGluZyByYXRlc1xuICAvLyAncGxheWJhY2tSYXRlcyc6IFswLjUsIDEsIDEuNSwgMl0sXG5cbiAgLy8gSW5jbHVkZWQgY29udHJvbCBzZXRzXG4gIGNoaWxkcmVuOiBbJ21lZGlhTG9hZGVyJywgJ3Bvc3RlckltYWdlJywgJ3RleHRUcmFja0Rpc3BsYXknLCAnbG9hZGluZ1NwaW5uZXInLCAnYmlnUGxheUJ1dHRvbicsICdjb250cm9sQmFyJywgJ2Vycm9yRGlzcGxheScsICd0ZXh0VHJhY2tTZXR0aW5ncycsICdyZXNpemVNYW5hZ2VyJ10sXG5cbiAgbGFuZ3VhZ2U6IG5hdmlnYXRvciAmJiAobmF2aWdhdG9yLmxhbmd1YWdlcyAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdIHx8IG5hdmlnYXRvci51c2VyTGFuZ3VhZ2UgfHwgbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCAnZW4nLFxuXG4gIC8vIGxvY2FsZXMgYW5kIHRoZWlyIGxhbmd1YWdlIHRyYW5zbGF0aW9uc1xuICBsYW5ndWFnZXM6IHt9LFxuXG4gIC8vIERlZmF1bHQgbWVzc2FnZSB0byBzaG93IHdoZW4gYSB2aWRlbyBjYW5ub3QgYmUgcGxheWVkLlxuICBub3RTdXBwb3J0ZWRNZXNzYWdlOiAnTm8gY29tcGF0aWJsZSBzb3VyY2Ugd2FzIGZvdW5kIGZvciB0aGlzIG1lZGlhLidcbn07XG5cbltcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxheWVyIGlzIGluIHRoZSBcImVuZGVkXCIgc3RhdGUuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGxheWVyIGlzIGluIHRoZSBlbmRlZCBzdGF0ZSwgZmFsc2UgaWYgbm90LlxuICogQG1ldGhvZCBQbGF5ZXIjZW5kZWRcbiAqL1xuJ2VuZGVkJyxcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxheWVyIGlzIGluIHRoZSBcInNlZWtpbmdcIiBzdGF0ZS5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwbGF5ZXIgaXMgaW4gdGhlIHNlZWtpbmcgc3RhdGUsIGZhbHNlIGlmIG5vdC5cbiAqIEBtZXRob2QgUGxheWVyI3NlZWtpbmdcbiAqL1xuJ3NlZWtpbmcnLFxuLyoqXG4gKiBSZXR1cm5zIHRoZSBUaW1lUmFuZ2VzIG9mIHRoZSBtZWRpYSB0aGF0IGFyZSBjdXJyZW50bHkgYXZhaWxhYmxlXG4gKiBmb3Igc2Vla2luZyB0by5cbiAqXG4gKiBAcmV0dXJuIHtUaW1lUmFuZ2VzfSB0aGUgc2Vla2FibGUgaW50ZXJ2YWxzIG9mIHRoZSBtZWRpYSB0aW1lbGluZVxuICogQG1ldGhvZCBQbGF5ZXIjc2Vla2FibGVcbiAqL1xuJ3NlZWthYmxlJyxcbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZSBvZiBuZXR3b3JrIGFjdGl2aXR5IGZvciB0aGUgZWxlbWVudCwgZnJvbVxuICogdGhlIGNvZGVzIGluIHRoZSBsaXN0IGJlbG93LlxuICogLSBORVRXT1JLX0VNUFRZIChudW1lcmljIHZhbHVlIDApXG4gKiAgIFRoZSBlbGVtZW50IGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGlzZWQuIEFsbCBhdHRyaWJ1dGVzIGFyZSBpblxuICogICB0aGVpciBpbml0aWFsIHN0YXRlcy5cbiAqIC0gTkVUV09SS19JRExFIChudW1lcmljIHZhbHVlIDEpXG4gKiAgIFRoZSBlbGVtZW50J3MgcmVzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobSBpcyBhY3RpdmUgYW5kIGhhc1xuICogICBzZWxlY3RlZCBhIHJlc291cmNlLCBidXQgaXQgaXMgbm90IGFjdHVhbGx5IHVzaW5nIHRoZSBuZXR3b3JrIGF0XG4gKiAgIHRoaXMgdGltZS5cbiAqIC0gTkVUV09SS19MT0FESU5HIChudW1lcmljIHZhbHVlIDIpXG4gKiAgIFRoZSB1c2VyIGFnZW50IGlzIGFjdGl2ZWx5IHRyeWluZyB0byBkb3dubG9hZCBkYXRhLlxuICogLSBORVRXT1JLX05PX1NPVVJDRSAobnVtZXJpYyB2YWx1ZSAzKVxuICogICBUaGUgZWxlbWVudCdzIHJlc291cmNlIHNlbGVjdGlvbiBhbGdvcml0aG0gaXMgYWN0aXZlLCBidXQgaXQgaGFzXG4gKiAgIG5vdCB5ZXQgZm91bmQgYSByZXNvdXJjZSB0byB1c2UuXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjbmV0d29yay1zdGF0ZXNcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGN1cnJlbnQgbmV0d29yayBhY3Rpdml0eSBzdGF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjbmV0d29ya1N0YXRlXG4gKi9cbiduZXR3b3JrU3RhdGUnLFxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBleHByZXNzZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnRcbiAqIHdpdGggcmVzcGVjdCB0byByZW5kZXJpbmcgdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24sIGZyb20gdGhlXG4gKiBjb2RlcyBpbiB0aGUgbGlzdCBiZWxvdy5cbiAqIC0gSEFWRV9OT1RISU5HIChudW1lcmljIHZhbHVlIDApXG4gKiAgIE5vIGluZm9ybWF0aW9uIHJlZ2FyZGluZyB0aGUgbWVkaWEgcmVzb3VyY2UgaXMgYXZhaWxhYmxlLlxuICogLSBIQVZFX01FVEFEQVRBIChudW1lcmljIHZhbHVlIDEpXG4gKiAgIEVub3VnaCBvZiB0aGUgcmVzb3VyY2UgaGFzIGJlZW4gb2J0YWluZWQgdGhhdCB0aGUgZHVyYXRpb24gb2YgdGhlXG4gKiAgIHJlc291cmNlIGlzIGF2YWlsYWJsZS5cbiAqIC0gSEFWRV9DVVJSRU5UX0RBVEEgKG51bWVyaWMgdmFsdWUgMilcbiAqICAgRGF0YSBmb3IgdGhlIGltbWVkaWF0ZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGlzIGF2YWlsYWJsZS5cbiAqIC0gSEFWRV9GVVRVUkVfREFUQSAobnVtZXJpYyB2YWx1ZSAzKVxuICogICBEYXRhIGZvciB0aGUgaW1tZWRpYXRlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgYXZhaWxhYmxlLCBhc1xuICogICB3ZWxsIGFzIGVub3VnaCBkYXRhIGZvciB0aGUgdXNlciBhZ2VudCB0byBhZHZhbmNlIHRoZSBjdXJyZW50XG4gKiAgIHBsYXliYWNrIHBvc2l0aW9uIGluIHRoZSBkaXJlY3Rpb24gb2YgcGxheWJhY2suXG4gKiAtIEhBVkVfRU5PVUdIX0RBVEEgKG51bWVyaWMgdmFsdWUgNClcbiAqICAgVGhlIHVzZXIgYWdlbnQgZXN0aW1hdGVzIHRoYXQgZW5vdWdoIGRhdGEgaXMgYXZhaWxhYmxlIGZvclxuICogICBwbGF5YmFjayB0byBwcm9jZWVkIHVuaW50ZXJydXB0ZWQuXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXJlYWR5c3RhdGVcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGN1cnJlbnQgcGxheWJhY2sgcmVuZGVyaW5nIHN0YXRlXG4gKiBAbWV0aG9kIFBsYXllciNyZWFkeVN0YXRlXG4gKi9cbidyZWFkeVN0YXRlJ10uZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgUGxheWVyLnByb3RvdHlwZVtmbl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oZm4pO1xuICB9O1xufSk7XG5cblRFQ0hfRVZFTlRTX1JFVFJJR0dFUi5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICBQbGF5ZXIucHJvdG90eXBlWydoYW5kbGVUZWNoJyArIHRvVGl0bGVDYXNlKGV2ZW50KSArICdfJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlcihldmVudCk7XG4gIH07XG59KTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBwbGF5ZXIgaGFzIGluaXRpYWwgZHVyYXRpb24gYW5kIGRpbWVuc2lvbiBpbmZvcm1hdGlvblxuICpcbiAqIEBldmVudCBQbGF5ZXIjbG9hZGVkbWV0YWRhdGFcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBoYXMgZG93bmxvYWRlZCBkYXRhIGF0IHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uXG4gKlxuICogQGV2ZW50IFBsYXllciNsb2FkZWRkYXRhXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGhhcyBjaGFuZ2VkICpcbiAqIER1cmluZyBwbGF5YmFjayB0aGlzIGlzIGZpcmVkIGV2ZXJ5IDE1LTI1MCBtaWxsaXNlY29uZHMsIGRlcGVuZGluZyBvbiB0aGVcbiAqIHBsYXliYWNrIHRlY2hub2xvZ3kgaW4gdXNlLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjdGltZXVwZGF0ZVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdm9sdW1lIGNoYW5nZXNcbiAqXG4gKiBAZXZlbnQgUGxheWVyI3ZvbHVtZWNoYW5nZVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogUmVwb3J0cyB3aGV0aGVyIG9yIG5vdCBhIHBsYXllciBoYXMgYSBwbHVnaW4gYXZhaWxhYmxlLlxuICpcbiAqIFRoaXMgZG9lcyBub3QgcmVwb3J0IHdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaGFzIGV2ZXIgYmVlbiBpbml0aWFsaXplZFxuICogb24gdGhpcyBwbGF5ZXIuIEZvciB0aGF0LCBbdXNpbmdQbHVnaW5de0BsaW5rIFBsYXllciN1c2luZ1BsdWdpbn0uXG4gKlxuICogQG1ldGhvZCBQbGF5ZXIjaGFzUGx1Z2luXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoaXMgcGxheWVyIGhhcyB0aGUgcmVxdWVzdGVkIHBsdWdpbiBhdmFpbGFibGUuXG4gKi9cblxuLyoqXG4gKiBSZXBvcnRzIHdoZXRoZXIgb3Igbm90IGEgcGxheWVyIGlzIHVzaW5nIGEgcGx1Z2luIGJ5IG5hbWUuXG4gKlxuICogRm9yIGJhc2ljIHBsdWdpbnMsIHRoaXMgb25seSByZXBvcnRzIHdoZXRoZXIgdGhlIHBsdWdpbiBoYXMgX2V2ZXJfIGJlZW5cbiAqIGluaXRpYWxpemVkIG9uIHRoaXMgcGxheWVyLlxuICpcbiAqIEBtZXRob2QgUGxheWVyI3VzaW5nUGx1Z2luXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdGhpcyBwbGF5ZXIgaXMgdXNpbmcgdGhlIHJlcXVlc3RlZCBwbHVnaW4uXG4gKi9cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5ZXInLCBQbGF5ZXIpO1xuXG4vKipcbiAqIEBmaWxlIHBsdWdpbi5qc1xuICovXG5cbi8qKlxuICogVGhlIGJhc2UgcGx1Z2luIG5hbWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIEJBU0VfUExVR0lOX05BTUUgPSAncGx1Z2luJztcblxuLyoqXG4gKiBUaGUga2V5IG9uIHdoaWNoIGEgcGxheWVyJ3MgYWN0aXZlIHBsdWdpbnMgY2FjaGUgaXMgc3RvcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlICAgICB7c3RyaW5nfVxuICovXG52YXIgUExVR0lOX0NBQ0hFX0tFWSA9ICdhY3RpdmVQbHVnaW5zXyc7XG5cbi8qKlxuICogU3RvcmVzIHJlZ2lzdGVyZWQgcGx1Z2lucyBpbiBhIHByaXZhdGUgc3BhY2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0eXBlICAgIHtPYmplY3R9XG4gKi9cbnZhciBwbHVnaW5TdG9yYWdlID0ge307XG5cbi8qKlxuICogUmVwb3J0cyB3aGV0aGVyIG9yIG5vdCBhIHBsdWdpbiBoYXMgYmVlbiByZWdpc3RlcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAqL1xudmFyIHBsdWdpbkV4aXN0cyA9IGZ1bmN0aW9uIHBsdWdpbkV4aXN0cyhuYW1lKSB7XG4gIHJldHVybiBwbHVnaW5TdG9yYWdlLmhhc093blByb3BlcnR5KG5hbWUpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBzaW5nbGUgcmVnaXN0ZXJlZCBwbHVnaW4gYnkgbmFtZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqICAgICAgICAgIFRoZSBwbHVnaW4gKG9yIHVuZGVmaW5lZCkuXG4gKi9cbnZhciBnZXRQbHVnaW4gPSBmdW5jdGlvbiBnZXRQbHVnaW4obmFtZSkge1xuICByZXR1cm4gcGx1Z2luRXhpc3RzKG5hbWUpID8gcGx1Z2luU3RvcmFnZVtuYW1lXSA6IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogTWFya3MgYSBwbHVnaW4gYXMgXCJhY3RpdmVcIiBvbiBhIHBsYXllci5cbiAqXG4gKiBBbHNvLCBlbnN1cmVzIHRoYXQgdGhlIHBsYXllciBoYXMgYW4gb2JqZWN0IGZvciB0cmFja2luZyBhY3RpdmUgcGx1Z2lucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge1BsYXllcn0gcGxheWVyXG4gKiAgICAgICAgICBBIFZpZGVvLmpzIHBsYXllciBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqL1xudmFyIG1hcmtQbHVnaW5Bc0FjdGl2ZSA9IGZ1bmN0aW9uIG1hcmtQbHVnaW5Bc0FjdGl2ZShwbGF5ZXIsIG5hbWUpIHtcbiAgcGxheWVyW1BMVUdJTl9DQUNIRV9LRVldID0gcGxheWVyW1BMVUdJTl9DQUNIRV9LRVldIHx8IHt9O1xuICBwbGF5ZXJbUExVR0lOX0NBQ0hFX0tFWV1bbmFtZV0gPSB0cnVlO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VycyBhIHBhaXIgb2YgcGx1Z2luIHNldHVwIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAqICAgICAgICAgQSBWaWRlby5qcyBwbGF5ZXIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtICB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH0gaGFzaFxuICogICAgICAgICBBIHBsdWdpbiBldmVudCBoYXNoLlxuICpcbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtiZWZvcmVdXG4gKiAgICAgICAgIElmIHRydWUsIHByZWZpeGVzIHRoZSBldmVudCBuYW1lIHdpdGggXCJiZWZvcmVcIi4gSW4gb3RoZXIgd29yZHMsXG4gKiAgICAgICAgIHVzZSB0aGlzIHRvIHRyaWdnZXIgXCJiZWZvcmVwbHVnaW5zZXR1cFwiIGluc3RlYWQgb2YgXCJwbHVnaW5zZXR1cFwiLlxuICovXG52YXIgdHJpZ2dlclNldHVwRXZlbnQgPSBmdW5jdGlvbiB0cmlnZ2VyU2V0dXBFdmVudChwbGF5ZXIsIGhhc2gsIGJlZm9yZSkge1xuICB2YXIgZXZlbnROYW1lID0gKGJlZm9yZSA/ICdiZWZvcmUnIDogJycpICsgJ3BsdWdpbnNldHVwJztcblxuICBwbGF5ZXIudHJpZ2dlcihldmVudE5hbWUsIGhhc2gpO1xuICBwbGF5ZXIudHJpZ2dlcihldmVudE5hbWUgKyAnOicgKyBoYXNoLm5hbWUsIGhhc2gpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIGJhc2ljIHBsdWdpbiBmdW5jdGlvbiBhbmQgcmV0dXJucyBhIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggbWFya3NcbiAqIG9uIHRoZSBwbGF5ZXIgdGhhdCB0aGUgcGx1Z2luIGhhcyBiZWVuIGFjdGl2YXRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IHBsdWdpblxuICogICAgICAgICAgVGhlIGJhc2ljIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKiAgICAgICAgICBBIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBwbHVnaW4uXG4gKi9cbnZhciBjcmVhdGVCYXNpY1BsdWdpbiA9IGZ1bmN0aW9uIGNyZWF0ZUJhc2ljUGx1Z2luKG5hbWUsIHBsdWdpbikge1xuICB2YXIgYmFzaWNQbHVnaW5XcmFwcGVyID0gZnVuY3Rpb24gYmFzaWNQbHVnaW5XcmFwcGVyKCkge1xuXG4gICAgLy8gV2UgdHJpZ2dlciB0aGUgXCJiZWZvcmVwbHVnaW5zZXR1cFwiIGFuZCBcInBsdWdpbnNldHVwXCIgZXZlbnRzIG9uIHRoZSBwbGF5ZXJcbiAgICAvLyByZWdhcmRsZXNzLCBidXQgd2Ugd2FudCB0aGUgaGFzaCB0byBiZSBjb25zaXN0ZW50IHdpdGggdGhlIGhhc2ggcHJvdmlkZWRcbiAgICAvLyBmb3IgYWR2YW5jZWQgcGx1Z2lucy5cbiAgICAvL1xuICAgIC8vIFRoZSBvbmx5IHBvdGVudGlhbGx5IGNvdW50ZXItaW50dWl0aXZlIHRoaW5nIGhlcmUgaXMgdGhlIGBpbnN0YW5jZWAgaW5cbiAgICAvLyB0aGUgXCJwbHVnaW5zZXR1cFwiIGV2ZW50IGlzIHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgYHBsdWdpbmAgZnVuY3Rpb24uXG4gICAgdHJpZ2dlclNldHVwRXZlbnQodGhpcywgeyBuYW1lOiBuYW1lLCBwbHVnaW46IHBsdWdpbiwgaW5zdGFuY2U6IG51bGwgfSwgdHJ1ZSk7XG5cbiAgICB2YXIgaW5zdGFuY2UgPSBwbHVnaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIG1hcmtQbHVnaW5Bc0FjdGl2ZSh0aGlzLCBuYW1lKTtcbiAgICB0cmlnZ2VyU2V0dXBFdmVudCh0aGlzLCB7IG5hbWU6IG5hbWUsIHBsdWdpbjogcGx1Z2luLCBpbnN0YW5jZTogaW5zdGFuY2UgfSk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgT2JqZWN0LmtleXMocGx1Z2luKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgYmFzaWNQbHVnaW5XcmFwcGVyW3Byb3BdID0gcGx1Z2luW3Byb3BdO1xuICB9KTtcblxuICByZXR1cm4gYmFzaWNQbHVnaW5XcmFwcGVyO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIHBsdWdpbiBzdWItY2xhc3MgYW5kIHJldHVybnMgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nXG4gKiBpbnN0YW5jZXMgb2YgaXQuXG4gKlxuICogVGhpcyBmYWN0b3J5IGZ1bmN0aW9uIHdpbGwgcmVwbGFjZSBpdHNlbGYgd2l0aCBhbiBpbnN0YW5jZSBvZiB0aGUgcmVxdWVzdGVkXG4gKiBzdWItY2xhc3Mgb2YgUGx1Z2luLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSAgIHtQbHVnaW59IFBsdWdpblN1YkNsYXNzXG4gKiAgICAgICAgICBUaGUgYWR2YW5jZWQgcGx1Z2luLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xudmFyIGNyZWF0ZVBsdWdpbkZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVQbHVnaW5GYWN0b3J5KG5hbWUsIFBsdWdpblN1YkNsYXNzKSB7XG5cbiAgLy8gQWRkIGEgYG5hbWVgIHByb3BlcnR5IHRvIHRoZSBwbHVnaW4gcHJvdG90eXBlIHNvIHRoYXQgZWFjaCBwbHVnaW4gY2FuXG4gIC8vIHJlZmVyIHRvIGl0c2VsZiBieSBuYW1lLlxuICBQbHVnaW5TdWJDbGFzcy5wcm90b3R5cGUubmFtZSA9IG5hbWU7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0cmlnZ2VyU2V0dXBFdmVudCh0aGlzLCB7IG5hbWU6IG5hbWUsIHBsdWdpbjogUGx1Z2luU3ViQ2xhc3MsIGluc3RhbmNlOiBudWxsIH0sIHRydWUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShQbHVnaW5TdWJDbGFzcywgW251bGxdLmNvbmNhdChbdGhpc10uY29uY2F0KGFyZ3MpKSkpKCk7XG5cbiAgICAvLyBUaGUgcGx1Z2luIGlzIHJlcGxhY2VkIGJ5IGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcblxuICAgIHRyaWdnZXJTZXR1cEV2ZW50KHRoaXMsIGluc3RhbmNlLmdldEV2ZW50SGFzaCgpKTtcblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn07XG5cbi8qKlxuICogUGFyZW50IGNsYXNzIGZvciBhbGwgYWR2YW5jZWQgcGx1Z2lucy5cbiAqXG4gKiBAbWl4ZXMgICBtb2R1bGU6ZXZlbnRlZH5FdmVudGVkTWl4aW5cbiAqIEBtaXhlcyAgIG1vZHVsZTpzdGF0ZWZ1bH5TdGF0ZWZ1bE1peGluXG4gKiBAZmlyZXMgICBQbGF5ZXIjYmVmb3JlcGx1Z2luc2V0dXBcbiAqIEBmaXJlcyAgIFBsYXllciNiZWZvcmVwbHVnaW5zZXR1cDokbmFtZVxuICogQGZpcmVzICAgUGxheWVyI3BsdWdpbnNldHVwXG4gKiBAZmlyZXMgICBQbGF5ZXIjcGx1Z2luc2V0dXA6JG5hbWVcbiAqIEBsaXN0ZW5zIFBsYXllciNkaXNwb3NlXG4gKiBAdGhyb3dzICB7RXJyb3J9XG4gKiAgICAgICAgICBJZiBhdHRlbXB0aW5nIHRvIGluc3RhbnRpYXRlIHRoZSBiYXNlIHtAbGluayBQbHVnaW59IGNsYXNzXG4gKiAgICAgICAgICBkaXJlY3RseSBpbnN0ZWFkIG9mIHZpYSBhIHN1Yi1jbGFzcy5cbiAqL1xuXG52YXIgUGx1Z2luID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIFN1Yi1jbGFzc2VzIHNob3VsZCBjYWxsIGBzdXBlcmAgdG8gZW5zdXJlIHBsdWdpbnMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBBIFZpZGVvLmpzIHBsYXllciBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIFBsdWdpbihwbGF5ZXIpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbHVnaW4pO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IFBsdWdpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbHVnaW4gbXVzdCBiZSBzdWItY2xhc3NlZDsgbm90IGRpcmVjdGx5IGluc3RhbnRpYXRlZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnBsYXllciA9IHBsYXllcjtcblxuICAgIC8vIE1ha2UgdGhpcyBvYmplY3QgZXZlbnRlZCwgYnV0IHJlbW92ZSB0aGUgYWRkZWQgYHRyaWdnZXJgIG1ldGhvZCBzbyB3ZVxuICAgIC8vIHVzZSB0aGUgcHJvdG90eXBlIHZlcnNpb24gaW5zdGVhZC5cbiAgICBldmVudGVkKHRoaXMpO1xuICAgIGRlbGV0ZSB0aGlzLnRyaWdnZXI7XG5cbiAgICBzdGF0ZWZ1bCh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRTdGF0ZSk7XG4gICAgbWFya1BsdWdpbkFzQWN0aXZlKHBsYXllciwgdGhpcy5uYW1lKTtcblxuICAgIC8vIEF1dG8tYmluZCB0aGUgZGlzcG9zZSBtZXRob2Qgc28gd2UgY2FuIHVzZSBpdCBhcyBhIGxpc3RlbmVyIGFuZCB1bmJpbmRcbiAgICAvLyBpdCBsYXRlciBlYXNpbHkuXG4gICAgdGhpcy5kaXNwb3NlID0gYmluZCh0aGlzLCB0aGlzLmRpc3Bvc2UpO1xuXG4gICAgLy8gSWYgdGhlIHBsYXllciBpcyBkaXNwb3NlZCwgZGlzcG9zZSB0aGUgcGx1Z2luLlxuICAgIHBsYXllci5vbignZGlzcG9zZScsIHRoaXMuZGlzcG9zZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2ZXJzaW9uIG9mIHRoZSBwbHVnaW4gdGhhdCB3YXMgc2V0IG9uIDxwbHVnaW5OYW1lPi5WRVJTSU9OXG4gICAqL1xuXG5cbiAgUGx1Z2luLnByb3RvdHlwZS52ZXJzaW9uID0gZnVuY3Rpb24gdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5WRVJTSU9OO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFYWNoIGV2ZW50IHRyaWdnZXJlZCBieSBwbHVnaW5zIGluY2x1ZGVzIGEgaGFzaCBvZiBhZGRpdGlvbmFsIGRhdGEgd2l0aFxuICAgKiBjb252ZW50aW9uYWwgcHJvcGVydGllcy5cbiAgICpcbiAgICogVGhpcyByZXR1cm5zIHRoYXQgb2JqZWN0IG9yIG11dGF0ZXMgYW4gZXhpc3RpbmcgaGFzaC5cbiAgICpcbiAgICogQHBhcmFtICAge09iamVjdH0gW2hhc2g9e31dXG4gICAqICAgICAgICAgIEFuIG9iamVjdCB0byBiZSB1c2VkIGFzIGV2ZW50IGFuIGV2ZW50IGhhc2guXG4gICAqXG4gICAqIEByZXR1cm5zIHtQbHVnaW5+UGx1Z2luRXZlbnRIYXNofVxuICAgKiAgICAgICAgICBBbiBldmVudCBoYXNoIG9iamVjdCB3aXRoIHByb3ZpZGVkIHByb3BlcnRpZXMgbWl4ZWQtaW4uXG4gICAqL1xuXG5cbiAgUGx1Z2luLnByb3RvdHlwZS5nZXRFdmVudEhhc2ggPSBmdW5jdGlvbiBnZXRFdmVudEhhc2goKSB7XG4gICAgdmFyIGhhc2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgaGFzaC5uYW1lID0gdGhpcy5uYW1lO1xuICAgIGhhc2gucGx1Z2luID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBoYXNoLmluc3RhbmNlID0gdGhpcztcbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlcnMgYW4gZXZlbnQgb24gdGhlIHBsdWdpbiBvYmplY3QgYW5kIG92ZXJyaWRlc1xuICAgKiB7QGxpbmsgbW9kdWxlOmV2ZW50ZWR+RXZlbnRlZE1peGluLnRyaWdnZXJ8RXZlbnRlZE1peGluLnRyaWdnZXJ9LlxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfE9iamVjdH0gZXZlbnRcbiAgICogICAgICAgICAgQW4gZXZlbnQgdHlwZSBvciBhbiBvYmplY3Qgd2l0aCBhIHR5cGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9IFtoYXNoPXt9XVxuICAgKiAgICAgICAgICBBZGRpdGlvbmFsIGRhdGEgaGFzaCB0byBtZXJnZSB3aXRoIGFcbiAgICogICAgICAgICAge0BsaW5rIFBsdWdpbn5QbHVnaW5FdmVudEhhc2h8UGx1Z2luRXZlbnRIYXNofS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqICAgICAgICAgIFdoZXRoZXIgb3Igbm90IGRlZmF1bHQgd2FzIHByZXZlbnRlZC5cbiAgICovXG5cblxuICBQbHVnaW4ucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyJCQxKGV2ZW50KSB7XG4gICAgdmFyIGhhc2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgcmV0dXJuIHRyaWdnZXIodGhpcy5ldmVudEJ1c0VsXywgZXZlbnQsIHRoaXMuZ2V0RXZlbnRIYXNoKGhhc2gpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyBcInN0YXRlY2hhbmdlZFwiIGV2ZW50cyBvbiB0aGUgcGx1Z2luLiBOby1vcCBieSBkZWZhdWx0LCBvdmVycmlkZSBieVxuICAgKiBzdWJjbGFzc2luZy5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSAgICB7RXZlbnR9IGVcbiAgICogICAgICAgICAgIEFuIGV2ZW50IG9iamVjdCBwcm92aWRlZCBieSBhIFwic3RhdGVjaGFuZ2VkXCIgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAgICB7T2JqZWN0fSBlLmNoYW5nZXNcbiAgICogICAgICAgICAgIEFuIG9iamVjdCBkZXNjcmliaW5nIGNoYW5nZXMgdGhhdCBvY2N1cnJlZCB3aXRoIHRoZSBcInN0YXRlY2hhbmdlZFwiXG4gICAqICAgICAgICAgICBldmVudC5cbiAgICovXG5cblxuICBQbHVnaW4ucHJvdG90eXBlLmhhbmRsZVN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uIGhhbmRsZVN0YXRlQ2hhbmdlZChlKSB7fTtcblxuICAvKipcbiAgICogRGlzcG9zZXMgYSBwbHVnaW4uXG4gICAqXG4gICAqIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgaWYgdGhleSB3YW50LCBidXQgZm9yIHRoZSBzYWtlIG9mIHNhZmV0eSxcbiAgICogaXQncyBwcm9iYWJseSBiZXN0IHRvIHN1YnNjcmliZSB0aGUgXCJkaXNwb3NlXCIgZXZlbnQuXG4gICAqXG4gICAqIEBmaXJlcyBQbHVnaW4jZGlzcG9zZVxuICAgKi9cblxuXG4gIFBsdWdpbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUsXG4gICAgICAgIHBsYXllciA9IHRoaXMucGxheWVyO1xuXG4gICAgLyoqXG4gICAgICogU2lnbmFscyB0aGF0IGEgYWR2YW5jZWQgcGx1Z2luIGlzIGFib3V0IHRvIGJlIGRpc3Bvc2VkLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsdWdpbiNkaXNwb3NlXG4gICAgICogQHR5cGUgIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cblxuICAgIHRoaXMudHJpZ2dlcignZGlzcG9zZScpO1xuICAgIHRoaXMub2ZmKCk7XG4gICAgcGxheWVyLm9mZignZGlzcG9zZScsIHRoaXMuZGlzcG9zZSk7XG5cbiAgICAvLyBFbGltaW5hdGUgYW55IHBvc3NpYmxlIHNvdXJjZXMgb2YgbGVha2luZyBtZW1vcnkgYnkgY2xlYXJpbmcgdXBcbiAgICAvLyByZWZlcmVuY2VzIGJldHdlZW4gdGhlIHBsYXllciBhbmQgdGhlIHBsdWdpbiBpbnN0YW5jZSBhbmQgbnVsbGluZyBvdXRcbiAgICAvLyB0aGUgcGx1Z2luJ3Mgc3RhdGUgYW5kIHJlcGxhY2luZyBtZXRob2RzIHdpdGggYSBmdW5jdGlvbiB0aGF0IHRocm93cy5cbiAgICBwbGF5ZXJbUExVR0lOX0NBQ0hFX0tFWV1bbmFtZV0gPSBmYWxzZTtcbiAgICB0aGlzLnBsYXllciA9IHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gICAgLy8gRmluYWxseSwgcmVwbGFjZSB0aGUgcGx1Z2luIG5hbWUgb24gdGhlIHBsYXllciB3aXRoIGEgbmV3IGZhY3RvcnlcbiAgICAvLyBmdW5jdGlvbiwgc28gdGhhdCB0aGUgcGx1Z2luIGlzIHJlYWR5IHRvIGJlIHNldCB1cCBhZ2Fpbi5cbiAgICBwbGF5ZXJbbmFtZV0gPSBjcmVhdGVQbHVnaW5GYWN0b3J5KG5hbWUsIHBsdWdpblN0b3JhZ2VbbmFtZV0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGEgcGx1Z2luIGlzIGEgYmFzaWMgcGx1Z2luIChpLmUuIG5vdCBhIHN1Yi1jbGFzcyBvZiBgUGx1Z2luYCkuXG4gICAqXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd8RnVuY3Rpb259IHBsdWdpblxuICAgKiAgICAgICAgICBJZiBhIHN0cmluZywgbWF0Y2hlcyB0aGUgbmFtZSBvZiBhIHBsdWdpbi4gSWYgYSBmdW5jdGlvbiwgd2lsbCBiZVxuICAgKiAgICAgICAgICB0ZXN0ZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiAgICAgICAgICBXaGV0aGVyIG9yIG5vdCBhIHBsdWdpbiBpcyBhIGJhc2ljIHBsdWdpbi5cbiAgICovXG5cblxuICBQbHVnaW4uaXNCYXNpYyA9IGZ1bmN0aW9uIGlzQmFzaWMocGx1Z2luKSB7XG4gICAgdmFyIHAgPSB0eXBlb2YgcGx1Z2luID09PSAnc3RyaW5nJyA/IGdldFBsdWdpbihwbHVnaW4pIDogcGx1Z2luO1xuXG4gICAgcmV0dXJuIHR5cGVvZiBwID09PSAnZnVuY3Rpb24nICYmICFQbHVnaW4ucHJvdG90eXBlLmlzUHJvdG90eXBlT2YocC5wcm90b3R5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIFZpZGVvLmpzIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRvIGJlIHJlZ2lzdGVyZWQuIE11c3QgYmUgYSBzdHJpbmcgYW5kXG4gICAqICAgICAgICAgIG11c3Qgbm90IG1hdGNoIGFuIGV4aXN0aW5nIHBsdWdpbiBvciBhIG1ldGhvZCBvbiB0aGUgYFBsYXllcmBcbiAgICogICAgICAgICAgcHJvdG90eXBlLlxuICAgKlxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259IHBsdWdpblxuICAgKiAgICAgICAgICBBIHN1Yi1jbGFzcyBvZiBgUGx1Z2luYCBvciBhIGZ1bmN0aW9uIGZvciBiYXNpYyBwbHVnaW5zLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqICAgICAgICAgIEZvciBhZHZhbmNlZCBwbHVnaW5zLCBhIGZhY3RvcnkgZnVuY3Rpb24gZm9yIHRoYXQgcGx1Z2luLiBGb3JcbiAgICogICAgICAgICAgYmFzaWMgcGx1Z2lucywgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIHBsdWdpbi5cbiAgICovXG5cblxuICBQbHVnaW4ucmVnaXN0ZXJQbHVnaW4gPSBmdW5jdGlvbiByZWdpc3RlclBsdWdpbihuYW1lLCBwbHVnaW4pIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGx1Z2luIG5hbWUsIFwiJyArIG5hbWUgKyAnXCIsIG11c3QgYmUgYSBzdHJpbmcsIHdhcyAnICsgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgKyAnLicpO1xuICAgIH1cblxuICAgIGlmIChwbHVnaW5FeGlzdHMobmFtZSkpIHtcbiAgICAgIGxvZyQxLndhcm4oJ0EgcGx1Z2luIG5hbWVkIFwiJyArIG5hbWUgKyAnXCIgYWxyZWFkeSBleGlzdHMuIFlvdSBtYXkgd2FudCB0byBhdm9pZCByZS1yZWdpc3RlcmluZyBwbHVnaW5zIScpO1xuICAgIH0gZWxzZSBpZiAoUGxheWVyLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHBsdWdpbiBuYW1lLCBcIicgKyBuYW1lICsgJ1wiLCBjYW5ub3Qgc2hhcmUgYSBuYW1lIHdpdGggYW4gZXhpc3RpbmcgcGxheWVyIG1ldGhvZCEnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBsdWdpbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHBsdWdpbiBmb3IgXCInICsgbmFtZSArICdcIiwgbXVzdCBiZSBhIGZ1bmN0aW9uLCB3YXMgJyArICh0eXBlb2YgcGx1Z2luID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwbHVnaW4pKSArICcuJyk7XG4gICAgfVxuXG4gICAgcGx1Z2luU3RvcmFnZVtuYW1lXSA9IHBsdWdpbjtcblxuICAgIC8vIEFkZCBhIHBsYXllciBwcm90b3R5cGUgbWV0aG9kIGZvciBhbGwgc3ViLWNsYXNzZWQgcGx1Z2lucyAoYnV0IG5vdCBmb3JcbiAgICAvLyB0aGUgYmFzZSBQbHVnaW4gY2xhc3MpLlxuICAgIGlmIChuYW1lICE9PSBCQVNFX1BMVUdJTl9OQU1FKSB7XG4gICAgICBpZiAoUGx1Z2luLmlzQmFzaWMocGx1Z2luKSkge1xuICAgICAgICBQbGF5ZXIucHJvdG90eXBlW25hbWVdID0gY3JlYXRlQmFzaWNQbHVnaW4obmFtZSwgcGx1Z2luKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFBsYXllci5wcm90b3R5cGVbbmFtZV0gPSBjcmVhdGVQbHVnaW5GYWN0b3J5KG5hbWUsIHBsdWdpbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsdWdpbjtcbiAgfTtcblxuICAvKipcbiAgICogRGUtcmVnaXN0ZXIgYSBWaWRlby5qcyBwbHVnaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRvIGJlIGRlcmVnaXN0ZXJlZC5cbiAgICovXG5cblxuICBQbHVnaW4uZGVyZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uIGRlcmVnaXN0ZXJQbHVnaW4obmFtZSkge1xuICAgIGlmIChuYW1lID09PSBCQVNFX1BMVUdJTl9OQU1FKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZS1yZWdpc3RlciBiYXNlIHBsdWdpbi4nKTtcbiAgICB9XG4gICAgaWYgKHBsdWdpbkV4aXN0cyhuYW1lKSkge1xuICAgICAgZGVsZXRlIHBsdWdpblN0b3JhZ2VbbmFtZV07XG4gICAgICBkZWxldGUgUGxheWVyLnByb3RvdHlwZVtuYW1lXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbXVsdGlwbGUgVmlkZW8uanMgcGx1Z2lucy5cbiAgICpcbiAgICogQHBhcmFtICAge0FycmF5fSBbbmFtZXNdXG4gICAqICAgICAgICAgIElmIHByb3ZpZGVkLCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgcGx1Z2luIG5hbWVzLiBEZWZhdWx0cyB0byBfYWxsX1xuICAgKiAgICAgICAgICBwbHVnaW4gbmFtZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBwbHVnaW4ocykgYXNzb2NpYXRlZCB3aXRoIHRoZWlyIG5hbWUocykgb3JcbiAgICogICAgICAgICAgYHVuZGVmaW5lZGAgaWYgbm8gbWF0Y2hpbmcgcGx1Z2lucyBleGlzdCkuXG4gICAqL1xuXG5cbiAgUGx1Z2luLmdldFBsdWdpbnMgPSBmdW5jdGlvbiBnZXRQbHVnaW5zKCkge1xuICAgIHZhciBuYW1lcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogT2JqZWN0LmtleXMocGx1Z2luU3RvcmFnZSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuXG4gICAgbmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHBsdWdpbiA9IGdldFBsdWdpbihuYW1lKTtcblxuICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwge307XG4gICAgICAgIHJlc3VsdFtuYW1lXSA9IHBsdWdpbjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSBwbHVnaW4ncyB2ZXJzaW9uLCBpZiBhdmFpbGFibGVcbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogICAgICAgICAgVGhlIHBsdWdpbidzIHZlcnNpb24gb3IgYW4gZW1wdHkgc3RyaW5nLlxuICAgKi9cblxuXG4gIFBsdWdpbi5nZXRQbHVnaW5WZXJzaW9uID0gZnVuY3Rpb24gZ2V0UGx1Z2luVmVyc2lvbihuYW1lKSB7XG4gICAgdmFyIHBsdWdpbiA9IGdldFBsdWdpbihuYW1lKTtcblxuICAgIHJldHVybiBwbHVnaW4gJiYgcGx1Z2luLlZFUlNJT04gfHwgJyc7XG4gIH07XG5cbiAgcmV0dXJuIFBsdWdpbjtcbn0oKTtcblxuLyoqXG4gKiBHZXRzIGEgcGx1Z2luIGJ5IG5hbWUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgICBnZXRQbHVnaW5cbiAqIEBtZW1iZXJPZiBQbHVnaW5cbiAqIEBwYXJhbSAgICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybnMgIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKiAgICAgICAgICAgVGhlIHBsdWdpbiAob3IgYHVuZGVmaW5lZGApLlxuICovXG5cblxuUGx1Z2luLmdldFBsdWdpbiA9IGdldFBsdWdpbjtcblxuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgYmFzZSBwbHVnaW4gY2xhc3MgYXMgaXQgaXMgcmVnaXN0ZXJlZC5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5QbHVnaW4uQkFTRV9QTFVHSU5fTkFNRSA9IEJBU0VfUExVR0lOX05BTUU7XG5cblBsdWdpbi5yZWdpc3RlclBsdWdpbihCQVNFX1BMVUdJTl9OQU1FLCBQbHVnaW4pO1xuXG4vKipcbiAqIERvY3VtZW50ZWQgaW4gcGxheWVyLmpzXG4gKlxuICogQGlnbm9yZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLnVzaW5nUGx1Z2luID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICEhdGhpc1tQTFVHSU5fQ0FDSEVfS0VZXSAmJiB0aGlzW1BMVUdJTl9DQUNIRV9LRVldW25hbWVdID09PSB0cnVlO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudGVkIGluIHBsYXllci5qc1xuICpcbiAqIEBpZ25vcmVcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5oYXNQbHVnaW4gPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gISFwbHVnaW5FeGlzdHMobmFtZSk7XG59O1xuXG4vKipcbiAqIEBmaWxlIGV4dGVuZC5qc1xuICogQG1vZHVsZSBleHRlbmRcbiAqL1xuXG4vKipcbiAqIEEgY29tYmluYXRpb24gb2Ygbm9kZSBpbmhlcml0cyBhbmQgYmFiZWwncyBpbmhlcml0cyAoYWZ0ZXIgdHJhbnNwaWxlKS5cbiAqIEJvdGggd29yayB0aGUgc2FtZSBidXQgbm9kZSBhZGRzIGBzdXBlcl9gIHRvIHRoZSBzdWJDbGFzc1xuICogYW5kIEJhYmxlIGFkZHMgdGhlIHN1cGVyQ2xhc3MgYXMgX19wcm90b19fLiBCb3RoIHNlZW0gdXNlZnVsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJDbGFzc1xuICogICAgICAgIFRoZSBjbGFzcyB0byBpbmhlcml0IHRvXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN1cGVyQ2xhc3NcbiAqICAgICAgICBUaGUgY2xhc3MgdG8gaW5oZXJpdCBmcm9tXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIF9pbmhlcml0cyA9IGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3VwZXJDbGFzcykpKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBpZiAoc3VwZXJDbGFzcykge1xuICAgIC8vIG5vZGVcbiAgICBzdWJDbGFzcy5zdXBlcl8gPSBzdXBlckNsYXNzO1xuICB9XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIGZvciBzdWJjbGFzc2luZyB1c2luZyB0aGUgc2FtZSBpbmhlcml0YW5jZSB0aGF0XG4gKiB2aWRlb2pzIHVzZXMgaW50ZXJuYWxseVxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdXBlckNsYXNzXG4gKiAgICAgICAgVGhlIGNsYXNzIHRvIGluaGVyaXQgZnJvbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3ViQ2xhc3NNZXRob2RzPXt9XVxuICogICAgICAgIFRoZSBjbGFzcyB0byBpbmhlcml0IHRvXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBUaGUgbmV3IG9iamVjdCB3aXRoIHN1YkNsYXNzTWV0aG9kcyB0aGF0IGluaGVyaXRlZCBzdXBlckNsYXNzLlxuICovXG52YXIgZXh0ZW5kRm4gPSBmdW5jdGlvbiBleHRlbmRGbihzdXBlckNsYXNzKSB7XG4gIHZhciBzdWJDbGFzc01ldGhvZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIHZhciBzdWJDbGFzcyA9IGZ1bmN0aW9uIHN1YkNsYXNzKCkge1xuICAgIHN1cGVyQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgbWV0aG9kcyA9IHt9O1xuXG4gIGlmICgodHlwZW9mIHN1YkNsYXNzTWV0aG9kcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3ViQ2xhc3NNZXRob2RzKSkgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHN1YkNsYXNzTWV0aG9kcy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgc3ViQ2xhc3MgPSBzdWJDbGFzc01ldGhvZHMuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIG1ldGhvZHMgPSBzdWJDbGFzc01ldGhvZHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN1YkNsYXNzTWV0aG9kcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN1YkNsYXNzID0gc3ViQ2xhc3NNZXRob2RzO1xuICB9XG5cbiAgX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcblxuICAvLyBFeHRlbmQgc3ViT2JqJ3MgcHJvdG90eXBlIHdpdGggZnVuY3Rpb25zIGFuZCBvdGhlciBwcm9wZXJ0aWVzIGZyb20gcHJvcHNcbiAgZm9yICh2YXIgbmFtZSBpbiBtZXRob2RzKSB7XG4gICAgaWYgKG1ldGhvZHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHN1YkNsYXNzLnByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZHNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YkNsYXNzO1xufTtcblxuLyoqXG4gKiBAZmlsZSB2aWRlby5qc1xuICogQG1vZHVsZSB2aWRlb2pzXG4gKi9cblxuLyoqXG4gKiBOb3JtYWxpemUgYW4gYGlkYCB2YWx1ZSBieSB0cmltbWluZyBvZmYgYSBsZWFkaW5nIGAjYFxuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IGlkXG4gKiAgICAgICAgICBBIHN0cmluZywgbWF5YmUgd2l0aCBhIGxlYWRpbmcgYCNgLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgICAgICAgICBUaGUgc3RyaW5nLCB3aXRob3V0IGFueSBsZWFkaW5nIGAjYC5cbiAqL1xudmFyIG5vcm1hbGl6ZUlkID0gZnVuY3Rpb24gbm9ybWFsaXplSWQoaWQpIHtcbiAgcmV0dXJuIGlkLmluZGV4T2YoJyMnKSA9PT0gMCA/IGlkLnNsaWNlKDEpIDogaWQ7XG59O1xuXG4vKipcbiAqIERvdWJsZXMgYXMgdGhlIG1haW4gZnVuY3Rpb24gZm9yIHVzZXJzIHRvIGNyZWF0ZSBhIHBsYXllciBpbnN0YW5jZSBhbmQgYWxzb1xuICogdGhlIG1haW4gbGlicmFyeSBvYmplY3QuXG4gKiBUaGUgYHZpZGVvanNgIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGluaXRpYWxpemUgb3IgcmV0cmlldmUgYSBwbGF5ZXIuXG4gICpcbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IGlkXG4gKiAgICAgICAgVmlkZW8gZWxlbWVudCBvciB2aWRlbyBlbGVtZW50IElEXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IGZvciBjb25maWcvc2V0dGluZ3NcbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gKiAgICAgICAgT3B0aW9uYWwgcmVhZHkgY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gKiAgICAgICAgIEEgcGxheWVyIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHZpZGVvanMkMShpZCwgb3B0aW9ucywgcmVhZHkpIHtcbiAgdmFyIHBsYXllciA9IHZpZGVvanMkMS5nZXRQbGF5ZXIoaWQpO1xuXG4gIGlmIChwbGF5ZXIpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgbG9nJDEud2FybignUGxheWVyIFwiJyArIGlkICsgJ1wiIGlzIGFscmVhZHkgaW5pdGlhbGlzZWQuIE9wdGlvbnMgd2lsbCBub3QgYmUgYXBwbGllZC4nKTtcbiAgICB9XG4gICAgaWYgKHJlYWR5KSB7XG4gICAgICBwbGF5ZXIucmVhZHkocmVhZHkpO1xuICAgIH1cbiAgICByZXR1cm4gcGxheWVyO1xuICB9XG5cbiAgdmFyIGVsID0gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/ICQoJyMnICsgbm9ybWFsaXplSWQoaWQpKSA6IGlkO1xuXG4gIGlmICghaXNFbChlbCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZWxlbWVudCBvciBJRCBzdXBwbGllZCBpcyBub3QgdmFsaWQuICh2aWRlb2pzKScpO1xuICB9XG5cbiAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsKSkge1xuICAgIGxvZyQxLndhcm4oJ1RoZSBlbGVtZW50IHN1cHBsaWVkIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgRE9NJyk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2aWRlb2pzJDEuaG9va3MoJ2JlZm9yZXNldHVwJykuZm9yRWFjaChmdW5jdGlvbiAoaG9va0Z1bmN0aW9uKSB7XG4gICAgdmFyIG9wdHMgPSBob29rRnVuY3Rpb24oZWwsIG1lcmdlT3B0aW9ucyhvcHRpb25zKSk7XG5cbiAgICBpZiAoIWlzT2JqZWN0KG9wdHMpIHx8IEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgIGxvZyQxLmVycm9yKCdwbGVhc2UgcmV0dXJuIGFuIG9iamVjdCBpbiBiZWZvcmVzZXR1cCBob29rcycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywgb3B0cyk7XG4gIH0pO1xuXG4gIC8vIFdlIGdldCB0aGUgY3VycmVudCBcIlBsYXllclwiIGNvbXBvbmVudCBoZXJlIGluIGNhc2UgYW4gaW50ZWdyYXRpb24gaGFzXG4gIC8vIHJlcGxhY2VkIGl0IHdpdGggYSBjdXN0b20gcGxheWVyLlxuICB2YXIgUGxheWVyQ29tcG9uZW50ID0gQ29tcG9uZW50LmdldENvbXBvbmVudCgnUGxheWVyJyk7XG5cbiAgcGxheWVyID0gbmV3IFBsYXllckNvbXBvbmVudChlbCwgb3B0aW9ucywgcmVhZHkpO1xuXG4gIHZpZGVvanMkMS5ob29rcygnc2V0dXAnKS5mb3JFYWNoKGZ1bmN0aW9uIChob29rRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gaG9va0Z1bmN0aW9uKHBsYXllcik7XG4gIH0pO1xuXG4gIHJldHVybiBwbGF5ZXI7XG59XG5cbi8qKlxuICogQW4gT2JqZWN0IHRoYXQgY29udGFpbnMgbGlmZWN5Y2xlIGhvb2tzIGFzIGtleXMgd2hpY2ggcG9pbnQgdG8gYW4gYXJyYXlcbiAqIG9mIGZ1bmN0aW9ucyB0aGF0IGFyZSBydW4gd2hlbiBhIGxpZmVjeWNsZSBpcyB0cmlnZ2VyZWRcbiAqL1xudmlkZW9qcyQxLmhvb2tzXyA9IHt9O1xuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgaG9va3MgZm9yIGEgc3BlY2lmaWMgbGlmZWN5Y2xlXG4gKiBAZnVuY3Rpb24gdmlkZW9qcy5ob29rc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgdGhlIGxpZmVjeWxlIHRvIGdldCBob29rcyBmcm9tXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxGdW5jdGlvbltdfSBbZm5dXG4gKiAgICAgICAgT3B0aW9uYWxseSBhZGQgYSBob29rIChvciBob29rcykgdG8gdGhlIGxpZmVjeWNsZSB0aGF0IHlvdXIgYXJlIGdldHRpbmcuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiAgICAgICAgIGFuIGFycmF5IG9mIGhvb2tzLCBvciBhbiBlbXB0eSBhcnJheSBpZiB0aGVyZSBhcmUgbm9uZS5cbiAqL1xudmlkZW9qcyQxLmhvb2tzID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gIHZpZGVvanMkMS5ob29rc19bdHlwZV0gPSB2aWRlb2pzJDEuaG9va3NfW3R5cGVdIHx8IFtdO1xuICBpZiAoZm4pIHtcbiAgICB2aWRlb2pzJDEuaG9va3NfW3R5cGVdID0gdmlkZW9qcyQxLmhvb2tzX1t0eXBlXS5jb25jYXQoZm4pO1xuICB9XG4gIHJldHVybiB2aWRlb2pzJDEuaG9va3NfW3R5cGVdO1xufTtcblxuLyoqXG4gKiBBZGQgYSBmdW5jdGlvbiBob29rIHRvIGEgc3BlY2lmaWMgdmlkZW9qcyBsaWZlY3ljbGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICB0aGUgbGlmZWN5Y2xlIHRvIGhvb2sgdGhlIGZ1bmN0aW9uIHRvLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258RnVuY3Rpb25bXX1cbiAqICAgICAgICBUaGUgZnVuY3Rpb24gb3IgYXJyYXkgb2YgZnVuY3Rpb25zIHRvIGF0dGFjaC5cbiAqL1xudmlkZW9qcyQxLmhvb2sgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgdmlkZW9qcyQxLmhvb2tzKHR5cGUsIGZuKTtcbn07XG5cbi8qKlxuICogQWRkIGEgZnVuY3Rpb24gaG9vayB0aGF0IHdpbGwgb25seSBydW4gb25jZSB0byBhIHNwZWNpZmljIHZpZGVvanMgbGlmZWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgdGhlIGxpZmVjeWNsZSB0byBob29rIHRoZSBmdW5jdGlvbiB0by5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEZ1bmN0aW9uW119XG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIG9yIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBhdHRhY2guXG4gKi9cbnZpZGVvanMkMS5ob29rT25jZSA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICB2aWRlb2pzJDEuaG9va3ModHlwZSwgW10uY29uY2F0KGZuKS5tYXAoZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgdmlkZW9qcyQxLnJlbW92ZUhvb2sodHlwZSwgd3JhcHBlcik7XG4gICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfSkpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBob29rIGZyb20gYSBzcGVjaWZpYyB2aWRlb2pzIGxpZmVjeWNsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIHRoZSBsaWZlY3ljbGUgdGhhdCB0aGUgZnVuY3Rpb24gaG9va2VkIHRvXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqICAgICAgICBUaGUgaG9va2VkIGZ1bmN0aW9uIHRvIHJlbW92ZVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdhcyByZW1vdmVkIG9yIHVuZGVmXG4gKi9cbnZpZGVvanMkMS5yZW1vdmVIb29rID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gIHZhciBpbmRleCA9IHZpZGVvanMkMS5ob29rcyh0eXBlKS5pbmRleE9mKGZuKTtcblxuICBpZiAoaW5kZXggPD0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2aWRlb2pzJDEuaG9va3NfW3R5cGVdID0gdmlkZW9qcyQxLmhvb2tzX1t0eXBlXS5zbGljZSgpO1xuICB2aWRlb2pzJDEuaG9va3NfW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBBZGQgZGVmYXVsdCBzdHlsZXNcbmlmICh3aW5kb3ckMS5WSURFT0pTX05PX0RZTkFNSUNfU1RZTEUgIT09IHRydWUgJiYgaXNSZWFsKCkpIHtcbiAgdmFyIHN0eWxlJDEgPSAkKCcudmpzLXN0eWxlcy1kZWZhdWx0cycpO1xuXG4gIGlmICghc3R5bGUkMSkge1xuICAgIHN0eWxlJDEgPSBjcmVhdGVTdHlsZUVsZW1lbnQoJ3Zqcy1zdHlsZXMtZGVmYXVsdHMnKTtcbiAgICB2YXIgaGVhZCA9ICQoJ2hlYWQnKTtcblxuICAgIGlmIChoZWFkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSQxLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBzZXRUZXh0Q29udGVudChzdHlsZSQxLCAnXFxuICAgICAgLnZpZGVvLWpzIHtcXG4gICAgICAgIHdpZHRoOiAzMDBweDtcXG4gICAgICAgIGhlaWdodDogMTUwcHg7XFxuICAgICAgfVxcblxcbiAgICAgIC52anMtZmx1aWQge1xcbiAgICAgICAgcGFkZGluZy10b3A6IDU2LjI1JVxcbiAgICAgIH1cXG4gICAgJyk7XG4gIH1cbn1cblxuLy8gUnVuIEF1dG8tbG9hZCBwbGF5ZXJzXG4vLyBZb3UgaGF2ZSB0byB3YWl0IGF0IGxlYXN0IG9uY2UgaW4gY2FzZSB0aGlzIHNjcmlwdCBpcyBsb2FkZWQgYWZ0ZXIgeW91clxuLy8gdmlkZW8gaW4gdGhlIERPTSAod2VpcmQgYmVoYXZpb3Igb25seSB3aXRoIG1pbmlmaWVkIHZlcnNpb24pXG5hdXRvU2V0dXBUaW1lb3V0KDEsIHZpZGVvanMkMSk7XG5cbi8qKlxuICogQ3VycmVudCBzb2Z0d2FyZSB2ZXJzaW9uLiBGb2xsb3dzIHNlbXZlci5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52aWRlb2pzJDEuVkVSU0lPTiA9IHZlcnNpb247XG5cbi8qKlxuICogVGhlIGdsb2JhbCBvcHRpb25zIG9iamVjdC4gVGhlc2UgYXJlIHRoZSBzZXR0aW5ncyB0aGF0IHRha2UgZWZmZWN0XG4gKiBpZiBubyBvdmVycmlkZXMgYXJlIHNwZWNpZmllZCB3aGVuIHRoZSBwbGF5ZXIgaXMgY3JlYXRlZC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52aWRlb2pzJDEub3B0aW9ucyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc187XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50bHkgY3JlYXRlZCBwbGF5ZXJzLCBrZXllZCBieSBwbGF5ZXIgSURcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIFRoZSBjcmVhdGVkIHBsYXllcnNcbiAqL1xudmlkZW9qcyQxLmdldFBsYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBQbGF5ZXIucGxheWVycztcbn07XG5cbi8qKlxuICogR2V0IGEgc2luZ2xlIHBsYXllciBiYXNlZCBvbiBhbiBJRCBvciBET00gZWxlbWVudC5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBjaGVjayBpZiBhbiBlbGVtZW50IG9yIElEIGhhcyBhbiBhc3NvY2lhdGVkXG4gKiBWaWRlby5qcyBwbGF5ZXIsIGJ1dCBub3QgY3JlYXRlIG9uZSBpZiBpdCBkb2Vzbid0LlxuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmd8RWxlbWVudH0gaWRcbiAqICAgICAgICAgIEFuIEhUTUwgZWxlbWVudCAtIGA8dmlkZW8+YCwgYDxhdWRpbz5gLCBvciBgPHZpZGVvLWpzPmAgLVxuICogICAgICAgICAgb3IgYSBzdHJpbmcgbWF0Y2hpbmcgdGhlIGBpZGAgb2Ygc3VjaCBhbiBlbGVtZW50LlxuICpcbiAqIEByZXR1cm5zIHtQbGF5ZXJ8dW5kZWZpbmVkfVxuICogICAgICAgICAgQSBwbGF5ZXIgaW5zdGFuY2Ugb3IgYHVuZGVmaW5lZGAgaWYgdGhlcmUgaXMgbm8gcGxheWVyIGluc3RhbmNlXG4gKiAgICAgICAgICBtYXRjaGluZyB0aGUgYXJndW1lbnQuXG4gKi9cbnZpZGVvanMkMS5nZXRQbGF5ZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIHBsYXllcnMgPSBQbGF5ZXIucGxheWVycztcbiAgdmFyIHRhZyA9IHZvaWQgMDtcblxuICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgIHZhciBuSWQgPSBub3JtYWxpemVJZChpZCk7XG4gICAgdmFyIHBsYXllciA9IHBsYXllcnNbbklkXTtcblxuICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgfVxuXG4gICAgdGFnID0gJCgnIycgKyBuSWQpO1xuICB9IGVsc2Uge1xuICAgIHRhZyA9IGlkO1xuICB9XG5cbiAgaWYgKGlzRWwodGFnKSkge1xuICAgIHZhciBfdGFnID0gdGFnLFxuICAgICAgICBfcGxheWVyID0gX3RhZy5wbGF5ZXIsXG4gICAgICAgIHBsYXllcklkID0gX3RhZy5wbGF5ZXJJZDtcblxuICAgIC8vIEVsZW1lbnQgbWF5IGhhdmUgYSBgcGxheWVyYCBwcm9wZXJ0eSByZWZlcnJpbmcgdG8gYW4gYWxyZWFkeSBjcmVhdGVkXG4gICAgLy8gcGxheWVyIGluc3RhbmNlLiBJZiBzbywgcmV0dXJuIHRoYXQuXG5cbiAgICBpZiAoX3BsYXllciB8fCBwbGF5ZXJzW3BsYXllcklkXSkge1xuICAgICAgcmV0dXJuIF9wbGF5ZXIgfHwgcGxheWVyc1twbGF5ZXJJZF07XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGN1cnJlbnQgcGxheWVycy5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqICAgICAgICAgQW4gYXJyYXkgb2YgYWxsIHBsYXllcnMuIFRoZSBhcnJheSB3aWxsIGJlIGluIHRoZSBvcmRlciB0aGF0XG4gKiAgICAgICAgIGBPYmplY3Qua2V5c2AgcHJvdmlkZXMsIHdoaWNoIGNvdWxkIHBvdGVudGlhbGx5IHZhcnkgYmV0d2VlblxuICogICAgICAgICBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gKlxuICovXG52aWRlb2pzJDEuZ2V0QWxsUGxheWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIChcblxuICAgIC8vIERpc3Bvc2VkIHBsYXllcnMgbGVhdmUgYSBrZXkgd2l0aCBhIGBudWxsYCB2YWx1ZSwgc28gd2UgbmVlZCB0byBtYWtlIHN1cmVcbiAgICAvLyB3ZSBmaWx0ZXIgdGhvc2Ugb3V0LlxuICAgIE9iamVjdC5rZXlzKFBsYXllci5wbGF5ZXJzKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgIHJldHVybiBQbGF5ZXIucGxheWVyc1trXTtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbilcbiAgKTtcbn07XG5cbi8qKlxuICogRXhwb3NlIHBsYXllcnMgb2JqZWN0LlxuICpcbiAqIEBtZW1iZXJPZiB2aWRlb2pzXG4gKiBAcHJvcGVydHkge09iamVjdH0gcGxheWVyc1xuICovXG52aWRlb2pzJDEucGxheWVycyA9IFBsYXllci5wbGF5ZXJzO1xuXG4vKipcbiAqIEdldCBhIGNvbXBvbmVudCBjbGFzcyBvYmplY3QgYnkgbmFtZVxuICpcbiAqIEBib3Jyb3dzIENvbXBvbmVudC5nZXRDb21wb25lbnQgYXMgdmlkZW9qcy5nZXRDb21wb25lbnRcbiAqL1xudmlkZW9qcyQxLmdldENvbXBvbmVudCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQ7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBjb21wb25lbnQgc28gaXQgY2FuIHJlZmVycmVkIHRvIGJ5IG5hbWUuIFVzZWQgd2hlbiBhZGRpbmcgdG8gb3RoZXJcbiAqIGNvbXBvbmVudHMsIGVpdGhlciB0aHJvdWdoIGFkZENoaWxkIGBjb21wb25lbnQuYWRkQ2hpbGQoJ215Q29tcG9uZW50JylgIG9yIHRocm91Z2hcbiAqIGRlZmF1bHQgY2hpbGRyZW4gb3B0aW9ucyAgYHsgY2hpbGRyZW46IFsnbXlDb21wb25lbnQnXSB9YC5cbiAqXG4gKiA+IE5PVEU6IFlvdSBjb3VsZCBhbHNvIGp1c3QgaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50IGJlZm9yZSBhZGRpbmcuXG4gKiBgY29tcG9uZW50LmFkZENoaWxkKG5ldyBNeUNvbXBvbmVudCgpKTtgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICBUaGUgY2xhc3MgbmFtZSBvZiB0aGUgY29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtDb21wb25lbnR9IGNvbXBcbiAqICAgICAgICBUaGUgY29tcG9uZW50IGNsYXNzXG4gKlxuICogQHJldHVybiB7Q29tcG9uZW50fVxuICogICAgICAgICBUaGUgbmV3bHkgcmVnaXN0ZXJlZCBjb21wb25lbnRcbiAqL1xudmlkZW9qcyQxLnJlZ2lzdGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKG5hbWUkJDEsIGNvbXApIHtcbiAgaWYgKFRlY2guaXNUZWNoKGNvbXApKSB7XG4gICAgbG9nJDEud2FybignVGhlICcgKyBuYW1lJCQxICsgJyB0ZWNoIHdhcyByZWdpc3RlcmVkIGFzIGEgY29tcG9uZW50LiBJdCBzaG91bGQgaW5zdGVhZCBiZSByZWdpc3RlcmVkIHVzaW5nIHZpZGVvanMucmVnaXN0ZXJUZWNoKG5hbWUsIHRlY2gpJyk7XG4gIH1cblxuICBDb21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQuY2FsbChDb21wb25lbnQsIG5hbWUkJDEsIGNvbXApO1xufTtcblxuLyoqXG4gKiBHZXQgYSBUZWNoIGNsYXNzIG9iamVjdCBieSBuYW1lXG4gKlxuICogQGJvcnJvd3MgVGVjaC5nZXRUZWNoIGFzIHZpZGVvanMuZ2V0VGVjaFxuICovXG52aWRlb2pzJDEuZ2V0VGVjaCA9IFRlY2guZ2V0VGVjaDtcblxuLyoqXG4gKiBSZWdpc3RlciBhIFRlY2ggc28gaXQgY2FuIHJlZmVycmVkIHRvIGJ5IG5hbWUuXG4gKiBUaGlzIGlzIHVzZWQgaW4gdGhlIHRlY2ggb3JkZXIgZm9yIHRoZSBwbGF5ZXIuXG4gKlxuICogQGJvcnJvd3MgVGVjaC5yZWdpc3RlclRlY2ggYXMgdmlkZW9qcy5yZWdpc3RlclRlY2hcbiAqL1xudmlkZW9qcyQxLnJlZ2lzdGVyVGVjaCA9IFRlY2gucmVnaXN0ZXJUZWNoO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbWlkZGxld2FyZSB0byBhIHNvdXJjZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhIE1JTUUgdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ocGxheWVyKTpvYmplY3R9IG1pZGRsZXdhcmUgQSBtaWRkbGV3YXJlIGZhY3RvcnkgdGhhdCB0YWtlcyBhIHBsYXllci5cbiAqL1xudmlkZW9qcyQxLnVzZSA9IHVzZTtcblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjYW4gYmUgcmV0dXJuZWQgYnkgYSBtaWRkbGV3YXJlIHRvIHNpZ25pZnlcbiAqIHRoYXQgdGhlIG1pZGRsZXdhcmUgaXMgYmVpbmcgdGVybWluYXRlZC5cbiAqXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQG1lbWJlck9mIHt2aWRlb2pzfVxuICogQHByb3BlcnR5IHtvYmplY3R9IG1pZGRsZXdhcmUuVEVSTUlOQVRPUlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkodmlkZW9qcyQxLCAnbWlkZGxld2FyZScsIHtcbiAgdmFsdWU6IHt9LFxuICB3cml0ZWFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHZpZGVvanMkMS5taWRkbGV3YXJlLCAnVEVSTUlOQVRPUicsIHtcbiAgdmFsdWU6IFRFUk1JTkFUT1IsXG4gIHdyaXRlYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIEEgc3VpdGUgb2YgYnJvd3NlciBhbmQgZGV2aWNlIHRlc3RzIGZyb20ge0BsaW5rIGJyb3dzZXJ9LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52aWRlb2pzJDEuYnJvd3NlciA9IGJyb3dzZXI7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdG91Y2ggZXZlbnRzLiBJbmNsdWRlZCBmb3IgYmFja3dhcmRcbiAqIGNvbXBhdGliaWxpdHkgd2l0aCA0LngsIGJ1dCBkZXByZWNhdGVkLiBVc2UgYHZpZGVvanMuYnJvd3Nlci5UT1VDSF9FTkFCTEVEYFxuICogaW5zdGVhZCBnb2luZyBmb3J3YXJkLlxuICpcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNS4wXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudmlkZW9qcyQxLlRPVUNIX0VOQUJMRUQgPSBUT1VDSF9FTkFCTEVEO1xuXG4vKipcbiAqIFN1YmNsYXNzIGFuIGV4aXN0aW5nIGNsYXNzXG4gKiBNaW1pY3MgRVM2IHN1YmNsYXNzaW5nIHdpdGggdGhlIGBleHRlbmRgIGtleXdvcmRcbiAqXG4gKiBAYm9ycm93cyBleHRlbmQ6ZXh0ZW5kRm4gYXMgdmlkZW9qcy5leHRlbmRcbiAqL1xudmlkZW9qcyQxLmV4dGVuZCA9IGV4dGVuZEZuO1xuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb25zIG9iamVjdHMgcmVjdXJzaXZlbHlcbiAqIFBlcmZvcm1zIGEgZGVlcCBtZXJnZSBsaWtlIGxvZGFzaC5tZXJnZSBidXQgKipvbmx5IG1lcmdlcyBwbGFpbiBvYmplY3RzKipcbiAqIChub3QgYXJyYXlzLCBlbGVtZW50cywgYW55dGhpbmcgZWxzZSlcbiAqIE90aGVyIHZhbHVlcyB3aWxsIGJlIGNvcGllZCBkaXJlY3RseSBmcm9tIHRoZSBzZWNvbmQgb2JqZWN0LlxuICpcbiAqIEBib3Jyb3dzIG1lcmdlLW9wdGlvbnM6bWVyZ2VPcHRpb25zIGFzIHZpZGVvanMubWVyZ2VPcHRpb25zXG4gKi9cbnZpZGVvanMkMS5tZXJnZU9wdGlvbnMgPSBtZXJnZU9wdGlvbnM7XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBjb250ZXh0ICh0aGlzKSBvZiBhIGZ1bmN0aW9uXG4gKlxuICogPiBOT1RFOiBhcyBvZiB2NS4wIHdlIHJlcXVpcmUgYW4gRVM1IHNoaW0sIHNvIHlvdSBzaG91bGQgdXNlIHRoZSBuYXRpdmVcbiAqIGBmdW5jdGlvbigpIHt9LmJpbmQobmV3Q29udGV4dCk7YCBpbnN0ZWFkIG9mIHRoaXMuXG4gKlxuICogQGJvcnJvd3MgZm46YmluZCBhcyB2aWRlb2pzLmJpbmRcbiAqL1xudmlkZW9qcyQxLmJpbmQgPSBiaW5kO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgVmlkZW8uanMgcGx1Z2luLlxuICpcbiAqIEBib3Jyb3dzIHBsdWdpbjpyZWdpc3RlclBsdWdpbiBhcyB2aWRlb2pzLnJlZ2lzdGVyUGx1Z2luXG4gKiBAbWV0aG9kIHJlZ2lzdGVyUGx1Z2luXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gYmUgcmVnaXN0ZXJlZC4gTXVzdCBiZSBhIHN0cmluZyBhbmRcbiAqICAgICAgICAgbXVzdCBub3QgbWF0Y2ggYW4gZXhpc3RpbmcgcGx1Z2luIG9yIGEgbWV0aG9kIG9uIHRoZSBgUGxheWVyYFxuICogICAgICAgICBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IHBsdWdpblxuICogICAgICAgICBBIHN1Yi1jbGFzcyBvZiBgUGx1Z2luYCBvciBhIGZ1bmN0aW9uIGZvciBiYXNpYyBwbHVnaW5zLlxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogICAgICAgICBGb3IgYWR2YW5jZWQgcGx1Z2lucywgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciB0aGF0IHBsdWdpbi4gRm9yXG4gKiAgICAgICAgIGJhc2ljIHBsdWdpbnMsIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IGluaXRpYWxpemVzIHRoZSBwbHVnaW4uXG4gKi9cbnZpZGVvanMkMS5yZWdpc3RlclBsdWdpbiA9IFBsdWdpbi5yZWdpc3RlclBsdWdpbjtcblxuLyoqXG4gKiBEZXByZWNhdGVkIG1ldGhvZCB0byByZWdpc3RlciBhIHBsdWdpbiB3aXRoIFZpZGVvLmpzXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqICAgICAgICB2aWRlb2pzLnBsdWdpbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSB2aWRlb2pzLnJlZ2lzdGVyUGx1Z2luKCkgaW5zdGVhZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgVGhlIHBsdWdpbiBuYW1lXG4gKlxuICogQHBhcmFtIHtQbHVnaW58RnVuY3Rpb259IHBsdWdpblxuICogICAgICAgICBUaGUgcGx1Z2luIHN1Yi1jbGFzcyBvciBmdW5jdGlvblxuICovXG52aWRlb2pzJDEucGx1Z2luID0gZnVuY3Rpb24gKG5hbWUkJDEsIHBsdWdpbikge1xuICBsb2ckMS53YXJuKCd2aWRlb2pzLnBsdWdpbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSB2aWRlb2pzLnJlZ2lzdGVyUGx1Z2luKCkgaW5zdGVhZCcpO1xuICByZXR1cm4gUGx1Z2luLnJlZ2lzdGVyUGx1Z2luKG5hbWUkJDEsIHBsdWdpbik7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbXVsdGlwbGUgVmlkZW8uanMgcGx1Z2lucy5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gW25hbWVzXVxuICogICAgICAgICBJZiBwcm92aWRlZCwgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHBsdWdpbiBuYW1lcy4gRGVmYXVsdHMgdG8gX2FsbF9cbiAqICAgICAgICAgcGx1Z2luIG5hbWVzLlxuICpcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKiAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHBsdWdpbihzKSBhc3NvY2lhdGVkIHdpdGggdGhlaXIgbmFtZShzKSBvclxuICogICAgICAgICBgdW5kZWZpbmVkYCBpZiBubyBtYXRjaGluZyBwbHVnaW5zIGV4aXN0KS5cbiAqL1xudmlkZW9qcyQxLmdldFBsdWdpbnMgPSBQbHVnaW4uZ2V0UGx1Z2lucztcblxuLyoqXG4gKiBHZXRzIGEgcGx1Z2luIGJ5IG5hbWUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICogICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKiAgICAgICAgIFRoZSBwbHVnaW4gKG9yIGB1bmRlZmluZWRgKS5cbiAqL1xudmlkZW9qcyQxLmdldFBsdWdpbiA9IFBsdWdpbi5nZXRQbHVnaW47XG5cbi8qKlxuICogR2V0cyBhIHBsdWdpbidzIHZlcnNpb24sIGlmIGF2YWlsYWJsZVxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICogICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFRoZSBwbHVnaW4ncyB2ZXJzaW9uIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAqL1xudmlkZW9qcyQxLmdldFBsdWdpblZlcnNpb24gPSBQbHVnaW4uZ2V0UGx1Z2luVmVyc2lvbjtcblxuLyoqXG4gKiBBZGRpbmcgbGFuZ3VhZ2VzIHNvIHRoYXQgdGhleSdyZSBhdmFpbGFibGUgdG8gYWxsIHBsYXllcnMuXG4gKiBFeGFtcGxlOiBgdmlkZW9qcy5hZGRMYW5ndWFnZSgnZXMnLCB7ICdIZWxsbyc6ICdIb2xhJyB9KTtgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAqICAgICAgICBUaGUgbGFuZ3VhZ2UgY29kZSBvciBkaWN0aW9uYXJ5IHByb3BlcnR5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqICAgICAgICBUaGUgZGF0YSB2YWx1ZXMgdG8gYmUgdHJhbnNsYXRlZFxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgVGhlIHJlc3VsdGluZyBsYW5ndWFnZSBkaWN0aW9uYXJ5IG9iamVjdFxuICovXG52aWRlb2pzJDEuYWRkTGFuZ3VhZ2UgPSBmdW5jdGlvbiAoY29kZSwgZGF0YSkge1xuICB2YXIgX21lcmdlT3B0aW9ucztcblxuICBjb2RlID0gKCcnICsgY29kZSkudG9Mb3dlckNhc2UoKTtcblxuICB2aWRlb2pzJDEub3B0aW9ucy5sYW5ndWFnZXMgPSBtZXJnZU9wdGlvbnModmlkZW9qcyQxLm9wdGlvbnMubGFuZ3VhZ2VzLCAoX21lcmdlT3B0aW9ucyA9IHt9LCBfbWVyZ2VPcHRpb25zW2NvZGVdID0gZGF0YSwgX21lcmdlT3B0aW9ucykpO1xuXG4gIHJldHVybiB2aWRlb2pzJDEub3B0aW9ucy5sYW5ndWFnZXNbY29kZV07XG59O1xuXG4vKipcbiAqIExvZyBtZXNzYWdlc1xuICpcbiAqIEBib3Jyb3dzIGxvZzpsb2cgYXMgdmlkZW9qcy5sb2dcbiAqL1xudmlkZW9qcyQxLmxvZyA9IGxvZyQxO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW11bGF0ZWQgVGltZVJhbmdlIG9iamVjdC5cbiAqXG4gKiBAYm9ycm93cyB0aW1lLXJhbmdlczpjcmVhdGVUaW1lUmFuZ2VzIGFzIHZpZGVvanMuY3JlYXRlVGltZVJhbmdlXG4gKi9cbi8qKlxuICogQGJvcnJvd3MgdGltZS1yYW5nZXM6Y3JlYXRlVGltZVJhbmdlcyBhcyB2aWRlb2pzLmNyZWF0ZVRpbWVSYW5nZXNcbiAqL1xudmlkZW9qcyQxLmNyZWF0ZVRpbWVSYW5nZSA9IHZpZGVvanMkMS5jcmVhdGVUaW1lUmFuZ2VzID0gY3JlYXRlVGltZVJhbmdlcztcblxuLyoqXG4gKiBGb3JtYXQgc2Vjb25kcyBhcyBhIHRpbWUgc3RyaW5nLCBIOk1NOlNTIG9yIE06U1NcbiAqIFN1cHBseWluZyBhIGd1aWRlIChpbiBzZWNvbmRzKSB3aWxsIGZvcmNlIGEgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3NcbiAqIHRvIGNvdmVyIHRoZSBsZW5ndGggb2YgdGhlIGd1aWRlXG4gKlxuICogQGJvcnJvd3MgZm9ybWF0LXRpbWU6Zm9ybWF0VGltZSBhcyB2aWRlb2pzLmZvcm1hdFRpbWVcbiAqL1xudmlkZW9qcyQxLmZvcm1hdFRpbWUgPSBmb3JtYXRUaW1lO1xuXG4vKipcbiAqIFJlcGxhY2VzIGZvcm1hdC10aW1lIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24sIHRvIGJlIHVzZWQgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQuXG4gKlxuICogQGJvcnJvd3MgZm9ybWF0LXRpbWU6c2V0Rm9ybWF0VGltZSBhcyB2aWRlb2pzLnNldEZvcm1hdFRpbWVcbiAqXG4gKiBAbWV0aG9kIHNldEZvcm1hdFRpbWVcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21GblxuICogICAgICAgIEEgY3VzdG9tIGZvcm1hdC10aW1lIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGN1cnJlbnQgdGltZSBhbmQgZ3VpZGUgKGluIHNlY29uZHMpIGFzIGFyZ3VtZW50cy5cbiAqICAgICAgICBQYXNzZWQgZm4gc2hvdWxkIHJldHVybiBhIHN0cmluZy5cbiAqL1xudmlkZW9qcyQxLnNldEZvcm1hdFRpbWUgPSBzZXRGb3JtYXRUaW1lO1xuXG4vKipcbiAqIFJlc2V0cyBmb3JtYXQtdGltZSB0byB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAYm9ycm93cyBmb3JtYXQtdGltZTpyZXNldEZvcm1hdFRpbWUgYXMgdmlkZW9qcy5yZXNldEZvcm1hdFRpbWVcbiAqXG4gKiBAbWV0aG9kIHJlc2V0Rm9ybWF0VGltZVxuICovXG52aWRlb2pzJDEucmVzZXRGb3JtYXRUaW1lID0gcmVzZXRGb3JtYXRUaW1lO1xuXG4vKipcbiAqIFJlc29sdmUgYW5kIHBhcnNlIHRoZSBlbGVtZW50cyBvZiBhIFVSTFxuICpcbiAqIEBib3Jyb3dzIHVybDpwYXJzZVVybCBhcyB2aWRlb2pzLnBhcnNlVXJsXG4gKlxuICovXG52aWRlb2pzJDEucGFyc2VVcmwgPSBwYXJzZVVybDtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHVybCBwYXNzZWQgaXMgYSBjcm9zcyBkb21haW4gcmVxdWVzdCBvciBub3QuXG4gKlxuICogQGJvcnJvd3MgdXJsOmlzQ3Jvc3NPcmlnaW4gYXMgdmlkZW9qcy5pc0Nyb3NzT3JpZ2luXG4gKi9cbnZpZGVvanMkMS5pc0Nyb3NzT3JpZ2luID0gaXNDcm9zc09yaWdpbjtcblxuLyoqXG4gKiBFdmVudCB0YXJnZXQgY2xhc3MuXG4gKlxuICogQGJvcnJvd3MgRXZlbnRUYXJnZXQgYXMgdmlkZW9qcy5FdmVudFRhcmdldFxuICovXG52aWRlb2pzJDEuRXZlbnRUYXJnZXQgPSBFdmVudFRhcmdldDtcblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gZWxlbWVudFxuICogSXQgc3RvcmVzIHRoZSBoYW5kbGVyIGZ1bmN0aW9uIGluIGEgc2VwYXJhdGUgY2FjaGUgb2JqZWN0XG4gKiBhbmQgYWRkcyBhIGdlbmVyaWMgaGFuZGxlciB0byB0aGUgZWxlbWVudCdzIGV2ZW50LFxuICogYWxvbmcgd2l0aCBhIHVuaXF1ZSBpZCAoZ3VpZCkgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogQGJvcnJvd3MgZXZlbnRzOm9uIGFzIHZpZGVvanMub25cbiAqL1xudmlkZW9qcyQxLm9uID0gb247XG5cbi8qKlxuICogVHJpZ2dlciBhIGxpc3RlbmVyIG9ubHkgb25jZSBmb3IgYW4gZXZlbnRcbiAqXG4gKiBAYm9ycm93cyBldmVudHM6b25lIGFzIHZpZGVvanMub25lXG4gKi9cbnZpZGVvanMkMS5vbmUgPSBvbmU7XG5cbi8qKlxuICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgZnJvbSBhbiBlbGVtZW50XG4gKlxuICogQGJvcnJvd3MgZXZlbnRzOm9mZiBhcyB2aWRlb2pzLm9mZlxuICovXG52aWRlb2pzJDEub2ZmID0gb2ZmO1xuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnQgZm9yIGFuIGVsZW1lbnRcbiAqXG4gKiBAYm9ycm93cyBldmVudHM6dHJpZ2dlciBhcyB2aWRlb2pzLnRyaWdnZXJcbiAqL1xudmlkZW9qcyQxLnRyaWdnZXIgPSB0cmlnZ2VyO1xuXG4vKipcbiAqIEEgY3Jvc3MtYnJvd3NlciBYTUxIdHRwUmVxdWVzdCB3cmFwcGVyLiBIZXJlJ3MgYSBzaW1wbGUgZXhhbXBsZTpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgIHNldHRpbmdzIGZvciB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdHxYRG9tYWluUmVxdWVzdH1cbiAqICAgICAgICAgVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1JheW5vcy94aHJcbiAqL1xudmlkZW9qcyQxLnhociA9IHhocjtcblxuLyoqXG4gKiBUZXh0VHJhY2sgY2xhc3NcbiAqXG4gKiBAYm9ycm93cyBUZXh0VHJhY2sgYXMgdmlkZW9qcy5UZXh0VHJhY2tcbiAqL1xudmlkZW9qcyQxLlRleHRUcmFjayA9IFRleHRUcmFjaztcblxuLyoqXG4gKiBleHBvcnQgdGhlIEF1ZGlvVHJhY2sgY2xhc3Mgc28gdGhhdCBzb3VyY2UgaGFuZGxlcnMgY2FuIGNyZWF0ZVxuICogQXVkaW9UcmFja3MgYW5kIHRoZW4gYWRkIHRoZW0gdG8gdGhlIHBsYXllcnMgQXVkaW9UcmFja0xpc3RcbiAqXG4gKiBAYm9ycm93cyBBdWRpb1RyYWNrIGFzIHZpZGVvanMuQXVkaW9UcmFja1xuICovXG52aWRlb2pzJDEuQXVkaW9UcmFjayA9IEF1ZGlvVHJhY2s7XG5cbi8qKlxuICogZXhwb3J0IHRoZSBWaWRlb1RyYWNrIGNsYXNzIHNvIHRoYXQgc291cmNlIGhhbmRsZXJzIGNhbiBjcmVhdGVcbiAqIFZpZGVvVHJhY2tzIGFuZCB0aGVuIGFkZCB0aGVtIHRvIHRoZSBwbGF5ZXJzIFZpZGVvVHJhY2tMaXN0XG4gKlxuICogQGJvcnJvd3MgVmlkZW9UcmFjayBhcyB2aWRlb2pzLlZpZGVvVHJhY2tcbiAqL1xudmlkZW9qcyQxLlZpZGVvVHJhY2sgPSBWaWRlb1RyYWNrO1xuXG4vKipcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIERPTSBlbGVtZW50LlxuICpcbiAqIEBib3Jyb3dzIGRvbTppc0VsIGFzIHZpZGVvanMuaXNFbFxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmlzRWwoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBEZXRlcm1pbmVzLCB2aWEgZHVjayB0eXBpbmcsIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgYSB0ZXh0IG5vZGUuXG4gKlxuICogQGJvcnJvd3MgZG9tOmlzVGV4dE5vZGUgYXMgdmlkZW9qcy5pc1RleHROb2RlXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uaXNUZXh0Tm9kZSgpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZWxlbWVudCBhbmQgYXBwbGllcyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBib3Jyb3dzIGRvbTpjcmVhdGVFbCBhcyB2aWRlb2pzLmNyZWF0ZUVsXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uY3JlYXRlRWwoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGhhcyBhIENTUyBjbGFzc1xuICpcbiAqIEBib3Jyb3dzIGRvbTpoYXNFbENsYXNzIGFzIHZpZGVvanMuaGFzQ2xhc3NcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5oYXNDbGFzcygpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIEFkZCBhIENTUyBjbGFzcyBuYW1lIHRvIGFuIGVsZW1lbnRcbiAqXG4gKiBAYm9ycm93cyBkb206YWRkRWxDbGFzcyBhcyB2aWRlb2pzLmFkZENsYXNzXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uYWRkQ2xhc3MoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBSZW1vdmUgYSBDU1MgY2xhc3MgbmFtZSBmcm9tIGFuIGVsZW1lbnRcbiAqXG4gKiBAYm9ycm93cyBkb206cmVtb3ZlRWxDbGFzcyBhcyB2aWRlb2pzLnJlbW92ZUNsYXNzXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20ucmVtb3ZlQ2xhc3MoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBBZGRzIG9yIHJlbW92ZXMgYSBDU1MgY2xhc3MgbmFtZSBvbiBhbiBlbGVtZW50IGRlcGVuZGluZyBvbiBhbiBvcHRpb25hbFxuICogY29uZGl0aW9uIG9yIHRoZSBwcmVzZW5jZS9hYnNlbmNlIG9mIHRoZSBjbGFzcyBuYW1lLlxuICpcbiAqIEBib3Jyb3dzIGRvbTp0b2dnbGVFbENsYXNzIGFzIHZpZGVvanMudG9nZ2xlQ2xhc3NcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS50b2dnbGVDbGFzcygpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIEFwcGx5IGF0dHJpYnV0ZXMgdG8gYW4gSFRNTCBlbGVtZW50LlxuICpcbiAqIEBib3Jyb3dzIGRvbTpzZXRFbEF0dHJpYnV0ZXMgYXMgdmlkZW9qcy5zZXRBdHRyaWJ1dGVcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5zZXRBdHRyaWJ1dGVzKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogR2V0IGFuIGVsZW1lbnQncyBhdHRyaWJ1dGUgdmFsdWVzLCBhcyBkZWZpbmVkIG9uIHRoZSBIVE1MIHRhZ1xuICogQXR0cmlidXRlcyBhcmUgbm90IHRoZSBzYW1lIGFzIHByb3BlcnRpZXMuIFRoZXkncmUgZGVmaW5lZCBvbiB0aGUgdGFnXG4gKiBvciB3aXRoIHNldEF0dHJpYnV0ZSAod2hpY2ggc2hvdWxkbid0IGJlIHVzZWQgd2l0aCBIVE1MKVxuICogVGhpcyB3aWxsIHJldHVybiB0cnVlIG9yIGZhbHNlIGZvciBib29sZWFuIGF0dHJpYnV0ZXMuXG4gKlxuICogQGJvcnJvd3MgZG9tOmdldEVsQXR0cmlidXRlcyBhcyB2aWRlb2pzLmdldEF0dHJpYnV0ZXNcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5nZXRBdHRyaWJ1dGVzKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogRW1wdGllcyB0aGUgY29udGVudHMgb2YgYW4gZWxlbWVudC5cbiAqXG4gKiBAYm9ycm93cyBkb206ZW1wdHlFbCBhcyB2aWRlb2pzLmVtcHR5RWxcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5lbXB0eUVsKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogTm9ybWFsaXplcyBhbmQgYXBwZW5kcyBjb250ZW50IHRvIGFuIGVsZW1lbnQuXG4gKlxuICogVGhlIGNvbnRlbnQgZm9yIGFuIGVsZW1lbnQgY2FuIGJlIHBhc3NlZCBpbiBtdWx0aXBsZSB0eXBlcyBhbmRcbiAqIGNvbWJpbmF0aW9ucywgd2hvc2UgYmVoYXZpb3IgaXMgYXMgZm9sbG93czpcbiAqXG4gKiAtIFN0cmluZ1xuICogICBOb3JtYWxpemVkIGludG8gYSB0ZXh0IG5vZGUuXG4gKlxuICogLSBFbGVtZW50LCBUZXh0Tm9kZVxuICogICBQYXNzZWQgdGhyb3VnaC5cbiAqXG4gKiAtIEFycmF5XG4gKiAgIEEgb25lLWRpbWVuc2lvbmFsIGFycmF5IG9mIHN0cmluZ3MsIGVsZW1lbnRzLCBub2Rlcywgb3IgZnVuY3Rpb25zICh3aGljaFxuICogICByZXR1cm4gc2luZ2xlIHN0cmluZ3MsIGVsZW1lbnRzLCBvciBub2RlcykuXG4gKlxuICogLSBGdW5jdGlvblxuICogICBJZiB0aGUgc29sZSBhcmd1bWVudCwgaXMgZXhwZWN0ZWQgdG8gcHJvZHVjZSBhIHN0cmluZywgZWxlbWVudCxcbiAqICAgbm9kZSwgb3IgYXJyYXkuXG4gKlxuICogQGJvcnJvd3MgZG9tOmFwcGVuZENvbnRlbnRzIGFzIHZpZGVvanMuYXBwZW5kQ29udGV0XG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uYXBwZW5kQ29udGVudCgpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYW5kIGluc2VydHMgY29udGVudCBpbnRvIGFuIGVsZW1lbnQ7IHRoaXMgaXMgaWRlbnRpY2FsIHRvXG4gKiBgYXBwZW5kQ29udGVudCgpYCwgZXhjZXB0IGl0IGVtcHRpZXMgdGhlIGVsZW1lbnQgZmlyc3QuXG4gKlxuICogVGhlIGNvbnRlbnQgZm9yIGFuIGVsZW1lbnQgY2FuIGJlIHBhc3NlZCBpbiBtdWx0aXBsZSB0eXBlcyBhbmRcbiAqIGNvbWJpbmF0aW9ucywgd2hvc2UgYmVoYXZpb3IgaXMgYXMgZm9sbG93czpcbiAqXG4gKiAtIFN0cmluZ1xuICogICBOb3JtYWxpemVkIGludG8gYSB0ZXh0IG5vZGUuXG4gKlxuICogLSBFbGVtZW50LCBUZXh0Tm9kZVxuICogICBQYXNzZWQgdGhyb3VnaC5cbiAqXG4gKiAtIEFycmF5XG4gKiAgIEEgb25lLWRpbWVuc2lvbmFsIGFycmF5IG9mIHN0cmluZ3MsIGVsZW1lbnRzLCBub2Rlcywgb3IgZnVuY3Rpb25zICh3aGljaFxuICogICByZXR1cm4gc2luZ2xlIHN0cmluZ3MsIGVsZW1lbnRzLCBvciBub2RlcykuXG4gKlxuICogLSBGdW5jdGlvblxuICogICBJZiB0aGUgc29sZSBhcmd1bWVudCwgaXMgZXhwZWN0ZWQgdG8gcHJvZHVjZSBhIHN0cmluZywgZWxlbWVudCxcbiAqICAgbm9kZSwgb3IgYXJyYXkuXG4gKlxuICogQGJvcnJvd3MgZG9tOmluc2VydENvbnRlbnQgYXMgdmlkZW9qcy5pbnNlcnRDb250ZW50XG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uaW5zZXJ0Q29udGVudCgpIGluc3RlYWRcbiAqL1xuWydpc0VsJywgJ2lzVGV4dE5vZGUnLCAnY3JlYXRlRWwnLCAnaGFzQ2xhc3MnLCAnYWRkQ2xhc3MnLCAncmVtb3ZlQ2xhc3MnLCAndG9nZ2xlQ2xhc3MnLCAnc2V0QXR0cmlidXRlcycsICdnZXRBdHRyaWJ1dGVzJywgJ2VtcHR5RWwnLCAnYXBwZW5kQ29udGVudCcsICdpbnNlcnRDb250ZW50J10uZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICB2aWRlb2pzJDFba10gPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9nJDEud2FybigndmlkZW9qcy4nICsgayArICcoKSBpcyBkZXByZWNhdGVkOyB1c2UgdmlkZW9qcy5kb20uJyArIGsgKyAnKCkgaW5zdGVhZCcpO1xuICAgIHJldHVybiBEb21ba10uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEEgc2FmZSBnZXRDb21wdXRlZFN0eWxlLlxuICpcbiAqIFRoaXMgaXMgYmVjYXVzZSBpbiBGaXJlZm94LCBpZiB0aGUgcGxheWVyIGlzIGxvYWRlZCBpbiBhbiBpZnJhbWUgd2l0aCBgZGlzcGxheTpub25lYCxcbiAqIHRoZW4gYGdldENvbXB1dGVkU3R5bGVgIHJldHVybnMgYG51bGxgLCBzbywgd2UgZG8gYSBudWxsLWNoZWNrIHRvIG1ha2Ugc3VyZVxuICogdGhhdCB0aGUgcGxheWVyIGRvZXNuJ3QgYnJlYWsgaW4gdGhlc2UgY2FzZXMuXG4gKiBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQGJvcnJvd3MgY29tcHV0ZWQtc3R5bGU6Y29tcHV0ZWRTdHlsZSBhcyB2aWRlb2pzLmNvbXB1dGVkU3R5bGVcbiAqL1xudmlkZW9qcyQxLmNvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgRG9tIHV0aWxpdGllcyBmb3IgdXNlIGluIGV4dGVybmFsIHBsdWdpbnNcbiAqIGFuZCBUZWNoJ3NcbiAqL1xudmlkZW9qcyQxLmRvbSA9IERvbTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIFVybCB1dGlsaXRpZXMgZm9yIHVzZSBpbiBleHRlcm5hbCBwbHVnaW5zXG4gKiBhbmQgVGVjaCdzXG4gKi9cbnZpZGVvanMkMS51cmwgPSBVcmw7XG5cbi8qKlxuICogQHZpZGVvanMvaHR0cC1zdHJlYW1pbmdcbiAqIEB2ZXJzaW9uIDEuMS4wXG4gKiBAY29weXJpZ2h0IDIwMTggQnJpZ2h0Y292ZSwgSW5jXG4gKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4gKi9cblxuLyoqXG4gKiBAZmlsZSByZXNvbHZlLXVybC5qc1xuICovXG5cbnZhciByZXNvbHZlVXJsID0gZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICAvLyByZXR1cm4gZWFybHkgaWYgd2UgZG9uJ3QgbmVlZCB0byByZXNvbHZlXG4gIGlmICgvXlthLXpdKzovaS50ZXN0KHJlbGF0aXZlVVJMKSkge1xuICAgIHJldHVybiByZWxhdGl2ZVVSTDtcbiAgfVxuXG4gIC8vIGlmIHRoZSBiYXNlIFVSTCBpcyByZWxhdGl2ZSB0aGVuIGNvbWJpbmUgd2l0aCB0aGUgY3VycmVudCBsb2NhdGlvblxuICBpZiAoIS9cXC9cXC8vaS50ZXN0KGJhc2VVUkwpKSB7XG4gICAgYmFzZVVSTCA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTCh3aW5kb3ckMS5sb2NhdGlvbi5ocmVmLCBiYXNlVVJMKTtcbiAgfVxuXG4gIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwoYmFzZVVSTCwgcmVsYXRpdmVVUkwpO1xufTtcblxudmFyIGNsYXNzQ2FsbENoZWNrJDEgPSBmdW5jdGlvbiBjbGFzc0NhbGxDaGVjayQkMShpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MkMSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxudmFyIGdldCQyID0gZnVuY3Rpb24gZ2V0JCQxKG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0JCQxKHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHtcbiAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7XG5cbiAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTtcbiAgfVxufTtcblxudmFyIGluaGVyaXRzJDEgPSBmdW5jdGlvbiBpbmhlcml0cyQkMShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyAodHlwZW9mIHN1cGVyQ2xhc3MgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN1cGVyQ2xhc3MpKSk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJDEgPSBmdW5jdGlvbiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJCQxKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG52YXIgc2xpY2VkVG9BcnJheSQxID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG4vKipcbiAqIEBmaWxlIHBsYXlsaXN0LWxvYWRlci5qc1xuICpcbiAqIEEgc3RhdGUgbWFjaGluZSB0aGF0IG1hbmFnZXMgdGhlIGxvYWRpbmcsIGNhY2hpbmcsIGFuZCB1cGRhdGluZyBvZlxuICogTTNVOCBwbGF5bGlzdHMuXG4gKlxuICovXG5cbnZhciBtZXJnZU9wdGlvbnMkMSA9IHZpZGVvanMkMS5tZXJnZU9wdGlvbnMsXG4gICAgRXZlbnRUYXJnZXQkMSA9IHZpZGVvanMkMS5FdmVudFRhcmdldCxcbiAgICBsb2ckMiA9IHZpZGVvanMkMS5sb2c7XG5cbi8qKlxuICogTG9vcHMgdGhyb3VnaCBhbGwgc3VwcG9ydGVkIG1lZGlhIGdyb3VwcyBpbiBtYXN0ZXIgYW5kIGNhbGxzIHRoZSBwcm92aWRlZFxuICogY2FsbGJhY2sgZm9yIGVhY2ggZ3JvdXBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWFzdGVyXG4gKiAgICAgICAgVGhlIHBhcnNlZCBtYXN0ZXIgbWFuaWZlc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogICAgICAgIENhbGxiYWNrIHRvIGNhbGwgZm9yIGVhY2ggbWVkaWEgZ3JvdXBcbiAqL1xuXG52YXIgZm9yRWFjaE1lZGlhR3JvdXAgPSBmdW5jdGlvbiBmb3JFYWNoTWVkaWFHcm91cChtYXN0ZXIsIGNhbGxiYWNrKSB7XG4gIFsnQVVESU8nLCAnU1VCVElUTEVTJ10uZm9yRWFjaChmdW5jdGlvbiAobWVkaWFUeXBlKSB7XG4gICAgZm9yICh2YXIgZ3JvdXBLZXkgaW4gbWFzdGVyLm1lZGlhR3JvdXBzW21lZGlhVHlwZV0pIHtcbiAgICAgIGZvciAodmFyIGxhYmVsS2V5IGluIG1hc3Rlci5tZWRpYUdyb3Vwc1ttZWRpYVR5cGVdW2dyb3VwS2V5XSkge1xuICAgICAgICB2YXIgbWVkaWFQcm9wZXJ0aWVzID0gbWFzdGVyLm1lZGlhR3JvdXBzW21lZGlhVHlwZV1bZ3JvdXBLZXldW2xhYmVsS2V5XTtcblxuICAgICAgICBjYWxsYmFjayhtZWRpYVByb3BlcnRpZXMsIG1lZGlhVHlwZSwgZ3JvdXBLZXksIGxhYmVsS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gICogUmV0dXJucyBhIG5ldyBhcnJheSBvZiBzZWdtZW50cyB0aGF0IGlzIHRoZSByZXN1bHQgb2YgbWVyZ2luZ1xuICAqIHByb3BlcnRpZXMgZnJvbSBhbiBvbGRlciBsaXN0IG9mIHNlZ21lbnRzIG9udG8gYW4gdXBkYXRlZFxuICAqIGxpc3QuIE5vIHByb3BlcnRpZXMgb24gdGhlIHVwZGF0ZWQgcGxheWxpc3Qgd2lsbCBiZSBvdmVycmlkZGVuLlxuICAqXG4gICogQHBhcmFtIHtBcnJheX0gb3JpZ2luYWwgdGhlIG91dGRhdGVkIGxpc3Qgb2Ygc2VnbWVudHNcbiAgKiBAcGFyYW0ge0FycmF5fSB1cGRhdGUgdGhlIHVwZGF0ZWQgbGlzdCBvZiBzZWdtZW50c1xuICAqIEBwYXJhbSB7TnVtYmVyPX0gb2Zmc2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdXBkYXRlXG4gICogc2VnbWVudCBpbiB0aGUgb3JpZ2luYWwgc2VnbWVudCBsaXN0LiBGb3Igbm9uLWxpdmUgcGxheWxpc3RzLFxuICAqIHRoaXMgc2hvdWxkIGFsd2F5cyBiZSB6ZXJvIGFuZCBkb2VzIG5vdCBuZWVkIHRvIGJlXG4gICogc3BlY2lmaWVkLiBGb3IgbGl2ZSBwbGF5bGlzdHMsIGl0IHNob3VsZCBiZSB0aGUgZGlmZmVyZW5jZVxuICAqIGJldHdlZW4gdGhlIG1lZGlhIHNlcXVlbmNlIG51bWJlcnMgaW4gdGhlIG9yaWdpbmFsIGFuZCB1cGRhdGVkXG4gICogcGxheWxpc3RzLlxuICAqIEByZXR1cm4gYSBsaXN0IG9mIG1lcmdlZCBzZWdtZW50IG9iamVjdHNcbiAgKi9cbnZhciB1cGRhdGVTZWdtZW50cyA9IGZ1bmN0aW9uIHVwZGF0ZVNlZ21lbnRzKG9yaWdpbmFsLCB1cGRhdGUsIG9mZnNldCkge1xuICB2YXIgcmVzdWx0ID0gdXBkYXRlLnNsaWNlKCk7XG5cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihvcmlnaW5hbC5sZW5ndGgsIHVwZGF0ZS5sZW5ndGggKyBvZmZzZXQpO1xuXG4gIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpIC0gb2Zmc2V0XSA9IG1lcmdlT3B0aW9ucyQxKG9yaWdpbmFsW2ldLCByZXN1bHRbaSAtIG9mZnNldF0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgcmVzb2x2ZVNlZ21lbnRVcmlzID0gZnVuY3Rpb24gcmVzb2x2ZVNlZ21lbnRVcmlzKHNlZ21lbnQsIGJhc2VVcmkpIHtcbiAgaWYgKCFzZWdtZW50LnJlc29sdmVkVXJpKSB7XG4gICAgc2VnbWVudC5yZXNvbHZlZFVyaSA9IHJlc29sdmVVcmwoYmFzZVVyaSwgc2VnbWVudC51cmkpO1xuICB9XG4gIGlmIChzZWdtZW50LmtleSAmJiAhc2VnbWVudC5rZXkucmVzb2x2ZWRVcmkpIHtcbiAgICBzZWdtZW50LmtleS5yZXNvbHZlZFVyaSA9IHJlc29sdmVVcmwoYmFzZVVyaSwgc2VnbWVudC5rZXkudXJpKTtcbiAgfVxuICBpZiAoc2VnbWVudC5tYXAgJiYgIXNlZ21lbnQubWFwLnJlc29sdmVkVXJpKSB7XG4gICAgc2VnbWVudC5tYXAucmVzb2x2ZWRVcmkgPSByZXNvbHZlVXJsKGJhc2VVcmksIHNlZ21lbnQubWFwLnVyaSk7XG4gIH1cbn07XG5cbi8qKlxuICAqIFJldHVybnMgYSBuZXcgbWFzdGVyIHBsYXlsaXN0IHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBtZXJnaW5nIGFuXG4gICogdXBkYXRlZCBtZWRpYSBwbGF5bGlzdCBpbnRvIHRoZSBvcmlnaW5hbCB2ZXJzaW9uLiBJZiB0aGVcbiAgKiB1cGRhdGVkIG1lZGlhIHBsYXlsaXN0IGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgcGxheWxpc3RcbiAgKiBlbnRyaWVzIGluIHRoZSBvcmlnaW5hbCBtYXN0ZXIgcGxheWxpc3QsIG51bGwgaXMgcmV0dXJuZWQuXG4gICpcbiAgKiBAcGFyYW0ge09iamVjdH0gbWFzdGVyIGEgcGFyc2VkIG1hc3RlciBNM1U4IG9iamVjdFxuICAqIEBwYXJhbSB7T2JqZWN0fSBtZWRpYSBhIHBhcnNlZCBtZWRpYSBNM1U4IG9iamVjdFxuICAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgb3JpZ2luYWxcbiAgKiBtYXN0ZXIgcGxheWxpc3Qgd2l0aCB0aGUgdXBkYXRlZCBtZWRpYSBwbGF5bGlzdCBtZXJnZWQgaW4sIG9yXG4gICogbnVsbCBpZiB0aGUgbWVyZ2UgcHJvZHVjZWQgbm8gY2hhbmdlLlxuICAqL1xudmFyIHVwZGF0ZU1hc3RlciA9IGZ1bmN0aW9uIHVwZGF0ZU1hc3RlcihtYXN0ZXIsIG1lZGlhKSB7XG4gIHZhciByZXN1bHQgPSBtZXJnZU9wdGlvbnMkMShtYXN0ZXIsIHt9KTtcbiAgdmFyIHBsYXlsaXN0ID0gcmVzdWx0LnBsYXlsaXN0c1ttZWRpYS51cmldO1xuXG4gIGlmICghcGxheWxpc3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGNvbnNpZGVyIHRoZSBwbGF5bGlzdCB1bmNoYW5nZWQgaWYgdGhlIG51bWJlciBvZiBzZWdtZW50cyBpcyBlcXVhbCBhbmQgdGhlIG1lZGlhXG4gIC8vIHNlcXVlbmNlIG51bWJlciBpcyB1bmNoYW5nZWRcbiAgaWYgKHBsYXlsaXN0LnNlZ21lbnRzICYmIG1lZGlhLnNlZ21lbnRzICYmIHBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aCA9PT0gbWVkaWEuc2VnbWVudHMubGVuZ3RoICYmIHBsYXlsaXN0Lm1lZGlhU2VxdWVuY2UgPT09IG1lZGlhLm1lZGlhU2VxdWVuY2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtZXJnZWRQbGF5bGlzdCA9IG1lcmdlT3B0aW9ucyQxKHBsYXlsaXN0LCBtZWRpYSk7XG5cbiAgLy8gaWYgdGhlIHVwZGF0ZSBjb3VsZCBvdmVybGFwIGV4aXN0aW5nIHNlZ21lbnQgaW5mb3JtYXRpb24sIG1lcmdlIHRoZSB0d28gc2VnbWVudCBsaXN0c1xuICBpZiAocGxheWxpc3Quc2VnbWVudHMpIHtcbiAgICBtZXJnZWRQbGF5bGlzdC5zZWdtZW50cyA9IHVwZGF0ZVNlZ21lbnRzKHBsYXlsaXN0LnNlZ21lbnRzLCBtZWRpYS5zZWdtZW50cywgbWVkaWEubWVkaWFTZXF1ZW5jZSAtIHBsYXlsaXN0Lm1lZGlhU2VxdWVuY2UpO1xuICB9XG5cbiAgLy8gcmVzb2x2ZSBhbnkgc2VnbWVudCBVUklzIHRvIHByZXZlbnQgdXMgZnJvbSBoYXZpbmcgdG8gZG8gaXQgbGF0ZXJcbiAgbWVyZ2VkUGxheWxpc3Quc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgIHJlc29sdmVTZWdtZW50VXJpcyhzZWdtZW50LCBtZXJnZWRQbGF5bGlzdC5yZXNvbHZlZFVyaSk7XG4gIH0pO1xuXG4gIC8vIFRPRE8gUmlnaHQgbm93IGluIHRoZSBwbGF5bGlzdHMgYXJyYXkgdGhlcmUgYXJlIHR3byByZWZlcmVuY2VzIHRvIGVhY2ggcGxheWxpc3QsIG9uZVxuICAvLyB0aGF0IGlzIHJlZmVyZW5jZWQgYnkgaW5kZXgsIGFuZCBvbmUgYnkgVVJJLiBUaGUgaW5kZXggcmVmZXJlbmNlIG1heSBubyBsb25nZXIgYmVcbiAgLy8gbmVjZXNzYXJ5LlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5wbGF5bGlzdHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmVzdWx0LnBsYXlsaXN0c1tpXS51cmkgPT09IG1lZGlhLnVyaSkge1xuICAgICAgcmVzdWx0LnBsYXlsaXN0c1tpXSA9IG1lcmdlZFBsYXlsaXN0O1xuICAgIH1cbiAgfVxuICByZXN1bHQucGxheWxpc3RzW21lZGlhLnVyaV0gPSBtZXJnZWRQbGF5bGlzdDtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIHNldHVwTWVkaWFQbGF5bGlzdHMgPSBmdW5jdGlvbiBzZXR1cE1lZGlhUGxheWxpc3RzKG1hc3Rlcikge1xuICAvLyBzZXR1cCBieS1VUkkgbG9va3VwcyBhbmQgcmVzb2x2ZSBtZWRpYSBwbGF5bGlzdCBVUklzXG4gIHZhciBpID0gbWFzdGVyLnBsYXlsaXN0cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBwbGF5bGlzdCA9IG1hc3Rlci5wbGF5bGlzdHNbaV07XG5cbiAgICBtYXN0ZXIucGxheWxpc3RzW3BsYXlsaXN0LnVyaV0gPSBwbGF5bGlzdDtcbiAgICBwbGF5bGlzdC5yZXNvbHZlZFVyaSA9IHJlc29sdmVVcmwobWFzdGVyLnVyaSwgcGxheWxpc3QudXJpKTtcbiAgICBwbGF5bGlzdC5pZCA9IGk7XG5cbiAgICBpZiAoIXBsYXlsaXN0LmF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vIEFsdGhvdWdoIHRoZSBzcGVjIHN0YXRlcyBhbiAjRVhULVgtU1RSRUFNLUlORiB0YWcgTVVTVCBoYXZlIGFcbiAgICAgIC8vIEJBTkRXSURUSCBhdHRyaWJ1dGUsIHdlIGNhbiBwbGF5IHRoZSBzdHJlYW0gd2l0aG91dCBpdC4gVGhpcyBtZWFucyBhIHBvb3JseVxuICAgICAgLy8gZm9ybWF0dGVkIG1hc3RlciBwbGF5bGlzdCBtYXkgbm90IGhhdmUgYW4gYXR0cmlidXRlIGxpc3QuIEFuIGF0dHJpYnV0ZXNcbiAgICAgIC8vIHByb3BlcnR5IGlzIGFkZGVkIGhlcmUgdG8gcHJldmVudCB1bmRlZmluZWQgcmVmZXJlbmNlcyB3aGVuIHdlIGVuY291bnRlclxuICAgICAgLy8gdGhpcyBzY2VuYXJpby5cbiAgICAgIHBsYXlsaXN0LmF0dHJpYnV0ZXMgPSB7fTtcblxuICAgICAgbG9nJDIud2FybignSW52YWxpZCBwbGF5bGlzdCBTVFJFQU0tSU5GIGRldGVjdGVkLiBNaXNzaW5nIEJBTkRXSURUSCBhdHRyaWJ1dGUuJyk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcmVzb2x2ZU1lZGlhR3JvdXBVcmlzID0gZnVuY3Rpb24gcmVzb2x2ZU1lZGlhR3JvdXBVcmlzKG1hc3Rlcikge1xuICBmb3JFYWNoTWVkaWFHcm91cChtYXN0ZXIsIGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHByb3BlcnRpZXMudXJpKSB7XG4gICAgICBwcm9wZXJ0aWVzLnJlc29sdmVkVXJpID0gcmVzb2x2ZVVybChtYXN0ZXIudXJpLCBwcm9wZXJ0aWVzLnVyaSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgdGltZSB0byB3YWl0IGJlZm9yZSByZWZyZXNoaW5nIGEgbGl2ZSBwbGF5bGlzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZWRpYVxuICogICAgICAgIFRoZSBjdXJyZW50IG1lZGlhXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHVwZGF0ZVxuICogICAgICAgIFRydWUgaWYgdGhlcmUgd2VyZSBhbnkgdXBkYXRlcyBmcm9tIHRoZSBsYXN0IHJlZnJlc2gsIGZhbHNlIG90aGVyd2lzZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogICAgICAgICBUaGUgdGltZSBpbiBtcyB0byB3YWl0IGJlZm9yZSByZWZyZXNoaW5nIHRoZSBsaXZlIHBsYXlsaXN0XG4gKi9cbnZhciByZWZyZXNoRGVsYXkgPSBmdW5jdGlvbiByZWZyZXNoRGVsYXkobWVkaWEsIHVwZGF0ZSkge1xuICB2YXIgbGFzdFNlZ21lbnQgPSBtZWRpYS5zZWdtZW50c1ttZWRpYS5zZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgdmFyIGRlbGF5ID0gdm9pZCAwO1xuXG4gIGlmICh1cGRhdGUgJiYgbGFzdFNlZ21lbnQgJiYgbGFzdFNlZ21lbnQuZHVyYXRpb24pIHtcbiAgICBkZWxheSA9IGxhc3RTZWdtZW50LmR1cmF0aW9uICogMTAwMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgcGxheWxpc3QgaXMgdW5jaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHJlbG9hZCBvciBsYXN0IHNlZ21lbnQgZHVyYXRpb25cbiAgICAvLyBjYW5ub3QgYmUgZGV0ZXJtaW5lZCwgdHJ5IGFnYWluIGFmdGVyIGhhbGYgdGhlIHRhcmdldCBkdXJhdGlvblxuICAgIGRlbGF5ID0gKG1lZGlhLnRhcmdldER1cmF0aW9uIHx8IDEwKSAqIDUwMDtcbiAgfVxuICByZXR1cm4gZGVsYXk7XG59O1xuXG4vKipcbiAqIExvYWQgYSBwbGF5bGlzdCBmcm9tIGEgcmVtb3RlIGxvY2F0aW9uXG4gKlxuICogQGNsYXNzIFBsYXlsaXN0TG9hZGVyXG4gKiBAZXh0ZW5kcyBTdHJlYW1cbiAqIEBwYXJhbSB7U3RyaW5nfSBzcmNVcmwgdGhlIHVybCB0byBzdGFydCB3aXRoXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhDcmVkZW50aWFscyB0aGUgd2l0aENyZWRlbnRpYWxzIHhociBvcHRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBQbGF5bGlzdExvYWRlciA9IGZ1bmN0aW9uIChfRXZlbnRUYXJnZXQpIHtcbiAgaW5oZXJpdHMkMShQbGF5bGlzdExvYWRlciwgX0V2ZW50VGFyZ2V0KTtcblxuICBmdW5jdGlvbiBQbGF5bGlzdExvYWRlcihzcmNVcmwsIGhscywgd2l0aENyZWRlbnRpYWxzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2skMSh0aGlzLCBQbGF5bGlzdExvYWRlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJDEodGhpcywgKFBsYXlsaXN0TG9hZGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUGxheWxpc3RMb2FkZXIpKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLnNyY1VybCA9IHNyY1VybDtcbiAgICBfdGhpcy5obHNfID0gaGxzO1xuICAgIF90aGlzLndpdGhDcmVkZW50aWFscyA9IHdpdGhDcmVkZW50aWFscztcblxuICAgIGlmICghX3RoaXMuc3JjVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egbm9uLWVtcHR5IHBsYXlsaXN0IFVSTCBpcyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWxpemUgdGhlIGxvYWRlciBzdGF0ZVxuICAgIF90aGlzLnN0YXRlID0gJ0hBVkVfTk9USElORyc7XG5cbiAgICAvLyBsaXZlIHBsYXlsaXN0IHN0YWxlbmVzcyB0aW1lb3V0XG4gICAgX3RoaXMub24oJ21lZGlhdXBkYXRldGltZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5zdGF0ZSAhPT0gJ0hBVkVfTUVUQURBVEEnKSB7XG4gICAgICAgIC8vIG9ubHkgcmVmcmVzaCB0aGUgbWVkaWEgcGxheWxpc3QgaWYgbm8gb3RoZXIgYWN0aXZpdHkgaXMgZ29pbmcgb25cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zdGF0ZSA9ICdIQVZFX0NVUlJFTlRfTUVUQURBVEEnO1xuXG4gICAgICBfdGhpcy5yZXF1ZXN0ID0gX3RoaXMuaGxzXy54aHIoe1xuICAgICAgICB1cmk6IHJlc29sdmVVcmwoX3RoaXMubWFzdGVyLnVyaSwgX3RoaXMubWVkaWEoKS51cmkpLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IF90aGlzLndpdGhDcmVkZW50aWFsc1xuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yLCByZXEpIHtcbiAgICAgICAgLy8gZGlzcG9zZWRcbiAgICAgICAgaWYgKCFfdGhpcy5yZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnBsYXlsaXN0UmVxdWVzdEVycm9yKF90aGlzLnJlcXVlc3QsIF90aGlzLm1lZGlhKCkudXJpLCAnSEFWRV9NRVRBREFUQScpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuaGF2ZU1ldGFkYXRhKF90aGlzLnJlcXVlc3QsIF90aGlzLm1lZGlhKCkudXJpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzJDEoUGxheWxpc3RMb2FkZXIsIFt7XG4gICAga2V5OiAncGxheWxpc3RSZXF1ZXN0RXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5bGlzdFJlcXVlc3RFcnJvcih4aHIkJDEsIHVybCwgc3RhcnRpbmdTdGF0ZSkge1xuICAgICAgLy8gYW55IGluLWZsaWdodCByZXF1ZXN0IGlzIG5vdyBmaW5pc2hlZFxuICAgICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgaWYgKHN0YXJ0aW5nU3RhdGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXJ0aW5nU3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXJyb3IgPSB7XG4gICAgICAgIHBsYXlsaXN0OiB0aGlzLm1hc3Rlci5wbGF5bGlzdHNbdXJsXSxcbiAgICAgICAgc3RhdHVzOiB4aHIkJDEuc3RhdHVzLFxuICAgICAgICBtZXNzYWdlOiAnSExTIHBsYXlsaXN0IHJlcXVlc3QgZXJyb3IgYXQgVVJMOiAnICsgdXJsLFxuICAgICAgICByZXNwb25zZVRleHQ6IHhociQkMS5yZXNwb25zZVRleHQsXG4gICAgICAgIGNvZGU6IHhociQkMS5zdGF0dXMgPj0gNTAwID8gNCA6IDJcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudHJpZ2dlcignZXJyb3InKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIHBsYXlsaXN0IGxvYWRlcidzIHN0YXRlIGluIHJlc3BvbnNlIHRvIGEgbmV3IG9yXG4gICAgLy8gdXBkYXRlZCBwbGF5bGlzdC5cblxuICB9LCB7XG4gICAga2V5OiAnaGF2ZU1ldGFkYXRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGF2ZU1ldGFkYXRhKHhociQkMSwgdXJsKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gYW55IGluLWZsaWdodCByZXF1ZXN0IGlzIG5vdyBmaW5pc2hlZFxuICAgICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhdGUgPSAnSEFWRV9NRVRBREFUQSc7XG5cbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKCk7XG5cbiAgICAgIHBhcnNlci5wdXNoKHhociQkMS5yZXNwb25zZVRleHQpO1xuICAgICAgcGFyc2VyLmVuZCgpO1xuICAgICAgcGFyc2VyLm1hbmlmZXN0LnVyaSA9IHVybDtcbiAgICAgIC8vIG0zdTgtcGFyc2VyIGRvZXMgbm90IGF0dGFjaCBhbiBhdHRyaWJ1dGVzIHByb3BlcnR5IHRvIG1lZGlhIHBsYXlsaXN0cyBzbyBtYWtlXG4gICAgICAvLyBzdXJlIHRoYXQgdGhlIHByb3BlcnR5IGlzIGF0dGFjaGVkIHRvIGF2b2lkIHVuZGVmaW5lZCByZWZlcmVuY2UgZXJyb3JzXG4gICAgICBwYXJzZXIubWFuaWZlc3QuYXR0cmlidXRlcyA9IHBhcnNlci5tYW5pZmVzdC5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gICAgICAvLyBtZXJnZSB0aGlzIHBsYXlsaXN0IGludG8gdGhlIG1hc3RlclxuICAgICAgdmFyIHVwZGF0ZSA9IHVwZGF0ZU1hc3Rlcih0aGlzLm1hc3RlciwgcGFyc2VyLm1hbmlmZXN0KTtcblxuICAgICAgdGhpcy50YXJnZXREdXJhdGlvbiA9IHBhcnNlci5tYW5pZmVzdC50YXJnZXREdXJhdGlvbjtcblxuICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLm1hc3RlciA9IHVwZGF0ZTtcbiAgICAgICAgdGhpcy5tZWRpYV8gPSB0aGlzLm1hc3Rlci5wbGF5bGlzdHNbcGFyc2VyLm1hbmlmZXN0LnVyaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3BsYXlsaXN0dW5jaGFuZ2VkJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlZnJlc2ggbGl2ZSBwbGF5bGlzdHMgYWZ0ZXIgYSB0YXJnZXQgZHVyYXRpb24gcGFzc2VzXG4gICAgICBpZiAoIXRoaXMubWVkaWEoKS5lbmRMaXN0KSB7XG4gICAgICAgIHdpbmRvdyQxLmNsZWFyVGltZW91dCh0aGlzLm1lZGlhVXBkYXRlVGltZW91dCk7XG4gICAgICAgIHRoaXMubWVkaWFVcGRhdGVUaW1lb3V0ID0gd2luZG93JDEuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnRyaWdnZXIoJ21lZGlhdXBkYXRldGltZW91dCcpO1xuICAgICAgICB9LCByZWZyZXNoRGVsYXkodGhpcy5tZWRpYSgpLCAhIXVwZGF0ZSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyaWdnZXIoJ2xvYWRlZHBsYXlsaXN0Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWJvcnQgYW55IG91dHN0YW5kaW5nIHdvcmsgYW5kIGNsZWFuIHVwLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXNwb3NlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuc3RvcFJlcXVlc3QoKTtcbiAgICAgIHdpbmRvdyQxLmNsZWFyVGltZW91dCh0aGlzLm1lZGlhVXBkYXRlVGltZW91dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RvcFJlcXVlc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wUmVxdWVzdCgpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcbiAgICAgICAgdmFyIG9sZFJlcXVlc3QgPSB0aGlzLnJlcXVlc3Q7XG5cbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgb2xkUmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICBvbGRSZXF1ZXN0LmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBjYWxsZWQgd2l0aG91dCBhbnkgYXJndW1lbnRzLCByZXR1cm5zIHRoZSBjdXJyZW50bHlcbiAgICAgKiBhY3RpdmUgbWVkaWEgcGxheWxpc3QuIFdoZW4gY2FsbGVkIHdpdGggYSBzaW5nbGUgYXJndW1lbnQsXG4gICAgICogdHJpZ2dlcnMgdGhlIHBsYXlsaXN0IGxvYWRlciB0byBhc3luY2hyb25vdXNseSBzd2l0Y2ggdG8gdGhlXG4gICAgICogc3BlY2lmaWVkIG1lZGlhIHBsYXlsaXN0LiBDYWxsaW5nIHRoaXMgbWV0aG9kIHdoaWxlIHRoZVxuICAgICAqIGxvYWRlciBpcyBpbiB0aGUgSEFWRV9OT1RISU5HIGNhdXNlcyBhbiBlcnJvciB0byBiZSBlbWl0dGVkXG4gICAgICogYnV0IG90aGVyd2lzZSBoYXMgbm8gZWZmZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBwbGF5bGlzdCB0aGUgcGFyc2VkIG1lZGlhIHBsYXlsaXN0XG4gICAgICogb2JqZWN0IHRvIHN3aXRjaCB0b1xuICAgICAqIEByZXR1cm4ge1BsYXlsaXN0fSB0aGUgY3VycmVudCBsb2FkZWQgbWVkaWFcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWVkaWEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZWRpYShwbGF5bGlzdCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIC8vIGdldHRlclxuICAgICAgaWYgKCFwbGF5bGlzdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYV87XG4gICAgICB9XG5cbiAgICAgIC8vIHNldHRlclxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdIQVZFX05PVEhJTkcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3aXRjaCBtZWRpYSBwbGF5bGlzdCBmcm9tICcgKyB0aGlzLnN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0aW5nU3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgICAvLyBmaW5kIHRoZSBwbGF5bGlzdCBvYmplY3QgaWYgdGhlIHRhcmdldCBwbGF5bGlzdCBoYXMgYmVlblxuICAgICAgLy8gc3BlY2lmaWVkIGJ5IFVSSVxuICAgICAgaWYgKHR5cGVvZiBwbGF5bGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hc3Rlci5wbGF5bGlzdHNbcGxheWxpc3RdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHBsYXlsaXN0IFVSSTogJyArIHBsYXlsaXN0KTtcbiAgICAgICAgfVxuICAgICAgICBwbGF5bGlzdCA9IHRoaXMubWFzdGVyLnBsYXlsaXN0c1twbGF5bGlzdF07XG4gICAgICB9XG5cbiAgICAgIHZhciBtZWRpYUNoYW5nZSA9ICF0aGlzLm1lZGlhXyB8fCBwbGF5bGlzdC51cmkgIT09IHRoaXMubWVkaWFfLnVyaTtcblxuICAgICAgLy8gc3dpdGNoIHRvIGZ1bGx5IGxvYWRlZCBwbGF5bGlzdHMgaW1tZWRpYXRlbHlcbiAgICAgIGlmICh0aGlzLm1hc3Rlci5wbGF5bGlzdHNbcGxheWxpc3QudXJpXS5lbmRMaXN0KSB7XG4gICAgICAgIC8vIGFib3J0IG91dHN0YW5kaW5nIHBsYXlsaXN0IHJlcXVlc3RzXG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICB0aGlzLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnSEFWRV9NRVRBREFUQSc7XG4gICAgICAgIHRoaXMubWVkaWFfID0gcGxheWxpc3Q7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBtZWRpYSBjaGFuZ2UgaWYgdGhlIGFjdGl2ZSBtZWRpYSBoYXMgYmVlbiB1cGRhdGVkXG4gICAgICAgIGlmIChtZWRpYUNoYW5nZSkge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignbWVkaWFjaGFuZ2luZycpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignbWVkaWFjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHN3aXRjaGluZyB0byB0aGUgYWN0aXZlIHBsYXlsaXN0IGlzIGEgbm8tb3BcbiAgICAgIGlmICghbWVkaWFDaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0gJ1NXSVRDSElOR19NRURJQSc7XG5cbiAgICAgIC8vIHRoZXJlIGlzIGFscmVhZHkgYW4gb3V0c3RhbmRpbmcgcGxheWxpc3QgcmVxdWVzdFxuICAgICAgaWYgKHRoaXMucmVxdWVzdCkge1xuICAgICAgICBpZiAocmVzb2x2ZVVybCh0aGlzLm1hc3Rlci51cmksIHBsYXlsaXN0LnVyaSkgPT09IHRoaXMucmVxdWVzdC51cmwpIHtcbiAgICAgICAgICAvLyByZXF1ZXN0aW5nIHRvIHN3aXRjaCB0byB0aGUgc2FtZSBwbGF5bGlzdCBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgIC8vIGhhcyBubyBlZmZlY3QgYWZ0ZXIgdGhlIGZpcnN0XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gcmVxdWVzdCB0aGUgbmV3IHBsYXlsaXN0XG4gICAgICBpZiAodGhpcy5tZWRpYV8pIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdtZWRpYWNoYW5naW5nJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVxdWVzdCA9IHRoaXMuaGxzXy54aHIoe1xuICAgICAgICB1cmk6IHJlc29sdmVVcmwodGhpcy5tYXN0ZXIudXJpLCBwbGF5bGlzdC51cmkpLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHRoaXMud2l0aENyZWRlbnRpYWxzXG4gICAgICB9LCBmdW5jdGlvbiAoZXJyb3IsIHJlcSkge1xuICAgICAgICAvLyBkaXNwb3NlZFxuICAgICAgICBpZiAoIV90aGlzMy5yZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5wbGF5bGlzdFJlcXVlc3RFcnJvcihfdGhpczMucmVxdWVzdCwgcGxheWxpc3QudXJpLCBzdGFydGluZ1N0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMy5oYXZlTWV0YWRhdGEocmVxLCBwbGF5bGlzdC51cmkpO1xuXG4gICAgICAgIC8vIGZpcmUgbG9hZGVkbWV0YWRhdGEgdGhlIGZpcnN0IHRpbWUgYSBtZWRpYSBwbGF5bGlzdCBpcyBsb2FkZWRcbiAgICAgICAgaWYgKHN0YXJ0aW5nU3RhdGUgPT09ICdIQVZFX01BU1RFUicpIHtcbiAgICAgICAgICBfdGhpczMudHJpZ2dlcignbG9hZGVkbWV0YWRhdGEnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczMudHJpZ2dlcignbWVkaWFjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGF1c2UgbG9hZGluZyBvZiB0aGUgcGxheWxpc3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGF1c2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIHRoaXMuc3RvcFJlcXVlc3QoKTtcbiAgICAgIHdpbmRvdyQxLmNsZWFyVGltZW91dCh0aGlzLm1lZGlhVXBkYXRlVGltZW91dCk7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0hBVkVfTk9USElORycpIHtcbiAgICAgICAgLy8gSWYgd2UgcGF1c2UgdGhlIGxvYWRlciBiZWZvcmUgYW55IGRhdGEgaGFzIGJlZW4gcmV0cmlldmVkLCBpdHMgYXMgaWYgd2UgbmV2ZXJcbiAgICAgICAgLy8gc3RhcnRlZCwgc28gcmVzZXQgdG8gYW4gdW5zdGFydGVkIHN0YXRlLlxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIE5lZWQgdG8gcmVzdG9yZSBzdGF0ZSBub3cgdGhhdCBubyBhY3Rpdml0eSBpcyBoYXBwZW5pbmdcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnU1dJVENISU5HX01FRElBJykge1xuICAgICAgICAvLyBpZiB0aGUgbG9hZGVyIHdhcyBpbiB0aGUgcHJvY2VzcyBvZiBzd2l0Y2hpbmcgbWVkaWEsIGl0IHNob3VsZCBlaXRoZXIgcmV0dXJuIHRvXG4gICAgICAgIC8vIEhBVkVfTUFTVEVSIG9yIEhBVkVfTUVUQURBVEEgZGVwZW5kaW5nIG9uIGlmIHRoZSBsb2FkZXIgaGFzIGxvYWRlZCBhIG1lZGlhXG4gICAgICAgIC8vIHBsYXlsaXN0IHlldC4gVGhpcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBleGlzdGVuY2Ugb2YgbG9hZGVyLm1lZGlhX1xuICAgICAgICBpZiAodGhpcy5tZWRpYV8pIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ0hBVkVfTUVUQURBVEEnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAnSEFWRV9NQVNURVInO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdIQVZFX0NVUlJFTlRfTUVUQURBVEEnKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnSEFWRV9NRVRBREFUQSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc3RhcnQgbG9hZGluZyBvZiB0aGUgcGxheWxpc3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbG9hZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoaXNGaW5hbFJlbmRpdGlvbikge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHdpbmRvdyQxLmNsZWFyVGltZW91dCh0aGlzLm1lZGlhVXBkYXRlVGltZW91dCk7XG5cbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEoKTtcblxuICAgICAgaWYgKGlzRmluYWxSZW5kaXRpb24pIHtcbiAgICAgICAgdmFyIGRlbGF5ID0gbWVkaWEgPyBtZWRpYS50YXJnZXREdXJhdGlvbiAvIDIgKiAxMDAwIDogNSAqIDEwMDA7XG5cbiAgICAgICAgdGhpcy5tZWRpYVVwZGF0ZVRpbWVvdXQgPSB3aW5kb3ckMS5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LmxvYWQoKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWEgJiYgIW1lZGlhLmVuZExpc3QpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdtZWRpYXVwZGF0ZXRpbWVvdXQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignbG9hZGVkcGxheWxpc3QnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdGFydCBsb2FkaW5nIG9mIHRoZSBwbGF5bGlzdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIC8vIHJlcXVlc3QgdGhlIHNwZWNpZmllZCBVUkxcbiAgICAgIHRoaXMucmVxdWVzdCA9IHRoaXMuaGxzXy54aHIoe1xuICAgICAgICB1cmk6IHRoaXMuc3JjVXJsLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHRoaXMud2l0aENyZWRlbnRpYWxzXG4gICAgICB9LCBmdW5jdGlvbiAoZXJyb3IsIHJlcSkge1xuICAgICAgICAvLyBkaXNwb3NlZFxuICAgICAgICBpZiAoIV90aGlzNS5yZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGxvYWRlcidzIHJlcXVlc3QgcmVmZXJlbmNlXG4gICAgICAgIF90aGlzNS5yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBfdGhpczUuZXJyb3IgPSB7XG4gICAgICAgICAgICBzdGF0dXM6IHJlcS5zdGF0dXMsXG4gICAgICAgICAgICBtZXNzYWdlOiAnSExTIHBsYXlsaXN0IHJlcXVlc3QgZXJyb3IgYXQgVVJMOiAnICsgX3RoaXM1LnNyY1VybCxcbiAgICAgICAgICAgIHJlc3BvbnNlVGV4dDogcmVxLnJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgIC8vIE1FRElBX0VSUl9ORVRXT1JLXG4gICAgICAgICAgICBjb2RlOiAyXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoX3RoaXM1LnN0YXRlID09PSAnSEFWRV9OT1RISU5HJykge1xuICAgICAgICAgICAgX3RoaXM1LnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF90aGlzNS50cmlnZ2VyKCdlcnJvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIoKTtcblxuICAgICAgICBwYXJzZXIucHVzaChyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgcGFyc2VyLmVuZCgpO1xuXG4gICAgICAgIF90aGlzNS5zdGF0ZSA9ICdIQVZFX01BU1RFUic7XG5cbiAgICAgICAgcGFyc2VyLm1hbmlmZXN0LnVyaSA9IF90aGlzNS5zcmNVcmw7XG5cbiAgICAgICAgLy8gbG9hZGVkIGEgbWFzdGVyIHBsYXlsaXN0XG4gICAgICAgIGlmIChwYXJzZXIubWFuaWZlc3QucGxheWxpc3RzKSB7XG4gICAgICAgICAgX3RoaXM1Lm1hc3RlciA9IHBhcnNlci5tYW5pZmVzdDtcblxuICAgICAgICAgIHNldHVwTWVkaWFQbGF5bGlzdHMoX3RoaXM1Lm1hc3Rlcik7XG4gICAgICAgICAgcmVzb2x2ZU1lZGlhR3JvdXBVcmlzKF90aGlzNS5tYXN0ZXIpO1xuXG4gICAgICAgICAgX3RoaXM1LnRyaWdnZXIoJ2xvYWRlZHBsYXlsaXN0Jyk7XG4gICAgICAgICAgaWYgKCFfdGhpczUucmVxdWVzdCkge1xuICAgICAgICAgICAgLy8gbm8gbWVkaWEgcGxheWxpc3Qgd2FzIHNwZWNpZmljYWxseSBzZWxlY3RlZCBzbyBzdGFydFxuICAgICAgICAgICAgLy8gZnJvbSB0aGUgZmlyc3QgbGlzdGVkIG9uZVxuICAgICAgICAgICAgX3RoaXM1Lm1lZGlhKHBhcnNlci5tYW5pZmVzdC5wbGF5bGlzdHNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsb2FkZWQgYSBtZWRpYSBwbGF5bGlzdFxuICAgICAgICAvLyBpbmZlciBhIG1hc3RlciBwbGF5bGlzdCBpZiBub25lIHdhcyBwcmV2aW91c2x5IHJlcXVlc3RlZFxuICAgICAgICBfdGhpczUubWFzdGVyID0ge1xuICAgICAgICAgIG1lZGlhR3JvdXBzOiB7XG4gICAgICAgICAgICAnQVVESU8nOiB7fSxcbiAgICAgICAgICAgICdWSURFTyc6IHt9LFxuICAgICAgICAgICAgJ0NMT1NFRC1DQVBUSU9OUyc6IHt9LFxuICAgICAgICAgICAgJ1NVQlRJVExFUyc6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cmk6IHdpbmRvdyQxLmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgcGxheWxpc3RzOiBbe1xuICAgICAgICAgICAgdXJpOiBfdGhpczUuc3JjVXJsLFxuICAgICAgICAgICAgaWQ6IDBcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgICBfdGhpczUubWFzdGVyLnBsYXlsaXN0c1tfdGhpczUuc3JjVXJsXSA9IF90aGlzNS5tYXN0ZXIucGxheWxpc3RzWzBdO1xuICAgICAgICBfdGhpczUubWFzdGVyLnBsYXlsaXN0c1swXS5yZXNvbHZlZFVyaSA9IF90aGlzNS5zcmNVcmw7XG4gICAgICAgIC8vIG0zdTgtcGFyc2VyIGRvZXMgbm90IGF0dGFjaCBhbiBhdHRyaWJ1dGVzIHByb3BlcnR5IHRvIG1lZGlhIHBsYXlsaXN0cyBzbyBtYWtlXG4gICAgICAgIC8vIHN1cmUgdGhhdCB0aGUgcHJvcGVydHkgaXMgYXR0YWNoZWQgdG8gYXZvaWQgdW5kZWZpbmVkIHJlZmVyZW5jZSBlcnJvcnNcbiAgICAgICAgX3RoaXM1Lm1hc3Rlci5wbGF5bGlzdHNbMF0uYXR0cmlidXRlcyA9IF90aGlzNS5tYXN0ZXIucGxheWxpc3RzWzBdLmF0dHJpYnV0ZXMgfHwge307XG4gICAgICAgIF90aGlzNS5oYXZlTWV0YWRhdGEocmVxLCBfdGhpczUuc3JjVXJsKTtcbiAgICAgICAgcmV0dXJuIF90aGlzNS50cmlnZ2VyKCdsb2FkZWRtZXRhZGF0YScpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQbGF5bGlzdExvYWRlcjtcbn0oRXZlbnRUYXJnZXQkMSk7XG5cbi8qKlxuICogQGZpbGUgcGxheWxpc3QuanNcbiAqXG4gKiBQbGF5bGlzdCByZWxhdGVkIHV0aWxpdGllcy5cbiAqL1xuXG52YXIgY3JlYXRlVGltZVJhbmdlID0gdmlkZW9qcyQxLmNyZWF0ZVRpbWVSYW5nZTtcblxuLyoqXG4gKiB3YWxrIGJhY2t3YXJkIHVudGlsIHdlIGZpbmQgYSBkdXJhdGlvbiB3ZSBjYW4gdXNlXG4gKiBvciByZXR1cm4gYSBmYWlsdXJlXG4gKlxuICogQHBhcmFtIHtQbGF5bGlzdH0gcGxheWxpc3QgdGhlIHBsYXlsaXN0IHRvIHdhbGsgdGhyb3VnaFxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZFNlcXVlbmNlIHRoZSBtZWRpYVNlcXVlbmNlIHRvIHN0b3Agd2Fsa2luZyBvblxuICovXG5cbnZhciBiYWNrd2FyZER1cmF0aW9uID0gZnVuY3Rpb24gYmFja3dhcmREdXJhdGlvbihwbGF5bGlzdCwgZW5kU2VxdWVuY2UpIHtcbiAgdmFyIHJlc3VsdCA9IDA7XG4gIHZhciBpID0gZW5kU2VxdWVuY2UgLSBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlO1xuICAvLyBpZiBhIHN0YXJ0IHRpbWUgaXMgYXZhaWxhYmxlIGZvciBzZWdtZW50IGltbWVkaWF0ZWx5IGZvbGxvd2luZ1xuICAvLyB0aGUgaW50ZXJ2YWwsIHVzZSBpdFxuICB2YXIgc2VnbWVudCA9IHBsYXlsaXN0LnNlZ21lbnRzW2ldO1xuXG4gIC8vIFdhbGsgYmFja3dhcmQgdW50aWwgd2UgZmluZCB0aGUgbGF0ZXN0IHNlZ21lbnQgd2l0aCB0aW1lbGluZVxuICAvLyBpbmZvcm1hdGlvbiB0aGF0IGlzIGVhcmxpZXIgdGhhbiBlbmRTZXF1ZW5jZVxuICBpZiAoc2VnbWVudCkge1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudC5zdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB7IHJlc3VsdDogc2VnbWVudC5zdGFydCwgcHJlY2lzZTogdHJ1ZSB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlZ21lbnQuZW5kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBzZWdtZW50LmVuZCAtIHNlZ21lbnQuZHVyYXRpb24sXG4gICAgICAgIHByZWNpc2U6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHdoaWxlIChpLS0pIHtcbiAgICBzZWdtZW50ID0gcGxheWxpc3Quc2VnbWVudHNbaV07XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50LmVuZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB7IHJlc3VsdDogcmVzdWx0ICsgc2VnbWVudC5lbmQsIHByZWNpc2U6IHRydWUgfTtcbiAgICB9XG5cbiAgICByZXN1bHQgKz0gc2VnbWVudC5kdXJhdGlvbjtcblxuICAgIGlmICh0eXBlb2Ygc2VnbWVudC5zdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB7IHJlc3VsdDogcmVzdWx0ICsgc2VnbWVudC5zdGFydCwgcHJlY2lzZTogdHJ1ZSB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyByZXN1bHQ6IHJlc3VsdCwgcHJlY2lzZTogZmFsc2UgfTtcbn07XG5cbi8qKlxuICogd2FsayBmb3J3YXJkIHVudGlsIHdlIGZpbmQgYSBkdXJhdGlvbiB3ZSBjYW4gdXNlXG4gKiBvciByZXR1cm4gYSBmYWlsdXJlXG4gKlxuICogQHBhcmFtIHtQbGF5bGlzdH0gcGxheWxpc3QgdGhlIHBsYXlsaXN0IHRvIHdhbGsgdGhyb3VnaFxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZFNlcXVlbmNlIHRoZSBtZWRpYVNlcXVlbmNlIHRvIHN0b3Agd2Fsa2luZyBvblxuICovXG52YXIgZm9yd2FyZER1cmF0aW9uID0gZnVuY3Rpb24gZm9yd2FyZER1cmF0aW9uKHBsYXlsaXN0LCBlbmRTZXF1ZW5jZSkge1xuICB2YXIgcmVzdWx0ID0gMDtcbiAgdmFyIHNlZ21lbnQgPSB2b2lkIDA7XG4gIHZhciBpID0gZW5kU2VxdWVuY2UgLSBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlO1xuICAvLyBXYWxrIGZvcndhcmQgdW50aWwgd2UgZmluZCB0aGUgZWFybGllc3Qgc2VnbWVudCB3aXRoIHRpbWVsaW5lXG4gIC8vIGluZm9ybWF0aW9uXG5cbiAgZm9yICg7IGkgPCBwbGF5bGlzdC5zZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHNlZ21lbnQgPSBwbGF5bGlzdC5zZWdtZW50c1tpXTtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQuc3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHNlZ21lbnQuc3RhcnQgLSByZXN1bHQsXG4gICAgICAgIHByZWNpc2U6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9IHNlZ21lbnQuZHVyYXRpb247XG5cbiAgICBpZiAodHlwZW9mIHNlZ21lbnQuZW5kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBzZWdtZW50LmVuZCAtIHJlc3VsdCxcbiAgICAgICAgcHJlY2lzZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLy8gaW5kaWNhdGUgd2UgZGlkbid0IGZpbmQgYSB1c2VmdWwgZHVyYXRpb24gZXN0aW1hdGVcbiAgcmV0dXJuIHsgcmVzdWx0OiAtMSwgcHJlY2lzZTogZmFsc2UgfTtcbn07XG5cbi8qKlxuICAqIENhbGN1bGF0ZSB0aGUgbWVkaWEgZHVyYXRpb24gZnJvbSB0aGUgc2VnbWVudHMgYXNzb2NpYXRlZCB3aXRoIGFcbiAgKiBwbGF5bGlzdC4gVGhlIGR1cmF0aW9uIG9mIGEgc3ViaW50ZXJ2YWwgb2YgdGhlIGF2YWlsYWJsZSBzZWdtZW50c1xuICAqIG1heSBiZSBjYWxjdWxhdGVkIGJ5IHNwZWNpZnlpbmcgYW4gZW5kIGluZGV4LlxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IHBsYXlsaXN0IGEgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gICogQHBhcmFtIHtOdW1iZXI9fSBlbmRTZXF1ZW5jZSBhbiBleGNsdXNpdmUgdXBwZXIgYm91bmRhcnlcbiAgKiBmb3IgdGhlIHBsYXlsaXN0LiAgRGVmYXVsdHMgdG8gcGxheWxpc3QgbGVuZ3RoLlxuICAqIEBwYXJhbSB7TnVtYmVyfSBleHBpcmVkIHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGhhcyBkcm9wcGVkXG4gICogb2ZmIHRoZSBmcm9udCBvZiB0aGUgcGxheWxpc3QgaW4gYSBsaXZlIHNjZW5hcmlvXG4gICogQHJldHVybiB7TnVtYmVyfSB0aGUgZHVyYXRpb24gYmV0d2VlbiB0aGUgZmlyc3QgYXZhaWxhYmxlIHNlZ21lbnRcbiAgKiBhbmQgZW5kIGluZGV4LlxuICAqL1xudmFyIGludGVydmFsRHVyYXRpb24gPSBmdW5jdGlvbiBpbnRlcnZhbER1cmF0aW9uKHBsYXlsaXN0LCBlbmRTZXF1ZW5jZSwgZXhwaXJlZCkge1xuICB2YXIgYmFja3dhcmQgPSB2b2lkIDA7XG4gIHZhciBmb3J3YXJkID0gdm9pZCAwO1xuXG4gIGlmICh0eXBlb2YgZW5kU2VxdWVuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5kU2VxdWVuY2UgPSBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlICsgcGxheWxpc3Quc2VnbWVudHMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKGVuZFNlcXVlbmNlIDwgcGxheWxpc3QubWVkaWFTZXF1ZW5jZSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gZG8gYSBiYWNrd2FyZCB3YWxrIHRvIGVzdGltYXRlIHRoZSBkdXJhdGlvblxuICBiYWNrd2FyZCA9IGJhY2t3YXJkRHVyYXRpb24ocGxheWxpc3QsIGVuZFNlcXVlbmNlKTtcbiAgaWYgKGJhY2t3YXJkLnByZWNpc2UpIHtcbiAgICAvLyBpZiB3ZSB3ZXJlIGFibGUgdG8gYmFzZSBvdXIgZHVyYXRpb24gZXN0aW1hdGUgb24gdGltaW5nXG4gICAgLy8gaW5mb3JtYXRpb24gcHJvdmlkZWQgZGlyZWN0bHkgZnJvbSB0aGUgTWVkaWEgU291cmNlLCByZXR1cm5cbiAgICAvLyBpdFxuICAgIHJldHVybiBiYWNrd2FyZC5yZXN1bHQ7XG4gIH1cblxuICAvLyB3YWxrIGZvcndhcmQgdG8gc2VlIGlmIGEgcHJlY2lzZSBkdXJhdGlvbiBlc3RpbWF0ZSBjYW4gYmUgbWFkZVxuICAvLyB0aGF0IHdheVxuICBmb3J3YXJkID0gZm9yd2FyZER1cmF0aW9uKHBsYXlsaXN0LCBlbmRTZXF1ZW5jZSk7XG4gIGlmIChmb3J3YXJkLnByZWNpc2UpIHtcbiAgICAvLyB3ZSBmb3VuZCBhIHNlZ21lbnQgdGhhdCBoYXMgYmVlbiBidWZmZXJlZCBhbmQgc28gaXQnc1xuICAgIC8vIHBvc2l0aW9uIGlzIGtub3duIHByZWNpc2VseVxuICAgIHJldHVybiBmb3J3YXJkLnJlc3VsdDtcbiAgfVxuXG4gIC8vIHJldHVybiB0aGUgbGVzcy1wcmVjaXNlLCBwbGF5bGlzdC1iYXNlZCBkdXJhdGlvbiBlc3RpbWF0ZVxuICByZXR1cm4gYmFja3dhcmQucmVzdWx0ICsgZXhwaXJlZDtcbn07XG5cbi8qKlxuICAqIENhbGN1bGF0ZXMgdGhlIGR1cmF0aW9uIG9mIGEgcGxheWxpc3QuIElmIGEgc3RhcnQgYW5kIGVuZCBpbmRleFxuICAqIGFyZSBzcGVjaWZpZWQsIHRoZSBkdXJhdGlvbiB3aWxsIGJlIGZvciB0aGUgc3Vic2V0IG9mIHRoZSBtZWRpYVxuICAqIHRpbWVsaW5lIGJldHdlZW4gdGhvc2UgdHdvIGluZGljZXMuIFRoZSB0b3RhbCBkdXJhdGlvbiBmb3IgbGl2ZVxuICAqIHBsYXlsaXN0cyBpcyBhbHdheXMgSW5maW5pdHkuXG4gICpcbiAgKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgYSBtZWRpYSBwbGF5bGlzdCBvYmplY3RcbiAgKiBAcGFyYW0ge051bWJlcj19IGVuZFNlcXVlbmNlIGFuIGV4Y2x1c2l2ZSB1cHBlclxuICAqIGJvdW5kYXJ5IGZvciB0aGUgcGxheWxpc3QuIERlZmF1bHRzIHRvIHRoZSBwbGF5bGlzdCBtZWRpYVxuICAqIHNlcXVlbmNlIG51bWJlciBwbHVzIGl0cyBsZW5ndGguXG4gICogQHBhcmFtIHtOdW1iZXI9fSBleHBpcmVkIHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGhhc1xuICAqIGRyb3BwZWQgb2ZmIHRoZSBmcm9udCBvZiB0aGUgcGxheWxpc3QgaW4gYSBsaXZlIHNjZW5hcmlvXG4gICogQHJldHVybiB7TnVtYmVyfSB0aGUgZHVyYXRpb24gYmV0d2VlbiB0aGUgc3RhcnQgaW5kZXggYW5kIGVuZFxuICAqIGluZGV4LlxuICAqL1xudmFyIGR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24ocGxheWxpc3QsIGVuZFNlcXVlbmNlLCBleHBpcmVkKSB7XG4gIGlmICghcGxheWxpc3QpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwaXJlZCAhPT0gJ251bWJlcicpIHtcbiAgICBleHBpcmVkID0gMDtcbiAgfVxuXG4gIC8vIGlmIGEgc2xpY2Ugb2YgdGhlIHRvdGFsIGR1cmF0aW9uIGlzIG5vdCByZXF1ZXN0ZWQsIHVzZVxuICAvLyBwbGF5bGlzdC1sZXZlbCBkdXJhdGlvbiBpbmRpY2F0b3JzIHdoZW4gdGhleSdyZSBwcmVzZW50XG4gIGlmICh0eXBlb2YgZW5kU2VxdWVuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gaWYgcHJlc2VudCwgdXNlIHRoZSBkdXJhdGlvbiBzcGVjaWZpZWQgaW4gdGhlIHBsYXlsaXN0XG4gICAgaWYgKHBsYXlsaXN0LnRvdGFsRHVyYXRpb24pIHtcbiAgICAgIHJldHVybiBwbGF5bGlzdC50b3RhbER1cmF0aW9uO1xuICAgIH1cblxuICAgIC8vIGR1cmF0aW9uIHNob3VsZCBiZSBJbmZpbml0eSBmb3IgbGl2ZSBwbGF5bGlzdHNcbiAgICBpZiAoIXBsYXlsaXN0LmVuZExpc3QpIHtcbiAgICAgIHJldHVybiB3aW5kb3ckMS5JbmZpbml0eTtcbiAgICB9XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIGR1cmF0aW9uIGJhc2VkIG9uIHRoZSBzZWdtZW50IGR1cmF0aW9uc1xuICByZXR1cm4gaW50ZXJ2YWxEdXJhdGlvbihwbGF5bGlzdCwgZW5kU2VxdWVuY2UsIGV4cGlyZWQpO1xufTtcblxuLyoqXG4gICogQ2FsY3VsYXRlIHRoZSB0aW1lIGJldHdlZW4gdHdvIGluZGV4ZXMgaW4gdGhlIGN1cnJlbnQgcGxheWxpc3RcbiAgKiBuZWlnaHQgdGhlIHN0YXJ0LSBub3IgdGhlIGVuZC1pbmRleCBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgY3VycmVudFxuICAqIHBsYXlsaXN0IGluIHdoaWNoIGNhc2UsIHRoZSB0YXJnZXREdXJhdGlvbiBvZiB0aGUgcGxheWxpc3QgaXMgdXNlZFxuICAqIHRvIGFwcHJveGltYXRlIHRoZSBkdXJhdGlvbnMgb2YgdGhlIHNlZ21lbnRzXG4gICpcbiAgKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgYSBtZWRpYSBwbGF5bGlzdCBvYmplY3RcbiAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRJbmRleFxuICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRJbmRleFxuICAqIEByZXR1cm4ge051bWJlcn0gdGhlIG51bWJlciBvZiBzZWNvbmRzIGJldHdlZW4gc3RhcnRJbmRleCBhbmQgZW5kSW5kZXhcbiAgKi9cbnZhciBzdW1EdXJhdGlvbnMgPSBmdW5jdGlvbiBzdW1EdXJhdGlvbnMocGxheWxpc3QsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gIHZhciBkdXJhdGlvbnMgPSAwO1xuXG4gIGlmIChzdGFydEluZGV4ID4gZW5kSW5kZXgpIHtcbiAgICB2YXIgX3JlZiA9IFtlbmRJbmRleCwgc3RhcnRJbmRleF07XG4gICAgc3RhcnRJbmRleCA9IF9yZWZbMF07XG4gICAgZW5kSW5kZXggPSBfcmVmWzFdO1xuICB9XG5cbiAgaWYgKHN0YXJ0SW5kZXggPCAwKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBNYXRoLm1pbigwLCBlbmRJbmRleCk7IGkrKykge1xuICAgICAgZHVyYXRpb25zICs9IHBsYXlsaXN0LnRhcmdldER1cmF0aW9uO1xuICAgIH1cbiAgICBzdGFydEluZGV4ID0gMDtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gc3RhcnRJbmRleDsgX2kgPCBlbmRJbmRleDsgX2krKykge1xuICAgIGR1cmF0aW9ucyArPSBwbGF5bGlzdC5zZWdtZW50c1tfaV0uZHVyYXRpb247XG4gIH1cblxuICByZXR1cm4gZHVyYXRpb25zO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBtZWRpYSBpbmRleCBvZiB0aGUgc2VnbWVudCBjb3JyZXNwb25kaW5nIHRvIHRoZSBzYWZlIGVkZ2Ugb2YgdGhlIGxpdmVcbiAqIHdpbmRvdyB3aGljaCBpcyB0aGUgZHVyYXRpb24gb2YgdGhlIGxhc3Qgc2VnbWVudCBwbHVzIDIgdGFyZ2V0IGR1cmF0aW9ucyBmcm9tIHRoZSBlbmRcbiAqIG9mIHRoZSBwbGF5bGlzdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3RcbiAqICAgICAgICBhIG1lZGlhIHBsYXlsaXN0IG9iamVjdFxuICogQHJldHVybiB7TnVtYmVyfVxuICogICAgICAgICBUaGUgbWVkaWEgaW5kZXggb2YgdGhlIHNlZ21lbnQgYXQgdGhlIHNhZmUgbGl2ZSBwb2ludC4gMCBpZiB0aGVyZSBpcyBubyBcInNhZmVcIlxuICogICAgICAgICBwb2ludC5cbiAqIEBmdW5jdGlvbiBzYWZlTGl2ZUluZGV4XG4gKi9cbnZhciBzYWZlTGl2ZUluZGV4ID0gZnVuY3Rpb24gc2FmZUxpdmVJbmRleChwbGF5bGlzdCkge1xuICBpZiAoIXBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGkgPSBwbGF5bGlzdC5zZWdtZW50cy5sZW5ndGggLSAxO1xuICB2YXIgZGlzdGFuY2VGcm9tRW5kID0gcGxheWxpc3Quc2VnbWVudHNbaV0uZHVyYXRpb24gfHwgcGxheWxpc3QudGFyZ2V0RHVyYXRpb247XG4gIHZhciBzYWZlRGlzdGFuY2UgPSBkaXN0YW5jZUZyb21FbmQgKyBwbGF5bGlzdC50YXJnZXREdXJhdGlvbiAqIDI7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGRpc3RhbmNlRnJvbUVuZCArPSBwbGF5bGlzdC5zZWdtZW50c1tpXS5kdXJhdGlvbjtcblxuICAgIGlmIChkaXN0YW5jZUZyb21FbmQgPj0gc2FmZURpc3RhbmNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXgoMCwgaSk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHBsYXlsaXN0IGVuZCB0aW1lXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBsYXlsaXN0IGEgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge051bWJlcj19IGV4cGlyZWQgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzXG4gKiAgICAgICAgICAgICAgICAgIGRyb3BwZWQgb2ZmIHRoZSBmcm9udCBvZiB0aGUgcGxheWxpc3QgaW4gYSBsaXZlIHNjZW5hcmlvXG4gKiBAcGFyYW0ge0Jvb2xlYW58ZmFsc2V9IHVzZVNhZmVMaXZlRW5kIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICBwbGF5bGlzdCBlbmQgY2FsY3VsYXRpb24gc2hvdWxkIGNvbnNpZGVyIHRoZSBzYWZlIGxpdmUgZW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICh0cnVuY2F0ZSB0aGUgcGxheWxpc3QgZW5kIGJ5IHRocmVlIHNlZ21lbnRzKS4gVGhpcyBpcyBub3JtYWxseVxuICogICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGZvciBjYWxjdWxhdGluZyB0aGUgZW5kIG9mIHRoZSBwbGF5bGlzdCdzIHNlZWthYmxlIHJhbmdlLlxuICogQHJldHVybnMge051bWJlcn0gdGhlIGVuZCB0aW1lIG9mIHBsYXlsaXN0XG4gKiBAZnVuY3Rpb24gcGxheWxpc3RFbmRcbiAqL1xudmFyIHBsYXlsaXN0RW5kID0gZnVuY3Rpb24gcGxheWxpc3RFbmQocGxheWxpc3QsIGV4cGlyZWQsIHVzZVNhZmVMaXZlRW5kKSB7XG4gIGlmICghcGxheWxpc3QgfHwgIXBsYXlsaXN0LnNlZ21lbnRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHBsYXlsaXN0LmVuZExpc3QpIHtcbiAgICByZXR1cm4gZHVyYXRpb24ocGxheWxpc3QpO1xuICB9XG5cbiAgaWYgKGV4cGlyZWQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGV4cGlyZWQgPSBleHBpcmVkIHx8IDA7XG5cbiAgdmFyIGVuZFNlcXVlbmNlID0gdXNlU2FmZUxpdmVFbmQgPyBzYWZlTGl2ZUluZGV4KHBsYXlsaXN0KSA6IHBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aDtcblxuICByZXR1cm4gaW50ZXJ2YWxEdXJhdGlvbihwbGF5bGlzdCwgcGxheWxpc3QubWVkaWFTZXF1ZW5jZSArIGVuZFNlcXVlbmNlLCBleHBpcmVkKTtcbn07XG5cbi8qKlxuICAqIENhbGN1bGF0ZXMgdGhlIGludGVydmFsIG9mIHRpbWUgdGhhdCBpcyBjdXJyZW50bHkgc2Vla2FibGUgaW4gYVxuICAqIHBsYXlsaXN0LiBUaGUgcmV0dXJuZWQgdGltZSByYW5nZXMgYXJlIHJlbGF0aXZlIHRvIHRoZSBlYXJsaWVzdFxuICAqIG1vbWVudCBpbiB0aGUgc3BlY2lmaWVkIHBsYXlsaXN0IHRoYXQgaXMgc3RpbGwgYXZhaWxhYmxlLiBBIGZ1bGxcbiAgKiBzZWVrYWJsZSBpbXBsZW1lbnRhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zIHdvdWxkIG5lZWQgdG8gb2Zmc2V0XG4gICogdGhlc2UgdmFsdWVzIGJ5IHRoZSBkdXJhdGlvbiBvZiBjb250ZW50IHRoYXQgaGFzIGV4cGlyZWQgZnJvbSB0aGVcbiAgKiBzdHJlYW0uXG4gICpcbiAgKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgYSBtZWRpYSBwbGF5bGlzdCBvYmplY3RcbiAgKiBkcm9wcGVkIG9mZiB0aGUgZnJvbnQgb2YgdGhlIHBsYXlsaXN0IGluIGEgbGl2ZSBzY2VuYXJpb1xuICAqIEBwYXJhbSB7TnVtYmVyPX0gZXhwaXJlZCB0aGUgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXNcbiAgKiBkcm9wcGVkIG9mZiB0aGUgZnJvbnQgb2YgdGhlIHBsYXlsaXN0IGluIGEgbGl2ZSBzY2VuYXJpb1xuICAqIEByZXR1cm4ge1RpbWVSYW5nZXN9IHRoZSBwZXJpb2RzIG9mIHRpbWUgdGhhdCBhcmUgdmFsaWQgdGFyZ2V0c1xuICAqIGZvciBzZWVraW5nXG4gICovXG52YXIgc2Vla2FibGUgPSBmdW5jdGlvbiBzZWVrYWJsZShwbGF5bGlzdCwgZXhwaXJlZCkge1xuICB2YXIgdXNlU2FmZUxpdmVFbmQgPSB0cnVlO1xuICB2YXIgc2Vla2FibGVTdGFydCA9IGV4cGlyZWQgfHwgMDtcbiAgdmFyIHNlZWthYmxlRW5kID0gcGxheWxpc3RFbmQocGxheWxpc3QsIGV4cGlyZWQsIHVzZVNhZmVMaXZlRW5kKTtcblxuICBpZiAoc2Vla2FibGVFbmQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlKCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZShzZWVrYWJsZVN0YXJ0LCBzZWVrYWJsZUVuZCk7XG59O1xuXG52YXIgaXNXaG9sZU51bWJlciA9IGZ1bmN0aW9uIGlzV2hvbGVOdW1iZXIobnVtKSB7XG4gIHJldHVybiBudW0gLSBNYXRoLmZsb29yKG51bSkgPT09IDA7XG59O1xuXG52YXIgcm91bmRTaWduaWZpY2FudERpZ2l0ID0gZnVuY3Rpb24gcm91bmRTaWduaWZpY2FudERpZ2l0KGluY3JlbWVudCwgbnVtKSB7XG4gIC8vIElmIHdlIGhhdmUgYSB3aG9sZSBudW1iZXIsIGp1c3QgYWRkIDEgdG8gaXRcbiAgaWYgKGlzV2hvbGVOdW1iZXIobnVtKSkge1xuICAgIHJldHVybiBudW0gKyBpbmNyZW1lbnQgKiAwLjE7XG4gIH1cblxuICB2YXIgbnVtRGVjaW1hbERpZ2l0cyA9IG51bS50b1N0cmluZygpLnNwbGl0KCcuJylbMV0ubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IG51bURlY2ltYWxEaWdpdHM7IGkrKykge1xuICAgIHZhciBzY2FsZSA9IE1hdGgucG93KDEwLCBpKTtcbiAgICB2YXIgdGVtcCA9IG51bSAqIHNjYWxlO1xuXG4gICAgaWYgKGlzV2hvbGVOdW1iZXIodGVtcCkgfHwgaSA9PT0gbnVtRGVjaW1hbERpZ2l0cykge1xuICAgICAgcmV0dXJuICh0ZW1wICsgaW5jcmVtZW50KSAvIHNjYWxlO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGNlaWxMZWFzdFNpZ25pZmljYW50RGlnaXQgPSByb3VuZFNpZ25pZmljYW50RGlnaXQuYmluZChudWxsLCAxKTtcbnZhciBmbG9vckxlYXN0U2lnbmlmaWNhbnREaWdpdCA9IHJvdW5kU2lnbmlmaWNhbnREaWdpdC5iaW5kKG51bGwsIC0xKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGluZGV4IGFuZCBlc3RpbWF0ZWQgc3RhcnRpbmcgdGltZSBvZiB0aGUgc2VnbWVudCB0aGF0XG4gKiBjb250YWlucyBhIHNwZWNpZmllZCBwbGF5YmFjayBwb3NpdGlvbiBpbiBhIG1lZGlhIHBsYXlsaXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5bGlzdCB0aGUgbWVkaWEgcGxheWxpc3QgdG8gcXVlcnlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50VGltZSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIGVhcmxpZXN0XG4gKiBwb3NzaWJsZSBwb3NpdGlvbiB0byBkZXRlcm1pbmUgdGhlIGNvbnRhaW5pbmcgc2VnbWVudCBmb3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZGV4XG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRUaW1lXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBnZXRNZWRpYUluZm9Gb3JUaW1lID0gZnVuY3Rpb24gZ2V0TWVkaWFJbmZvRm9yVGltZShwbGF5bGlzdCwgY3VycmVudFRpbWUsIHN0YXJ0SW5kZXgsIHN0YXJ0VGltZSkge1xuICB2YXIgaSA9IHZvaWQgMDtcbiAgdmFyIHNlZ21lbnQgPSB2b2lkIDA7XG4gIHZhciBudW1TZWdtZW50cyA9IHBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aDtcblxuICB2YXIgdGltZSA9IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gIGlmICh0aW1lIDwgMCkge1xuICAgIC8vIFdhbGsgYmFja3dhcmQgZnJvbSBzdGFydEluZGV4IGluIHRoZSBwbGF5bGlzdCwgYWRkaW5nIGR1cmF0aW9uc1xuICAgIC8vIHVudGlsIHdlIGZpbmQgYSBzZWdtZW50IHRoYXQgY29udGFpbnMgYHRpbWVgIGFuZCByZXR1cm4gaXRcbiAgICBpZiAoc3RhcnRJbmRleCA+IDApIHtcbiAgICAgIGZvciAoaSA9IHN0YXJ0SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBzZWdtZW50ID0gcGxheWxpc3Quc2VnbWVudHNbaV07XG4gICAgICAgIHRpbWUgKz0gZmxvb3JMZWFzdFNpZ25pZmljYW50RGlnaXQoc2VnbWVudC5kdXJhdGlvbik7XG4gICAgICAgIGlmICh0aW1lID4gMCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZWRpYUluZGV4OiBpLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUgLSBzdW1EdXJhdGlvbnMocGxheWxpc3QsIHN0YXJ0SW5kZXgsIGkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSB3ZXJlIHVuYWJsZSB0byBmaW5kIGEgZ29vZCBzZWdtZW50IHdpdGhpbiB0aGUgcGxheWxpc3RcbiAgICAvLyBzbyBzZWxlY3QgdGhlIGZpcnN0IHNlZ21lbnRcbiAgICByZXR1cm4ge1xuICAgICAgbWVkaWFJbmRleDogMCxcbiAgICAgIHN0YXJ0VGltZTogY3VycmVudFRpbWVcbiAgICB9O1xuICB9XG5cbiAgLy8gV2hlbiBzdGFydEluZGV4IGlzIG5lZ2F0aXZlLCB3ZSBmaXJzdCB3YWxrIGZvcndhcmQgdG8gZmlyc3Qgc2VnbWVudFxuICAvLyBhZGRpbmcgdGFyZ2V0IGR1cmF0aW9ucy4gSWYgd2UgXCJydW4gb3V0IG9mIHRpbWVcIiBiZWZvcmUgZ2V0dGluZyB0b1xuICAvLyB0aGUgZmlyc3Qgc2VnbWVudCwgcmV0dXJuIHRoZSBmaXJzdCBzZWdtZW50XG4gIGlmIChzdGFydEluZGV4IDwgMCkge1xuICAgIGZvciAoaSA9IHN0YXJ0SW5kZXg7IGkgPCAwOyBpKyspIHtcbiAgICAgIHRpbWUgLT0gcGxheWxpc3QudGFyZ2V0RHVyYXRpb247XG4gICAgICBpZiAodGltZSA8IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtZWRpYUluZGV4OiAwLFxuICAgICAgICAgIHN0YXJ0VGltZTogY3VycmVudFRpbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRJbmRleCA9IDA7XG4gIH1cblxuICAvLyBXYWxrIGZvcndhcmQgZnJvbSBzdGFydEluZGV4IGluIHRoZSBwbGF5bGlzdCwgc3VidHJhY3RpbmcgZHVyYXRpb25zXG4gIC8vIHVudGlsIHdlIGZpbmQgYSBzZWdtZW50IHRoYXQgY29udGFpbnMgYHRpbWVgIGFuZCByZXR1cm4gaXRcbiAgZm9yIChpID0gc3RhcnRJbmRleDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcbiAgICBzZWdtZW50ID0gcGxheWxpc3Quc2VnbWVudHNbaV07XG4gICAgdGltZSAtPSBjZWlsTGVhc3RTaWduaWZpY2FudERpZ2l0KHNlZ21lbnQuZHVyYXRpb24pO1xuICAgIGlmICh0aW1lIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVkaWFJbmRleDogaSxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUgKyBzdW1EdXJhdGlvbnMocGxheWxpc3QsIHN0YXJ0SW5kZXgsIGkpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIFdlIGFyZSBvdXQgb2YgcG9zc2libGUgY2FuZGlkYXRlcyBzbyBsb2FkIHRoZSBsYXN0IG9uZS4uLlxuICByZXR1cm4ge1xuICAgIG1lZGlhSW5kZXg6IG51bVNlZ21lbnRzIC0gMSxcbiAgICBzdGFydFRpbWU6IGN1cnJlbnRUaW1lXG4gIH07XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHBsYXlsaXN0IGlzIGJsYWNrbGlzdGVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgdGhlIG1lZGlhIHBsYXlsaXN0IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGUgcGxheWxpc3QgaXMgYmxhY2tsaXN0ZWQgb3Igbm90XG4gKiBAZnVuY3Rpb24gaXNCbGFja2xpc3RlZFxuICovXG52YXIgaXNCbGFja2xpc3RlZCA9IGZ1bmN0aW9uIGlzQmxhY2tsaXN0ZWQocGxheWxpc3QpIHtcbiAgcmV0dXJuIHBsYXlsaXN0LmV4Y2x1ZGVVbnRpbCAmJiBwbGF5bGlzdC5leGNsdWRlVW50aWwgPiBEYXRlLm5vdygpO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBwbGF5bGlzdCBpcyBjb21wYXRpYmxlIHdpdGggY3VycmVudCBwbGF5YmFjayBjb25maWd1cmF0aW9uIG9yIGhhc1xuICogYmVlbiBibGFja2xpc3RlZCBwZXJtYW5lbnRseSBmb3IgYmVpbmcgaW5jb21wYXRpYmxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5bGlzdCB0aGUgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSBwbGF5bGlzdCBpcyBpbmNvbXBhdGlibGUgb3Igbm90XG4gKiBAZnVuY3Rpb24gaXNJbmNvbXBhdGlibGVcbiAqL1xudmFyIGlzSW5jb21wYXRpYmxlID0gZnVuY3Rpb24gaXNJbmNvbXBhdGlibGUocGxheWxpc3QpIHtcbiAgcmV0dXJuIHBsYXlsaXN0LmV4Y2x1ZGVVbnRpbCAmJiBwbGF5bGlzdC5leGNsdWRlVW50aWwgPT09IEluZmluaXR5O1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBwbGF5bGlzdCBpcyBlbmFibGVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgdGhlIG1lZGlhIHBsYXlsaXN0IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGUgcGxheWxpc3QgaXMgZW5hYmxlZCBvciBub3RcbiAqIEBmdW5jdGlvbiBpc0VuYWJsZWRcbiAqL1xudmFyIGlzRW5hYmxlZCA9IGZ1bmN0aW9uIGlzRW5hYmxlZChwbGF5bGlzdCkge1xuICB2YXIgYmxhY2tsaXN0ZWQgPSBpc0JsYWNrbGlzdGVkKHBsYXlsaXN0KTtcblxuICByZXR1cm4gIXBsYXlsaXN0LmRpc2FibGVkICYmICFibGFja2xpc3RlZDtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgcGxheWxpc3QgaGFzIGJlZW4gbWFudWFsbHkgZGlzYWJsZWQgdGhyb3VnaCB0aGUgcmVwcmVzZW50YXRpb25zIGFwaS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgdGhlIG1lZGlhIHBsYXlsaXN0IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGUgcGxheWxpc3QgaXMgZGlzYWJsZWQgbWFudWFsbHkgb3Igbm90XG4gKiBAZnVuY3Rpb24gaXNEaXNhYmxlZFxuICovXG52YXIgaXNEaXNhYmxlZCA9IGZ1bmN0aW9uIGlzRGlzYWJsZWQocGxheWxpc3QpIHtcbiAgcmV0dXJuIHBsYXlsaXN0LmRpc2FibGVkO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcGxheWxpc3QgaXMgYW4gQUVTIGVuY3J5cHRlZCBITFMgc3RyZWFtXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCdzIGFuIEFFUyBlbmNyeXB0ZWQgSExTIHN0cmVhbVxuICovXG52YXIgaXNBZXMgPSBmdW5jdGlvbiBpc0FlcyhtZWRpYSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhLnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1lZGlhLnNlZ21lbnRzW2ldLmtleSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHBsYXlsaXN0IGNvbnRhaW5zIGZNUDRcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBwbGF5bGlzdCBjb250YWlucyBmTVA0XG4gKi9cbnZhciBpc0ZtcDQgPSBmdW5jdGlvbiBpc0ZtcDQobWVkaWEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWRpYS5zZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtZWRpYS5zZWdtZW50c1tpXS5tYXApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcGxheWxpc3QgaGFzIGEgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJcbiAqICAgICAgICBBdHRyaWJ1dGUgdG8gY2hlY2sgZm9yXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3RcbiAqICAgICAgICBUaGUgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogICAgICAgICBXaGV0aGVyIHRoZSBwbGF5bGlzdCBjb250YWlucyBhIHZhbHVlIGZvciB0aGUgYXR0cmlidXRlIG9yIG5vdFxuICogQGZ1bmN0aW9uIGhhc0F0dHJpYnV0ZVxuICovXG52YXIgaGFzQXR0cmlidXRlID0gZnVuY3Rpb24gaGFzQXR0cmlidXRlKGF0dHIsIHBsYXlsaXN0KSB7XG4gIHJldHVybiBwbGF5bGlzdC5hdHRyaWJ1dGVzICYmIHBsYXlsaXN0LmF0dHJpYnV0ZXNbYXR0cl07XG59O1xuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgdGltZSByZXF1aXJlZCB0byBjb21wbGV0ZSBhIHNlZ21lbnQgZG93bmxvYWQgZnJvbSB0aGUgc3BlY2lmaWVkIHBsYXlsaXN0XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNlZ21lbnREdXJhdGlvblxuICogICAgICAgIER1cmF0aW9uIG9mIHJlcXVlc3RlZCBzZWdtZW50XG4gKiBAcGFyYW0ge051bWJlcn0gYmFuZHdpZHRoXG4gKiAgICAgICAgQ3VycmVudCBtZWFzdXJlZCBiYW5kd2lkdGggb2YgdGhlIHBsYXllclxuICogQHBhcmFtIHtPYmplY3R9IHBsYXlsaXN0XG4gKiAgICAgICAgVGhlIG1lZGlhIHBsYXlsaXN0IG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXI9fSBieXRlc1JlY2VpdmVkXG4gKiAgICAgICAgTnVtYmVyIG9mIGJ5dGVzIGFscmVhZHkgcmVjZWl2ZWQgZm9yIHRoZSByZXF1ZXN0LiBEZWZhdWx0cyB0byAwXG4gKiBAcmV0dXJuIHtOdW1iZXJ8TmFOfVxuICogICAgICAgICBUaGUgZXN0aW1hdGVkIHRpbWUgdG8gcmVxdWVzdCB0aGUgc2VnbWVudC4gTmFOIGlmIGJhbmR3aWR0aCBpbmZvcm1hdGlvbiBmb3JcbiAqICAgICAgICAgdGhlIGdpdmVuIHBsYXlsaXN0IGlzIHVuYXZhaWxhYmxlXG4gKiBAZnVuY3Rpb24gZXN0aW1hdGVTZWdtZW50UmVxdWVzdFRpbWVcbiAqL1xudmFyIGVzdGltYXRlU2VnbWVudFJlcXVlc3RUaW1lID0gZnVuY3Rpb24gZXN0aW1hdGVTZWdtZW50UmVxdWVzdFRpbWUoc2VnbWVudER1cmF0aW9uLCBiYW5kd2lkdGgsIHBsYXlsaXN0KSB7XG4gIHZhciBieXRlc1JlY2VpdmVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuXG4gIGlmICghaGFzQXR0cmlidXRlKCdCQU5EV0lEVEgnLCBwbGF5bGlzdCkpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgdmFyIHNpemUgPSBzZWdtZW50RHVyYXRpb24gKiBwbGF5bGlzdC5hdHRyaWJ1dGVzLkJBTkRXSURUSDtcblxuICByZXR1cm4gKHNpemUgLSBieXRlc1JlY2VpdmVkICogOCkgLyBiYW5kd2lkdGg7XG59O1xuXG4vKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHBsYXlsaXN0IGlzIHRoZSBsb3dlc3QgcmVuZGl0aW9uXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvbiBsb3dlc3QgcmVuZGl0aW9uXG4gKi9cbnZhciBpc0xvd2VzdEVuYWJsZWRSZW5kaXRpb24gPSBmdW5jdGlvbiBpc0xvd2VzdEVuYWJsZWRSZW5kaXRpb24obWFzdGVyLCBtZWRpYSkge1xuICBpZiAobWFzdGVyLnBsYXlsaXN0cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBjdXJyZW50QmFuZHdpZHRoID0gbWVkaWEuYXR0cmlidXRlcy5CQU5EV0lEVEggfHwgTnVtYmVyLk1BWF9WQUxVRTtcblxuICByZXR1cm4gbWFzdGVyLnBsYXlsaXN0cy5maWx0ZXIoZnVuY3Rpb24gKHBsYXlsaXN0KSB7XG4gICAgaWYgKCFpc0VuYWJsZWQocGxheWxpc3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIChwbGF5bGlzdC5hdHRyaWJ1dGVzLkJBTkRXSURUSCB8fCAwKSA8IGN1cnJlbnRCYW5kd2lkdGg7XG4gIH0pLmxlbmd0aCA9PT0gMDtcbn07XG5cbi8vIGV4cG9ydHNcbnZhciBQbGF5bGlzdCA9IHtcbiAgZHVyYXRpb246IGR1cmF0aW9uLFxuICBzZWVrYWJsZTogc2Vla2FibGUsXG4gIHNhZmVMaXZlSW5kZXg6IHNhZmVMaXZlSW5kZXgsXG4gIGdldE1lZGlhSW5mb0ZvclRpbWU6IGdldE1lZGlhSW5mb0ZvclRpbWUsXG4gIGlzRW5hYmxlZDogaXNFbmFibGVkLFxuICBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLFxuICBpc0JsYWNrbGlzdGVkOiBpc0JsYWNrbGlzdGVkLFxuICBpc0luY29tcGF0aWJsZTogaXNJbmNvbXBhdGlibGUsXG4gIHBsYXlsaXN0RW5kOiBwbGF5bGlzdEVuZCxcbiAgaXNBZXM6IGlzQWVzLFxuICBpc0ZtcDQ6IGlzRm1wNCxcbiAgaGFzQXR0cmlidXRlOiBoYXNBdHRyaWJ1dGUsXG4gIGVzdGltYXRlU2VnbWVudFJlcXVlc3RUaW1lOiBlc3RpbWF0ZVNlZ21lbnRSZXF1ZXN0VGltZSxcbiAgaXNMb3dlc3RFbmFibGVkUmVuZGl0aW9uOiBpc0xvd2VzdEVuYWJsZWRSZW5kaXRpb25cbn07XG5cbi8qKlxuICogQGZpbGUgeGhyLmpzXG4gKi9cblxudmFyIHZpZGVvanNYSFIgPSB2aWRlb2pzJDEueGhyLFxuICAgIG1lcmdlT3B0aW9ucyQxJDEgPSB2aWRlb2pzJDEubWVyZ2VPcHRpb25zO1xuXG52YXIgeGhyRmFjdG9yeSA9IGZ1bmN0aW9uIHhockZhY3RvcnkoKSB7XG4gIHZhciB4aHIkJDEgPSBmdW5jdGlvbiBYaHJGdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIC8vIEFkZCBhIGRlZmF1bHQgdGltZW91dCBmb3IgYWxsIGhscyByZXF1ZXN0c1xuICAgIG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMkMSQxKHtcbiAgICAgIHRpbWVvdXQ6IDQ1ZTNcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIC8vIEFsbG93IGFuIG9wdGlvbmFsIHVzZXItc3BlY2lmaWVkIGZ1bmN0aW9uIHRvIG1vZGlmeSB0aGUgb3B0aW9uXG4gICAgLy8gb2JqZWN0IGJlZm9yZSB3ZSBjb25zdHJ1Y3QgdGhlIHhociByZXF1ZXN0XG4gICAgdmFyIGJlZm9yZVJlcXVlc3QgPSBYaHJGdW5jdGlvbi5iZWZvcmVSZXF1ZXN0IHx8IHZpZGVvanMkMS5IbHMueGhyLmJlZm9yZVJlcXVlc3Q7XG5cbiAgICBpZiAoYmVmb3JlUmVxdWVzdCAmJiB0eXBlb2YgYmVmb3JlUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIG5ld09wdGlvbnMgPSBiZWZvcmVSZXF1ZXN0KG9wdGlvbnMpO1xuXG4gICAgICBpZiAobmV3T3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IHZpZGVvanNYSFIob3B0aW9ucywgZnVuY3Rpb24gKGVycm9yLCByZXNwb25zZSkge1xuICAgICAgdmFyIHJlcVJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcblxuICAgICAgaWYgKCFlcnJvciAmJiByZXFSZXNwb25zZSkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJlcXVlc3Qucm91bmRUcmlwVGltZSA9IHJlcXVlc3QucmVzcG9uc2VUaW1lIC0gcmVxdWVzdC5yZXF1ZXN0VGltZTtcbiAgICAgICAgcmVxdWVzdC5ieXRlc1JlY2VpdmVkID0gcmVxUmVzcG9uc2UuYnl0ZUxlbmd0aCB8fCByZXFSZXNwb25zZS5sZW5ndGg7XG4gICAgICAgIGlmICghcmVxdWVzdC5iYW5kd2lkdGgpIHtcbiAgICAgICAgICByZXF1ZXN0LmJhbmR3aWR0aCA9IE1hdGguZmxvb3IocmVxdWVzdC5ieXRlc1JlY2VpdmVkIC8gcmVxdWVzdC5yb3VuZFRyaXBUaW1lICogOCAqIDEwMDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2UuaGVhZGVycztcbiAgICAgIH1cblxuICAgICAgLy8gdmlkZW9qcy54aHIgbm93IHVzZXMgYSBzcGVjaWZpYyBjb2RlIG9uIHRoZSBlcnJvclxuICAgICAgLy8gb2JqZWN0IHRvIHNpZ25hbCB0aGF0IGEgcmVxdWVzdCBoYXMgdGltZWQgb3V0IGluc3RlYWRcbiAgICAgIC8vIG9mIHNldHRpbmcgYSBib29sZWFuIG9uIHRoZSByZXF1ZXN0IG9iamVjdFxuICAgICAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09ICdFVElNRURPVVQnKSB7XG4gICAgICAgIHJlcXVlc3QudGltZWRvdXQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB2aWRlb2pzLnhociBubyBsb25nZXIgY29uc2lkZXJzIHN0YXR1cyBjb2RlcyBvdXRzaWRlIG9mIDIwMCBhbmQgMFxuICAgICAgLy8gKGZvciBmaWxlIHVyaXMpIHRvIGJlIGVycm9ycywgYnV0IHRoZSBvbGQgWEhSIGRpZCwgc28gZW11bGF0ZSB0aGF0XG4gICAgICAvLyBiZWhhdmlvci4gU3RhdHVzIDIwNiBtYXkgYmUgdXNlZCBpbiByZXNwb25zZSB0byBieXRlcmFuZ2UgcmVxdWVzdHMuXG4gICAgICBpZiAoIWVycm9yICYmICFyZXF1ZXN0LmFib3J0ZWQgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMjAwICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDIwNiAmJiByZXNwb25zZS5zdGF0dXNDb2RlICE9PSAwKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdYSFIgRmFpbGVkIHdpdGggYSByZXNwb25zZSBvZjogJyArIChyZXF1ZXN0ICYmIChyZXFSZXNwb25zZSB8fCByZXF1ZXN0LnJlc3BvbnNlVGV4dCkpKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soZXJyb3IsIHJlcXVlc3QpO1xuICAgIH0pO1xuICAgIHZhciBvcmlnaW5hbEFib3J0ID0gcmVxdWVzdC5hYm9ydDtcblxuICAgIHJlcXVlc3QuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXF1ZXN0LmFib3J0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIG9yaWdpbmFsQWJvcnQuYXBwbHkocmVxdWVzdCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHJlcXVlc3QudXJpID0gb3B0aW9ucy51cmk7XG4gICAgcmVxdWVzdC5yZXF1ZXN0VGltZSA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH07XG5cbiAgcmV0dXJuIHhociQkMTtcbn07XG5cbi8qKlxuICogQGZpbGUgYmluLXV0aWxzLmpzXG4gKi9cblxuLyoqXG4gKiBjb252ZXJ0IGEgVGltZVJhbmdlIHRvIHRleHRcbiAqXG4gKiBAcGFyYW0ge1RpbWVSYW5nZX0gcmFuZ2UgdGhlIHRpbWVyYW5nZSB0byB1c2UgZm9yIGNvbnZlcnNpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBpIHRoZSBpdGVyYXRvciBvbiB0aGUgcmFuZ2UgdG8gY29udmVydFxuICovXG52YXIgdGV4dFJhbmdlID0gZnVuY3Rpb24gdGV4dFJhbmdlKHJhbmdlLCBpKSB7XG4gIHJldHVybiByYW5nZS5zdGFydChpKSArICctJyArIHJhbmdlLmVuZChpKTtcbn07XG5cbi8qKlxuICogZm9ybWF0IGEgbnVtYmVyIGFzIGhleCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZSBUaGUgbnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gaSB0aGUgaXRlcmF0b3JcbiAqL1xudmFyIGZvcm1hdEhleFN0cmluZyA9IGZ1bmN0aW9uIGZvcm1hdEhleFN0cmluZyhlLCBpKSB7XG4gIHZhciB2YWx1ZSA9IGUudG9TdHJpbmcoMTYpO1xuXG4gIHJldHVybiAnMDAnLnN1YnN0cmluZygwLCAyIC0gdmFsdWUubGVuZ3RoKSArIHZhbHVlICsgKGkgJSAyID8gJyAnIDogJycpO1xufTtcbnZhciBmb3JtYXRBc2NpaVN0cmluZyA9IGZ1bmN0aW9uIGZvcm1hdEFzY2lpU3RyaW5nKGUpIHtcbiAgaWYgKGUgPj0gMHgyMCAmJiBlIDwgMHg3ZSkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpO1xuICB9XG4gIHJldHVybiAnLic7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGZvciBzZW5kaW5nIHRvIGEgd2ViIHdvcmtlciBtb2RpZnlpbmcgcHJvcGVydGllcyB0aGF0IGFyZSBUeXBlZEFycmF5c1xuICogaW50byBhIG5ldyBvYmplY3Qgd2l0aCBzZXBlcmF0ZWQgcHJvcGVydGllcyBmb3IgdGhlIGJ1ZmZlciwgYnl0ZU9mZnNldCwgYW5kIGJ5dGVMZW5ndGguXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VcbiAqICAgICAgICBPYmplY3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHRvIHNlbmQgdG8gdGhlIHdlYiB3b3JrZXJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgTW9kaWZpZWQgbWVzc2FnZSB3aXRoIFR5cGVkQXJyYXkgdmFsdWVzIGV4cGFuZGVkXG4gKiBAZnVuY3Rpb24gY3JlYXRlVHJhbnNmZXJhYmxlTWVzc2FnZVxuICovXG52YXIgY3JlYXRlVHJhbnNmZXJhYmxlTWVzc2FnZSA9IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zZmVyYWJsZU1lc3NhZ2UobWVzc2FnZSkge1xuICB2YXIgdHJhbnNmZXJhYmxlID0ge307XG5cbiAgT2JqZWN0LmtleXMobWVzc2FnZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbHVlID0gbWVzc2FnZVtrZXldO1xuXG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgIHRyYW5zZmVyYWJsZVtrZXldID0ge1xuICAgICAgICBieXRlczogdmFsdWUuYnVmZmVyLFxuICAgICAgICBieXRlT2Zmc2V0OiB2YWx1ZS5ieXRlT2Zmc2V0LFxuICAgICAgICBieXRlTGVuZ3RoOiB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2ZlcmFibGVba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRyYW5zZmVyYWJsZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHVuaXF1ZSBzdHJpbmcgaWRlbnRpZmllciBmb3IgYSBtZWRpYSBpbml0aWFsaXphdGlvblxuICogc2VnbWVudC5cbiAqL1xudmFyIGluaXRTZWdtZW50SWQgPSBmdW5jdGlvbiBpbml0U2VnbWVudElkKGluaXRTZWdtZW50KSB7XG4gIHZhciBieXRlcmFuZ2UgPSBpbml0U2VnbWVudC5ieXRlcmFuZ2UgfHwge1xuICAgIGxlbmd0aDogSW5maW5pdHksXG4gICAgb2Zmc2V0OiAwXG4gIH07XG5cbiAgcmV0dXJuIFtieXRlcmFuZ2UubGVuZ3RoLCBieXRlcmFuZ2Uub2Zmc2V0LCBpbml0U2VnbWVudC5yZXNvbHZlZFVyaV0uam9pbignLCcpO1xufTtcblxuLyoqXG4gKiB1dGlscyB0byBoZWxwIGR1bXAgYmluYXJ5IGRhdGEgdG8gdGhlIGNvbnNvbGVcbiAqL1xudmFyIGhleER1bXAgPSBmdW5jdGlvbiBoZXhEdW1wKGRhdGEpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSk7XG4gIHZhciBzdGVwID0gMTY7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGhleCA9IHZvaWQgMDtcbiAgdmFyIGFzY2lpID0gdm9pZCAwO1xuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgYnl0ZXMubGVuZ3RoIC8gc3RlcDsgaisrKSB7XG4gICAgaGV4ID0gYnl0ZXMuc2xpY2UoaiAqIHN0ZXAsIGogKiBzdGVwICsgc3RlcCkubWFwKGZvcm1hdEhleFN0cmluZykuam9pbignJyk7XG4gICAgYXNjaWkgPSBieXRlcy5zbGljZShqICogc3RlcCwgaiAqIHN0ZXAgKyBzdGVwKS5tYXAoZm9ybWF0QXNjaWlTdHJpbmcpLmpvaW4oJycpO1xuICAgIHJlc3VsdCArPSBoZXggKyAnICcgKyBhc2NpaSArICdcXG4nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciB0YWdEdW1wID0gZnVuY3Rpb24gdGFnRHVtcChfcmVmKSB7XG4gIHZhciBieXRlcyA9IF9yZWYuYnl0ZXM7XG4gIHJldHVybiBoZXhEdW1wKGJ5dGVzKTtcbn07XG5cbnZhciB0ZXh0UmFuZ2VzID0gZnVuY3Rpb24gdGV4dFJhbmdlcyhyYW5nZXMpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgaSA9IHZvaWQgMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IHRleHRSYW5nZShyYW5nZXMsIGkpICsgJyAnO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgdXRpbHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIGNyZWF0ZVRyYW5zZmVyYWJsZU1lc3NhZ2U6IGNyZWF0ZVRyYW5zZmVyYWJsZU1lc3NhZ2UsXG4gIGluaXRTZWdtZW50SWQ6IGluaXRTZWdtZW50SWQsXG4gIGhleER1bXA6IGhleER1bXAsXG4gIHRhZ0R1bXA6IHRhZ0R1bXAsXG4gIHRleHRSYW5nZXM6IHRleHRSYW5nZXNcbn0pO1xuXG4vKipcbiAqIHJhbmdlc1xuICpcbiAqIFV0aWxpdGllcyBmb3Igd29ya2luZyB3aXRoIFRpbWVSYW5nZXMuXG4gKlxuICovXG5cbi8vIEZ1ZGdlIGZhY3RvciB0byBhY2NvdW50IGZvciBUaW1lUmFuZ2VzIHJvdW5kaW5nXG52YXIgVElNRV9GVURHRV9GQUNUT1IgPSAxIC8gMzA7XG4vLyBDb21wYXJpc29ucyBiZXR3ZWVuIHRpbWUgdmFsdWVzIHN1Y2ggYXMgY3VycmVudCB0aW1lIGFuZCB0aGUgZW5kIG9mIHRoZSBidWZmZXJlZCByYW5nZVxuLy8gY2FuIGJlIG1pc2xlYWRpbmcgYmVjYXVzZSBvZiBwcmVjaXNpb24gZGlmZmVyZW5jZXMgb3Igd2hlbiB0aGUgY3VycmVudCBtZWRpYSBoYXMgcG9vcmx5XG4vLyBhbGlnbmVkIGF1ZGlvIGFuZCB2aWRlbywgd2hpY2ggY2FuIGNhdXNlIHZhbHVlcyB0byBiZSBzbGlnaHRseSBvZmYgZnJvbSB3aGF0IHlvdSB3b3VsZFxuLy8gZXhwZWN0LiBUaGlzIHZhbHVlIGlzIHdoYXQgd2UgY29uc2lkZXIgdG8gYmUgc2FmZSB0byB1c2UgaW4gc3VjaCBjb21wYXJpc29ucyB0byBhY2NvdW50XG4vLyBmb3IgdGhlc2Ugc2NlbmFyaW9zLlxudmFyIFNBRkVfVElNRV9ERUxUQSA9IFRJTUVfRlVER0VfRkFDVE9SICogMztcbnZhciBmaWx0ZXJSYW5nZXMgPSBmdW5jdGlvbiBmaWx0ZXJSYW5nZXModGltZVJhbmdlcywgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciBpID0gdm9pZCAwO1xuXG4gIGlmICh0aW1lUmFuZ2VzICYmIHRpbWVSYW5nZXMubGVuZ3RoKSB7XG4gICAgLy8gU2VhcmNoIGZvciByYW5nZXMgdGhhdCBtYXRjaCB0aGUgcHJlZGljYXRlXG4gICAgZm9yIChpID0gMDsgaSA8IHRpbWVSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodGltZVJhbmdlcy5zdGFydChpKSwgdGltZVJhbmdlcy5lbmQoaSkpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChbdGltZVJhbmdlcy5zdGFydChpKSwgdGltZVJhbmdlcy5lbmQoaSldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmlkZW9qcyQxLmNyZWF0ZVRpbWVSYW5nZXMocmVzdWx0cyk7XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGZpbmQgdGhlIGJ1ZmZlcmVkIFRpbWVSYW5nZSB0aGF0IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWRcbiAqIHRpbWUuXG4gKiBAcGFyYW0ge1RpbWVSYW5nZXN9IGJ1ZmZlcmVkIC0gdGhlIFRpbWVSYW5nZXMgb2JqZWN0IHRvIHF1ZXJ5XG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSAgLSB0aGUgdGltZSB0byBmaWx0ZXIgb24uXG4gKiBAcmV0dXJucyB7VGltZVJhbmdlc30gYSBuZXcgVGltZVJhbmdlcyBvYmplY3RcbiAqL1xudmFyIGZpbmRSYW5nZSA9IGZ1bmN0aW9uIGZpbmRSYW5nZShidWZmZXJlZCwgdGltZSkge1xuICByZXR1cm4gZmlsdGVyUmFuZ2VzKGJ1ZmZlcmVkLCBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBzdGFydCAtIFRJTUVfRlVER0VfRkFDVE9SIDw9IHRpbWUgJiYgZW5kICsgVElNRV9GVURHRV9GQUNUT1IgPj0gdGltZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIFRpbWVSYW5nZXMgdGhhdCBiZWdpbiBsYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQgdGltZS5cbiAqIEBwYXJhbSB7VGltZVJhbmdlc30gdGltZVJhbmdlcyAtIHRoZSBUaW1lUmFuZ2VzIG9iamVjdCB0byBxdWVyeVxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgLSB0aGUgdGltZSB0byBmaWx0ZXIgb24uXG4gKiBAcmV0dXJucyB7VGltZVJhbmdlc30gYSBuZXcgVGltZVJhbmdlcyBvYmplY3QuXG4gKi9cbnZhciBmaW5kTmV4dFJhbmdlID0gZnVuY3Rpb24gZmluZE5leHRSYW5nZSh0aW1lUmFuZ2VzLCB0aW1lKSB7XG4gIHJldHVybiBmaWx0ZXJSYW5nZXModGltZVJhbmdlcywgZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgcmV0dXJuIHN0YXJ0IC0gVElNRV9GVURHRV9GQUNUT1IgPj0gdGltZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZ2FwcyB3aXRoaW4gYSBsaXN0IG9mIFRpbWVSYW5nZXNcbiAqIEBwYXJhbSB7VGltZVJhbmdlc30gYnVmZmVyZWQgLSB0aGUgVGltZVJhbmdlcyBvYmplY3RcbiAqIEByZXR1cm4ge1RpbWVSYW5nZXN9IGEgVGltZVJhbmdlcyBvYmplY3Qgb2YgZ2Fwc1xuICovXG52YXIgZmluZEdhcHMgPSBmdW5jdGlvbiBmaW5kR2FwcyhidWZmZXJlZCkge1xuICBpZiAoYnVmZmVyZWQubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiB2aWRlb2pzJDEuY3JlYXRlVGltZVJhbmdlcygpO1xuICB9XG5cbiAgdmFyIHJhbmdlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RhcnQgPSBidWZmZXJlZC5lbmQoaSAtIDEpO1xuICAgIHZhciBlbmQgPSBidWZmZXJlZC5zdGFydChpKTtcblxuICAgIHJhbmdlcy5wdXNoKFtzdGFydCwgZW5kXSk7XG4gIH1cblxuICByZXR1cm4gdmlkZW9qcyQxLmNyZWF0ZVRpbWVSYW5nZXMocmFuZ2VzKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGh1bWFuIHJlYWRhYmxlIHN0cmluZyBmb3IgYSBUaW1lUmFuZ2VcbiAqXG4gKiBAcGFyYW0ge1RpbWVSYW5nZX0gcmFuZ2VcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGEgaHVtYW4gcmVhZGFibGUgc3RyaW5nXG4gKi9cbnZhciBwcmludGFibGVSYW5nZSA9IGZ1bmN0aW9uIHByaW50YWJsZVJhbmdlKHJhbmdlKSB7XG4gIHZhciBzdHJBcnIgPSBbXTtcblxuICBpZiAoIXJhbmdlIHx8ICFyYW5nZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RyQXJyLnB1c2gocmFuZ2Uuc3RhcnQoaSkgKyAnID0+ICcgKyByYW5nZS5lbmQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIHN0ckFyci5qb2luKCcsICcpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhbW91bnQgb2YgdGltZSBsZWZ0IGluIHNlY29uZHMgdW50aWwgdGhlIHBsYXllciBoaXRzIHRoZSBlbmQgb2YgdGhlXG4gKiBidWZmZXIgYW5kIGNhdXNlcyBhIHJlYnVmZmVyXG4gKlxuICogQHBhcmFtIHtUaW1lUmFuZ2V9IGJ1ZmZlcmVkXG4gKiAgICAgICAgVGhlIHN0YXRlIG9mIHRoZSBidWZmZXJcbiAqIEBwYXJhbSB7TnVtbmJlcn0gY3VycmVudFRpbWVcbiAqICAgICAgICBUaGUgY3VycmVudCB0aW1lIG9mIHRoZSBwbGF5ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwbGF5YmFja1JhdGVcbiAqICAgICAgICBUaGUgY3VycmVudCBwbGF5YmFjayByYXRlIG9mIHRoZSBwbGF5ZXIuIERlZmF1bHRzIHRvIDEuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiAgICAgICAgIFRpbWUgdW50aWwgdGhlIHBsYXllciBoYXMgdG8gc3RhcnQgcmVidWZmZXJpbmcgaW4gc2Vjb25kcy5cbiAqIEBmdW5jdGlvbiB0aW1lVW50aWxSZWJ1ZmZlclxuICovXG52YXIgdGltZVVudGlsUmVidWZmZXIgPSBmdW5jdGlvbiB0aW1lVW50aWxSZWJ1ZmZlcihidWZmZXJlZCwgY3VycmVudFRpbWUpIHtcbiAgdmFyIHBsYXliYWNrUmF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcblxuICB2YXIgYnVmZmVyZWRFbmQgPSBidWZmZXJlZC5sZW5ndGggPyBidWZmZXJlZC5lbmQoYnVmZmVyZWQubGVuZ3RoIC0gMSkgOiAwO1xuXG4gIHJldHVybiAoYnVmZmVyZWRFbmQgLSBjdXJyZW50VGltZSkgLyBwbGF5YmFja1JhdGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVGltZVJhbmdlcyBvYmplY3QgaW50byBhbiBhcnJheSByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIHtUaW1lUmFuZ2VzfSB0aW1lUmFuZ2VzXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbnZhciB0aW1lUmFuZ2VzVG9BcnJheSA9IGZ1bmN0aW9uIHRpbWVSYW5nZXNUb0FycmF5KHRpbWVSYW5nZXMpIHtcbiAgdmFyIHRpbWVSYW5nZXNMaXN0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lUmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGltZVJhbmdlc0xpc3QucHVzaCh7XG4gICAgICBzdGFydDogdGltZVJhbmdlcy5zdGFydChpKSxcbiAgICAgIGVuZDogdGltZVJhbmdlcy5lbmQoaSlcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aW1lUmFuZ2VzTGlzdDtcbn07XG5cbi8qKlxuICogQGZpbGUgY3JlYXRlLXRleHQtdHJhY2tzLWlmLW5lY2Vzc2FyeS5qc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIHRleHQgdHJhY2tzIG9uIHZpZGVvLmpzIGlmIHRoZXkgZXhpc3Qgb24gYSBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VCdWZmZXIgdGhlIFZTQiBvciBGU0JcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZWRpYVNvdXJjZSB0aGUgSFRNTCBtZWRpYSBzb3VyY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWdtZW50IHRoZSBzZWdtZW50IHRoYXQgbWF5IGNvbnRhaW4gdGhlIHRleHQgdHJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBjcmVhdGVUZXh0VHJhY2tzSWZOZWNlc3NhcnkgPSBmdW5jdGlvbiBjcmVhdGVUZXh0VHJhY2tzSWZOZWNlc3Nhcnkoc291cmNlQnVmZmVyLCBtZWRpYVNvdXJjZSwgc2VnbWVudCkge1xuICB2YXIgcGxheWVyID0gbWVkaWFTb3VyY2UucGxheWVyXztcblxuICAvLyBjcmVhdGUgYW4gaW4tYmFuZCBjYXB0aW9uIHRyYWNrIGlmIG9uZSBpcyBwcmVzZW50IGluIHRoZSBzZWdtZW50XG4gIGlmIChzZWdtZW50LmNhcHRpb25zICYmIHNlZ21lbnQuY2FwdGlvbnMubGVuZ3RoKSB7XG4gICAgaWYgKCFzb3VyY2VCdWZmZXIuaW5iYW5kVGV4dFRyYWNrc18pIHtcbiAgICAgIHNvdXJjZUJ1ZmZlci5pbmJhbmRUZXh0VHJhY2tzXyA9IHt9O1xuICAgIH1cblxuICAgIGZvciAodmFyIHRyYWNrSWQgaW4gc2VnbWVudC5jYXB0aW9uU3RyZWFtcykge1xuICAgICAgaWYgKCFzb3VyY2VCdWZmZXIuaW5iYW5kVGV4dFRyYWNrc19bdHJhY2tJZF0pIHtcbiAgICAgICAgcGxheWVyLnRlY2hfLnRyaWdnZXIoeyB0eXBlOiAndXNhZ2UnLCBuYW1lOiAnaGxzLTYwOCcgfSk7XG4gICAgICAgIHZhciB0cmFjayA9IHBsYXllci50ZXh0VHJhY2tzKCkuZ2V0VHJhY2tCeUlkKHRyYWNrSWQpO1xuXG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgIC8vIFJlc3VzZSBhbiBleGlzdGluZyB0cmFjayB3aXRoIGEgQ0MjIGlkIGJlY2F1c2UgdGhpcyB3YXNcbiAgICAgICAgICAvLyB2ZXJ5IGxpa2VseSBjcmVhdGVkIGJ5IHZpZGVvanMtY29udHJpYi1obHMgZnJvbSBpbmZvcm1hdGlvblxuICAgICAgICAgIC8vIGluIHRoZSBtM3U4IGZvciB1cyB0byB1c2VcbiAgICAgICAgICBzb3VyY2VCdWZmZXIuaW5iYW5kVGV4dFRyYWNrc19bdHJhY2tJZF0gPSB0cmFjaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhIHRyYWNrIHdpdGggdGhlIGRlZmF1bHQgYENDI2AgbGFiZWwgYW5kXG4gICAgICAgICAgLy8gd2l0aG91dCBhIGxhbmd1YWdlXG4gICAgICAgICAgc291cmNlQnVmZmVyLmluYmFuZFRleHRUcmFja3NfW3RyYWNrSWRdID0gcGxheWVyLmFkZFJlbW90ZVRleHRUcmFjayh7XG4gICAgICAgICAgICBraW5kOiAnY2FwdGlvbnMnLFxuICAgICAgICAgICAgaWQ6IHRyYWNrSWQsXG4gICAgICAgICAgICBsYWJlbDogdHJhY2tJZFxuICAgICAgICAgIH0sIGZhbHNlKS50cmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZWdtZW50Lm1ldGFkYXRhICYmIHNlZ21lbnQubWV0YWRhdGEubGVuZ3RoICYmICFzb3VyY2VCdWZmZXIubWV0YWRhdGFUcmFja18pIHtcbiAgICBzb3VyY2VCdWZmZXIubWV0YWRhdGFUcmFja18gPSBwbGF5ZXIuYWRkUmVtb3RlVGV4dFRyYWNrKHtcbiAgICAgIGtpbmQ6ICdtZXRhZGF0YScsXG4gICAgICBsYWJlbDogJ1RpbWVkIE1ldGFkYXRhJ1xuICAgIH0sIGZhbHNlKS50cmFjaztcbiAgICBzb3VyY2VCdWZmZXIubWV0YWRhdGFUcmFja18uaW5CYW5kTWV0YWRhdGFUcmFja0Rpc3BhdGNoVHlwZSA9IHNlZ21lbnQubWV0YWRhdGEuZGlzcGF0Y2hUeXBlO1xuICB9XG59O1xuXG4vKipcbiAqIEBmaWxlIHJlbW92ZS1jdWVzLWZyb20tdHJhY2suanNcbiAqL1xuXG4vKipcbiAqIFJlbW92ZSBjdWVzIGZyb20gYSB0cmFjayBvbiB2aWRlby5qcy5cbiAqXG4gKiBAcGFyYW0ge0RvdWJsZX0gc3RhcnQgc3RhcnQgb2Ygd2hlcmUgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgY3VlXG4gKiBAcGFyYW0ge0RvdWJsZX0gZW5kIGVuZCBvZiB3aGVyZSB0aGUgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgY3VlXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhY2sgdGhlIHRleHQgdHJhY2sgdG8gcmVtb3ZlIHRoZSBjdWVzIGZyb21cbiAqIEBwcml2YXRlXG4gKi9cbnZhciByZW1vdmVDdWVzRnJvbVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlQ3Vlc0Zyb21UcmFjayhzdGFydCwgZW5kLCB0cmFjaykge1xuICB2YXIgaSA9IHZvaWQgMDtcbiAgdmFyIGN1ZSA9IHZvaWQgMDtcblxuICBpZiAoIXRyYWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF0cmFjay5jdWVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaSA9IHRyYWNrLmN1ZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBjdWUgPSB0cmFjay5jdWVzW2ldO1xuXG4gICAgLy8gUmVtb3ZlIGFueSBvdmVybGFwcGluZyBjdWVcbiAgICBpZiAoY3VlLnN0YXJ0VGltZSA8PSBlbmQgJiYgY3VlLmVuZFRpbWUgPj0gc3RhcnQpIHtcbiAgICAgIHRyYWNrLnJlbW92ZUN1ZShjdWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAZmlsZSBhZGQtdGV4dC10cmFjay1kYXRhLmpzXG4gKi9cbi8qKlxuICogRGVmaW5lIHByb3BlcnRpZXMgb24gYSBjdWUgZm9yIGJhY2t3YXJkcyBjb21wYXRhYmlsaXR5LFxuICogYnV0IHdhcm4gdGhlIHVzZXIgdGhhdCB0aGUgd2F5IHRoYXQgdGhleSBhcmUgdXNpbmcgaXRcbiAqIGlzIGRlcHJpY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBhdCBhIGxhdGVyIGRhdGUuXG4gKlxuICogQHBhcmFtIHtDdWV9IGN1ZSB0aGUgY3VlIHRvIGFkZCB0aGUgcHJvcGVydGllcyBvblxuICogQHByaXZhdGVcbiAqL1xudmFyIGRlcHJlY2F0ZU9sZEN1ZSA9IGZ1bmN0aW9uIGRlcHJlY2F0ZU9sZEN1ZShjdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY3VlLmZyYW1lLCB7XG4gICAgaWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICB2aWRlb2pzJDEubG9nLndhcm4oJ2N1ZS5mcmFtZS5pZCBpcyBkZXByZWNhdGVkLiBVc2UgY3VlLnZhbHVlLmtleSBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gY3VlLnZhbHVlLmtleTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgdmlkZW9qcyQxLmxvZy53YXJuKCdjdWUuZnJhbWUudmFsdWUgaXMgZGVwcmVjYXRlZC4gVXNlIGN1ZS52YWx1ZS5kYXRhIGluc3RlYWQuJyk7XG4gICAgICAgIHJldHVybiBjdWUudmFsdWUuZGF0YTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByaXZhdGVEYXRhOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgdmlkZW9qcyQxLmxvZy53YXJuKCdjdWUuZnJhbWUucHJpdmF0ZURhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIGN1ZS52YWx1ZS5kYXRhIGluc3RlYWQuJyk7XG4gICAgICAgIHJldHVybiBjdWUudmFsdWUuZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGR1cmF0aW9uT2ZWaWRlbyA9IGZ1bmN0aW9uIGR1cmF0aW9uT2ZWaWRlbyhkdXJhdGlvbikge1xuICB2YXIgZHVyID0gdm9pZCAwO1xuXG4gIGlmIChpc05hTihkdXJhdGlvbikgfHwgTWF0aC5hYnMoZHVyYXRpb24pID09PSBJbmZpbml0eSkge1xuICAgIGR1ciA9IE51bWJlci5NQVhfVkFMVUU7XG4gIH0gZWxzZSB7XG4gICAgZHVyID0gZHVyYXRpb247XG4gIH1cbiAgcmV0dXJuIGR1cjtcbn07XG4vKipcbiAqIEFkZCB0ZXh0IHRyYWNrIGRhdGEgdG8gYSBzb3VyY2UgaGFuZGxlciBnaXZlbiB0aGUgY2FwdGlvbnMgYW5kXG4gKiBtZXRhZGF0YSBmcm9tIHRoZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZUhhbmRsZXIgdGhlIHZpcnR1YWwgc291cmNlIGJ1ZmZlclxuICogQHBhcmFtIHtBcnJheX0gY2FwdGlvbkFycmF5IGFuIGFycmF5IG9mIGNhcHRpb24gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbWV0YWRhdGFBcnJheSBhbiBhcnJheSBvZiBtZXRhIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBhZGRUZXh0VHJhY2tEYXRhID0gZnVuY3Rpb24gYWRkVGV4dFRyYWNrRGF0YShzb3VyY2VIYW5kbGVyLCBjYXB0aW9uQXJyYXksIG1ldGFkYXRhQXJyYXkpIHtcbiAgdmFyIEN1ZSA9IHdpbmRvdyQxLldlYktpdERhdGFDdWUgfHwgd2luZG93JDEuVlRUQ3VlO1xuXG4gIGlmIChjYXB0aW9uQXJyYXkpIHtcbiAgICBjYXB0aW9uQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoY2FwdGlvbikge1xuICAgICAgdmFyIHRyYWNrID0gY2FwdGlvbi5zdHJlYW07XG5cbiAgICAgIHRoaXMuaW5iYW5kVGV4dFRyYWNrc19bdHJhY2tdLmFkZEN1ZShuZXcgQ3VlKGNhcHRpb24uc3RhcnRUaW1lICsgdGhpcy50aW1lc3RhbXBPZmZzZXQsIGNhcHRpb24uZW5kVGltZSArIHRoaXMudGltZXN0YW1wT2Zmc2V0LCBjYXB0aW9uLnRleHQpKTtcbiAgICB9LCBzb3VyY2VIYW5kbGVyKTtcbiAgfVxuXG4gIGlmIChtZXRhZGF0YUFycmF5KSB7XG4gICAgdmFyIHZpZGVvRHVyYXRpb24gPSBkdXJhdGlvbk9mVmlkZW8oc291cmNlSGFuZGxlci5tZWRpYVNvdXJjZV8uZHVyYXRpb24pO1xuXG4gICAgbWV0YWRhdGFBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgICAgdmFyIHRpbWUgPSBtZXRhZGF0YS5jdWVUaW1lICsgdGhpcy50aW1lc3RhbXBPZmZzZXQ7XG5cbiAgICAgIG1ldGFkYXRhLmZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICB2YXIgY3VlID0gbmV3IEN1ZSh0aW1lLCB0aW1lLCBmcmFtZS52YWx1ZSB8fCBmcmFtZS51cmwgfHwgZnJhbWUuZGF0YSB8fCAnJyk7XG5cbiAgICAgICAgY3VlLmZyYW1lID0gZnJhbWU7XG4gICAgICAgIGN1ZS52YWx1ZSA9IGZyYW1lO1xuICAgICAgICBkZXByZWNhdGVPbGRDdWUoY3VlKTtcblxuICAgICAgICB0aGlzLm1ldGFkYXRhVHJhY2tfLmFkZEN1ZShjdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSwgc291cmNlSGFuZGxlcik7XG5cbiAgICAvLyBVcGRhdGluZyB0aGUgbWV0YWRldGEgY3VlcyBzbyB0aGF0XG4gICAgLy8gdGhlIGVuZFRpbWUgb2YgZWFjaCBjdWUgaXMgdGhlIHN0YXJ0VGltZSBvZiB0aGUgbmV4dCBjdWVcbiAgICAvLyB0aGUgZW5kVGltZSBvZiBsYXN0IGN1ZSBpcyB0aGUgZHVyYXRpb24gb2YgdGhlIHZpZGVvXG4gICAgaWYgKHNvdXJjZUhhbmRsZXIubWV0YWRhdGFUcmFja18gJiYgc291cmNlSGFuZGxlci5tZXRhZGF0YVRyYWNrXy5jdWVzICYmIHNvdXJjZUhhbmRsZXIubWV0YWRhdGFUcmFja18uY3Vlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBjdWVzID0gc291cmNlSGFuZGxlci5tZXRhZGF0YVRyYWNrXy5jdWVzO1xuICAgICAgdmFyIGN1ZXNBcnJheSA9IFtdO1xuXG4gICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBUZXh0VHJhY2tDdWVMaXN0Li4uXG4gICAgICAvLyAuLi5kaXNyZWdhcmRpbmcgY3VlcyB3aXRoIGEgZmFsc2V5IHZhbHVlXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGN1ZXNbaV0pIHtcbiAgICAgICAgICBjdWVzQXJyYXkucHVzaChjdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBHcm91cCBjdWVzIGJ5IHRoZWlyIHN0YXJ0VGltZSB2YWx1ZVxuICAgICAgdmFyIGN1ZXNHcm91cGVkQnlTdGFydFRpbWUgPSBjdWVzQXJyYXkucmVkdWNlKGZ1bmN0aW9uIChvYmosIGN1ZSkge1xuICAgICAgICB2YXIgdGltZVNsb3QgPSBvYmpbY3VlLnN0YXJ0VGltZV0gfHwgW107XG5cbiAgICAgICAgdGltZVNsb3QucHVzaChjdWUpO1xuICAgICAgICBvYmpbY3VlLnN0YXJ0VGltZV0gPSB0aW1lU2xvdDtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSwge30pO1xuXG4gICAgICAvLyBTb3J0IHN0YXJ0VGltZXMgYnkgYXNjZW5kaW5nIG9yZGVyXG4gICAgICB2YXIgc29ydGVkU3RhcnRUaW1lcyA9IE9iamVjdC5rZXlzKGN1ZXNHcm91cGVkQnlTdGFydFRpbWUpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcihhKSAtIE51bWJlcihiKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNYXAgZWFjaCBjdWUgZ3JvdXAncyBlbmRUaW1lIHRvIHRoZSBuZXh0IGdyb3VwJ3Mgc3RhcnRUaW1lXG4gICAgICBzb3J0ZWRTdGFydFRpbWVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXJ0VGltZSwgaWR4KSB7XG4gICAgICAgIHZhciBjdWVHcm91cCA9IGN1ZXNHcm91cGVkQnlTdGFydFRpbWVbc3RhcnRUaW1lXTtcbiAgICAgICAgdmFyIG5leHRUaW1lID0gTnVtYmVyKHNvcnRlZFN0YXJ0VGltZXNbaWR4ICsgMV0pIHx8IHZpZGVvRHVyYXRpb247XG5cbiAgICAgICAgLy8gTWFwIGVhY2ggY3VlJ3MgZW5kVGltZSB0aGUgbmV4dCBncm91cCdzIHN0YXJ0VGltZVxuICAgICAgICBjdWVHcm91cC5mb3JFYWNoKGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgICAgICBjdWUuZW5kVGltZSA9IG5leHRUaW1lO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge30sXG4gICAgVEFSR0VUID0gdHlwZW9mIFN5bWJvbCA9PT0gJ3VuZGVmaW5lZCcgPyAnX190YXJnZXQnIDogU3ltYm9sKCksXG4gICAgU0NSSVBUX1RZUEUgPSAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXG4gICAgQmxvYkJ1aWxkZXIgPSB3aW4uQmxvYkJ1aWxkZXIgfHwgd2luLldlYktpdEJsb2JCdWlsZGVyIHx8IHdpbi5Nb3pCbG9iQnVpbGRlciB8fCB3aW4uTVNCbG9iQnVpbGRlcixcbiAgICBVUkwgPSB3aW4uVVJMIHx8IHdpbi53ZWJraXRVUkwgfHwgVVJMICYmIFVSTC5tc1VSTCxcbiAgICBXb3JrZXIgPSB3aW4uV29ya2VyO1xuXG4vKipcbiAqIFJldHVybnMgYSB3cmFwcGVyIGFyb3VuZCBXZWIgV29ya2VyIGNvZGUgdGhhdCBpcyBjb25zdHJ1Y3RpYmxlLlxuICpcbiAqIEBmdW5jdGlvbiBzaGltV29ya2VyXG4gKlxuICogQHBhcmFtIHsgU3RyaW5nIH0gICAgZmlsZW5hbWUgICAgVGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gIGZuICAgICAgICAgIEZ1bmN0aW9uIHdyYXBwaW5nIHRoZSBjb2RlIG9mIHRoZSB3b3JrZXJcbiAqL1xuZnVuY3Rpb24gc2hpbVdvcmtlcihmaWxlbmFtZSwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNoaW1Xb3JrZXIoZm9yY2VGYWxsYmFjaykge1xuICAgIHZhciBvID0gdGhpcztcblxuICAgIGlmICghZm4pIHtcbiAgICAgIHJldHVybiBuZXcgV29ya2VyKGZpbGVuYW1lKTtcbiAgICB9IGVsc2UgaWYgKFdvcmtlciAmJiAhZm9yY2VGYWxsYmFjaykge1xuICAgICAgLy8gQ29udmVydCB0aGUgZnVuY3Rpb24ncyBpbm5lciBjb2RlIHRvIGEgc3RyaW5nIHRvIGNvbnN0cnVjdCB0aGUgd29ya2VyXG4gICAgICB2YXIgc291cmNlID0gZm4udG9TdHJpbmcoKS5yZXBsYWNlKC9eZnVuY3Rpb24uKz97LywgJycpLnNsaWNlKDAsIC0xKSxcbiAgICAgICAgICBvYmpVUkwgPSBjcmVhdGVTb3VyY2VPYmplY3Qoc291cmNlKTtcblxuICAgICAgdGhpc1tUQVJHRVRdID0gbmV3IFdvcmtlcihvYmpVUkwpO1xuICAgICAgd3JhcFRlcm1pbmF0ZSh0aGlzW1RBUkdFVF0sIG9ialVSTCk7XG4gICAgICByZXR1cm4gdGhpc1tUQVJHRVRdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2VsZlNoaW0gPSB7XG4gICAgICAgIHBvc3RNZXNzYWdlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZShtKSB7XG4gICAgICAgICAgaWYgKG8ub25tZXNzYWdlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgby5vbm1lc3NhZ2UoeyBkYXRhOiBtLCB0YXJnZXQ6IHNlbGZTaGltIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmbi5jYWxsKHNlbGZTaGltKTtcbiAgICAgIHRoaXMucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmU2hpbS5vbm1lc3NhZ2UoeyBkYXRhOiBtLCB0YXJnZXQ6IG8gfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMuaXNUaGlzVGhyZWFkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG59XG4vLyBUZXN0IFdvcmtlciBjYXBhYmlsaXRpZXNcbmlmIChXb3JrZXIpIHtcbiAgdmFyIHRlc3RXb3JrZXIsXG4gICAgICBvYmpVUkwgPSBjcmVhdGVTb3VyY2VPYmplY3QoJ3NlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge30nKSxcbiAgICAgIHRlc3RBcnJheSA9IG5ldyBVaW50OEFycmF5KDEpO1xuXG4gIHRyeSB7XG4gICAgdGVzdFdvcmtlciA9IG5ldyBXb3JrZXIob2JqVVJMKTtcblxuICAgIC8vIE5hdGl2ZSBicm93c2VyIG9uIHNvbWUgU2Ftc3VuZyBkZXZpY2VzIHRocm93cyBmb3IgdHJhbnNmZXJhYmxlcywgbGV0J3MgZGV0ZWN0IGl0XG4gICAgdGVzdFdvcmtlci5wb3N0TWVzc2FnZSh0ZXN0QXJyYXksIFt0ZXN0QXJyYXkuYnVmZmVyXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBXb3JrZXIgPSBudWxsO1xuICB9IGZpbmFsbHkge1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwob2JqVVJMKTtcbiAgICBpZiAodGVzdFdvcmtlcikge1xuICAgICAgdGVzdFdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU291cmNlT2JqZWN0KHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtzdHJdLCB7IHR5cGU6IFNDUklQVF9UWVBFIH0pKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBibG9iID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gICAgYmxvYi5hcHBlbmQoc3RyKTtcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iLmdldEJsb2IodHlwZSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyYXBUZXJtaW5hdGUod29ya2VyLCBvYmpVUkwpIHtcbiAgaWYgKCF3b3JrZXIgfHwgIW9ialVSTCkgcmV0dXJuO1xuICB2YXIgdGVybSA9IHdvcmtlci50ZXJtaW5hdGU7XG4gIHdvcmtlci5vYmpVUkwgPSBvYmpVUkw7XG4gIHdvcmtlci50ZXJtaW5hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHdvcmtlci5vYmpVUkwpIFVSTC5yZXZva2VPYmplY3RVUkwod29ya2VyLm9ialVSTCk7XG4gICAgdGVybS5jYWxsKHdvcmtlcik7XG4gIH07XG59XG5cbnZhciBUcmFuc211eFdvcmtlciA9IG5ldyBzaGltV29ya2VyKFwiLi90cmFuc211eGVyLXdvcmtlci53b3JrZXIuanNcIiwgZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQkJDEpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHJhbnNtdXhlcldvcmtlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbiAgICB2YXIgd2luO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbiA9IHdpbmRvdztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb21tb25qc0dsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luID0gY29tbW9uanNHbG9iYWw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luID0gc2VsZjtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luID0ge307XG4gICAgfVxuXG4gICAgdmFyIHdpbmRvd18xID0gd2luO1xuXG4gICAgLyoqXG4gICAgICogbXV4LmpzXG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTUgQnJpZ2h0Y292ZVxuICAgICAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBGdW5jdGlvbnMgdGhhdCBnZW5lcmF0ZSBmcmFnbWVudGVkIE1QNHMgc3VpdGFibGUgZm9yIHVzZSB3aXRoIE1lZGlhXG4gICAgICogU291cmNlIEV4dGVuc2lvbnMuXG4gICAgICovXG5cbiAgICB2YXIgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5cbiAgICB2YXIgYm94LCBkaW5mLCBlc2RzLCBmdHlwLCBtZGF0LCBtZmhkLCBtaW5mLCBtb29mLCBtb292LCBtdmV4LCBtdmhkLCB0cmFrLCB0a2hkLCBtZGlhLCBtZGhkLCBoZGxyLCBzZHRwLCBzdGJsLCBzdHNkLCB0cmFmLCB0cmV4LCB0cnVuLCB0eXBlcywgTUFKT1JfQlJBTkQsIE1JTk9SX1ZFUlNJT04sIEFWQzFfQlJBTkQsIFZJREVPX0hETFIsIEFVRElPX0hETFIsIEhETFJfVFlQRVMsIFZNSEQsIFNNSEQsIERSRUYsIFNUQ08sIFNUU0MsIFNUU1osIFNUVFM7XG5cbiAgICAvLyBwcmUtY2FsY3VsYXRlIGNvbnN0YW50c1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHR5cGVzID0ge1xuICAgICAgICBhdmMxOiBbXSwgLy8gY29kaW5nbmFtZVxuICAgICAgICBhdmNDOiBbXSxcbiAgICAgICAgYnRydDogW10sXG4gICAgICAgIGRpbmY6IFtdLFxuICAgICAgICBkcmVmOiBbXSxcbiAgICAgICAgZXNkczogW10sXG4gICAgICAgIGZ0eXA6IFtdLFxuICAgICAgICBoZGxyOiBbXSxcbiAgICAgICAgbWRhdDogW10sXG4gICAgICAgIG1kaGQ6IFtdLFxuICAgICAgICBtZGlhOiBbXSxcbiAgICAgICAgbWZoZDogW10sXG4gICAgICAgIG1pbmY6IFtdLFxuICAgICAgICBtb29mOiBbXSxcbiAgICAgICAgbW9vdjogW10sXG4gICAgICAgIG1wNGE6IFtdLCAvLyBjb2RpbmduYW1lXG4gICAgICAgIG12ZXg6IFtdLFxuICAgICAgICBtdmhkOiBbXSxcbiAgICAgICAgc2R0cDogW10sXG4gICAgICAgIHNtaGQ6IFtdLFxuICAgICAgICBzdGJsOiBbXSxcbiAgICAgICAgc3RjbzogW10sXG4gICAgICAgIHN0c2M6IFtdLFxuICAgICAgICBzdHNkOiBbXSxcbiAgICAgICAgc3RzejogW10sXG4gICAgICAgIHN0dHM6IFtdLFxuICAgICAgICBzdHlwOiBbXSxcbiAgICAgICAgdGZkdDogW10sXG4gICAgICAgIHRmaGQ6IFtdLFxuICAgICAgICB0cmFmOiBbXSxcbiAgICAgICAgdHJhazogW10sXG4gICAgICAgIHRydW46IFtdLFxuICAgICAgICB0cmV4OiBbXSxcbiAgICAgICAgdGtoZDogW10sXG4gICAgICAgIHZtaGQ6IFtdXG4gICAgICB9O1xuXG4gICAgICAvLyBJbiBlbnZpcm9ubWVudHMgd2hlcmUgVWludDhBcnJheSBpcyB1bmRlZmluZWQgKGUuZy4sIElFOCksIHNraXAgc2V0IHVwIHNvIHRoYXQgd2VcbiAgICAgIC8vIGRvbid0IHRocm93IGFuIGVycm9yXG4gICAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yIChpIGluIHR5cGVzKSB7XG4gICAgICAgIGlmICh0eXBlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIHR5cGVzW2ldID0gW2kuY2hhckNvZGVBdCgwKSwgaS5jaGFyQ29kZUF0KDEpLCBpLmNoYXJDb2RlQXQoMiksIGkuY2hhckNvZGVBdCgzKV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgTUFKT1JfQlJBTkQgPSBuZXcgVWludDhBcnJheShbJ2knLmNoYXJDb2RlQXQoMCksICdzJy5jaGFyQ29kZUF0KDApLCAnbycuY2hhckNvZGVBdCgwKSwgJ20nLmNoYXJDb2RlQXQoMCldKTtcbiAgICAgIEFWQzFfQlJBTkQgPSBuZXcgVWludDhBcnJheShbJ2EnLmNoYXJDb2RlQXQoMCksICd2Jy5jaGFyQ29kZUF0KDApLCAnYycuY2hhckNvZGVBdCgwKSwgJzEnLmNoYXJDb2RlQXQoMCldKTtcbiAgICAgIE1JTk9SX1ZFUlNJT04gPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMV0pO1xuICAgICAgVklERU9fSERMUiA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHg3NiwgMHg2OSwgMHg2NCwgMHg2NSwgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4NTYsIDB4NjksIDB4NjQsIDB4NjUsIDB4NmYsIDB4NDgsIDB4NjEsIDB4NmUsIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1ZpZGVvSGFuZGxlcidcbiAgICAgIF0pO1xuICAgICAgQVVESU9fSERMUiA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHg3MywgMHg2ZiwgMHg3NSwgMHg2ZSwgLy8gaGFuZGxlcl90eXBlOiAnc291bidcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4NTMsIDB4NmYsIDB4NzUsIDB4NmUsIDB4NjQsIDB4NDgsIDB4NjEsIDB4NmUsIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1NvdW5kSGFuZGxlcidcbiAgICAgIF0pO1xuICAgICAgSERMUl9UWVBFUyA9IHtcbiAgICAgICAgdmlkZW86IFZJREVPX0hETFIsXG4gICAgICAgIGF1ZGlvOiBBVURJT19IRExSXG4gICAgICB9O1xuICAgICAgRFJFRiA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBlbnRyeV9jb3VudFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYywgLy8gZW50cnlfc2l6ZVxuICAgICAgMHg3NSwgMHg3MiwgMHg2YywgMHgyMCwgLy8gJ3VybCcgdHlwZVxuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXG4gICAgICBdKTtcbiAgICAgIFNNSEQgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGJhbGFuY2UsIDAgbWVhbnMgY2VudGVyZWRcbiAgICAgIDB4MDAsIDB4MDAgLy8gcmVzZXJ2ZWRcbiAgICAgIF0pO1xuICAgICAgU1RDTyA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBlbnRyeV9jb3VudFxuICAgICAgXSk7XG4gICAgICBTVFNDID0gU1RDTztcbiAgICAgIFNUU1ogPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHNhbXBsZV9zaXplXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIHNhbXBsZV9jb3VudFxuICAgICAgXSk7XG4gICAgICBTVFRTID0gU1RDTztcbiAgICAgIFZNSEQgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGdyYXBoaWNzbW9kZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBvcGNvbG9yXG4gICAgICBdKTtcbiAgICB9KSgpO1xuXG4gICAgYm94ID0gZnVuY3Rpb24gYm94KHR5cGUpIHtcbiAgICAgIHZhciBwYXlsb2FkID0gW10sXG4gICAgICAgICAgc2l6ZSA9IDAsXG4gICAgICAgICAgaSxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgdmlldztcblxuICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXlsb2FkLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cblxuICAgICAgaSA9IHBheWxvYWQubGVuZ3RoO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHNpemUgd2UgbmVlZCB0byBhbGxvY2F0ZVxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUgKyA4KTtcbiAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcocmVzdWx0LmJ1ZmZlciwgcmVzdWx0LmJ5dGVPZmZzZXQsIHJlc3VsdC5ieXRlTGVuZ3RoKTtcbiAgICAgIHZpZXcuc2V0VWludDMyKDAsIHJlc3VsdC5ieXRlTGVuZ3RoKTtcbiAgICAgIHJlc3VsdC5zZXQodHlwZSwgNCk7XG5cbiAgICAgIC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG4gICAgICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IHBheWxvYWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBkaW5mID0gZnVuY3Rpb24gZGluZigpIHtcbiAgICAgIHJldHVybiBib3godHlwZXMuZGluZiwgYm94KHR5cGVzLmRyZWYsIERSRUYpKTtcbiAgICB9O1xuXG4gICAgZXNkcyA9IGZ1bmN0aW9uIGVzZHModHJhY2spIHtcbiAgICAgIHJldHVybiBib3godHlwZXMuZXNkcywgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG5cbiAgICAgIC8vIEVTX0Rlc2NyaXB0b3JcbiAgICAgIDB4MDMsIC8vIHRhZywgRVNfRGVzY3JUYWdcbiAgICAgIDB4MTksIC8vIGxlbmd0aFxuICAgICAgMHgwMCwgMHgwMCwgLy8gRVNfSURcbiAgICAgIDB4MDAsIC8vIHN0cmVhbURlcGVuZGVuY2VGbGFnLCBVUkxfZmxhZywgcmVzZXJ2ZWQsIHN0cmVhbVByaW9yaXR5XG5cbiAgICAgIC8vIERlY29kZXJDb25maWdEZXNjcmlwdG9yXG4gICAgICAweDA0LCAvLyB0YWcsIERlY29kZXJDb25maWdEZXNjclRhZ1xuICAgICAgMHgxMSwgLy8gbGVuZ3RoXG4gICAgICAweDQwLCAvLyBvYmplY3QgdHlwZVxuICAgICAgMHgxNSwgLy8gc3RyZWFtVHlwZVxuICAgICAgMHgwMCwgMHgwNiwgMHgwMCwgLy8gYnVmZmVyU2l6ZURCXG4gICAgICAweDAwLCAweDAwLCAweGRhLCAweGMwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAweDAwLCAweDAwLCAweGRhLCAweGMwLCAvLyBhdmdCaXRyYXRlXG5cbiAgICAgIC8vIERlY29kZXJTcGVjaWZpY0luZm9cbiAgICAgIDB4MDUsIC8vIHRhZywgRGVjb2RlclNwZWNpZmljSW5mb1RhZ1xuICAgICAgMHgwMiwgLy8gbGVuZ3RoXG4gICAgICAvLyBJU08vSUVDIDE0NDk2LTMsIEF1ZGlvU3BlY2lmaWNDb25maWdcbiAgICAgIC8vIGZvciBzYW1wbGluZ0ZyZXF1ZW5jeUluZGV4IHNlZSBJU08vSUVDIDEzODE4LTc6MjAwNiwgOC4xLjMuMi4yLCBUYWJsZSAzNVxuICAgICAgdHJhY2suYXVkaW9vYmplY3R0eXBlIDw8IDMgfCB0cmFjay5zYW1wbGluZ2ZyZXF1ZW5jeWluZGV4ID4+PiAxLCB0cmFjay5zYW1wbGluZ2ZyZXF1ZW5jeWluZGV4IDw8IDcgfCB0cmFjay5jaGFubmVsY291bnQgPDwgMywgMHgwNiwgMHgwMSwgMHgwMiAvLyBHQVNwZWNpZmljQ29uZmlnXG4gICAgICBdKSk7XG4gICAgfTtcblxuICAgIGZ0eXAgPSBmdW5jdGlvbiBmdHlwKCkge1xuICAgICAgcmV0dXJuIGJveCh0eXBlcy5mdHlwLCBNQUpPUl9CUkFORCwgTUlOT1JfVkVSU0lPTiwgTUFKT1JfQlJBTkQsIEFWQzFfQlJBTkQpO1xuICAgIH07XG5cbiAgICBoZGxyID0gZnVuY3Rpb24gaGRscih0eXBlKSB7XG4gICAgICByZXR1cm4gYm94KHR5cGVzLmhkbHIsIEhETFJfVFlQRVNbdHlwZV0pO1xuICAgIH07XG4gICAgbWRhdCA9IGZ1bmN0aW9uIG1kYXQoZGF0YSkge1xuICAgICAgcmV0dXJuIGJveCh0eXBlcy5tZGF0LCBkYXRhKTtcbiAgICB9O1xuICAgIG1kaGQgPSBmdW5jdGlvbiBtZGhkKHRyYWNrKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAweDAwLCAweDAxLCAweDVmLCAweDkwLCAvLyB0aW1lc2NhbGUsIDkwLDAwMCBcInRpY2tzXCIgcGVyIHNlY29uZFxuXG4gICAgICB0cmFjay5kdXJhdGlvbiA+Pj4gMjQgJiAweEZGLCB0cmFjay5kdXJhdGlvbiA+Pj4gMTYgJiAweEZGLCB0cmFjay5kdXJhdGlvbiA+Pj4gOCAmIDB4RkYsIHRyYWNrLmR1cmF0aW9uICYgMHhGRiwgLy8gZHVyYXRpb25cbiAgICAgIDB4NTUsIDB4YzQsIC8vICd1bmQnIGxhbmd1YWdlICh1bmRldGVybWluZWQpXG4gICAgICAweDAwLCAweDAwXSk7XG5cbiAgICAgIC8vIFVzZSB0aGUgc2FtcGxlIHJhdGUgZnJvbSB0aGUgdHJhY2sgbWV0YWRhdGEsIHdoZW4gaXQgaXNcbiAgICAgIC8vIGRlZmluZWQuIFRoZSBzYW1wbGUgcmF0ZSBjYW4gYmUgcGFyc2VkIG91dCBvZiBhbiBBRFRTIGhlYWRlciwgZm9yXG4gICAgICAvLyBpbnN0YW5jZS5cbiAgICAgIGlmICh0cmFjay5zYW1wbGVyYXRlKSB7XG4gICAgICAgIHJlc3VsdFsxMl0gPSB0cmFjay5zYW1wbGVyYXRlID4+PiAyNCAmIDB4RkY7XG4gICAgICAgIHJlc3VsdFsxM10gPSB0cmFjay5zYW1wbGVyYXRlID4+PiAxNiAmIDB4RkY7XG4gICAgICAgIHJlc3VsdFsxNF0gPSB0cmFjay5zYW1wbGVyYXRlID4+PiA4ICYgMHhGRjtcbiAgICAgICAgcmVzdWx0WzE1XSA9IHRyYWNrLnNhbXBsZXJhdGUgJiAweEZGO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYm94KHR5cGVzLm1kaGQsIHJlc3VsdCk7XG4gICAgfTtcbiAgICBtZGlhID0gZnVuY3Rpb24gbWRpYSh0cmFjaykge1xuICAgICAgcmV0dXJuIGJveCh0eXBlcy5tZGlhLCBtZGhkKHRyYWNrKSwgaGRscih0cmFjay50eXBlKSwgbWluZih0cmFjaykpO1xuICAgIH07XG4gICAgbWZoZCA9IGZ1bmN0aW9uIG1maGQoc2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgIHJldHVybiBib3godHlwZXMubWZoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAoc2VxdWVuY2VOdW1iZXIgJiAweEZGMDAwMDAwKSA+PiAyNCwgKHNlcXVlbmNlTnVtYmVyICYgMHhGRjAwMDApID4+IDE2LCAoc2VxdWVuY2VOdW1iZXIgJiAweEZGMDApID4+IDgsIHNlcXVlbmNlTnVtYmVyICYgMHhGRiAvLyBzZXF1ZW5jZV9udW1iZXJcbiAgICAgIF0pKTtcbiAgICB9O1xuICAgIG1pbmYgPSBmdW5jdGlvbiBtaW5mKHRyYWNrKSB7XG4gICAgICByZXR1cm4gYm94KHR5cGVzLm1pbmYsIHRyYWNrLnR5cGUgPT09ICd2aWRlbycgPyBib3godHlwZXMudm1oZCwgVk1IRCkgOiBib3godHlwZXMuc21oZCwgU01IRCksIGRpbmYoKSwgc3RibCh0cmFjaykpO1xuICAgIH07XG4gICAgbW9vZiA9IGZ1bmN0aW9uIG1vb2Yoc2VxdWVuY2VOdW1iZXIsIHRyYWNrcykge1xuICAgICAgdmFyIHRyYWNrRnJhZ21lbnRzID0gW10sXG4gICAgICAgICAgaSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgICAvLyBidWlsZCB0cmFmIGJveGVzIGZvciBlYWNoIHRyYWNrIGZyYWdtZW50XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHRyYWNrRnJhZ21lbnRzW2ldID0gdHJhZih0cmFja3NbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJveC5hcHBseShudWxsLCBbdHlwZXMubW9vZiwgbWZoZChzZXF1ZW5jZU51bWJlcildLmNvbmNhdCh0cmFja0ZyYWdtZW50cykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1vdmllIGJveC5cbiAgICAgKiBAcGFyYW0gdHJhY2tzIHthcnJheX0gdGhlIHRyYWNrcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtb3ZpZVxuICAgICAqIEBzZWUgSVNPL0lFQyAxNDQ5Ni0xMjoyMDEyKEUpLCBzZWN0aW9uIDguMi4xXG4gICAgICovXG4gICAgbW9vdiA9IGZ1bmN0aW9uIG1vb3YodHJhY2tzKSB7XG4gICAgICB2YXIgaSA9IHRyYWNrcy5sZW5ndGgsXG4gICAgICAgICAgYm94ZXMgPSBbXTtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBib3hlc1tpXSA9IHRyYWsodHJhY2tzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJveC5hcHBseShudWxsLCBbdHlwZXMubW9vdiwgbXZoZCgweGZmZmZmZmZmKV0uY29uY2F0KGJveGVzKS5jb25jYXQobXZleCh0cmFja3MpKSk7XG4gICAgfTtcbiAgICBtdmV4ID0gZnVuY3Rpb24gbXZleCh0cmFja3MpIHtcbiAgICAgIHZhciBpID0gdHJhY2tzLmxlbmd0aCxcbiAgICAgICAgICBib3hlcyA9IFtdO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGJveGVzW2ldID0gdHJleCh0cmFja3NbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJveC5hcHBseShudWxsLCBbdHlwZXMubXZleF0uY29uY2F0KGJveGVzKSk7XG4gICAgfTtcbiAgICBtdmhkID0gZnVuY3Rpb24gbXZoZChkdXJhdGlvbikge1xuICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAweDAwLCAweDAxLCAweDVmLCAweDkwLCAvLyB0aW1lc2NhbGUsIDkwLDAwMCBcInRpY2tzXCIgcGVyIHNlY29uZFxuICAgICAgKGR1cmF0aW9uICYgMHhGRjAwMDAwMCkgPj4gMjQsIChkdXJhdGlvbiAmIDB4RkYwMDAwKSA+PiAxNiwgKGR1cmF0aW9uICYgMHhGRjAwKSA+PiA4LCBkdXJhdGlvbiAmIDB4RkYsIC8vIGR1cmF0aW9uXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAvLyAxLjAgcmF0ZVxuICAgICAgMHgwMSwgMHgwMCwgLy8gMS4wIHZvbHVtZVxuICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYgLy8gbmV4dF90cmFja19JRFxuICAgICAgXSk7XG4gICAgICByZXR1cm4gYm94KHR5cGVzLm12aGQsIGJ5dGVzKTtcbiAgICB9O1xuXG4gICAgc2R0cCA9IGZ1bmN0aW9uIHNkdHAodHJhY2spIHtcbiAgICAgIHZhciBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXSxcbiAgICAgICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KDQgKyBzYW1wbGVzLmxlbmd0aCksXG4gICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgaTtcblxuICAgICAgLy8gbGVhdmUgdGhlIGZ1bGwgYm94IGhlYWRlciAoNCBieXRlcykgYWxsIHplcm9cblxuICAgICAgLy8gd3JpdGUgdGhlIHNhbXBsZSB0YWJsZVxuICAgICAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xuXG4gICAgICAgIGJ5dGVzW2kgKyA0XSA9IGZsYWdzLmRlcGVuZHNPbiA8PCA0IHwgZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDIgfCBmbGFncy5oYXNSZWR1bmRhbmN5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYm94KHR5cGVzLnNkdHAsIGJ5dGVzKTtcbiAgICB9O1xuXG4gICAgc3RibCA9IGZ1bmN0aW9uIHN0YmwodHJhY2spIHtcbiAgICAgIHJldHVybiBib3godHlwZXMuc3RibCwgc3RzZCh0cmFjayksIGJveCh0eXBlcy5zdHRzLCBTVFRTKSwgYm94KHR5cGVzLnN0c2MsIFNUU0MpLCBib3godHlwZXMuc3RzeiwgU1RTWiksIGJveCh0eXBlcy5zdGNvLCBTVENPKSk7XG4gICAgfTtcblxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmlkZW9TYW1wbGUsIGF1ZGlvU2FtcGxlO1xuXG4gICAgICBzdHNkID0gZnVuY3Rpb24gc3RzZCh0cmFjaykge1xuXG4gICAgICAgIHJldHVybiBib3godHlwZXMuc3RzZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxXSksIHRyYWNrLnR5cGUgPT09ICd2aWRlbycgPyB2aWRlb1NhbXBsZSh0cmFjaykgOiBhdWRpb1NhbXBsZSh0cmFjaykpO1xuICAgICAgfTtcblxuICAgICAgdmlkZW9TYW1wbGUgPSBmdW5jdGlvbiB2aWRlb1NhbXBsZSh0cmFjaykge1xuICAgICAgICB2YXIgc3BzID0gdHJhY2suc3BzIHx8IFtdLFxuICAgICAgICAgICAgcHBzID0gdHJhY2sucHBzIHx8IFtdLFxuICAgICAgICAgICAgc2VxdWVuY2VQYXJhbWV0ZXJTZXRzID0gW10sXG4gICAgICAgICAgICBwaWN0dXJlUGFyYW1ldGVyU2V0cyA9IFtdLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyBhc3NlbWJsZSB0aGUgU1BTc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2VxdWVuY2VQYXJhbWV0ZXJTZXRzLnB1c2goKHNwc1tpXS5ieXRlTGVuZ3RoICYgMHhGRjAwKSA+Pj4gOCk7XG4gICAgICAgICAgc2VxdWVuY2VQYXJhbWV0ZXJTZXRzLnB1c2goc3BzW2ldLmJ5dGVMZW5ndGggJiAweEZGKTsgLy8gc2VxdWVuY2VQYXJhbWV0ZXJTZXRMZW5ndGhcbiAgICAgICAgICBzZXF1ZW5jZVBhcmFtZXRlclNldHMgPSBzZXF1ZW5jZVBhcmFtZXRlclNldHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNwc1tpXSkpOyAvLyBTUFNcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFzc2VtYmxlIHRoZSBQUFNzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwaWN0dXJlUGFyYW1ldGVyU2V0cy5wdXNoKChwcHNbaV0uYnl0ZUxlbmd0aCAmIDB4RkYwMCkgPj4+IDgpO1xuICAgICAgICAgIHBpY3R1cmVQYXJhbWV0ZXJTZXRzLnB1c2gocHBzW2ldLmJ5dGVMZW5ndGggJiAweEZGKTtcbiAgICAgICAgICBwaWN0dXJlUGFyYW1ldGVyU2V0cyA9IHBpY3R1cmVQYXJhbWV0ZXJTZXRzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwcHNbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib3godHlwZXMuYXZjMSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAgICh0cmFjay53aWR0aCAmIDB4ZmYwMCkgPj4gOCwgdHJhY2sud2lkdGggJiAweGZmLCAvLyB3aWR0aFxuICAgICAgICAodHJhY2suaGVpZ2h0ICYgMHhmZjAwKSA+PiA4LCB0cmFjay5oZWlnaHQgJiAweGZmLCAvLyBoZWlnaHRcbiAgICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCwgLy8gaG9yaXpyZXNvbHV0aW9uXG4gICAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDEsIC8vIGZyYW1lX2NvdW50XG4gICAgICAgIDB4MTMsIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsIDB4NmYsIDB4NmEsIDB4NzMsIDB4MmQsIDB4NjMsIDB4NmYsIDB4NmUsIDB4NzQsIDB4NzIsIDB4NjksIDB4NjIsIDB4MmQsIDB4NjgsIDB4NmMsIDB4NzMsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNvbXByZXNzb3JuYW1lXG4gICAgICAgIDB4MDAsIDB4MTgsIC8vIGRlcHRoID0gMjRcbiAgICAgICAgMHgxMSwgMHgxMSAvLyBwcmVfZGVmaW5lZCA9IC0xXG4gICAgICAgIF0pLCBib3godHlwZXMuYXZjQywgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsIC8vIGNvbmZpZ3VyYXRpb25WZXJzaW9uXG4gICAgICAgIHRyYWNrLnByb2ZpbGVJZGMsIC8vIEFWQ1Byb2ZpbGVJbmRpY2F0aW9uXG4gICAgICAgIHRyYWNrLnByb2ZpbGVDb21wYXRpYmlsaXR5LCAvLyBwcm9maWxlX2NvbXBhdGliaWxpdHlcbiAgICAgICAgdHJhY2subGV2ZWxJZGMsIC8vIEFWQ0xldmVsSW5kaWNhdGlvblxuICAgICAgICAweGZmIC8vIGxlbmd0aFNpemVNaW51c09uZSwgaGFyZC1jb2RlZCB0byA0IGJ5dGVzXG4gICAgICAgIF0uY29uY2F0KFtzcHMubGVuZ3RoIC8vIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgICAgIF0pLmNvbmNhdChzZXF1ZW5jZVBhcmFtZXRlclNldHMpLmNvbmNhdChbcHBzLmxlbmd0aCAvLyBudW1PZlBpY3R1cmVQYXJhbWV0ZXJTZXRzXG4gICAgICAgIF0pLmNvbmNhdChwaWN0dXJlUGFyYW1ldGVyU2V0cykpKSwgLy8gXCJQUFNcIlxuICAgICAgICBib3godHlwZXMuYnRydCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MWMsIDB4OWMsIDB4ODAsIC8vIGJ1ZmZlclNpemVEQlxuICAgICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzBdKSkgLy8gYXZnQml0cmF0ZVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgYXVkaW9TYW1wbGUgPSBmdW5jdGlvbiBhdWRpb1NhbXBsZSh0cmFjaykge1xuICAgICAgICByZXR1cm4gYm94KHR5cGVzLm1wNGEsIG5ldyBVaW50OEFycmF5KFtcblxuICAgICAgICAvLyBTYW1wbGVFbnRyeSwgSVNPL0lFQyAxNDQ5Ni0xMlxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuXG4gICAgICAgIC8vIEF1ZGlvU2FtcGxlRW50cnksIElTTy9JRUMgMTQ0OTYtMTJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgKHRyYWNrLmNoYW5uZWxjb3VudCAmIDB4ZmYwMCkgPj4gOCwgdHJhY2suY2hhbm5lbGNvdW50ICYgMHhmZiwgLy8gY2hhbm5lbGNvdW50XG5cbiAgICAgICAgKHRyYWNrLnNhbXBsZXNpemUgJiAweGZmMDApID4+IDgsIHRyYWNrLnNhbXBsZXNpemUgJiAweGZmLCAvLyBzYW1wbGVzaXplXG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG5cbiAgICAgICAgKHRyYWNrLnNhbXBsZXJhdGUgJiAweGZmMDApID4+IDgsIHRyYWNrLnNhbXBsZXJhdGUgJiAweGZmLCAweDAwLCAweDAwIC8vIHNhbXBsZXJhdGUsIDE2LjE2XG5cbiAgICAgICAgLy8gTVA0QXVkaW9TYW1wbGVFbnRyeSwgSVNPL0lFQyAxNDQ5Ni0xNFxuICAgICAgICBdKSwgZXNkcyh0cmFjaykpO1xuICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgdGtoZCA9IGZ1bmN0aW9uIHRraGQodHJhY2spIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDA3LCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgICh0cmFjay5pZCAmIDB4RkYwMDAwMDApID4+IDI0LCAodHJhY2suaWQgJiAweEZGMDAwMCkgPj4gMTYsICh0cmFjay5pZCAmIDB4RkYwMCkgPj4gOCwgdHJhY2suaWQgJiAweEZGLCAvLyB0cmFja19JRFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICh0cmFjay5kdXJhdGlvbiAmIDB4RkYwMDAwMDApID4+IDI0LCAodHJhY2suZHVyYXRpb24gJiAweEZGMDAwMCkgPj4gMTYsICh0cmFjay5kdXJhdGlvbiAmIDB4RkYwMCkgPj4gOCwgdHJhY2suZHVyYXRpb24gJiAweEZGLCAvLyBkdXJhdGlvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGxheWVyXG4gICAgICAweDAwLCAweDAwLCAvLyBhbHRlcm5hdGVfZ3JvdXBcbiAgICAgIDB4MDEsIDB4MDAsIC8vIG5vbi1hdWRpbyB0cmFjayB2b2x1bWVcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgICAodHJhY2sud2lkdGggJiAweEZGMDApID4+IDgsIHRyYWNrLndpZHRoICYgMHhGRiwgMHgwMCwgMHgwMCwgLy8gd2lkdGhcbiAgICAgICh0cmFjay5oZWlnaHQgJiAweEZGMDApID4+IDgsIHRyYWNrLmhlaWdodCAmIDB4RkYsIDB4MDAsIDB4MDAgLy8gaGVpZ2h0XG4gICAgICBdKTtcblxuICAgICAgcmV0dXJuIGJveCh0eXBlcy50a2hkLCByZXN1bHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHRyYWNrIGZyYWdtZW50ICh0cmFmKSBib3guIEEgdHJhZiBib3ggY29sbGVjdHMgbWV0YWRhdGFcbiAgICAgKiBhYm91dCB0cmFja3MgaW4gYSBtb3ZpZSBmcmFnbWVudCAobW9vZikgYm94LlxuICAgICAqL1xuICAgIHRyYWYgPSBmdW5jdGlvbiB0cmFmKHRyYWNrKSB7XG4gICAgICB2YXIgdHJhY2tGcmFnbWVudEhlYWRlciwgdHJhY2tGcmFnbWVudERlY29kZVRpbWUsIHRyYWNrRnJhZ21lbnRSdW4sIHNhbXBsZURlcGVuZGVuY3lUYWJsZSwgZGF0YU9mZnNldCwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZTtcblxuICAgICAgdHJhY2tGcmFnbWVudEhlYWRlciA9IGJveCh0eXBlcy50ZmhkLCBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDNhLCAvLyBmbGFnc1xuICAgICAgKHRyYWNrLmlkICYgMHhGRjAwMDAwMCkgPj4gMjQsICh0cmFjay5pZCAmIDB4RkYwMDAwKSA+PiAxNiwgKHRyYWNrLmlkICYgMHhGRjAwKSA+PiA4LCB0cmFjay5pZCAmIDB4RkYsIC8vIHRyYWNrX0lEXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBzYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9zaXplXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gICAgICBdKSk7XG5cbiAgICAgIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKHRyYWNrLmJhc2VNZWRpYURlY29kZVRpbWUgLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICAgIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKHRyYWNrLmJhc2VNZWRpYURlY29kZVRpbWUgJSAoVUlOVDMyX01BWCArIDEpKTtcblxuICAgICAgdHJhY2tGcmFnbWVudERlY29kZVRpbWUgPSBib3godHlwZXMudGZkdCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsIC8vIHZlcnNpb24gMVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIC8vIGJhc2VNZWRpYURlY29kZVRpbWVcbiAgICAgIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4+IDI0ICYgMHhGRiwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+Pj4gMTYgJiAweEZGLCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+PiA4ICYgMHhGRiwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4RkYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4+IDI0ICYgMHhGRiwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+Pj4gMTYgJiAweEZGLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+PiA4ICYgMHhGRiwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4RkZdKSk7XG5cbiAgICAgIC8vIHRoZSBkYXRhIG9mZnNldCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiBieXRlcyBmcm9tIHRoZSBzdGFydCBvZlxuICAgICAgLy8gdGhlIGNvbnRhaW5pbmcgbW9vZiB0byB0aGUgZmlyc3QgcGF5bG9hZCBieXRlIG9mIHRoZSBhc3NvY2lhdGVkXG4gICAgICAvLyBtZGF0XG4gICAgICBkYXRhT2Zmc2V0ID0gMzIgKyAvLyB0ZmhkXG4gICAgICAyMCArIC8vIHRmZHRcbiAgICAgIDggKyAvLyB0cmFmIGhlYWRlclxuICAgICAgMTYgKyAvLyBtZmhkXG4gICAgICA4ICsgLy8gbW9vZiBoZWFkZXJcbiAgICAgIDg7IC8vIG1kYXQgaGVhZGVyXG5cbiAgICAgIC8vIGF1ZGlvIHRyYWNrcyByZXF1aXJlIGxlc3MgbWV0YWRhdGFcbiAgICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgIHRyYWNrRnJhZ21lbnRSdW4gPSB0cnVuKHRyYWNrLCBkYXRhT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIGJveCh0eXBlcy50cmFmLCB0cmFja0ZyYWdtZW50SGVhZGVyLCB0cmFja0ZyYWdtZW50RGVjb2RlVGltZSwgdHJhY2tGcmFnbWVudFJ1bik7XG4gICAgICB9XG5cbiAgICAgIC8vIHZpZGVvIHRyYWNrcyBzaG91bGQgY29udGFpbiBhbiBpbmRlcGVuZGVudCBhbmQgZGlzcG9zYWJsZSBzYW1wbGVzXG4gICAgICAvLyBib3ggKHNkdHApXG4gICAgICAvLyBnZW5lcmF0ZSBvbmUgYW5kIGFkanVzdCBvZmZzZXRzIHRvIG1hdGNoXG4gICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUgPSBzZHRwKHRyYWNrKTtcbiAgICAgIHRyYWNrRnJhZ21lbnRSdW4gPSB0cnVuKHRyYWNrLCBzYW1wbGVEZXBlbmRlbmN5VGFibGUubGVuZ3RoICsgZGF0YU9mZnNldCk7XG4gICAgICByZXR1cm4gYm94KHR5cGVzLnRyYWYsIHRyYWNrRnJhZ21lbnRIZWFkZXIsIHRyYWNrRnJhZ21lbnREZWNvZGVUaW1lLCB0cmFja0ZyYWdtZW50UnVuLCBzYW1wbGVEZXBlbmRlbmN5VGFibGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHRyYWNrIGJveC5cbiAgICAgKiBAcGFyYW0gdHJhY2sge29iamVjdH0gYSB0cmFjayBkZWZpbml0aW9uXG4gICAgICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIHRyYWNrIGJveFxuICAgICAqL1xuICAgIHRyYWsgPSBmdW5jdGlvbiB0cmFrKHRyYWNrKSB7XG4gICAgICB0cmFjay5kdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uIHx8IDB4ZmZmZmZmZmY7XG4gICAgICByZXR1cm4gYm94KHR5cGVzLnRyYWssIHRraGQodHJhY2spLCBtZGlhKHRyYWNrKSk7XG4gICAgfTtcblxuICAgIHRyZXggPSBmdW5jdGlvbiB0cmV4KHRyYWNrKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICh0cmFjay5pZCAmIDB4RkYwMDAwMDApID4+IDI0LCAodHJhY2suaWQgJiAweEZGMDAwMCkgPj4gMTYsICh0cmFjay5pZCAmIDB4RkYwMCkgPj4gOCwgdHJhY2suaWQgJiAweEZGLCAvLyB0cmFja19JRFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9zaXplXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAxIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gICAgICBdKTtcbiAgICAgIC8vIHRoZSBsYXN0IHR3byBieXRlcyBvZiBkZWZhdWx0X3NhbXBsZV9mbGFncyBpcyB0aGUgc2FtcGxlXG4gICAgICAvLyBkZWdyYWRhdGlvbiBwcmlvcml0eSwgYSBoaW50IGFib3V0IHRoZSBpbXBvcnRhbmNlIG9mIHRoaXMgc2FtcGxlXG4gICAgICAvLyByZWxhdGl2ZSB0byBvdGhlcnMuIExvd2VyIHRoZSBkZWdyYWRhdGlvbiBwcmlvcml0eSBmb3IgYWxsIHNhbXBsZVxuICAgICAgLy8gdHlwZXMgb3RoZXIgdGhhbiB2aWRlby5cbiAgICAgIGlmICh0cmFjay50eXBlICE9PSAndmlkZW8nKSB7XG4gICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSAweDAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYm94KHR5cGVzLnRyZXgsIHJlc3VsdCk7XG4gICAgfTtcblxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXVkaW9UcnVuLCB2aWRlb1RydW4sIHRydW5IZWFkZXI7XG5cbiAgICAgIC8vIFRoaXMgbWV0aG9kIGFzc3VtZXMgYWxsIHNhbXBsZXMgYXJlIHVuaWZvcm0uIFRoYXQgaXMsIGlmIGFcbiAgICAgIC8vIGR1cmF0aW9uIGlzIHByZXNlbnQgZm9yIHRoZSBmaXJzdCBzYW1wbGUsIGl0IHdpbGwgYmUgcHJlc2VudCBmb3JcbiAgICAgIC8vIGFsbCBzdWJzZXF1ZW50IHNhbXBsZXMuXG4gICAgICAvLyBzZWUgSVNPL0lFQyAxNDQ5Ni0xMjoyMDEyLCBTZWN0aW9uIDguOC44LjFcbiAgICAgIHRydW5IZWFkZXIgPSBmdW5jdGlvbiB0cnVuSGVhZGVyKHNhbXBsZXMsIG9mZnNldCkge1xuICAgICAgICB2YXIgZHVyYXRpb25QcmVzZW50ID0gMCxcbiAgICAgICAgICAgIHNpemVQcmVzZW50ID0gMCxcbiAgICAgICAgICAgIGZsYWdzUHJlc2VudCA9IDAsXG4gICAgICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSAwO1xuXG4gICAgICAgIC8vIHRydW4gZmxhZyBjb25zdGFudHNcbiAgICAgICAgaWYgKHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHNhbXBsZXNbMF0uZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHVyYXRpb25QcmVzZW50ID0gMHgxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtcGxlc1swXS5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNpemVQcmVzZW50ID0gMHgyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtcGxlc1swXS5mbGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmbGFnc1ByZXNlbnQgPSAweDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzYW1wbGVzWzBdLmNvbXBvc2l0aW9uVGltZU9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSAweDg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgICAgMHgwMCwgZHVyYXRpb25QcmVzZW50IHwgc2l6ZVByZXNlbnQgfCBmbGFnc1ByZXNlbnQgfCBjb21wb3NpdGlvblRpbWVPZmZzZXQsIDB4MDEsIC8vIGZsYWdzXG4gICAgICAgIChzYW1wbGVzLmxlbmd0aCAmIDB4RkYwMDAwMDApID4+PiAyNCwgKHNhbXBsZXMubGVuZ3RoICYgMHhGRjAwMDApID4+PiAxNiwgKHNhbXBsZXMubGVuZ3RoICYgMHhGRjAwKSA+Pj4gOCwgc2FtcGxlcy5sZW5ndGggJiAweEZGLCAvLyBzYW1wbGVfY291bnRcbiAgICAgICAgKG9mZnNldCAmIDB4RkYwMDAwMDApID4+PiAyNCwgKG9mZnNldCAmIDB4RkYwMDAwKSA+Pj4gMTYsIChvZmZzZXQgJiAweEZGMDApID4+PiA4LCBvZmZzZXQgJiAweEZGIC8vIGRhdGFfb2Zmc2V0XG4gICAgICAgIF07XG4gICAgICB9O1xuXG4gICAgICB2aWRlb1RydW4gPSBmdW5jdGlvbiB2aWRlb1RydW4odHJhY2ssIG9mZnNldCkge1xuICAgICAgICB2YXIgYnl0ZXMsIHNhbXBsZXMsIHNhbXBsZSwgaTtcblxuICAgICAgICBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICAgICAgb2Zmc2V0ICs9IDggKyAxMiArIDE2ICogc2FtcGxlcy5sZW5ndGg7XG5cbiAgICAgICAgYnl0ZXMgPSB0cnVuSGVhZGVyKHNhbXBsZXMsIG9mZnNldCk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgICAgIGJ5dGVzID0gYnl0ZXMuY29uY2F0KFsoc2FtcGxlLmR1cmF0aW9uICYgMHhGRjAwMDAwMCkgPj4+IDI0LCAoc2FtcGxlLmR1cmF0aW9uICYgMHhGRjAwMDApID4+PiAxNiwgKHNhbXBsZS5kdXJhdGlvbiAmIDB4RkYwMCkgPj4+IDgsIHNhbXBsZS5kdXJhdGlvbiAmIDB4RkYsIC8vIHNhbXBsZV9kdXJhdGlvblxuICAgICAgICAgIChzYW1wbGUuc2l6ZSAmIDB4RkYwMDAwMDApID4+PiAyNCwgKHNhbXBsZS5zaXplICYgMHhGRjAwMDApID4+PiAxNiwgKHNhbXBsZS5zaXplICYgMHhGRjAwKSA+Pj4gOCwgc2FtcGxlLnNpemUgJiAweEZGLCAvLyBzYW1wbGVfc2l6ZVxuICAgICAgICAgIHNhbXBsZS5mbGFncy5pc0xlYWRpbmcgPDwgMiB8IHNhbXBsZS5mbGFncy5kZXBlbmRzT24sIHNhbXBsZS5mbGFncy5pc0RlcGVuZGVkT24gPDwgNiB8IHNhbXBsZS5mbGFncy5oYXNSZWR1bmRhbmN5IDw8IDQgfCBzYW1wbGUuZmxhZ3MucGFkZGluZ1ZhbHVlIDw8IDEgfCBzYW1wbGUuZmxhZ3MuaXNOb25TeW5jU2FtcGxlLCBzYW1wbGUuZmxhZ3MuZGVncmFkYXRpb25Qcmlvcml0eSAmIDB4RjAgPDwgOCwgc2FtcGxlLmZsYWdzLmRlZ3JhZGF0aW9uUHJpb3JpdHkgJiAweDBGLCAvLyBzYW1wbGVfZmxhZ3NcbiAgICAgICAgICAoc2FtcGxlLmNvbXBvc2l0aW9uVGltZU9mZnNldCAmIDB4RkYwMDAwMDApID4+PiAyNCwgKHNhbXBsZS5jb21wb3NpdGlvblRpbWVPZmZzZXQgJiAweEZGMDAwMCkgPj4+IDE2LCAoc2FtcGxlLmNvbXBvc2l0aW9uVGltZU9mZnNldCAmIDB4RkYwMCkgPj4+IDgsIHNhbXBsZS5jb21wb3NpdGlvblRpbWVPZmZzZXQgJiAweEZGIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3godHlwZXMudHJ1biwgbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICAgIH07XG5cbiAgICAgIGF1ZGlvVHJ1biA9IGZ1bmN0aW9uIGF1ZGlvVHJ1bih0cmFjaywgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBieXRlcywgc2FtcGxlcywgc2FtcGxlLCBpO1xuXG4gICAgICAgIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdO1xuICAgICAgICBvZmZzZXQgKz0gOCArIDEyICsgOCAqIHNhbXBsZXMubGVuZ3RoO1xuXG4gICAgICAgIGJ5dGVzID0gdHJ1bkhlYWRlcihzYW1wbGVzLCBvZmZzZXQpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2FtcGxlID0gc2FtcGxlc1tpXTtcbiAgICAgICAgICBieXRlcyA9IGJ5dGVzLmNvbmNhdChbKHNhbXBsZS5kdXJhdGlvbiAmIDB4RkYwMDAwMDApID4+PiAyNCwgKHNhbXBsZS5kdXJhdGlvbiAmIDB4RkYwMDAwKSA+Pj4gMTYsIChzYW1wbGUuZHVyYXRpb24gJiAweEZGMDApID4+PiA4LCBzYW1wbGUuZHVyYXRpb24gJiAweEZGLCAvLyBzYW1wbGVfZHVyYXRpb25cbiAgICAgICAgICAoc2FtcGxlLnNpemUgJiAweEZGMDAwMDAwKSA+Pj4gMjQsIChzYW1wbGUuc2l6ZSAmIDB4RkYwMDAwKSA+Pj4gMTYsIChzYW1wbGUuc2l6ZSAmIDB4RkYwMCkgPj4+IDgsIHNhbXBsZS5zaXplICYgMHhGRl0pOyAvLyBzYW1wbGVfc2l6ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJveCh0eXBlcy50cnVuLCBuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgICAgfTtcblxuICAgICAgdHJ1biA9IGZ1bmN0aW9uIHRydW4odHJhY2ssIG9mZnNldCkge1xuICAgICAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgIHJldHVybiBhdWRpb1RydW4odHJhY2ssIG9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmlkZW9UcnVuKHRyYWNrLCBvZmZzZXQpO1xuICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgdmFyIG1wNEdlbmVyYXRvciA9IHtcbiAgICAgIGZ0eXA6IGZ0eXAsXG4gICAgICBtZGF0OiBtZGF0LFxuICAgICAgbW9vZjogbW9vZixcbiAgICAgIG1vb3Y6IG1vb3YsXG4gICAgICBpbml0U2VnbWVudDogZnVuY3Rpb24gaW5pdFNlZ21lbnQodHJhY2tzKSB7XG4gICAgICAgIHZhciBmaWxlVHlwZSA9IGZ0eXAoKSxcbiAgICAgICAgICAgIG1vdmllID0gbW9vdih0cmFja3MpLFxuICAgICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGZpbGVUeXBlLmJ5dGVMZW5ndGggKyBtb3ZpZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmVzdWx0LnNldChmaWxlVHlwZSk7XG4gICAgICAgIHJlc3VsdC5zZXQobW92aWUsIGZpbGVUeXBlLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBtdXguanNcbiAgICAgKlxuICAgICAqIENvcHlyaWdodCAoYykgMjAxNCBCcmlnaHRjb3ZlXG4gICAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIEEgbGlnaHR3ZWlnaHQgcmVhZGFibGUgc3RyZWFtIGltcGxlbWVudGlvbiB0aGF0IGhhbmRsZXMgZXZlbnQgZGlzcGF0Y2hpbmcuXG4gICAgICogT2JqZWN0cyB0aGF0IGluaGVyaXQgZnJvbSBzdHJlYW1zIHNob3VsZCBjYWxsIGluaXQgaW4gdGhlaXIgY29uc3RydWN0b3JzLlxuICAgICAqL1xuXG4gICAgdmFyIFN0cmVhbSA9IGZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAgICAgICAqIEBwYXJhbSB0eXBlIHtzdHJpbmd9IHRoZSBldmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSBsaXN0ZW5lciB7ZnVuY3Rpb259IHRoZSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYW4gZXZlbnQgb2ZcbiAgICAgICAgICogdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vyc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgIGlmICghbGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXJzW3R5cGVdLmNvbmNhdChsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYSBsaXN0ZW5lciBmb3IgYSBzcGVjaWZpZWQgZXZlbnQgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHR5cGUge3N0cmluZ30gdGhlIGV2ZW50IG5hbWVcbiAgICAgICAgICogQHBhcmFtIGxpc3RlbmVyIHtmdW5jdGlvbn0gYSBmdW5jdGlvbiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgZm9yIHRoaXNcbiAgICAgICAgICogdHlwZSBvZiBldmVudCB0aHJvdWdoIGBvbmBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICAgIGlmICghbGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluZGV4ID0gbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyc1t0eXBlXS5zbGljZSgpO1xuICAgICAgICAgIGxpc3RlbmVyc1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIHJldHVybiBpbmRleCA+IC0xO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZ2dlciBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb24gdGhpcyBzdHJlYW0uIEFueSBhZGRpdGlvbmFsXG4gICAgICAgICAqIGFyZ3VtZW50cyB0byB0aGlzIGZ1bmN0aW9uIGFyZSBwYXNzZWQgYXMgcGFyYW1ldGVycyB0byBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAqIEBwYXJhbSB0eXBlIHtzdHJpbmd9IHRoZSBldmVudCBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIHZhciBjYWxsYmFja3MsIGksIGxlbmd0aCwgYXJncztcbiAgICAgICAgICBjYWxsYmFja3MgPSBsaXN0ZW5lcnNbdHlwZV07XG4gICAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2xpY2luZyB0aGUgYXJndW1lbnRzIG9uIGV2ZXJ5IGludm9jYXRpb24gb2YgdGhpcyBtZXRob2RcbiAgICAgICAgICAvLyBjYW4gYWRkIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mIG92ZXJoZWFkLiBBdm9pZCB0aGVcbiAgICAgICAgICAvLyBpbnRlcm1lZGlhdGUgb2JqZWN0IGNyZWF0aW9uIGZvciB0aGUgY29tbW9uIGNhc2Ugb2YgYVxuICAgICAgICAgIC8vIHNpbmdsZSBjYWxsYmFjayBhcmd1bWVudFxuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3lzIHRoZSBzdHJlYW0gYW5kIGNsZWFucyB1cC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZvcndhcmRzIGFsbCBgZGF0YWAgZXZlbnRzIG9uIHRoaXMgc3RyZWFtIHRvIHRoZSBkZXN0aW5hdGlvbiBzdHJlYW0uIFRoZVxuICAgICAqIGRlc3RpbmF0aW9uIHN0cmVhbSBzaG91bGQgcHJvdmlkZSBhIG1ldGhvZCBgcHVzaGAgdG8gcmVjZWl2ZSB0aGUgZGF0YVxuICAgICAqIGV2ZW50cyBhcyB0aGV5IGFycml2ZS5cbiAgICAgKiBAcGFyYW0gZGVzdGluYXRpb24ge3N0cmVhbX0gdGhlIHN0cmVhbSB0aGF0IHdpbGwgcmVjZWl2ZSBhbGwgYGRhdGFgIGV2ZW50c1xuICAgICAqIEBwYXJhbSBhdXRvRmx1c2gge2Jvb2xlYW59IGlmIGZhbHNlLCB3ZSB3aWxsIG5vdCBjYWxsIGBmbHVzaGAgb24gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgY3VycmVudCBzdHJlYW0gZW1pdHMgYSAnZG9uZScgZXZlbnRcbiAgICAgKiBAc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fcmVhZGFibGVfcGlwZV9kZXN0aW5hdGlvbl9vcHRpb25zXG4gICAgICovXG4gICAgU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gICAgICB0aGlzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgZGVzdGluYXRpb24ucHVzaChkYXRhKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm9uKCdkb25lJywgZnVuY3Rpb24gKGZsdXNoU291cmNlKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uLmZsdXNoKGZsdXNoU291cmNlKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfTtcblxuICAgIC8vIERlZmF1bHQgc3RyZWFtIGZ1bmN0aW9ucyB0aGF0IGFyZSBleHBlY3RlZCB0byBiZSBvdmVycmlkZGVuIHRvIHBlcmZvcm1cbiAgICAvLyBhY3R1YWwgd29yay4gVGhlc2UgYXJlIHByb3ZpZGVkIGJ5IHRoZSBwcm90b3R5cGUgYXMgYSBzb3J0IG9mIG5vLW9wXG4gICAgLy8gaW1wbGVtZW50YXRpb24gc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNoZWNrIGZvciB0aGVpciBleGlzdGVuY2UgaW4gdGhlXG4gICAgLy8gYHBpcGVgIGZ1bmN0aW9uIGFib3ZlLlxuICAgIFN0cmVhbS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBkYXRhKTtcbiAgICB9O1xuXG4gICAgU3RyZWFtLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIChmbHVzaFNvdXJjZSkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdkb25lJywgZmx1c2hTb3VyY2UpO1xuICAgIH07XG5cbiAgICB2YXIgc3RyZWFtID0gU3RyZWFtO1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBMaW5rIFRvIFRyYW5zcG9ydFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBTdXBwbGVtZW50YWwgZW5oYW5jZW1lbnQgaW5mb3JtYXRpb24gKFNFSSkgTkFMIHVuaXRzIGhhdmUgYVxuICAgIC8vIHBheWxvYWQgdHlwZSBmaWVsZCB0byBpbmRpY2F0ZSBob3cgdGhleSBhcmUgdG8gYmVcbiAgICAvLyBpbnRlcnByZXRlZC4gQ0VBUy03MDggY2FwdGlvbiBjb250ZW50IGlzIGFsd2F5cyB0cmFuc21pdHRlZCB3aXRoXG4gICAgLy8gcGF5bG9hZCB0eXBlIDB4MDQuXG4gICAgdmFyIFVTRVJfREFUQV9SRUdJU1RFUkVEX0lUVV9UX1QzNSA9IDQsXG4gICAgICAgIFJCU1BfVFJBSUxJTkdfQklUUyA9IDEyODtcblxuICAgIC8qKlxuICAgICAgKiBQYXJzZSBhIHN1cHBsZW1lbnRhbCBlbmhhbmNlbWVudCBpbmZvcm1hdGlvbiAoU0VJKSBOQUwgdW5pdC5cbiAgICAgICogU3RvcHMgcGFyc2luZyBvbmNlIGEgbWVzc2FnZSBvZiB0eXBlIElUVSBUIFQzNSBoYXMgYmVlbiBmb3VuZC5cbiAgICAgICpcbiAgICAgICogQHBhcmFtIGJ5dGVzIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBTRUkgTkFMIHVuaXRcbiAgICAgICogQHJldHVybiB7b2JqZWN0fSB0aGUgcGFyc2VkIFNFSSBwYXlsb2FkXG4gICAgICAqIEBzZWUgUmVjLiBJVFUtVCBILjI2NCwgNy4zLjIuMy4xXG4gICAgICAqL1xuICAgIHZhciBwYXJzZVNlaSA9IGZ1bmN0aW9uIHBhcnNlU2VpKGJ5dGVzKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBwYXlsb2FkVHlwZTogLTEsXG4gICAgICAgIHBheWxvYWRTaXplOiAwXG4gICAgICB9LFxuICAgICAgICAgIHBheWxvYWRUeXBlID0gMCxcbiAgICAgICAgICBwYXlsb2FkU2l6ZSA9IDA7XG5cbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHNlaV9yYnNwIHBhcnNpbmcgZWFjaCBlYWNoIGluZGl2aWR1YWwgc2VpX21lc3NhZ2VcbiAgICAgIHdoaWxlIChpIDwgYnl0ZXMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAvLyBzdG9wIG9uY2Ugd2UgaGF2ZSBoaXQgdGhlIGVuZCBvZiB0aGUgc2VpX3Jic3BcbiAgICAgICAgaWYgKGJ5dGVzW2ldID09PSBSQlNQX1RSQUlMSU5HX0JJVFMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcnNlIHBheWxvYWQgdHlwZVxuICAgICAgICB3aGlsZSAoYnl0ZXNbaV0gPT09IDB4RkYpIHtcbiAgICAgICAgICBwYXlsb2FkVHlwZSArPSAyNTU7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWRUeXBlICs9IGJ5dGVzW2krK107XG5cbiAgICAgICAgLy8gUGFyc2UgcGF5bG9hZCBzaXplXG4gICAgICAgIHdoaWxlIChieXRlc1tpXSA9PT0gMHhGRikge1xuICAgICAgICAgIHBheWxvYWRTaXplICs9IDI1NTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZFNpemUgKz0gYnl0ZXNbaSsrXTtcblxuICAgICAgICAvLyB0aGlzIHNlaV9tZXNzYWdlIGlzIGEgNjA4LzcwOCBjYXB0aW9uIHNvIHNhdmUgaXQgYW5kIGJyZWFrXG4gICAgICAgIC8vIHRoZXJlIGNhbiBvbmx5IGV2ZXIgYmUgb25lIGNhcHRpb24gbWVzc2FnZSBpbiBhIGZyYW1lJ3Mgc2VpXG4gICAgICAgIGlmICghcmVzdWx0LnBheWxvYWQgJiYgcGF5bG9hZFR5cGUgPT09IFVTRVJfREFUQV9SRUdJU1RFUkVEX0lUVV9UX1QzNSkge1xuICAgICAgICAgIHJlc3VsdC5wYXlsb2FkVHlwZSA9IHBheWxvYWRUeXBlO1xuICAgICAgICAgIHJlc3VsdC5wYXlsb2FkU2l6ZSA9IHBheWxvYWRTaXplO1xuICAgICAgICAgIHJlc3VsdC5wYXlsb2FkID0gYnl0ZXMuc3ViYXJyYXkoaSwgaSArIHBheWxvYWRTaXplKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNraXAgdGhlIHBheWxvYWQgYW5kIHBhcnNlIHRoZSBuZXh0IG1lc3NhZ2VcbiAgICAgICAgaSArPSBwYXlsb2FkU2l6ZTtcbiAgICAgICAgcGF5bG9hZFR5cGUgPSAwO1xuICAgICAgICBwYXlsb2FkU2l6ZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIHNlZSBBTlNJL1NDVEUgMTI4LTEgKDIwMTMpLCBzZWN0aW9uIDguMVxuICAgIHZhciBwYXJzZVVzZXJEYXRhID0gZnVuY3Rpb24gcGFyc2VVc2VyRGF0YShzZWkpIHtcbiAgICAgIC8vIGl0dV90X3QzNV9jb250cnlfY29kZSBtdXN0IGJlIDE4MSAoVW5pdGVkIFN0YXRlcykgZm9yXG4gICAgICAvLyBjYXB0aW9uc1xuICAgICAgaWYgKHNlaS5wYXlsb2FkWzBdICE9PSAxODEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIGl0dV90X3QzNV9wcm92aWRlcl9jb2RlIHNob3VsZCBiZSA0OSAoQVRTQykgZm9yIGNhcHRpb25zXG4gICAgICBpZiAoKHNlaS5wYXlsb2FkWzFdIDw8IDggfCBzZWkucGF5bG9hZFsyXSkgIT09IDQ5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGUgdXNlcl9pZGVudGlmaWVyIHNob3VsZCBiZSBcIkdBOTRcIiB0byBpbmRpY2F0ZSBBVFNDMSBkYXRhXG4gICAgICBpZiAoU3RyaW5nLmZyb21DaGFyQ29kZShzZWkucGF5bG9hZFszXSwgc2VpLnBheWxvYWRbNF0sIHNlaS5wYXlsb2FkWzVdLCBzZWkucGF5bG9hZFs2XSkgIT09ICdHQTk0Jykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gZmluYWxseSwgdXNlcl9kYXRhX3R5cGVfY29kZSBzaG91bGQgYmUgMHgwMyBmb3IgY2FwdGlvbiBkYXRhXG4gICAgICBpZiAoc2VpLnBheWxvYWRbN10gIT09IDB4MDMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIHJldHVybiB0aGUgdXNlcl9kYXRhX3R5cGVfc3RydWN0dXJlIGFuZCBzdHJpcCB0aGUgdHJhaWxpbmdcbiAgICAgIC8vIG1hcmtlciBiaXRzXG4gICAgICByZXR1cm4gc2VpLnBheWxvYWQuc3ViYXJyYXkoOCwgc2VpLnBheWxvYWQubGVuZ3RoIC0gMSk7XG4gICAgfTtcblxuICAgIC8vIHNlZSBDRUEtNzA4LUQsIHNlY3Rpb24gNC40XG4gICAgdmFyIHBhcnNlQ2FwdGlvblBhY2tldHMgPSBmdW5jdGlvbiBwYXJzZUNhcHRpb25QYWNrZXRzKHB0cywgdXNlckRhdGEpIHtcbiAgICAgIHZhciByZXN1bHRzID0gW10sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBjb3VudCxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgZGF0YTtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBqdXN0IGZpbGxlciwgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgICBpZiAoISh1c2VyRGF0YVswXSAmIDB4NDApKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSBvdXQgdGhlIGNjX2RhdGFfMSBhbmQgY2NfZGF0YV8yIGZpZWxkc1xuICAgICAgY291bnQgPSB1c2VyRGF0YVswXSAmIDB4MWY7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBvZmZzZXQgPSBpICogMztcbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICB0eXBlOiB1c2VyRGF0YVtvZmZzZXQgKyAyXSAmIDB4MDMsXG4gICAgICAgICAgcHRzOiBwdHNcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBjYXB0dXJlIGNjIGRhdGEgd2hlbiBjY192YWxpZCBpcyAxXG4gICAgICAgIGlmICh1c2VyRGF0YVtvZmZzZXQgKyAyXSAmIDB4MDQpIHtcbiAgICAgICAgICBkYXRhLmNjRGF0YSA9IHVzZXJEYXRhW29mZnNldCArIDNdIDw8IDggfCB1c2VyRGF0YVtvZmZzZXQgKyA0XTtcbiAgICAgICAgICByZXN1bHRzLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICB2YXIgQ2FwdGlvblN0cmVhbSA9IGZ1bmN0aW9uIENhcHRpb25TdHJlYW0oKSB7XG5cbiAgICAgIENhcHRpb25TdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5jYXB0aW9uUGFja2V0c18gPSBbXTtcblxuICAgICAgdGhpcy5jY1N0cmVhbXNfID0gW25ldyBDZWE2MDhTdHJlYW0oMCwgMCksIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgIG5ldyBDZWE2MDhTdHJlYW0oMCwgMSksIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgIG5ldyBDZWE2MDhTdHJlYW0oMSwgMCksIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgIG5ldyBDZWE2MDhTdHJlYW0oMSwgMSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgXTtcblxuICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAvLyBmb3J3YXJkIGRhdGEgYW5kIGRvbmUgZXZlbnRzIGZyb20gQ0NzIHRvIHRoaXMgQ2FwdGlvblN0cmVhbVxuICAgICAgdGhpcy5jY1N0cmVhbXNfLmZvckVhY2goZnVuY3Rpb24gKGNjKSB7XG4gICAgICAgIGNjLm9uKCdkYXRhJywgdGhpcy50cmlnZ2VyLmJpbmQodGhpcywgJ2RhdGEnKSk7XG4gICAgICAgIGNjLm9uKCdkb25lJywgdGhpcy50cmlnZ2VyLmJpbmQodGhpcywgJ2RvbmUnKSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gICAgQ2FwdGlvblN0cmVhbS5wcm90b3R5cGUgPSBuZXcgc3RyZWFtKCk7XG4gICAgQ2FwdGlvblN0cmVhbS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIHNlaSwgdXNlckRhdGE7XG5cbiAgICAgIC8vIG9ubHkgZXhhbWluZSBTRUkgTkFMc1xuICAgICAgaWYgKGV2ZW50Lm5hbFVuaXRUeXBlICE9PSAnc2VpX3Jic3AnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgdGhlIHNlaVxuICAgICAgc2VpID0gcGFyc2VTZWkoZXZlbnQuZXNjYXBlZFJCU1ApO1xuXG4gICAgICAvLyBpZ25vcmUgZXZlcnl0aGluZyBidXQgdXNlcl9kYXRhX3JlZ2lzdGVyZWRfaXR1X3RfdDM1XG4gICAgICBpZiAoc2VpLnBheWxvYWRUeXBlICE9PSBVU0VSX0RBVEFfUkVHSVNURVJFRF9JVFVfVF9UMzUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSBvdXQgdGhlIHVzZXIgZGF0YSBwYXlsb2FkXG4gICAgICB1c2VyRGF0YSA9IHBhcnNlVXNlckRhdGEoc2VpKTtcblxuICAgICAgLy8gaWdub3JlIHVucmVjb2duaXplZCB1c2VyRGF0YVxuICAgICAgaWYgKCF1c2VyRGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNvbWV0aW1lcywgdGhlIHNhbWUgc2VnbWVudCAjIHdpbGwgYmUgZG93bmxvYWRlZCB0d2ljZS4gVG8gc3RvcCB0aGVcbiAgICAgIC8vIGNhcHRpb24gZGF0YSBmcm9tIGJlaW5nIHByb2Nlc3NlZCB0d2ljZSwgd2UgdHJhY2sgdGhlIGxhdGVzdCBkdHMgd2UndmVcbiAgICAgIC8vIHJlY2VpdmVkIGFuZCBpZ25vcmUgZXZlcnl0aGluZyB3aXRoIGEgZHRzIGJlZm9yZSB0aGF0LiBIb3dldmVyLCBzaW5jZVxuICAgICAgLy8gZGF0YSBmb3IgYSBzcGVjaWZpYyBkdHMgY2FuIGJlIHNwbGl0IGFjcm9zcyBwYWNrZXRzIG9uIGVpdGhlciBzaWRlIG9mXG4gICAgICAvLyBhIHNlZ21lbnQgYm91bmRhcnksIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlICpkb24ndCogaWdub3JlIHRoZSBwYWNrZXRzXG4gICAgICAvLyBmcm9tIHRoZSAqbmV4dCogc2VnbWVudCB0aGF0IGhhdmUgZHRzID09PSB0aGlzLmxhdGVzdER0c18uIEJ5IGNvbnN0YW50bHlcbiAgICAgIC8vIHRyYWNraW5nIHRoZSBudW1iZXIgb2YgcGFja2V0cyByZWNlaXZlZCB3aXRoIGR0cyA9PT0gdGhpcy5sYXRlc3REdHNfLCB3ZVxuICAgICAgLy8ga25vdyBob3cgbWFueSBzaG91bGQgYmUgaWdub3JlZCBvbmNlIHdlIHN0YXJ0IHJlY2VpdmluZyBkdXBsaWNhdGVzLlxuICAgICAgaWYgKGV2ZW50LmR0cyA8IHRoaXMubGF0ZXN0RHRzXykge1xuICAgICAgICAvLyBXZSd2ZSBzdGFydGVkIGdldHRpbmcgb2xkZXIgZGF0YSwgc28gc2V0IHRoZSBmbGFnLlxuICAgICAgICB0aGlzLmlnbm9yZU5leHRFcXVhbER0c18gPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmR0cyA9PT0gdGhpcy5sYXRlc3REdHNfICYmIHRoaXMuaWdub3JlTmV4dEVxdWFsRHRzXykge1xuICAgICAgICB0aGlzLm51bVNhbWVEdHNfLS07XG4gICAgICAgIGlmICghdGhpcy5udW1TYW1lRHRzXykge1xuICAgICAgICAgIC8vIFdlJ3ZlIHJlY2VpdmVkIHRoZSBsYXN0IGR1cGxpY2F0ZSBwYWNrZXQsIHRpbWUgdG8gc3RhcnQgcHJvY2Vzc2luZyBhZ2FpblxuICAgICAgICAgIHRoaXMuaWdub3JlTmV4dEVxdWFsRHRzXyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2Ugb3V0IENDIGRhdGEgcGFja2V0cyBhbmQgc2F2ZSB0aGVtIGZvciBsYXRlclxuICAgICAgdGhpcy5jYXB0aW9uUGFja2V0c18gPSB0aGlzLmNhcHRpb25QYWNrZXRzXy5jb25jYXQocGFyc2VDYXB0aW9uUGFja2V0cyhldmVudC5wdHMsIHVzZXJEYXRhKSk7XG4gICAgICBpZiAodGhpcy5sYXRlc3REdHNfICE9PSBldmVudC5kdHMpIHtcbiAgICAgICAgdGhpcy5udW1TYW1lRHRzXyA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLm51bVNhbWVEdHNfKys7XG4gICAgICB0aGlzLmxhdGVzdER0c18gPSBldmVudC5kdHM7XG4gICAgfTtcblxuICAgIENhcHRpb25TdHJlYW0ucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IHBhcnNlZCBjYXB0aW9ucyBiZWZvcmUgcHJvY2VlZGluZ1xuICAgICAgaWYgKCF0aGlzLmNhcHRpb25QYWNrZXRzXy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jY1N0cmVhbXNfLmZvckVhY2goZnVuY3Rpb24gKGNjKSB7XG4gICAgICAgICAgY2MuZmx1c2goKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSW4gQ2hyb21lLCB0aGUgQXJyYXkjc29ydCBmdW5jdGlvbiBpcyBub3Qgc3RhYmxlIHNvIGFkZCBhXG4gICAgICAvLyBwcmVzb3J0SW5kZXggdGhhdCB3ZSBjYW4gdXNlIHRvIGVuc3VyZSB3ZSBnZXQgYSBzdGFibGUtc29ydFxuICAgICAgdGhpcy5jYXB0aW9uUGFja2V0c18uZm9yRWFjaChmdW5jdGlvbiAoZWxlbSwgaWR4KSB7XG4gICAgICAgIGVsZW0ucHJlc29ydEluZGV4ID0gaWR4O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHNvcnQgY2FwdGlvbiBieXRlLXBhaXJzIGJhc2VkIG9uIHRoZWlyIFBUUyB2YWx1ZXNcbiAgICAgIHRoaXMuY2FwdGlvblBhY2tldHNfLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKGEucHRzID09PSBiLnB0cykge1xuICAgICAgICAgIHJldHVybiBhLnByZXNvcnRJbmRleCAtIGIucHJlc29ydEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLnB0cyAtIGIucHRzO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuY2FwdGlvblBhY2tldHNfLmZvckVhY2goZnVuY3Rpb24gKHBhY2tldCkge1xuICAgICAgICBpZiAocGFja2V0LnR5cGUgPCAyKSB7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggcGFja2V0IHRvIHRoZSByaWdodCBDZWE2MDhTdHJlYW1cbiAgICAgICAgICB0aGlzLmRpc3BhdGNoQ2VhNjA4UGFja2V0KHBhY2tldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBpcyB3aGVyZSBhbiAnZWxzZScgd291bGQgZ28gZm9yIGEgZGlzcGF0Y2hpbmcgcGFja2V0c1xuICAgICAgICAvLyB0byBhIHRoZW9yZXRpY2FsIENlYTcwOFN0cmVhbSB0aGF0IGhhbmRsZXMgU0VSVklDRW4gZGF0YVxuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHRoaXMuY2FwdGlvblBhY2tldHNfLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmNjU3RyZWFtc18uZm9yRWFjaChmdW5jdGlvbiAoY2MpIHtcbiAgICAgICAgY2MuZmx1c2goKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICBDYXB0aW9uU3RyZWFtLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubGF0ZXN0RHRzXyA9IG51bGw7XG4gICAgICB0aGlzLmlnbm9yZU5leHRFcXVhbER0c18gPSBmYWxzZTtcbiAgICAgIHRoaXMubnVtU2FtZUR0c18gPSAwO1xuICAgICAgdGhpcy5hY3RpdmVDZWE2MDhDaGFubmVsXyA9IFtudWxsLCBudWxsXTtcbiAgICAgIHRoaXMuY2NTdHJlYW1zXy5mb3JFYWNoKGZ1bmN0aW9uIChjY1N0cmVhbSkge1xuICAgICAgICBjY1N0cmVhbS5yZXNldCgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIENhcHRpb25TdHJlYW0ucHJvdG90eXBlLmRpc3BhdGNoQ2VhNjA4UGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICAgICAgLy8gTk9URTogcGFja2V0LnR5cGUgaXMgdGhlIENFQTYwOCBmaWVsZFxuICAgICAgaWYgKHRoaXMuc2V0c0NoYW5uZWwxQWN0aXZlKHBhY2tldCkpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVDZWE2MDhDaGFubmVsX1twYWNrZXQudHlwZV0gPSAwO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHNDaGFubmVsMkFjdGl2ZShwYWNrZXQpKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2VhNjA4Q2hhbm5lbF9bcGFja2V0LnR5cGVdID0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFjdGl2ZUNlYTYwOENoYW5uZWxfW3BhY2tldC50eXBlXSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IHJlY2VpdmVkIGFueXRoaW5nIHRvIHNldCB0aGUgYWN0aXZlIGNoYW5uZWwsIGRpc2NhcmQgdGhlXG4gICAgICAgIC8vIGRhdGE7IHdlIGRvbid0IHdhbnQganVtYmxlZCBjYXB0aW9uc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNjU3RyZWFtc19bKHBhY2tldC50eXBlIDw8IDEpICsgdGhpcy5hY3RpdmVDZWE2MDhDaGFubmVsX1twYWNrZXQudHlwZV1dLnB1c2gocGFja2V0KTtcbiAgICB9O1xuXG4gICAgQ2FwdGlvblN0cmVhbS5wcm90b3R5cGUuc2V0c0NoYW5uZWwxQWN0aXZlID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICAgICAgcmV0dXJuIChwYWNrZXQuY2NEYXRhICYgMHg3ODAwKSA9PT0gMHgxMDAwO1xuICAgIH07XG4gICAgQ2FwdGlvblN0cmVhbS5wcm90b3R5cGUuc2V0c0NoYW5uZWwyQWN0aXZlID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICAgICAgcmV0dXJuIChwYWNrZXQuY2NEYXRhICYgMHg3ODAwKSA9PT0gMHgxODAwO1xuICAgIH07XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU2Vzc2lvbiB0byBBcHBsaWNhdGlvblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBDSEFSQUNURVJfVFJBTlNMQVRJT04gPSB7XG4gICAgICAweDJhOiAweGUxLCAvLyDDoVxuICAgICAgMHg1YzogMHhlOSwgLy8gw6lcbiAgICAgIDB4NWU6IDB4ZWQsIC8vIMOtXG4gICAgICAweDVmOiAweGYzLCAvLyDDs1xuICAgICAgMHg2MDogMHhmYSwgLy8gw7pcbiAgICAgIDB4N2I6IDB4ZTcsIC8vIMOnXG4gICAgICAweDdjOiAweGY3LCAvLyDDt1xuICAgICAgMHg3ZDogMHhkMSwgLy8gw5FcbiAgICAgIDB4N2U6IDB4ZjEsIC8vIMOxXG4gICAgICAweDdmOiAweDI1ODgsIC8vIOKWiFxuICAgICAgMHgwMTMwOiAweGFlLCAvLyDCrlxuICAgICAgMHgwMTMxOiAweGIwLCAvLyDCsFxuICAgICAgMHgwMTMyOiAweGJkLCAvLyDCvVxuICAgICAgMHgwMTMzOiAweGJmLCAvLyDCv1xuICAgICAgMHgwMTM0OiAweDIxMjIsIC8vIOKEolxuICAgICAgMHgwMTM1OiAweGEyLCAvLyDColxuICAgICAgMHgwMTM2OiAweGEzLCAvLyDCo1xuICAgICAgMHgwMTM3OiAweDI2NmEsIC8vIOKZqlxuICAgICAgMHgwMTM4OiAweGUwLCAvLyDDoFxuICAgICAgMHgwMTM5OiAweGEwLCAvL1xuICAgICAgMHgwMTNhOiAweGU4LCAvLyDDqFxuICAgICAgMHgwMTNiOiAweGUyLCAvLyDDolxuICAgICAgMHgwMTNjOiAweGVhLCAvLyDDqlxuICAgICAgMHgwMTNkOiAweGVlLCAvLyDDrlxuICAgICAgMHgwMTNlOiAweGY0LCAvLyDDtFxuICAgICAgMHgwMTNmOiAweGZiLCAvLyDDu1xuICAgICAgMHgwMjIwOiAweGMxLCAvLyDDgVxuICAgICAgMHgwMjIxOiAweGM5LCAvLyDDiVxuICAgICAgMHgwMjIyOiAweGQzLCAvLyDDk1xuICAgICAgMHgwMjIzOiAweGRhLCAvLyDDmlxuICAgICAgMHgwMjI0OiAweGRjLCAvLyDDnFxuICAgICAgMHgwMjI1OiAweGZjLCAvLyDDvFxuICAgICAgMHgwMjI2OiAweDIwMTgsIC8vIOKAmFxuICAgICAgMHgwMjI3OiAweGExLCAvLyDCoVxuICAgICAgMHgwMjI4OiAweDJhLCAvLyAqXG4gICAgICAweDAyMjk6IDB4MjcsIC8vICdcbiAgICAgIDB4MDIyYTogMHgyMDE0LCAvLyDigJRcbiAgICAgIDB4MDIyYjogMHhhOSwgLy8gwqlcbiAgICAgIDB4MDIyYzogMHgyMTIwLCAvLyDihKBcbiAgICAgIDB4MDIyZDogMHgyMDIyLCAvLyDigKJcbiAgICAgIDB4MDIyZTogMHgyMDFjLCAvLyDigJxcbiAgICAgIDB4MDIyZjogMHgyMDFkLCAvLyDigJ1cbiAgICAgIDB4MDIzMDogMHhjMCwgLy8gw4BcbiAgICAgIDB4MDIzMTogMHhjMiwgLy8gw4JcbiAgICAgIDB4MDIzMjogMHhjNywgLy8gw4dcbiAgICAgIDB4MDIzMzogMHhjOCwgLy8gw4hcbiAgICAgIDB4MDIzNDogMHhjYSwgLy8gw4pcbiAgICAgIDB4MDIzNTogMHhjYiwgLy8gw4tcbiAgICAgIDB4MDIzNjogMHhlYiwgLy8gw6tcbiAgICAgIDB4MDIzNzogMHhjZSwgLy8gw45cbiAgICAgIDB4MDIzODogMHhjZiwgLy8gw49cbiAgICAgIDB4MDIzOTogMHhlZiwgLy8gw69cbiAgICAgIDB4MDIzYTogMHhkNCwgLy8gw5RcbiAgICAgIDB4MDIzYjogMHhkOSwgLy8gw5lcbiAgICAgIDB4MDIzYzogMHhmOSwgLy8gw7lcbiAgICAgIDB4MDIzZDogMHhkYiwgLy8gw5tcbiAgICAgIDB4MDIzZTogMHhhYiwgLy8gwqtcbiAgICAgIDB4MDIzZjogMHhiYiwgLy8gwrtcbiAgICAgIDB4MDMyMDogMHhjMywgLy8gw4NcbiAgICAgIDB4MDMyMTogMHhlMywgLy8gw6NcbiAgICAgIDB4MDMyMjogMHhjZCwgLy8gw41cbiAgICAgIDB4MDMyMzogMHhjYywgLy8gw4xcbiAgICAgIDB4MDMyNDogMHhlYywgLy8gw6xcbiAgICAgIDB4MDMyNTogMHhkMiwgLy8gw5JcbiAgICAgIDB4MDMyNjogMHhmMiwgLy8gw7JcbiAgICAgIDB4MDMyNzogMHhkNSwgLy8gw5VcbiAgICAgIDB4MDMyODogMHhmNSwgLy8gw7VcbiAgICAgIDB4MDMyOTogMHg3YiwgLy8ge1xuICAgICAgMHgwMzJhOiAweDdkLCAvLyB9XG4gICAgICAweDAzMmI6IDB4NWMsIC8vIFxcXG4gICAgICAweDAzMmM6IDB4NWUsIC8vIF5cbiAgICAgIDB4MDMyZDogMHg1ZiwgLy8gX1xuICAgICAgMHgwMzJlOiAweDdjLCAvLyB8XG4gICAgICAweDAzMmY6IDB4N2UsIC8vIH5cbiAgICAgIDB4MDMzMDogMHhjNCwgLy8gw4RcbiAgICAgIDB4MDMzMTogMHhlNCwgLy8gw6RcbiAgICAgIDB4MDMzMjogMHhkNiwgLy8gw5ZcbiAgICAgIDB4MDMzMzogMHhmNiwgLy8gw7ZcbiAgICAgIDB4MDMzNDogMHhkZiwgLy8gw59cbiAgICAgIDB4MDMzNTogMHhhNSwgLy8gwqVcbiAgICAgIDB4MDMzNjogMHhhNCwgLy8gwqRcbiAgICAgIDB4MDMzNzogMHgyNTAyLCAvLyDilIJcbiAgICAgIDB4MDMzODogMHhjNSwgLy8gw4VcbiAgICAgIDB4MDMzOTogMHhlNSwgLy8gw6VcbiAgICAgIDB4MDMzYTogMHhkOCwgLy8gw5hcbiAgICAgIDB4MDMzYjogMHhmOCwgLy8gw7hcbiAgICAgIDB4MDMzYzogMHgyNTBjLCAvLyDilIxcbiAgICAgIDB4MDMzZDogMHgyNTEwLCAvLyDilJBcbiAgICAgIDB4MDMzZTogMHgyNTE0LCAvLyDilJRcbiAgICAgIDB4MDMzZjogMHgyNTE4IC8vIOKUmFxuICAgIH07XG5cbiAgICB2YXIgZ2V0Q2hhckZyb21Db2RlID0gZnVuY3Rpb24gZ2V0Q2hhckZyb21Db2RlKGNvZGUpIHtcbiAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGNvZGUgPSBDSEFSQUNURVJfVFJBTlNMQVRJT05bY29kZV0gfHwgY29kZTtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH07XG5cbiAgICAvLyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgcm93IGluIGEgQ0VBLTYwOCBkaXNwbGF5IGJ1ZmZlclxuICAgIHZhciBCT1RUT01fUk9XID0gMTQ7XG5cbiAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgZm9yIG1hcHBpbmcgUEFDcyAtPiByb3cgIywgc2luY2UgdGhlcmUncyBubyB3YXkgb2ZcbiAgICAvLyBnZXR0aW5nIGl0IHRocm91Z2ggYml0IGxvZ2ljLlxuICAgIHZhciBST1dTID0gWzB4MTEwMCwgMHgxMTIwLCAweDEyMDAsIDB4MTIyMCwgMHgxNTAwLCAweDE1MjAsIDB4MTYwMCwgMHgxNjIwLCAweDE3MDAsIDB4MTcyMCwgMHgxMDAwLCAweDEzMDAsIDB4MTMyMCwgMHgxNDAwLCAweDE0MjBdO1xuXG4gICAgLy8gQ0VBLTYwOCBjYXB0aW9ucyBhcmUgcmVuZGVyZWQgb250byBhIDM0eDE1IG1hdHJpeCBvZiBjaGFyYWN0ZXJcbiAgICAvLyBjZWxscy4gVGhlIFwiYm90dG9tXCIgcm93IGlzIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIG91dGVyIGFycmF5LlxuICAgIHZhciBjcmVhdGVEaXNwbGF5QnVmZmVyID0gZnVuY3Rpb24gY3JlYXRlRGlzcGxheUJ1ZmZlcigpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBpID0gQk9UVE9NX1JPVyArIDE7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHZhciBDZWE2MDhTdHJlYW0gPSBmdW5jdGlvbiBDZWE2MDhTdHJlYW0oZmllbGQsIGRhdGFDaGFubmVsKSB7XG4gICAgICBDZWE2MDhTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5maWVsZF8gPSBmaWVsZCB8fCAwO1xuICAgICAgdGhpcy5kYXRhQ2hhbm5lbF8gPSBkYXRhQ2hhbm5lbCB8fCAwO1xuXG4gICAgICB0aGlzLm5hbWVfID0gJ0NDJyArICgodGhpcy5maWVsZF8gPDwgMSB8IHRoaXMuZGF0YUNoYW5uZWxfKSArIDEpO1xuXG4gICAgICB0aGlzLnNldENvbnN0YW50cygpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICB0aGlzLnB1c2ggPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICAgIHZhciBkYXRhLCBzd2FwLCBjaGFyMCwgY2hhcjEsIHRleHQ7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgcGFyaXR5IGJpdHNcbiAgICAgICAgZGF0YSA9IHBhY2tldC5jY0RhdGEgJiAweDdmN2Y7XG5cbiAgICAgICAgLy8gaWdub3JlIGR1cGxpY2F0ZSBjb250cm9sIGNvZGVzOyB0aGUgc3BlYyBkZW1hbmRzIHRoZXkncmUgc2VudCB0d2ljZVxuICAgICAgICBpZiAoZGF0YSA9PT0gdGhpcy5sYXN0Q29udHJvbENvZGVfKSB7XG4gICAgICAgICAgdGhpcy5sYXN0Q29udHJvbENvZGVfID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSBjb250cm9sIGNvZGVzXG4gICAgICAgIGlmICgoZGF0YSAmIDB4ZjAwMCkgPT09IDB4MTAwMCkge1xuICAgICAgICAgIHRoaXMubGFzdENvbnRyb2xDb2RlXyA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSAhPT0gdGhpcy5QQURESU5HXykge1xuICAgICAgICAgIHRoaXMubGFzdENvbnRyb2xDb2RlXyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFyMCA9IGRhdGEgPj4+IDg7XG4gICAgICAgIGNoYXIxID0gZGF0YSAmIDB4ZmY7XG5cbiAgICAgICAgaWYgKGRhdGEgPT09IHRoaXMuUEFERElOR18pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdGhpcy5SRVNVTUVfQ0FQVElPTl9MT0FESU5HXykge1xuICAgICAgICAgIHRoaXMubW9kZV8gPSAncG9wT24nO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHRoaXMuRU5EX09GX0NBUFRJT05fKSB7XG4gICAgICAgICAgdGhpcy5jbGVhckZvcm1hdHRpbmcocGFja2V0LnB0cyk7XG4gICAgICAgICAgLy8gaWYgYSBjYXB0aW9uIHdhcyBiZWluZyBkaXNwbGF5ZWQsIGl0J3MgZ29uZSBub3dcbiAgICAgICAgICB0aGlzLmZsdXNoRGlzcGxheWVkKHBhY2tldC5wdHMpO1xuXG4gICAgICAgICAgLy8gZmxpcCBtZW1vcnlcbiAgICAgICAgICBzd2FwID0gdGhpcy5kaXNwbGF5ZWRfO1xuICAgICAgICAgIHRoaXMuZGlzcGxheWVkXyA9IHRoaXMubm9uRGlzcGxheWVkXztcbiAgICAgICAgICB0aGlzLm5vbkRpc3BsYXllZF8gPSBzd2FwO1xuXG4gICAgICAgICAgLy8gc3RhcnQgbWVhc3VyaW5nIHRoZSB0aW1lIHRvIGRpc3BsYXkgdGhlIGNhcHRpb25cbiAgICAgICAgICB0aGlzLnN0YXJ0UHRzXyA9IHBhY2tldC5wdHM7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdGhpcy5ST0xMX1VQXzJfUk9XU18pIHtcbiAgICAgICAgICB0aGlzLnRvcFJvd18gPSBCT1RUT01fUk9XIC0gMTtcbiAgICAgICAgICB0aGlzLm1vZGVfID0gJ3JvbGxVcCc7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdGhpcy5ST0xMX1VQXzNfUk9XU18pIHtcbiAgICAgICAgICB0aGlzLnRvcFJvd18gPSBCT1RUT01fUk9XIC0gMjtcbiAgICAgICAgICB0aGlzLm1vZGVfID0gJ3JvbGxVcCc7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdGhpcy5ST0xMX1VQXzRfUk9XU18pIHtcbiAgICAgICAgICB0aGlzLnRvcFJvd18gPSBCT1RUT01fUk9XIC0gMztcbiAgICAgICAgICB0aGlzLm1vZGVfID0gJ3JvbGxVcCc7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdGhpcy5DQVJSSUFHRV9SRVRVUk5fKSB7XG4gICAgICAgICAgdGhpcy5jbGVhckZvcm1hdHRpbmcocGFja2V0LnB0cyk7XG4gICAgICAgICAgdGhpcy5mbHVzaERpc3BsYXllZChwYWNrZXQucHRzKTtcbiAgICAgICAgICB0aGlzLnNoaWZ0Um93c1VwXygpO1xuICAgICAgICAgIHRoaXMuc3RhcnRQdHNfID0gcGFja2V0LnB0cztcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhID09PSB0aGlzLkJBQ0tTUEFDRV8pIHtcbiAgICAgICAgICBpZiAodGhpcy5tb2RlXyA9PT0gJ3BvcE9uJykge1xuICAgICAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRfW0JPVFRPTV9ST1ddID0gdGhpcy5ub25EaXNwbGF5ZWRfW0JPVFRPTV9ST1ddLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRfW0JPVFRPTV9ST1ddID0gdGhpcy5kaXNwbGF5ZWRfW0JPVFRPTV9ST1ddLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdGhpcy5FUkFTRV9ESVNQTEFZRURfTUVNT1JZXykge1xuICAgICAgICAgIHRoaXMuZmx1c2hEaXNwbGF5ZWQocGFja2V0LnB0cyk7XG4gICAgICAgICAgdGhpcy5kaXNwbGF5ZWRfID0gY3JlYXRlRGlzcGxheUJ1ZmZlcigpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHRoaXMuRVJBU0VfTk9OX0RJU1BMQVlFRF9NRU1PUllfKSB7XG4gICAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRfID0gY3JlYXRlRGlzcGxheUJ1ZmZlcigpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHRoaXMuUkVTVU1FX0RJUkVDVF9DQVBUSU9OSU5HXykge1xuICAgICAgICAgIHRoaXMubW9kZV8gPSAncGFpbnRPbic7XG5cbiAgICAgICAgICAvLyBBcHBlbmQgc3BlY2lhbCBjaGFyYWN0ZXJzIHRvIGNhcHRpb24gdGV4dFxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTcGVjaWFsQ2hhcmFjdGVyKGNoYXIwLCBjaGFyMSkpIHtcbiAgICAgICAgICAvLyBCaXRtYXNrIGNoYXIwIHNvIHRoYXQgd2UgY2FuIGFwcGx5IGNoYXJhY3RlciB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIGZpZWxkIGFuZCBkYXRhIGNoYW5uZWwuXG4gICAgICAgICAgLy8gVGhlbiBieXRlLXNoaWZ0IHRvIHRoZSBsZWZ0IGFuZCBPUiB3aXRoIGNoYXIxIHNvIHdlIGNhbiBwYXNzIHRoZVxuICAgICAgICAgIC8vIGVudGlyZSBjaGFyYWN0ZXIgY29kZSB0byBgZ2V0Q2hhckZyb21Db2RlYC5cbiAgICAgICAgICBjaGFyMCA9IChjaGFyMCAmIDB4MDMpIDw8IDg7XG4gICAgICAgICAgdGV4dCA9IGdldENoYXJGcm9tQ29kZShjaGFyMCB8IGNoYXIxKTtcbiAgICAgICAgICB0aGlzW3RoaXMubW9kZV9dKHBhY2tldC5wdHMsIHRleHQpO1xuICAgICAgICAgIHRoaXMuY29sdW1uXysrO1xuXG4gICAgICAgICAgLy8gQXBwZW5kIGV4dGVuZGVkIGNoYXJhY3RlcnMgdG8gY2FwdGlvbiB0ZXh0XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0V4dENoYXJhY3RlcihjaGFyMCwgY2hhcjEpKSB7XG4gICAgICAgICAgLy8gRXh0ZW5kZWQgY2hhcmFjdGVycyBhbHdheXMgZm9sbG93IHRoZWlyIFwibm9uLWV4dGVuZGVkXCIgZXF1aXZhbGVudHMuXG4gICAgICAgICAgLy8gSUUgaWYgYSBcIsOoXCIgaXMgZGVzaXJlZCwgeW91J2xsIGFsd2F5cyByZWNlaXZlIFwiZcOoXCI7IG5vbi1jb21wbGlhbnRcbiAgICAgICAgICAvLyBkZWNvZGVycyBhcmUgc3VwcG9zZWQgdG8gZHJvcCB0aGUgXCLDqFwiLCB3aGlsZSBjb21wbGlhbnQgZGVjb2RlcnNcbiAgICAgICAgICAvLyBiYWNrc3BhY2UgdGhlIFwiZVwiIGFuZCBpbnNlcnQgXCLDqFwiLlxuXG4gICAgICAgICAgLy8gRGVsZXRlIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXJcbiAgICAgICAgICBpZiAodGhpcy5tb2RlXyA9PT0gJ3BvcE9uJykge1xuICAgICAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRfW3RoaXMucm93X10gPSB0aGlzLm5vbkRpc3BsYXllZF9bdGhpcy5yb3dfXS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXSA9IHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQml0bWFzayBjaGFyMCBzbyB0aGF0IHdlIGNhbiBhcHBseSBjaGFyYWN0ZXIgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiBmaWVsZCBhbmQgZGF0YSBjaGFubmVsLlxuICAgICAgICAgIC8vIFRoZW4gYnl0ZS1zaGlmdCB0byB0aGUgbGVmdCBhbmQgT1Igd2l0aCBjaGFyMSBzbyB3ZSBjYW4gcGFzcyB0aGVcbiAgICAgICAgICAvLyBlbnRpcmUgY2hhcmFjdGVyIGNvZGUgdG8gYGdldENoYXJGcm9tQ29kZWAuXG4gICAgICAgICAgY2hhcjAgPSAoY2hhcjAgJiAweDAzKSA8PCA4O1xuICAgICAgICAgIHRleHQgPSBnZXRDaGFyRnJvbUNvZGUoY2hhcjAgfCBjaGFyMSk7XG4gICAgICAgICAgdGhpc1t0aGlzLm1vZGVfXShwYWNrZXQucHRzLCB0ZXh0KTtcbiAgICAgICAgICB0aGlzLmNvbHVtbl8rKztcblxuICAgICAgICAgIC8vIFByb2Nlc3MgbWlkLXJvdyBjb2Rlc1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNNaWRSb3dDb2RlKGNoYXIwLCBjaGFyMSkpIHtcbiAgICAgICAgICAvLyBBdHRyaWJ1dGVzIGFyZSBub3QgYWRkaXRpdmUsIHNvIGNsZWFyIGFsbCBmb3JtYXR0aW5nXG4gICAgICAgICAgdGhpcy5jbGVhckZvcm1hdHRpbmcocGFja2V0LnB0cyk7XG5cbiAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHN0YW5kYXJkLCBtaWQtcm93IGNvZGVzXG4gICAgICAgICAgLy8gc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggc3BhY2VzLCBzbyBhZGQgb25lIG5vd1xuICAgICAgICAgIHRoaXNbdGhpcy5tb2RlX10ocGFja2V0LnB0cywgJyAnKTtcbiAgICAgICAgICB0aGlzLmNvbHVtbl8rKztcblxuICAgICAgICAgIGlmICgoY2hhcjEgJiAweGUpID09PSAweGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRm9ybWF0dGluZyhwYWNrZXQucHRzLCBbJ2knXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKChjaGFyMSAmIDB4MSkgPT09IDB4MSkge1xuICAgICAgICAgICAgdGhpcy5hZGRGb3JtYXR0aW5nKHBhY2tldC5wdHMsIFsndSddKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZXRlY3Qgb2Zmc2V0IGNvbnRyb2wgY29kZXMgYW5kIGFkanVzdCBjdXJzb3JcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzT2Zmc2V0Q29udHJvbENvZGUoY2hhcjAsIGNoYXIxKSkge1xuICAgICAgICAgIC8vIEN1cnNvciBwb3NpdGlvbiBpcyBzZXQgYnkgaW5kZW50IFBBQyAoc2VlIGJlbG93KSBpbiA0LWNvbHVtblxuICAgICAgICAgIC8vIGluY3JlbWVudHMsIHdpdGggYW4gYWRkaXRpb25hbCBvZmZzZXQgY29kZSBvZiAxLTMgdG8gcmVhY2ggYW55XG4gICAgICAgICAgLy8gb2YgdGhlIDMyIGNvbHVtbnMgc3BlY2lmaWVkIGJ5IENFQS02MDguIFNvIGFsbCB3ZSBuZWVkIHRvIGRvXG4gICAgICAgICAgLy8gaGVyZSBpcyBpbmNyZW1lbnQgdGhlIGNvbHVtbiBjdXJzb3IgYnkgdGhlIGdpdmVuIG9mZnNldC5cbiAgICAgICAgICB0aGlzLmNvbHVtbl8gKz0gY2hhcjEgJiAweDAzO1xuXG4gICAgICAgICAgLy8gRGV0ZWN0IFBBQ3MgKFByZWFtYmxlIEFkZHJlc3MgQ29kZXMpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1BBQyhjaGFyMCwgY2hhcjEpKSB7XG5cbiAgICAgICAgICAvLyBUaGVyZSdzIG5vIGxvZ2ljIGZvciBQQUMgLT4gcm93IG1hcHBpbmcsIHNvIHdlIGhhdmUgdG8ganVzdFxuICAgICAgICAgIC8vIGZpbmQgdGhlIHJvdyBjb2RlIGluIGFuIGFycmF5IGFuZCB1c2UgaXRzIGluZGV4IDooXG4gICAgICAgICAgdmFyIHJvdyA9IFJPV1MuaW5kZXhPZihkYXRhICYgMHgxZjIwKTtcblxuICAgICAgICAgIGlmIChyb3cgIT09IHRoaXMucm93Xykge1xuICAgICAgICAgICAgLy8gZm9ybWF0dGluZyBpcyBvbmx5IHBlcnNpc3RlbnQgZm9yIGN1cnJlbnQgcm93XG4gICAgICAgICAgICB0aGlzLmNsZWFyRm9ybWF0dGluZyhwYWNrZXQucHRzKTtcbiAgICAgICAgICAgIHRoaXMucm93XyA9IHJvdztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQWxsIFBBQ3MgY2FuIGFwcGx5IHVuZGVybGluZSwgc28gZGV0ZWN0IGFuZCBhcHBseVxuICAgICAgICAgIC8vIChBbGwgb2RkLW51bWJlcmVkIHNlY29uZCBieXRlcyBzZXQgdW5kZXJsaW5lKVxuICAgICAgICAgIGlmIChjaGFyMSAmIDB4MSAmJiB0aGlzLmZvcm1hdHRpbmdfLmluZGV4T2YoJ3UnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRm9ybWF0dGluZyhwYWNrZXQucHRzLCBbJ3UnXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKChkYXRhICYgMHgxMCkgPT09IDB4MTApIHtcbiAgICAgICAgICAgIC8vIFdlJ3ZlIGdvdCBhbiBpbmRlbnQgbGV2ZWwgY29kZS4gRWFjaCBzdWNjZXNzaXZlIGV2ZW4gbnVtYmVyXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnRzIHRoZSBjb2x1bW4gY3Vyc29yIGJ5IDQsIHNvIHdlIGNhbiBnZXQgdGhlIGRlc2lyZWRcbiAgICAgICAgICAgIC8vIGNvbHVtbiBwb3NpdGlvbiBieSBiaXQtc2hpZnRpbmcgdG8gdGhlIHJpZ2h0ICh0byBnZXQgbi8yKVxuICAgICAgICAgICAgLy8gYW5kIG11bHRpcGx5aW5nIGJ5IDQuXG4gICAgICAgICAgICB0aGlzLmNvbHVtbl8gPSAoKGRhdGEgJiAweGUpID4+IDEpICogNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5pc0NvbG9yUEFDKGNoYXIxKSkge1xuICAgICAgICAgICAgLy8gaXQncyBhIGNvbG9yIGNvZGUsIHRob3VnaCB3ZSBvbmx5IHN1cHBvcnQgd2hpdGUsIHdoaWNoXG4gICAgICAgICAgICAvLyBjYW4gYmUgZWl0aGVyIG5vcm1hbCBvciBpdGFsaWNpemVkLiB3aGl0ZSBpdGFsaWNzIGNhbiBiZVxuICAgICAgICAgICAgLy8gZWl0aGVyIDB4NGUgb3IgMHg2ZSBkZXBlbmRpbmcgb24gdGhlIHJvdywgc28gd2UganVzdFxuICAgICAgICAgICAgLy8gYml0d2lzZS1hbmQgd2l0aCAweGUgdG8gc2VlIGlmIGl0YWxpY3Mgc2hvdWxkIGJlIHR1cm5lZCBvblxuICAgICAgICAgICAgaWYgKChjaGFyMSAmIDB4ZSkgPT09IDB4ZSkge1xuICAgICAgICAgICAgICB0aGlzLmFkZEZvcm1hdHRpbmcocGFja2V0LnB0cywgWydpJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdlIGhhdmUgYSBub3JtYWwgY2hhcmFjdGVyIGluIGNoYXIwLCBhbmQgcG9zc2libHkgb25lIGluIGNoYXIxXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc05vcm1hbENoYXIoY2hhcjApKSB7XG4gICAgICAgICAgaWYgKGNoYXIxID09PSAweDAwKSB7XG4gICAgICAgICAgICBjaGFyMSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHQgPSBnZXRDaGFyRnJvbUNvZGUoY2hhcjApO1xuICAgICAgICAgIHRleHQgKz0gZ2V0Q2hhckZyb21Db2RlKGNoYXIxKTtcbiAgICAgICAgICB0aGlzW3RoaXMubW9kZV9dKHBhY2tldC5wdHMsIHRleHQpO1xuICAgICAgICAgIHRoaXMuY29sdW1uXyArPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgfSAvLyBmaW5pc2ggZGF0YSBwcm9jZXNzaW5nXG4gICAgICB9O1xuICAgIH07XG4gICAgQ2VhNjA4U3RyZWFtLnByb3RvdHlwZSA9IG5ldyBzdHJlYW0oKTtcbiAgICAvLyBUcmlnZ2VyIGEgY3VlIHBvaW50IHRoYXQgY2FwdHVyZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlXG4gICAgLy8gZGlzcGxheSBidWZmZXJcbiAgICBDZWE2MDhTdHJlYW0ucHJvdG90eXBlLmZsdXNoRGlzcGxheWVkID0gZnVuY3Rpb24gKHB0cykge1xuICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmRpc3BsYXllZF9cbiAgICAgIC8vIHJlbW92ZSBzcGFjZXMgZnJvbSB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgc3RyaW5nXG4gICAgICAubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIHJvdy50cmltKCk7XG4gICAgICB9KVxuICAgICAgLy8gY29tYmluZSBhbGwgdGV4dCByb3dzIHRvIGRpc3BsYXkgaW4gb25lIGN1ZVxuICAgICAgLmpvaW4oJ1xcbicpXG4gICAgICAvLyBhbmQgcmVtb3ZlIGJsYW5rIHJvd3MgZnJvbSB0aGUgc3RhcnQgYW5kIGVuZCwgYnV0IG5vdCB0aGUgbWlkZGxlXG4gICAgICAucmVwbGFjZSgvXlxcbit8XFxuKyQvZywgJycpO1xuXG4gICAgICBpZiAoY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywge1xuICAgICAgICAgIHN0YXJ0UHRzOiB0aGlzLnN0YXJ0UHRzXyxcbiAgICAgICAgICBlbmRQdHM6IHB0cyxcbiAgICAgICAgICB0ZXh0OiBjb250ZW50LFxuICAgICAgICAgIHN0cmVhbTogdGhpcy5uYW1lX1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogWmVybyBvdXQgdGhlIGRhdGEsIHVzZWQgZm9yIHN0YXJ0dXAgYW5kIG9uIHNlZWtcbiAgICAgKi9cbiAgICBDZWE2MDhTdHJlYW0ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tb2RlXyA9ICdwb3BPbic7XG4gICAgICAvLyBXaGVuIGluIHJvbGwtdXAgbW9kZSwgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHJvdyB0aGF0IHdpbGxcbiAgICAgIC8vIGFjdHVhbGx5IGRpc3BsYXkgY2FwdGlvbnMuIElmIGEgY2FwdGlvbiBpcyBzaGlmdGVkIHRvIGEgcm93XG4gICAgICAvLyB3aXRoIGEgbG93ZXIgaW5kZXggdGhhbiB0aGlzLCBpdCBpcyBjbGVhcmVkIGZyb20gdGhlIGRpc3BsYXlcbiAgICAgIC8vIGJ1ZmZlclxuICAgICAgdGhpcy50b3BSb3dfID0gMDtcbiAgICAgIHRoaXMuc3RhcnRQdHNfID0gMDtcbiAgICAgIHRoaXMuZGlzcGxheWVkXyA9IGNyZWF0ZURpc3BsYXlCdWZmZXIoKTtcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkXyA9IGNyZWF0ZURpc3BsYXlCdWZmZXIoKTtcbiAgICAgIHRoaXMubGFzdENvbnRyb2xDb2RlXyA9IG51bGw7XG5cbiAgICAgIC8vIFRyYWNrIHJvdyBhbmQgY29sdW1uIGZvciBwcm9wZXIgbGluZS1icmVha2luZyBhbmQgc3BhY2luZ1xuICAgICAgdGhpcy5jb2x1bW5fID0gMDtcbiAgICAgIHRoaXMucm93XyA9IEJPVFRPTV9ST1c7XG5cbiAgICAgIC8vIFRoaXMgdmFyaWFibGUgaG9sZHMgY3VycmVudGx5LWFwcGxpZWQgZm9ybWF0dGluZ1xuICAgICAgdGhpcy5mb3JtYXR0aW5nXyA9IFtdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGNvbnRyb2wgY29kZSBhbmQgcmVsYXRlZCBjb25zdGFudHMgZm9yIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBDZWE2MDhTdHJlYW0ucHJvdG90eXBlLnNldENvbnN0YW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcyBoYXZlIHRoZXNlIHVzZXM6XG4gICAgICAvLyBleHRfIDogICAgY2hhcjAgZm9yIG1pZC1yb3cgY29kZXMsIGFuZCB0aGUgYmFzZSBmb3IgZXh0ZW5kZWRcbiAgICAgIC8vICAgICAgICAgICBjaGFycyAoZXh0XyswLCBleHRfKzEsIGFuZCBleHRfKzIgYXJlIGNoYXIwcyBmb3JcbiAgICAgIC8vICAgICAgICAgICBleHRlbmRlZCBjb2RlcylcbiAgICAgIC8vIGNvbnRyb2xfOiBjaGFyMCBmb3IgY29udHJvbCBjb2RlcywgZXhjZXB0IGJ5dGUtc2hpZnRlZCB0byB0aGVcbiAgICAgIC8vICAgICAgICAgICBsZWZ0IHNvIHRoYXQgd2UgY2FuIGRvIHRoaXMuY29udHJvbF8gfCBDT05UUk9MX0NPREVcbiAgICAgIC8vIG9mZnNldF86ICBjaGFyMCBmb3IgdGFiIG9mZnNldCBjb2Rlc1xuICAgICAgLy9cbiAgICAgIC8vIEl0J3MgYWxzbyB3b3J0aCBub3RpbmcgdGhhdCBjb250cm9sIGNvZGVzLCBhbmQgX29ubHlfIGNvbnRyb2wgY29kZXMsXG4gICAgICAvLyBkaWZmZXIgYmV0d2VlbiBmaWVsZCAxIGFuZCBmaWVsZDIuIEZpZWxkIDIgY29udHJvbCBjb2RlcyBhcmUgYWx3YXlzXG4gICAgICAvLyB0aGVpciBmaWVsZCAxIHZhbHVlIHBsdXMgMS4gVGhhdCdzIHdoeSB0aGVyZSdzIHRoZSBcInwgZmllbGRcIiBvbiB0aGVcbiAgICAgIC8vIGNvbnRyb2wgdmFsdWUuXG4gICAgICBpZiAodGhpcy5kYXRhQ2hhbm5lbF8gPT09IDApIHtcbiAgICAgICAgdGhpcy5CQVNFXyA9IDB4MTA7XG4gICAgICAgIHRoaXMuRVhUXyA9IDB4MTE7XG4gICAgICAgIHRoaXMuQ09OVFJPTF8gPSAoMHgxNCB8IHRoaXMuZmllbGRfKSA8PCA4O1xuICAgICAgICB0aGlzLk9GRlNFVF8gPSAweDE3O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFDaGFubmVsXyA9PT0gMSkge1xuICAgICAgICB0aGlzLkJBU0VfID0gMHgxODtcbiAgICAgICAgdGhpcy5FWFRfID0gMHgxOTtcbiAgICAgICAgdGhpcy5DT05UUk9MXyA9ICgweDFjIHwgdGhpcy5maWVsZF8pIDw8IDg7XG4gICAgICAgIHRoaXMuT0ZGU0VUXyA9IDB4MWY7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnN0YW50cyBmb3IgdGhlIExTQnl0ZSBjb21tYW5kIGNvZGVzIHJlY29nbml6ZWQgYnkgQ2VhNjA4U3RyZWFtLiBUaGlzXG4gICAgICAvLyBsaXN0IGlzIG5vdCBleGhhdXN0aXZlLiBGb3IgYSBtb3JlIGNvbXByZWhlbnNpdmUgbGlzdGluZyBhbmQgc2VtYW50aWNzIHNlZVxuICAgICAgLy8gaHR0cDovL3d3dy5ncG8uZ292L2Zkc3lzL3BrZy9DRlItMjAxMC10aXRsZTQ3LXZvbDEvcGRmL0NGUi0yMDEwLXRpdGxlNDctdm9sMS1zZWMxNS0xMTkucGRmXG4gICAgICAvLyBQYWRkaW5nXG4gICAgICB0aGlzLlBBRERJTkdfID0gMHgwMDAwO1xuICAgICAgLy8gUG9wLW9uIE1vZGVcbiAgICAgIHRoaXMuUkVTVU1FX0NBUFRJT05fTE9BRElOR18gPSB0aGlzLkNPTlRST0xfIHwgMHgyMDtcbiAgICAgIHRoaXMuRU5EX09GX0NBUFRJT05fID0gdGhpcy5DT05UUk9MXyB8IDB4MmY7XG4gICAgICAvLyBSb2xsLXVwIE1vZGVcbiAgICAgIHRoaXMuUk9MTF9VUF8yX1JPV1NfID0gdGhpcy5DT05UUk9MXyB8IDB4MjU7XG4gICAgICB0aGlzLlJPTExfVVBfM19ST1dTXyA9IHRoaXMuQ09OVFJPTF8gfCAweDI2O1xuICAgICAgdGhpcy5ST0xMX1VQXzRfUk9XU18gPSB0aGlzLkNPTlRST0xfIHwgMHgyNztcbiAgICAgIHRoaXMuQ0FSUklBR0VfUkVUVVJOXyA9IHRoaXMuQ09OVFJPTF8gfCAweDJkO1xuICAgICAgLy8gcGFpbnQtb24gbW9kZSAobm90IHN1cHBvcnRlZClcbiAgICAgIHRoaXMuUkVTVU1FX0RJUkVDVF9DQVBUSU9OSU5HXyA9IHRoaXMuQ09OVFJPTF8gfCAweDI5O1xuICAgICAgLy8gRXJhc3VyZVxuICAgICAgdGhpcy5CQUNLU1BBQ0VfID0gdGhpcy5DT05UUk9MXyB8IDB4MjE7XG4gICAgICB0aGlzLkVSQVNFX0RJU1BMQVlFRF9NRU1PUllfID0gdGhpcy5DT05UUk9MXyB8IDB4MmM7XG4gICAgICB0aGlzLkVSQVNFX05PTl9ESVNQTEFZRURfTUVNT1JZXyA9IHRoaXMuQ09OVFJPTF8gfCAweDJlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIGlmIHRoZSAyLWJ5dGUgcGFja2V0IGRhdGEgaXMgYSBzcGVjaWFsIGNoYXJhY3RlclxuICAgICAqXG4gICAgICogU3BlY2lhbCBjaGFyYWN0ZXJzIGhhdmUgYSBzZWNvbmQgYnl0ZSBpbiB0aGUgcmFuZ2UgMHgzMCB0byAweDNmLFxuICAgICAqIHdpdGggdGhlIGZpcnN0IGJ5dGUgYmVpbmcgMHgxMSAoZm9yIGRhdGEgY2hhbm5lbCAxKSBvciAweDE5IChmb3JcbiAgICAgKiBkYXRhIGNoYW5uZWwgMikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtJbnRlZ2VyfSBjaGFyMCBUaGUgZmlyc3QgYnl0ZVxuICAgICAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIxIFRoZSBzZWNvbmQgYnl0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgIFdoZXRoZXIgdGhlIDIgYnl0ZXMgYXJlIGFuIHNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICovXG4gICAgQ2VhNjA4U3RyZWFtLnByb3RvdHlwZS5pc1NwZWNpYWxDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY2hhcjAsIGNoYXIxKSB7XG4gICAgICByZXR1cm4gY2hhcjAgPT09IHRoaXMuRVhUXyAmJiBjaGFyMSA+PSAweDMwICYmIGNoYXIxIDw9IDB4M2Y7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdHMgaWYgdGhlIDItYnl0ZSBwYWNrZXQgZGF0YSBpcyBhbiBleHRlbmRlZCBjaGFyYWN0ZXJcbiAgICAgKlxuICAgICAqIEV4dGVuZGVkIGNoYXJhY3RlcnMgaGF2ZSBhIHNlY29uZCBieXRlIGluIHRoZSByYW5nZSAweDIwIHRvIDB4M2YsXG4gICAgICogd2l0aCB0aGUgZmlyc3QgYnl0ZSBiZWluZyAweDEyIG9yIDB4MTMgKGZvciBkYXRhIGNoYW5uZWwgMSkgb3JcbiAgICAgKiAweDFhIG9yIDB4MWIgKGZvciBkYXRhIGNoYW5uZWwgMikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtJbnRlZ2VyfSBjaGFyMCBUaGUgZmlyc3QgYnl0ZVxuICAgICAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIxIFRoZSBzZWNvbmQgYnl0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgIFdoZXRoZXIgdGhlIDIgYnl0ZXMgYXJlIGFuIGV4dGVuZGVkIGNoYXJhY3RlclxuICAgICAqL1xuICAgIENlYTYwOFN0cmVhbS5wcm90b3R5cGUuaXNFeHRDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY2hhcjAsIGNoYXIxKSB7XG4gICAgICByZXR1cm4gKGNoYXIwID09PSB0aGlzLkVYVF8gKyAxIHx8IGNoYXIwID09PSB0aGlzLkVYVF8gKyAyKSAmJiBjaGFyMSA+PSAweDIwICYmIGNoYXIxIDw9IDB4M2Y7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdHMgaWYgdGhlIDItYnl0ZSBwYWNrZXQgaXMgYSBtaWQtcm93IGNvZGVcbiAgICAgKlxuICAgICAqIE1pZC1yb3cgY29kZXMgaGF2ZSBhIHNlY29uZCBieXRlIGluIHRoZSByYW5nZSAweDIwIHRvIDB4MmYsIHdpdGhcbiAgICAgKiB0aGUgZmlyc3QgYnl0ZSBiZWluZyAweDExIChmb3IgZGF0YSBjaGFubmVsIDEpIG9yIDB4MTkgKGZvciBkYXRhXG4gICAgICogY2hhbm5lbCAyKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIwIFRoZSBmaXJzdCBieXRlXG4gICAgICogQHBhcmFtICB7SW50ZWdlcn0gY2hhcjEgVGhlIHNlY29uZCBieXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgV2hldGhlciB0aGUgMiBieXRlcyBhcmUgYSBtaWQtcm93IGNvZGVcbiAgICAgKi9cbiAgICBDZWE2MDhTdHJlYW0ucHJvdG90eXBlLmlzTWlkUm93Q29kZSA9IGZ1bmN0aW9uIChjaGFyMCwgY2hhcjEpIHtcbiAgICAgIHJldHVybiBjaGFyMCA9PT0gdGhpcy5FWFRfICYmIGNoYXIxID49IDB4MjAgJiYgY2hhcjEgPD0gMHgyZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyBpZiB0aGUgMi1ieXRlIHBhY2tldCBpcyBhbiBvZmZzZXQgY29udHJvbCBjb2RlXG4gICAgICpcbiAgICAgKiBPZmZzZXQgY29udHJvbCBjb2RlcyBoYXZlIGEgc2Vjb25kIGJ5dGUgaW4gdGhlIHJhbmdlIDB4MjEgdG8gMHgyMyxcbiAgICAgKiB3aXRoIHRoZSBmaXJzdCBieXRlIGJlaW5nIDB4MTcgKGZvciBkYXRhIGNoYW5uZWwgMSkgb3IgMHgxZiAoZm9yXG4gICAgICogZGF0YSBjaGFubmVsIDIpLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7SW50ZWdlcn0gY2hhcjAgVGhlIGZpcnN0IGJ5dGVcbiAgICAgKiBAcGFyYW0gIHtJbnRlZ2VyfSBjaGFyMSBUaGUgc2Vjb25kIGJ5dGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICBXaGV0aGVyIHRoZSAyIGJ5dGVzIGFyZSBhbiBvZmZzZXQgY29udHJvbCBjb2RlXG4gICAgICovXG4gICAgQ2VhNjA4U3RyZWFtLnByb3RvdHlwZS5pc09mZnNldENvbnRyb2xDb2RlID0gZnVuY3Rpb24gKGNoYXIwLCBjaGFyMSkge1xuICAgICAgcmV0dXJuIGNoYXIwID09PSB0aGlzLk9GRlNFVF8gJiYgY2hhcjEgPj0gMHgyMSAmJiBjaGFyMSA8PSAweDIzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIGlmIHRoZSAyLWJ5dGUgcGFja2V0IGlzIGEgUHJlYW1ibGUgQWRkcmVzcyBDb2RlXG4gICAgICpcbiAgICAgKiBQQUNzIGhhdmUgYSBmaXJzdCBieXRlIGluIHRoZSByYW5nZSAweDEwIHRvIDB4MTcgKGZvciBkYXRhIGNoYW5uZWwgMSlcbiAgICAgKiBvciAweDE4IHRvIDB4MWYgKGZvciBkYXRhIGNoYW5uZWwgMiksIHdpdGggdGhlIHNlY29uZCBieXRlIGluIHRoZVxuICAgICAqIHJhbmdlIDB4NDAgdG8gMHg3Zi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIwIFRoZSBmaXJzdCBieXRlXG4gICAgICogQHBhcmFtICB7SW50ZWdlcn0gY2hhcjEgVGhlIHNlY29uZCBieXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgV2hldGhlciB0aGUgMiBieXRlcyBhcmUgYSBQQUNcbiAgICAgKi9cbiAgICBDZWE2MDhTdHJlYW0ucHJvdG90eXBlLmlzUEFDID0gZnVuY3Rpb24gKGNoYXIwLCBjaGFyMSkge1xuICAgICAgcmV0dXJuIGNoYXIwID49IHRoaXMuQkFTRV8gJiYgY2hhcjAgPCB0aGlzLkJBU0VfICsgOCAmJiBjaGFyMSA+PSAweDQwICYmIGNoYXIxIDw9IDB4N2Y7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdHMgaWYgYSBwYWNrZXQncyBzZWNvbmQgYnl0ZSBpcyBpbiB0aGUgcmFuZ2Ugb2YgYSBQQUMgY29sb3IgY29kZVxuICAgICAqXG4gICAgICogUEFDIGNvbG9yIGNvZGVzIGhhdmUgdGhlIHNlY29uZCBieXRlIGJlIGluIHRoZSByYW5nZSAweDQwIHRvIDB4NGYsIG9yXG4gICAgICogMHg2MCB0byAweDZmLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7SW50ZWdlcn0gY2hhcjEgVGhlIHNlY29uZCBieXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgV2hldGhlciB0aGUgYnl0ZSBpcyBhIGNvbG9yIFBBQ1xuICAgICAqL1xuICAgIENlYTYwOFN0cmVhbS5wcm90b3R5cGUuaXNDb2xvclBBQyA9IGZ1bmN0aW9uIChjaGFyMSkge1xuICAgICAgcmV0dXJuIGNoYXIxID49IDB4NDAgJiYgY2hhcjEgPD0gMHg0ZiB8fCBjaGFyMSA+PSAweDYwICYmIGNoYXIxIDw9IDB4N2Y7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdHMgaWYgYSBzaW5nbGUgYnl0ZSBpcyBpbiB0aGUgcmFuZ2Ugb2YgYSBub3JtYWwgY2hhcmFjdGVyXG4gICAgICpcbiAgICAgKiBOb3JtYWwgdGV4dCBieXRlcyBhcmUgaW4gdGhlIHJhbmdlIDB4MjAgdG8gMHg3Zi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIgIFRoZSBieXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgV2hldGhlciB0aGUgYnl0ZSBpcyBhIG5vcm1hbCBjaGFyYWN0ZXJcbiAgICAgKi9cbiAgICBDZWE2MDhTdHJlYW0ucHJvdG90eXBlLmlzTm9ybWFsQ2hhciA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICByZXR1cm4gY2hhciA+PSAweDIwICYmIGNoYXIgPD0gMHg3ZjtcbiAgICB9O1xuXG4gICAgLy8gQWRkcyB0aGUgb3BlbmluZyBIVE1MIHRhZyBmb3IgdGhlIHBhc3NlZCBjaGFyYWN0ZXIgdG8gdGhlIGNhcHRpb24gdGV4dCxcbiAgICAvLyBhbmQga2VlcHMgdHJhY2sgb2YgaXQgZm9yIGxhdGVyIGNsb3NpbmdcbiAgICBDZWE2MDhTdHJlYW0ucHJvdG90eXBlLmFkZEZvcm1hdHRpbmcgPSBmdW5jdGlvbiAocHRzLCBmb3JtYXQpIHtcbiAgICAgIHRoaXMuZm9ybWF0dGluZ18gPSB0aGlzLmZvcm1hdHRpbmdfLmNvbmNhdChmb3JtYXQpO1xuICAgICAgdmFyIHRleHQgPSBmb3JtYXQucmVkdWNlKGZ1bmN0aW9uICh0ZXh0LCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQgKyAnPCcgKyBmb3JtYXQgKyAnPic7XG4gICAgICB9LCAnJyk7XG4gICAgICB0aGlzW3RoaXMubW9kZV9dKHB0cywgdGV4dCk7XG4gICAgfTtcblxuICAgIC8vIEFkZHMgSFRNTCBjbG9zaW5nIHRhZ3MgZm9yIGN1cnJlbnQgZm9ybWF0dGluZyB0byBjYXB0aW9uIHRleHQgYW5kXG4gICAgLy8gY2xlYXJzIHJlbWVtYmVyZWQgZm9ybWF0dGluZ1xuICAgIENlYTYwOFN0cmVhbS5wcm90b3R5cGUuY2xlYXJGb3JtYXR0aW5nID0gZnVuY3Rpb24gKHB0cykge1xuICAgICAgaWYgKCF0aGlzLmZvcm1hdHRpbmdfLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdGV4dCA9IHRoaXMuZm9ybWF0dGluZ18ucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAodGV4dCwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0ICsgJzwvJyArIGZvcm1hdCArICc+JztcbiAgICAgIH0sICcnKTtcbiAgICAgIHRoaXMuZm9ybWF0dGluZ18gPSBbXTtcbiAgICAgIHRoaXNbdGhpcy5tb2RlX10ocHRzLCB0ZXh0KTtcbiAgICB9O1xuXG4gICAgLy8gTW9kZSBJbXBsZW1lbnRhdGlvbnNcbiAgICBDZWE2MDhTdHJlYW0ucHJvdG90eXBlLnBvcE9uID0gZnVuY3Rpb24gKHB0cywgdGV4dCkge1xuICAgICAgdmFyIGJhc2VSb3cgPSB0aGlzLm5vbkRpc3BsYXllZF9bdGhpcy5yb3dfXTtcblxuICAgICAgLy8gYnVmZmVyIGNoYXJhY3RlcnNcbiAgICAgIGJhc2VSb3cgKz0gdGV4dDtcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkX1t0aGlzLnJvd19dID0gYmFzZVJvdztcbiAgICB9O1xuXG4gICAgQ2VhNjA4U3RyZWFtLnByb3RvdHlwZS5yb2xsVXAgPSBmdW5jdGlvbiAocHRzLCB0ZXh0KSB7XG4gICAgICB2YXIgYmFzZVJvdyA9IHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXTtcblxuICAgICAgYmFzZVJvdyArPSB0ZXh0O1xuICAgICAgdGhpcy5kaXNwbGF5ZWRfW0JPVFRPTV9ST1ddID0gYmFzZVJvdztcbiAgICB9O1xuXG4gICAgQ2VhNjA4U3RyZWFtLnByb3RvdHlwZS5zaGlmdFJvd3NVcF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIC8vIGNsZWFyIG91dCBpbmFjdGl2ZSByb3dzXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b3BSb3dfOyBpKyspIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRfW2ldID0gJyc7XG4gICAgICB9XG4gICAgICAvLyBzaGlmdCBkaXNwbGF5ZWQgcm93cyB1cFxuICAgICAgZm9yIChpID0gdGhpcy50b3BSb3dfOyBpIDwgQk9UVE9NX1JPVzsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkX1tpXSA9IHRoaXMuZGlzcGxheWVkX1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBjbGVhciBvdXQgdGhlIGJvdHRvbSByb3dcbiAgICAgIHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXSA9ICcnO1xuICAgIH07XG5cbiAgICAvLyBwYWludE9uIG1vZGUgaXMgbm90IGltcGxlbWVudGVkXG4gICAgQ2VhNjA4U3RyZWFtLnByb3RvdHlwZS5wYWludE9uID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBleHBvcnRzXG4gICAgdmFyIGNhcHRpb25TdHJlYW0gPSB7XG4gICAgICBDYXB0aW9uU3RyZWFtOiBDYXB0aW9uU3RyZWFtLFxuICAgICAgQ2VhNjA4U3RyZWFtOiBDZWE2MDhTdHJlYW1cbiAgICB9O1xuXG4gICAgdmFyIHN0cmVhbVR5cGVzID0ge1xuICAgICAgSDI2NF9TVFJFQU1fVFlQRTogMHgxQixcbiAgICAgIEFEVFNfU1RSRUFNX1RZUEU6IDB4MEYsXG4gICAgICBNRVRBREFUQV9TVFJFQU1fVFlQRTogMHgxNVxuICAgIH07XG5cbiAgICB2YXIgTUFYX1RTID0gODU4OTkzNDU5MjtcblxuICAgIHZhciBST19USFJFU0ggPSA0Mjk0OTY3Mjk2O1xuXG4gICAgdmFyIGhhbmRsZVJvbGxvdmVyID0gZnVuY3Rpb24gaGFuZGxlUm9sbG92ZXIodmFsdWUsIHJlZmVyZW5jZSkge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IDE7XG5cbiAgICAgIGlmICh2YWx1ZSA+IHJlZmVyZW5jZSkge1xuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCB0aW1lc3RhbXAgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG91ciByZWZlcmVuY2UgdGltZXN0YW1wIGFuZCB3ZSBkZXRlY3QgYVxuICAgICAgICAvLyB0aW1lc3RhbXAgcm9sbG92ZXIsIHRoaXMgbWVhbnMgdGhlIHJvbGwgb3ZlciBpcyBoYXBwZW5pbmcgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi5cbiAgICAgICAgLy8gRXhhbXBsZSBzY2VuYXJpbzogRW50ZXIgYSBsb25nIHN0cmVhbS92aWRlbyBqdXN0IGFmdGVyIGEgcm9sbG92ZXIgb2NjdXJyZWQuIFRoZSByZWZlcmVuY2VcbiAgICAgICAgLy8gcG9pbnQgd2lsbCBiZSBzZXQgdG8gYSBzbWFsbCBudW1iZXIsIGUuZy4gMS4gVGhlIHVzZXIgdGhlbiBzZWVrcyBiYWNrd2FyZHMgb3ZlciB0aGVcbiAgICAgICAgLy8gcm9sbG92ZXIgcG9pbnQuIEluIGxvYWRpbmcgdGhpcyBzZWdtZW50LCB0aGUgdGltZXN0YW1wIHZhbHVlcyB3aWxsIGJlIHZlcnkgbGFyZ2UsXG4gICAgICAgIC8vIGUuZy4gMl4zMyAtIDEuIFNpbmNlIHRoaXMgY29tZXMgYmVmb3JlIHRoZSBkYXRhIHdlIGxvYWRlZCBwcmV2aW91c2x5LCB3ZSB3YW50IHRvIGFkanVzdFxuICAgICAgICAvLyB0aGUgdGltZSBzdGFtcCB0byBiZSBgdmFsdWUgLSAyXjMzYC5cbiAgICAgICAgZGlyZWN0aW9uID0gLTE7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdGU6IEEgc2VlayBmb3J3YXJkcyBvciBiYWNrIHRoYXQgaXMgZ3JlYXRlciB0aGFuIHRoZSBST19USFJFU0ggKDJeMzIsIH4xMyBob3Vycykgd2lsbFxuICAgICAgLy8gY2F1c2UgYW4gaW5jb3JyZWN0IGFkanVzdG1lbnQuXG4gICAgICB3aGlsZSAoTWF0aC5hYnMocmVmZXJlbmNlIC0gdmFsdWUpID4gUk9fVEhSRVNIKSB7XG4gICAgICAgIHZhbHVlICs9IGRpcmVjdGlvbiAqIE1BWF9UUztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICB2YXIgVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0gPSBmdW5jdGlvbiBUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSh0eXBlKSB7XG4gICAgICB2YXIgbGFzdERUUywgcmVmZXJlbmNlRFRTO1xuXG4gICAgICBUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLnR5cGVfID0gdHlwZTtcblxuICAgICAgdGhpcy5wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEudHlwZSAhPT0gdGhpcy50eXBlXykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWZlcmVuY2VEVFMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlZmVyZW5jZURUUyA9IGRhdGEuZHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5kdHMgPSBoYW5kbGVSb2xsb3ZlcihkYXRhLmR0cywgcmVmZXJlbmNlRFRTKTtcbiAgICAgICAgZGF0YS5wdHMgPSBoYW5kbGVSb2xsb3ZlcihkYXRhLnB0cywgcmVmZXJlbmNlRFRTKTtcblxuICAgICAgICBsYXN0RFRTID0gZGF0YS5kdHM7XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZGF0YSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZWZlcmVuY2VEVFMgPSBsYXN0RFRTO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZGlzY29udGludWl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVmZXJlbmNlRFRTID0gdm9pZCAwO1xuICAgICAgICBsYXN0RFRTID0gdm9pZCAwO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0ucHJvdG90eXBlID0gbmV3IHN0cmVhbSgpO1xuXG4gICAgdmFyIHRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtID0ge1xuICAgICAgVGltZXN0YW1wUm9sbG92ZXJTdHJlYW06IFRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtLFxuICAgICAgaGFuZGxlUm9sbG92ZXI6IGhhbmRsZVJvbGxvdmVyXG4gICAgfTtcblxuICAgIHZhciBwZXJjZW50RW5jb2RlID0gZnVuY3Rpb24gcGVyY2VudEVuY29kZShieXRlcywgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSAnJScgKyAoJzAwJyArIGJ5dGVzW2ldLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG5cbiAgICAvLyByZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGJ5dGUgcmFuZ2UsXG4gICAgLy8gaW50ZXJwcmV0ZWQgYXMgVVRmLTguXG4gICAgcGFyc2VVdGY4ID0gZnVuY3Rpb24gcGFyc2VVdGY4KGJ5dGVzLCBzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBlcmNlbnRFbmNvZGUoYnl0ZXMsIHN0YXJ0LCBlbmQpKTtcbiAgICB9LFxuXG5cbiAgICAvLyByZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGJ5dGUgcmFuZ2UsXG4gICAgLy8gaW50ZXJwcmV0ZWQgYXMgSVNPLTg4NTktMS5cbiAgICBwYXJzZUlzbzg4NTkxID0gZnVuY3Rpb24gcGFyc2VJc284ODU5MShieXRlcywgc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIHVuZXNjYXBlKHBlcmNlbnRFbmNvZGUoYnl0ZXMsIHN0YXJ0LCBlbmQpKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgfSxcbiAgICAgICAgcGFyc2VTeW5jU2FmZUludGVnZXIgPSBmdW5jdGlvbiBwYXJzZVN5bmNTYWZlSW50ZWdlcihkYXRhKSB7XG4gICAgICByZXR1cm4gZGF0YVswXSA8PCAyMSB8IGRhdGFbMV0gPDwgMTQgfCBkYXRhWzJdIDw8IDcgfCBkYXRhWzNdO1xuICAgIH0sXG4gICAgICAgIHRhZ1BhcnNlcnMgPSB7XG4gICAgICBUWFhYOiBmdW5jdGlvbiBUWFhYKHRhZykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKHRhZy5kYXRhWzBdICE9PSAzKSB7XG4gICAgICAgICAgLy8gaWdub3JlIGZyYW1lcyB3aXRoIHVucmVjb2duaXplZCBjaGFyYWN0ZXIgZW5jb2RpbmdzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHRhZy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRhZy5kYXRhW2ldID09PSAwKSB7XG4gICAgICAgICAgICAvLyBwYXJzZSB0aGUgdGV4dCBmaWVsZHNcbiAgICAgICAgICAgIHRhZy5kZXNjcmlwdGlvbiA9IHBhcnNlVXRmOCh0YWcuZGF0YSwgMSwgaSk7XG4gICAgICAgICAgICAvLyBkbyBub3QgaW5jbHVkZSB0aGUgbnVsbCB0ZXJtaW5hdG9yIGluIHRoZSB0YWcgdmFsdWVcbiAgICAgICAgICAgIHRhZy52YWx1ZSA9IHBhcnNlVXRmOCh0YWcuZGF0YSwgaSArIDEsIHRhZy5kYXRhLmxlbmd0aCkucmVwbGFjZSgvXFwwKiQvLCAnJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGFnLmRhdGEgPSB0YWcudmFsdWU7XG4gICAgICB9LFxuICAgICAgV1hYWDogZnVuY3Rpb24gV1hYWCh0YWcpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmICh0YWcuZGF0YVswXSAhPT0gMykge1xuICAgICAgICAgIC8vIGlnbm9yZSBmcmFtZXMgd2l0aCB1bnJlY29nbml6ZWQgY2hhcmFjdGVyIGVuY29kaW5nc1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCB0YWcuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0YWcuZGF0YVtpXSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gcGFyc2UgdGhlIGRlc2NyaXB0aW9uIGFuZCBVUkwgZmllbGRzXG4gICAgICAgICAgICB0YWcuZGVzY3JpcHRpb24gPSBwYXJzZVV0ZjgodGFnLmRhdGEsIDEsIGkpO1xuICAgICAgICAgICAgdGFnLnVybCA9IHBhcnNlVXRmOCh0YWcuZGF0YSwgaSArIDEsIHRhZy5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBQUklWOiBmdW5jdGlvbiBQUklWKHRhZykge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFnLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGFnLmRhdGFbaV0gPT09IDApIHtcbiAgICAgICAgICAgIC8vIHBhcnNlIHRoZSBkZXNjcmlwdGlvbiBhbmQgVVJMIGZpZWxkc1xuICAgICAgICAgICAgdGFnLm93bmVyID0gcGFyc2VJc284ODU5MSh0YWcuZGF0YSwgMCwgaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGFnLnByaXZhdGVEYXRhID0gdGFnLmRhdGEuc3ViYXJyYXkoaSArIDEpO1xuICAgICAgICB0YWcuZGF0YSA9IHRhZy5wcml2YXRlRGF0YTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBfTWV0YWRhdGFTdHJlYW07XG5cbiAgICBfTWV0YWRhdGFTdHJlYW0gPSBmdW5jdGlvbiBNZXRhZGF0YVN0cmVhbShvcHRpb25zKSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgICAgIGRlYnVnOiAhIShvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpLFxuXG4gICAgICAgIC8vIHRoZSBieXRlcyBvZiB0aGUgcHJvZ3JhbS1sZXZlbCBkZXNjcmlwdG9yIGZpZWxkIGluIE1QMlRcbiAgICAgICAgLy8gc2VlIElTTy9JRUMgMTM4MTgtMToyMDEzIChFKSwgc2VjdGlvbiAyLjYgXCJQcm9ncmFtIGFuZFxuICAgICAgICAvLyBwcm9ncmFtIGVsZW1lbnQgZGVzY3JpcHRvcnNcIlxuICAgICAgICBkZXNjcmlwdG9yOiBvcHRpb25zICYmIG9wdGlvbnMuZGVzY3JpcHRvclxuICAgICAgfSxcblxuXG4gICAgICAvLyB0aGUgdG90YWwgc2l6ZSBpbiBieXRlcyBvZiB0aGUgSUQzIHRhZyBiZWluZyBwYXJzZWRcbiAgICAgIHRhZ1NpemUgPSAwLFxuXG5cbiAgICAgIC8vIHRhZyBkYXRhIHRoYXQgaXMgbm90IGNvbXBsZXRlIGVub3VnaCB0byBiZSBwYXJzZWRcbiAgICAgIGJ1ZmZlciA9IFtdLFxuXG5cbiAgICAgIC8vIHRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY3VycmVudGx5IGluIHRoZSBidWZmZXJcbiAgICAgIGJ1ZmZlclNpemUgPSAwLFxuICAgICAgICAgIGk7XG5cbiAgICAgIF9NZXRhZGF0YVN0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIHRleHQgdHJhY2sgaW4tYmFuZCBtZXRhZGF0YSB0cmFjayBkaXNwYXRjaCB0eXBlXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjc3RlcHMtdG8tZXhwb3NlLWEtbWVkaWEtcmVzb3VyY2Utc3BlY2lmaWMtdGV4dC10cmFja1xuICAgICAgdGhpcy5kaXNwYXRjaFR5cGUgPSBzdHJlYW1UeXBlcy5NRVRBREFUQV9TVFJFQU1fVFlQRS50b1N0cmluZygxNik7XG4gICAgICBpZiAoc2V0dGluZ3MuZGVzY3JpcHRvcikge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2V0dGluZ3MuZGVzY3JpcHRvci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUeXBlICs9ICgnMDAnICsgc2V0dGluZ3MuZGVzY3JpcHRvcltpXS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdmFyIHRhZywgZnJhbWVTdGFydCwgZnJhbWVTaXplLCBmcmFtZSwgaSwgZnJhbWVIZWFkZXI7XG4gICAgICAgIGlmIChjaHVuay50eXBlICE9PSAndGltZWQtbWV0YWRhdGEnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgZGF0YV9hbGlnbm1lbnRfaW5kaWNhdG9yIGlzIHNldCBpbiB0aGUgUEVTIGhlYWRlcixcbiAgICAgICAgLy8gd2UgbXVzdCBoYXZlIHRoZSBzdGFydCBvZiBhIG5ldyBJRDMgdGFnLiBBc3N1bWUgYW55dGhpbmdcbiAgICAgICAgLy8gcmVtYWluaW5nIGluIHRoZSBidWZmZXIgd2FzIG1hbGZvcm1lZCBhbmQgdGhyb3cgaXQgb3V0XG4gICAgICAgIGlmIChjaHVuay5kYXRhQWxpZ25tZW50SW5kaWNhdG9yKSB7XG4gICAgICAgICAgYnVmZmVyU2l6ZSA9IDA7XG4gICAgICAgICAgYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZ25vcmUgZXZlbnRzIHRoYXQgZG9uJ3QgbG9vayBsaWtlIElEMyBkYXRhXG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwICYmIChjaHVuay5kYXRhLmxlbmd0aCA8IDEwIHx8IGNodW5rLmRhdGFbMF0gIT09ICdJJy5jaGFyQ29kZUF0KDApIHx8IGNodW5rLmRhdGFbMV0gIT09ICdEJy5jaGFyQ29kZUF0KDApIHx8IGNodW5rLmRhdGFbMl0gIT09ICczJy5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWJ1Zykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTa2lwcGluZyB1bnJlY29nbml6ZWQgbWV0YWRhdGEgcGFja2V0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGlzIGNodW5rIHRvIHRoZSBkYXRhIHdlJ3ZlIGNvbGxlY3RlZCBzbyBmYXJcblxuICAgICAgICBidWZmZXIucHVzaChjaHVuayk7XG4gICAgICAgIGJ1ZmZlclNpemUgKz0gY2h1bmsuZGF0YS5ieXRlTGVuZ3RoO1xuXG4gICAgICAgIC8vIGdyYWIgdGhlIHNpemUgb2YgdGhlIGVudGlyZSBmcmFtZSBmcm9tIHRoZSBJRDMgaGVhZGVyXG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gdGhlIGZyYW1lIHNpemUgaXMgdHJhbnNtaXR0ZWQgYXMgYSAyOC1iaXQgaW50ZWdlciBpbiB0aGVcbiAgICAgICAgICAvLyBsYXN0IGZvdXIgYnl0ZXMgb2YgdGhlIElEMyBoZWFkZXIuXG4gICAgICAgICAgLy8gVGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIGVhY2ggYnl0ZSBpcyBkcm9wcGVkIGFuZCB0aGVcbiAgICAgICAgICAvLyByZXN1bHRzIGNvbmNhdGVuYXRlZCB0byByZWNvdmVyIHRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICAgICAgdGFnU2l6ZSA9IHBhcnNlU3luY1NhZmVJbnRlZ2VyKGNodW5rLmRhdGEuc3ViYXJyYXkoNiwgMTApKTtcblxuICAgICAgICAgIC8vIElEMyByZXBvcnRzIHRoZSB0YWcgc2l6ZSBleGNsdWRpbmcgdGhlIGhlYWRlciBidXQgaXQncyBtb3JlXG4gICAgICAgICAgLy8gY29udmVuaWVudCBmb3Igb3VyIGNvbXBhcmlzb25zIHRvIGluY2x1ZGUgaXRcbiAgICAgICAgICB0YWdTaXplICs9IDEwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIGVudGlyZSBmcmFtZSBoYXMgbm90IGFycml2ZWQsIHdhaXQgZm9yIG1vcmUgZGF0YVxuICAgICAgICBpZiAoYnVmZmVyU2l6ZSA8IHRhZ1NpemUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb2xsZWN0IHRoZSBlbnRpcmUgZnJhbWUgc28gaXQgY2FuIGJlIHBhcnNlZFxuICAgICAgICB0YWcgPSB7XG4gICAgICAgICAgZGF0YTogbmV3IFVpbnQ4QXJyYXkodGFnU2l6ZSksXG4gICAgICAgICAgZnJhbWVzOiBbXSxcbiAgICAgICAgICBwdHM6IGJ1ZmZlclswXS5wdHMsXG4gICAgICAgICAgZHRzOiBidWZmZXJbMF0uZHRzXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0YWdTaXplOykge1xuICAgICAgICAgIHRhZy5kYXRhLnNldChidWZmZXJbMF0uZGF0YS5zdWJhcnJheSgwLCB0YWdTaXplIC0gaSksIGkpO1xuICAgICAgICAgIGkgKz0gYnVmZmVyWzBdLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBidWZmZXJTaXplIC09IGJ1ZmZlclswXS5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgYnVmZmVyLnNoaWZ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIHRoZSBzdGFydCBvZiB0aGUgZmlyc3QgZnJhbWUgYW5kIHRoZSBlbmQgb2YgdGhlIHRhZ1xuICAgICAgICBmcmFtZVN0YXJ0ID0gMTA7XG4gICAgICAgIGlmICh0YWcuZGF0YVs1XSAmIDB4NDApIHtcbiAgICAgICAgICAvLyBhZHZhbmNlIHRoZSBmcmFtZSBzdGFydCBwYXN0IHRoZSBleHRlbmRlZCBoZWFkZXJcbiAgICAgICAgICBmcmFtZVN0YXJ0ICs9IDQ7IC8vIGhlYWRlciBzaXplIGZpZWxkXG4gICAgICAgICAgZnJhbWVTdGFydCArPSBwYXJzZVN5bmNTYWZlSW50ZWdlcih0YWcuZGF0YS5zdWJhcnJheSgxMCwgMTQpKTtcblxuICAgICAgICAgIC8vIGNsaXAgYW55IHBhZGRpbmcgb2ZmIHRoZSBlbmRcbiAgICAgICAgICB0YWdTaXplIC09IHBhcnNlU3luY1NhZmVJbnRlZ2VyKHRhZy5kYXRhLnN1YmFycmF5KDE2LCAyMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFyc2Ugb25lIG9yIG1vcmUgSUQzIGZyYW1lc1xuICAgICAgICAvLyBodHRwOi8vaWQzLm9yZy9pZDN2Mi4zLjAjSUQzdjJfZnJhbWVfb3ZlcnZpZXdcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgZnJhbWVcbiAgICAgICAgICBmcmFtZVNpemUgPSBwYXJzZVN5bmNTYWZlSW50ZWdlcih0YWcuZGF0YS5zdWJhcnJheShmcmFtZVN0YXJ0ICsgNCwgZnJhbWVTdGFydCArIDgpKTtcbiAgICAgICAgICBpZiAoZnJhbWVTaXplIDwgMSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZygnTWFsZm9ybWVkIElEMyBmcmFtZSBlbmNvdW50ZXJlZC4gU2tpcHBpbmcgbWV0YWRhdGEgcGFyc2luZy4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJhbWVIZWFkZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRhZy5kYXRhW2ZyYW1lU3RhcnRdLCB0YWcuZGF0YVtmcmFtZVN0YXJ0ICsgMV0sIHRhZy5kYXRhW2ZyYW1lU3RhcnQgKyAyXSwgdGFnLmRhdGFbZnJhbWVTdGFydCArIDNdKTtcblxuICAgICAgICAgIGZyYW1lID0ge1xuICAgICAgICAgICAgaWQ6IGZyYW1lSGVhZGVyLFxuICAgICAgICAgICAgZGF0YTogdGFnLmRhdGEuc3ViYXJyYXkoZnJhbWVTdGFydCArIDEwLCBmcmFtZVN0YXJ0ICsgZnJhbWVTaXplICsgMTApXG4gICAgICAgICAgfTtcbiAgICAgICAgICBmcmFtZS5rZXkgPSBmcmFtZS5pZDtcbiAgICAgICAgICBpZiAodGFnUGFyc2Vyc1tmcmFtZS5pZF0pIHtcbiAgICAgICAgICAgIHRhZ1BhcnNlcnNbZnJhbWUuaWRdKGZyYW1lKTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBzcGVjaWFsIFBSSVYgZnJhbWUgdXNlZCB0byBpbmRpY2F0ZSB0aGUgc3RhcnRcbiAgICAgICAgICAgIC8vIHRpbWUgZm9yIHJhdyBBQUMgZGF0YVxuICAgICAgICAgICAgaWYgKGZyYW1lLm93bmVyID09PSAnY29tLmFwcGxlLnN0cmVhbWluZy50cmFuc3BvcnRTdHJlYW1UaW1lc3RhbXAnKSB7XG4gICAgICAgICAgICAgIHZhciBkID0gZnJhbWUuZGF0YSxcbiAgICAgICAgICAgICAgICAgIHNpemUgPSAoZFszXSAmIDB4MDEpIDw8IDMwIHwgZFs0XSA8PCAyMiB8IGRbNV0gPDwgMTQgfCBkWzZdIDw8IDYgfCBkWzddID4+PiAyO1xuXG4gICAgICAgICAgICAgIHNpemUgKj0gNDtcbiAgICAgICAgICAgICAgc2l6ZSArPSBkWzddICYgMHgwMztcbiAgICAgICAgICAgICAgZnJhbWUudGltZVN0YW1wID0gc2l6ZTtcbiAgICAgICAgICAgICAgLy8gaW4gcmF3IEFBQywgYWxsIHN1YnNlcXVlbnQgZGF0YSB3aWxsIGJlIHRpbWVzdGFtcGVkIGJhc2VkXG4gICAgICAgICAgICAgIC8vIG9uIHRoZSB2YWx1ZSBvZiB0aGlzIGZyYW1lXG4gICAgICAgICAgICAgIC8vIHdlIGNvdWxkbid0IGhhdmUga25vd24gdGhlIGFwcHJvcHJpYXRlIHB0cyBhbmQgZHRzIGJlZm9yZVxuICAgICAgICAgICAgICAvLyBwYXJzaW5nIHRoaXMgSUQzIHRhZyBzbyBzZXQgdGhvc2UgdmFsdWVzIG5vd1xuICAgICAgICAgICAgICBpZiAodGFnLnB0cyA9PT0gdW5kZWZpbmVkICYmIHRhZy5kdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRhZy5wdHMgPSBmcmFtZS50aW1lU3RhbXA7XG4gICAgICAgICAgICAgICAgdGFnLmR0cyA9IGZyYW1lLnRpbWVTdGFtcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RpbWVzdGFtcCcsIGZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGFnLmZyYW1lcy5wdXNoKGZyYW1lKTtcblxuICAgICAgICAgIGZyYW1lU3RhcnQgKz0gMTA7IC8vIGFkdmFuY2UgcGFzdCB0aGUgZnJhbWUgaGVhZGVyXG4gICAgICAgICAgZnJhbWVTdGFydCArPSBmcmFtZVNpemU7IC8vIGFkdmFuY2UgcGFzdCB0aGUgZnJhbWUgYm9keVxuICAgICAgICB9IHdoaWxlIChmcmFtZVN0YXJ0IDwgdGFnU2l6ZSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIHRhZyk7XG4gICAgICB9O1xuICAgIH07XG4gICAgX01ldGFkYXRhU3RyZWFtLnByb3RvdHlwZSA9IG5ldyBzdHJlYW0oKTtcblxuICAgIHZhciBtZXRhZGF0YVN0cmVhbSA9IF9NZXRhZGF0YVN0cmVhbTtcblxuICAgIHZhciBUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSQxID0gdGltZXN0YW1wUm9sbG92ZXJTdHJlYW0uVGltZXN0YW1wUm9sbG92ZXJTdHJlYW07XG5cbiAgICAvLyBvYmplY3QgdHlwZXNcbiAgICB2YXIgX1RyYW5zcG9ydFBhY2tldFN0cmVhbSwgX1RyYW5zcG9ydFBhcnNlU3RyZWFtLCBfRWxlbWVudGFyeVN0cmVhbTtcblxuICAgIC8vIGNvbnN0YW50c1xuICAgIHZhciBNUDJUX1BBQ0tFVF9MRU5HVEggPSAxODgsXG5cblxuICAgIC8vIGJ5dGVzXG4gICAgU1lOQ19CWVRFID0gMHg0NztcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhbiBpbmNvbWluZyBzdHJlYW0gb2YgYmluYXJ5IGRhdGEgaW50byBNUEVHLTIgVHJhbnNwb3J0XG4gICAgICogU3RyZWFtIHBhY2tldHMuXG4gICAgICovXG4gICAgX1RyYW5zcG9ydFBhY2tldFN0cmVhbSA9IGZ1bmN0aW9uIFRyYW5zcG9ydFBhY2tldFN0cmVhbSgpIHtcbiAgICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShNUDJUX1BBQ0tFVF9MRU5HVEgpLFxuICAgICAgICAgIGJ5dGVzSW5CdWZmZXIgPSAwO1xuXG4gICAgICBfVHJhbnNwb3J0UGFja2V0U3RyZWFtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgICAgIC8vIERlbGl2ZXIgbmV3IGJ5dGVzIHRvIHRoZSBzdHJlYW0uXG5cbiAgICAgIHRoaXMucHVzaCA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICB2YXIgc3RhcnRJbmRleCA9IDAsXG4gICAgICAgICAgICBlbmRJbmRleCA9IE1QMlRfUEFDS0VUX0xFTkdUSCxcbiAgICAgICAgICAgIGV2ZXJ5dGhpbmc7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGJ5dGVzIHJlbWFpbmluZyBmcm9tIHRoZSBsYXN0IHNlZ21lbnQsIHByZXBlbmQgdGhlbSB0byB0aGVcbiAgICAgICAgLy8gYnl0ZXMgdGhhdCB3ZXJlIHB1c2hlZCBpblxuICAgICAgICBpZiAoYnl0ZXNJbkJ1ZmZlcikge1xuICAgICAgICAgIGV2ZXJ5dGhpbmcgPSBuZXcgVWludDhBcnJheShieXRlcy5ieXRlTGVuZ3RoICsgYnl0ZXNJbkJ1ZmZlcik7XG4gICAgICAgICAgZXZlcnl0aGluZy5zZXQoYnVmZmVyLnN1YmFycmF5KDAsIGJ5dGVzSW5CdWZmZXIpKTtcbiAgICAgICAgICBldmVyeXRoaW5nLnNldChieXRlcywgYnl0ZXNJbkJ1ZmZlcik7XG4gICAgICAgICAgYnl0ZXNJbkJ1ZmZlciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlcnl0aGluZyA9IGJ5dGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2hpbGUgd2UgaGF2ZSBlbm91Z2ggZGF0YSBmb3IgYSBwYWNrZXRcbiAgICAgICAgd2hpbGUgKGVuZEluZGV4IDwgZXZlcnl0aGluZy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgLy8gTG9vayBmb3IgYSBwYWlyIG9mIHN0YXJ0IGFuZCBlbmQgc3luYyBieXRlcyBpbiB0aGUgZGF0YS4uXG4gICAgICAgICAgaWYgKGV2ZXJ5dGhpbmdbc3RhcnRJbmRleF0gPT09IFNZTkNfQllURSAmJiBldmVyeXRoaW5nW2VuZEluZGV4XSA9PT0gU1lOQ19CWVRFKSB7XG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIHBhY2tldCBzbyBlbWl0IGl0IGFuZCBqdW1wIG9uZSB3aG9sZSBwYWNrZXQgZm9yd2FyZCBpblxuICAgICAgICAgICAgLy8gdGhlIHN0cmVhbVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlcnl0aGluZy5zdWJhcnJheShzdGFydEluZGV4LCBlbmRJbmRleCkpO1xuICAgICAgICAgICAgc3RhcnRJbmRleCArPSBNUDJUX1BBQ0tFVF9MRU5HVEg7XG4gICAgICAgICAgICBlbmRJbmRleCArPSBNUDJUX1BBQ0tFVF9MRU5HVEg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHdlIGhhdmUgc29tZWhvdyBiZWNvbWUgZGUtc3luY2hyb25pemVkIGFuZCB3ZSBuZWVkIHRvIHN0ZXBcbiAgICAgICAgICAvLyBmb3J3YXJkIG9uZSBieXRlIGF0IGEgdGltZSB1bnRpbCB3ZSBmaW5kIGEgcGFpciBvZiBzeW5jIGJ5dGVzIHRoYXQgZGVub3RlXG4gICAgICAgICAgLy8gYSBwYWNrZXRcbiAgICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICAgICAgZW5kSW5kZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBzb21lIGRhdGEgbGVmdCBvdmVyIGF0IHRoZSBlbmQgb2YgdGhlIHNlZ21lbnQgdGhhdCBjb3VsZG4ndFxuICAgICAgICAvLyBwb3NzaWJseSBiZSBhIHdob2xlIHBhY2tldCwga2VlcCBpdCBiZWNhdXNlIGl0IG1pZ2h0IGJlIHRoZSBzdGFydCBvZiBhIHBhY2tldFxuICAgICAgICAvLyB0aGF0IGNvbnRpbnVlcyBpbiB0aGUgbmV4dCBzZWdtZW50XG4gICAgICAgIGlmIChzdGFydEluZGV4IDwgZXZlcnl0aGluZy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgYnVmZmVyLnNldChldmVyeXRoaW5nLnN1YmFycmF5KHN0YXJ0SW5kZXgpLCAwKTtcbiAgICAgICAgICBieXRlc0luQnVmZmVyID0gZXZlcnl0aGluZy5ieXRlTGVuZ3RoIC0gc3RhcnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSWYgdGhlIGJ1ZmZlciBjb250YWlucyBhIHdob2xlIHBhY2tldCB3aGVuIHdlIGFyZSBiZWluZyBmbHVzaGVkLCBlbWl0IGl0XG4gICAgICAgIC8vIGFuZCBlbXB0eSB0aGUgYnVmZmVyLiBPdGhlcndpc2UgaG9sZCBvbnRvIHRoZSBkYXRhIGJlY2F1c2UgaXQgbWF5IGJlXG4gICAgICAgIC8vIGltcG9ydGFudCBmb3IgZGVjb2RpbmcgdGhlIG5leHQgc2VnbWVudFxuICAgICAgICBpZiAoYnl0ZXNJbkJ1ZmZlciA9PT0gTVAyVF9QQUNLRVRfTEVOR1RIICYmIGJ1ZmZlclswXSA9PT0gU1lOQ19CWVRFKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgYnVmZmVyKTtcbiAgICAgICAgICBieXRlc0luQnVmZmVyID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBfVHJhbnNwb3J0UGFja2V0U3RyZWFtLnByb3RvdHlwZSA9IG5ldyBzdHJlYW0oKTtcblxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgYW4gTVAyVCBUcmFuc3BvcnRQYWNrZXRTdHJlYW0gYW5kIGVtaXRzIGRhdGEgZXZlbnRzIHdpdGggcGFyc2VkXG4gICAgICogZm9ybXMgb2YgdGhlIGluZGl2aWR1YWwgdHJhbnNwb3J0IHN0cmVhbSBwYWNrZXRzLlxuICAgICAqL1xuICAgIF9UcmFuc3BvcnRQYXJzZVN0cmVhbSA9IGZ1bmN0aW9uIFRyYW5zcG9ydFBhcnNlU3RyZWFtKCkge1xuICAgICAgdmFyIHBhcnNlUHNpLCBwYXJzZVBhdCwgcGFyc2VQbXQsIHNlbGY7XG4gICAgICBfVHJhbnNwb3J0UGFyc2VTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcbiAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICB0aGlzLnBhY2tldHNXYWl0aW5nRm9yUG10ID0gW107XG4gICAgICB0aGlzLnByb2dyYW1NYXBUYWJsZSA9IHVuZGVmaW5lZDtcblxuICAgICAgcGFyc2VQc2kgPSBmdW5jdGlvbiBwYXJzZVBzaShwYXlsb2FkLCBwc2kpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgICAgLy8gUFNJIHBhY2tldHMgbWF5IGJlIHNwbGl0IGludG8gbXVsdGlwbGUgc2VjdGlvbnMgYW5kIHRob3NlXG4gICAgICAgIC8vIHNlY3Rpb25zIG1heSBiZSBzcGxpdCBpbnRvIG11bHRpcGxlIHBhY2tldHMuIElmIGEgUFNJXG4gICAgICAgIC8vIHNlY3Rpb24gc3RhcnRzIGluIHRoaXMgcGFja2V0LCB0aGUgcGF5bG9hZF91bml0X3N0YXJ0X2luZGljYXRvclxuICAgICAgICAvLyB3aWxsIGJlIHRydWUgYW5kIHRoZSBmaXJzdCBieXRlIG9mIHRoZSBwYXlsb2FkIHdpbGwgaW5kaWNhdGVcbiAgICAgICAgLy8gdGhlIG9mZnNldCBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGVcbiAgICAgICAgLy8gc2VjdGlvbi5cbiAgICAgICAgaWYgKHBzaS5wYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IHBheWxvYWRbb2Zmc2V0XSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHNpLnR5cGUgPT09ICdwYXQnKSB7XG4gICAgICAgICAgcGFyc2VQYXQocGF5bG9hZC5zdWJhcnJheShvZmZzZXQpLCBwc2kpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlUG10KHBheWxvYWQuc3ViYXJyYXkob2Zmc2V0KSwgcHNpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcGFyc2VQYXQgPSBmdW5jdGlvbiBwYXJzZVBhdChwYXlsb2FkLCBwYXQpIHtcbiAgICAgICAgcGF0LnNlY3Rpb25fbnVtYmVyID0gcGF5bG9hZFs3XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgcGF0Lmxhc3Rfc2VjdGlvbl9udW1iZXIgPSBwYXlsb2FkWzhdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICAgIC8vIHNraXAgdGhlIFBTSSBoZWFkZXIgYW5kIHBhcnNlIHRoZSBmaXJzdCBQTVQgZW50cnlcbiAgICAgICAgc2VsZi5wbXRQaWQgPSAocGF5bG9hZFsxMF0gJiAweDFGKSA8PCA4IHwgcGF5bG9hZFsxMV07XG4gICAgICAgIHBhdC5wbXRQaWQgPSBzZWxmLnBtdFBpZDtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyc2Ugb3V0IHRoZSByZWxldmFudCBmaWVsZHMgb2YgYSBQcm9ncmFtIE1hcCBUYWJsZSAoUE1UKS5cbiAgICAgICAqIEBwYXJhbSBwYXlsb2FkIHtVaW50OEFycmF5fSB0aGUgUE1ULXNwZWNpZmljIHBvcnRpb24gb2YgYW4gTVAyVFxuICAgICAgICogcGFja2V0LiBUaGUgZmlyc3QgYnl0ZSBpbiB0aGlzIGFycmF5IHNob3VsZCBiZSB0aGUgdGFibGVfaWRcbiAgICAgICAqIGZpZWxkLlxuICAgICAgICogQHBhcmFtIHBtdCB7b2JqZWN0fSB0aGUgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGRlY29yYXRlZCB3aXRoXG4gICAgICAgKiBmaWVsZHMgcGFyc2VkIGZyb20gdGhlIFBNVC5cbiAgICAgICAqL1xuICAgICAgcGFyc2VQbXQgPSBmdW5jdGlvbiBwYXJzZVBtdChwYXlsb2FkLCBwbXQpIHtcbiAgICAgICAgdmFyIHNlY3Rpb25MZW5ndGgsIHRhYmxlRW5kLCBwcm9ncmFtSW5mb0xlbmd0aCwgb2Zmc2V0O1xuXG4gICAgICAgIC8vIFBNVHMgY2FuIGJlIHNlbnQgYWhlYWQgb2YgdGhlIHRpbWUgd2hlbiB0aGV5IHNob3VsZCBhY3R1YWxseVxuICAgICAgICAvLyB0YWtlIGVmZmVjdC4gV2UgZG9uJ3QgYmVsaWV2ZSB0aGlzIHNob3VsZCBldmVyIGJlIHRoZSBjYXNlXG4gICAgICAgIC8vIGZvciBITFMgYnV0IHdlJ2xsIGlnbm9yZSBcImZvcndhcmRcIiBQTVQgZGVjbGFyYXRpb25zIGlmIHdlIHNlZVxuICAgICAgICAvLyB0aGVtLiBGdXR1cmUgUE1UIGRlY2xhcmF0aW9ucyBoYXZlIHRoZSBjdXJyZW50X25leHRfaW5kaWNhdG9yXG4gICAgICAgIC8vIHNldCB0byB6ZXJvLlxuICAgICAgICBpZiAoIShwYXlsb2FkWzVdICYgMHgwMSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdmVyd3JpdGUgYW55IGV4aXN0aW5nIHByb2dyYW0gbWFwIHRhYmxlXG4gICAgICAgIHNlbGYucHJvZ3JhbU1hcFRhYmxlID0ge1xuICAgICAgICAgIHZpZGVvOiBudWxsLFxuICAgICAgICAgIGF1ZGlvOiBudWxsLFxuICAgICAgICAgICd0aW1lZC1tZXRhZGF0YSc6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdGhlIG1hcHBpbmcgdGFibGUgZW5kcyBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHNlY3Rpb25cbiAgICAgICAgc2VjdGlvbkxlbmd0aCA9IChwYXlsb2FkWzFdICYgMHgwZikgPDwgOCB8IHBheWxvYWRbMl07XG4gICAgICAgIHRhYmxlRW5kID0gMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuXG4gICAgICAgIC8vIHRvIGRldGVybWluZSB3aGVyZSB0aGUgdGFibGUgaXMsIHdlIGhhdmUgdG8gZmlndXJlIG91dCBob3dcbiAgICAgICAgLy8gbG9uZyB0aGUgcHJvZ3JhbSBpbmZvIGRlc2NyaXB0b3JzIGFyZVxuICAgICAgICBwcm9ncmFtSW5mb0xlbmd0aCA9IChwYXlsb2FkWzEwXSAmIDB4MGYpIDw8IDggfCBwYXlsb2FkWzExXTtcblxuICAgICAgICAvLyBhZHZhbmNlIHRoZSBvZmZzZXQgdG8gdGhlIGZpcnN0IGVudHJ5IGluIHRoZSBtYXBwaW5nIHRhYmxlXG4gICAgICAgIG9mZnNldCA9IDEyICsgcHJvZ3JhbUluZm9MZW5ndGg7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgICAgICAgIHZhciBzdHJlYW1UeXBlID0gcGF5bG9hZFtvZmZzZXRdO1xuICAgICAgICAgIHZhciBwaWQgPSAocGF5bG9hZFtvZmZzZXQgKyAxXSAmIDB4MUYpIDw8IDggfCBwYXlsb2FkW29mZnNldCArIDJdO1xuXG4gICAgICAgICAgLy8gb25seSBtYXAgYSBzaW5nbGUgZWxlbWVudGFyeV9waWQgZm9yIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW0gdHlwZXNcbiAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyBiZSBkb25lIGZvciBtZXRhZGF0YSB0b28/IGZvciBub3cgbWFpbnRhaW4gYmVoYXZpb3Igb2ZcbiAgICAgICAgICAvLyAgICAgICBtdWx0aXBsZSBtZXRhZGF0YSBzdHJlYW1zXG4gICAgICAgICAgaWYgKHN0cmVhbVR5cGUgPT09IHN0cmVhbVR5cGVzLkgyNjRfU1RSRUFNX1RZUEUgJiYgc2VsZi5wcm9ncmFtTWFwVGFibGUudmlkZW8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHNlbGYucHJvZ3JhbU1hcFRhYmxlLnZpZGVvID0gcGlkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtVHlwZSA9PT0gc3RyZWFtVHlwZXMuQURUU19TVFJFQU1fVFlQRSAmJiBzZWxmLnByb2dyYW1NYXBUYWJsZS5hdWRpbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc2VsZi5wcm9ncmFtTWFwVGFibGUuYXVkaW8gPSBwaWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1UeXBlID09PSBzdHJlYW1UeXBlcy5NRVRBREFUQV9TVFJFQU1fVFlQRSkge1xuICAgICAgICAgICAgLy8gbWFwIHBpZCB0byBzdHJlYW0gdHlwZSBmb3IgbWV0YWRhdGEgc3RyZWFtc1xuICAgICAgICAgICAgc2VsZi5wcm9ncmFtTWFwVGFibGVbJ3RpbWVkLW1ldGFkYXRhJ11bcGlkXSA9IHN0cmVhbVR5cGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCB0YWJsZSBlbnRyeVxuICAgICAgICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcbiAgICAgICAgICBvZmZzZXQgKz0gKChwYXlsb2FkW29mZnNldCArIDNdICYgMHgwRikgPDwgOCB8IHBheWxvYWRbb2Zmc2V0ICsgNF0pICsgNTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY29yZCB0aGUgbWFwIG9uIHRoZSBwYWNrZXQgYXMgd2VsbFxuICAgICAgICBwbXQucHJvZ3JhbU1hcFRhYmxlID0gc2VsZi5wcm9ncmFtTWFwVGFibGU7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIERlbGl2ZXIgYSBuZXcgTVAyVCBwYWNrZXQgdG8gdGhlIHN0cmVhbS5cbiAgICAgICAqL1xuICAgICAgdGhpcy5wdXNoID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgICAgICBvZmZzZXQgPSA0O1xuXG4gICAgICAgIHJlc3VsdC5wYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yID0gISEocGFja2V0WzFdICYgMHg0MCk7XG5cbiAgICAgICAgLy8gcGlkIGlzIGEgMTMtYml0IGZpZWxkIHN0YXJ0aW5nIGF0IHRoZSBsYXN0IGJpdCBvZiBwYWNrZXRbMV1cbiAgICAgICAgcmVzdWx0LnBpZCA9IHBhY2tldFsxXSAmIDB4MWY7XG4gICAgICAgIHJlc3VsdC5waWQgPDw9IDg7XG4gICAgICAgIHJlc3VsdC5waWQgfD0gcGFja2V0WzJdO1xuXG4gICAgICAgIC8vIGlmIGFuIGFkYXB0aW9uIGZpZWxkIGlzIHByZXNlbnQsIGl0cyBsZW5ndGggaXMgc3BlY2lmaWVkIGJ5IHRoZVxuICAgICAgICAvLyBmaWZ0aCBieXRlIG9mIHRoZSBUUyBwYWNrZXQgaGVhZGVyLiBUaGUgYWRhcHRhdGlvbiBmaWVsZCBpc1xuICAgICAgICAvLyB1c2VkIHRvIGFkZCBzdHVmZmluZyB0byBQRVMgcGFja2V0cyB0aGF0IGRvbid0IGZpbGwgYSBjb21wbGV0ZVxuICAgICAgICAvLyBUUyBwYWNrZXQsIGFuZCB0byBzcGVjaWZ5IHNvbWUgZm9ybXMgb2YgdGltaW5nIGFuZCBjb250cm9sIGRhdGFcbiAgICAgICAgLy8gdGhhdCB3ZSBkbyBub3QgY3VycmVudGx5IHVzZS5cbiAgICAgICAgaWYgKChwYWNrZXRbM10gJiAweDMwKSA+Pj4gNCA+IDB4MDEpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gcGFja2V0W29mZnNldF0gKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFyc2UgdGhlIHJlc3Qgb2YgdGhlIHBhY2tldCBiYXNlZCBvbiB0aGUgdHlwZVxuICAgICAgICBpZiAocmVzdWx0LnBpZCA9PT0gMCkge1xuICAgICAgICAgIHJlc3VsdC50eXBlID0gJ3BhdCc7XG4gICAgICAgICAgcGFyc2VQc2kocGFja2V0LnN1YmFycmF5KG9mZnNldCksIHJlc3VsdCk7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQucGlkID09PSB0aGlzLnBtdFBpZCkge1xuICAgICAgICAgIHJlc3VsdC50eXBlID0gJ3BtdCc7XG4gICAgICAgICAgcGFyc2VQc2kocGFja2V0LnN1YmFycmF5KG9mZnNldCksIHJlc3VsdCk7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgcmVzdWx0KTtcblxuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBhbnkgcGFja2V0cyB3YWl0aW5nIGZvciBhIFBNVCB0byBiZSBmb3VuZCwgcHJvY2VzcyB0aGVtIG5vd1xuICAgICAgICAgIHdoaWxlICh0aGlzLnBhY2tldHNXYWl0aW5nRm9yUG10Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVzXy5hcHBseSh0aGlzLCB0aGlzLnBhY2tldHNXYWl0aW5nRm9yUG10LnNoaWZ0KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb2dyYW1NYXBUYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBoYXZlIG5vdCBzZWVuIGEgUE1UIHlldCwgZGVmZXIgZnVydGhlciBwcm9jZXNzaW5nIG9mXG4gICAgICAgICAgLy8gUEVTIHBhY2tldHMgdW50aWwgb25lIGhhcyBiZWVuIHBhcnNlZFxuICAgICAgICAgIHRoaXMucGFja2V0c1dhaXRpbmdGb3JQbXQucHVzaChbcGFja2V0LCBvZmZzZXQsIHJlc3VsdF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc1Blc18ocGFja2V0LCBvZmZzZXQsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMucHJvY2Vzc1Blc18gPSBmdW5jdGlvbiAocGFja2V0LCBvZmZzZXQsIHJlc3VsdCkge1xuICAgICAgICAvLyBzZXQgdGhlIGFwcHJvcHJpYXRlIHN0cmVhbSB0eXBlXG4gICAgICAgIGlmIChyZXN1bHQucGlkID09PSB0aGlzLnByb2dyYW1NYXBUYWJsZS52aWRlbykge1xuICAgICAgICAgIHJlc3VsdC5zdHJlYW1UeXBlID0gc3RyZWFtVHlwZXMuSDI2NF9TVFJFQU1fVFlQRTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQucGlkID09PSB0aGlzLnByb2dyYW1NYXBUYWJsZS5hdWRpbykge1xuICAgICAgICAgIHJlc3VsdC5zdHJlYW1UeXBlID0gc3RyZWFtVHlwZXMuQURUU19TVFJFQU1fVFlQRTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBub3QgdmlkZW8gb3IgYXVkaW8sIGl0IGlzIHRpbWVkLW1ldGFkYXRhIG9yIHVua25vd25cbiAgICAgICAgICAvLyBpZiB1bmtub3duLCBzdHJlYW1UeXBlIHdpbGwgYmUgdW5kZWZpbmVkXG4gICAgICAgICAgcmVzdWx0LnN0cmVhbVR5cGUgPSB0aGlzLnByb2dyYW1NYXBUYWJsZVsndGltZWQtbWV0YWRhdGEnXVtyZXN1bHQucGlkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC50eXBlID0gJ3Blcyc7XG4gICAgICAgIHJlc3VsdC5kYXRhID0gcGFja2V0LnN1YmFycmF5KG9mZnNldCk7XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgcmVzdWx0KTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBfVHJhbnNwb3J0UGFyc2VTdHJlYW0ucHJvdG90eXBlID0gbmV3IHN0cmVhbSgpO1xuICAgIF9UcmFuc3BvcnRQYXJzZVN0cmVhbS5TVFJFQU1fVFlQRVMgPSB7XG4gICAgICBoMjY0OiAweDFiLFxuICAgICAgYWR0czogMHgwZlxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWNvbnNpc3R1dGVzIHByb2dyYW0gZWxlbWVudGFyeSBzdHJlYW0gKFBFUykgcGFja2V0cyBmcm9tIHBhcnNlZFxuICAgICAqIHRyYW5zcG9ydCBzdHJlYW0gcGFja2V0cy4gVGhhdCBpcywgaWYgeW91IHBpcGUgYW5cbiAgICAgKiBtcDJ0LlRyYW5zcG9ydFBhcnNlU3RyZWFtIGludG8gYSBtcDJ0LkVsZW1lbnRhcnlTdHJlYW0sIHRoZSBvdXRwdXRcbiAgICAgKiBldmVudHMgd2lsbCBiZSBldmVudHMgd2hpY2ggY2FwdHVyZSB0aGUgYnl0ZXMgZm9yIGluZGl2aWR1YWwgUEVTXG4gICAgICogcGFja2V0cyBwbHVzIHJlbGV2YW50IG1ldGFkYXRhIHRoYXQgaGFzIGJlZW4gZXh0cmFjdGVkIGZyb20gdGhlXG4gICAgICogY29udGFpbmVyLlxuICAgICAqL1xuICAgIF9FbGVtZW50YXJ5U3RyZWFtID0gZnVuY3Rpb24gRWxlbWVudGFyeVN0cmVhbSgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcblxuXG4gICAgICAvLyBQRVMgcGFja2V0IGZyYWdtZW50c1xuICAgICAgdmlkZW8gPSB7XG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBzaXplOiAwXG4gICAgICB9LFxuICAgICAgICAgIGF1ZGlvID0ge1xuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgc2l6ZTogMFxuICAgICAgfSxcbiAgICAgICAgICB0aW1lZE1ldGFkYXRhID0ge1xuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgc2l6ZTogMFxuICAgICAgfSxcbiAgICAgICAgICBwYXJzZVBlcyA9IGZ1bmN0aW9uIHBhcnNlUGVzKHBheWxvYWQsIHBlcykge1xuICAgICAgICB2YXIgcHRzRHRzRmxhZ3M7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBwYWNrZXQgbGVuZ3RoLCB0aGlzIHdpbGwgYmUgMCBmb3IgdmlkZW9cbiAgICAgICAgcGVzLnBhY2tldExlbmd0aCA9IDYgKyAocGF5bG9hZFs0XSA8PCA4IHwgcGF5bG9hZFs1XSk7XG5cbiAgICAgICAgLy8gZmluZCBvdXQgaWYgdGhpcyBwYWNrZXRzIHN0YXJ0cyBhIG5ldyBrZXlmcmFtZVxuICAgICAgICBwZXMuZGF0YUFsaWdubWVudEluZGljYXRvciA9IChwYXlsb2FkWzZdICYgMHgwNCkgIT09IDA7XG4gICAgICAgIC8vIFBFUyBwYWNrZXRzIG1heSBiZSBhbm5vdGF0ZWQgd2l0aCBhIFBUUyB2YWx1ZSwgb3IgYSBQVFMgdmFsdWVcbiAgICAgICAgLy8gYW5kIGEgRFRTIHZhbHVlLiBEZXRlcm1pbmUgd2hhdCBjb21iaW5hdGlvbiBvZiB2YWx1ZXMgaXNcbiAgICAgICAgLy8gYXZhaWxhYmxlIHRvIHdvcmsgd2l0aC5cbiAgICAgICAgcHRzRHRzRmxhZ3MgPSBwYXlsb2FkWzddO1xuXG4gICAgICAgIC8vIFBUUyBhbmQgRFRTIGFyZSBub3JtYWxseSBzdG9yZWQgYXMgYSAzMy1iaXQgbnVtYmVyLiAgSmF2YXNjcmlwdFxuICAgICAgICAvLyBwZXJmb3JtcyBhbGwgYml0d2lzZSBvcGVyYXRpb25zIG9uIDMyLWJpdCBpbnRlZ2VycyBidXQgamF2YXNjcmlwdFxuICAgICAgICAvLyBzdXBwb3J0cyBhIG11Y2ggZ3JlYXRlciByYW5nZSAoNTItYml0cykgb2YgaW50ZWdlciB1c2luZyBzdGFuZGFyZFxuICAgICAgICAvLyBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucy5cbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgMzEtYml0IHZhbHVlIHVzaW5nIGJpdHdpc2Ugb3BlcmF0b3JzIG92ZXIgdGhlIDMxXG4gICAgICAgIC8vIG1vc3Qgc2lnbmlmaWNhbnQgYml0cyBhbmQgdGhlbiBtdWx0aXBseSBieSA0IChlcXVhbCB0byBhIGxlZnQtc2hpZnRcbiAgICAgICAgLy8gb2YgMikgYmVmb3JlIHdlIGFkZCB0aGUgZmluYWwgMiBsZWFzdCBzaWduaWZpY2FudCBiaXRzIG9mIHRoZVxuICAgICAgICAvLyB0aW1lc3RhbXAgKGVxdWFsIHRvIGFuIE9SLilcbiAgICAgICAgaWYgKHB0c0R0c0ZsYWdzICYgMHhDMCkge1xuICAgICAgICAgIC8vIHRoZSBQVFMgYW5kIERUUyBhcmUgbm90IHdyaXR0ZW4gb3V0IGRpcmVjdGx5LiBGb3IgaW5mb3JtYXRpb25cbiAgICAgICAgICAvLyBvbiBob3cgdGhleSBhcmUgZW5jb2RlZCwgc2VlXG4gICAgICAgICAgLy8gaHR0cDovL2R2ZC5zb3VyY2Vmb3JnZS5uZXQvZHZkaW5mby9wZXMtaGRyLmh0bWxcbiAgICAgICAgICBwZXMucHRzID0gKHBheWxvYWRbOV0gJiAweDBFKSA8PCAyNyB8IChwYXlsb2FkWzEwXSAmIDB4RkYpIDw8IDIwIHwgKHBheWxvYWRbMTFdICYgMHhGRSkgPDwgMTIgfCAocGF5bG9hZFsxMl0gJiAweEZGKSA8PCA1IHwgKHBheWxvYWRbMTNdICYgMHhGRSkgPj4+IDM7XG4gICAgICAgICAgcGVzLnB0cyAqPSA0OyAvLyBMZWZ0IHNoaWZ0IGJ5IDJcbiAgICAgICAgICBwZXMucHRzICs9IChwYXlsb2FkWzEzXSAmIDB4MDYpID4+PiAxOyAvLyBPUiBieSB0aGUgdHdvIExTQnNcbiAgICAgICAgICBwZXMuZHRzID0gcGVzLnB0cztcbiAgICAgICAgICBpZiAocHRzRHRzRmxhZ3MgJiAweDQwKSB7XG4gICAgICAgICAgICBwZXMuZHRzID0gKHBheWxvYWRbMTRdICYgMHgwRSkgPDwgMjcgfCAocGF5bG9hZFsxNV0gJiAweEZGKSA8PCAyMCB8IChwYXlsb2FkWzE2XSAmIDB4RkUpIDw8IDEyIHwgKHBheWxvYWRbMTddICYgMHhGRikgPDwgNSB8IChwYXlsb2FkWzE4XSAmIDB4RkUpID4+PiAzO1xuICAgICAgICAgICAgcGVzLmR0cyAqPSA0OyAvLyBMZWZ0IHNoaWZ0IGJ5IDJcbiAgICAgICAgICAgIHBlcy5kdHMgKz0gKHBheWxvYWRbMThdICYgMHgwNikgPj4+IDE7IC8vIE9SIGJ5IHRoZSB0d28gTFNCc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgZGF0YSBzZWN0aW9uIHN0YXJ0cyBpbW1lZGlhdGVseSBhZnRlciB0aGUgUEVTIGhlYWRlci5cbiAgICAgICAgLy8gcGVzX2hlYWRlcl9kYXRhX2xlbmd0aCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiBoZWFkZXIgYnl0ZXNcbiAgICAgICAgLy8gdGhhdCBmb2xsb3cgdGhlIGxhc3QgYnl0ZSBvZiB0aGUgZmllbGQuXG4gICAgICAgIHBlcy5kYXRhID0gcGF5bG9hZC5zdWJhcnJheSg5ICsgcGF5bG9hZFs4XSk7XG4gICAgICB9LFxuICAgICAgICAgIGZsdXNoU3RyZWFtID0gZnVuY3Rpb24gZmx1c2hTdHJlYW0oc3RyZWFtJCQxLCB0eXBlLCBmb3JjZUZsdXNoKSB7XG4gICAgICAgIHZhciBwYWNrZXREYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtJCQxLnNpemUpLFxuICAgICAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICB9LFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICAgICAgcGFja2V0Rmx1c2hhYmxlID0gZmFsc2UsXG4gICAgICAgICAgICBmcmFnbWVudDtcblxuICAgICAgICAvLyBkbyBub3RoaW5nIGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggYnVmZmVyZWQgZGF0YSBmb3IgYSBjb21wbGV0ZVxuICAgICAgICAvLyBQRVMgaGVhZGVyXG4gICAgICAgIGlmICghc3RyZWFtJCQxLmRhdGEubGVuZ3RoIHx8IHN0cmVhbSQkMS5zaXplIDwgOSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC50cmFja0lkID0gc3RyZWFtJCQxLmRhdGFbMF0ucGlkO1xuXG4gICAgICAgIC8vIHJlYXNzZW1ibGUgdGhlIHBhY2tldFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyZWFtJCQxLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmcmFnbWVudCA9IHN0cmVhbSQkMS5kYXRhW2ldO1xuXG4gICAgICAgICAgcGFja2V0RGF0YS5zZXQoZnJhZ21lbnQuZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhZ21lbnQuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFyc2UgYXNzZW1ibGVkIHBhY2tldCdzIFBFUyBoZWFkZXJcbiAgICAgICAgcGFyc2VQZXMocGFja2V0RGF0YSwgZXZlbnQpO1xuXG4gICAgICAgIC8vIG5vbi12aWRlbyBQRVMgcGFja2V0cyBNVVNUIGhhdmUgYSBub24temVybyBQRVNfcGFja2V0X2xlbmd0aFxuICAgICAgICAvLyBjaGVjayB0aGF0IHRoZXJlIGlzIGVub3VnaCBzdHJlYW0gZGF0YSB0byBmaWxsIHRoZSBwYWNrZXRcbiAgICAgICAgcGFja2V0Rmx1c2hhYmxlID0gdHlwZSA9PT0gJ3ZpZGVvJyB8fCBldmVudC5wYWNrZXRMZW5ndGggPD0gc3RyZWFtJCQxLnNpemU7XG5cbiAgICAgICAgLy8gZmx1c2ggcGVuZGluZyBwYWNrZXRzIGlmIHRoZSBjb25kaXRpb25zIGFyZSByaWdodFxuICAgICAgICBpZiAoZm9yY2VGbHVzaCB8fCBwYWNrZXRGbHVzaGFibGUpIHtcbiAgICAgICAgICBzdHJlYW0kJDEuc2l6ZSA9IDA7XG4gICAgICAgICAgc3RyZWFtJCQxLmRhdGEubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkgZW1pdCBwYWNrZXRzIHRoYXQgYXJlIGNvbXBsZXRlLiB0aGlzIGlzIHRvIGF2b2lkIGFzc2VtYmxpbmdcbiAgICAgICAgLy8gaW5jb21wbGV0ZSBQRVMgcGFja2V0cyBkdWUgdG8gcG9vciBzZWdtZW50YXRpb25cbiAgICAgICAgaWYgKHBhY2tldEZsdXNoYWJsZSkge1xuICAgICAgICAgIHNlbGYudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX0VsZW1lbnRhcnlTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgKHtcbiAgICAgICAgICBwYXQ6IGZ1bmN0aW9uIHBhdCgpIHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhlIFBNVCB0byBhcnJpdmUgYXMgd2VsbCBiZWZvcmUgd2VcbiAgICAgICAgICAgIC8vIGhhdmUgYW55IG1lYW5pbmdmdWwgbWV0YWRhdGFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBlczogZnVuY3Rpb24gcGVzKCkge1xuICAgICAgICAgICAgdmFyIHN0cmVhbSQkMSwgc3RyZWFtVHlwZTtcblxuICAgICAgICAgICAgc3dpdGNoIChkYXRhLnN0cmVhbVR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBzdHJlYW1UeXBlcy5IMjY0X1NUUkVBTV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIHN0cmVhbVR5cGVzLkgyNjRfU1RSRUFNX1RZUEU6XG4gICAgICAgICAgICAgICAgc3RyZWFtJCQxID0gdmlkZW87XG4gICAgICAgICAgICAgICAgc3RyZWFtVHlwZSA9ICd2aWRlbyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2Ugc3RyZWFtVHlwZXMuQURUU19TVFJFQU1fVFlQRTpcbiAgICAgICAgICAgICAgICBzdHJlYW0kJDEgPSBhdWRpbztcbiAgICAgICAgICAgICAgICBzdHJlYW1UeXBlID0gJ2F1ZGlvJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBzdHJlYW1UeXBlcy5NRVRBREFUQV9TVFJFQU1fVFlQRTpcbiAgICAgICAgICAgICAgICBzdHJlYW0kJDEgPSB0aW1lZE1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIHN0cmVhbVR5cGUgPSAndGltZWQtbWV0YWRhdGEnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB1bmtub3duIHN0cmVhbSB0eXBlc1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgYSBuZXcgcGFja2V0IGlzIHN0YXJ0aW5nLCB3ZSBjYW4gZmx1c2ggdGhlIGNvbXBsZXRlZFxuICAgICAgICAgICAgLy8gcGFja2V0XG4gICAgICAgICAgICBpZiAoZGF0YS5wYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAgIGZsdXNoU3RyZWFtKHN0cmVhbSQkMSwgc3RyZWFtVHlwZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGlzIGZyYWdtZW50IHVudGlsIHdlIGFyZSBzdXJlIHdlJ3ZlIHJlY2VpdmVkIHRoZVxuICAgICAgICAgICAgLy8gY29tcGxldGUgcGF5bG9hZFxuICAgICAgICAgICAgc3RyZWFtJCQxLmRhdGEucHVzaChkYXRhKTtcbiAgICAgICAgICAgIHN0cmVhbSQkMS5zaXplICs9IGRhdGEuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcG10OiBmdW5jdGlvbiBwbXQoKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICAgIHR5cGU6ICdtZXRhZGF0YScsXG4gICAgICAgICAgICAgIHRyYWNrczogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJvZ3JhbU1hcFRhYmxlID0gZGF0YS5wcm9ncmFtTWFwVGFibGU7XG5cbiAgICAgICAgICAgIC8vIHRyYW5zbGF0ZSBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtcyB0byB0cmFja3NcbiAgICAgICAgICAgIGlmIChwcm9ncmFtTWFwVGFibGUudmlkZW8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZXZlbnQudHJhY2tzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRpbWVsaW5lU3RhcnRJbmZvOiB7XG4gICAgICAgICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lOiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogK3Byb2dyYW1NYXBUYWJsZS52aWRlbyxcbiAgICAgICAgICAgICAgICBjb2RlYzogJ2F2YycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3ZpZGVvJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9ncmFtTWFwVGFibGUuYXVkaW8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZXZlbnQudHJhY2tzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRpbWVsaW5lU3RhcnRJbmZvOiB7XG4gICAgICAgICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lOiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogK3Byb2dyYW1NYXBUYWJsZS5hdWRpbyxcbiAgICAgICAgICAgICAgICBjb2RlYzogJ2FkdHMnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhdWRpbydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pW2RhdGEudHlwZV0oKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRmx1c2ggYW55IHJlbWFpbmluZyBpbnB1dC4gVmlkZW8gUEVTIHBhY2tldHMgbWF5IGJlIG9mIHZhcmlhYmxlXG4gICAgICAgKiBsZW5ndGguIE5vcm1hbGx5LCB0aGUgc3RhcnQgb2YgYSBuZXcgdmlkZW8gcGFja2V0IGNhbiB0cmlnZ2VyIHRoZVxuICAgICAgICogZmluYWxpemF0aW9uIG9mIHRoZSBwcmV2aW91cyBwYWNrZXQuIFRoYXQgaXMgbm90IHBvc3NpYmxlIGlmIG5vXG4gICAgICAgKiBtb3JlIHZpZGVvIGlzIGZvcnRoY29taW5nLCBob3dldmVyLiBJbiB0aGF0IGNhc2UsIHNvbWUgb3RoZXJcbiAgICAgICAqIG1lY2hhbmlzbSAobGlrZSB0aGUgZW5kIG9mIHRoZSBmaWxlKSBoYXMgdG8gYmUgZW1wbG95ZWQuIFdoZW4gaXQgaXNcbiAgICAgICAqIGNsZWFyIHRoYXQgbm8gYWRkaXRpb25hbCBkYXRhIGlzIGZvcnRoY29taW5nLCBjYWxsaW5nIHRoaXMgbWV0aG9kXG4gICAgICAgKiB3aWxsIGZsdXNoIHRoZSBidWZmZXJlZCBwYWNrZXRzLlxuICAgICAgICovXG4gICAgICB0aGlzLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAhIVRISVMgT1JERVIgSVMgSU1QT1JUQU5UISFcbiAgICAgICAgLy8gdmlkZW8gZmlyc3QgdGhlbiBhdWRpb1xuICAgICAgICBmbHVzaFN0cmVhbSh2aWRlbywgJ3ZpZGVvJyk7XG4gICAgICAgIGZsdXNoU3RyZWFtKGF1ZGlvLCAnYXVkaW8nKTtcbiAgICAgICAgZmx1c2hTdHJlYW0odGltZWRNZXRhZGF0YSwgJ3RpbWVkLW1ldGFkYXRhJyk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignZG9uZScpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIF9FbGVtZW50YXJ5U3RyZWFtLnByb3RvdHlwZSA9IG5ldyBzdHJlYW0oKTtcblxuICAgIHZhciBtMnRzID0ge1xuICAgICAgUEFUX1BJRDogMHgwMDAwLFxuICAgICAgTVAyVF9QQUNLRVRfTEVOR1RIOiBNUDJUX1BBQ0tFVF9MRU5HVEgsXG4gICAgICBUcmFuc3BvcnRQYWNrZXRTdHJlYW06IF9UcmFuc3BvcnRQYWNrZXRTdHJlYW0sXG4gICAgICBUcmFuc3BvcnRQYXJzZVN0cmVhbTogX1RyYW5zcG9ydFBhcnNlU3RyZWFtLFxuICAgICAgRWxlbWVudGFyeVN0cmVhbTogX0VsZW1lbnRhcnlTdHJlYW0sXG4gICAgICBUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbTogVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0kMSxcbiAgICAgIENhcHRpb25TdHJlYW06IGNhcHRpb25TdHJlYW0uQ2FwdGlvblN0cmVhbSxcbiAgICAgIENlYTYwOFN0cmVhbTogY2FwdGlvblN0cmVhbS5DZWE2MDhTdHJlYW0sXG4gICAgICBNZXRhZGF0YVN0cmVhbTogbWV0YWRhdGFTdHJlYW1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgdHlwZSBpbiBzdHJlYW1UeXBlcykge1xuICAgICAgaWYgKHN0cmVhbVR5cGVzLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgICAgIG0ydHNbdHlwZV0gPSBzdHJlYW1UeXBlc1t0eXBlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbTJ0c18xID0gbTJ0cztcblxuICAgIHZhciBfQWR0c1N0cmVhbTtcblxuICAgIHZhciBBRFRTX1NBTVBMSU5HX0ZSRVFVRU5DSUVTID0gWzk2MDAwLCA4ODIwMCwgNjQwMDAsIDQ4MDAwLCA0NDEwMCwgMzIwMDAsIDI0MDAwLCAyMjA1MCwgMTYwMDAsIDEyMDAwLCAxMTAyNSwgODAwMCwgNzM1MF07XG5cbiAgICAvKlxuICAgICAqIEFjY2VwdHMgYSBFbGVtZW50YXJ5U3RyZWFtIGFuZCBlbWl0cyBkYXRhIGV2ZW50cyB3aXRoIHBhcnNlZFxuICAgICAqIEFBQyBBdWRpbyBGcmFtZXMgb2YgdGhlIGluZGl2aWR1YWwgcGFja2V0cy4gSW5wdXQgYXVkaW8gaW4gQURUU1xuICAgICAqIGZvcm1hdCBpcyB1bnBhY2tlZCBhbmQgcmUtZW1pdHRlZCBhcyBBQUMgZnJhbWVzLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gICAgICogQHNlZSBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4Lz90aXRsZT1VbmRlcnN0YW5kaW5nX0FBQ1xuICAgICAqL1xuICAgIF9BZHRzU3RyZWFtID0gZnVuY3Rpb24gQWR0c1N0cmVhbSgpIHtcbiAgICAgIHZhciBidWZmZXI7XG5cbiAgICAgIF9BZHRzU3RyZWFtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgICAgIHRoaXMucHVzaCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgZnJhbWVOdW0gPSAwLFxuICAgICAgICAgICAgZnJhbWVMZW5ndGgsXG4gICAgICAgICAgICBwcm90ZWN0aW9uU2tpcEJ5dGVzLFxuICAgICAgICAgICAgZnJhbWVFbmQsXG4gICAgICAgICAgICBvbGRCdWZmZXIsXG4gICAgICAgICAgICBzYW1wbGVDb3VudCxcbiAgICAgICAgICAgIGFkdHNGcmFtZUR1cmF0aW9uO1xuXG4gICAgICAgIGlmIChwYWNrZXQudHlwZSAhPT0gJ2F1ZGlvJykge1xuICAgICAgICAgIC8vIGlnbm9yZSBub24tYXVkaW8gZGF0YVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXBlbmQgYW55IGRhdGEgaW4gdGhlIGJ1ZmZlciB0byB0aGUgaW5wdXQgZGF0YSBzbyB0aGF0IHdlIGNhbiBwYXJzZVxuICAgICAgICAvLyBhYWMgZnJhbWVzIHRoZSBjcm9zcyBhIFBFUyBwYWNrZXQgYm91bmRhcnlcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgIG9sZEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheShvbGRCdWZmZXIuYnl0ZUxlbmd0aCArIHBhY2tldC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIGJ1ZmZlci5zZXQob2xkQnVmZmVyKTtcbiAgICAgICAgICBidWZmZXIuc2V0KHBhY2tldC5kYXRhLCBvbGRCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyID0gcGFja2V0LmRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1bnBhY2sgYW55IEFEVFMgZnJhbWVzIHdoaWNoIGhhdmUgYmVlbiBmdWxseSByZWNlaXZlZFxuICAgICAgICAvLyBmb3IgZGV0YWlscyBvbiB0aGUgQURUUyBoZWFkZXIsIHNlZSBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gICAgICAgIHdoaWxlIChpICsgNSA8IGJ1ZmZlci5sZW5ndGgpIHtcblxuICAgICAgICAgIC8vIExvb29rIGZvciB0aGUgc3RhcnQgb2YgYW4gQURUUyBoZWFkZXIuLlxuICAgICAgICAgIGlmIChidWZmZXJbaV0gIT09IDB4RkYgfHwgKGJ1ZmZlcltpICsgMV0gJiAweEY2KSAhPT0gMHhGMCkge1xuICAgICAgICAgICAgLy8gSWYgYSB2YWxpZCBoZWFkZXIgd2FzIG5vdCBmb3VuZCwgIGp1bXAgb25lIGZvcndhcmQgYW5kIGF0dGVtcHQgdG9cbiAgICAgICAgICAgIC8vIGZpbmQgYSB2YWxpZCBBRFRTIGhlYWRlciBzdGFydGluZyBhdCB0aGUgbmV4dCBieXRlXG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUaGUgcHJvdGVjdGlvbiBza2lwIGJpdCB0ZWxscyB1cyBpZiB3ZSBoYXZlIDIgYnl0ZXMgb2YgQ1JDIGRhdGEgYXQgdGhlXG4gICAgICAgICAgLy8gZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuICAgICAgICAgIHByb3RlY3Rpb25Ta2lwQnl0ZXMgPSAofmJ1ZmZlcltpICsgMV0gJiAweDAxKSAqIDI7XG5cbiAgICAgICAgICAvLyBGcmFtZSBsZW5ndGggaXMgYSAxMyBiaXQgaW50ZWdlciBzdGFydGluZyAxNiBiaXRzIGZyb20gdGhlXG4gICAgICAgICAgLy8gZW5kIG9mIHRoZSBzeW5jIHNlcXVlbmNlXG4gICAgICAgICAgZnJhbWVMZW5ndGggPSAoYnVmZmVyW2kgKyAzXSAmIDB4MDMpIDw8IDExIHwgYnVmZmVyW2kgKyA0XSA8PCAzIHwgKGJ1ZmZlcltpICsgNV0gJiAweGUwKSA+PiA1O1xuXG4gICAgICAgICAgc2FtcGxlQ291bnQgPSAoKGJ1ZmZlcltpICsgNl0gJiAweDAzKSArIDEpICogMTAyNDtcbiAgICAgICAgICBhZHRzRnJhbWVEdXJhdGlvbiA9IHNhbXBsZUNvdW50ICogOTAwMDAgLyBBRFRTX1NBTVBMSU5HX0ZSRVFVRU5DSUVTWyhidWZmZXJbaSArIDJdICYgMHgzYykgPj4+IDJdO1xuXG4gICAgICAgICAgZnJhbWVFbmQgPSBpICsgZnJhbWVMZW5ndGg7XG5cbiAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBkYXRhIHRvIGFjdHVhbGx5IGZpbmlzaCB0aGlzIEFEVFMgZnJhbWUsIHJldHVyblxuICAgICAgICAgIC8vIGFuZCB3YWl0IGZvciBtb3JlIGRhdGFcbiAgICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPCBmcmFtZUVuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgZGVsaXZlciB0aGUgY29tcGxldGUgQUFDIGZyYW1lXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywge1xuICAgICAgICAgICAgcHRzOiBwYWNrZXQucHRzICsgZnJhbWVOdW0gKiBhZHRzRnJhbWVEdXJhdGlvbixcbiAgICAgICAgICAgIGR0czogcGFja2V0LmR0cyArIGZyYW1lTnVtICogYWR0c0ZyYW1lRHVyYXRpb24sXG4gICAgICAgICAgICBzYW1wbGVDb3VudDogc2FtcGxlQ291bnQsXG4gICAgICAgICAgICBhdWRpb29iamVjdHR5cGU6IChidWZmZXJbaSArIDJdID4+PiA2ICYgMHgwMykgKyAxLFxuICAgICAgICAgICAgY2hhbm5lbGNvdW50OiAoYnVmZmVyW2kgKyAyXSAmIDEpIDw8IDIgfCAoYnVmZmVyW2kgKyAzXSAmIDB4YzApID4+PiA2LFxuICAgICAgICAgICAgc2FtcGxlcmF0ZTogQURUU19TQU1QTElOR19GUkVRVUVOQ0lFU1soYnVmZmVyW2kgKyAyXSAmIDB4M2MpID4+PiAyXSxcbiAgICAgICAgICAgIHNhbXBsaW5nZnJlcXVlbmN5aW5kZXg6IChidWZmZXJbaSArIDJdICYgMHgzYykgPj4+IDIsXG4gICAgICAgICAgICAvLyBhc3N1bWUgSVNPL0lFQyAxNDQ5Ni0xMiBBdWRpb1NhbXBsZUVudHJ5IGRlZmF1bHQgb2YgMTZcbiAgICAgICAgICAgIHNhbXBsZXNpemU6IDE2LFxuICAgICAgICAgICAgZGF0YTogYnVmZmVyLnN1YmFycmF5KGkgKyA3ICsgcHJvdGVjdGlvblNraXBCeXRlcywgZnJhbWVFbmQpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBJZiB0aGUgYnVmZmVyIGlzIGVtcHR5LCBjbGVhciBpdCBhbmQgcmV0dXJuXG4gICAgICAgICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoID09PSBmcmFtZUVuZCkge1xuICAgICAgICAgICAgYnVmZmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZyYW1lTnVtKys7XG5cbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGZpbmlzaGVkIGZyYW1lIGZyb20gdGhlIGJ1ZmZlciBhbmQgc3RhcnQgdGhlIHByb2Nlc3MgYWdhaW5cbiAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc3ViYXJyYXkoZnJhbWVFbmQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkb25lJyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBfQWR0c1N0cmVhbS5wcm90b3R5cGUgPSBuZXcgc3RyZWFtKCk7XG5cbiAgICB2YXIgYWR0cyA9IF9BZHRzU3RyZWFtO1xuXG4gICAgdmFyIEV4cEdvbG9tYjtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlciBmb3IgZXhwb25lbnRpYWwgR29sb21iIGNvZGVzLCBhIHZhcmlhYmxlLWJpdHdpZHRoIG51bWJlciBlbmNvZGluZ1xuICAgICAqIHNjaGVtZSB1c2VkIGJ5IGgyNjQuXG4gICAgICovXG4gICAgRXhwR29sb21iID0gZnVuY3Rpb24gRXhwR29sb21iKHdvcmtpbmdEYXRhKSB7XG4gICAgICB2YXJcbiAgICAgIC8vIHRoZSBudW1iZXIgb2YgYnl0ZXMgbGVmdCB0byBleGFtaW5lIGluIHdvcmtpbmdEYXRhXG4gICAgICB3b3JraW5nQnl0ZXNBdmFpbGFibGUgPSB3b3JraW5nRGF0YS5ieXRlTGVuZ3RoLFxuXG5cbiAgICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgYmVpbmcgZXhhbWluZWRcbiAgICAgIHdvcmtpbmdXb3JkID0gMCxcblxuXG4gICAgICAvLyA6dWludFxuXG4gICAgICAvLyB0aGUgbnVtYmVyIG9mIGJpdHMgbGVmdCB0byBleGFtaW5lIGluIHRoZSBjdXJyZW50IHdvcmRcbiAgICAgIHdvcmtpbmdCaXRzQXZhaWxhYmxlID0gMDsgLy8gOnVpbnQ7XG5cbiAgICAgIC8vICgpOnVpbnRcbiAgICAgIHRoaXMubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gOCAqIHdvcmtpbmdCeXRlc0F2YWlsYWJsZTtcbiAgICAgIH07XG5cbiAgICAgIC8vICgpOnVpbnRcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDggKiB3b3JraW5nQnl0ZXNBdmFpbGFibGUgKyB3b3JraW5nQml0c0F2YWlsYWJsZTtcbiAgICAgIH07XG5cbiAgICAgIC8vICgpOnZvaWRcbiAgICAgIHRoaXMubG9hZFdvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHdvcmtpbmdEYXRhLmJ5dGVMZW5ndGggLSB3b3JraW5nQnl0ZXNBdmFpbGFibGUsXG4gICAgICAgICAgICB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KSxcbiAgICAgICAgICAgIGF2YWlsYWJsZUJ5dGVzID0gTWF0aC5taW4oNCwgd29ya2luZ0J5dGVzQXZhaWxhYmxlKTtcblxuICAgICAgICBpZiAoYXZhaWxhYmxlQnl0ZXMgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgd29ya2luZ0J5dGVzLnNldCh3b3JraW5nRGF0YS5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBhdmFpbGFibGVCeXRlcykpO1xuICAgICAgICB3b3JraW5nV29yZCA9IG5ldyBEYXRhVmlldyh3b3JraW5nQnl0ZXMuYnVmZmVyKS5nZXRVaW50MzIoMCk7XG5cbiAgICAgICAgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB3b3JraW5nRGF0YSB0aGF0IGhhcyBiZWVuIHByb2Nlc3NlZFxuICAgICAgICB3b3JraW5nQml0c0F2YWlsYWJsZSA9IGF2YWlsYWJsZUJ5dGVzICogODtcbiAgICAgICAgd29ya2luZ0J5dGVzQXZhaWxhYmxlIC09IGF2YWlsYWJsZUJ5dGVzO1xuICAgICAgfTtcblxuICAgICAgLy8gKGNvdW50OmludCk6dm9pZFxuICAgICAgdGhpcy5za2lwQml0cyA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICB2YXIgc2tpcEJ5dGVzOyAvLyA6aW50XG4gICAgICAgIGlmICh3b3JraW5nQml0c0F2YWlsYWJsZSA+IGNvdW50KSB7XG4gICAgICAgICAgd29ya2luZ1dvcmQgPDw9IGNvdW50O1xuICAgICAgICAgIHdvcmtpbmdCaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50IC09IHdvcmtpbmdCaXRzQXZhaWxhYmxlO1xuICAgICAgICAgIHNraXBCeXRlcyA9IE1hdGguZmxvb3IoY291bnQgLyA4KTtcblxuICAgICAgICAgIGNvdW50IC09IHNraXBCeXRlcyAqIDg7XG4gICAgICAgICAgd29ya2luZ0J5dGVzQXZhaWxhYmxlIC09IHNraXBCeXRlcztcblxuICAgICAgICAgIHRoaXMubG9hZFdvcmQoKTtcblxuICAgICAgICAgIHdvcmtpbmdXb3JkIDw8PSBjb3VudDtcbiAgICAgICAgICB3b3JraW5nQml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gKHNpemU6aW50KTp1aW50XG4gICAgICB0aGlzLnJlYWRCaXRzID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgdmFyIGJpdHMgPSBNYXRoLm1pbih3b3JraW5nQml0c0F2YWlsYWJsZSwgc2l6ZSksXG5cblxuICAgICAgICAvLyA6dWludFxuICAgICAgICB2YWx1ID0gd29ya2luZ1dvcmQgPj4+IDMyIC0gYml0czsgLy8gOnVpbnRcbiAgICAgICAgLy8gaWYgc2l6ZSA+IDMxLCBoYW5kbGUgZXJyb3JcbiAgICAgICAgd29ya2luZ0JpdHNBdmFpbGFibGUgLT0gYml0cztcbiAgICAgICAgaWYgKHdvcmtpbmdCaXRzQXZhaWxhYmxlID4gMCkge1xuICAgICAgICAgIHdvcmtpbmdXb3JkIDw8PSBiaXRzO1xuICAgICAgICB9IGVsc2UgaWYgKHdvcmtpbmdCeXRlc0F2YWlsYWJsZSA+IDApIHtcbiAgICAgICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBiaXRzID0gc2l6ZSAtIGJpdHM7XG4gICAgICAgIGlmIChiaXRzID4gMCkge1xuICAgICAgICAgIHJldHVybiB2YWx1IDw8IGJpdHMgfCB0aGlzLnJlYWRCaXRzKGJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1O1xuICAgICAgfTtcblxuICAgICAgLy8gKCk6dWludFxuICAgICAgdGhpcy5za2lwTGVhZGluZ1plcm9zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGVhZGluZ1plcm9Db3VudDsgLy8gOnVpbnRcbiAgICAgICAgZm9yIChsZWFkaW5nWmVyb0NvdW50ID0gMDsgbGVhZGluZ1plcm9Db3VudCA8IHdvcmtpbmdCaXRzQXZhaWxhYmxlOyArK2xlYWRpbmdaZXJvQ291bnQpIHtcbiAgICAgICAgICBpZiAoKHdvcmtpbmdXb3JkICYgMHg4MDAwMDAwMCA+Pj4gbGVhZGluZ1plcm9Db3VudCkgIT09IDApIHtcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBiaXQgb2Ygd29ya2luZyB3b3JkIGlzIDFcbiAgICAgICAgICAgIHdvcmtpbmdXb3JkIDw8PSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICAgICAgd29ya2luZ0JpdHNBdmFpbGFibGUgLT0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIGV4aGF1c3RlZCB3b3JraW5nV29yZCBhbmQgc3RpbGwgaGF2ZSBub3QgZm91bmQgYSAxXG4gICAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQgKyB0aGlzLnNraXBMZWFkaW5nWmVyb3MoKTtcbiAgICAgIH07XG5cbiAgICAgIC8vICgpOnZvaWRcbiAgICAgIHRoaXMuc2tpcFVuc2lnbmVkRXhwR29sb21iID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMZWFkaW5nWmVyb3MoKSk7XG4gICAgICB9O1xuXG4gICAgICAvLyAoKTp2b2lkXG4gICAgICB0aGlzLnNraXBFeHBHb2xvbWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExlYWRpbmdaZXJvcygpKTtcbiAgICAgIH07XG5cbiAgICAgIC8vICgpOnVpbnRcbiAgICAgIHRoaXMucmVhZFVuc2lnbmVkRXhwR29sb21iID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2x6ID0gdGhpcy5za2lwTGVhZGluZ1plcm9zKCk7IC8vIDp1aW50XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGNseiArIDEpIC0gMTtcbiAgICAgIH07XG5cbiAgICAgIC8vICgpOmludFxuICAgICAgdGhpcy5yZWFkRXhwR29sb21iID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdSA9IHRoaXMucmVhZFVuc2lnbmVkRXhwR29sb21iKCk7IC8vIDppbnRcbiAgICAgICAgaWYgKDB4MDEgJiB2YWx1KSB7XG4gICAgICAgICAgLy8gdGhlIG51bWJlciBpcyBvZGQgaWYgdGhlIGxvdyBvcmRlciBiaXQgaXMgc2V0XG4gICAgICAgICAgcmV0dXJuIDEgKyB2YWx1ID4+PiAxOyAvLyBhZGQgMSB0byBtYWtlIGl0IGV2ZW4sIGFuZCBkaXZpZGUgYnkgMlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgICAgIH07XG5cbiAgICAgIC8vIFNvbWUgY29udmVuaWVuY2UgZnVuY3Rpb25zXG4gICAgICAvLyA6Qm9vbGVhblxuICAgICAgdGhpcy5yZWFkQm9vbGVhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMSkgPT09IDE7XG4gICAgICB9O1xuXG4gICAgICAvLyAoKTppbnRcbiAgICAgIHRoaXMucmVhZFVuc2lnbmVkQnl0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoOCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgfTtcblxuICAgIHZhciBleHBHb2xvbWIgPSBFeHBHb2xvbWI7XG5cbiAgICB2YXIgX0gyNjRTdHJlYW0sIF9OYWxCeXRlU3RyZWFtO1xuICAgIHZhciBQUk9GSUxFU19XSVRIX09QVElPTkFMX1NQU19EQVRBO1xuXG4gICAgLyoqXG4gICAgICogQWNjZXB0cyBhIE5BTCB1bml0IGJ5dGUgc3RyZWFtIGFuZCB1bnBhY2tzIHRoZSBlbWJlZGRlZCBOQUwgdW5pdHMuXG4gICAgICovXG4gICAgX05hbEJ5dGVTdHJlYW0gPSBmdW5jdGlvbiBOYWxCeXRlU3RyZWFtKCkge1xuICAgICAgdmFyIHN5bmNQb2ludCA9IDAsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBidWZmZXI7XG4gICAgICBfTmFsQnl0ZVN0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc3dhcEJ1ZmZlcjtcblxuICAgICAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGEuZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2FwQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ5dGVMZW5ndGggKyBkYXRhLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgc3dhcEJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgICBzd2FwQnVmZmVyLnNldChkYXRhLmRhdGEsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICBidWZmZXIgPSBzd2FwQnVmZmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVjLiBJVFUtVCBILjI2NCwgQW5uZXggQlxuICAgICAgICAvLyBzY2FuIGZvciBOQUwgdW5pdCBib3VuZGFyaWVzXG5cbiAgICAgICAgLy8gYSBtYXRjaCBsb29rcyBsaWtlIHRoaXM6XG4gICAgICAgIC8vIDAgMCAxIC4uIE5BTCAuLiAwIDAgMVxuICAgICAgICAvLyBeIHN5bmMgcG9pbnQgICAgICAgIF4gaVxuICAgICAgICAvLyBvciB0aGlzOlxuICAgICAgICAvLyAwIDAgMSAuLiBOQUwgLi4gMCAwIDBcbiAgICAgICAgLy8gXiBzeW5jIHBvaW50ICAgICAgICBeIGlcblxuICAgICAgICAvLyBhZHZhbmNlIHRoZSBzeW5jIHBvaW50IHRvIGEgTkFMIHN0YXJ0LCBpZiBuZWNlc3NhcnlcbiAgICAgICAgZm9yICg7IHN5bmNQb2ludCA8IGJ1ZmZlci5ieXRlTGVuZ3RoIC0gMzsgc3luY1BvaW50KyspIHtcbiAgICAgICAgICBpZiAoYnVmZmVyW3N5bmNQb2ludCArIDJdID09PSAxKSB7XG4gICAgICAgICAgICAvLyB0aGUgc3luYyBwb2ludCBpcyBwcm9wZXJseSBhbGlnbmVkXG4gICAgICAgICAgICBpID0gc3luY1BvaW50ICsgNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpIDwgYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAvLyBsb29rIGF0IHRoZSBjdXJyZW50IGJ5dGUgdG8gZGV0ZXJtaW5lIGlmIHdlJ3ZlIGhpdCB0aGUgZW5kIG9mXG4gICAgICAgICAgLy8gYSBOQUwgdW5pdCBib3VuZGFyeVxuICAgICAgICAgIHN3aXRjaCAoYnVmZmVyW2ldKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIC8vIHNraXAgcGFzdCBub24tc3luYyBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlcltpIC0gMV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyW2kgLSAyXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGRlbGl2ZXIgdGhlIE5BTCB1bml0IGlmIGl0IGlzbid0IGVtcHR5XG4gICAgICAgICAgICAgIGlmIChzeW5jUG9pbnQgKyAzICE9PSBpIC0gMikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGJ1ZmZlci5zdWJhcnJheShzeW5jUG9pbnQgKyAzLCBpIC0gMikpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gZHJvcCB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgfSB3aGlsZSAoYnVmZmVyW2ldICE9PSAxICYmIGkgPCBidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgc3luY1BvaW50ID0gaSAtIDI7XG4gICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIC8vIHNraXAgcGFzdCBub24tc3luYyBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlcltpIC0gMV0gIT09IDAgfHwgYnVmZmVyW2kgLSAyXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGRlbGl2ZXIgdGhlIE5BTCB1bml0XG4gICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGJ1ZmZlci5zdWJhcnJheShzeW5jUG9pbnQgKyAzLCBpIC0gMikpO1xuICAgICAgICAgICAgICBzeW5jUG9pbnQgPSBpIC0gMjtcbiAgICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IGJ5dGUgaXNuJ3QgYSBvbmUgb3IgemVybywgc28gaXQgY2Fubm90IGJlIHBhcnRcbiAgICAgICAgICAgICAgLy8gb2YgYSBzeW5jIHNlcXVlbmNlXG4gICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZpbHRlciBvdXQgdGhlIE5BTCB1bml0cyB0aGF0IHdlcmUgZGVsaXZlcmVkXG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheShzeW5jUG9pbnQpO1xuICAgICAgICBpIC09IHN5bmNQb2ludDtcbiAgICAgICAgc3luY1BvaW50ID0gMDtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGRlbGl2ZXIgdGhlIGxhc3QgYnVmZmVyZWQgTkFMIHVuaXRcbiAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIuYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBidWZmZXIuc3ViYXJyYXkoc3luY1BvaW50ICsgMykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc2V0IHRoZSBzdHJlYW0gc3RhdGVcbiAgICAgICAgYnVmZmVyID0gbnVsbDtcbiAgICAgICAgc3luY1BvaW50ID0gMDtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkb25lJyk7XG4gICAgICB9O1xuICAgIH07XG4gICAgX05hbEJ5dGVTdHJlYW0ucHJvdG90eXBlID0gbmV3IHN0cmVhbSgpO1xuXG4gICAgLy8gdmFsdWVzIG9mIHByb2ZpbGVfaWRjIHRoYXQgaW5kaWNhdGUgYWRkaXRpb25hbCBmaWVsZHMgYXJlIGluY2x1ZGVkIGluIHRoZSBTUFNcbiAgICAvLyBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQgKDQvMjAxMyksXG4gICAgLy8gNy4zLjIuMS4xIFNlcXVlbmNlIHBhcmFtZXRlciBzZXQgZGF0YSBzeW50YXhcbiAgICBQUk9GSUxFU19XSVRIX09QVElPTkFMX1NQU19EQVRBID0ge1xuICAgICAgMTAwOiB0cnVlLFxuICAgICAgMTEwOiB0cnVlLFxuICAgICAgMTIyOiB0cnVlLFxuICAgICAgMjQ0OiB0cnVlLFxuICAgICAgNDQ6IHRydWUsXG4gICAgICA4MzogdHJ1ZSxcbiAgICAgIDg2OiB0cnVlLFxuICAgICAgMTE4OiB0cnVlLFxuICAgICAgMTI4OiB0cnVlLFxuICAgICAgMTM4OiB0cnVlLFxuICAgICAgMTM5OiB0cnVlLFxuICAgICAgMTM0OiB0cnVlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgaW5wdXQgZnJvbSBhIEVsZW1lbnRhcnlTdHJlYW0gYW5kIHByb2R1Y2VzIEguMjY0IE5BTCB1bml0IGRhdGFcbiAgICAgKiBldmVudHMuXG4gICAgICovXG4gICAgX0gyNjRTdHJlYW0gPSBmdW5jdGlvbiBIMjY0U3RyZWFtKCkge1xuICAgICAgdmFyIG5hbEJ5dGVTdHJlYW0gPSBuZXcgX05hbEJ5dGVTdHJlYW0oKSxcbiAgICAgICAgICBzZWxmLFxuICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgY3VycmVudFB0cyxcbiAgICAgICAgICBjdXJyZW50RHRzLFxuICAgICAgICAgIGRpc2NhcmRFbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXMsXG4gICAgICAgICAgcmVhZFNlcXVlbmNlUGFyYW1ldGVyU2V0LFxuICAgICAgICAgIHNraXBTY2FsaW5nTGlzdDtcblxuICAgICAgX0gyNjRTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcbiAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICB0aGlzLnB1c2ggPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICAgIGlmIChwYWNrZXQudHlwZSAhPT0gJ3ZpZGVvJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFja0lkID0gcGFja2V0LnRyYWNrSWQ7XG4gICAgICAgIGN1cnJlbnRQdHMgPSBwYWNrZXQucHRzO1xuICAgICAgICBjdXJyZW50RHRzID0gcGFja2V0LmR0cztcblxuICAgICAgICBuYWxCeXRlU3RyZWFtLnB1c2gocGFja2V0KTtcbiAgICAgIH07XG5cbiAgICAgIG5hbEJ5dGVTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgdHJhY2tJZDogdHJhY2tJZCxcbiAgICAgICAgICBwdHM6IGN1cnJlbnRQdHMsXG4gICAgICAgICAgZHRzOiBjdXJyZW50RHRzLFxuICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGFbMF0gJiAweDFmKSB7XG4gICAgICAgICAgY2FzZSAweDA1OlxuICAgICAgICAgICAgZXZlbnQubmFsVW5pdFR5cGUgPSAnc2xpY2VfbGF5ZXJfd2l0aG91dF9wYXJ0aXRpb25pbmdfcmJzcF9pZHInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDA2OlxuICAgICAgICAgICAgZXZlbnQubmFsVW5pdFR5cGUgPSAnc2VpX3Jic3AnO1xuICAgICAgICAgICAgZXZlbnQuZXNjYXBlZFJCU1AgPSBkaXNjYXJkRW11bGF0aW9uUHJldmVudGlvbkJ5dGVzKGRhdGEuc3ViYXJyYXkoMSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDA3OlxuICAgICAgICAgICAgZXZlbnQubmFsVW5pdFR5cGUgPSAnc2VxX3BhcmFtZXRlcl9zZXRfcmJzcCc7XG4gICAgICAgICAgICBldmVudC5lc2NhcGVkUkJTUCA9IGRpc2NhcmRFbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXMoZGF0YS5zdWJhcnJheSgxKSk7XG4gICAgICAgICAgICBldmVudC5jb25maWcgPSByZWFkU2VxdWVuY2VQYXJhbWV0ZXJTZXQoZXZlbnQuZXNjYXBlZFJCU1ApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDA4OlxuICAgICAgICAgICAgZXZlbnQubmFsVW5pdFR5cGUgPSAncGljX3BhcmFtZXRlcl9zZXRfcmJzcCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MDk6XG4gICAgICAgICAgICBldmVudC5uYWxVbml0VHlwZSA9ICdhY2Nlc3NfdW5pdF9kZWxpbWl0ZXJfcmJzcCc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICB9KTtcbiAgICAgIG5hbEJ5dGVTdHJlYW0ub24oJ2RvbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcignZG9uZScpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5hbEJ5dGVTdHJlYW0uZmx1c2goKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQWR2YW5jZSB0aGUgRXhwR29sb21iIGRlY29kZXIgcGFzdCBhIHNjYWxpbmcgbGlzdC4gVGhlIHNjYWxpbmdcbiAgICAgICAqIGxpc3QgaXMgb3B0aW9uYWxseSB0cmFuc21pdHRlZCBhcyBwYXJ0IG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyXG4gICAgICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cbiAgICAgICAqIEBwYXJhbSBjb3VudCB7bnVtYmVyfSB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhpcyBzY2FsaW5nIGxpc3RcbiAgICAgICAqIEBwYXJhbSBleHBHb2xvbWJEZWNvZGVyIHtvYmplY3R9IGFuIEV4cEdvbG9tYiBwb2ludGVkIHRvIHRoZVxuICAgICAgICogc3RhcnQgb2YgYSBzY2FsaW5nIGxpc3RcbiAgICAgICAqIEBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQsIFNlY3Rpb24gNy4zLjIuMS4xLjFcbiAgICAgICAqL1xuICAgICAgc2tpcFNjYWxpbmdMaXN0ID0gZnVuY3Rpb24gc2tpcFNjYWxpbmdMaXN0KGNvdW50LCBleHBHb2xvbWJEZWNvZGVyKSB7XG4gICAgICAgIHZhciBsYXN0U2NhbGUgPSA4LFxuICAgICAgICAgICAgbmV4dFNjYWxlID0gOCxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBkZWx0YVNjYWxlO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgaWYgKG5leHRTY2FsZSAhPT0gMCkge1xuICAgICAgICAgICAgZGVsdGFTY2FsZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZEV4cEdvbG9tYigpO1xuICAgICAgICAgICAgbmV4dFNjYWxlID0gKGxhc3RTY2FsZSArIGRlbHRhU2NhbGUgKyAyNTYpICUgMjU2O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxhc3RTY2FsZSA9IG5leHRTY2FsZSA9PT0gMCA/IGxhc3RTY2FsZSA6IG5leHRTY2FsZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBFeHB1bmdlIGFueSBcIkVtdWxhdGlvbiBQcmV2ZW50aW9uXCIgYnl0ZXMgZnJvbSBhIFwiUmF3IEJ5dGVcbiAgICAgICAqIFNlcXVlbmNlIFBheWxvYWRcIlxuICAgICAgICogQHBhcmFtIGRhdGEge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiBhIFJCU1AgZnJvbSBhIE5BTFxuICAgICAgICogdW5pdFxuICAgICAgICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIFJCU1Agd2l0aG91dCBhbnkgRW11bGF0aW9uXG4gICAgICAgKiBQcmV2ZW50aW9uIEJ5dGVzXG4gICAgICAgKi9cbiAgICAgIGRpc2NhcmRFbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXMgPSBmdW5jdGlvbiBkaXNjYXJkRW11bGF0aW9uUHJldmVudGlvbkJ5dGVzKGRhdGEpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgIGVtdWxhdGlvblByZXZlbnRpb25CeXRlc1Bvc2l0aW9ucyA9IFtdLFxuICAgICAgICAgICAgaSA9IDEsXG4gICAgICAgICAgICBuZXdMZW5ndGgsXG4gICAgICAgICAgICBuZXdEYXRhO1xuXG4gICAgICAgIC8vIEZpbmQgYWxsIGBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlc2BcbiAgICAgICAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgICAgICAgaWYgKGRhdGFbaV0gPT09IDAgJiYgZGF0YVtpICsgMV0gPT09IDAgJiYgZGF0YVtpICsgMl0gPT09IDB4MDMpIHtcbiAgICAgICAgICAgIGVtdWxhdGlvblByZXZlbnRpb25CeXRlc1Bvc2l0aW9ucy5wdXNoKGkgKyAyKTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIGFycmF5XG4gICAgICAgIGlmIChlbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXNQb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gaG9sZCB0aGUgTkFMIHVuaXQgZGF0YVxuICAgICAgICBuZXdMZW5ndGggPSBsZW5ndGggLSBlbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXNQb3NpdGlvbnMubGVuZ3RoO1xuICAgICAgICBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gMDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcbiAgICAgICAgICBpZiAoc291cmNlSW5kZXggPT09IGVtdWxhdGlvblByZXZlbnRpb25CeXRlc1Bvc2l0aW9uc1swXSkge1xuICAgICAgICAgICAgLy8gU2tpcCB0aGlzIGJ5dGVcbiAgICAgICAgICAgIHNvdXJjZUluZGV4Kys7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuICAgICAgICAgICAgZW11bGF0aW9uUHJldmVudGlvbkJ5dGVzUG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ld0RhdGFbaV0gPSBkYXRhW3NvdXJjZUluZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBSZWFkIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBhbmQgcmV0dXJuIHNvbWUgaW50ZXJlc3RpbmcgdmlkZW9cbiAgICAgICAqIHByb3BlcnRpZXMuIEEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBpcyB0aGUgSDI2NCBtZXRhZGF0YSB0aGF0XG4gICAgICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgICAgICogQHBhcmFtIGRhdGEge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXRcbiAgICAgICAqIEByZXR1cm4ge29iamVjdH0gYW4gb2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBwYXJzZWQgZnJvbSB0aGVcbiAgICAgICAqIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQsIGluY2x1ZGluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcbiAgICAgICAqIGFzc29jaWF0ZWQgdmlkZW8gZnJhbWVzLlxuICAgICAgICovXG4gICAgICByZWFkU2VxdWVuY2VQYXJhbWV0ZXJTZXQgPSBmdW5jdGlvbiByZWFkU2VxdWVuY2VQYXJhbWV0ZXJTZXQoZGF0YSkge1xuICAgICAgICB2YXIgZnJhbWVDcm9wTGVmdE9mZnNldCA9IDAsXG4gICAgICAgICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IDAsXG4gICAgICAgICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSAwLFxuICAgICAgICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIHNhclNjYWxlID0gMSxcbiAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIsXG4gICAgICAgICAgICBwcm9maWxlSWRjLFxuICAgICAgICAgICAgbGV2ZWxJZGMsXG4gICAgICAgICAgICBwcm9maWxlQ29tcGF0aWJpbGl0eSxcbiAgICAgICAgICAgIGNocm9tYUZvcm1hdElkYyxcbiAgICAgICAgICAgIHBpY09yZGVyQ250VHlwZSxcbiAgICAgICAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSxcbiAgICAgICAgICAgIHBpY1dpZHRoSW5NYnNNaW51czEsXG4gICAgICAgICAgICBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxLFxuICAgICAgICAgICAgZnJhbWVNYnNPbmx5RmxhZyxcbiAgICAgICAgICAgIHNjYWxpbmdMaXN0Q291bnQsXG4gICAgICAgICAgICBzYXJSYXRpbyxcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvSWRjLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBleHBHb2xvbWJEZWNvZGVyID0gbmV3IGV4cEdvbG9tYihkYXRhKTtcbiAgICAgICAgcHJvZmlsZUlkYyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkQnl0ZSgpOyAvLyBwcm9maWxlX2lkY1xuICAgICAgICBwcm9maWxlQ29tcGF0aWJpbGl0eSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkQnl0ZSgpOyAvLyBjb25zdHJhaW50X3NldFswLTVdX2ZsYWdcbiAgICAgICAgbGV2ZWxJZGMgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEJ5dGUoKTsgLy8gbGV2ZWxfaWRjIHUoOClcbiAgICAgICAgZXhwR29sb21iRGVjb2Rlci5za2lwVW5zaWduZWRFeHBHb2xvbWIoKTsgLy8gc2VxX3BhcmFtZXRlcl9zZXRfaWRcblxuICAgICAgICAvLyBzb21lIHByb2ZpbGVzIGhhdmUgbW9yZSBvcHRpb25hbCBkYXRhIHdlIGRvbid0IG5lZWRcbiAgICAgICAgaWYgKFBST0ZJTEVTX1dJVEhfT1BUSU9OQUxfU1BTX0RBVEFbcHJvZmlsZUlkY10pIHtcbiAgICAgICAgICBjaHJvbWFGb3JtYXRJZGMgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEV4cEdvbG9tYigpO1xuICAgICAgICAgIGlmIChjaHJvbWFGb3JtYXRJZGMgPT09IDMpIHtcbiAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIuc2tpcEJpdHMoMSk7IC8vIHNlcGFyYXRlX2NvbG91cl9wbGFuZV9mbGFnXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIuc2tpcFVuc2lnbmVkRXhwR29sb21iKCk7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxuICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIuc2tpcFVuc2lnbmVkRXhwR29sb21iKCk7IC8vIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4XG4gICAgICAgICAgZXhwR29sb21iRGVjb2Rlci5za2lwQml0cygxKTsgLy8gcXBwcmltZV95X3plcm9fdHJhbnNmb3JtX2J5cGFzc19mbGFnXG4gICAgICAgICAgaWYgKGV4cEdvbG9tYkRlY29kZXIucmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgICAgLy8gc2VxX3NjYWxpbmdfbWF0cml4X3ByZXNlbnRfZmxhZ1xuICAgICAgICAgICAgc2NhbGluZ0xpc3RDb3VudCA9IGNocm9tYUZvcm1hdElkYyAhPT0gMyA/IDggOiAxMjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FsaW5nTGlzdENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGV4cEdvbG9tYkRlY29kZXIucmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgICAgICAgIC8vIHNlcV9zY2FsaW5nX2xpc3RfcHJlc2VudF9mbGFnWyBpIF1cbiAgICAgICAgICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCgxNiwgZXhwR29sb21iRGVjb2Rlcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCg2NCwgZXhwR29sb21iRGVjb2Rlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwR29sb21iRGVjb2Rlci5za2lwVW5zaWduZWRFeHBHb2xvbWIoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgICAgICBwaWNPcmRlckNudFR5cGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEV4cEdvbG9tYigpO1xuXG4gICAgICAgIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDApIHtcbiAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEV4cEdvbG9tYigpOyAvLyBsb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czRcbiAgICAgICAgfSBlbHNlIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDEpIHtcbiAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnNraXBCaXRzKDEpOyAvLyBkZWx0YV9waWNfb3JkZXJfYWx3YXlzX3plcm9fZmxhZ1xuICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIuc2tpcEV4cEdvbG9tYigpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICAgICAgZXhwR29sb21iRGVjb2Rlci5za2lwRXhwR29sb21iKCk7IC8vIG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZFxuICAgICAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkRXhwR29sb21iKCk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XG4gICAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnNraXBFeHBHb2xvbWIoKTsgLy8gb2Zmc2V0X2Zvcl9yZWZfZnJhbWVbIGkgXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cEdvbG9tYkRlY29kZXIuc2tpcFVuc2lnbmVkRXhwR29sb21iKCk7IC8vIG1heF9udW1fcmVmX2ZyYW1lc1xuICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnNraXBCaXRzKDEpOyAvLyBnYXBzX2luX2ZyYW1lX251bV92YWx1ZV9hbGxvd2VkX2ZsYWdcblxuICAgICAgICBwaWNXaWR0aEluTWJzTWludXMxID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRFeHBHb2xvbWIoKTtcbiAgICAgICAgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkRXhwR29sb21iKCk7XG5cbiAgICAgICAgZnJhbWVNYnNPbmx5RmxhZyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZEJpdHMoMSk7XG4gICAgICAgIGlmIChmcmFtZU1ic09ubHlGbGFnID09PSAwKSB7XG4gICAgICAgICAgZXhwR29sb21iRGVjb2Rlci5za2lwQml0cygxKTsgLy8gbWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZ1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwR29sb21iRGVjb2Rlci5za2lwQml0cygxKTsgLy8gZGlyZWN0Xzh4OF9pbmZlcmVuY2VfZmxhZ1xuICAgICAgICBpZiAoZXhwR29sb21iRGVjb2Rlci5yZWFkQm9vbGVhbigpKSB7XG4gICAgICAgICAgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEV4cEdvbG9tYigpO1xuICAgICAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRFeHBHb2xvbWIoKTtcbiAgICAgICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEV4cEdvbG9tYigpO1xuICAgICAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkRXhwR29sb21iKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cEdvbG9tYkRlY29kZXIucmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgIC8vIHZ1aV9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZ1xuICAgICAgICAgIGlmIChleHBHb2xvbWJEZWNvZGVyLnJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICAgICAgYXNwZWN0UmF0aW9JZGMgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEJ5dGUoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoYXNwZWN0UmF0aW9JZGMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHNhclJhdGlvID0gWzEsIDFdO2JyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgc2FyUmF0aW8gPSBbMTIsIDExXTticmVhaztcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHNhclJhdGlvID0gWzEwLCAxMV07YnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBzYXJSYXRpbyA9IFsxNiwgMTFdO2JyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgc2FyUmF0aW8gPSBbNDAsIDMzXTticmVhaztcbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHNhclJhdGlvID0gWzI0LCAxMV07YnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBzYXJSYXRpbyA9IFsyMCwgMTFdO2JyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgc2FyUmF0aW8gPSBbMzIsIDExXTticmVhaztcbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHNhclJhdGlvID0gWzgwLCAzM107YnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgc2FyUmF0aW8gPSBbMTgsIDExXTticmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBzYXJSYXRpbyA9IFsxNSwgMTFdO2JyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIHNhclJhdGlvID0gWzY0LCAzM107YnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgc2FyUmF0aW8gPSBbMTYwLCA5OV07YnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgc2FyUmF0aW8gPSBbNCwgM107YnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgc2FyUmF0aW8gPSBbMywgMl07YnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgc2FyUmF0aW8gPSBbMiwgMV07YnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMjU1OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHNhclJhdGlvID0gW2V4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkQnl0ZSgpIDw8IDggfCBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEJ5dGUoKSwgZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRCeXRlKCkgPDwgOCB8IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkQnl0ZSgpXTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzYXJSYXRpbykge1xuICAgICAgICAgICAgICBzYXJTY2FsZSA9IHNhclJhdGlvWzBdIC8gc2FyUmF0aW9bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJvZmlsZUlkYzogcHJvZmlsZUlkYyxcbiAgICAgICAgICBsZXZlbElkYzogbGV2ZWxJZGMsXG4gICAgICAgICAgcHJvZmlsZUNvbXBhdGliaWxpdHk6IHByb2ZpbGVDb21wYXRpYmlsaXR5LFxuICAgICAgICAgIHdpZHRoOiBNYXRoLmNlaWwoKChwaWNXaWR0aEluTWJzTWludXMxICsgMSkgKiAxNiAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSAqIHNhclNjYWxlKSxcbiAgICAgICAgICBoZWlnaHQ6ICgyIC0gZnJhbWVNYnNPbmx5RmxhZykgKiAocGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSArIDEpICogMTYgLSBmcmFtZUNyb3BUb3BPZmZzZXQgKiAyIC0gZnJhbWVDcm9wQm90dG9tT2Zmc2V0ICogMlxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICAgIF9IMjY0U3RyZWFtLnByb3RvdHlwZSA9IG5ldyBzdHJlYW0oKTtcblxuICAgIHZhciBoMjY0ID0ge1xuICAgICAgSDI2NFN0cmVhbTogX0gyNjRTdHJlYW0sXG4gICAgICBOYWxCeXRlU3RyZWFtOiBfTmFsQnl0ZVN0cmVhbVxuICAgIH07XG5cbiAgICAvLyBDb25zdGFudHNcbiAgICB2YXIgX0FhY1N0cmVhbTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhbiBpbmNvbWluZyBzdHJlYW0gb2YgYmluYXJ5IGRhdGEgaW50byBBRFRTIGFuZCBJRDMgRnJhbWVzLlxuICAgICAqL1xuXG4gICAgX0FhY1N0cmVhbSA9IGZ1bmN0aW9uIEFhY1N0cmVhbSgpIHtcbiAgICAgIHZhciBldmVyeXRoaW5nID0gbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICB0aW1lU3RhbXAgPSAwO1xuXG4gICAgICBfQWFjU3RyZWFtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgICAgIHRoaXMuc2V0VGltZXN0YW1wID0gZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICB0aW1lU3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnBhcnNlSWQzVGFnU2l6ZSA9IGZ1bmN0aW9uIChoZWFkZXIsIGJ5dGVJbmRleCkge1xuICAgICAgICB2YXIgcmV0dXJuU2l6ZSA9IGhlYWRlcltieXRlSW5kZXggKyA2XSA8PCAyMSB8IGhlYWRlcltieXRlSW5kZXggKyA3XSA8PCAxNCB8IGhlYWRlcltieXRlSW5kZXggKyA4XSA8PCA3IHwgaGVhZGVyW2J5dGVJbmRleCArIDldLFxuICAgICAgICAgICAgZmxhZ3MgPSBoZWFkZXJbYnl0ZUluZGV4ICsgNV0sXG4gICAgICAgICAgICBmb290ZXJQcmVzZW50ID0gKGZsYWdzICYgMTYpID4+IDQ7XG5cbiAgICAgICAgaWYgKGZvb3RlclByZXNlbnQpIHtcbiAgICAgICAgICByZXR1cm4gcmV0dXJuU2l6ZSArIDIwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5TaXplICsgMTA7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnBhcnNlQWR0c1NpemUgPSBmdW5jdGlvbiAoaGVhZGVyLCBieXRlSW5kZXgpIHtcbiAgICAgICAgdmFyIGxvd1RocmVlID0gKGhlYWRlcltieXRlSW5kZXggKyA1XSAmIDB4RTApID4+IDUsXG4gICAgICAgICAgICBtaWRkbGUgPSBoZWFkZXJbYnl0ZUluZGV4ICsgNF0gPDwgMyxcbiAgICAgICAgICAgIGhpZ2hUd28gPSBoZWFkZXJbYnl0ZUluZGV4ICsgM10gJiAweDMgPDwgMTE7XG5cbiAgICAgICAgcmV0dXJuIGhpZ2hUd28gfCBtaWRkbGUgfCBsb3dUaHJlZTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMucHVzaCA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICB2YXIgZnJhbWVTaXplID0gMCxcbiAgICAgICAgICAgIGJ5dGVJbmRleCA9IDAsXG4gICAgICAgICAgICBieXRlc0xlZnQsXG4gICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgIHBhY2tldCxcbiAgICAgICAgICAgIHRlbXBMZW5ndGg7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGJ5dGVzIHJlbWFpbmluZyBmcm9tIHRoZSBsYXN0IHNlZ21lbnQsIHByZXBlbmQgdGhlbSB0byB0aGVcbiAgICAgICAgLy8gYnl0ZXMgdGhhdCB3ZXJlIHB1c2hlZCBpblxuICAgICAgICBpZiAoZXZlcnl0aGluZy5sZW5ndGgpIHtcbiAgICAgICAgICB0ZW1wTGVuZ3RoID0gZXZlcnl0aGluZy5sZW5ndGg7XG4gICAgICAgICAgZXZlcnl0aGluZyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmJ5dGVMZW5ndGggKyB0ZW1wTGVuZ3RoKTtcbiAgICAgICAgICBldmVyeXRoaW5nLnNldChldmVyeXRoaW5nLnN1YmFycmF5KDAsIHRlbXBMZW5ndGgpKTtcbiAgICAgICAgICBldmVyeXRoaW5nLnNldChieXRlcywgdGVtcExlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlcnl0aGluZyA9IGJ5dGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGV2ZXJ5dGhpbmcubGVuZ3RoIC0gYnl0ZUluZGV4ID49IDMpIHtcbiAgICAgICAgICBpZiAoZXZlcnl0aGluZ1tieXRlSW5kZXhdID09PSAnSScuY2hhckNvZGVBdCgwKSAmJiBldmVyeXRoaW5nW2J5dGVJbmRleCArIDFdID09PSAnRCcuY2hhckNvZGVBdCgwKSAmJiBldmVyeXRoaW5nW2J5dGVJbmRleCArIDJdID09PSAnMycuY2hhckNvZGVBdCgwKSkge1xuXG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggdG8gcGFyc2VcbiAgICAgICAgICAgIC8vIHRoZSBJRDMgdGFnIGhlYWRlclxuICAgICAgICAgICAgaWYgKGV2ZXJ5dGhpbmcubGVuZ3RoIC0gYnl0ZUluZGV4IDwgMTApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZyYW1lc2l6ZVxuICAgICAgICAgICAgZnJhbWVTaXplID0gdGhpcy5wYXJzZUlkM1RhZ1NpemUoZXZlcnl0aGluZywgYnl0ZUluZGV4KTtcblxuICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBpbiB0aGUgYnVmZmVyXG4gICAgICAgICAgICAvLyB0byBlbWl0IGEgZnVsbCBwYWNrZXRcbiAgICAgICAgICAgIGlmIChmcmFtZVNpemUgPiBldmVyeXRoaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rID0ge1xuICAgICAgICAgICAgICB0eXBlOiAndGltZWQtbWV0YWRhdGEnLFxuICAgICAgICAgICAgICBkYXRhOiBldmVyeXRoaW5nLnN1YmFycmF5KGJ5dGVJbmRleCwgYnl0ZUluZGV4ICsgZnJhbWVTaXplKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGNodW5rKTtcbiAgICAgICAgICAgIGJ5dGVJbmRleCArPSBmcmFtZVNpemU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZXJ5dGhpbmdbYnl0ZUluZGV4XSAmIDB4ZmYgPT09IDB4ZmYgJiYgKGV2ZXJ5dGhpbmdbYnl0ZUluZGV4ICsgMV0gJiAweGYwKSA9PT0gMHhmMCkge1xuXG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggdG8gcGFyc2VcbiAgICAgICAgICAgIC8vIHRoZSBBRFRTIGZyYW1lIGhlYWRlclxuICAgICAgICAgICAgaWYgKGV2ZXJ5dGhpbmcubGVuZ3RoIC0gYnl0ZUluZGV4IDwgNykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJhbWVTaXplID0gdGhpcy5wYXJzZUFkdHNTaXplKGV2ZXJ5dGhpbmcsIGJ5dGVJbmRleCk7XG5cbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggaW4gdGhlIGJ1ZmZlclxuICAgICAgICAgICAgLy8gdG8gZW1pdCBhIGZ1bGwgcGFja2V0XG4gICAgICAgICAgICBpZiAoZnJhbWVTaXplID4gZXZlcnl0aGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhY2tldCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICAgICAgZGF0YTogZXZlcnl0aGluZy5zdWJhcnJheShieXRlSW5kZXgsIGJ5dGVJbmRleCArIGZyYW1lU2l6ZSksXG4gICAgICAgICAgICAgIHB0czogdGltZVN0YW1wLFxuICAgICAgICAgICAgICBkdHM6IHRpbWVTdGFtcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIHBhY2tldCk7XG4gICAgICAgICAgICBieXRlSW5kZXggKz0gZnJhbWVTaXplO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ5dGVJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzTGVmdCA9IGV2ZXJ5dGhpbmcubGVuZ3RoIC0gYnl0ZUluZGV4O1xuXG4gICAgICAgIGlmIChieXRlc0xlZnQgPiAwKSB7XG4gICAgICAgICAgZXZlcnl0aGluZyA9IGV2ZXJ5dGhpbmcuc3ViYXJyYXkoYnl0ZUluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVyeXRoaW5nID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX0FhY1N0cmVhbS5wcm90b3R5cGUgPSBuZXcgc3RyZWFtKCk7XG5cbiAgICB2YXIgYWFjID0gX0FhY1N0cmVhbTtcblxuICAgIHZhciBoaWdoUHJlZml4ID0gWzMzLCAxNiwgNSwgMzIsIDE2NCwgMjddO1xuICAgIHZhciBsb3dQcmVmaXggPSBbMzMsIDY1LCAxMDgsIDg0LCAxLCAyLCA0LCA4LCAxNjgsIDIsIDQsIDgsIDE3LCAxOTEsIDI1Ml07XG4gICAgdmFyIHplcm9GaWxsID0gZnVuY3Rpb24gemVyb0ZpbGwoY291bnQpIHtcbiAgICAgIHZhciBhID0gW107XG4gICAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgICBhLnB1c2goMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9O1xuXG4gICAgdmFyIG1ha2VUYWJsZSA9IGZ1bmN0aW9uIG1ha2VUYWJsZShtZXRhVGFibGUpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtZXRhVGFibGUpLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBuZXcgVWludDhBcnJheShtZXRhVGFibGVba2V5XS5yZWR1Y2UoZnVuY3Rpb24gKGFyciwgcGFydCkge1xuICAgICAgICAgIHJldHVybiBhcnIuY29uY2F0KHBhcnQpO1xuICAgICAgICB9LCBbXSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSwge30pO1xuICAgIH07XG5cbiAgICAvLyBGcmFtZXMtb2Ytc2lsZW5jZSB0byB1c2UgZm9yIGZpbGxpbmcgaW4gbWlzc2luZyBBQUMgZnJhbWVzXG4gICAgdmFyIGNvbmVPZlNpbGVuY2UgPSB7XG4gICAgICA5NjAwMDogW2hpZ2hQcmVmaXgsIFsyMjcsIDY0XSwgemVyb0ZpbGwoMTU0KSwgWzU2XV0sXG4gICAgICA4ODIwMDogW2hpZ2hQcmVmaXgsIFsyMzFdLCB6ZXJvRmlsbCgxNzApLCBbNTZdXSxcbiAgICAgIDY0MDAwOiBbaGlnaFByZWZpeCwgWzI0OCwgMTkyXSwgemVyb0ZpbGwoMjQwKSwgWzU2XV0sXG4gICAgICA0ODAwMDogW2hpZ2hQcmVmaXgsIFsyNTUsIDE5Ml0sIHplcm9GaWxsKDI2OCksIFs1NSwgMTQ4LCAxMjhdLCB6ZXJvRmlsbCg1NCksIFsxMTJdXSxcbiAgICAgIDQ0MTAwOiBbaGlnaFByZWZpeCwgWzI1NSwgMTkyXSwgemVyb0ZpbGwoMjY4KSwgWzU1LCAxNjMsIDEyOF0sIHplcm9GaWxsKDg0KSwgWzExMl1dLFxuICAgICAgMzIwMDA6IFtoaWdoUHJlZml4LCBbMjU1LCAxOTJdLCB6ZXJvRmlsbCgyNjgpLCBbNTUsIDIzNF0sIHplcm9GaWxsKDIyNiksIFsxMTJdXSxcbiAgICAgIDI0MDAwOiBbaGlnaFByZWZpeCwgWzI1NSwgMTkyXSwgemVyb0ZpbGwoMjY4KSwgWzU1LCAyNTUsIDEyOF0sIHplcm9GaWxsKDI2OCksIFsxMTEsIDExMl0sIHplcm9GaWxsKDEyNiksIFsyMjRdXSxcbiAgICAgIDE2MDAwOiBbaGlnaFByZWZpeCwgWzI1NSwgMTkyXSwgemVyb0ZpbGwoMjY4KSwgWzU1LCAyNTUsIDEyOF0sIHplcm9GaWxsKDI2OCksIFsxMTEsIDI1NV0sIHplcm9GaWxsKDI2OSksIFsyMjMsIDEwOF0sIHplcm9GaWxsKDE5NSksIFsxLCAxOTJdXSxcbiAgICAgIDEyMDAwOiBbbG93UHJlZml4LCB6ZXJvRmlsbCgyNjgpLCBbMywgMTI3LCAyNDhdLCB6ZXJvRmlsbCgyNjgpLCBbNiwgMjU1LCAyNDBdLCB6ZXJvRmlsbCgyNjgpLCBbMTMsIDI1NSwgMjI0XSwgemVyb0ZpbGwoMjY4KSwgWzI3LCAyNTMsIDEyOF0sIHplcm9GaWxsKDI1OSksIFs1Nl1dLFxuICAgICAgMTEwMjU6IFtsb3dQcmVmaXgsIHplcm9GaWxsKDI2OCksIFszLCAxMjcsIDI0OF0sIHplcm9GaWxsKDI2OCksIFs2LCAyNTUsIDI0MF0sIHplcm9GaWxsKDI2OCksIFsxMywgMjU1LCAyMjRdLCB6ZXJvRmlsbCgyNjgpLCBbMjcsIDI1NSwgMTkyXSwgemVyb0ZpbGwoMjY4KSwgWzU1LCAxNzUsIDEyOF0sIHplcm9GaWxsKDEwOCksIFsxMTJdXSxcbiAgICAgIDgwMDA6IFtsb3dQcmVmaXgsIHplcm9GaWxsKDI2OCksIFszLCAxMjEsIDE2XSwgemVyb0ZpbGwoNDcpLCBbN11dXG4gICAgfTtcblxuICAgIHZhciBzaWxlbmNlID0gbWFrZVRhYmxlKGNvbmVPZlNpbGVuY2UpO1xuXG4gICAgdmFyIE9ORV9TRUNPTkRfSU5fVFMgPSA5MDAwMCxcblxuXG4gICAgLy8gOTBrSHogY2xvY2tcbiAgICBzZWNvbmRzVG9WaWRlb1RzLFxuICAgICAgICBzZWNvbmRzVG9BdWRpb1RzLFxuICAgICAgICB2aWRlb1RzVG9TZWNvbmRzLFxuICAgICAgICBhdWRpb1RzVG9TZWNvbmRzLFxuICAgICAgICBhdWRpb1RzVG9WaWRlb1RzLFxuICAgICAgICB2aWRlb1RzVG9BdWRpb1RzO1xuXG4gICAgc2Vjb25kc1RvVmlkZW9UcyA9IGZ1bmN0aW9uIHNlY29uZHNUb1ZpZGVvVHMoc2Vjb25kcykge1xuICAgICAgcmV0dXJuIHNlY29uZHMgKiBPTkVfU0VDT05EX0lOX1RTO1xuICAgIH07XG5cbiAgICBzZWNvbmRzVG9BdWRpb1RzID0gZnVuY3Rpb24gc2Vjb25kc1RvQXVkaW9UcyhzZWNvbmRzLCBzYW1wbGVSYXRlKSB7XG4gICAgICByZXR1cm4gc2Vjb25kcyAqIHNhbXBsZVJhdGU7XG4gICAgfTtcblxuICAgIHZpZGVvVHNUb1NlY29uZHMgPSBmdW5jdGlvbiB2aWRlb1RzVG9TZWNvbmRzKHRpbWVzdGFtcCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcCAvIE9ORV9TRUNPTkRfSU5fVFM7XG4gICAgfTtcblxuICAgIGF1ZGlvVHNUb1NlY29uZHMgPSBmdW5jdGlvbiBhdWRpb1RzVG9TZWNvbmRzKHRpbWVzdGFtcCwgc2FtcGxlUmF0ZSkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcCAvIHNhbXBsZVJhdGU7XG4gICAgfTtcblxuICAgIGF1ZGlvVHNUb1ZpZGVvVHMgPSBmdW5jdGlvbiBhdWRpb1RzVG9WaWRlb1RzKHRpbWVzdGFtcCwgc2FtcGxlUmF0ZSkge1xuICAgICAgcmV0dXJuIHNlY29uZHNUb1ZpZGVvVHMoYXVkaW9Uc1RvU2Vjb25kcyh0aW1lc3RhbXAsIHNhbXBsZVJhdGUpKTtcbiAgICB9O1xuXG4gICAgdmlkZW9Uc1RvQXVkaW9UcyA9IGZ1bmN0aW9uIHZpZGVvVHNUb0F1ZGlvVHModGltZXN0YW1wLCBzYW1wbGVSYXRlKSB7XG4gICAgICByZXR1cm4gc2Vjb25kc1RvQXVkaW9Ucyh2aWRlb1RzVG9TZWNvbmRzKHRpbWVzdGFtcCksIHNhbXBsZVJhdGUpO1xuICAgIH07XG5cbiAgICB2YXIgY2xvY2sgPSB7XG4gICAgICBzZWNvbmRzVG9WaWRlb1RzOiBzZWNvbmRzVG9WaWRlb1RzLFxuICAgICAgc2Vjb25kc1RvQXVkaW9Uczogc2Vjb25kc1RvQXVkaW9UcyxcbiAgICAgIHZpZGVvVHNUb1NlY29uZHM6IHZpZGVvVHNUb1NlY29uZHMsXG4gICAgICBhdWRpb1RzVG9TZWNvbmRzOiBhdWRpb1RzVG9TZWNvbmRzLFxuICAgICAgYXVkaW9Uc1RvVmlkZW9UczogYXVkaW9Uc1RvVmlkZW9UcyxcbiAgICAgIHZpZGVvVHNUb0F1ZGlvVHM6IHZpZGVvVHNUb0F1ZGlvVHNcbiAgICB9O1xuXG4gICAgdmFyIEgyNjRTdHJlYW0gPSBoMjY0LkgyNjRTdHJlYW07XG5cbiAgICAvLyBjb25zdGFudHNcbiAgICB2YXIgQVVESU9fUFJPUEVSVElFUyA9IFsnYXVkaW9vYmplY3R0eXBlJywgJ2NoYW5uZWxjb3VudCcsICdzYW1wbGVyYXRlJywgJ3NhbXBsaW5nZnJlcXVlbmN5aW5kZXgnLCAnc2FtcGxlc2l6ZSddO1xuXG4gICAgdmFyIFZJREVPX1BST1BFUlRJRVMgPSBbJ3dpZHRoJywgJ2hlaWdodCcsICdwcm9maWxlSWRjJywgJ2xldmVsSWRjJywgJ3Byb2ZpbGVDb21wYXRpYmlsaXR5J107XG5cbiAgICB2YXIgT05FX1NFQ09ORF9JTl9UUyQxID0gOTAwMDA7IC8vIDkwa0h6IGNsb2NrXG5cbiAgICAvLyBvYmplY3QgdHlwZXNcbiAgICB2YXIgX1ZpZGVvU2VnbWVudFN0cmVhbSwgX0F1ZGlvU2VnbWVudFN0cmVhbSwgX1RyYW5zbXV4ZXIsIF9Db2FsZXNjZVN0cmVhbTtcblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnNcbiAgICB2YXIgY3JlYXRlRGVmYXVsdFNhbXBsZSwgaXNMaWtlbHlBYWNEYXRhLCBjb2xsZWN0RHRzSW5mbywgY2xlYXJEdHNJbmZvLCBjYWxjdWxhdGVUcmFja0Jhc2VNZWRpYURlY29kZVRpbWUsIGFycmF5RXF1YWxzLCBzdW1GcmFtZUJ5dGVMZW5ndGhzO1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBzYW1wbGUgb2JqZWN0XG4gICAgICogc2VlIElTTy9JRUMgMTQ0OTYtMTI6MjAxMiwgc2VjdGlvbiA4LjYuNC4zXG4gICAgICovXG4gICAgY3JlYXRlRGVmYXVsdFNhbXBsZSA9IGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTYW1wbGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaXplOiAwLFxuICAgICAgICBmbGFnczoge1xuICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICBkZXBlbmRzT246IDEsXG4gICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICAgICAgZGVncmFkYXRpb25Qcmlvcml0eTogMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBpc0xpa2VseUFhY0RhdGEgPSBmdW5jdGlvbiBpc0xpa2VseUFhY0RhdGEoZGF0YSkge1xuICAgICAgaWYgKGRhdGFbMF0gPT09ICdJJy5jaGFyQ29kZUF0KDApICYmIGRhdGFbMV0gPT09ICdEJy5jaGFyQ29kZUF0KDApICYmIGRhdGFbMl0gPT09ICczJy5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHR3byBhcnJheXMgKGV2ZW4gdHlwZWQpIGZvciBzYW1lLW5lc3NcbiAgICAgKi9cbiAgICBhcnJheUVxdWFscyA9IGZ1bmN0aW9uIGFycmF5RXF1YWxzKGEsIGIpIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gY29tcGFyZSB0aGUgdmFsdWUgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1bSB0aGUgYGJ5dGVMZW5ndGhgIHByb3BlcnRpZXMgb2YgdGhlIGRhdGEgaW4gZWFjaCBBQUMgZnJhbWVcbiAgICAgKi9cbiAgICBzdW1GcmFtZUJ5dGVMZW5ndGhzID0gZnVuY3Rpb24gc3VtRnJhbWVCeXRlTGVuZ3RocyhhcnJheSkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgY3VycmVudE9iaixcbiAgICAgICAgICBzdW0gPSAwO1xuXG4gICAgICAvLyBzdW0gdGhlIGJ5dGVMZW5ndGgncyBhbGwgZWFjaCBuYWwgdW5pdCBpbiB0aGUgZnJhbWVcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50T2JqID0gYXJyYXlbaV07XG4gICAgICAgIHN1bSArPSBjdXJyZW50T2JqLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIHNpbmdsZS10cmFjaywgSVNPIEJNRkYgbWVkaWEgc2VnbWVudCBmcm9tIEFBQyBkYXRhXG4gICAgICogZXZlbnRzLiBUaGUgb3V0cHV0IG9mIHRoaXMgc3RyZWFtIGNhbiBiZSBmZWQgdG8gYSBTb3VyY2VCdWZmZXJcbiAgICAgKiBjb25maWd1cmVkIHdpdGggYSBzdWl0YWJsZSBpbml0aWFsaXphdGlvbiBzZWdtZW50LlxuICAgICAqIEBwYXJhbSB0cmFjayB7b2JqZWN0fSB0cmFjayBtZXRhZGF0YSBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH0gdHJhbnNtdXhlciBvcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmtlZXBPcmlnaW5hbFRpbWVzdGFtcHMge2Jvb2xlYW59IElmIHRydWUsIGtlZXAgdGhlIHRpbWVzdGFtcHNcbiAgICAgKiAgICAgICAgaW4gdGhlIHNvdXJjZTsgZmFsc2UgdG8gYWRqdXN0IHRoZSBmaXJzdCBzZWdtZW50IHRvIHN0YXJ0IGF0IDAuXG4gICAgICovXG4gICAgX0F1ZGlvU2VnbWVudFN0cmVhbSA9IGZ1bmN0aW9uIEF1ZGlvU2VnbWVudFN0cmVhbSh0cmFjaywgb3B0aW9ucykge1xuICAgICAgdmFyIGFkdHNGcmFtZXMgPSBbXSxcbiAgICAgICAgICBzZXF1ZW5jZU51bWJlciA9IDAsXG4gICAgICAgICAgZWFybGllc3RBbGxvd2VkRHRzID0gMCxcbiAgICAgICAgICBhdWRpb0FwcGVuZFN0YXJ0VHMgPSAwLFxuICAgICAgICAgIHZpZGVvQmFzZU1lZGlhRGVjb2RlVGltZSA9IEluZmluaXR5O1xuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgX0F1ZGlvU2VnbWVudFN0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBjb2xsZWN0RHRzSW5mbyh0cmFjaywgZGF0YSk7XG5cbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgQVVESU9fUFJPUEVSVElFUy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB0cmFja1twcm9wXSA9IGRhdGFbcHJvcF07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWZmZXIgYXVkaW8gZGF0YSB1bnRpbCBlbmQoKSBpcyBjYWxsZWRcbiAgICAgICAgYWR0c0ZyYW1lcy5wdXNoKGRhdGEpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5zZXRFYXJsaWVzdER0cyA9IGZ1bmN0aW9uIChlYXJsaWVzdER0cykge1xuICAgICAgICBlYXJsaWVzdEFsbG93ZWREdHMgPSBlYXJsaWVzdER0cyAtIHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmJhc2VNZWRpYURlY29kZVRpbWU7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnNldFZpZGVvQmFzZU1lZGlhRGVjb2RlVGltZSA9IGZ1bmN0aW9uIChiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgICAgIHZpZGVvQmFzZU1lZGlhRGVjb2RlVGltZSA9IGJhc2VNZWRpYURlY29kZVRpbWU7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnNldEF1ZGlvQXBwZW5kU3RhcnQgPSBmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgIGF1ZGlvQXBwZW5kU3RhcnRUcyA9IHRpbWVzdGFtcDtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmcmFtZXMsIG1vb2YsIG1kYXQsIGJveGVzO1xuXG4gICAgICAgIC8vIHJldHVybiBlYXJseSBpZiBubyBhdWRpbyBkYXRhIGhhcyBiZWVuIG9ic2VydmVkXG4gICAgICAgIGlmIChhZHRzRnJhbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignZG9uZScsICdBdWRpb1NlZ21lbnRTdHJlYW0nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmcmFtZXMgPSB0aGlzLnRyaW1BZHRzRnJhbWVzQnlFYXJsaWVzdER0c18oYWR0c0ZyYW1lcyk7XG4gICAgICAgIHRyYWNrLmJhc2VNZWRpYURlY29kZVRpbWUgPSBjYWxjdWxhdGVUcmFja0Jhc2VNZWRpYURlY29kZVRpbWUodHJhY2ssIG9wdGlvbnMua2VlcE9yaWdpbmFsVGltZXN0YW1wcyk7XG5cbiAgICAgICAgdGhpcy5wcmVmaXhXaXRoU2lsZW5jZV8odHJhY2ssIGZyYW1lcyk7XG5cbiAgICAgICAgLy8gd2UgaGF2ZSB0byBidWlsZCB0aGUgaW5kZXggZnJvbSBieXRlIGxvY2F0aW9ucyB0b1xuICAgICAgICAvLyBzYW1wbGVzICh0aGF0IGlzLCBhZHRzIGZyYW1lcykgaW4gdGhlIGF1ZGlvIGRhdGFcbiAgICAgICAgdHJhY2suc2FtcGxlcyA9IHRoaXMuZ2VuZXJhdGVTYW1wbGVUYWJsZV8oZnJhbWVzKTtcblxuICAgICAgICAvLyBjb25jYXRlbmF0ZSB0aGUgYXVkaW8gZGF0YSB0byBjb25zdHVjdCB0aGUgbWRhdFxuICAgICAgICBtZGF0ID0gbXA0R2VuZXJhdG9yLm1kYXQodGhpcy5jb25jYXRlbmF0ZUZyYW1lRGF0YV8oZnJhbWVzKSk7XG5cbiAgICAgICAgYWR0c0ZyYW1lcyA9IFtdO1xuXG4gICAgICAgIG1vb2YgPSBtcDRHZW5lcmF0b3IubW9vZihzZXF1ZW5jZU51bWJlciwgW3RyYWNrXSk7XG4gICAgICAgIGJveGVzID0gbmV3IFVpbnQ4QXJyYXkobW9vZi5ieXRlTGVuZ3RoICsgbWRhdC5ieXRlTGVuZ3RoKTtcblxuICAgICAgICAvLyBidW1wIHRoZSBzZXF1ZW5jZSBudW1iZXIgZm9yIG5leHQgdGltZVxuICAgICAgICBzZXF1ZW5jZU51bWJlcisrO1xuXG4gICAgICAgIGJveGVzLnNldChtb29mKTtcbiAgICAgICAgYm94ZXMuc2V0KG1kYXQsIG1vb2YuYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgY2xlYXJEdHNJbmZvKHRyYWNrKTtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7IHRyYWNrOiB0cmFjaywgYm94ZXM6IGJveGVzIH0pO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnLCAnQXVkaW9TZWdtZW50U3RyZWFtJyk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQb3NzaWJseSBwYWQgKHByZWZpeCkgdGhlIGF1ZGlvIHRyYWNrIHdpdGggc2lsZW5jZSBpZiBhcHBlbmRpbmcgdGhpcyB0cmFja1xuICAgICAgLy8gd291bGQgbGVhZCB0byB0aGUgaW50cm9kdWN0aW9uIG9mIGEgZ2FwIGluIHRoZSBhdWRpbyBidWZmZXJcbiAgICAgIHRoaXMucHJlZml4V2l0aFNpbGVuY2VfID0gZnVuY3Rpb24gKHRyYWNrLCBmcmFtZXMpIHtcbiAgICAgICAgdmFyIGJhc2VNZWRpYURlY29kZVRpbWVUcyxcbiAgICAgICAgICAgIGZyYW1lRHVyYXRpb24gPSAwLFxuICAgICAgICAgICAgYXVkaW9HYXBEdXJhdGlvbiA9IDAsXG4gICAgICAgICAgICBhdWRpb0ZpbGxGcmFtZUNvdW50ID0gMCxcbiAgICAgICAgICAgIGF1ZGlvRmlsbER1cmF0aW9uID0gMCxcbiAgICAgICAgICAgIHNpbGVudEZyYW1lLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBpZiAoIWZyYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lVHMgPSBjbG9jay5hdWRpb1RzVG9WaWRlb1RzKHRyYWNrLmJhc2VNZWRpYURlY29kZVRpbWUsIHRyYWNrLnNhbXBsZXJhdGUpO1xuICAgICAgICAvLyBkZXRlcm1pbmUgZnJhbWUgY2xvY2sgZHVyYXRpb24gYmFzZWQgb24gc2FtcGxlIHJhdGUsIHJvdW5kIHVwIHRvIGF2b2lkIG92ZXJmaWxsc1xuICAgICAgICBmcmFtZUR1cmF0aW9uID0gTWF0aC5jZWlsKE9ORV9TRUNPTkRfSU5fVFMkMSAvICh0cmFjay5zYW1wbGVyYXRlIC8gMTAyNCkpO1xuXG4gICAgICAgIGlmIChhdWRpb0FwcGVuZFN0YXJ0VHMgJiYgdmlkZW9CYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgICAgICAgLy8gaW5zZXJ0IHRoZSBzaG9ydGVzdCBwb3NzaWJsZSBhbW91bnQgKGF1ZGlvIGdhcCBvciBhdWRpbyB0byB2aWRlbyBnYXApXG4gICAgICAgICAgYXVkaW9HYXBEdXJhdGlvbiA9IGJhc2VNZWRpYURlY29kZVRpbWVUcyAtIE1hdGgubWF4KGF1ZGlvQXBwZW5kU3RhcnRUcywgdmlkZW9CYXNlTWVkaWFEZWNvZGVUaW1lKTtcbiAgICAgICAgICAvLyBudW1iZXIgb2YgZnVsbCBmcmFtZXMgaW4gdGhlIGF1ZGlvIGdhcFxuICAgICAgICAgIGF1ZGlvRmlsbEZyYW1lQ291bnQgPSBNYXRoLmZsb29yKGF1ZGlvR2FwRHVyYXRpb24gLyBmcmFtZUR1cmF0aW9uKTtcbiAgICAgICAgICBhdWRpb0ZpbGxEdXJhdGlvbiA9IGF1ZGlvRmlsbEZyYW1lQ291bnQgKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uJ3QgYXR0ZW1wdCB0byBmaWxsIGdhcHMgc21hbGxlciB0aGFuIGEgc2luZ2xlIGZyYW1lIG9yIGxhcmdlclxuICAgICAgICAvLyB0aGFuIGEgaGFsZiBzZWNvbmRcbiAgICAgICAgaWYgKGF1ZGlvRmlsbEZyYW1lQ291bnQgPCAxIHx8IGF1ZGlvRmlsbER1cmF0aW9uID4gT05FX1NFQ09ORF9JTl9UUyQxIC8gMikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpbGVudEZyYW1lID0gc2lsZW5jZVt0cmFjay5zYW1wbGVyYXRlXTtcblxuICAgICAgICBpZiAoIXNpbGVudEZyYW1lKSB7XG4gICAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSBhIHNpbGVudCBmcmFtZSBwcmVnZW5lcmF0ZWQgZm9yIHRoZSBzYW1wbGUgcmF0ZSwgc28gdXNlIGEgZnJhbWVcbiAgICAgICAgICAvLyBmcm9tIHRoZSBjb250ZW50IGluc3RlYWRcbiAgICAgICAgICBzaWxlbnRGcmFtZSA9IGZyYW1lc1swXS5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF1ZGlvRmlsbEZyYW1lQ291bnQ7IGkrKykge1xuICAgICAgICAgIGZyYW1lcy5zcGxpY2UoaSwgMCwge1xuICAgICAgICAgICAgZGF0YTogc2lsZW50RnJhbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNrLmJhc2VNZWRpYURlY29kZVRpbWUgLT0gTWF0aC5mbG9vcihjbG9jay52aWRlb1RzVG9BdWRpb1RzKGF1ZGlvRmlsbER1cmF0aW9uLCB0cmFjay5zYW1wbGVyYXRlKSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJZiB0aGUgYXVkaW8gc2VnbWVudCBleHRlbmRzIGJlZm9yZSB0aGUgZWFybGllc3QgYWxsb3dlZCBkdHNcbiAgICAgIC8vIHZhbHVlLCByZW1vdmUgQUFDIGZyYW1lcyB1bnRpbCBzdGFydHMgYXQgb3IgYWZ0ZXIgdGhlIGVhcmxpZXN0XG4gICAgICAvLyBhbGxvd2VkIERUUyBzbyB0aGF0IHdlIGRvbid0IGVuZCB1cCB3aXRoIGEgbmVnYXRpdmUgYmFzZU1lZGlhLVxuICAgICAgLy8gRGVjb2RlVGltZSBmb3IgdGhlIGF1ZGlvIHRyYWNrXG4gICAgICB0aGlzLnRyaW1BZHRzRnJhbWVzQnlFYXJsaWVzdER0c18gPSBmdW5jdGlvbiAoYWR0c0ZyYW1lcykge1xuICAgICAgICBpZiAodHJhY2subWluU2VnbWVudER0cyA+PSBlYXJsaWVzdEFsbG93ZWREdHMpIHtcbiAgICAgICAgICByZXR1cm4gYWR0c0ZyYW1lcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIHdpbGwgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgZWFybGllc3Qgc2VnbWVudCBEdHNcbiAgICAgICAgdHJhY2subWluU2VnbWVudER0cyA9IEluZmluaXR5O1xuXG4gICAgICAgIHJldHVybiBhZHRzRnJhbWVzLmZpbHRlcihmdW5jdGlvbiAoY3VycmVudEZyYW1lKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBhbGxvd2VkIGZyYW1lLCBrZWVwIGl0IGFuZCByZWNvcmQgaXQncyBEdHNcbiAgICAgICAgICBpZiAoY3VycmVudEZyYW1lLmR0cyA+PSBlYXJsaWVzdEFsbG93ZWREdHMpIHtcbiAgICAgICAgICAgIHRyYWNrLm1pblNlZ21lbnREdHMgPSBNYXRoLm1pbih0cmFjay5taW5TZWdtZW50RHRzLCBjdXJyZW50RnJhbWUuZHRzKTtcbiAgICAgICAgICAgIHRyYWNrLm1pblNlZ21lbnRQdHMgPSB0cmFjay5taW5TZWdtZW50RHRzO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgZGlzY2FyZCBpdFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBnZW5lcmF0ZSB0aGUgdHJhY2sncyByYXcgbWRhdCBkYXRhIGZyb20gYW4gYXJyYXkgb2YgZnJhbWVzXG4gICAgICB0aGlzLmdlbmVyYXRlU2FtcGxlVGFibGVfID0gZnVuY3Rpb24gKGZyYW1lcykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGN1cnJlbnRGcmFtZSxcbiAgICAgICAgICAgIHNhbXBsZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudEZyYW1lID0gZnJhbWVzW2ldO1xuICAgICAgICAgIHNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICBzaXplOiBjdXJyZW50RnJhbWUuZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgZHVyYXRpb246IDEwMjQgLy8gRm9yIEFBQyBhdWRpbywgYWxsIHNhbXBsZXMgY29udGFpbiAxMDI0IHNhbXBsZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FtcGxlcztcbiAgICAgIH07XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSB0cmFjaydzIHNhbXBsZSB0YWJsZSBmcm9tIGFuIGFycmF5IG9mIGZyYW1lc1xuICAgICAgdGhpcy5jb25jYXRlbmF0ZUZyYW1lRGF0YV8gPSBmdW5jdGlvbiAoZnJhbWVzKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgY3VycmVudEZyYW1lLFxuICAgICAgICAgICAgZGF0YU9mZnNldCA9IDAsXG4gICAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3VtRnJhbWVCeXRlTGVuZ3RocyhmcmFtZXMpKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudEZyYW1lID0gZnJhbWVzW2ldO1xuXG4gICAgICAgICAgZGF0YS5zZXQoY3VycmVudEZyYW1lLmRhdGEsIGRhdGFPZmZzZXQpO1xuICAgICAgICAgIGRhdGFPZmZzZXQgKz0gY3VycmVudEZyYW1lLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF9BdWRpb1NlZ21lbnRTdHJlYW0ucHJvdG90eXBlID0gbmV3IHN0cmVhbSgpO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIHNpbmdsZS10cmFjaywgSVNPIEJNRkYgbWVkaWEgc2VnbWVudCBmcm9tIEgyNjQgZGF0YVxuICAgICAqIGV2ZW50cy4gVGhlIG91dHB1dCBvZiB0aGlzIHN0cmVhbSBjYW4gYmUgZmVkIHRvIGEgU291cmNlQnVmZmVyXG4gICAgICogY29uZmlndXJlZCB3aXRoIGEgc3VpdGFibGUgaW5pdGlhbGl6YXRpb24gc2VnbWVudC5cbiAgICAgKiBAcGFyYW0gdHJhY2sge29iamVjdH0gdHJhY2sgbWV0YWRhdGEgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9IHRyYW5zbXV4ZXIgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbGlnbkdvcHNBdEVuZCB7Ym9vbGVhbn0gSWYgdHJ1ZSwgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZVxuICAgICAqICAgICAgICBnb3BzVG9BbGlnbldpdGggbGlzdCB3aGVuIGF0dGVtcHRpbmcgdG8gYWxpZ24gZ29wIHB0c1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmtlZXBPcmlnaW5hbFRpbWVzdGFtcHMge2Jvb2xlYW59IElmIHRydWUsIGtlZXAgdGhlIHRpbWVzdGFtcHNcbiAgICAgKiAgICAgICAgaW4gdGhlIHNvdXJjZTsgZmFsc2UgdG8gYWRqdXN0IHRoZSBmaXJzdCBzZWdtZW50IHRvIHN0YXJ0IGF0IDAuXG4gICAgICovXG4gICAgX1ZpZGVvU2VnbWVudFN0cmVhbSA9IGZ1bmN0aW9uIFZpZGVvU2VnbWVudFN0cmVhbSh0cmFjaywgb3B0aW9ucykge1xuICAgICAgdmFyIHNlcXVlbmNlTnVtYmVyID0gMCxcbiAgICAgICAgICBuYWxVbml0cyA9IFtdLFxuICAgICAgICAgIGdvcHNUb0FsaWduV2l0aCA9IFtdLFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBwcHM7XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICBfVmlkZW9TZWdtZW50U3RyZWFtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgICAgIGRlbGV0ZSB0cmFjay5taW5QVFM7XG5cbiAgICAgIHRoaXMuZ29wQ2FjaGVfID0gW107XG5cbiAgICAgIHRoaXMucHVzaCA9IGZ1bmN0aW9uIChuYWxVbml0KSB7XG4gICAgICAgIGNvbGxlY3REdHNJbmZvKHRyYWNrLCBuYWxVbml0KTtcblxuICAgICAgICAvLyByZWNvcmQgdGhlIHRyYWNrIGNvbmZpZ1xuICAgICAgICBpZiAobmFsVW5pdC5uYWxVbml0VHlwZSA9PT0gJ3NlcV9wYXJhbWV0ZXJfc2V0X3Jic3AnICYmICFjb25maWcpIHtcbiAgICAgICAgICBjb25maWcgPSBuYWxVbml0LmNvbmZpZztcbiAgICAgICAgICB0cmFjay5zcHMgPSBbbmFsVW5pdC5kYXRhXTtcblxuICAgICAgICAgIFZJREVPX1BST1BFUlRJRVMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdHJhY2tbcHJvcF0gPSBjb25maWdbcHJvcF07XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFsVW5pdC5uYWxVbml0VHlwZSA9PT0gJ3BpY19wYXJhbWV0ZXJfc2V0X3Jic3AnICYmICFwcHMpIHtcbiAgICAgICAgICBwcHMgPSBuYWxVbml0LmRhdGE7XG4gICAgICAgICAgdHJhY2sucHBzID0gW25hbFVuaXQuZGF0YV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWZmZXIgdmlkZW8gdW50aWwgZmx1c2goKSBpcyBjYWxsZWRcbiAgICAgICAgbmFsVW5pdHMucHVzaChuYWxVbml0KTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmcmFtZXMsIGdvcEZvckZ1c2lvbiwgZ29wcywgbW9vZiwgbWRhdCwgYm94ZXM7XG5cbiAgICAgICAgLy8gVGhyb3cgYXdheSBuYWxVbml0cyBhdCB0aGUgc3RhcnQgb2YgdGhlIGJ5dGUgc3RyZWFtIHVudGlsXG4gICAgICAgIC8vIHdlIGZpbmQgdGhlIGZpcnN0IEFVRFxuICAgICAgICB3aGlsZSAobmFsVW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG5hbFVuaXRzWzBdLm5hbFVuaXRUeXBlID09PSAnYWNjZXNzX3VuaXRfZGVsaW1pdGVyX3Jic3AnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbmFsVW5pdHMuc2hpZnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiBlYXJseSBpZiBubyB2aWRlbyBkYXRhIGhhcyBiZWVuIG9ic2VydmVkXG4gICAgICAgIGlmIChuYWxVbml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RyZWFtXygpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignZG9uZScsICdWaWRlb1NlZ21lbnRTdHJlYW0nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcmdhbml6ZSB0aGUgcmF3IG5hbC11bml0cyBpbnRvIGFycmF5cyB0aGF0IHJlcHJlc2VudFxuICAgICAgICAvLyBoaWdoZXItbGV2ZWwgY29uc3RydWN0cyBzdWNoIGFzIGZyYW1lcyBhbmQgZ29wc1xuICAgICAgICAvLyAoZ3JvdXAtb2YtcGljdHVyZXMpXG4gICAgICAgIGZyYW1lcyA9IHRoaXMuZ3JvdXBOYWxzSW50b0ZyYW1lc18obmFsVW5pdHMpO1xuICAgICAgICBnb3BzID0gdGhpcy5ncm91cEZyYW1lc0ludG9Hb3BzXyhmcmFtZXMpO1xuXG4gICAgICAgIC8vIElmIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGlzIGZyYWdtZW50IGlzIG5vdCBhIGtleWZyYW1lIHdlIGhhdmVcbiAgICAgICAgLy8gYSBwcm9ibGVtIHNpbmNlIE1TRSAob24gQ2hyb21lKSByZXF1aXJlcyBhIGxlYWRpbmcga2V5ZnJhbWUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIGhhdmUgdHdvIGFwcHJvYWNoZXMgdG8gcmVwYWlyaW5nIHRoaXMgc2l0dWF0aW9uOlxuICAgICAgICAvLyAxKSBHT1AtRlVTSU9OOlxuICAgICAgICAvLyAgICBUaGlzIGlzIHdoZXJlIHdlIGtlZXAgdHJhY2sgb2YgdGhlIEdPUFMgKGdyb3VwLW9mLXBpY3R1cmVzKVxuICAgICAgICAvLyAgICBmcm9tIHByZXZpb3VzIGZyYWdtZW50cyBhbmQgYXR0ZW1wdCB0byBmaW5kIG9uZSB0aGF0IHdlIGNhblxuICAgICAgICAvLyAgICBwcmVwZW5kIHRvIHRoZSBjdXJyZW50IGZyYWdtZW50IGluIG9yZGVyIHRvIGNyZWF0ZSBhIHZhbGlkXG4gICAgICAgIC8vICAgIGZyYWdtZW50LlxuICAgICAgICAvLyAyKSBLRVlGUkFNRS1QVUxMSU5HOlxuICAgICAgICAvLyAgICBIZXJlIHdlIHNlYXJjaCBmb3IgdGhlIGZpcnN0IGtleWZyYW1lIGluIHRoZSBmcmFnbWVudCBhbmRcbiAgICAgICAgLy8gICAgdGhyb3cgYXdheSBhbGwgdGhlIGZyYW1lcyBiZXR3ZWVuIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnRcbiAgICAgICAgLy8gICAgYW5kIHRoYXQga2V5ZnJhbWUuIFdlIHRoZW4gZXh0ZW5kIHRoZSBkdXJhdGlvbiBhbmQgcHVsbCB0aGVcbiAgICAgICAgLy8gICAgUFRTIG9mIHRoZSBrZXlmcmFtZSBmb3J3YXJkIHNvIHRoYXQgaXQgY292ZXJzIHRoZSB0aW1lIHJhbmdlXG4gICAgICAgIC8vICAgIG9mIHRoZSBmcmFtZXMgdGhhdCB3ZXJlIGRpc3Bvc2VkIG9mLlxuICAgICAgICAvL1xuICAgICAgICAvLyAjMSBpcyBmYXIgcHJlZmVyZWFibGUgb3ZlciAjMiB3aGljaCBjYW4gY2F1c2UgXCJzdHV0dGVyaW5nXCIgYnV0XG4gICAgICAgIC8vIHJlcXVpcmVzIG1vcmUgdGhpbmdzIHRvIGJlIGp1c3QgcmlnaHQuXG4gICAgICAgIGlmICghZ29wc1swXVswXS5rZXlGcmFtZSkge1xuICAgICAgICAgIC8vIFNlYXJjaCBmb3IgYSBnb3AgZm9yIGZ1c2lvbiBmcm9tIG91ciBnb3BDYWNoZVxuICAgICAgICAgIGdvcEZvckZ1c2lvbiA9IHRoaXMuZ2V0R29wRm9yRnVzaW9uXyhuYWxVbml0c1swXSwgdHJhY2spO1xuXG4gICAgICAgICAgaWYgKGdvcEZvckZ1c2lvbikge1xuICAgICAgICAgICAgZ29wcy51bnNoaWZ0KGdvcEZvckZ1c2lvbik7XG4gICAgICAgICAgICAvLyBBZGp1c3QgR29wcycgbWV0YWRhdGEgdG8gYWNjb3VudCBmb3IgdGhlIGluY2x1c2lvbiBvZiB0aGVcbiAgICAgICAgICAgIC8vIG5ldyBnb3AgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgICAgZ29wcy5ieXRlTGVuZ3RoICs9IGdvcEZvckZ1c2lvbi5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgZ29wcy5uYWxDb3VudCArPSBnb3BGb3JGdXNpb24ubmFsQ291bnQ7XG4gICAgICAgICAgICBnb3BzLnB0cyA9IGdvcEZvckZ1c2lvbi5wdHM7XG4gICAgICAgICAgICBnb3BzLmR0cyA9IGdvcEZvckZ1c2lvbi5kdHM7XG4gICAgICAgICAgICBnb3BzLmR1cmF0aW9uICs9IGdvcEZvckZ1c2lvbi5kdXJhdGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYSBjYW5kaWRhdGUgZ29wIGZhbGwgYmFjayB0byBrZXlmcmFtZS1wdWxsaW5nXG4gICAgICAgICAgICBnb3BzID0gdGhpcy5leHRlbmRGaXJzdEtleUZyYW1lXyhnb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmltIGdvcHMgdG8gYWxpZ24gd2l0aCBnb3BzVG9BbGlnbldpdGhcbiAgICAgICAgaWYgKGdvcHNUb0FsaWduV2l0aC5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgYWxpZ25lZEdvcHM7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5hbGlnbkdvcHNBdEVuZCkge1xuICAgICAgICAgICAgYWxpZ25lZEdvcHMgPSB0aGlzLmFsaWduR29wc0F0RW5kXyhnb3BzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxpZ25lZEdvcHMgPSB0aGlzLmFsaWduR29wc0F0U3RhcnRfKGdvcHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYWxpZ25lZEdvcHMpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYWxsIHRoZSBuYWxzIGluIHRoZSBsYXN0IEdPUCBpbnRvIHRoZSBnb3AgY2FjaGVcbiAgICAgICAgICAgIHRoaXMuZ29wQ2FjaGVfLnVuc2hpZnQoe1xuICAgICAgICAgICAgICBnb3A6IGdvcHMucG9wKCksXG4gICAgICAgICAgICAgIHBwczogdHJhY2sucHBzLFxuICAgICAgICAgICAgICBzcHM6IHRyYWNrLnNwc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEtlZXAgYSBtYXhpbXVtIG9mIDYgR09QcyBpbiB0aGUgY2FjaGVcbiAgICAgICAgICAgIHRoaXMuZ29wQ2FjaGVfLmxlbmd0aCA9IE1hdGgubWluKDYsIHRoaXMuZ29wQ2FjaGVfLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIENsZWFyIG5hbFVuaXRzXG4gICAgICAgICAgICBuYWxVbml0cyA9IFtdO1xuXG4gICAgICAgICAgICAvLyByZXR1cm4gZWFybHkgbm8gZ29wcyBjYW4gYmUgYWxpZ25lZCB3aXRoIGRlc2lyZWQgZ29wc1RvQWxpZ25XaXRoXG4gICAgICAgICAgICB0aGlzLnJlc2V0U3RyZWFtXygpO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdkb25lJywgJ1ZpZGVvU2VnbWVudFN0cmVhbScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNvbWUgZ29wcyB3ZXJlIHRyaW1tZWQuIGNsZWFyIGR0cyBpbmZvIHNvIG1pblNlZ21lbnREdHMgYW5kIHB0cyBhcmUgY29ycmVjdFxuICAgICAgICAgIC8vIHdoZW4gcmVjYWxjdWxhdGVkIGJlZm9yZSBzZW5kaW5nIG9mZiB0byBDb2FsZXNjZVN0cmVhbVxuICAgICAgICAgIGNsZWFyRHRzSW5mbyh0cmFjayk7XG5cbiAgICAgICAgICBnb3BzID0gYWxpZ25lZEdvcHM7XG4gICAgICAgIH1cblxuICAgICAgICBjb2xsZWN0RHRzSW5mbyh0cmFjaywgZ29wcyk7XG5cbiAgICAgICAgLy8gRmlyc3QsIHdlIGhhdmUgdG8gYnVpbGQgdGhlIGluZGV4IGZyb20gYnl0ZSBsb2NhdGlvbnMgdG9cbiAgICAgICAgLy8gc2FtcGxlcyAodGhhdCBpcywgZnJhbWVzKSBpbiB0aGUgdmlkZW8gZGF0YVxuICAgICAgICB0cmFjay5zYW1wbGVzID0gdGhpcy5nZW5lcmF0ZVNhbXBsZVRhYmxlXyhnb3BzKTtcblxuICAgICAgICAvLyBDb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0XG4gICAgICAgIG1kYXQgPSBtcDRHZW5lcmF0b3IubWRhdCh0aGlzLmNvbmNhdGVuYXRlTmFsRGF0YV8oZ29wcykpO1xuXG4gICAgICAgIHRyYWNrLmJhc2VNZWRpYURlY29kZVRpbWUgPSBjYWxjdWxhdGVUcmFja0Jhc2VNZWRpYURlY29kZVRpbWUodHJhY2ssIG9wdGlvbnMua2VlcE9yaWdpbmFsVGltZXN0YW1wcyk7XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwcm9jZXNzZWRHb3BzSW5mbycsIGdvcHMubWFwKGZ1bmN0aW9uIChnb3ApIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHRzOiBnb3AucHRzLFxuICAgICAgICAgICAgZHRzOiBnb3AuZHRzLFxuICAgICAgICAgICAgYnl0ZUxlbmd0aDogZ29wLmJ5dGVMZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gc2F2ZSBhbGwgdGhlIG5hbHMgaW4gdGhlIGxhc3QgR09QIGludG8gdGhlIGdvcCBjYWNoZVxuICAgICAgICB0aGlzLmdvcENhY2hlXy51bnNoaWZ0KHtcbiAgICAgICAgICBnb3A6IGdvcHMucG9wKCksXG4gICAgICAgICAgcHBzOiB0cmFjay5wcHMsXG4gICAgICAgICAgc3BzOiB0cmFjay5zcHNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gS2VlcCBhIG1heGltdW0gb2YgNiBHT1BzIGluIHRoZSBjYWNoZVxuICAgICAgICB0aGlzLmdvcENhY2hlXy5sZW5ndGggPSBNYXRoLm1pbig2LCB0aGlzLmdvcENhY2hlXy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIENsZWFyIG5hbFVuaXRzXG4gICAgICAgIG5hbFVuaXRzID0gW107XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdiYXNlTWVkaWFEZWNvZGVUaW1lJywgdHJhY2suYmFzZU1lZGlhRGVjb2RlVGltZSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcigndGltZWxpbmVTdGFydEluZm8nLCB0cmFjay50aW1lbGluZVN0YXJ0SW5mbyk7XG5cbiAgICAgICAgbW9vZiA9IG1wNEdlbmVyYXRvci5tb29mKHNlcXVlbmNlTnVtYmVyLCBbdHJhY2tdKTtcblxuICAgICAgICAvLyBpdCB3b3VsZCBiZSBncmVhdCB0byBhbGxvY2F0ZSB0aGlzIGFycmF5IHVwIGZyb250IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdGhyb3dpbmcgYXdheSBodW5kcmVkcyBvZiBtZWRpYSBzZWdtZW50IGZyYWdtZW50c1xuICAgICAgICBib3hlcyA9IG5ldyBVaW50OEFycmF5KG1vb2YuYnl0ZUxlbmd0aCArIG1kYXQuYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgLy8gQnVtcCB0aGUgc2VxdWVuY2UgbnVtYmVyIGZvciBuZXh0IHRpbWVcbiAgICAgICAgc2VxdWVuY2VOdW1iZXIrKztcblxuICAgICAgICBib3hlcy5zZXQobW9vZik7XG4gICAgICAgIGJveGVzLnNldChtZGF0LCBtb29mLmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIHsgdHJhY2s6IHRyYWNrLCBib3hlczogYm94ZXMgfSk7XG5cbiAgICAgICAgdGhpcy5yZXNldFN0cmVhbV8oKTtcblxuICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBmbHVzaCBwcm9jZXNzIG5vd1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnLCAnVmlkZW9TZWdtZW50U3RyZWFtJyk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnJlc2V0U3RyZWFtXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJEdHNJbmZvKHRyYWNrKTtcblxuICAgICAgICAvLyByZXNldCBjb25maWcgYW5kIHBwcyBiZWNhdXNlIHRoZXkgbWF5IGRpZmZlciBhY3Jvc3Mgc2VnbWVudHNcbiAgICAgICAgLy8gZm9yIGluc3RhbmNlLCB3aGVuIHdlIGFyZSByZW5kaXRpb24gc3dpdGNoaW5nXG4gICAgICAgIGNvbmZpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcHBzID0gdW5kZWZpbmVkO1xuICAgICAgfTtcblxuICAgICAgLy8gU2VhcmNoIGZvciBhIGNhbmRpZGF0ZSBHb3AgZm9yIGdvcC1mdXNpb24gZnJvbSB0aGUgZ29wIGNhY2hlIGFuZFxuICAgICAgLy8gcmV0dXJuIGl0IG9yIHJldHVybiBudWxsIGlmIG5vIGdvb2QgY2FuZGlkYXRlIHdhcyBmb3VuZFxuICAgICAgdGhpcy5nZXRHb3BGb3JGdXNpb25fID0gZnVuY3Rpb24gKG5hbFVuaXQpIHtcbiAgICAgICAgdmFyIGhhbGZTZWNvbmQgPSA0NTAwMCxcblxuXG4gICAgICAgIC8vIEhhbGYtYS1zZWNvbmQgaW4gYSA5MGtoeiBjbG9ja1xuICAgICAgICBhbGxvd2FibGVPdmVybGFwID0gMTAwMDAsXG5cblxuICAgICAgICAvLyBBYm91dCAzIGZyYW1lcyBAIDMwZnBzXG4gICAgICAgIG5lYXJlc3REaXN0YW5jZSA9IEluZmluaXR5LFxuICAgICAgICAgICAgZHRzRGlzdGFuY2UsXG4gICAgICAgICAgICBuZWFyZXN0R29wT2JqLFxuICAgICAgICAgICAgY3VycmVudEdvcCxcbiAgICAgICAgICAgIGN1cnJlbnRHb3BPYmosXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIEdPUCBuZWFyZXN0IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBuYWwgdW5pdFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5nb3BDYWNoZV8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjdXJyZW50R29wT2JqID0gdGhpcy5nb3BDYWNoZV9baV07XG4gICAgICAgICAgY3VycmVudEdvcCA9IGN1cnJlbnRHb3BPYmouZ29wO1xuXG4gICAgICAgICAgLy8gUmVqZWN0IEdvcHMgd2l0aCBkaWZmZXJlbnQgU1BTIG9yIFBQU1xuICAgICAgICAgIGlmICghKHRyYWNrLnBwcyAmJiBhcnJheUVxdWFscyh0cmFjay5wcHNbMF0sIGN1cnJlbnRHb3BPYmoucHBzWzBdKSkgfHwgISh0cmFjay5zcHMgJiYgYXJyYXlFcXVhbHModHJhY2suc3BzWzBdLCBjdXJyZW50R29wT2JqLnNwc1swXSkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZWplY3QgR29wcyB0aGF0IHdvdWxkIHJlcXVpcmUgYSBuZWdhdGl2ZSBiYXNlTWVkaWFEZWNvZGVUaW1lXG4gICAgICAgICAgaWYgKGN1cnJlbnRHb3AuZHRzIDwgdHJhY2sudGltZWxpbmVTdGFydEluZm8uZHRzKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZW5kIG9mIHRoZSBnb3AgYW5kIHRoZSBzdGFydCBvZiB0aGUgbmFsVW5pdFxuICAgICAgICAgIGR0c0Rpc3RhbmNlID0gbmFsVW5pdC5kdHMgLSBjdXJyZW50R29wLmR0cyAtIGN1cnJlbnRHb3AuZHVyYXRpb247XG5cbiAgICAgICAgICAvLyBPbmx5IGNvbnNpZGVyIEdPUFMgdGhhdCBzdGFydCBiZWZvcmUgdGhlIG5hbCB1bml0IGFuZCBlbmQgd2l0aGluXG4gICAgICAgICAgLy8gYSBoYWxmLXNlY29uZCBvZiB0aGUgbmFsIHVuaXRcbiAgICAgICAgICBpZiAoZHRzRGlzdGFuY2UgPj0gLWFsbG93YWJsZU92ZXJsYXAgJiYgZHRzRGlzdGFuY2UgPD0gaGFsZlNlY29uZCkge1xuXG4gICAgICAgICAgICAvLyBBbHdheXMgdXNlIHRoZSBjbG9zZXN0IEdPUCB3ZSBmb3VuZCBpZiB0aGVyZSBpcyBtb3JlIHRoYW5cbiAgICAgICAgICAgIC8vIG9uZSBjYW5kaWRhdGVcbiAgICAgICAgICAgIGlmICghbmVhcmVzdEdvcE9iaiB8fCBuZWFyZXN0RGlzdGFuY2UgPiBkdHNEaXN0YW5jZSkge1xuICAgICAgICAgICAgICBuZWFyZXN0R29wT2JqID0gY3VycmVudEdvcE9iajtcbiAgICAgICAgICAgICAgbmVhcmVzdERpc3RhbmNlID0gZHRzRGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lYXJlc3RHb3BPYmopIHtcbiAgICAgICAgICByZXR1cm4gbmVhcmVzdEdvcE9iai5nb3A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmV4dGVuZEZpcnN0S2V5RnJhbWVfID0gZnVuY3Rpb24gKGdvcHMpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRHb3A7XG5cbiAgICAgICAgaWYgKCFnb3BzWzBdWzBdLmtleUZyYW1lICYmIGdvcHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgR09QXG4gICAgICAgICAgY3VycmVudEdvcCA9IGdvcHMuc2hpZnQoKTtcblxuICAgICAgICAgIGdvcHMuYnl0ZUxlbmd0aCAtPSBjdXJyZW50R29wLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgZ29wcy5uYWxDb3VudCAtPSBjdXJyZW50R29wLm5hbENvdW50O1xuXG4gICAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCBmcmFtZSBvZiB3aGF0IGlzIG5vdyB0aGVcbiAgICAgICAgICAvLyBmaXJzdCBnb3AgdG8gY292ZXIgdGhlIHRpbWUgcGVyaW9kIG9mIHRoZVxuICAgICAgICAgIC8vIGZyYW1lcyB3ZSBqdXN0IHJlbW92ZWRcbiAgICAgICAgICBnb3BzWzBdWzBdLmR0cyA9IGN1cnJlbnRHb3AuZHRzO1xuICAgICAgICAgIGdvcHNbMF1bMF0ucHRzID0gY3VycmVudEdvcC5wdHM7XG4gICAgICAgICAgZ29wc1swXVswXS5kdXJhdGlvbiArPSBjdXJyZW50R29wLmR1cmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdvcHM7XG4gICAgICB9O1xuXG4gICAgICAvLyBDb252ZXJ0IGFuIGFycmF5IG9mIG5hbCB1bml0cyBpbnRvIGFuIGFycmF5IG9mIGZyYW1lcyB3aXRoIGVhY2ggZnJhbWUgYmVpbmdcbiAgICAgIC8vIGNvbXBvc2VkIG9mIHRoZSBuYWwgdW5pdHMgdGhhdCBtYWtlIHVwIHRoYXQgZnJhbWVcbiAgICAgIC8vIEFsc28ga2VlcCB0cmFjayBvZiBjdW1tdWxhdGl2ZSBkYXRhIGFib3V0IHRoZSBmcmFtZSBmcm9tIHRoZSBuYWwgdW5pdHMgc3VjaFxuICAgICAgLy8gYXMgdGhlIGZyYW1lIGR1cmF0aW9uLCBzdGFydGluZyBwdHMsIGV0Yy5cbiAgICAgIHRoaXMuZ3JvdXBOYWxzSW50b0ZyYW1lc18gPSBmdW5jdGlvbiAobmFsVW5pdHMpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBjdXJyZW50TmFsLFxuICAgICAgICAgICAgY3VycmVudEZyYW1lID0gW10sXG4gICAgICAgICAgICBmcmFtZXMgPSBbXTtcblxuICAgICAgICBjdXJyZW50RnJhbWUuYnl0ZUxlbmd0aCA9IDA7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5hbFVuaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudE5hbCA9IG5hbFVuaXRzW2ldO1xuXG4gICAgICAgICAgLy8gU3BsaXQgb24gJ2F1ZCctdHlwZSBuYWwgdW5pdHNcbiAgICAgICAgICBpZiAoY3VycmVudE5hbC5uYWxVbml0VHlwZSA9PT0gJ2FjY2Vzc191bml0X2RlbGltaXRlcl9yYnNwJykge1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIHZlcnkgZmlyc3QgbmFsIHVuaXQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gQVVEXG4gICAgICAgICAgICAvLyBvbmx5IHB1c2ggdG8gdGhlIGZyYW1lcyBhcnJheSB3aGVuIGN1cnJlbnRGcmFtZSBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgIGlmIChjdXJyZW50RnJhbWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRGcmFtZS5kdXJhdGlvbiA9IGN1cnJlbnROYWwuZHRzIC0gY3VycmVudEZyYW1lLmR0cztcbiAgICAgICAgICAgICAgZnJhbWVzLnB1c2goY3VycmVudEZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRGcmFtZSA9IFtjdXJyZW50TmFsXTtcbiAgICAgICAgICAgIGN1cnJlbnRGcmFtZS5ieXRlTGVuZ3RoID0gY3VycmVudE5hbC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50RnJhbWUucHRzID0gY3VycmVudE5hbC5wdHM7XG4gICAgICAgICAgICBjdXJyZW50RnJhbWUuZHRzID0gY3VycmVudE5hbC5kdHM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNwZWNpZmljYWxseSBmbGFnIGtleSBmcmFtZXMgZm9yIGVhc2Ugb2YgdXNlIGxhdGVyXG4gICAgICAgICAgICBpZiAoY3VycmVudE5hbC5uYWxVbml0VHlwZSA9PT0gJ3NsaWNlX2xheWVyX3dpdGhvdXRfcGFydGl0aW9uaW5nX3Jic3BfaWRyJykge1xuICAgICAgICAgICAgICBjdXJyZW50RnJhbWUua2V5RnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEZyYW1lLmR1cmF0aW9uID0gY3VycmVudE5hbC5kdHMgLSBjdXJyZW50RnJhbWUuZHRzO1xuICAgICAgICAgICAgY3VycmVudEZyYW1lLmJ5dGVMZW5ndGggKz0gY3VycmVudE5hbC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50RnJhbWUucHVzaChjdXJyZW50TmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3IgdGhlIGxhc3QgZnJhbWUsIHVzZSB0aGUgZHVyYXRpb24gb2YgdGhlIHByZXZpb3VzIGZyYW1lIGlmIHdlXG4gICAgICAgIC8vIGhhdmUgbm90aGluZyBiZXR0ZXIgdG8gZ28gb25cbiAgICAgICAgaWYgKGZyYW1lcy5sZW5ndGggJiYgKCFjdXJyZW50RnJhbWUuZHVyYXRpb24gfHwgY3VycmVudEZyYW1lLmR1cmF0aW9uIDw9IDApKSB7XG4gICAgICAgICAgY3VycmVudEZyYW1lLmR1cmF0aW9uID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAxXS5kdXJhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1c2ggdGhlIGZpbmFsIGZyYW1lXG4gICAgICAgIGZyYW1lcy5wdXNoKGN1cnJlbnRGcmFtZSk7XG4gICAgICAgIHJldHVybiBmcmFtZXM7XG4gICAgICB9O1xuXG4gICAgICAvLyBDb252ZXJ0IGFuIGFycmF5IG9mIGZyYW1lcyBpbnRvIGFuIGFycmF5IG9mIEdvcCB3aXRoIGVhY2ggR29wIGJlaW5nIGNvbXBvc2VkXG4gICAgICAvLyBvZiB0aGUgZnJhbWVzIHRoYXQgbWFrZSB1cCB0aGF0IEdvcFxuICAgICAgLy8gQWxzbyBrZWVwIHRyYWNrIG9mIGN1bW11bGF0aXZlIGRhdGEgYWJvdXQgdGhlIEdvcCBmcm9tIHRoZSBmcmFtZXMgc3VjaCBhcyB0aGVcbiAgICAgIC8vIEdvcCBkdXJhdGlvbiwgc3RhcnRpbmcgcHRzLCBldGMuXG4gICAgICB0aGlzLmdyb3VwRnJhbWVzSW50b0dvcHNfID0gZnVuY3Rpb24gKGZyYW1lcykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGN1cnJlbnRGcmFtZSxcbiAgICAgICAgICAgIGN1cnJlbnRHb3AgPSBbXSxcbiAgICAgICAgICAgIGdvcHMgPSBbXTtcblxuICAgICAgICAvLyBXZSBtdXN0IHByZS1zZXQgc29tZSBvZiB0aGUgdmFsdWVzIG9uIHRoZSBHb3Agc2luY2Ugd2VcbiAgICAgICAgLy8ga2VlcCBydW5uaW5nIHRvdGFscyBvZiB0aGVzZSB2YWx1ZXNcbiAgICAgICAgY3VycmVudEdvcC5ieXRlTGVuZ3RoID0gMDtcbiAgICAgICAgY3VycmVudEdvcC5uYWxDb3VudCA9IDA7XG4gICAgICAgIGN1cnJlbnRHb3AuZHVyYXRpb24gPSAwO1xuICAgICAgICBjdXJyZW50R29wLnB0cyA9IGZyYW1lc1swXS5wdHM7XG4gICAgICAgIGN1cnJlbnRHb3AuZHRzID0gZnJhbWVzWzBdLmR0cztcblxuICAgICAgICAvLyBzdG9yZSBzb21lIG1ldGFkYXRhIGFib3V0IGFsbCB0aGUgR29wc1xuICAgICAgICBnb3BzLmJ5dGVMZW5ndGggPSAwO1xuICAgICAgICBnb3BzLm5hbENvdW50ID0gMDtcbiAgICAgICAgZ29wcy5kdXJhdGlvbiA9IDA7XG4gICAgICAgIGdvcHMucHRzID0gZnJhbWVzWzBdLnB0cztcbiAgICAgICAgZ29wcy5kdHMgPSBmcmFtZXNbMF0uZHRzO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjdXJyZW50RnJhbWUgPSBmcmFtZXNbaV07XG5cbiAgICAgICAgICBpZiAoY3VycmVudEZyYW1lLmtleUZyYW1lKSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgdmVyeSBmaXJzdCBmcmFtZSBpcyBleHBlY3RlZCB0byBiZSBhbiBrZXlmcmFtZVxuICAgICAgICAgICAgLy8gb25seSBwdXNoIHRvIHRoZSBnb3BzIGFycmF5IHdoZW4gY3VycmVudEdvcCBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgIGlmIChjdXJyZW50R29wLmxlbmd0aCkge1xuICAgICAgICAgICAgICBnb3BzLnB1c2goY3VycmVudEdvcCk7XG4gICAgICAgICAgICAgIGdvcHMuYnl0ZUxlbmd0aCArPSBjdXJyZW50R29wLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgIGdvcHMubmFsQ291bnQgKz0gY3VycmVudEdvcC5uYWxDb3VudDtcbiAgICAgICAgICAgICAgZ29wcy5kdXJhdGlvbiArPSBjdXJyZW50R29wLmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50R29wID0gW2N1cnJlbnRGcmFtZV07XG4gICAgICAgICAgICBjdXJyZW50R29wLm5hbENvdW50ID0gY3VycmVudEZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIGN1cnJlbnRHb3AuYnl0ZUxlbmd0aCA9IGN1cnJlbnRGcmFtZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgY3VycmVudEdvcC5wdHMgPSBjdXJyZW50RnJhbWUucHRzO1xuICAgICAgICAgICAgY3VycmVudEdvcC5kdHMgPSBjdXJyZW50RnJhbWUuZHRzO1xuICAgICAgICAgICAgY3VycmVudEdvcC5kdXJhdGlvbiA9IGN1cnJlbnRGcmFtZS5kdXJhdGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudEdvcC5kdXJhdGlvbiArPSBjdXJyZW50RnJhbWUuZHVyYXRpb247XG4gICAgICAgICAgICBjdXJyZW50R29wLm5hbENvdW50ICs9IGN1cnJlbnRGcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50R29wLmJ5dGVMZW5ndGggKz0gY3VycmVudEZyYW1lLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50R29wLnB1c2goY3VycmVudEZyYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ29wcy5sZW5ndGggJiYgY3VycmVudEdvcC5kdXJhdGlvbiA8PSAwKSB7XG4gICAgICAgICAgY3VycmVudEdvcC5kdXJhdGlvbiA9IGdvcHNbZ29wcy5sZW5ndGggLSAxXS5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBnb3BzLmJ5dGVMZW5ndGggKz0gY3VycmVudEdvcC5ieXRlTGVuZ3RoO1xuICAgICAgICBnb3BzLm5hbENvdW50ICs9IGN1cnJlbnRHb3AubmFsQ291bnQ7XG4gICAgICAgIGdvcHMuZHVyYXRpb24gKz0gY3VycmVudEdvcC5kdXJhdGlvbjtcblxuICAgICAgICAvLyBwdXNoIHRoZSBmaW5hbCBHb3BcbiAgICAgICAgZ29wcy5wdXNoKGN1cnJlbnRHb3ApO1xuICAgICAgICByZXR1cm4gZ29wcztcbiAgICAgIH07XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSB0cmFjaydzIHNhbXBsZSB0YWJsZSBmcm9tIGFuIGFycmF5IG9mIGdvcHNcbiAgICAgIHRoaXMuZ2VuZXJhdGVTYW1wbGVUYWJsZV8gPSBmdW5jdGlvbiAoZ29wcywgYmFzZURhdGFPZmZzZXQpIHtcbiAgICAgICAgdmFyIGgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgc2FtcGxlLFxuICAgICAgICAgICAgY3VycmVudEdvcCxcbiAgICAgICAgICAgIGN1cnJlbnRGcmFtZSxcbiAgICAgICAgICAgIGRhdGFPZmZzZXQgPSBiYXNlRGF0YU9mZnNldCB8fCAwLFxuICAgICAgICAgICAgc2FtcGxlcyA9IFtdO1xuXG4gICAgICAgIGZvciAoaCA9IDA7IGggPCBnb3BzLmxlbmd0aDsgaCsrKSB7XG4gICAgICAgICAgY3VycmVudEdvcCA9IGdvcHNbaF07XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY3VycmVudEdvcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudEZyYW1lID0gY3VycmVudEdvcFtpXTtcblxuICAgICAgICAgICAgc2FtcGxlID0gY3JlYXRlRGVmYXVsdFNhbXBsZSgpO1xuXG4gICAgICAgICAgICBzYW1wbGUuZGF0YU9mZnNldCA9IGRhdGFPZmZzZXQ7XG4gICAgICAgICAgICBzYW1wbGUuY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gY3VycmVudEZyYW1lLnB0cyAtIGN1cnJlbnRGcmFtZS5kdHM7XG4gICAgICAgICAgICBzYW1wbGUuZHVyYXRpb24gPSBjdXJyZW50RnJhbWUuZHVyYXRpb247XG4gICAgICAgICAgICBzYW1wbGUuc2l6ZSA9IDQgKiBjdXJyZW50RnJhbWUubGVuZ3RoOyAvLyBTcGFjZSBmb3IgbmFsIHVuaXQgc2l6ZVxuICAgICAgICAgICAgc2FtcGxlLnNpemUgKz0gY3VycmVudEZyYW1lLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50RnJhbWUua2V5RnJhbWUpIHtcbiAgICAgICAgICAgICAgc2FtcGxlLmZsYWdzLmRlcGVuZHNPbiA9IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGFPZmZzZXQgKz0gc2FtcGxlLnNpemU7XG5cbiAgICAgICAgICAgIHNhbXBsZXMucHVzaChzYW1wbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FtcGxlcztcbiAgICAgIH07XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSB0cmFjaydzIHJhdyBtZGF0IGRhdGEgZnJvbSBhbiBhcnJheSBvZiBnb3BzXG4gICAgICB0aGlzLmNvbmNhdGVuYXRlTmFsRGF0YV8gPSBmdW5jdGlvbiAoZ29wcykge1xuICAgICAgICB2YXIgaCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgY3VycmVudEdvcCxcbiAgICAgICAgICAgIGN1cnJlbnRGcmFtZSxcbiAgICAgICAgICAgIGN1cnJlbnROYWwsXG4gICAgICAgICAgICBkYXRhT2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIG5hbHNCeXRlTGVuZ3RoID0gZ29wcy5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgbnVtYmVyT2ZOYWxzID0gZ29wcy5uYWxDb3VudCxcbiAgICAgICAgICAgIHRvdGFsQnl0ZUxlbmd0aCA9IG5hbHNCeXRlTGVuZ3RoICsgNCAqIG51bWJlck9mTmFscyxcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVMZW5ndGgpLFxuICAgICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlcik7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggR29wLi5cbiAgICAgICAgZm9yIChoID0gMDsgaCA8IGdvcHMubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgICBjdXJyZW50R29wID0gZ29wc1toXTtcblxuICAgICAgICAgIC8vIEZvciBlYWNoIEZyYW1lLi5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY3VycmVudEdvcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudEZyYW1lID0gY3VycmVudEdvcFtpXTtcblxuICAgICAgICAgICAgLy8gRm9yIGVhY2ggTkFMLi5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXJyZW50RnJhbWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgY3VycmVudE5hbCA9IGN1cnJlbnRGcmFtZVtqXTtcblxuICAgICAgICAgICAgICB2aWV3LnNldFVpbnQzMihkYXRhT2Zmc2V0LCBjdXJyZW50TmFsLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgIGRhdGFPZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgZGF0YS5zZXQoY3VycmVudE5hbC5kYXRhLCBkYXRhT2Zmc2V0KTtcbiAgICAgICAgICAgICAgZGF0YU9mZnNldCArPSBjdXJyZW50TmFsLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9O1xuXG4gICAgICAvLyB0cmltIGdvcCBsaXN0IHRvIHRoZSBmaXJzdCBnb3AgZm91bmQgdGhhdCBoYXMgYSBtYXRjaGluZyBwdHMgd2l0aCBhIGdvcCBpbiB0aGUgbGlzdFxuICAgICAgLy8gb2YgZ29wc1RvQWxpZ25XaXRoIHN0YXJ0aW5nIGZyb20gdGhlIFNUQVJUIG9mIHRoZSBsaXN0XG4gICAgICB0aGlzLmFsaWduR29wc0F0U3RhcnRfID0gZnVuY3Rpb24gKGdvcHMpIHtcbiAgICAgICAgdmFyIGFsaWduSW5kZXgsIGdvcEluZGV4LCBhbGlnbiwgZ29wLCBieXRlTGVuZ3RoLCBuYWxDb3VudCwgZHVyYXRpb24sIGFsaWduZWRHb3BzO1xuXG4gICAgICAgIGJ5dGVMZW5ndGggPSBnb3BzLmJ5dGVMZW5ndGg7XG4gICAgICAgIG5hbENvdW50ID0gZ29wcy5uYWxDb3VudDtcbiAgICAgICAgZHVyYXRpb24gPSBnb3BzLmR1cmF0aW9uO1xuICAgICAgICBhbGlnbkluZGV4ID0gZ29wSW5kZXggPSAwO1xuXG4gICAgICAgIHdoaWxlIChhbGlnbkluZGV4IDwgZ29wc1RvQWxpZ25XaXRoLmxlbmd0aCAmJiBnb3BJbmRleCA8IGdvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgYWxpZ24gPSBnb3BzVG9BbGlnbldpdGhbYWxpZ25JbmRleF07XG4gICAgICAgICAgZ29wID0gZ29wc1tnb3BJbmRleF07XG5cbiAgICAgICAgICBpZiAoYWxpZ24ucHRzID09PSBnb3AucHRzKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZ29wLnB0cyA+IGFsaWduLnB0cykge1xuICAgICAgICAgICAgLy8gdGhpcyBjdXJyZW50IGdvcCBzdGFydHMgYWZ0ZXIgdGhlIGN1cnJlbnQgZ29wIHdlIHdhbnQgdG8gYWxpZ24gb24sIHNvIGluY3JlbWVudFxuICAgICAgICAgICAgLy8gYWxpZ24gaW5kZXhcbiAgICAgICAgICAgIGFsaWduSW5kZXgrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGN1cnJlbnQgZ29wIHN0YXJ0cyBiZWZvcmUgdGhlIGN1cnJlbnQgZ29wIHdlIHdhbnQgdG8gYWxpZ24gb24uIHNvIGluY3JlbWVudCBnb3BcbiAgICAgICAgICAvLyBpbmRleFxuICAgICAgICAgIGdvcEluZGV4Kys7XG4gICAgICAgICAgYnl0ZUxlbmd0aCAtPSBnb3AuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBuYWxDb3VudCAtPSBnb3AubmFsQ291bnQ7XG4gICAgICAgICAgZHVyYXRpb24gLT0gZ29wLmR1cmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdvcEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgLy8gbm8gZ29wcyB0byB0cmltXG4gICAgICAgICAgcmV0dXJuIGdvcHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ29wSW5kZXggPT09IGdvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gYWxsIGdvcHMgdHJpbW1lZCwgc2tpcCBhcHBlbmRpbmcgYWxsIGdvcHNcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFsaWduZWRHb3BzID0gZ29wcy5zbGljZShnb3BJbmRleCk7XG4gICAgICAgIGFsaWduZWRHb3BzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuICAgICAgICBhbGlnbmVkR29wcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICBhbGlnbmVkR29wcy5uYWxDb3VudCA9IG5hbENvdW50O1xuICAgICAgICBhbGlnbmVkR29wcy5wdHMgPSBhbGlnbmVkR29wc1swXS5wdHM7XG4gICAgICAgIGFsaWduZWRHb3BzLmR0cyA9IGFsaWduZWRHb3BzWzBdLmR0cztcblxuICAgICAgICByZXR1cm4gYWxpZ25lZEdvcHM7XG4gICAgICB9O1xuXG4gICAgICAvLyB0cmltIGdvcCBsaXN0IHRvIHRoZSBmaXJzdCBnb3AgZm91bmQgdGhhdCBoYXMgYSBtYXRjaGluZyBwdHMgd2l0aCBhIGdvcCBpbiB0aGUgbGlzdFxuICAgICAgLy8gb2YgZ29wc1RvQWxpZ25XaXRoIHN0YXJ0aW5nIGZyb20gdGhlIEVORCBvZiB0aGUgbGlzdFxuICAgICAgdGhpcy5hbGlnbkdvcHNBdEVuZF8gPSBmdW5jdGlvbiAoZ29wcykge1xuICAgICAgICB2YXIgYWxpZ25JbmRleCwgZ29wSW5kZXgsIGFsaWduLCBnb3AsIGFsaWduRW5kSW5kZXgsIG1hdGNoRm91bmQ7XG5cbiAgICAgICAgYWxpZ25JbmRleCA9IGdvcHNUb0FsaWduV2l0aC5sZW5ndGggLSAxO1xuICAgICAgICBnb3BJbmRleCA9IGdvcHMubGVuZ3RoIC0gMTtcbiAgICAgICAgYWxpZ25FbmRJbmRleCA9IG51bGw7XG4gICAgICAgIG1hdGNoRm91bmQgPSBmYWxzZTtcblxuICAgICAgICB3aGlsZSAoYWxpZ25JbmRleCA+PSAwICYmIGdvcEluZGV4ID49IDApIHtcbiAgICAgICAgICBhbGlnbiA9IGdvcHNUb0FsaWduV2l0aFthbGlnbkluZGV4XTtcbiAgICAgICAgICBnb3AgPSBnb3BzW2dvcEluZGV4XTtcblxuICAgICAgICAgIGlmIChhbGlnbi5wdHMgPT09IGdvcC5wdHMpIHtcbiAgICAgICAgICAgIG1hdGNoRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFsaWduLnB0cyA+IGdvcC5wdHMpIHtcbiAgICAgICAgICAgIGFsaWduSW5kZXgtLTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhbGlnbkluZGV4ID09PSBnb3BzVG9BbGlnbldpdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgLy8gZ29wLnB0cyBpcyBncmVhdGVyIHRoYW4gdGhlIGxhc3QgYWxpZ25tZW50IGNhbmRpZGF0ZS4gSWYgbm8gbWF0Y2ggaXMgZm91bmRcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBlbmQgb2YgdGhpcyBsb29wLCB3ZSBzdGlsbCB3YW50IHRvIGFwcGVuZCBnb3BzIHRoYXQgY29tZSBhZnRlciB0aGlzXG4gICAgICAgICAgICAvLyBwb2ludFxuICAgICAgICAgICAgYWxpZ25FbmRJbmRleCA9IGdvcEluZGV4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdvcEluZGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1hdGNoRm91bmQgJiYgYWxpZ25FbmRJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyaW1JbmRleDtcblxuICAgICAgICBpZiAobWF0Y2hGb3VuZCkge1xuICAgICAgICAgIHRyaW1JbmRleCA9IGdvcEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyaW1JbmRleCA9IGFsaWduRW5kSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJpbUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGdvcHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWxpZ25lZEdvcHMgPSBnb3BzLnNsaWNlKHRyaW1JbmRleCk7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGFsaWduZWRHb3BzLnJlZHVjZShmdW5jdGlvbiAodG90YWwsIGdvcCkge1xuICAgICAgICAgIHRvdGFsLmJ5dGVMZW5ndGggKz0gZ29wLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgdG90YWwuZHVyYXRpb24gKz0gZ29wLmR1cmF0aW9uO1xuICAgICAgICAgIHRvdGFsLm5hbENvdW50ICs9IGdvcC5uYWxDb3VudDtcbiAgICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgICAgIH0sIHsgYnl0ZUxlbmd0aDogMCwgZHVyYXRpb246IDAsIG5hbENvdW50OiAwIH0pO1xuXG4gICAgICAgIGFsaWduZWRHb3BzLmJ5dGVMZW5ndGggPSBtZXRhZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICBhbGlnbmVkR29wcy5kdXJhdGlvbiA9IG1ldGFkYXRhLmR1cmF0aW9uO1xuICAgICAgICBhbGlnbmVkR29wcy5uYWxDb3VudCA9IG1ldGFkYXRhLm5hbENvdW50O1xuICAgICAgICBhbGlnbmVkR29wcy5wdHMgPSBhbGlnbmVkR29wc1swXS5wdHM7XG4gICAgICAgIGFsaWduZWRHb3BzLmR0cyA9IGFsaWduZWRHb3BzWzBdLmR0cztcblxuICAgICAgICByZXR1cm4gYWxpZ25lZEdvcHM7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFsaWduR29wc1dpdGggPSBmdW5jdGlvbiAobmV3R29wc1RvQWxpZ25XaXRoKSB7XG4gICAgICAgIGdvcHNUb0FsaWduV2l0aCA9IG5ld0dvcHNUb0FsaWduV2l0aDtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF9WaWRlb1NlZ21lbnRTdHJlYW0ucHJvdG90eXBlID0gbmV3IHN0cmVhbSgpO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHRyYWNrIGFuZCB0aGVcbiAgICAgKiBkdXJhdGlvbiBmb3IgZWFjaCBmcmFtZS9zYW1wbGUgd2UgcHJvY2VzcyBpbiBvcmRlciB0byBjYWxjdWxhdGVcbiAgICAgKiB0aGUgYmFzZU1lZGlhRGVjb2RlVGltZVxuICAgICAqL1xuICAgIGNvbGxlY3REdHNJbmZvID0gZnVuY3Rpb24gY29sbGVjdER0c0luZm8odHJhY2ssIGRhdGEpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YS5wdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICh0cmFjay50aW1lbGluZVN0YXJ0SW5mby5wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLnB0cyA9IGRhdGEucHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYWNrLm1pblNlZ21lbnRQdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRyYWNrLm1pblNlZ21lbnRQdHMgPSBkYXRhLnB0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFjay5taW5TZWdtZW50UHRzID0gTWF0aC5taW4odHJhY2subWluU2VnbWVudFB0cywgZGF0YS5wdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYWNrLm1heFNlZ21lbnRQdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRyYWNrLm1heFNlZ21lbnRQdHMgPSBkYXRhLnB0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFjay5tYXhTZWdtZW50UHRzID0gTWF0aC5tYXgodHJhY2subWF4U2VnbWVudFB0cywgZGF0YS5wdHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YS5kdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICh0cmFjay50aW1lbGluZVN0YXJ0SW5mby5kdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmR0cyA9IGRhdGEuZHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYWNrLm1pblNlZ21lbnREdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRyYWNrLm1pblNlZ21lbnREdHMgPSBkYXRhLmR0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFjay5taW5TZWdtZW50RHRzID0gTWF0aC5taW4odHJhY2subWluU2VnbWVudER0cywgZGF0YS5kdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYWNrLm1heFNlZ21lbnREdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRyYWNrLm1heFNlZ21lbnREdHMgPSBkYXRhLmR0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFjay5tYXhTZWdtZW50RHRzID0gTWF0aC5tYXgodHJhY2subWF4U2VnbWVudER0cywgZGF0YS5kdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHZhbHVlcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgYmFzZU1lZGlhRGVjb2RlVGltZSBiZXR3ZWVuXG4gICAgICogdHJhY2tzXG4gICAgICovXG4gICAgY2xlYXJEdHNJbmZvID0gZnVuY3Rpb24gY2xlYXJEdHNJbmZvKHRyYWNrKSB7XG4gICAgICBkZWxldGUgdHJhY2subWluU2VnbWVudER0cztcbiAgICAgIGRlbGV0ZSB0cmFjay5tYXhTZWdtZW50RHRzO1xuICAgICAgZGVsZXRlIHRyYWNrLm1pblNlZ21lbnRQdHM7XG4gICAgICBkZWxldGUgdHJhY2subWF4U2VnbWVudFB0cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSB0cmFjaydzIGJhc2VNZWRpYURlY29kZVRpbWUgYmFzZWQgb24gdGhlIGVhcmxpZXN0XG4gICAgICogRFRTIHRoZSB0cmFuc211eGVyIGhhcyBldmVyIHNlZW4gYW5kIHRoZSBtaW5pbXVtIERUUyBmb3IgdGhlXG4gICAgICogY3VycmVudCB0cmFja1xuICAgICAqIEBwYXJhbSB0cmFjayB7b2JqZWN0fSB0cmFjayBtZXRhZGF0YSBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIGtlZXBPcmlnaW5hbFRpbWVzdGFtcHMge2Jvb2xlYW59IElmIHRydWUsIGtlZXAgdGhlIHRpbWVzdGFtcHNcbiAgICAgKiAgICAgICAgaW4gdGhlIHNvdXJjZTsgZmFsc2UgdG8gYWRqdXN0IHRoZSBmaXJzdCBzZWdtZW50IHRvIHN0YXJ0IGF0IDAuXG4gICAgICovXG4gICAgY2FsY3VsYXRlVHJhY2tCYXNlTWVkaWFEZWNvZGVUaW1lID0gZnVuY3Rpb24gY2FsY3VsYXRlVHJhY2tCYXNlTWVkaWFEZWNvZGVUaW1lKHRyYWNrLCBrZWVwT3JpZ2luYWxUaW1lc3RhbXBzKSB7XG4gICAgICB2YXIgYmFzZU1lZGlhRGVjb2RlVGltZSxcbiAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICBtaW5TZWdtZW50RHRzID0gdHJhY2subWluU2VnbWVudER0cztcblxuICAgICAgLy8gT3B0aW9uYWxseSBhZGp1c3QgdGhlIHRpbWUgc28gdGhlIGZpcnN0IHNlZ21lbnQgc3RhcnRzIGF0IHplcm8uXG4gICAgICBpZiAoIWtlZXBPcmlnaW5hbFRpbWVzdGFtcHMpIHtcbiAgICAgICAgbWluU2VnbWVudER0cyAtPSB0cmFjay50aW1lbGluZVN0YXJ0SW5mby5kdHM7XG4gICAgICB9XG5cbiAgICAgIC8vIHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmJhc2VNZWRpYURlY29kZVRpbWUgaXMgdGhlIGxvY2F0aW9uLCBpbiB0aW1lLCB3aGVyZVxuICAgICAgLy8gd2Ugd2FudCB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IHNlZ21lbnQgdG8gYmUgcGxhY2VkXG4gICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lID0gdHJhY2sudGltZWxpbmVTdGFydEluZm8uYmFzZU1lZGlhRGVjb2RlVGltZTtcblxuICAgICAgLy8gQWRkIHRvIHRoYXQgdGhlIGRpc3RhbmNlIHRoaXMgc2VnbWVudCBpcyBmcm9tIHRoZSB2ZXJ5IGZpcnN0XG4gICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICs9IG1pblNlZ21lbnREdHM7XG5cbiAgICAgIC8vIGJhc2VNZWRpYURlY29kZVRpbWUgbXVzdCBub3QgYmVjb21lIG5lZ2F0aXZlXG4gICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5tYXgoMCwgYmFzZU1lZGlhRGVjb2RlVGltZSk7XG5cbiAgICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgIC8vIEF1ZGlvIGhhcyBhIGRpZmZlcmVudCBjbG9jayBlcXVhbCB0byB0aGUgc2FtcGxpbmdfcmF0ZSBzbyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHNjYWxlIHRoZSBQVFMgdmFsdWVzIGludG8gdGhlIGNsb2NrIHJhdGUgb2YgdGhlIHRyYWNrXG4gICAgICAgIHNjYWxlID0gdHJhY2suc2FtcGxlcmF0ZSAvIE9ORV9TRUNPTkRfSU5fVFMkMTtcbiAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAqPSBzY2FsZTtcbiAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYXNlTWVkaWFEZWNvZGVUaW1lO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIFN0cmVhbSB0aGF0IGNhbiBjb21iaW5lIG11bHRpcGxlIHN0cmVhbXMgKGllLiBhdWRpbyAmIHZpZGVvKVxuICAgICAqIGludG8gYSBzaW5nbGUgb3V0cHV0IHNlZ21lbnQgZm9yIE1TRS4gQWxzbyBzdXBwb3J0cyBhdWRpby1vbmx5XG4gICAgICogYW5kIHZpZGVvLW9ubHkgc3RyZWFtcy5cbiAgICAgKi9cbiAgICBfQ29hbGVzY2VTdHJlYW0gPSBmdW5jdGlvbiBDb2FsZXNjZVN0cmVhbShvcHRpb25zLCBtZXRhZGF0YVN0cmVhbSkge1xuICAgICAgLy8gTnVtYmVyIG9mIFRyYWNrcyBwZXIgb3V0cHV0IHNlZ21lbnRcbiAgICAgIC8vIElmIGdyZWF0ZXIgdGhhbiAxLCB3ZSBjb21iaW5lIG11bHRpcGxlXG4gICAgICAvLyB0cmFja3MgaW50byBhIHNpbmdsZSBzZWdtZW50XG4gICAgICB0aGlzLm51bWJlck9mVHJhY2tzID0gMDtcbiAgICAgIHRoaXMubWV0YWRhdGFTdHJlYW0gPSBtZXRhZGF0YVN0cmVhbTtcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlbXV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnJlbXV4VHJhY2tzID0gISFvcHRpb25zLnJlbXV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW11eFRyYWNrcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IFtdO1xuICAgICAgdGhpcy52aWRlb1RyYWNrID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ0JveGVzID0gW107XG4gICAgICB0aGlzLnBlbmRpbmdDYXB0aW9ucyA9IFtdO1xuICAgICAgdGhpcy5wZW5kaW5nTWV0YWRhdGEgPSBbXTtcbiAgICAgIHRoaXMucGVuZGluZ0J5dGVzID0gMDtcbiAgICAgIHRoaXMuZW1pdHRlZFRyYWNrcyA9IDA7XG5cbiAgICAgIF9Db2FsZXNjZVN0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgICAvLyBUYWtlIG91dHB1dCBmcm9tIG11bHRpcGxlXG4gICAgICB0aGlzLnB1c2ggPSBmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgICAgIC8vIGJ1ZmZlciBpbmNvbWluZyBjYXB0aW9ucyB1bnRpbCB0aGUgYXNzb2NpYXRlZCB2aWRlbyBzZWdtZW50XG4gICAgICAgIC8vIGZpbmlzaGVzXG4gICAgICAgIGlmIChvdXRwdXQudGV4dCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdDYXB0aW9ucy5wdXNoKG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnVmZmVyIGluY29taW5nIGlkMyB0YWdzIHVudGlsIHRoZSBmaW5hbCBmbHVzaFxuICAgICAgICBpZiAob3V0cHV0LmZyYW1lcykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdNZXRhZGF0YS5wdXNoKG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhpcyB0cmFjayB0byB0aGUgbGlzdCBvZiBwZW5kaW5nIHRyYWNrcyBhbmQgc3RvcmVcbiAgICAgICAgLy8gaW1wb3J0YW50IGluZm9ybWF0aW9uIHJlcXVpcmVkIGZvciB0aGUgY29uc3RydWN0aW9uIG9mXG4gICAgICAgIC8vIHRoZSBmaW5hbCBzZWdtZW50XG4gICAgICAgIHRoaXMucGVuZGluZ1RyYWNrcy5wdXNoKG91dHB1dC50cmFjayk7XG4gICAgICAgIHRoaXMucGVuZGluZ0JveGVzLnB1c2gob3V0cHV0LmJveGVzKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nQnl0ZXMgKz0gb3V0cHV0LmJveGVzLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgaWYgKG91dHB1dC50cmFjay50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgdGhpcy52aWRlb1RyYWNrID0gb3V0cHV0LnRyYWNrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRwdXQudHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgIHRoaXMuYXVkaW9UcmFjayA9IG91dHB1dC50cmFjaztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX0NvYWxlc2NlU3RyZWFtLnByb3RvdHlwZSA9IG5ldyBzdHJlYW0oKTtcbiAgICBfQ29hbGVzY2VTdHJlYW0ucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGZsdXNoU291cmNlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCxcbiAgICAgICAgICBldmVudCA9IHtcbiAgICAgICAgY2FwdGlvbnM6IFtdLFxuICAgICAgICBjYXB0aW9uU3RyZWFtczoge30sXG4gICAgICAgIG1ldGFkYXRhOiBbXSxcbiAgICAgICAgaW5mbzoge31cbiAgICAgIH0sXG4gICAgICAgICAgY2FwdGlvbixcbiAgICAgICAgICBpZDMsXG4gICAgICAgICAgaW5pdFNlZ21lbnQsXG4gICAgICAgICAgdGltZWxpbmVTdGFydFB0cyA9IDAsXG4gICAgICAgICAgaTtcblxuICAgICAgaWYgKHRoaXMucGVuZGluZ1RyYWNrcy5sZW5ndGggPCB0aGlzLm51bWJlck9mVHJhY2tzKSB7XG4gICAgICAgIGlmIChmbHVzaFNvdXJjZSAhPT0gJ1ZpZGVvU2VnbWVudFN0cmVhbScgJiYgZmx1c2hTb3VyY2UgIT09ICdBdWRpb1NlZ21lbnRTdHJlYW0nKSB7XG4gICAgICAgICAgLy8gUmV0dXJuIGJlY2F1c2Ugd2UgaGF2ZW4ndCByZWNlaXZlZCBhIGZsdXNoIGZyb20gYSBkYXRhLWdlbmVyYXRpbmdcbiAgICAgICAgICAvLyBwb3J0aW9uIG9mIHRoZSBzZWdtZW50IChtZWFuaW5nIHRoYXQgd2UgaGF2ZSBvbmx5IHJlY2lldmVkIG1ldGEtZGF0YVxuICAgICAgICAgIC8vIG9yIGNhcHRpb25zLilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5yZW11eFRyYWNrcykge1xuICAgICAgICAgIC8vIFJldHVybiB1bnRpbCB3ZSBoYXZlIGVub3VnaCB0cmFja3MgZnJvbSB0aGUgcGlwZWxpbmUgdG8gcmVtdXggKGlmIHdlXG4gICAgICAgICAgLy8gYXJlIHJlbXV4aW5nIGF1ZGlvIGFuZCB2aWRlbyBpbnRvIGEgc2luZ2xlIE1QNClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wZW5kaW5nVHJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIEluIHRoZSBjYXNlIHdoZXJlIHdlIHJlY2VpdmUgYSBmbHVzaCB3aXRob3V0IGFueSBkYXRhIGhhdmluZyBiZWVuXG4gICAgICAgICAgLy8gcmVjZWl2ZWQgd2UgY29uc2lkZXIgaXQgYW4gZW1pdHRlZCB0cmFjayBmb3IgdGhlIHB1cnBvc2VzIG9mIGNvYWxlc2NpbmdcbiAgICAgICAgICAvLyBgZG9uZWAgZXZlbnRzLlxuICAgICAgICAgIC8vIFdlIGRvIHRoaXMgZm9yIHRoZSBjYXNlIHdoZXJlIHRoZXJlIGlzIGFuIGF1ZGlvIGFuZCB2aWRlbyB0cmFjayBpbiB0aGVcbiAgICAgICAgICAvLyBzZWdtZW50IGJ1dCBubyBhdWRpbyBkYXRhLiAoc2VlbiBpbiBzZXZlcmFsIHBsYXlsaXN0cyB3aXRoIGFsdGVybmF0ZVxuICAgICAgICAgIC8vIGF1ZGlvIHRyYWNrcyBhbmQgbm8gYXVkaW8gcHJlc2VudCBpbiB0aGUgbWFpbiBUUyBzZWdtZW50cy4pXG4gICAgICAgICAgdGhpcy5lbWl0dGVkVHJhY2tzKys7XG5cbiAgICAgICAgICBpZiAodGhpcy5lbWl0dGVkVHJhY2tzID49IHRoaXMubnVtYmVyT2ZUcmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZG9uZScpO1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVkVHJhY2tzID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnZpZGVvVHJhY2spIHtcbiAgICAgICAgdGltZWxpbmVTdGFydFB0cyA9IHRoaXMudmlkZW9UcmFjay50aW1lbGluZVN0YXJ0SW5mby5wdHM7XG4gICAgICAgIFZJREVPX1BST1BFUlRJRVMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgIGV2ZW50LmluZm9bcHJvcF0gPSB0aGlzLnZpZGVvVHJhY2tbcHJvcF07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmF1ZGlvVHJhY2spIHtcbiAgICAgICAgdGltZWxpbmVTdGFydFB0cyA9IHRoaXMuYXVkaW9UcmFjay50aW1lbGluZVN0YXJ0SW5mby5wdHM7XG4gICAgICAgIEFVRElPX1BST1BFUlRJRVMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgIGV2ZW50LmluZm9bcHJvcF0gPSB0aGlzLmF1ZGlvVHJhY2tbcHJvcF07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wZW5kaW5nVHJhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBldmVudC50eXBlID0gdGhpcy5wZW5kaW5nVHJhY2tzWzBdLnR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudC50eXBlID0gJ2NvbWJpbmVkJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0dGVkVHJhY2tzICs9IHRoaXMucGVuZGluZ1RyYWNrcy5sZW5ndGg7XG5cbiAgICAgIGluaXRTZWdtZW50ID0gbXA0R2VuZXJhdG9yLmluaXRTZWdtZW50KHRoaXMucGVuZGluZ1RyYWNrcyk7XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyB0eXBlZCBhcnJheSB0byBob2xkIHRoZSBpbml0IHNlZ21lbnRcbiAgICAgIGV2ZW50LmluaXRTZWdtZW50ID0gbmV3IFVpbnQ4QXJyYXkoaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCk7XG5cbiAgICAgIC8vIENyZWF0ZSBhbiBpbml0IHNlZ21lbnQgY29udGFpbmluZyBhIG1vb3ZcbiAgICAgIC8vIGFuZCB0cmFjayBkZWZpbml0aW9uc1xuICAgICAgZXZlbnQuaW5pdFNlZ21lbnQuc2V0KGluaXRTZWdtZW50KTtcblxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IHR5cGVkIGFycmF5IHRvIGhvbGQgdGhlIG1vb2YrbWRhdHNcbiAgICAgIGV2ZW50LmRhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLnBlbmRpbmdCeXRlcyk7XG5cbiAgICAgIC8vIEFwcGVuZCBlYWNoIG1vb2YrbWRhdCAob25lIHBlciB0cmFjaykgdG9nZXRoZXJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdCb3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBldmVudC5kYXRhLnNldCh0aGlzLnBlbmRpbmdCb3hlc1tpXSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHRoaXMucGVuZGluZ0JveGVzW2ldLmJ5dGVMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyYW5zbGF0ZSBjYXB0aW9uIFBUUyB0aW1lcyBpbnRvIHNlY29uZCBvZmZzZXRzIGludG8gdGhlXG4gICAgICAvLyB2aWRlbyB0aW1lbGluZSBmb3IgdGhlIHNlZ21lbnQsIGFuZCBhZGQgdHJhY2sgaW5mb1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucGVuZGluZ0NhcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhcHRpb24gPSB0aGlzLnBlbmRpbmdDYXB0aW9uc1tpXTtcbiAgICAgICAgY2FwdGlvbi5zdGFydFRpbWUgPSBjYXB0aW9uLnN0YXJ0UHRzIC0gdGltZWxpbmVTdGFydFB0cztcbiAgICAgICAgY2FwdGlvbi5zdGFydFRpbWUgLz0gOTBlMztcbiAgICAgICAgY2FwdGlvbi5lbmRUaW1lID0gY2FwdGlvbi5lbmRQdHMgLSB0aW1lbGluZVN0YXJ0UHRzO1xuICAgICAgICBjYXB0aW9uLmVuZFRpbWUgLz0gOTBlMztcbiAgICAgICAgZXZlbnQuY2FwdGlvblN0cmVhbXNbY2FwdGlvbi5zdHJlYW1dID0gdHJ1ZTtcbiAgICAgICAgZXZlbnQuY2FwdGlvbnMucHVzaChjYXB0aW9uKTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJhbnNsYXRlIElEMyBmcmFtZSBQVFMgdGltZXMgaW50byBzZWNvbmQgb2Zmc2V0cyBpbnRvIHRoZVxuICAgICAgLy8gdmlkZW8gdGltZWxpbmUgZm9yIHRoZSBzZWdtZW50XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nTWV0YWRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWQzID0gdGhpcy5wZW5kaW5nTWV0YWRhdGFbaV07XG4gICAgICAgIGlkMy5jdWVUaW1lID0gaWQzLnB0cyAtIHRpbWVsaW5lU3RhcnRQdHM7XG4gICAgICAgIGlkMy5jdWVUaW1lIC89IDkwZTM7XG4gICAgICAgIGV2ZW50Lm1ldGFkYXRhLnB1c2goaWQzKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGFkZCB0aGlzIHRvIGV2ZXJ5IHNpbmdsZSBlbWl0dGVkIHNlZ21lbnQgZXZlbiB0aG91Z2ggd2Ugb25seSBuZWVkXG4gICAgICAvLyBpdCBmb3IgdGhlIGZpcnN0XG4gICAgICBldmVudC5tZXRhZGF0YS5kaXNwYXRjaFR5cGUgPSB0aGlzLm1ldGFkYXRhU3RyZWFtLmRpc3BhdGNoVHlwZTtcblxuICAgICAgLy8gUmVzZXQgc3RyZWFtIHN0YXRlXG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3MubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMudmlkZW9UcmFjayA9IG51bGw7XG4gICAgICB0aGlzLnBlbmRpbmdCb3hlcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5wZW5kaW5nQ2FwdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMucGVuZGluZ0J5dGVzID0gMDtcbiAgICAgIHRoaXMucGVuZGluZ01ldGFkYXRhLmxlbmd0aCA9IDA7XG5cbiAgICAgIC8vIEVtaXQgdGhlIGJ1aWx0IHNlZ21lbnRcbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcblxuICAgICAgLy8gT25seSBlbWl0IGBkb25lYCBpZiBhbGwgdHJhY2tzIGhhdmUgYmVlbiBmbHVzaGVkIGFuZCBlbWl0dGVkXG4gICAgICBpZiAodGhpcy5lbWl0dGVkVHJhY2tzID49IHRoaXMubnVtYmVyT2ZUcmFja3MpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkb25lJyk7XG4gICAgICAgIHRoaXMuZW1pdHRlZFRyYWNrcyA9IDA7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIFN0cmVhbSB0aGF0IGV4cGVjdHMgTVAyVCBiaW5hcnkgZGF0YSBhcyBpbnB1dCBhbmQgcHJvZHVjZXNcbiAgICAgKiBjb3JyZXNwb25kaW5nIG1lZGlhIHNlZ21lbnRzLCBzdWl0YWJsZSBmb3IgdXNlIHdpdGggTWVkaWEgU291cmNlXG4gICAgICogRXh0ZW5zaW9uIChNU0UpIGltcGxlbWVudGF0aW9ucyB0aGF0IHN1cHBvcnQgdGhlIElTTyBCTUZGIGJ5dGVcbiAgICAgKiBzdHJlYW0gZm9ybWF0LCBsaWtlIENocm9tZS5cbiAgICAgKi9cbiAgICBfVHJhbnNtdXhlciA9IGZ1bmN0aW9uIFRyYW5zbXV4ZXIob3B0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgIGhhc0ZsdXNoZWQgPSB0cnVlLFxuICAgICAgICAgIHZpZGVvVHJhY2ssXG4gICAgICAgICAgYXVkaW9UcmFjaztcblxuICAgICAgX1RyYW5zbXV4ZXIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLmJhc2VNZWRpYURlY29kZVRpbWUgPSBvcHRpb25zLmJhc2VNZWRpYURlY29kZVRpbWUgfHwgMDtcbiAgICAgIHRoaXMudHJhbnNtdXhQaXBlbGluZV8gPSB7fTtcblxuICAgICAgdGhpcy5zZXR1cEFhY1BpcGVsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGlwZWxpbmUgPSB7fTtcbiAgICAgICAgdGhpcy50cmFuc211eFBpcGVsaW5lXyA9IHBpcGVsaW5lO1xuXG4gICAgICAgIHBpcGVsaW5lLnR5cGUgPSAnYWFjJztcbiAgICAgICAgcGlwZWxpbmUubWV0YWRhdGFTdHJlYW0gPSBuZXcgbTJ0c18xLk1ldGFkYXRhU3RyZWFtKCk7XG5cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gICAgICAgIHBpcGVsaW5lLmFhY1N0cmVhbSA9IG5ldyBhYWMoKTtcbiAgICAgICAgcGlwZWxpbmUuYXVkaW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSA9IG5ldyBtMnRzXzEuVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0oJ2F1ZGlvJyk7XG4gICAgICAgIHBpcGVsaW5lLnRpbWVkTWV0YWRhdGFUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSA9IG5ldyBtMnRzXzEuVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0oJ3RpbWVkLW1ldGFkYXRhJyk7XG4gICAgICAgIHBpcGVsaW5lLmFkdHNTdHJlYW0gPSBuZXcgYWR0cygpO1xuICAgICAgICBwaXBlbGluZS5jb2FsZXNjZVN0cmVhbSA9IG5ldyBfQ29hbGVzY2VTdHJlYW0ob3B0aW9ucywgcGlwZWxpbmUubWV0YWRhdGFTdHJlYW0pO1xuICAgICAgICBwaXBlbGluZS5oZWFkT2ZQaXBlbGluZSA9IHBpcGVsaW5lLmFhY1N0cmVhbTtcblxuICAgICAgICBwaXBlbGluZS5hYWNTdHJlYW0ucGlwZShwaXBlbGluZS5hdWRpb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtKS5waXBlKHBpcGVsaW5lLmFkdHNTdHJlYW0pO1xuICAgICAgICBwaXBlbGluZS5hYWNTdHJlYW0ucGlwZShwaXBlbGluZS50aW1lZE1ldGFkYXRhVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0pLnBpcGUocGlwZWxpbmUubWV0YWRhdGFTdHJlYW0pLnBpcGUocGlwZWxpbmUuY29hbGVzY2VTdHJlYW0pO1xuXG4gICAgICAgIHBpcGVsaW5lLm1ldGFkYXRhU3RyZWFtLm9uKCd0aW1lc3RhbXAnLCBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICBwaXBlbGluZS5hYWNTdHJlYW0uc2V0VGltZXN0YW1wKGZyYW1lLnRpbWVTdGFtcCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBpcGVsaW5lLmFhY1N0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3RpbWVkLW1ldGFkYXRhJyAmJiAhcGlwZWxpbmUuYXVkaW9TZWdtZW50U3RyZWFtKSB7XG4gICAgICAgICAgICBhdWRpb1RyYWNrID0gYXVkaW9UcmFjayB8fCB7XG4gICAgICAgICAgICAgIHRpbWVsaW5lU3RhcnRJbmZvOiB7XG4gICAgICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZTogc2VsZi5iYXNlTWVkaWFEZWNvZGVUaW1lXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNvZGVjOiAnYWR0cycsXG4gICAgICAgICAgICAgIHR5cGU6ICdhdWRpbydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBob29rIHVwIHRoZSBhdWRpbyBzZWdtZW50IHN0cmVhbSB0byB0aGUgZmlyc3QgdHJhY2sgd2l0aCBhYWMgZGF0YVxuICAgICAgICAgICAgcGlwZWxpbmUuY29hbGVzY2VTdHJlYW0ubnVtYmVyT2ZUcmFja3MrKztcbiAgICAgICAgICAgIHBpcGVsaW5lLmF1ZGlvU2VnbWVudFN0cmVhbSA9IG5ldyBfQXVkaW9TZWdtZW50U3RyZWFtKGF1ZGlvVHJhY2ssIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBhdWRpbyBwaXBlbGluZVxuICAgICAgICAgICAgcGlwZWxpbmUuYWR0c1N0cmVhbS5waXBlKHBpcGVsaW5lLmF1ZGlvU2VnbWVudFN0cmVhbSkucGlwZShwaXBlbGluZS5jb2FsZXNjZVN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZS1lbWl0IGFueSBkYXRhIGNvbWluZyBmcm9tIHRoZSBjb2FsZXNjZSBzdHJlYW0gdG8gdGhlIG91dHNpZGUgd29ybGRcbiAgICAgICAgcGlwZWxpbmUuY29hbGVzY2VTdHJlYW0ub24oJ2RhdGEnLCB0aGlzLnRyaWdnZXIuYmluZCh0aGlzLCAnZGF0YScpKTtcbiAgICAgICAgLy8gTGV0IHRoZSBjb25zdW1lciBrbm93IHdlIGhhdmUgZmluaXNoZWQgZmx1c2hpbmcgdGhlIGVudGlyZSBwaXBlbGluZVxuICAgICAgICBwaXBlbGluZS5jb2FsZXNjZVN0cmVhbS5vbignZG9uZScsIHRoaXMudHJpZ2dlci5iaW5kKHRoaXMsICdkb25lJykpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5zZXR1cFRzUGlwZWxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwaXBlbGluZSA9IHt9O1xuICAgICAgICB0aGlzLnRyYW5zbXV4UGlwZWxpbmVfID0gcGlwZWxpbmU7XG5cbiAgICAgICAgcGlwZWxpbmUudHlwZSA9ICd0cyc7XG4gICAgICAgIHBpcGVsaW5lLm1ldGFkYXRhU3RyZWFtID0gbmV3IG0ydHNfMS5NZXRhZGF0YVN0cmVhbSgpO1xuXG4gICAgICAgIC8vIHNldCB1cCB0aGUgcGFyc2luZyBwaXBlbGluZVxuICAgICAgICBwaXBlbGluZS5wYWNrZXRTdHJlYW0gPSBuZXcgbTJ0c18xLlRyYW5zcG9ydFBhY2tldFN0cmVhbSgpO1xuICAgICAgICBwaXBlbGluZS5wYXJzZVN0cmVhbSA9IG5ldyBtMnRzXzEuVHJhbnNwb3J0UGFyc2VTdHJlYW0oKTtcbiAgICAgICAgcGlwZWxpbmUuZWxlbWVudGFyeVN0cmVhbSA9IG5ldyBtMnRzXzEuRWxlbWVudGFyeVN0cmVhbSgpO1xuICAgICAgICBwaXBlbGluZS52aWRlb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtID0gbmV3IG0ydHNfMS5UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSgndmlkZW8nKTtcbiAgICAgICAgcGlwZWxpbmUuYXVkaW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSA9IG5ldyBtMnRzXzEuVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0oJ2F1ZGlvJyk7XG4gICAgICAgIHBpcGVsaW5lLnRpbWVkTWV0YWRhdGFUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSA9IG5ldyBtMnRzXzEuVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0oJ3RpbWVkLW1ldGFkYXRhJyk7XG4gICAgICAgIHBpcGVsaW5lLmFkdHNTdHJlYW0gPSBuZXcgYWR0cygpO1xuICAgICAgICBwaXBlbGluZS5oMjY0U3RyZWFtID0gbmV3IEgyNjRTdHJlYW0oKTtcbiAgICAgICAgcGlwZWxpbmUuY2FwdGlvblN0cmVhbSA9IG5ldyBtMnRzXzEuQ2FwdGlvblN0cmVhbSgpO1xuICAgICAgICBwaXBlbGluZS5jb2FsZXNjZVN0cmVhbSA9IG5ldyBfQ29hbGVzY2VTdHJlYW0ob3B0aW9ucywgcGlwZWxpbmUubWV0YWRhdGFTdHJlYW0pO1xuICAgICAgICBwaXBlbGluZS5oZWFkT2ZQaXBlbGluZSA9IHBpcGVsaW5lLnBhY2tldFN0cmVhbTtcblxuICAgICAgICAvLyBkaXNhc3NlbWJsZSBNUEVHMi1UUyBwYWNrZXRzIGludG8gZWxlbWVudGFyeSBzdHJlYW1zXG4gICAgICAgIHBpcGVsaW5lLnBhY2tldFN0cmVhbS5waXBlKHBpcGVsaW5lLnBhcnNlU3RyZWFtKS5waXBlKHBpcGVsaW5lLmVsZW1lbnRhcnlTdHJlYW0pO1xuXG4gICAgICAgIC8vICEhVEhJUyBPUkRFUiBJUyBJTVBPUlRBTlQhIVxuICAgICAgICAvLyBkZW11eCB0aGUgc3RyZWFtc1xuICAgICAgICBwaXBlbGluZS5lbGVtZW50YXJ5U3RyZWFtLnBpcGUocGlwZWxpbmUudmlkZW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSkucGlwZShwaXBlbGluZS5oMjY0U3RyZWFtKTtcbiAgICAgICAgcGlwZWxpbmUuZWxlbWVudGFyeVN0cmVhbS5waXBlKHBpcGVsaW5lLmF1ZGlvVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0pLnBpcGUocGlwZWxpbmUuYWR0c1N0cmVhbSk7XG5cbiAgICAgICAgcGlwZWxpbmUuZWxlbWVudGFyeVN0cmVhbS5waXBlKHBpcGVsaW5lLnRpbWVkTWV0YWRhdGFUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSkucGlwZShwaXBlbGluZS5tZXRhZGF0YVN0cmVhbSkucGlwZShwaXBlbGluZS5jb2FsZXNjZVN0cmVhbSk7XG5cbiAgICAgICAgLy8gSG9vayB1cCBDRUEtNjA4LzcwOCBjYXB0aW9uIHN0cmVhbVxuICAgICAgICBwaXBlbGluZS5oMjY0U3RyZWFtLnBpcGUocGlwZWxpbmUuY2FwdGlvblN0cmVhbSkucGlwZShwaXBlbGluZS5jb2FsZXNjZVN0cmVhbSk7XG5cbiAgICAgICAgcGlwZWxpbmUuZWxlbWVudGFyeVN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnbWV0YWRhdGEnKSB7XG4gICAgICAgICAgICBpID0gZGF0YS50cmFja3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBzY2FuIHRoZSB0cmFja3MgbGlzdGVkIGluIHRoZSBtZXRhZGF0YVxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICBpZiAoIXZpZGVvVHJhY2sgJiYgZGF0YS50cmFja3NbaV0udHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICAgIHZpZGVvVHJhY2sgPSBkYXRhLnRyYWNrc1tpXTtcbiAgICAgICAgICAgICAgICB2aWRlb1RyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmJhc2VNZWRpYURlY29kZVRpbWUgPSBzZWxmLmJhc2VNZWRpYURlY29kZVRpbWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWF1ZGlvVHJhY2sgJiYgZGF0YS50cmFja3NbaV0udHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2sgPSBkYXRhLnRyYWNrc1tpXTtcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmJhc2VNZWRpYURlY29kZVRpbWUgPSBzZWxmLmJhc2VNZWRpYURlY29kZVRpbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaG9vayB1cCB0aGUgdmlkZW8gc2VnbWVudCBzdHJlYW0gdG8gdGhlIGZpcnN0IHRyYWNrIHdpdGggaDI2NCBkYXRhXG4gICAgICAgICAgICBpZiAodmlkZW9UcmFjayAmJiAhcGlwZWxpbmUudmlkZW9TZWdtZW50U3RyZWFtKSB7XG4gICAgICAgICAgICAgIHBpcGVsaW5lLmNvYWxlc2NlU3RyZWFtLm51bWJlck9mVHJhY2tzKys7XG4gICAgICAgICAgICAgIHBpcGVsaW5lLnZpZGVvU2VnbWVudFN0cmVhbSA9IG5ldyBfVmlkZW9TZWdtZW50U3RyZWFtKHZpZGVvVHJhY2ssIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgIHBpcGVsaW5lLnZpZGVvU2VnbWVudFN0cmVhbS5vbigndGltZWxpbmVTdGFydEluZm8nLCBmdW5jdGlvbiAodGltZWxpbmVTdGFydEluZm8pIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHZpZGVvIGVtaXRzIHRpbWVsaW5lU3RhcnRJbmZvIGRhdGEgYWZ0ZXIgYSBmbHVzaCwgd2UgZm9yd2FyZCB0aGF0XG4gICAgICAgICAgICAgICAgLy8gaW5mbyB0byB0aGUgQXVkaW9TZWdtZW50U3RyZWFtLCBpZiBpdCBleGlzdHMsIGJlY2F1c2UgdmlkZW8gdGltZWxpbmVcbiAgICAgICAgICAgICAgICAvLyBkYXRhIHRha2VzIHByZWNlZGVuY2UuXG4gICAgICAgICAgICAgICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2sudGltZWxpbmVTdGFydEluZm8gPSB0aW1lbGluZVN0YXJ0SW5mbztcbiAgICAgICAgICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBzZWdtZW50IHdlIHRyaW0gQUFDIGZyYW1lcyB0aGF0IGV4aXN0IGJlZm9yZSB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIHZlcnkgZWFybGllc3QgRFRTIHdlIGhhdmUgc2VlbiBpbiB2aWRlbyBiZWNhdXNlIENocm9tZSB3aWxsXG4gICAgICAgICAgICAgICAgICAvLyBpbnRlcnByZXQgYW55IHZpZGVvIHRyYWNrIHdpdGggYSBiYXNlTWVkaWFEZWNvZGVUaW1lIHRoYXQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIG5vbi16ZXJvIGFzIGEgZ2FwLlxuICAgICAgICAgICAgICAgICAgcGlwZWxpbmUuYXVkaW9TZWdtZW50U3RyZWFtLnNldEVhcmxpZXN0RHRzKHRpbWVsaW5lU3RhcnRJbmZvLmR0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBwaXBlbGluZS52aWRlb1NlZ21lbnRTdHJlYW0ub24oJ3Byb2Nlc3NlZEdvcHNJbmZvJywgc2VsZi50cmlnZ2VyLmJpbmQoc2VsZiwgJ2dvcEluZm8nKSk7XG5cbiAgICAgICAgICAgICAgcGlwZWxpbmUudmlkZW9TZWdtZW50U3RyZWFtLm9uKCdiYXNlTWVkaWFEZWNvZGVUaW1lJywgZnVuY3Rpb24gKGJhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9UcmFjaykge1xuICAgICAgICAgICAgICAgICAgcGlwZWxpbmUuYXVkaW9TZWdtZW50U3RyZWFtLnNldFZpZGVvQmFzZU1lZGlhRGVjb2RlVGltZShiYXNlTWVkaWFEZWNvZGVUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgZmluYWwgcGFydCBvZiB0aGUgdmlkZW8gcGlwZWxpbmVcbiAgICAgICAgICAgICAgcGlwZWxpbmUuaDI2NFN0cmVhbS5waXBlKHBpcGVsaW5lLnZpZGVvU2VnbWVudFN0cmVhbSkucGlwZShwaXBlbGluZS5jb2FsZXNjZVN0cmVhbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrICYmICFwaXBlbGluZS5hdWRpb1NlZ21lbnRTdHJlYW0pIHtcbiAgICAgICAgICAgICAgLy8gaG9vayB1cCB0aGUgYXVkaW8gc2VnbWVudCBzdHJlYW0gdG8gdGhlIGZpcnN0IHRyYWNrIHdpdGggYWFjIGRhdGFcbiAgICAgICAgICAgICAgcGlwZWxpbmUuY29hbGVzY2VTdHJlYW0ubnVtYmVyT2ZUcmFja3MrKztcbiAgICAgICAgICAgICAgcGlwZWxpbmUuYXVkaW9TZWdtZW50U3RyZWFtID0gbmV3IF9BdWRpb1NlZ21lbnRTdHJlYW0oYXVkaW9UcmFjaywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBhdWRpbyBwaXBlbGluZVxuICAgICAgICAgICAgICBwaXBlbGluZS5hZHRzU3RyZWFtLnBpcGUocGlwZWxpbmUuYXVkaW9TZWdtZW50U3RyZWFtKS5waXBlKHBpcGVsaW5lLmNvYWxlc2NlU3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlLWVtaXQgYW55IGRhdGEgY29taW5nIGZyb20gdGhlIGNvYWxlc2NlIHN0cmVhbSB0byB0aGUgb3V0c2lkZSB3b3JsZFxuICAgICAgICBwaXBlbGluZS5jb2FsZXNjZVN0cmVhbS5vbignZGF0YScsIHRoaXMudHJpZ2dlci5iaW5kKHRoaXMsICdkYXRhJykpO1xuICAgICAgICAvLyBMZXQgdGhlIGNvbnN1bWVyIGtub3cgd2UgaGF2ZSBmaW5pc2hlZCBmbHVzaGluZyB0aGUgZW50aXJlIHBpcGVsaW5lXG4gICAgICAgIHBpcGVsaW5lLmNvYWxlc2NlU3RyZWFtLm9uKCdkb25lJywgdGhpcy50cmlnZ2VyLmJpbmQodGhpcywgJ2RvbmUnKSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBob29rIHVwIHRoZSBzZWdtZW50IHN0cmVhbXMgb25jZSB0cmFjayBtZXRhZGF0YSBpcyBkZWxpdmVyZWRcbiAgICAgIHRoaXMuc2V0QmFzZU1lZGlhRGVjb2RlVGltZSA9IGZ1bmN0aW9uIChiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgICAgIHZhciBwaXBlbGluZSA9IHRoaXMudHJhbnNtdXhQaXBlbGluZV87XG5cbiAgICAgICAgdGhpcy5iYXNlTWVkaWFEZWNvZGVUaW1lID0gYmFzZU1lZGlhRGVjb2RlVGltZTtcbiAgICAgICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgICAgICBhdWRpb1RyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmR0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBhdWRpb1RyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLnB0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBjbGVhckR0c0luZm8oYXVkaW9UcmFjayk7XG4gICAgICAgICAgYXVkaW9UcmFjay50aW1lbGluZVN0YXJ0SW5mby5iYXNlTWVkaWFEZWNvZGVUaW1lID0gYmFzZU1lZGlhRGVjb2RlVGltZTtcbiAgICAgICAgICBpZiAocGlwZWxpbmUuYXVkaW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSkge1xuICAgICAgICAgICAgcGlwZWxpbmUuYXVkaW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbS5kaXNjb250aW51aXR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgICAgICAgaWYgKHBpcGVsaW5lLnZpZGVvU2VnbWVudFN0cmVhbSkge1xuICAgICAgICAgICAgcGlwZWxpbmUudmlkZW9TZWdtZW50U3RyZWFtLmdvcENhY2hlXyA9IFtdO1xuICAgICAgICAgICAgcGlwZWxpbmUudmlkZW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbS5kaXNjb250aW51aXR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZpZGVvVHJhY2sudGltZWxpbmVTdGFydEluZm8uZHRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHZpZGVvVHJhY2sudGltZWxpbmVTdGFydEluZm8ucHRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNsZWFyRHRzSW5mbyh2aWRlb1RyYWNrKTtcbiAgICAgICAgICBwaXBlbGluZS5jYXB0aW9uU3RyZWFtLnJlc2V0KCk7XG4gICAgICAgICAgdmlkZW9UcmFjay50aW1lbGluZVN0YXJ0SW5mby5iYXNlTWVkaWFEZWNvZGVUaW1lID0gYmFzZU1lZGlhRGVjb2RlVGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwaXBlbGluZS50aW1lZE1ldGFkYXRhVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0pIHtcbiAgICAgICAgICBwaXBlbGluZS50aW1lZE1ldGFkYXRhVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0uZGlzY29udGludWl0eSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnNldEF1ZGlvQXBwZW5kU3RhcnQgPSBmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICAgICAgdGhpcy50cmFuc211eFBpcGVsaW5lXy5hdWRpb1NlZ21lbnRTdHJlYW0uc2V0QXVkaW9BcHBlbmRTdGFydCh0aW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFsaWduR29wc1dpdGggPSBmdW5jdGlvbiAoZ29wc1RvQWxpZ25XaXRoKSB7XG4gICAgICAgIGlmICh2aWRlb1RyYWNrICYmIHRoaXMudHJhbnNtdXhQaXBlbGluZV8udmlkZW9TZWdtZW50U3RyZWFtKSB7XG4gICAgICAgICAgdGhpcy50cmFuc211eFBpcGVsaW5lXy52aWRlb1NlZ21lbnRTdHJlYW0uYWxpZ25Hb3BzV2l0aChnb3BzVG9BbGlnbldpdGgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gICAgICB0aGlzLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoaGFzRmx1c2hlZCkge1xuICAgICAgICAgIHZhciBpc0FhYyA9IGlzTGlrZWx5QWFjRGF0YShkYXRhKTtcblxuICAgICAgICAgIGlmIChpc0FhYyAmJiB0aGlzLnRyYW5zbXV4UGlwZWxpbmVfLnR5cGUgIT09ICdhYWMnKSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwQWFjUGlwZWxpbmUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFpc0FhYyAmJiB0aGlzLnRyYW5zbXV4UGlwZWxpbmVfLnR5cGUgIT09ICd0cycpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBUc1BpcGVsaW5lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhc0ZsdXNoZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zbXV4UGlwZWxpbmVfLmhlYWRPZlBpcGVsaW5lLnB1c2goZGF0YSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBmbHVzaCBhbnkgYnVmZmVyZWQgZGF0YVxuICAgICAgdGhpcy5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGFzRmx1c2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFN0YXJ0IGF0IHRoZSB0b3Agb2YgdGhlIHBpcGVsaW5lIGFuZCBmbHVzaCBhbGwgcGVuZGluZyB3b3JrXG4gICAgICAgIHRoaXMudHJhbnNtdXhQaXBlbGluZV8uaGVhZE9mUGlwZWxpbmUuZmx1c2goKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIENhcHRpb24gZGF0YSBoYXMgdG8gYmUgcmVzZXQgd2hlbiBzZWVraW5nIG91dHNpZGUgYnVmZmVyZWQgcmFuZ2VcbiAgICAgIHRoaXMucmVzZXRDYXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNtdXhQaXBlbGluZV8uY2FwdGlvblN0cmVhbSkge1xuICAgICAgICAgIHRoaXMudHJhbnNtdXhQaXBlbGluZV8uY2FwdGlvblN0cmVhbS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgX1RyYW5zbXV4ZXIucHJvdG90eXBlID0gbmV3IHN0cmVhbSgpO1xuXG4gICAgdmFyIHRyYW5zbXV4ZXIgPSB7XG4gICAgICBUcmFuc211eGVyOiBfVHJhbnNtdXhlcixcbiAgICAgIFZpZGVvU2VnbWVudFN0cmVhbTogX1ZpZGVvU2VnbWVudFN0cmVhbSxcbiAgICAgIEF1ZGlvU2VnbWVudFN0cmVhbTogX0F1ZGlvU2VnbWVudFN0cmVhbSxcbiAgICAgIEFVRElPX1BST1BFUlRJRVM6IEFVRElPX1BST1BFUlRJRVMsXG4gICAgICBWSURFT19QUk9QRVJUSUVTOiBWSURFT19QUk9QRVJUSUVTXG4gICAgfTtcblxuICAgIHZhciBtcDQgPSB7XG4gICAgICBnZW5lcmF0b3I6IG1wNEdlbmVyYXRvcixcbiAgICAgIFRyYW5zbXV4ZXI6IHRyYW5zbXV4ZXIuVHJhbnNtdXhlcixcbiAgICAgIEF1ZGlvU2VnbWVudFN0cmVhbTogdHJhbnNtdXhlci5BdWRpb1NlZ21lbnRTdHJlYW0sXG4gICAgICBWaWRlb1NlZ21lbnRTdHJlYW06IHRyYW5zbXV4ZXIuVmlkZW9TZWdtZW50U3RyZWFtXG4gICAgfTtcblxuICAgIHZhciBjbGFzc0NhbGxDaGVjayQkMSA9IGZ1bmN0aW9uIGNsYXNzQ2FsbENoZWNrJCQxKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUNsYXNzJCQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICAgICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQGZpbGUgdHJhbnNtdXhlci13b3JrZXIuanNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJlLWVtaXRzIHRyYW5zbXV4ZXIgZXZlbnRzIGJ5IGNvbnZlcnRpbmcgdGhlbSBpbnRvIG1lc3NhZ2VzIHRvIHRoZVxuICAgICAqIHdvcmxkIG91dHNpZGUgdGhlIHdvcmtlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc211eGVyIHRoZSB0cmFuc211eGVyIHRvIHdpcmUgZXZlbnRzIG9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgd2lyZVRyYW5zbXV4ZXJFdmVudHMgPSBmdW5jdGlvbiB3aXJlVHJhbnNtdXhlckV2ZW50cyh0cmFuc211eGVyKSB7XG4gICAgICB0cmFuc211eGVyLm9uKCdkYXRhJywgZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgLy8gdHJhbnNmZXIgb3duZXJzaGlwIG9mIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyXG4gICAgICAgIC8vIGluc3RlYWQgb2YgZG9pbmcgYSBjb3B5IHRvIHNhdmUgbWVtb3J5XG4gICAgICAgIC8vIEFycmF5QnVmZmVycyBhcmUgdHJhbnNmZXJhYmxlIGJ1dCBnZW5lcmljIFR5cGVkQXJyYXlzIGFyZSBub3RcbiAgICAgICAgLy8gQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSS9Vc2luZ193ZWJfd29ya2VycyNQYXNzaW5nX2RhdGFfYnlfdHJhbnNmZXJyaW5nX293bmVyc2hpcF8odHJhbnNmZXJhYmxlX29iamVjdHMpXG4gICAgICAgIHZhciBpbml0QXJyYXkgPSBzZWdtZW50LmluaXRTZWdtZW50O1xuXG4gICAgICAgIHNlZ21lbnQuaW5pdFNlZ21lbnQgPSB7XG4gICAgICAgICAgZGF0YTogaW5pdEFycmF5LmJ1ZmZlcixcbiAgICAgICAgICBieXRlT2Zmc2V0OiBpbml0QXJyYXkuYnl0ZU9mZnNldCxcbiAgICAgICAgICBieXRlTGVuZ3RoOiBpbml0QXJyYXkuYnl0ZUxlbmd0aFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0eXBlZEFycmF5ID0gc2VnbWVudC5kYXRhO1xuXG4gICAgICAgIHNlZ21lbnQuZGF0YSA9IHR5cGVkQXJyYXkuYnVmZmVyO1xuICAgICAgICB3aW5kb3dfMS5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgYWN0aW9uOiAnZGF0YScsXG4gICAgICAgICAgc2VnbWVudDogc2VnbWVudCxcbiAgICAgICAgICBieXRlT2Zmc2V0OiB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsXG4gICAgICAgICAgYnl0ZUxlbmd0aDogdHlwZWRBcnJheS5ieXRlTGVuZ3RoXG4gICAgICAgIH0sIFtzZWdtZW50LmRhdGFdKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHJhbnNtdXhlci5jYXB0aW9uU3RyZWFtKSB7XG4gICAgICAgIHRyYW5zbXV4ZXIuY2FwdGlvblN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjYXB0aW9uKSB7XG4gICAgICAgICAgd2luZG93XzEucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWN0aW9uOiAnY2FwdGlvbicsXG4gICAgICAgICAgICBkYXRhOiBjYXB0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0cmFuc211eGVyLm9uKCdkb25lJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgd2luZG93XzEucG9zdE1lc3NhZ2UoeyBhY3Rpb246ICdkb25lJyB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0cmFuc211eGVyLm9uKCdnb3BJbmZvJywgZnVuY3Rpb24gKGdvcEluZm8pIHtcbiAgICAgICAgd2luZG93XzEucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGFjdGlvbjogJ2dvcEluZm8nLFxuICAgICAgICAgIGdvcEluZm86IGdvcEluZm9cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxsIGluY29taW5nIG1lc3NhZ2VzIHJvdXRlIHRocm91Z2ggdGhpcyBoYXNoLiBJZiBubyBmdW5jdGlvbiBleGlzdHNcbiAgICAgKiB0byBoYW5kbGUgYW4gaW5jb21pbmcgbWVzc2FnZSwgdGhlbiB3ZSBpZ25vcmUgdGhlIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgTWVzc2FnZUhhbmRsZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gaW5pdGlhbGl6ZSB3aXRoXG4gICAgICovXG5cbiAgICB2YXIgTWVzc2FnZUhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTWVzc2FnZUhhbmRsZXJzKG9wdGlvbnMpIHtcbiAgICAgICAgY2xhc3NDYWxsQ2hlY2skJDEodGhpcywgTWVzc2FnZUhhbmRsZXJzKTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBpbml0aWFsaXplIG91ciB3ZWIgd29ya2VyIGFuZCB3aXJlIGFsbCB0aGUgZXZlbnRzLlxuICAgICAgICovXG5cbiAgICAgIGNyZWF0ZUNsYXNzJCQxKE1lc3NhZ2VIYW5kbGVycywgW3tcbiAgICAgICAga2V5OiAnaW5pdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgIGlmICh0aGlzLnRyYW5zbXV4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNtdXhlci5kaXNwb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudHJhbnNtdXhlciA9IG5ldyBtcDQuVHJhbnNtdXhlcih0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgIHdpcmVUcmFuc211eGVyRXZlbnRzKHRoaXMudHJhbnNtdXhlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBkYXRhIChhIHRzIHNlZ21lbnQpIHRvIHRoZSBzdGFydCBvZiB0aGUgdHJhbnNtdXhlciBwaXBlbGluZSBmb3JcbiAgICAgICAgICogcHJvY2Vzc2luZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSBkYXRhIHRvIHB1c2ggaW50byB0aGUgbXV4ZXJcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAncHVzaCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKGRhdGEpIHtcbiAgICAgICAgICAvLyBDYXN0IGFycmF5IGJ1ZmZlciB0byBjb3JyZWN0IHR5cGUgZm9yIHRyYW5zbXV4ZXJcbiAgICAgICAgICB2YXIgc2VnbWVudCA9IG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YSwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgICAgdGhpcy50cmFuc211eGVyLnB1c2goc2VnbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVjcmVhdGUgdGhlIHRyYW5zbXV4ZXIgc28gdGhhdCB0aGUgbmV4dCBzZWdtZW50IGFkZGVkIHZpYSBgcHVzaGBcbiAgICAgICAgICogc3RhcnQgd2l0aCBhIGZyZXNoIHRyYW5zbXV4ZXIuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgdmFsdWUgdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGBiYXNlTWVkaWFEZWNvZGVUaW1lYCB0aW1lIGZvciB0aGVcbiAgICAgICAgICogbmV4dCBzZWdtZW50IHB1c2hlZCBpbi4gU3Vic2VxdWVudCBzZWdtZW50cyB3aWxsIGhhdmUgdGhlaXIgYGJhc2VNZWRpYURlY29kZVRpbWVgXG4gICAgICAgICAqIHNldCByZWxhdGl2ZSB0byB0aGUgZmlyc3QgYmFzZWQgb24gdGhlIFBUUyB2YWx1ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIHVzZWQgdG8gc2V0IHRoZSB0aW1lc3RhbXAgb2Zmc2V0IGluIHRoZSBtdXhlclxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRUaW1lc3RhbXBPZmZzZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGltZXN0YW1wT2Zmc2V0KGRhdGEpIHtcbiAgICAgICAgICB2YXIgdGltZXN0YW1wT2Zmc2V0ID0gZGF0YS50aW1lc3RhbXBPZmZzZXQgfHwgMDtcblxuICAgICAgICAgIHRoaXMudHJhbnNtdXhlci5zZXRCYXNlTWVkaWFEZWNvZGVUaW1lKE1hdGgucm91bmQodGltZXN0YW1wT2Zmc2V0ICogOTAwMDApKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRBdWRpb0FwcGVuZFN0YXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF1ZGlvQXBwZW5kU3RhcnQoZGF0YSkge1xuICAgICAgICAgIHRoaXMudHJhbnNtdXhlci5zZXRBdWRpb0FwcGVuZFN0YXJ0KE1hdGguY2VpbChkYXRhLmFwcGVuZFN0YXJ0ICogOTAwMDApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JjZXMgdGhlIHBpcGVsaW5lIHRvIGZpbmlzaCBwcm9jZXNzaW5nIHRoZSBsYXN0IHNlZ21lbnQgYW5kIGVtaXQgaXQnc1xuICAgICAgICAgKiByZXN1bHRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBldmVudCBkYXRhLCBub3QgcmVhbGx5IHVzZWRcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZmx1c2gnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2goZGF0YSkge1xuICAgICAgICAgIHRoaXMudHJhbnNtdXhlci5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc2V0Q2FwdGlvbnMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRDYXB0aW9ucygpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXIucmVzZXRDYXB0aW9ucygpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2FsaWduR29wc1dpdGgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWxpZ25Hb3BzV2l0aChkYXRhKSB7XG4gICAgICAgICAgdGhpcy50cmFuc211eGVyLmFsaWduR29wc1dpdGgoZGF0YS5nb3BzVG9BbGlnbldpdGguc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICAgIHJldHVybiBNZXNzYWdlSGFuZGxlcnM7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogT3VyIHdlYiB3cm9rZXIgaW50ZXJmYWNlIHNvIHRoYXQgdGhpbmdzIGNhbiB0YWxrIHRvIG11eC5qc1xuICAgICAqIHRoYXQgd2lsbCBiZSBydW5uaW5nIGluIGEgd2ViIHdvcmtlci4gdGhlIHNjb3BlIGlzIHBhc3NlZCB0byB0aGlzIGJ5XG4gICAgICogd2Vid29ya2lmeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIHRoZSBzY29wZSBmb3IgdGhlIHdlYiB3b3JrZXJcbiAgICAgKi9cblxuICAgIHZhciBUcmFuc211eGVyV29ya2VyID0gZnVuY3Rpb24gVHJhbnNtdXhlcldvcmtlcihzZWxmKSB7XG4gICAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS5hY3Rpb24gPT09ICdpbml0JyAmJiBldmVudC5kYXRhLm9wdGlvbnMpIHtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycyA9IG5ldyBNZXNzYWdlSGFuZGxlcnMoZXZlbnQuZGF0YS5vcHRpb25zKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubWVzc2FnZUhhbmRsZXJzKSB7XG4gICAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcnMgPSBuZXcgTWVzc2FnZUhhbmRsZXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLmFjdGlvbiAmJiBldmVudC5kYXRhLmFjdGlvbiAhPT0gJ2luaXQnKSB7XG4gICAgICAgICAgaWYgKHRoaXMubWVzc2FnZUhhbmRsZXJzW2V2ZW50LmRhdGEuYWN0aW9uXSkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcnNbZXZlbnQuZGF0YS5hY3Rpb25dKGV2ZW50LmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHRyYW5zbXV4ZXJXb3JrZXIgPSBuZXcgVHJhbnNtdXhlcldvcmtlcihzZWxmKTtcblxuICAgIHJldHVybiB0cmFuc211eGVyV29ya2VyO1xuICB9KCk7XG59KTtcblxuLyoqXG4gKiBAZmlsZSBjb2RlYy11dGlscy5qc1xuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjb2RlYyBzdHJpbmcgcmVmZXJzIHRvIGFuIGF1ZGlvIGNvZGVjLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlYyBjb2RlYyBzdHJpbmcgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlmIHRoaXMgaXMgYW4gYXVkaW8gY29kZWNcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpc0F1ZGlvQ29kZWMgPSBmdW5jdGlvbiBpc0F1ZGlvQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuICgvbXA0YVxcLlxcZCsuXFxkKy9pLnRlc3QoY29kZWMpXG4gICk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgY29kZWMgc3RyaW5nIHJlZmVycyB0byBhIHZpZGVvIGNvZGVjLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlYyBjb2RlYyBzdHJpbmcgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlmIHRoaXMgaXMgYSB2aWRlbyBjb2RlY1xuICogQHByaXZhdGVcbiAqL1xudmFyIGlzVmlkZW9Db2RlYyA9IGZ1bmN0aW9uIGlzVmlkZW9Db2RlYyhjb2RlYykge1xuICByZXR1cm4gKC9hdmMxXFwuW1xcZGEtZl0rL2kudGVzdChjb2RlYylcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBjb250ZW50IHR5cGUgaGVhZGVyIGludG8gYSB0eXBlIGFuZCBwYXJhbWV0ZXJzXG4gKiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgY29udGVudCB0eXBlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgcGFyc2VkIGNvbnRlbnQtdHlwZVxuICogQHByaXZhdGVcbiAqL1xudmFyIHBhcnNlQ29udGVudFR5cGUgPSBmdW5jdGlvbiBwYXJzZUNvbnRlbnRUeXBlKHR5cGUpIHtcbiAgdmFyIG9iamVjdCA9IHsgdHlwZTogJycsIHBhcmFtZXRlcnM6IHt9IH07XG4gIHZhciBwYXJhbWV0ZXJzID0gdHlwZS50cmltKCkuc3BsaXQoJzsnKTtcblxuICAvLyBmaXJzdCBwYXJhbWV0ZXIgc2hvdWxkIGFsd2F5cyBiZSBjb250ZW50LXR5cGVcbiAgb2JqZWN0LnR5cGUgPSBwYXJhbWV0ZXJzLnNoaWZ0KCkudHJpbSgpO1xuICBwYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtZXRlcikge1xuICAgIHZhciBwYWlyID0gcGFyYW1ldGVyLnRyaW0oKS5zcGxpdCgnPScpO1xuXG4gICAgaWYgKHBhaXIubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIG5hbWUgPSBwYWlyWzBdLnJlcGxhY2UoL1wiL2csICcnKS50cmltKCk7XG4gICAgICB2YXIgdmFsdWUgPSBwYWlyWzFdLnJlcGxhY2UoL1wiL2csICcnKS50cmltKCk7XG5cbiAgICAgIG9iamVjdC5wYXJhbWV0ZXJzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb2JqZWN0O1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIHRoZSBvbGQgYXBwbGUtc3R5bGUgYGF2YzEuPGRkPi48ZGQ+YCBjb2RlYyBzdHJpbmcgd2l0aCB0aGUgc3RhbmRhcmRcbiAqIGBhdmMxLjxoaGhoaGg+YFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGNvZGVjcyBhbiBhcnJheSBvZiBjb2RlYyBzdHJpbmdzIHRvIGZpeFxuICogQHJldHVybiB7QXJyYXl9IHRoZSB0cmFuc2xhdGVkIGNvZGVjIGFycmF5XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdHJhbnNsYXRlTGVnYWN5Q29kZWNzID0gZnVuY3Rpb24gdHJhbnNsYXRlTGVnYWN5Q29kZWNzKGNvZGVjcykge1xuICByZXR1cm4gY29kZWNzLm1hcChmdW5jdGlvbiAoY29kZWMpIHtcbiAgICByZXR1cm4gY29kZWMucmVwbGFjZSgvYXZjMVxcLihcXGQrKVxcLihcXGQrKS9pLCBmdW5jdGlvbiAob3JpZywgcHJvZmlsZSwgYXZjTGV2ZWwpIHtcbiAgICAgIHZhciBwcm9maWxlSGV4ID0gKCcwMCcgKyBOdW1iZXIocHJvZmlsZSkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICB2YXIgYXZjTGV2ZWxIZXggPSAoJzAwJyArIE51bWJlcihhdmNMZXZlbCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG5cbiAgICAgIHJldHVybiAnYXZjMS4nICsgcHJvZmlsZUhleCArICcwMCcgKyBhdmNMZXZlbEhleDtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBmaWxlIHZpcnR1YWwtc291cmNlLWJ1ZmZlci5qc1xuICovXG5cbi8vIFdlIGNyZWF0ZSBhIHdyYXBwZXIgYXJvdW5kIHRoZSBTb3VyY2VCdWZmZXIgc28gdGhhdCB3ZSBjYW4gbWFuYWdlIHRoZVxuLy8gc3RhdGUgb2YgdGhlIGB1cGRhdGluZ2AgcHJvcGVydHkgbWFudWFsbHkuIFdlIGhhdmUgdG8gZG8gdGhpcyBiZWNhdXNlXG4vLyBGaXJlZm94IGNoYW5nZXMgYHVwZGF0aW5nYCB0byBmYWxzZSBsb25nIGJlZm9yZSB0cmlnZ2VyaW5nIGB1cGRhdGVlbmRgXG4vLyBldmVudHMgYW5kIHRoYXQgd2FzIGNhdXNpbmcgc3RyYW5nZSBwcm9ibGVtcyBpbiB2aWRlb2pzLWNvbnRyaWItaGxzXG52YXIgbWFrZVdyYXBwZWRTb3VyY2VCdWZmZXIgPSBmdW5jdGlvbiBtYWtlV3JhcHBlZFNvdXJjZUJ1ZmZlcihtZWRpYVNvdXJjZSwgbWltZVR5cGUpIHtcbiAgdmFyIHNvdXJjZUJ1ZmZlciA9IG1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihtaW1lVHlwZSk7XG4gIHZhciB3cmFwcGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB3cmFwcGVyLnVwZGF0aW5nID0gZmFsc2U7XG4gIHdyYXBwZXIucmVhbEJ1ZmZlcl8gPSBzb3VyY2VCdWZmZXI7XG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3Aoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VCdWZmZXJba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd3JhcHBlcltrZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc291cmNlQnVmZmVyW2tleV0uYXBwbHkoc291cmNlQnVmZmVyLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3cmFwcGVyW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod3JhcHBlciwga2V5LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgIHJldHVybiBzb3VyY2VCdWZmZXJba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICAgIHJldHVybiBzb3VyY2VCdWZmZXJba2V5XSA9IHY7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgX2xvb3Aoa2V5KTtcbiAgfVxuXG4gIHJldHVybiB3cmFwcGVyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBnb3BzIGluIHRoZSBidWZmZXIgdGhhdCBoYXZlIGEgcHRzIHZhbHVlIG9mIDMgc2Vjb25kcyBvciBtb3JlIGluXG4gKiBmcm9udCBvZiBjdXJyZW50IHRpbWUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYnVmZmVyXG4gKiAgICAgICAgVGhlIGN1cnJlbnQgYnVmZmVyIG9mIGdvcCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICogICAgICAgIFRoZSBwbGF5ZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RG91YmxlfSBtYXBwaW5nXG4gKiAgICAgICAgT2Zmc2V0IHRvIG1hcCBkaXNwbGF5IHRpbWUgdG8gc3RyZWFtIHByZXNlbnRhdGlvbiB0aW1lXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqICAgICAgICAgTGlzdCBvZiBnb3BzIGNvbnNpZGVyZWQgc2FmZSB0byBhcHBlbmQgb3ZlclxuICovXG52YXIgZ29wc1NhZmVUb0FsaWduV2l0aCA9IGZ1bmN0aW9uIGdvcHNTYWZlVG9BbGlnbldpdGgoYnVmZmVyLCBwbGF5ZXIsIG1hcHBpbmcpIHtcbiAgaWYgKCFwbGF5ZXIgfHwgIWJ1ZmZlci5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyBwdHMgdmFsdWUgZm9yIGN1cnJlbnQgdGltZSArIDMgc2Vjb25kcyB0byBnaXZlIGEgYml0IG1vcmUgd2lnZ2xlIHJvb21cbiAgdmFyIGN1cnJlbnRUaW1lUHRzID0gTWF0aC5jZWlsKChwbGF5ZXIuY3VycmVudFRpbWUoKSAtIG1hcHBpbmcgKyAzKSAqIDkwMDAwKTtcblxuICB2YXIgaSA9IHZvaWQgMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGJ1ZmZlcltpXS5wdHMgPiBjdXJyZW50VGltZVB0cykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlci5zbGljZShpKTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBnb3AgaW5mb3JtYXRpb24gKHRpbWluZyBhbmQgYnl0ZUxlbmd0aCkgcmVjZWl2ZWQgYnkgdGhlIHRyYW5zbXV4ZXIgZm9yIHRoZVxuICogZ29wcyBhcHBlbmRlZCBpbiB0aGUgbGFzdCBjYWxsIHRvIGFwcGVuZEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlclxuICogICAgICAgIFRoZSBjdXJyZW50IGJ1ZmZlciBvZiBnb3AgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSB7QXJyYXl9IGdvcHNcbiAqICAgICAgICBMaXN0IG9mIG5ldyBnb3AgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVwbGFjZVxuICogICAgICAgIElmIHRydWUsIHJlcGxhY2UgdGhlIGJ1ZmZlciB3aXRoIHRoZSBuZXcgZ29wIGluZm9ybWF0aW9uLiBJZiBmYWxzZSwgYXBwZW5kIHRoZVxuICogICAgICAgIG5ldyBnb3AgaW5mb3JtYXRpb24gdG8gdGhlIGJ1ZmZlciBpbiB0aGUgcmlnaHQgbG9jYXRpb24gb2YgdGltZS5cbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBVcGRhdGVkIGxpc3Qgb2YgZ29wIGluZm9ybWF0aW9uXG4gKi9cbnZhciB1cGRhdGVHb3BCdWZmZXIgPSBmdW5jdGlvbiB1cGRhdGVHb3BCdWZmZXIoYnVmZmVyLCBnb3BzLCByZXBsYWNlKSB7XG4gIGlmICghZ29wcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgaWYgKHJlcGxhY2UpIHtcbiAgICAvLyBJZiB3ZSBhcmUgaW4gc2FmZSBhcHBlbmQgbW9kZSwgdGhlbiBjb21wbGV0ZWx5IG92ZXJ3cml0ZSB0aGUgZ29wIGJ1ZmZlclxuICAgIC8vIHdpdGggdGhlIG1vc3QgcmVjZW50IGFwcGVuZWRlZCBkYXRhLiBUaGlzIHdpbGwgbWFrZSBzdXJlIHRoYXQgd2hlbiBhcHBlbmRpbmdcbiAgICAvLyBmdXR1cmUgc2VnbWVudHMsIHdlIG9ubHkgdHJ5IHRvIGFsaWduIHdpdGggZ29wcyB0aGF0IGFyZSBib3RoIGFoZWFkIG9mIGN1cnJlbnRcbiAgICAvLyB0aW1lIGFuZCBpbiB0aGUgbGFzdCBzZWdtZW50IGFwcGVuZGVkLlxuICAgIHJldHVybiBnb3BzLnNsaWNlKCk7XG4gIH1cblxuICB2YXIgc3RhcnQgPSBnb3BzWzBdLnB0cztcblxuICB2YXIgaSA9IDA7XG5cbiAgZm9yIChpOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGJ1ZmZlcltpXS5wdHMgPj0gc3RhcnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZmZXIuc2xpY2UoMCwgaSkuY29uY2F0KGdvcHMpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGdvcCBpbmZvcm1hdGlvbiBpbiBidWZmZXIgdGhhdCBvdmVybGFwcyB3aXRoIHByb3ZpZGVkIHN0YXJ0IGFuZCBlbmRcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJcbiAqICAgICAgICBUaGUgY3VycmVudCBidWZmZXIgb2YgZ29wIGluZm9ybWF0aW9uXG4gKiBAcGFyYW0ge0RvdWJsZX0gc3RhcnRcbiAqICAgICAgICBwb3NpdGlvbiB0byBzdGFydCB0aGUgcmVtb3ZlIGF0XG4gKiBAcGFyYW0ge0RvdWJsZX0gZW5kXG4gKiAgICAgICAgcG9zaXRpb24gdG8gZW5kIHRoZSByZW1vdmUgYXRcbiAqIEBwYXJhbSB7RG91YmxlfSBtYXBwaW5nXG4gKiAgICAgICAgT2Zmc2V0IHRvIG1hcCBkaXNwbGF5IHRpbWUgdG8gc3RyZWFtIHByZXNlbnRhdGlvbiB0aW1lXG4gKi9cbnZhciByZW1vdmVHb3BCdWZmZXIgPSBmdW5jdGlvbiByZW1vdmVHb3BCdWZmZXIoYnVmZmVyLCBzdGFydCwgZW5kLCBtYXBwaW5nKSB7XG4gIHZhciBzdGFydFB0cyA9IE1hdGguY2VpbCgoc3RhcnQgLSBtYXBwaW5nKSAqIDkwMDAwKTtcbiAgdmFyIGVuZFB0cyA9IE1hdGguY2VpbCgoZW5kIC0gbWFwcGluZykgKiA5MDAwMCk7XG4gIHZhciB1cGRhdGVkQnVmZmVyID0gYnVmZmVyLnNsaWNlKCk7XG5cbiAgdmFyIGkgPSBidWZmZXIubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoYnVmZmVyW2ldLnB0cyA8PSBlbmRQdHMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpID09PSAtMSkge1xuICAgIC8vIG5vIHJlbW92YWwgYmVjYXVzZSBlbmQgb2YgcmVtb3ZlIHJhbmdlIGlzIGJlZm9yZSBzdGFydCBvZiBidWZmZXJcbiAgICByZXR1cm4gdXBkYXRlZEJ1ZmZlcjtcbiAgfVxuXG4gIHZhciBqID0gaSArIDE7XG5cbiAgd2hpbGUgKGotLSkge1xuICAgIGlmIChidWZmZXJbal0ucHRzIDw9IHN0YXJ0UHRzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBjbGFtcCByZW1vdmUgcmFuZ2Ugc3RhcnQgdG8gMCBpbmRleFxuICBqID0gTWF0aC5tYXgoaiwgMCk7XG5cbiAgdXBkYXRlZEJ1ZmZlci5zcGxpY2UoaiwgaSAtIGogKyAxKTtcblxuICByZXR1cm4gdXBkYXRlZEJ1ZmZlcjtcbn07XG5cbi8qKlxuICogVmlydHVhbFNvdXJjZUJ1ZmZlcnMgZXhpc3Qgc28gdGhhdCB3ZSBjYW4gdHJhbnNtdXggbm9uIG5hdGl2ZSBmb3JtYXRzXG4gKiBpbnRvIGEgbmF0aXZlIGZvcm1hdCwgYnV0IGtlZXAgdGhlIHNhbWUgYXBpIGFzIGEgbmF0aXZlIHNvdXJjZSBidWZmZXIuXG4gKiBJdCBjcmVhdGVzIGEgdHJhbnNtdXhlciwgdGhhdCB3b3JrcyBpbiBpdHMgb3duIHRocmVhZCAoYSB3ZWIgd29ya2VyKSBhbmRcbiAqIHRoYXQgdHJhbnNtdXhlciBtdXhlcyB0aGUgZGF0YSBpbnRvIGEgbmF0aXZlIGZvcm1hdC4gVmlydHVhbFNvdXJjZUJ1ZmZlciB3aWxsXG4gKiB0aGVuIHNlbmQgYWxsIG9mIHRoYXQgZGF0YSB0byB0aGUgbmFpdmUgc291cmNlYnVmZmVyIHNvIHRoYXQgaXQgaXNcbiAqIGluZGVzdGluZ3Vpc2hhYmxlIGZyb20gYSBuYXRpdmVseSBzdXBwb3J0ZWQgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7SHRtbE1lZGlhU291cmNlfSBtZWRpYVNvdXJjZSB0aGUgcGFyZW50IG1lZGlhU291cmNlXG4gKiBAcGFyYW0ge0FycmF5fSBjb2RlY3MgYXJyYXkgb2YgY29kZWNzIHRoYXQgd2Ugd2lsbCBiZSBkZWFsaW5nIHdpdGhcbiAqIEBjbGFzcyBWaXJ0dWFsU291cmNlQnVmZmVyXG4gKiBAZXh0ZW5kcyB2aWRlby5qcy5FdmVudFRhcmdldFxuICovXG5cbnZhciBWaXJ0dWFsU291cmNlQnVmZmVyID0gZnVuY3Rpb24gKF92aWRlb2pzJEV2ZW50VGFyZ2V0KSB7XG4gIGluaGVyaXRzJDEoVmlydHVhbFNvdXJjZUJ1ZmZlciwgX3ZpZGVvanMkRXZlbnRUYXJnZXQpO1xuXG4gIGZ1bmN0aW9uIFZpcnR1YWxTb3VyY2VCdWZmZXIobWVkaWFTb3VyY2UsIGNvZGVjcykge1xuICAgIGNsYXNzQ2FsbENoZWNrJDEodGhpcywgVmlydHVhbFNvdXJjZUJ1ZmZlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJDEodGhpcywgKFZpcnR1YWxTb3VyY2VCdWZmZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihWaXJ0dWFsU291cmNlQnVmZmVyKSkuY2FsbCh0aGlzLCB2aWRlb2pzJDEuRXZlbnRUYXJnZXQpKTtcblxuICAgIF90aGlzLnRpbWVzdGFtcE9mZnNldF8gPSAwO1xuICAgIF90aGlzLnBlbmRpbmdCdWZmZXJzXyA9IFtdO1xuICAgIF90aGlzLmJ1ZmZlclVwZGF0aW5nXyA9IGZhbHNlO1xuXG4gICAgX3RoaXMubWVkaWFTb3VyY2VfID0gbWVkaWFTb3VyY2U7XG4gICAgX3RoaXMuY29kZWNzXyA9IGNvZGVjcztcbiAgICBfdGhpcy5hdWRpb0NvZGVjXyA9IG51bGw7XG4gICAgX3RoaXMudmlkZW9Db2RlY18gPSBudWxsO1xuICAgIF90aGlzLmF1ZGlvRGlzYWJsZWRfID0gZmFsc2U7XG4gICAgX3RoaXMuYXBwZW5kQXVkaW9Jbml0U2VnbWVudF8gPSB0cnVlO1xuICAgIF90aGlzLmdvcEJ1ZmZlcl8gPSBbXTtcbiAgICBfdGhpcy50aW1lTWFwcGluZ18gPSAwO1xuICAgIF90aGlzLnNhZmVBcHBlbmRfID0gdmlkZW9qcyQxLmJyb3dzZXIuSUVfVkVSU0lPTiA+PSAxMTtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgcmVtdXg6IGZhbHNlLFxuICAgICAgYWxpZ25Hb3BzQXRFbmQ6IF90aGlzLnNhZmVBcHBlbmRfXG4gICAgfTtcblxuICAgIF90aGlzLmNvZGVjc18uZm9yRWFjaChmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgIGlmIChpc0F1ZGlvQ29kZWMoY29kZWMpKSB7XG4gICAgICAgIF90aGlzLmF1ZGlvQ29kZWNfID0gY29kZWM7XG4gICAgICB9IGVsc2UgaWYgKGlzVmlkZW9Db2RlYyhjb2RlYykpIHtcbiAgICAgICAgX3RoaXMudmlkZW9Db2RlY18gPSBjb2RlYztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGFwcGVuZCBtdXhlZCBzZWdtZW50cyB0byB0aGVpciByZXNwZWN0aXZlIG5hdGl2ZSBidWZmZXJzIGFzXG4gICAgLy8gc29vbiBhcyB0aGV5IGFyZSBhdmFpbGFibGVcbiAgICBfdGhpcy50cmFuc211eGVyXyA9IG5ldyBUcmFuc211eFdvcmtlcigpO1xuICAgIF90aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiAnaW5pdCcsIG9wdGlvbnM6IG9wdGlvbnMgfSk7XG5cbiAgICBfdGhpcy50cmFuc211eGVyXy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kYXRhLmFjdGlvbiA9PT0gJ2RhdGEnKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5kYXRhXyhldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5kYXRhLmFjdGlvbiA9PT0gJ2RvbmUnKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5kb25lXyhldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5kYXRhLmFjdGlvbiA9PT0gJ2dvcEluZm8nKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5hcHBlbmRHb3BJbmZvXyhldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHRoaXMgdGltZXN0YW1wT2Zmc2V0IGlzIGEgcHJvcGVydHkgd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgcmVzZXR0aW5nXG4gICAgLy8gYmFzZU1lZGlhRGVjb2RlVGltZSBpbiB0aGUgdHJhbnNtdXhlciBvbiB0aGUgc2V0dGVyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCAndGltZXN0YW1wT2Zmc2V0Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcE9mZnNldF87XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodmFsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiB2YWwgPj0gMCkge1xuICAgICAgICAgIHRoaXMudGltZXN0YW1wT2Zmc2V0XyA9IHZhbDtcbiAgICAgICAgICB0aGlzLmFwcGVuZEF1ZGlvSW5pdFNlZ21lbnRfID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIHJlc2V0IGdvcCBidWZmZXIgb24gdGltZXN0YW1wb2Zmc2V0IGFzIHRoaXMgc2lnbmFscyBhIGNoYW5nZSBpbiB0aW1lbGluZVxuICAgICAgICAgIHRoaXMuZ29wQnVmZmVyXy5sZW5ndGggPSAwO1xuICAgICAgICAgIHRoaXMudGltZU1hcHBpbmdfID0gMDtcblxuICAgICAgICAgIC8vIFdlIGhhdmUgdG8gdGVsbCB0aGUgdHJhbnNtdXhlciB0byBzZXQgdGhlIGJhc2VNZWRpYURlY29kZVRpbWUgdG9cbiAgICAgICAgICAvLyB0aGUgZGVzaXJlZCB0aW1lc3RhbXBPZmZzZXQgZm9yIHRoZSBuZXh0IHNlZ21lbnRcbiAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGFjdGlvbjogJ3NldFRpbWVzdGFtcE9mZnNldCcsXG4gICAgICAgICAgICB0aW1lc3RhbXBPZmZzZXQ6IHZhbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBzZXR0aW5nIHRoZSBhcHBlbmQgd2luZG93IGFmZmVjdHMgYm90aCBzb3VyY2UgYnVmZmVyc1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgJ2FwcGVuZFdpbmRvd1N0YXJ0Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52aWRlb0J1ZmZlcl8gfHwgdGhpcy5hdWRpb0J1ZmZlcl8pLmFwcGVuZFdpbmRvd1N0YXJ0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLnZpZGVvQnVmZmVyXykge1xuICAgICAgICAgIHRoaXMudmlkZW9CdWZmZXJfLmFwcGVuZFdpbmRvd1N0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXVkaW9CdWZmZXJfKSB7XG4gICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcl8uYXBwZW5kV2luZG93U3RhcnQgPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gdGhpcyBidWZmZXIgaXMgXCJ1cGRhdGluZ1wiIGlmIGVpdGhlciBvZiBpdHMgbmF0aXZlIGJ1ZmZlcnMgYXJlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCAndXBkYXRpbmcnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuYnVmZmVyVXBkYXRpbmdfIHx8ICF0aGlzLmF1ZGlvRGlzYWJsZWRfICYmIHRoaXMuYXVkaW9CdWZmZXJfICYmIHRoaXMuYXVkaW9CdWZmZXJfLnVwZGF0aW5nIHx8IHRoaXMudmlkZW9CdWZmZXJfICYmIHRoaXMudmlkZW9CdWZmZXJfLnVwZGF0aW5nKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHRoZSBidWZmZXJlZCBwcm9wZXJ0eSBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSBidWZmZXJlZFxuICAgIC8vIHJhbmdlcyBvZiB0aGUgbmF0aXZlIHNvdXJjZSBidWZmZXJzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCAnYnVmZmVyZWQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdmFyIGVuZCA9IG51bGw7XG4gICAgICAgIHZhciBhcml0eSA9IDA7XG4gICAgICAgIHZhciBleHRlbnRzID0gW107XG4gICAgICAgIHZhciByYW5nZXMgPSBbXTtcblxuICAgICAgICAvLyBuZWl0aGVyIGJ1ZmZlciBoYXMgYmVlbiBjcmVhdGVkIHlldFxuICAgICAgICBpZiAoIXRoaXMudmlkZW9CdWZmZXJfICYmICF0aGlzLmF1ZGlvQnVmZmVyXykge1xuICAgICAgICAgIHJldHVybiB2aWRlb2pzJDEuY3JlYXRlVGltZVJhbmdlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbmx5IG9uZSBidWZmZXIgaXMgY29uZmlndXJlZFxuICAgICAgICBpZiAoIXRoaXMudmlkZW9CdWZmZXJfKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9CdWZmZXJfLmJ1ZmZlcmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5hdWRpb0J1ZmZlcl8pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52aWRlb0J1ZmZlcl8uYnVmZmVyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBib3RoIGJ1ZmZlcnMgYXJlIGNvbmZpZ3VyZWRcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9EaXNhYmxlZF8pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52aWRlb0J1ZmZlcl8uYnVmZmVyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBib3RoIGJ1ZmZlcnMgYXJlIGVtcHR5XG4gICAgICAgIGlmICh0aGlzLnZpZGVvQnVmZmVyXy5idWZmZXJlZC5sZW5ndGggPT09IDAgJiYgdGhpcy5hdWRpb0J1ZmZlcl8uYnVmZmVyZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZpZGVvanMkMS5jcmVhdGVUaW1lUmFuZ2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBoYXZlIGJvdGggYnVmZmVycyBhbmQgY3JlYXRlIGFuXG4gICAgICAgIC8vIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvXG4gICAgICAgIHZhciB2aWRlb0J1ZmZlcmVkID0gdGhpcy52aWRlb0J1ZmZlcl8uYnVmZmVyZWQ7XG4gICAgICAgIHZhciBhdWRpb0J1ZmZlcmVkID0gdGhpcy5hdWRpb0J1ZmZlcl8uYnVmZmVyZWQ7XG4gICAgICAgIHZhciBjb3VudCA9IHZpZGVvQnVmZmVyZWQubGVuZ3RoO1xuXG4gICAgICAgIC8vIEEpIEdhdGhlciB1cCBhbGwgc3RhcnQgYW5kIGVuZCB0aW1lc1xuICAgICAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgICAgIGV4dGVudHMucHVzaCh7IHRpbWU6IHZpZGVvQnVmZmVyZWQuc3RhcnQoY291bnQpLCB0eXBlOiAnc3RhcnQnIH0pO1xuICAgICAgICAgIGV4dGVudHMucHVzaCh7IHRpbWU6IHZpZGVvQnVmZmVyZWQuZW5kKGNvdW50KSwgdHlwZTogJ2VuZCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQgPSBhdWRpb0J1ZmZlcmVkLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICAgICAgICBleHRlbnRzLnB1c2goeyB0aW1lOiBhdWRpb0J1ZmZlcmVkLnN0YXJ0KGNvdW50KSwgdHlwZTogJ3N0YXJ0JyB9KTtcbiAgICAgICAgICBleHRlbnRzLnB1c2goeyB0aW1lOiBhdWRpb0J1ZmZlcmVkLmVuZChjb3VudCksIHR5cGU6ICdlbmQnIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEIpIFNvcnQgdGhlbSBieSB0aW1lXG4gICAgICAgIGV4dGVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEMpIEdvIGFsb25nIG9uZSBieSBvbmUgaW5jcmVtZW50aW5nIGFyaXR5IGZvciBzdGFydCBhbmQgZGVjcmVtZW50aW5nXG4gICAgICAgIC8vICAgIGFyaXR5IGZvciBlbmRzXG4gICAgICAgIGZvciAoY291bnQgPSAwOyBjb3VudCA8IGV4dGVudHMubGVuZ3RoOyBjb3VudCsrKSB7XG4gICAgICAgICAgaWYgKGV4dGVudHNbY291bnRdLnR5cGUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgIGFyaXR5Kys7XG5cbiAgICAgICAgICAgIC8vIEQpIElmIGFyaXR5IGlzIGV2ZXIgaW5jcmVtZW50ZWQgdG8gMiB3ZSBhcmUgZW50ZXJpbmcgYW5cbiAgICAgICAgICAgIC8vICAgIG92ZXJsYXBwaW5nIHJhbmdlXG4gICAgICAgICAgICBpZiAoYXJpdHkgPT09IDIpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBleHRlbnRzW2NvdW50XS50aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZXh0ZW50c1tjb3VudF0udHlwZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIGFyaXR5LS07XG5cbiAgICAgICAgICAgIC8vIEUpIElmIGFyaXR5IGlzIGV2ZXIgZGVjcmVtZW50ZWQgdG8gMSB3ZSBsZWF2aW5nIGFuXG4gICAgICAgICAgICAvLyAgICBvdmVybGFwcGluZyByYW5nZVxuICAgICAgICAgICAgaWYgKGFyaXR5ID09PSAxKSB7XG4gICAgICAgICAgICAgIGVuZCA9IGV4dGVudHNbY291bnRdLnRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRikgUmVjb3JkIG92ZXJsYXBwaW5nIHJhbmdlc1xuICAgICAgICAgIGlmIChzdGFydCAhPT0gbnVsbCAmJiBlbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKFtzdGFydCwgZW5kXSk7XG4gICAgICAgICAgICBzdGFydCA9IG51bGw7XG4gICAgICAgICAgICBlbmQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2aWRlb2pzJDEuY3JlYXRlVGltZVJhbmdlcyhyYW5nZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHdlIGdldCBhIGRhdGEgZXZlbnQgZnJvbSB0aGUgdHJhbnNtdXhlclxuICAgKiB3ZSBjYWxsIHRoaXMgZnVuY3Rpb24gYW5kIGhhbmRsZSB0aGUgZGF0YSB0aGF0XG4gICAqIHdhcyBzZW50IHRvIHVzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBkYXRhIGV2ZW50IGZyb20gdGhlIHRyYW5zbXV4ZXJcbiAgICovXG5cbiAgY3JlYXRlQ2xhc3MkMShWaXJ0dWFsU291cmNlQnVmZmVyLCBbe1xuICAgIGtleTogJ2RhdGFfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0YV8oZXZlbnQpIHtcbiAgICAgIHZhciBzZWdtZW50ID0gZXZlbnQuZGF0YS5zZWdtZW50O1xuXG4gICAgICAvLyBDYXN0IEFycmF5QnVmZmVyIHRvIFR5cGVkQXJyYXlcbiAgICAgIHNlZ21lbnQuZGF0YSA9IG5ldyBVaW50OEFycmF5KHNlZ21lbnQuZGF0YSwgZXZlbnQuZGF0YS5ieXRlT2Zmc2V0LCBldmVudC5kYXRhLmJ5dGVMZW5ndGgpO1xuXG4gICAgICBzZWdtZW50LmluaXRTZWdtZW50ID0gbmV3IFVpbnQ4QXJyYXkoc2VnbWVudC5pbml0U2VnbWVudC5kYXRhLCBzZWdtZW50LmluaXRTZWdtZW50LmJ5dGVPZmZzZXQsIHNlZ21lbnQuaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCk7XG5cbiAgICAgIGNyZWF0ZVRleHRUcmFja3NJZk5lY2Vzc2FyeSh0aGlzLCB0aGlzLm1lZGlhU291cmNlXywgc2VnbWVudCk7XG5cbiAgICAgIC8vIEFkZCB0aGUgc2VnbWVudHMgdG8gdGhlIHBlbmRpbmdCdWZmZXJzIGFycmF5XG4gICAgICB0aGlzLnBlbmRpbmdCdWZmZXJzXy5wdXNoKHNlZ21lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgZ2V0IGEgZG9uZSBldmVudCBmcm9tIHRoZSB0cmFuc211eGVyXG4gICAgICogd2UgY2FsbCB0aGlzIGZ1bmN0aW9uIGFuZCB3ZSBwcm9jZXNzIGFsbFxuICAgICAqIG9mIHRoZSBwZW5kaW5nIGRhdGEgdGhhdCB3ZSBoYXZlIGJlZW4gc2F2aW5nIGluIHRoZVxuICAgICAqIGRhdGFfIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBkb25lIGV2ZW50IGZyb20gdGhlIHRyYW5zbXV4ZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZG9uZV8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb25lXyhldmVudCkge1xuICAgICAgLy8gRG9uJ3QgcHJvY2VzcyBhbmQgYXBwZW5kIGRhdGEgaWYgdGhlIG1lZGlhU291cmNlIGlzIGNsb3NlZFxuICAgICAgaWYgKHRoaXMubWVkaWFTb3VyY2VfLnJlYWR5U3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcnNfLmxlbmd0aCA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQWxsIGJ1ZmZlcnMgc2hvdWxkIGhhdmUgYmVlbiBmbHVzaGVkIGZyb20gdGhlIG11eGVyXG4gICAgICAvLyBzdGFydCBwcm9jZXNzaW5nIGFueXRoaW5nIHdlIGhhdmUgcmVjZWl2ZWRcbiAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdTZWdtZW50c18oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgb3VyIGludGVybmFsIG5hdGl2ZSBhdWRpby92aWRlbyBzb3VyY2UgYnVmZmVycyBhbmQgYWRkXG4gICAgICogZXZlbnQgaGFuZGxlcnMgdG8gdGhlbSB3aXRoIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKiAxLiB0aGV5IGRvIG5vdCBhbHJlYWR5IGV4aXN0IG9uIHRoZSBtZWRpYVNvdXJjZVxuICAgICAqIDIuIHRoaXMgVlNCIGhhcyBhIGNvZGVjIGZvciB0aGVtXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVSZWFsU291cmNlQnVmZmVyc18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSZWFsU291cmNlQnVmZmVyc18oKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHR5cGVzID0gWydhdWRpbycsICd2aWRlbyddO1xuXG4gICAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIC8vIERvbid0IGNyZWF0ZSBhIFNvdXJjZUJ1ZmZlciBvZiB0aGlzIHR5cGUgaWYgd2UgZG9uJ3QgaGF2ZSBhXG4gICAgICAgIC8vIGNvZGVjIGZvciBpdFxuICAgICAgICBpZiAoIV90aGlzMlt0eXBlICsgJ0NvZGVjXyddKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBhIFNvdXJjZUJ1ZmZlciBvZiB0aGlzIHR5cGUgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKF90aGlzMlt0eXBlICsgJ0J1ZmZlcl8nXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidWZmZXIgPSBudWxsO1xuXG4gICAgICAgIC8vIElmIHRoZSBtZWRpYXNvdXJjZSBhbHJlYWR5IGhhcyBhIFNvdXJjZUJ1ZmZlciBmb3IgdGhlIGNvZGVjXG4gICAgICAgIC8vIHVzZSB0aGF0XG4gICAgICAgIGlmIChfdGhpczIubWVkaWFTb3VyY2VfW3R5cGUgKyAnQnVmZmVyXyddKSB7XG4gICAgICAgICAgYnVmZmVyID0gX3RoaXMyLm1lZGlhU291cmNlX1t0eXBlICsgJ0J1ZmZlcl8nXTtcbiAgICAgICAgICAvLyBJbiBtdWx0aXBsZSBhdWRpbyB0cmFjayBjYXNlcywgdGhlIGF1ZGlvIHNvdXJjZSBidWZmZXIgaXMgZGlzYWJsZWRcbiAgICAgICAgICAvLyBvbiB0aGUgbWFpbiBWaXJ0dWFsU291cmNlQnVmZmVyIGJ5IHRoZSBIVE1MTWVkaWFTb3VyY2UgbXVjaCBlYXJsaWVyXG4gICAgICAgICAgLy8gdGhhbiBjcmVhdGVSZWFsU291cmNlQnVmZmVyc18gaXMgY2FsbGVkIHRvIGNyZWF0ZSB0aGUgc2Vjb25kXG4gICAgICAgICAgLy8gVmlydHVhbFNvdXJjZUJ1ZmZlciBiZWNhdXNlIHRoYXQgaGFwcGVucyBhcyBhIHNpZGUtZWZmZWN0IG9mXG4gICAgICAgICAgLy8gdmlkZW9qcy1jb250cmliLWhscyBzdGFydGluZyB0aGUgYXVkaW9TZWdtZW50TG9hZGVyLiBBcyBhIHJlc3VsdCxcbiAgICAgICAgICAvLyB0aGUgYXVkaW9CdWZmZXIgaXMgZXNzZW50aWFsbHkgXCJvd25lcmxlc3NcIiBhbmQgbm8gb25lIHdpbGwgdG9nZ2xlXG4gICAgICAgICAgLy8gdGhlIGB1cGRhdGluZ2Agc3RhdGUgYmFjayB0byBmYWxzZSBvbmNlIHRoZSBgdXBkYXRlZW5kYCBldmVudCBpcyByZWNlaXZlZFxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gU2V0dGluZyBgdXBkYXRpbmdgIHRvIGZhbHNlIG1hbnVhbGx5IHdpbGwgd29yayBhcm91bmQgdGhpc1xuICAgICAgICAgIC8vIHNpdHVhdGlvbiBhbmQgYWxsb3cgd29yayB0byBjb250aW51ZVxuICAgICAgICAgIGJ1ZmZlci51cGRhdGluZyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjb2RlY1Byb3BlcnR5ID0gdHlwZSArICdDb2RlY18nO1xuICAgICAgICAgIHZhciBtaW1lVHlwZSA9IHR5cGUgKyAnL21wNDtjb2RlY3M9XCInICsgX3RoaXMyW2NvZGVjUHJvcGVydHldICsgJ1wiJztcblxuICAgICAgICAgIGJ1ZmZlciA9IG1ha2VXcmFwcGVkU291cmNlQnVmZmVyKF90aGlzMi5tZWRpYVNvdXJjZV8ubmF0aXZlTWVkaWFTb3VyY2VfLCBtaW1lVHlwZSk7XG5cbiAgICAgICAgICBfdGhpczIubWVkaWFTb3VyY2VfW3R5cGUgKyAnQnVmZmVyXyddID0gYnVmZmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyW3R5cGUgKyAnQnVmZmVyXyddID0gYnVmZmVyO1xuXG4gICAgICAgIC8vIFdpcmUgdXAgdGhlIGV2ZW50cyB0byB0aGUgU291cmNlQnVmZmVyXG4gICAgICAgIFsndXBkYXRlJywgJ3VwZGF0ZXN0YXJ0JywgJ3VwZGF0ZWVuZCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgYnVmZmVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGlmIGF1ZGlvIGlzIGRpc2FibGVkXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiBfdGhpczIuYXVkaW9EaXNhYmxlZF8pIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09ICd1cGRhdGVlbmQnKSB7XG4gICAgICAgICAgICAgIF90aGlzMlt0eXBlICsgJ0J1ZmZlcl8nXS51cGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2hvdWxkVHJpZ2dlciA9IHR5cGVzLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIC8vIHNraXAgY2hlY2tpbmcgYXVkaW8ncyB1cGRhdGluZyBzdGF0dXMgaWYgYXVkaW9cbiAgICAgICAgICAgICAgLy8gaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgaWYgKHQgPT09ICdhdWRpbycgJiYgX3RoaXMyLmF1ZGlvRGlzYWJsZWRfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gaWYgdGhlIG90aGVyIHR5cGUgaWYgdXBkYXRpbmcgd2UgZG9uJ3QgdHJpZ2dlclxuICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdCAmJiBfdGhpczJbdCArICdCdWZmZXJfJ10gJiYgX3RoaXMyW3QgKyAnQnVmZmVyXyddLnVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChzaG91bGRUcmlnZ2VyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczIudHJpZ2dlcihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW11bGF0ZSB0aGUgbmF0aXZlIG1lZGlhc291cmNlIGZ1bmN0aW9uLCBidXQgb3VyIGZ1bmN0aW9uIHdpbGxcbiAgICAgKiBzZW5kIGFsbCBvZiB0aGUgcHJvcG9zZWQgc2VnbWVudHMgdG8gdGhlIHRyYW5zbXV4ZXIgc28gdGhhdCB3ZVxuICAgICAqIGNhbiB0cmFuc211eCB0aGVtIGJlZm9yZSB3ZSBhcHBlbmQgdGhlbSB0byBvdXIgaW50ZXJuYWxcbiAgICAgKiBuYXRpdmUgc291cmNlIGJ1ZmZlcnMgaW4gdGhlIGNvcnJlY3QgZm9ybWF0LlxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NvdXJjZUJ1ZmZlci9hcHBlbmRCdWZmZXJcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHNlZ21lbnQgdGhlIHNlZ21lbnQgdG8gYXBwZW5kIHRvIHRoZSBidWZmZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXBwZW5kQnVmZmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kQnVmZmVyKHNlZ21lbnQpIHtcbiAgICAgIC8vIFN0YXJ0IHRoZSBpbnRlcm5hbCBcInVwZGF0aW5nXCIgc3RhdGVcbiAgICAgIHRoaXMuYnVmZmVyVXBkYXRpbmdfID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuYXVkaW9CdWZmZXJfICYmIHRoaXMuYXVkaW9CdWZmZXJfLmJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgICB2YXIgYXVkaW9CdWZmZXJlZCA9IHRoaXMuYXVkaW9CdWZmZXJfLmJ1ZmZlcmVkO1xuXG4gICAgICAgIHRoaXMudHJhbnNtdXhlcl8ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGFjdGlvbjogJ3NldEF1ZGlvQXBwZW5kU3RhcnQnLFxuICAgICAgICAgIGFwcGVuZFN0YXJ0OiBhdWRpb0J1ZmZlcmVkLmVuZChhdWRpb0J1ZmZlcmVkLmxlbmd0aCAtIDEpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy52aWRlb0J1ZmZlcl8pIHtcbiAgICAgICAgdGhpcy50cmFuc211eGVyXy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgYWN0aW9uOiAnYWxpZ25Hb3BzV2l0aCcsXG4gICAgICAgICAgZ29wc1RvQWxpZ25XaXRoOiBnb3BzU2FmZVRvQWxpZ25XaXRoKHRoaXMuZ29wQnVmZmVyXywgdGhpcy5tZWRpYVNvdXJjZV8ucGxheWVyXywgdGhpcy50aW1lTWFwcGluZ18pXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgYWN0aW9uOiAncHVzaCcsXG4gICAgICAgIC8vIFNlbmQgdGhlIHR5cGVkLWFycmF5IG9mIGRhdGEgYXMgYW4gQXJyYXlCdWZmZXIgc28gdGhhdFxuICAgICAgICAvLyBpdCBjYW4gYmUgc2VudCBhcyBhIFwiVHJhbnNmZXJhYmxlXCIgYW5kIGF2b2lkIHRoZSBjb3N0bHlcbiAgICAgICAgLy8gbWVtb3J5IGNvcHlcbiAgICAgICAgZGF0YTogc2VnbWVudC5idWZmZXIsXG5cbiAgICAgICAgLy8gVG8gcmVjcmVhdGUgdGhlIG9yaWdpbmFsIHR5cGVkLWFycmF5LCB3ZSBuZWVkIGluZm9ybWF0aW9uXG4gICAgICAgIC8vIGFib3V0IHdoYXQgcG9ydGlvbiBvZiB0aGUgQXJyYXlCdWZmZXIgaXQgd2FzIGEgdmlldyBpbnRvXG4gICAgICAgIGJ5dGVPZmZzZXQ6IHNlZ21lbnQuYnl0ZU9mZnNldCxcbiAgICAgICAgYnl0ZUxlbmd0aDogc2VnbWVudC5ieXRlTGVuZ3RoXG4gICAgICB9LCBbc2VnbWVudC5idWZmZXJdKTtcbiAgICAgIHRoaXMudHJhbnNtdXhlcl8ucG9zdE1lc3NhZ2UoeyBhY3Rpb246ICdmbHVzaCcgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBnb3AgaW5mb3JtYXRpb24gKHRpbWluZyBhbmQgYnl0ZUxlbmd0aCkgcmVjZWl2ZWQgYnkgdGhlIHRyYW5zbXV4ZXIgZm9yIHRoZVxuICAgICAqIGdvcHMgYXBwZW5kZWQgaW4gdGhlIGxhc3QgY2FsbCB0byBhcHBlbmRCdWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogICAgICAgIFRoZSBnb3BJbmZvIGV2ZW50IGZyb20gdGhlIHRyYW5zbXV4ZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBldmVudC5kYXRhLmdvcEluZm9cbiAgICAgKiAgICAgICAgTGlzdCBvZiBnb3AgaW5mbyB0byBhcHBlbmRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXBwZW5kR29wSW5mb18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRHb3BJbmZvXyhldmVudCkge1xuICAgICAgdGhpcy5nb3BCdWZmZXJfID0gdXBkYXRlR29wQnVmZmVyKHRoaXMuZ29wQnVmZmVyXywgZXZlbnQuZGF0YS5nb3BJbmZvLCB0aGlzLnNhZmVBcHBlbmRfKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbXVsYXRlIHRoZSBuYXRpdmUgbWVkaWFzb3VyY2UgZnVuY3Rpb24gYW5kIHJlbW92ZSBwYXJ0c1xuICAgICAqIG9mIHRoZSBidWZmZXIgZnJvbSBhbnkgb2Ygb3VyIGludGVybmFsIGJ1ZmZlcnMgdGhhdCBleGlzdFxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NvdXJjZUJ1ZmZlci9yZW1vdmVcbiAgICAgKiBAcGFyYW0ge0RvdWJsZX0gc3RhcnQgcG9zaXRpb24gdG8gc3RhcnQgdGhlIHJlbW92ZSBhdFxuICAgICAqIEBwYXJhbSB7RG91YmxlfSBlbmQgcG9zaXRpb24gdG8gZW5kIHRoZSByZW1vdmUgYXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICh0aGlzLnZpZGVvQnVmZmVyXykge1xuICAgICAgICB0aGlzLnZpZGVvQnVmZmVyXy51cGRhdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudmlkZW9CdWZmZXJfLnJlbW92ZShzdGFydCwgZW5kKTtcbiAgICAgICAgdGhpcy5nb3BCdWZmZXJfID0gcmVtb3ZlR29wQnVmZmVyKHRoaXMuZ29wQnVmZmVyXywgc3RhcnQsIGVuZCwgdGhpcy50aW1lTWFwcGluZ18pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmF1ZGlvRGlzYWJsZWRfICYmIHRoaXMuYXVkaW9CdWZmZXJfKSB7XG4gICAgICAgIHRoaXMuYXVkaW9CdWZmZXJfLnVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcl8ucmVtb3ZlKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgTWV0YWRhdGEgQ3VlcyAoaWQzKVxuICAgICAgcmVtb3ZlQ3Vlc0Zyb21UcmFjayhzdGFydCwgZW5kLCB0aGlzLm1ldGFkYXRhVHJhY2tfKTtcblxuICAgICAgLy8gUmVtb3ZlIEFueSBDYXB0aW9uc1xuICAgICAgaWYgKHRoaXMuaW5iYW5kVGV4dFRyYWNrc18pIHtcbiAgICAgICAgZm9yICh2YXIgdHJhY2sgaW4gdGhpcy5pbmJhbmRUZXh0VHJhY2tzXykge1xuICAgICAgICAgIHJlbW92ZUN1ZXNGcm9tVHJhY2soc3RhcnQsIGVuZCwgdGhpcy5pbmJhbmRUZXh0VHJhY2tzX1t0cmFja10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhbnkgc2VnbWVudHMgdGhhdCB0aGUgbXV4ZXIgaGFzIG91dHB1dFxuICAgICAqIENvbmNhdGVuYXRlIHNlZ21lbnRzIHRvZ2V0aGVyIGJhc2VkIG9uIHR5cGUgYW5kIGFwcGVuZCB0aGVtIGludG9cbiAgICAgKiB0aGVpciByZXNwZWN0aXZlIHNvdXJjZUJ1ZmZlcnNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NQZW5kaW5nU2VnbWVudHNfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1BlbmRpbmdTZWdtZW50c18oKSB7XG4gICAgICB2YXIgc29ydGVkU2VnbWVudHMgPSB7XG4gICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgc2VnbWVudHM6IFtdLFxuICAgICAgICAgIGJ5dGVzOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGF1ZGlvOiB7XG4gICAgICAgICAgc2VnbWVudHM6IFtdLFxuICAgICAgICAgIGJ5dGVzOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGNhcHRpb25zOiBbXSxcbiAgICAgICAgbWV0YWRhdGE6IFtdXG4gICAgICB9O1xuXG4gICAgICAvLyBTb3J0IHNlZ21lbnRzIGludG8gc2VwYXJhdGUgdmlkZW8vYXVkaW8gYXJyYXlzIGFuZFxuICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGVpciB0b3RhbCBieXRlIGxlbmd0aHNcbiAgICAgIHNvcnRlZFNlZ21lbnRzID0gdGhpcy5wZW5kaW5nQnVmZmVyc18ucmVkdWNlKGZ1bmN0aW9uIChzZWdtZW50T2JqLCBzZWdtZW50KSB7XG4gICAgICAgIHZhciB0eXBlID0gc2VnbWVudC50eXBlO1xuICAgICAgICB2YXIgZGF0YSA9IHNlZ21lbnQuZGF0YTtcbiAgICAgICAgdmFyIGluaXRTZWdtZW50ID0gc2VnbWVudC5pbml0U2VnbWVudDtcblxuICAgICAgICBzZWdtZW50T2JqW3R5cGVdLnNlZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgICAgIHNlZ21lbnRPYmpbdHlwZV0uYnl0ZXMgKz0gZGF0YS5ieXRlTGVuZ3RoO1xuXG4gICAgICAgIHNlZ21lbnRPYmpbdHlwZV0uaW5pdFNlZ21lbnQgPSBpbml0U2VnbWVudDtcblxuICAgICAgICAvLyBHYXRoZXIgYW55IGNhcHRpb25zIGludG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgaWYgKHNlZ21lbnQuY2FwdGlvbnMpIHtcbiAgICAgICAgICBzZWdtZW50T2JqLmNhcHRpb25zID0gc2VnbWVudE9iai5jYXB0aW9ucy5jb25jYXQoc2VnbWVudC5jYXB0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VnbWVudC5pbmZvKSB7XG4gICAgICAgICAgc2VnbWVudE9ialt0eXBlXS5pbmZvID0gc2VnbWVudC5pbmZvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2F0aGVyIGFueSBtZXRhZGF0YSBpbnRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgIGlmIChzZWdtZW50Lm1ldGFkYXRhKSB7XG4gICAgICAgICAgc2VnbWVudE9iai5tZXRhZGF0YSA9IHNlZ21lbnRPYmoubWV0YWRhdGEuY29uY2F0KHNlZ21lbnQubWV0YWRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlZ21lbnRPYmo7XG4gICAgICB9LCBzb3J0ZWRTZWdtZW50cyk7XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgcmVhbCBzb3VyY2UgYnVmZmVycyBpZiB0aGV5IGRvbid0IGV4aXN0IGJ5IG5vdyBzaW5jZSB3ZVxuICAgICAgLy8gZmluYWxseSBhcmUgc3VyZSB3aGF0IHRyYWNrcyBhcmUgY29udGFpbmVkIGluIHRoZSBzb3VyY2VcbiAgICAgIGlmICghdGhpcy52aWRlb0J1ZmZlcl8gJiYgIXRoaXMuYXVkaW9CdWZmZXJfKSB7XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgY29kZWNzIHRoYXQgbWF5IGhhdmUgYmVlbiBzcGVjaWZpZWQgYnkgZGVmYXVsdCBidXRcbiAgICAgICAgLy8gYXJlIG5vIGxvbmdlciBhcHBsaWNhYmxlIG5vd1xuICAgICAgICBpZiAoc29ydGVkU2VnbWVudHMudmlkZW8uYnl0ZXMgPT09IDApIHtcbiAgICAgICAgICB0aGlzLnZpZGVvQ29kZWNfID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ydGVkU2VnbWVudHMuYXVkaW8uYnl0ZXMgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmF1ZGlvQ29kZWNfID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3JlYXRlUmVhbFNvdXJjZUJ1ZmZlcnNfKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3J0ZWRTZWdtZW50cy5hdWRpby5pbmZvKSB7XG4gICAgICAgIHRoaXMubWVkaWFTb3VyY2VfLnRyaWdnZXIoeyB0eXBlOiAnYXVkaW9pbmZvJywgaW5mbzogc29ydGVkU2VnbWVudHMuYXVkaW8uaW5mbyB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3J0ZWRTZWdtZW50cy52aWRlby5pbmZvKSB7XG4gICAgICAgIHRoaXMubWVkaWFTb3VyY2VfLnRyaWdnZXIoeyB0eXBlOiAndmlkZW9pbmZvJywgaW5mbzogc29ydGVkU2VnbWVudHMudmlkZW8uaW5mbyB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYXBwZW5kQXVkaW9Jbml0U2VnbWVudF8pIHtcbiAgICAgICAgaWYgKCF0aGlzLmF1ZGlvRGlzYWJsZWRfICYmIHRoaXMuYXVkaW9CdWZmZXJfKSB7XG4gICAgICAgICAgc29ydGVkU2VnbWVudHMuYXVkaW8uc2VnbWVudHMudW5zaGlmdChzb3J0ZWRTZWdtZW50cy5hdWRpby5pbml0U2VnbWVudCk7XG4gICAgICAgICAgc29ydGVkU2VnbWVudHMuYXVkaW8uYnl0ZXMgKz0gc29ydGVkU2VnbWVudHMuYXVkaW8uaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZEF1ZGlvSW5pdFNlZ21lbnRfID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmlnZ2VyVXBkYXRlZW5kID0gZmFsc2U7XG5cbiAgICAgIC8vIE1lcmdlIG11bHRpcGxlIHZpZGVvIGFuZCBhdWRpbyBzZWdtZW50cyBpbnRvIG9uZSBhbmQgYXBwZW5kXG4gICAgICBpZiAodGhpcy52aWRlb0J1ZmZlcl8gJiYgc29ydGVkU2VnbWVudHMudmlkZW8uYnl0ZXMpIHtcbiAgICAgICAgc29ydGVkU2VnbWVudHMudmlkZW8uc2VnbWVudHMudW5zaGlmdChzb3J0ZWRTZWdtZW50cy52aWRlby5pbml0U2VnbWVudCk7XG4gICAgICAgIHNvcnRlZFNlZ21lbnRzLnZpZGVvLmJ5dGVzICs9IHNvcnRlZFNlZ21lbnRzLnZpZGVvLmluaXRTZWdtZW50LmJ5dGVMZW5ndGg7XG4gICAgICAgIHRoaXMuY29uY2F0QW5kQXBwZW5kU2VnbWVudHNfKHNvcnRlZFNlZ21lbnRzLnZpZGVvLCB0aGlzLnZpZGVvQnVmZmVyXyk7XG4gICAgICAgIC8vIFRPRE86IGFyZSB2aWRlbyB0cmFja3MgdGhlIG9ubHkgb25lcyB3aXRoIHRleHQgdHJhY2tzP1xuICAgICAgICBhZGRUZXh0VHJhY2tEYXRhKHRoaXMsIHNvcnRlZFNlZ21lbnRzLmNhcHRpb25zLCBzb3J0ZWRTZWdtZW50cy5tZXRhZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudmlkZW9CdWZmZXJfICYmICh0aGlzLmF1ZGlvRGlzYWJsZWRfIHx8ICF0aGlzLmF1ZGlvQnVmZmVyXykpIHtcbiAgICAgICAgLy8gVGhlIHRyYW5zbXV4ZXIgZGlkIG5vdCByZXR1cm4gYW55IGJ5dGVzIG9mIHZpZGVvLCBtZWFuaW5nIGl0IHdhcyBhbGwgdHJpbW1lZFxuICAgICAgICAvLyBmb3IgZ29wIGFsaWdubWVudC4gU2luY2Ugd2UgaGF2ZSBhIHZpZGVvIGJ1ZmZlciBhbmQgYXVkaW8gaXMgZGlzYWJsZWQsIHVwZGF0ZWVuZFxuICAgICAgICAvLyB3aWxsIG5ldmVyIGJlIHRyaWdnZXJlZCBieSB0aGlzIHNvdXJjZSBidWZmZXIsIHdoaWNoIHdpbGwgY2F1c2UgY29udHJpYi1obHNcbiAgICAgICAgLy8gdG8gYmUgc3R1Y2sgZm9yZXZlciB3YWl0aW5nIGZvciB1cGRhdGVlbmQuIElmIGF1ZGlvIGlzIG5vdCBkaXNhYmxlZCwgdXBkYXRlZW5kXG4gICAgICAgIC8vIHdpbGwgYmUgdHJpZ2dlcmVkIGJ5IHRoZSBhdWRpbyBidWZmZXIsIHdoaWNoIHdpbGwgYmUgc2VudCB1cHdhcmRzIHNpbmNlIHRoZSB2aWRlb1xuICAgICAgICAvLyBidWZmZXIgd2lsbCBub3QgYmUgaW4gYW4gdXBkYXRpbmcgc3RhdGUuXG4gICAgICAgIHRyaWdnZXJVcGRhdGVlbmQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuYXVkaW9EaXNhYmxlZF8gJiYgdGhpcy5hdWRpb0J1ZmZlcl8pIHtcbiAgICAgICAgdGhpcy5jb25jYXRBbmRBcHBlbmRTZWdtZW50c18oc29ydGVkU2VnbWVudHMuYXVkaW8sIHRoaXMuYXVkaW9CdWZmZXJfKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyc18ubGVuZ3RoID0gMDtcblxuICAgICAgaWYgKHRyaWdnZXJVcGRhdGVlbmQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd1cGRhdGVlbmQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYXJlIG5vIGxvbmdlciBpbiB0aGUgaW50ZXJuYWwgXCJ1cGRhdGluZ1wiIHN0YXRlXG4gICAgICB0aGlzLmJ1ZmZlclVwZGF0aW5nXyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbWJpbmUgYWxsIHNlZ21lbnRzIGludG8gYSBzaW5nbGUgVWludDhBcnJheSBhbmQgdGhlbiBhcHBlbmQgdGhlbVxuICAgICAqIHRvIHRoZSBkZXN0aW5hdGlvbiBidWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWdtZW50T2JqXG4gICAgICogQHBhcmFtIHtTb3VyY2VCdWZmZXJ9IGRlc3RpbmF0aW9uQnVmZmVyIG5hdGl2ZSBzb3VyY2UgYnVmZmVyIHRvIGFwcGVuZCBkYXRhIHRvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY29uY2F0QW5kQXBwZW5kU2VnbWVudHNfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0QW5kQXBwZW5kU2VnbWVudHNfKHNlZ21lbnRPYmosIGRlc3RpbmF0aW9uQnVmZmVyKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciB0ZW1wQnVmZmVyID0gdm9pZCAwO1xuXG4gICAgICBpZiAoc2VnbWVudE9iai5ieXRlcykge1xuICAgICAgICB0ZW1wQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2VnbWVudE9iai5ieXRlcyk7XG5cbiAgICAgICAgLy8gQ29tYmluZSB0aGUgaW5kaXZpZHVhbCBzZWdtZW50cyBpbnRvIG9uZSBsYXJnZSB0eXBlZC1hcnJheVxuICAgICAgICBzZWdtZW50T2JqLnNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgICB0ZW1wQnVmZmVyLnNldChzZWdtZW50LCBvZmZzZXQpO1xuICAgICAgICAgIG9mZnNldCArPSBzZWdtZW50LmJ5dGVMZW5ndGg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGVzdGluYXRpb25CdWZmZXIudXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIGRlc3RpbmF0aW9uQnVmZmVyLmFwcGVuZEJ1ZmZlcih0ZW1wQnVmZmVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAodGhpcy5tZWRpYVNvdXJjZV8ucGxheWVyXykge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVNvdXJjZV8ucGxheWVyXy5lcnJvcih7XG4gICAgICAgICAgICAgIGNvZGU6IC0zLFxuICAgICAgICAgICAgICB0eXBlOiAnQVBQRU5EX0JVRkZFUl9FUlInLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW11bGF0ZSB0aGUgbmF0aXZlIG1lZGlhc291cmNlIGZ1bmN0aW9uLiBhYm9ydCBhbnkgc291cmVCdWZmZXJcbiAgICAgKiBhY3Rpb25zIGFuZCB0aHJvdyBvdXQgYW55IHVuLWFwcGVuZGVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU291cmNlQnVmZmVyL2Fib3J0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Fib3J0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICBpZiAodGhpcy52aWRlb0J1ZmZlcl8pIHtcbiAgICAgICAgdGhpcy52aWRlb0J1ZmZlcl8uYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5hdWRpb0Rpc2FibGVkXyAmJiB0aGlzLmF1ZGlvQnVmZmVyXykge1xuICAgICAgICB0aGlzLmF1ZGlvQnVmZmVyXy5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudHJhbnNtdXhlcl8pIHtcbiAgICAgICAgdGhpcy50cmFuc211eGVyXy5wb3N0TWVzc2FnZSh7IGFjdGlvbjogJ3Jlc2V0JyB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcnNfLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmJ1ZmZlclVwZGF0aW5nXyA9IGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmlydHVhbFNvdXJjZUJ1ZmZlcjtcbn0odmlkZW9qcyQxLkV2ZW50VGFyZ2V0KTtcblxuLyoqXG4gKiBAZmlsZSBodG1sLW1lZGlhLXNvdXJjZS5qc1xuICovXG5cbi8qKlxuICogT3VyIE1lZGlhU291cmNlIGltcGxlbWVudGF0aW9uIGluIEhUTUwsIG1pbWljcyBuYXRpdmVcbiAqIE1lZGlhU291cmNlIHdoZXJlL2lmIHBvc3NpYmxlLlxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVNvdXJjZVxuICogQGNsYXNzIEh0bWxNZWRpYVNvdXJjZVxuICogQGV4dGVuZHMgdmlkZW9qcy5FdmVudFRhcmdldFxuICovXG5cbnZhciBIdG1sTWVkaWFTb3VyY2UgPSBmdW5jdGlvbiAoX3ZpZGVvanMkRXZlbnRUYXJnZXQpIHtcbiAgaW5oZXJpdHMkMShIdG1sTWVkaWFTb3VyY2UsIF92aWRlb2pzJEV2ZW50VGFyZ2V0KTtcblxuICBmdW5jdGlvbiBIdG1sTWVkaWFTb3VyY2UoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2skMSh0aGlzLCBIdG1sTWVkaWFTb3VyY2UpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiQxKHRoaXMsIChIdG1sTWVkaWFTb3VyY2UuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihIdG1sTWVkaWFTb3VyY2UpKS5jYWxsKHRoaXMpKTtcblxuICAgIHZhciBwcm9wZXJ0eSA9IHZvaWQgMDtcblxuICAgIF90aGlzLm5hdGl2ZU1lZGlhU291cmNlXyA9IG5ldyB3aW5kb3ckMS5NZWRpYVNvdXJjZSgpO1xuICAgIC8vIGRlbGVnYXRlIHRvIHRoZSBuYXRpdmUgTWVkaWFTb3VyY2UncyBtZXRob2RzIGJ5IGRlZmF1bHRcbiAgICBmb3IgKHByb3BlcnR5IGluIF90aGlzLm5hdGl2ZU1lZGlhU291cmNlXykge1xuICAgICAgaWYgKCEocHJvcGVydHkgaW4gSHRtbE1lZGlhU291cmNlLnByb3RvdHlwZSkgJiYgdHlwZW9mIF90aGlzLm5hdGl2ZU1lZGlhU291cmNlX1twcm9wZXJ0eV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgX3RoaXNbcHJvcGVydHldID0gX3RoaXMubmF0aXZlTWVkaWFTb3VyY2VfW3Byb3BlcnR5XS5iaW5kKF90aGlzLm5hdGl2ZU1lZGlhU291cmNlXyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZW11bGF0ZSBgZHVyYXRpb25gIGFuZCBgc2Vla2FibGVgIHVudGlsIHNlZWtpbmcgY2FuIGJlXG4gICAgLy8gaGFuZGxlZCB1bmlmb3JtbHkgZm9yIGxpdmUgc3RyZWFtc1xuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdzNjL21lZGlhLXNvdXJjZS9pc3N1ZXMvNVxuICAgIF90aGlzLmR1cmF0aW9uXyA9IE5hTjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsICdkdXJhdGlvbicsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICBpZiAodGhpcy5kdXJhdGlvbl8gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHVyYXRpb25fO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZU1lZGlhU291cmNlXy5kdXJhdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShkdXJhdGlvbikge1xuICAgICAgICB0aGlzLmR1cmF0aW9uXyA9IGR1cmF0aW9uO1xuICAgICAgICBpZiAoZHVyYXRpb24gIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgdGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8uZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsICdzZWVrYWJsZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICBpZiAodGhpcy5kdXJhdGlvbl8gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIHZpZGVvanMkMS5jcmVhdGVUaW1lUmFuZ2VzKFtbMCwgdGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8uZHVyYXRpb25dXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlTWVkaWFTb3VyY2VfLnNlZWthYmxlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCAncmVhZHlTdGF0ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8ucmVhZHlTdGF0ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgJ2FjdGl2ZVNvdXJjZUJ1ZmZlcnMnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlU291cmNlQnVmZmVyc187XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB0aGUgbGlzdCBvZiB2aXJ0dWFsIGFuZCBuYXRpdmUgU291cmNlQnVmZmVycyBjcmVhdGVkIGJ5IHRoaXNcbiAgICAvLyBNZWRpYVNvdXJjZVxuICAgIF90aGlzLnNvdXJjZUJ1ZmZlcnMgPSBbXTtcblxuICAgIF90aGlzLmFjdGl2ZVNvdXJjZUJ1ZmZlcnNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIGxpc3Qgb2YgYWN0aXZlIHNvdXJjZSBidWZmZXJzIGJhc2VkIHVwb24gdmFyaW91c1xuICAgICAqIGltZm9ybWF0aW9uIGZyb20gSExTIGFuZCB2aWRlby5qc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdGhpcy51cGRhdGVBY3RpdmVTb3VyY2VCdWZmZXJzXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFJldGFpbiB0aGUgcmVmZXJlbmNlIGJ1dCBlbXB0eSB0aGUgYXJyYXlcbiAgICAgIF90aGlzLmFjdGl2ZVNvdXJjZUJ1ZmZlcnNfLmxlbmd0aCA9IDA7XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgb25lIHNvdXJjZSBidWZmZXIsIHRoZW4gaXQgd2lsbCBhbHdheXMgYmUgYWN0aXZlIGFuZCBhdWRpbyB3aWxsXG4gICAgICAvLyBiZSBkaXNhYmxlZCBiYXNlZCBvbiB0aGUgY29kZWMgb2YgdGhlIHNvdXJjZSBidWZmZXJcbiAgICAgIGlmIChfdGhpcy5zb3VyY2VCdWZmZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgc291cmNlQnVmZmVyID0gX3RoaXMuc291cmNlQnVmZmVyc1swXTtcblxuICAgICAgICBzb3VyY2VCdWZmZXIuYXBwZW5kQXVkaW9Jbml0U2VnbWVudF8gPSB0cnVlO1xuICAgICAgICBzb3VyY2VCdWZmZXIuYXVkaW9EaXNhYmxlZF8gPSAhc291cmNlQnVmZmVyLmF1ZGlvQ29kZWNfO1xuICAgICAgICBfdGhpcy5hY3RpdmVTb3VyY2VCdWZmZXJzXy5wdXNoKHNvdXJjZUJ1ZmZlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlcmUgYXJlIDIgc291cmNlIGJ1ZmZlcnMsIGEgY29tYmluZWQgKHBvc3NpYmx5IHZpZGVvIG9ubHkpIHNvdXJjZSBidWZmZXIgYW5kXG4gICAgICAvLyBhbmQgYW4gYXVkaW8gb25seSBzb3VyY2UgYnVmZmVyLlxuICAgICAgLy8gQnkgZGVmYXVsdCwgdGhlIGF1ZGlvIGluIHRoZSBjb21iaW5lZCB2aXJ0dWFsIHNvdXJjZSBidWZmZXIgaXMgZW5hYmxlZFxuICAgICAgLy8gYW5kIHRoZSBhdWRpby1vbmx5IHNvdXJjZSBidWZmZXIgKGlmIGl0IGV4aXN0cykgaXMgZGlzYWJsZWQuXG4gICAgICB2YXIgZGlzYWJsZUNvbWJpbmVkID0gZmFsc2U7XG4gICAgICB2YXIgZGlzYWJsZUF1ZGlvT25seSA9IHRydWU7XG5cbiAgICAgIC8vIFRPRE86IG1heWJlIHdlIGNhbiBzdG9yZSB0aGUgc291cmNlYnVmZmVycyBvbiB0aGUgdHJhY2sgb2JqZWN0cz9cbiAgICAgIC8vIHNhZmFyaSBtYXkgZG8gc29tZXRoaW5nIGxpa2UgdGhpc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzKCkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYWNrID0gX3RoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpW2ldO1xuXG4gICAgICAgIGlmICh0cmFjay5lbmFibGVkICYmIHRyYWNrLmtpbmQgIT09ICdtYWluJykge1xuICAgICAgICAgIC8vIFRoZSBlbmFibGVkIHRyYWNrIGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFjayBzbyBkaXNhYmxlIHRoZSBhdWRpbyBpblxuICAgICAgICAgIC8vIHRoZSBjb21iaW5lZCBzb3VyY2UgYnVmZmVyIGFuZCBlbmFibGUgdGhlIGF1ZGlvLW9ubHkgc291cmNlIGJ1ZmZlci5cbiAgICAgICAgICBkaXNhYmxlQ29tYmluZWQgPSB0cnVlO1xuICAgICAgICAgIGRpc2FibGVBdWRpb09ubHkgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgLyogZXNsaW5zdC1kaXNhYmxlICovXG4gICAgICAgIC8vIFRPRE8gb25jZSBjb2RlY3MgYXJlIHJlcXVpcmVkLCB3ZSBjYW4gc3dpdGNoIHRvIHVzaW5nIHRoZSBjb2RlY3MgdG8gZGV0ZXJtaW5lXG4gICAgICAgIC8vICAgICAgd2hhdCBzdHJlYW0gaXMgdGhlIHZpZGVvIHN0cmVhbSwgcmF0aGVyIHRoYW4gcmVseWluZyBvbiB2aWRlb1RyYWNrc1xuICAgICAgICAvKiBlc2xpbnN0LWVuYWJsZSAqL1xuXG4gICAgICAgIHNvdXJjZUJ1ZmZlci5hcHBlbmRBdWRpb0luaXRTZWdtZW50XyA9IHRydWU7XG5cbiAgICAgICAgaWYgKHNvdXJjZUJ1ZmZlci52aWRlb0NvZGVjXyAmJiBzb3VyY2VCdWZmZXIuYXVkaW9Db2RlY18pIHtcbiAgICAgICAgICAvLyBjb21iaW5lZFxuICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hdWRpb0Rpc2FibGVkXyA9IGRpc2FibGVDb21iaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VCdWZmZXIudmlkZW9Db2RlY18gJiYgIXNvdXJjZUJ1ZmZlci5hdWRpb0NvZGVjXykge1xuICAgICAgICAgIC8vIElmIHRoZSBcImNvbWJpbmVkXCIgc291cmNlIGJ1ZmZlciBpcyB2aWRlbyBvbmx5LCB0aGVuIHdlIGRvIG5vdCB3YW50XG4gICAgICAgICAgLy8gZGlzYWJsZSB0aGUgYXVkaW8tb25seSBzb3VyY2UgYnVmZmVyICh0aGlzIGlzIG1vc3RseSBmb3IgZGVtdXhlZFxuICAgICAgICAgIC8vIGF1ZGlvIGFuZCB2aWRlbyBobHMpXG4gICAgICAgICAgc291cmNlQnVmZmVyLmF1ZGlvRGlzYWJsZWRfID0gdHJ1ZTtcbiAgICAgICAgICBkaXNhYmxlQXVkaW9Pbmx5ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoIXNvdXJjZUJ1ZmZlci52aWRlb0NvZGVjXyAmJiBzb3VyY2VCdWZmZXIuYXVkaW9Db2RlY18pIHtcbiAgICAgICAgICAvLyBhdWRpbyBvbmx5XG4gICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYXVkaW8gb25seSB3aXRoIGFsdGVybmF0ZSBhdWRpbyBhbmQgZGlzYWJsZUF1ZGlvT25seSBpcyB0cnVlXG4gICAgICAgICAgLy8gdGhpcyBtZWFucyB3ZSB3YW50IHRvIGRpc2FibGUgdGhlIGF1ZGlvIG9uIHRoZSBhbHRlcm5hdGUgYXVkaW8gc291cmNlYnVmZmVyXG4gICAgICAgICAgLy8gYnV0IG5vdCB0aGUgbWFpbiBcImNvbWJpbmVkXCIgc291cmNlIGJ1ZmZlci4gVGhlIFwiY29tYmluZWRcIiBzb3VyY2UgYnVmZmVyIGlzXG4gICAgICAgICAgLy8gYWx3YXlzIGF0IGluZGV4IDAsIHNvIHRoaXMgZW5zdXJlcyBhdWRpbyB3b24ndCBiZSBkaXNhYmxlZCBpbiBib3RoIHNvdXJjZVxuICAgICAgICAgIC8vIGJ1ZmZlcnMuXG4gICAgICAgICAgc291cmNlQnVmZmVyLmF1ZGlvRGlzYWJsZWRfID0gaW5kZXggPyBkaXNhYmxlQXVkaW9Pbmx5IDogIWRpc2FibGVBdWRpb09ubHk7XG4gICAgICAgICAgaWYgKHNvdXJjZUJ1ZmZlci5hdWRpb0Rpc2FibGVkXykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmFjdGl2ZVNvdXJjZUJ1ZmZlcnNfLnB1c2goc291cmNlQnVmZmVyKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5vblBsYXllck1lZGlhY2hhbmdlXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlQnVmZmVyKSB7XG4gICAgICAgIHNvdXJjZUJ1ZmZlci5hcHBlbmRBdWRpb0luaXRTZWdtZW50XyA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25IbHNSZXNldF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICBpZiAoc291cmNlQnVmZmVyLnRyYW5zbXV4ZXJfKSB7XG4gICAgICAgICAgc291cmNlQnVmZmVyLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiAncmVzZXRDYXB0aW9ucycgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkhsc1NlZ21lbnRUaW1lTWFwcGluZ18gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBidWZmZXIudGltZU1hcHBpbmdfID0gZXZlbnQubWFwcGluZztcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBSZS1lbWl0IE1lZGlhU291cmNlIGV2ZW50cyBvbiB0aGUgcG9seWZpbGxcbiAgICBbJ3NvdXJjZW9wZW4nLCAnc291cmNlY2xvc2UnLCAnc291cmNlZW5kZWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgIHRoaXMubmF0aXZlTWVkaWFTb3VyY2VfLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLnRyaWdnZXIuYmluZCh0aGlzKSk7XG4gICAgfSwgX3RoaXMpO1xuXG4gICAgLy8gY2FwdHVyZSB0aGUgYXNzb2NpYXRlZCBwbGF5ZXIgd2hlbiB0aGUgTWVkaWFTb3VyY2UgaXNcbiAgICAvLyBzdWNjZXNzZnVsbHkgYXR0YWNoZWRcbiAgICBfdGhpcy5vbignc291cmNlb3BlbicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gR2V0IHRoZSBwbGF5ZXIgdGhpcyBNZWRpYVNvdXJjZSBpcyBhdHRhY2hlZCB0b1xuICAgICAgdmFyIHZpZGVvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW3NyYz1cIicgKyBfdGhpcy51cmxfICsgJ1wiXScpO1xuXG4gICAgICBpZiAoIXZpZGVvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMucGxheWVyXyA9IHZpZGVvanMkMSh2aWRlby5wYXJlbnROb2RlKTtcblxuICAgICAgLy8gaGxzLXJlc2V0IGlzIGZpcmVkIGJ5IHZpZGVvanMuSGxzIG9uIHRvIHRoZSB0ZWNoIGFmdGVyIHRoZSBtYWluIFNlZ21lbnRMb2FkZXJcbiAgICAgIC8vIHJlc2V0cyBpdHMgc3RhdGUgYW5kIGZsdXNoZXMgdGhlIGJ1ZmZlclxuICAgICAgX3RoaXMucGxheWVyXy50ZWNoXy5vbignaGxzLXJlc2V0JywgX3RoaXMub25IbHNSZXNldF8pO1xuICAgICAgLy8gaGxzLXNlZ21lbnQtdGltZS1tYXBwaW5nIGlzIGZpcmVkIGJ5IHZpZGVvanMuSGxzIG9uIHRvIHRoZSB0ZWNoIGFmdGVyIHRoZSBtYWluXG4gICAgICAvLyBTZWdtZW50TG9hZGVyIGluc3BlY3RzIGFuIE1UUyBzZWdtZW50IGFuZCBoYXMgYW4gYWNjdXJhdGUgc3RyZWFtIHRvIGRpc3BsYXlcbiAgICAgIC8vIHRpbWUgbWFwcGluZ1xuICAgICAgX3RoaXMucGxheWVyXy50ZWNoXy5vbignaGxzLXNlZ21lbnQtdGltZS1tYXBwaW5nJywgX3RoaXMub25IbHNTZWdtZW50VGltZU1hcHBpbmdfKTtcblxuICAgICAgaWYgKF90aGlzLnBsYXllcl8uYXVkaW9UcmFja3MgJiYgX3RoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpKSB7XG4gICAgICAgIF90aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKS5vbignY2hhbmdlJywgX3RoaXMudXBkYXRlQWN0aXZlU291cmNlQnVmZmVyc18pO1xuICAgICAgICBfdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzKCkub24oJ2FkZHRyYWNrJywgX3RoaXMudXBkYXRlQWN0aXZlU291cmNlQnVmZmVyc18pO1xuICAgICAgICBfdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzKCkub24oJ3JlbW92ZXRyYWNrJywgX3RoaXMudXBkYXRlQWN0aXZlU291cmNlQnVmZmVyc18pO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5wbGF5ZXJfLm9uKCdtZWRpYWNoYW5nZScsIF90aGlzLm9uUGxheWVyTWVkaWFjaGFuZ2VfKTtcbiAgICB9KTtcblxuICAgIF90aGlzLm9uKCdzb3VyY2VlbmRlZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGR1cmF0aW9uID0gZHVyYXRpb25PZlZpZGVvKF90aGlzLmR1cmF0aW9uKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5zb3VyY2VCdWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2VidWZmZXIgPSBfdGhpcy5zb3VyY2VCdWZmZXJzW2ldO1xuICAgICAgICB2YXIgY3VlcyA9IHNvdXJjZWJ1ZmZlci5tZXRhZGF0YVRyYWNrXyAmJiBzb3VyY2VidWZmZXIubWV0YWRhdGFUcmFja18uY3VlcztcblxuICAgICAgICBpZiAoY3VlcyAmJiBjdWVzLmxlbmd0aCkge1xuICAgICAgICAgIGN1ZXNbY3Vlcy5sZW5ndGggLSAxXS5lbmRUaW1lID0gZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGV4cGxpY2l0bHkgdGVybWluYXRlIGFueSBXZWJXb3JrZXJzIHRoYXQgd2VyZSBjcmVhdGVkXG4gICAgLy8gYnkgU291cmNlSGFuZGxlcnNcbiAgICBfdGhpcy5vbignc291cmNlY2xvc2UnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHRoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgaWYgKHNvdXJjZUJ1ZmZlci50cmFuc211eGVyXykge1xuICAgICAgICAgIHNvdXJjZUJ1ZmZlci50cmFuc211eGVyXy50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc291cmNlQnVmZmVycy5sZW5ndGggPSAwO1xuICAgICAgaWYgKCF0aGlzLnBsYXllcl8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzICYmIHRoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpKSB7XG4gICAgICAgIHRoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpLm9mZignY2hhbmdlJywgdGhpcy51cGRhdGVBY3RpdmVTb3VyY2VCdWZmZXJzXyk7XG4gICAgICAgIHRoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpLm9mZignYWRkdHJhY2snLCB0aGlzLnVwZGF0ZUFjdGl2ZVNvdXJjZUJ1ZmZlcnNfKTtcbiAgICAgICAgdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzKCkub2ZmKCdyZW1vdmV0cmFjaycsIHRoaXMudXBkYXRlQWN0aXZlU291cmNlQnVmZmVyc18pO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBjYW4gb25seSBjaGFuZ2UgdGhpcyBpZiB0aGUgcGxheWVyIGhhc24ndCBiZWVuIGRpc3Bvc2VkIG9mIHlldFxuICAgICAgLy8gYmVjYXVzZSBgb2ZmYCBldmVudHVhbGx5IHRyaWVzIHRvIHVzZSB0aGUgZWxfIHByb3BlcnR5LiBJZiBpdCBoYXNcbiAgICAgIC8vIGJlZW4gZGlzcG9zZWQgb2YsIHRoZW4gZG9uJ3Qgd29ycnkgYWJvdXQgaXQgYmVjYXVzZSB0aGVyZSBhcmUgbm9cbiAgICAgIC8vIGV2ZW50IGhhbmRsZXJzIGxlZnQgdG8gdW5iaW5kIGFueXdheVxuICAgICAgaWYgKHRoaXMucGxheWVyXy5lbF8pIHtcbiAgICAgICAgdGhpcy5wbGF5ZXJfLm9mZignbWVkaWFjaGFuZ2UnLCB0aGlzLm9uUGxheWVyTWVkaWFjaGFuZ2VfKTtcbiAgICAgICAgdGhpcy5wbGF5ZXJfLnRlY2hfLm9mZignaGxzLXJlc2V0JywgdGhpcy5vbkhsc1Jlc2V0Xyk7XG4gICAgICAgIHRoaXMucGxheWVyXy50ZWNoXy5vZmYoJ2hscy1zZWdtZW50LXRpbWUtbWFwcGluZycsIHRoaXMub25IbHNTZWdtZW50VGltZU1hcHBpbmdfKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcmFuZ2UgdGhhdCB0aGF0IGNhbiBub3cgYmUgc2Vla2VkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge0RvdWJsZX0gc3RhcnQgd2hlcmUgdG8gc3RhcnQgdGhlIGFkZGl0aW9uXG4gICAqIEBwYXJhbSB7RG91YmxlfSBlbmQgd2hlcmUgdG8gZW5kIHRoZSBhZGRpdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBjcmVhdGVDbGFzcyQxKEh0bWxNZWRpYVNvdXJjZSwgW3tcbiAgICBrZXk6ICdhZGRTZWVrYWJsZVJhbmdlXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNlZWthYmxlUmFuZ2VfKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcblxuICAgICAgaWYgKHRoaXMuZHVyYXRpb24gIT09IEluZmluaXR5KSB7XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNZWRpYVNvdXJjZS5hZGRTZWVrYWJsZVJhbmdlKCkgY2FuIG9ubHkgYmUgaW52b2tlZCAnICsgJ3doZW4gdGhlIGR1cmF0aW9uIGlzIEluZmluaXR5Jyk7XG4gICAgICAgIGVycm9yLm5hbWUgPSAnSW52YWxpZFN0YXRlRXJyb3InO1xuICAgICAgICBlcnJvci5jb2RlID0gMTE7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID4gdGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8uZHVyYXRpb24gfHwgaXNOYU4odGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8uZHVyYXRpb24pKSB7XG4gICAgICAgIHRoaXMubmF0aXZlTWVkaWFTb3VyY2VfLmR1cmF0aW9uID0gZW5kO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHNvdXJjZSBidWZmZXIgdG8gdGhlIG1lZGlhIHNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVNvdXJjZS9hZGRTb3VyY2VCdWZmZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgY29udGVudC10eXBlIG9mIHRoZSBjb250ZW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgY3JlYXRlZCBzb3VyY2UgYnVmZmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZFNvdXJjZUJ1ZmZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNvdXJjZUJ1ZmZlcih0eXBlKSB7XG4gICAgICB2YXIgYnVmZmVyID0gdm9pZCAwO1xuICAgICAgdmFyIHBhcnNlZFR5cGUgPSBwYXJzZUNvbnRlbnRUeXBlKHR5cGUpO1xuXG4gICAgICAvLyBDcmVhdGUgYSBWaXJ0dWFsU291cmNlQnVmZmVyIHRvIHRyYW5zbXV4IE1QRUctMiB0cmFuc3BvcnRcbiAgICAgIC8vIHN0cmVhbSBzZWdtZW50cyBpbnRvIGZyYWdtZW50ZWQgTVA0c1xuICAgICAgaWYgKC9eKHZpZGVvfGF1ZGlvKVxcL21wMnQkL2kudGVzdChwYXJzZWRUeXBlLnR5cGUpKSB7XG4gICAgICAgIHZhciBjb2RlY3MgPSBbXTtcblxuICAgICAgICBpZiAocGFyc2VkVHlwZS5wYXJhbWV0ZXJzICYmIHBhcnNlZFR5cGUucGFyYW1ldGVycy5jb2RlY3MpIHtcbiAgICAgICAgICBjb2RlY3MgPSBwYXJzZWRUeXBlLnBhcmFtZXRlcnMuY29kZWNzLnNwbGl0KCcsJyk7XG4gICAgICAgICAgY29kZWNzID0gdHJhbnNsYXRlTGVnYWN5Q29kZWNzKGNvZGVjcyk7XG4gICAgICAgICAgY29kZWNzID0gY29kZWNzLmZpbHRlcihmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0F1ZGlvQ29kZWMoY29kZWMpIHx8IGlzVmlkZW9Db2RlYyhjb2RlYyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvZGVjcyA9IFsnYXZjMS40ZDQwMGQnLCAnbXA0YS40MC4yJ107XG4gICAgICAgIH1cblxuICAgICAgICBidWZmZXIgPSBuZXcgVmlydHVhbFNvdXJjZUJ1ZmZlcih0aGlzLCBjb2RlY3MpO1xuXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZUJ1ZmZlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgLy8gSWYgYW5vdGhlciBWaXJ0dWFsU291cmNlQnVmZmVyIGFscmVhZHkgZXhpc3RzLCB0aGVuIHdlIGFyZSBjcmVhdGluZyBhXG4gICAgICAgICAgLy8gU291cmNlQnVmZmVyIGZvciBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2sgYW5kIHRoZXJlZm9yZSB3ZSBrbm93IHRoYXRcbiAgICAgICAgICAvLyB0aGUgc291cmNlIGhhcyBib3RoIGFuIGF1ZGlvIGFuZCB2aWRlbyB0cmFjay5cbiAgICAgICAgICAvLyBUaGF0IG1lYW5zIHdlIHNob3VsZCB0cmlnZ2VyIHRoZSBtYW51YWwgY3JlYXRpb24gb2YgdGhlIHJlYWxcbiAgICAgICAgICAvLyBTb3VyY2VCdWZmZXJzIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIHRyYW5zbXV4ZXIgdG8gcmV0dXJuIGRhdGFcbiAgICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnNbMF0uY3JlYXRlUmVhbFNvdXJjZUJ1ZmZlcnNfKCk7XG4gICAgICAgICAgYnVmZmVyLmNyZWF0ZVJlYWxTb3VyY2VCdWZmZXJzXygpO1xuXG4gICAgICAgICAgLy8gQXV0b21hdGljYWxseSBkaXNhYmxlIHRoZSBhdWRpbyBvbiB0aGUgZmlyc3Qgc291cmNlIGJ1ZmZlciBpZlxuICAgICAgICAgIC8vIGEgc2Vjb25kIHNvdXJjZSBidWZmZXIgaXMgZXZlciBjcmVhdGVkXG4gICAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzWzBdLmF1ZGlvRGlzYWJsZWRfID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICBidWZmZXIgPSB0aGlzLm5hdGl2ZU1lZGlhU291cmNlXy5hZGRTb3VyY2VCdWZmZXIodHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc291cmNlQnVmZmVycy5wdXNoKGJ1ZmZlcik7XG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSHRtbE1lZGlhU291cmNlO1xufSh2aWRlb2pzJDEuRXZlbnRUYXJnZXQpO1xuXG4vKipcbiAqIEBmaWxlIHZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzLmpzXG4gKi9cbnZhciB1cmxDb3VudCA9IDA7XG5cbi8vIC0tLS0tLS0tLS0tLVxuLy8gTWVkaWEgU291cmNlXG4vLyAtLS0tLS0tLS0tLS1cblxuLy8gc3RvcmUgcmVmZXJlbmNlcyB0byB0aGUgbWVkaWEgc291cmNlcyBzbyB0aGV5IGNhbiBiZSBjb25uZWN0ZWRcbi8vIHRvIGEgdmlkZW8gZWxlbWVudCAoYSBzd2Ygb2JqZWN0KVxuLy8gVE9ETzogY2FuIHdlIHN0b3JlIHRoaXMgc29tZXdoZXJlIGxvY2FsIHRvIHRoaXMgbW9kdWxlP1xudmlkZW9qcyQxLm1lZGlhU291cmNlcyA9IHt9O1xuXG4vKipcbiAqIFByb3ZpZGUgYSBtZXRob2QgZm9yIGEgc3dmIG9iamVjdCB0byBub3RpZnkgSlMgdGhhdCBhXG4gKiBtZWRpYSBzb3VyY2UgaXMgbm93IG9wZW4uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1zT2JqZWN0VVJMIHN0cmluZyByZWZlcmVuY2luZyB0aGUgTVNFIE9iamVjdCBVUkxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzd2ZJZCB0aGUgc3dmIGlkXG4gKi9cbnZhciBvcGVuID0gZnVuY3Rpb24gb3Blbihtc09iamVjdFVSTCwgc3dmSWQpIHtcbiAgdmFyIG1lZGlhU291cmNlID0gdmlkZW9qcyQxLm1lZGlhU291cmNlc1ttc09iamVjdFVSTF07XG5cbiAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgbWVkaWFTb3VyY2UudHJpZ2dlcih7IHR5cGU6ICdzb3VyY2VvcGVuJywgc3dmSWQ6IHN3ZklkIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignTWVkaWEgU291cmNlIG5vdCBmb3VuZCAoVmlkZW8uanMpJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBuYXRpdmUgTWVkaWFTb3VyY2Ugb2JqZWN0IGV4aXN0cyBhbmQgc3VwcG9ydHNcbiAqIGFuIE1QNCBjb250YWluZXIgd2l0aCBib3RoIEguMjY0IHZpZGVvIGFuZCBBQUMtTEMgYXVkaW8uXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gaWYgIG5hdGl2ZSBtZWRpYSBzb3VyY2VzIGFyZSBzdXBwb3J0ZWRcbiAqL1xudmFyIHN1cHBvcnRzTmF0aXZlTWVkaWFTb3VyY2VzID0gZnVuY3Rpb24gc3VwcG9ydHNOYXRpdmVNZWRpYVNvdXJjZXMoKSB7XG4gIHJldHVybiAhIXdpbmRvdyQxLk1lZGlhU291cmNlICYmICEhd2luZG93JDEuTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkICYmIHdpbmRvdyQxLk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0O2NvZGVjcz1cImF2YzEuNGQ0MDBkLG1wNGEuNDAuMlwiJyk7XG59O1xuXG4vKipcbiAqIEFuIGVtdWxhdGlvbiBvZiB0aGUgTWVkaWFTb3VyY2UgQVBJIHNvIHRoYXQgd2UgY2FuIHN1cHBvcnRcbiAqIG5hdGl2ZSBhbmQgbm9uLW5hdGl2ZSBmdW5jdGlvbmFsaXR5LiByZXR1cm5zIGFuIGluc3RhbmNlIG9mXG4gKiBIdG1sTWVkaWFTb3VyY2UuXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhU291cmNlL01lZGlhU291cmNlXG4gKi9cbnZhciBNZWRpYVNvdXJjZSA9IGZ1bmN0aW9uIE1lZGlhU291cmNlKCkge1xuICB0aGlzLk1lZGlhU291cmNlID0ge1xuICAgIG9wZW46IG9wZW4sXG4gICAgc3VwcG9ydHNOYXRpdmVNZWRpYVNvdXJjZXM6IHN1cHBvcnRzTmF0aXZlTWVkaWFTb3VyY2VzXG4gIH07XG5cbiAgaWYgKHN1cHBvcnRzTmF0aXZlTWVkaWFTb3VyY2VzKCkpIHtcbiAgICByZXR1cm4gbmV3IEh0bWxNZWRpYVNvdXJjZSgpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGNyZWF0ZSBhIHZpcnR1YWwgTWVkaWFTb3VyY2UgZm9yIHRoaXMgdmlkZW8nKTtcbn07XG5cbk1lZGlhU291cmNlLm9wZW4gPSBvcGVuO1xuTWVkaWFTb3VyY2Uuc3VwcG9ydHNOYXRpdmVNZWRpYVNvdXJjZXMgPSBzdXBwb3J0c05hdGl2ZU1lZGlhU291cmNlcztcblxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgVVJMIGZvciBvdXIgTVNFIG9iamVjdFxuICogaW1wbGVtZW50YXRpb24sIHRoaXMgb2JqZWN0IGlzIGV4cG9zZWQgdW5kZXIgdmlkZW9qcy5VUkxcbiAqXG4gKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJML1VSTFxuICovXG52YXIgVVJMJDEgPSB7XG4gIC8qKlxuICAgKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgY3JlYXRlT2JqZWN0VVJMIGZvciBvdXIgb2JqZWN0cy5cbiAgICogVGhpcyBmdW5jdGlvbiBtYXBzIGEgbmF0aXZlIG9yIGVtdWxhdGVkIG1lZGlhU291cmNlIHRvIGEgYmxvYlxuICAgKiB1cmwgc28gdGhhdCBpdCBjYW4gYmUgbG9hZGVkIGludG8gdmlkZW8uanNcbiAgICpcbiAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9jcmVhdGVPYmplY3RVUkxcbiAgICogQHBhcmFtIHtNZWRpYVNvdXJjZX0gb2JqZWN0IHRoZSBvYmplY3QgdG8gY3JlYXRlIGEgYmxvYiB1cmwgdG9cbiAgICovXG4gIGNyZWF0ZU9iamVjdFVSTDogZnVuY3Rpb24gY3JlYXRlT2JqZWN0VVJMKG9iamVjdCkge1xuICAgIHZhciBvYmplY3RVcmxQcmVmaXggPSAnYmxvYjp2anMtbWVkaWEtc291cmNlLyc7XG4gICAgdmFyIHVybCA9IHZvaWQgMDtcblxuICAgIC8vIHVzZSB0aGUgbmF0aXZlIE1lZGlhU291cmNlIHRvIGdlbmVyYXRlIGFuIG9iamVjdCBVUkxcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgSHRtbE1lZGlhU291cmNlKSB7XG4gICAgICB1cmwgPSB3aW5kb3ckMS5VUkwuY3JlYXRlT2JqZWN0VVJMKG9iamVjdC5uYXRpdmVNZWRpYVNvdXJjZV8pO1xuICAgICAgb2JqZWN0LnVybF8gPSB1cmw7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgb2JqZWN0IGlzbid0IGFuIGVtdWxhdGVkIE1lZGlhU291cmNlLCBkZWxlZ2F0ZSB0byB0aGVcbiAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb25cbiAgICBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBIdG1sTWVkaWFTb3VyY2UpKSB7XG4gICAgICB1cmwgPSB3aW5kb3ckMS5VUkwuY3JlYXRlT2JqZWN0VVJMKG9iamVjdCk7XG4gICAgICBvYmplY3QudXJsXyA9IHVybDtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgYSBVUkwgdGhhdCBjYW4gYmUgdXNlZCB0byBtYXAgYmFjayB0byB0aGUgZW11bGF0ZWRcbiAgICAvLyBNZWRpYVNvdXJjZVxuICAgIHVybCA9IG9iamVjdFVybFByZWZpeCArIHVybENvdW50O1xuXG4gICAgdXJsQ291bnQrKztcblxuICAgIC8vIHNldHVwIHRoZSBtYXBwaW5nIGJhY2sgdG8gb2JqZWN0XG4gICAgdmlkZW9qcyQxLm1lZGlhU291cmNlc1t1cmxdID0gb2JqZWN0O1xuXG4gICAgcmV0dXJuIHVybDtcbiAgfVxufTtcblxudmlkZW9qcyQxLk1lZGlhU291cmNlID0gTWVkaWFTb3VyY2U7XG52aWRlb2pzJDEuVVJMID0gVVJMJDE7XG5cbnZhciBFdmVudFRhcmdldCQxJDEgPSB2aWRlb2pzJDEuRXZlbnRUYXJnZXQsXG4gICAgbWVyZ2VPcHRpb25zJDIgPSB2aWRlb2pzJDEubWVyZ2VPcHRpb25zO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbWFzdGVyIG1hbmlmZXN0IHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBtZXJnaW5nIGFuIHVwZGF0ZWQgbWFzdGVyIG1hbmlmZXN0XG4gKiBpbnRvIHRoZSBvcmlnaW5hbCB2ZXJzaW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRNYXN0ZXJcbiAqICAgICAgICBUaGUgb2xkIHBhcnNlZCBtcGQgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gbmV3TWFzdGVyXG4gKiAgICAgICAgVGhlIHVwZGF0ZWQgcGFyc2VkIG1wZCBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgQSBuZXcgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgb3JpZ2luYWwgbWFzdGVyIG1hbmlmZXN0IHdpdGggdGhlIHVwZGF0ZWQgbWVkaWFcbiAqICAgICAgICAgcGxheWxpc3RzIG1lcmdlZCBpblxuICovXG5cbnZhciB1cGRhdGVNYXN0ZXIkMSA9IGZ1bmN0aW9uIHVwZGF0ZU1hc3RlciQkMShvbGRNYXN0ZXIsIG5ld01hc3Rlcikge1xuICB2YXIgdXBkYXRlID0gbWVyZ2VPcHRpb25zJDIob2xkTWFzdGVyLCB7XG4gICAgLy8gVGhlc2UgYXJlIHRvcCBsZXZlbCBwcm9wZXJ0aWVzIHRoYXQgY2FuIGJlIHVwZGF0ZWRcbiAgICBkdXJhdGlvbjogbmV3TWFzdGVyLmR1cmF0aW9uLFxuICAgIG1pbmltdW1VcGRhdGVQZXJpb2Q6IG5ld01hc3Rlci5taW5pbXVtVXBkYXRlUGVyaW9kXG4gIH0pO1xuXG4gIC8vIEZpcnN0IHVwZGF0ZSB0aGUgcGxheWxpc3RzIGluIHBsYXlsaXN0IGxpc3RcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdNYXN0ZXIucGxheWxpc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYXlsaXN0VXBkYXRlID0gdXBkYXRlTWFzdGVyKHVwZGF0ZSwgbmV3TWFzdGVyLnBsYXlsaXN0c1tpXSk7XG5cbiAgICBpZiAocGxheWxpc3RVcGRhdGUpIHtcbiAgICAgIHVwZGF0ZSA9IHBsYXlsaXN0VXBkYXRlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoZW4gdXBkYXRlIG1lZGlhIGdyb3VwIHBsYXlsaXN0c1xuICBmb3JFYWNoTWVkaWFHcm91cChuZXdNYXN0ZXIsIGZ1bmN0aW9uIChwcm9wZXJ0aWVzLCB0eXBlLCBncm91cCwgbGFiZWwpIHtcbiAgICBpZiAocHJvcGVydGllcy5wbGF5bGlzdHMgJiYgcHJvcGVydGllcy5wbGF5bGlzdHMubGVuZ3RoKSB7XG4gICAgICB2YXIgdXJpID0gcHJvcGVydGllcy5wbGF5bGlzdHNbMF0udXJpO1xuICAgICAgdmFyIF9wbGF5bGlzdFVwZGF0ZSA9IHVwZGF0ZU1hc3Rlcih1cGRhdGUsIHByb3BlcnRpZXMucGxheWxpc3RzWzBdKTtcblxuICAgICAgaWYgKF9wbGF5bGlzdFVwZGF0ZSkge1xuICAgICAgICB1cGRhdGUgPSBfcGxheWxpc3RVcGRhdGU7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgcGxheWxpc3QgcmVmZXJlbmNlIHdpdGhpbiBtZWRpYSBncm91cHNcbiAgICAgICAgdXBkYXRlLm1lZGlhR3JvdXBzW3R5cGVdW2dyb3VwXVtsYWJlbF0ucGxheWxpc3RzWzBdID0gdXBkYXRlLnBsYXlsaXN0c1t1cmldO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHVwZGF0ZTtcbn07XG5cbnZhciBEYXNoUGxheWxpc3RMb2FkZXIgPSBmdW5jdGlvbiAoX0V2ZW50VGFyZ2V0KSB7XG4gIGluaGVyaXRzJDEoRGFzaFBsYXlsaXN0TG9hZGVyLCBfRXZlbnRUYXJnZXQpO1xuXG4gIC8vIERhc2hQbGF5bGlzdExvYWRlciBtdXN0IGFjY2VwdCBlaXRoZXIgYSBzcmMgdXJsIG9yIGEgcGxheWxpc3QgYmVjYXVzZSBzdWJzZXF1ZW50XG4gIC8vIHBsYXlsaXN0IGxvYWRlciBzZXR1cHMgZnJvbSBtZWRpYSBncm91cHMgd2lsbCBleHBlY3QgdG8gYmUgYWJsZSB0byBwYXNzIGEgcGxheWxpc3RcbiAgLy8gKHNpbmNlIHRoZXJlIGFyZW4ndCBleHRlcm5hbCBVUkxzIHRvIG1lZGlhIHBsYXlsaXN0cyB3aXRoIERBU0gpXG4gIGZ1bmN0aW9uIERhc2hQbGF5bGlzdExvYWRlcihzcmNVcmxPclBsYXlsaXN0LCBobHMsIHdpdGhDcmVkZW50aWFscywgbWFzdGVyUGxheWxpc3RMb2FkZXIpIHtcbiAgICBjbGFzc0NhbGxDaGVjayQxKHRoaXMsIERhc2hQbGF5bGlzdExvYWRlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJDEodGhpcywgKERhc2hQbGF5bGlzdExvYWRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERhc2hQbGF5bGlzdExvYWRlcikpLmNhbGwodGhpcykpO1xuXG4gICAgX3RoaXMuaGxzXyA9IGhscztcbiAgICBfdGhpcy53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHM7XG5cbiAgICBpZiAoIXNyY1VybE9yUGxheWxpc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBub24tZW1wdHkgcGxheWxpc3QgVVJMIG9yIHBsYXlsaXN0IGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgLy8gZXZlbnQgbmFtaW5nP1xuICAgIF90aGlzLm9uKCdtaW5pbXVtVXBkYXRlUGVyaW9kJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucmVmcmVzaFhtbF8oKTtcbiAgICB9KTtcblxuICAgIC8vIGxpdmUgcGxheWxpc3Qgc3RhbGVuZXNzIHRpbWVvdXRcbiAgICBfdGhpcy5vbignbWVkaWF1cGRhdGV0aW1lb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucmVmcmVzaE1lZGlhXygpO1xuICAgIH0pO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgbG9hZGVyIHN0YXRlXG4gICAgaWYgKHR5cGVvZiBzcmNVcmxPclBsYXlsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgX3RoaXMuc3JjVXJsID0gc3JjVXJsT3JQbGF5bGlzdDtcbiAgICAgIF90aGlzLnN0YXRlID0gJ0hBVkVfTk9USElORyc7XG4gICAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiQxKF90aGlzKTtcbiAgICB9XG5cbiAgICBfdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8gPSBtYXN0ZXJQbGF5bGlzdExvYWRlcjtcblxuICAgIF90aGlzLnN0YXRlID0gJ0hBVkVfTUVUQURBVEEnO1xuICAgIF90aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIC8vIHdlIG9ubHkgc2hvdWxkIGhhdmUgb25lIHBsYXlsaXN0IHNvIHNlbGVjdCBpdFxuICAgIF90aGlzLm1lZGlhKHNyY1VybE9yUGxheWxpc3QpO1xuICAgIC8vIHRyaWdnZXIgYXN5bmMgdG8gbWltaWMgYmVoYXZpb3Igb2YgSExTLCB3aGVyZSBpdCBtdXN0IHJlcXVlc3QgYSBwbGF5bGlzdFxuICAgIHdpbmRvdyQxLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMudHJpZ2dlcignbG9hZGVkbWV0YWRhdGEnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBjcmVhdGVDbGFzcyQxKERhc2hQbGF5bGlzdExvYWRlciwgW3tcbiAgICBrZXk6ICdkaXNwb3NlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuc3RvcFJlcXVlc3QoKTtcbiAgICAgIHdpbmRvdyQxLmNsZWFyVGltZW91dCh0aGlzLm1lZGlhVXBkYXRlVGltZW91dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RvcFJlcXVlc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wUmVxdWVzdCgpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcbiAgICAgICAgdmFyIG9sZFJlcXVlc3QgPSB0aGlzLnJlcXVlc3Q7XG5cbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgb2xkUmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICBvbGRSZXF1ZXN0LmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWVkaWEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZWRpYShwbGF5bGlzdCkge1xuICAgICAgLy8gZ2V0dGVyXG4gICAgICBpZiAoIXBsYXlsaXN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhXztcbiAgICAgIH1cblxuICAgICAgLy8gc2V0dGVyXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0hBVkVfTk9USElORycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dpdGNoIG1lZGlhIHBsYXlsaXN0IGZyb20gJyArIHRoaXMuc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRpbmdTdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgIC8vIGZpbmQgdGhlIHBsYXlsaXN0IG9iamVjdCBpZiB0aGUgdGFyZ2V0IHBsYXlsaXN0IGhhcyBiZWVuIHNwZWNpZmllZCBieSBVUklcbiAgICAgIGlmICh0eXBlb2YgcGxheWxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXN0ZXIucGxheWxpc3RzW3BsYXlsaXN0XSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwbGF5bGlzdCBVUkk6ICcgKyBwbGF5bGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcGxheWxpc3QgPSB0aGlzLm1hc3Rlci5wbGF5bGlzdHNbcGxheWxpc3RdO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWVkaWFDaGFuZ2UgPSAhdGhpcy5tZWRpYV8gfHwgcGxheWxpc3QudXJpICE9PSB0aGlzLm1lZGlhXy51cmk7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSAnSEFWRV9NRVRBREFUQSc7XG5cbiAgICAgIC8vIHN3aXRjaGluZyB0byB0aGUgYWN0aXZlIHBsYXlsaXN0IGlzIGEgbm8tb3BcbiAgICAgIGlmICghbWVkaWFDaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBzd2l0Y2hpbmcgZnJvbSBhbiBhbHJlYWR5IGxvYWRlZCBwbGF5bGlzdFxuICAgICAgaWYgKHRoaXMubWVkaWFfKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignbWVkaWFjaGFuZ2luZycpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1lZGlhXyA9IHBsYXlsaXN0O1xuXG4gICAgICB0aGlzLnJlZnJlc2hNZWRpYV8oKTtcblxuICAgICAgLy8gdHJpZ2dlciBtZWRpYSBjaGFuZ2UgaWYgdGhlIGFjdGl2ZSBtZWRpYSBoYXMgYmVlbiB1cGRhdGVkXG4gICAgICBpZiAoc3RhcnRpbmdTdGF0ZSAhPT0gJ0hBVkVfTUFTVEVSJykge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ21lZGlhY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncGF1c2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIHRoaXMuc3RvcFJlcXVlc3QoKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnSEFWRV9OT1RISU5HJykge1xuICAgICAgICAvLyBJZiB3ZSBwYXVzZSB0aGUgbG9hZGVyIGJlZm9yZSBhbnkgZGF0YSBoYXMgYmVlbiByZXRyaWV2ZWQsIGl0cyBhcyBpZiB3ZSBuZXZlclxuICAgICAgICAvLyBzdGFydGVkLCBzbyByZXNldCB0byBhbiB1bnN0YXJ0ZWQgc3RhdGUuXG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgLy8gYmVjYXVzZSB0aGUgcGxheWxpc3RzIGFyZSBpbnRlcm5hbCB0byB0aGUgbWFuaWZlc3QsIGxvYWQgc2hvdWxkIGVpdGhlciBsb2FkIHRoZVxuICAgICAgLy8gbWFpbiBtYW5pZmVzdCwgb3IgZG8gbm90aGluZyBidXQgdHJpZ2dlciBhbiBldmVudFxuICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZGVkcGxheWxpc3QnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIG1hc3RlciB4bWwgc3RyaW5nIGFuZCB1cGRhdGVzIHBsYXlsaXN0IHVyaSByZWZlcmVuY2VzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICogICAgICAgICBUaGUgcGFyc2VkIG1wZCBtYW5pZmVzdCBvYmplY3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGFyc2VNYXN0ZXJYbWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU1hc3RlclhtbCgpIHtcbiAgICAgIHZhciBtYXN0ZXIgPSBwYXJzZSh0aGlzLm1hc3RlclhtbF8sIHtcbiAgICAgICAgbWFuaWZlc3RVcmk6IHRoaXMuc3JjVXJsLFxuICAgICAgICBjbGllbnRPZmZzZXQ6IHRoaXMuY2xpZW50T2Zmc2V0X1xuICAgICAgfSk7XG5cbiAgICAgIG1hc3Rlci51cmkgPSB0aGlzLnNyY1VybDtcblxuICAgICAgLy8gU2V0IHVwIHBob255IFVSSXMgZm9yIHRoZSBwbGF5bGlzdHMgc2luY2Ugd2Ugd29uJ3QgaGF2ZSBleHRlcm5hbCBVUklzIGZvciBEQVNIXG4gICAgICAvLyBidXQgcmVmZXJlbmNlIHBsYXlsaXN0cyBieSB0aGVpciBVUkkgdGhyb3VnaG91dCB0aGUgcHJvamVjdFxuICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIGNyZWF0ZSB0aGUgZHVtbXkgdXJpcyBpbiBtcGQtcGFyc2VyIGFzIHdlbGwgKGxlYW5pbmcgdG93YXJkcyB5ZXMpLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXN0ZXIucGxheWxpc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwaG9ueVVyaSA9ICdwbGFjZWhvbGRlci11cmktJyArIGk7XG5cbiAgICAgICAgbWFzdGVyLnBsYXlsaXN0c1tpXS51cmkgPSBwaG9ueVVyaTtcbiAgICAgICAgLy8gc2V0IHVwIGJ5IFVSSSByZWZlcmVuY2VzXG4gICAgICAgIG1hc3Rlci5wbGF5bGlzdHNbcGhvbnlVcmldID0gbWFzdGVyLnBsYXlsaXN0c1tpXTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHVwIHBob255IFVSSXMgZm9yIHRoZSBtZWRpYSBncm91cCBwbGF5bGlzdHMgc2luY2Ugd2Ugd29uJ3QgaGF2ZSBleHRlcm5hbFxuICAgICAgLy8gVVJJcyBmb3IgREFTSCBidXQgcmVmZXJlbmNlIHBsYXlsaXN0cyBieSB0aGVpciBVUkkgdGhyb3VnaG91dCB0aGUgcHJvamVjdFxuICAgICAgZm9yRWFjaE1lZGlhR3JvdXAobWFzdGVyLCBmdW5jdGlvbiAocHJvcGVydGllcywgbWVkaWFUeXBlLCBncm91cEtleSwgbGFiZWxLZXkpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMucGxheWxpc3RzICYmIHByb3BlcnRpZXMucGxheWxpc3RzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBfcGhvbnlVcmkgPSAncGxhY2Vob2xkZXItdXJpLScgKyBtZWRpYVR5cGUgKyAnLScgKyBncm91cEtleSArICctJyArIGxhYmVsS2V5O1xuXG4gICAgICAgICAgcHJvcGVydGllcy5wbGF5bGlzdHNbMF0udXJpID0gX3Bob255VXJpO1xuICAgICAgICAgIC8vIHNldHVwIFVSSSByZWZlcmVuY2VzXG4gICAgICAgICAgbWFzdGVyLnBsYXlsaXN0c1tfcGhvbnlVcmldID0gcHJvcGVydGllcy5wbGF5bGlzdHNbMF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBzZXR1cE1lZGlhUGxheWxpc3RzKG1hc3Rlcik7XG4gICAgICByZXNvbHZlTWVkaWFHcm91cFVyaXMobWFzdGVyKTtcblxuICAgICAgcmV0dXJuIG1hc3RlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIC8vIHJlcXVlc3QgdGhlIHNwZWNpZmllZCBVUkxcbiAgICAgIHRoaXMucmVxdWVzdCA9IHRoaXMuaGxzXy54aHIoe1xuICAgICAgICB1cmk6IHRoaXMuc3JjVXJsLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHRoaXMud2l0aENyZWRlbnRpYWxzXG4gICAgICB9LCBmdW5jdGlvbiAoZXJyb3IsIHJlcSkge1xuICAgICAgICAvLyBkaXNwb3NlZFxuICAgICAgICBpZiAoIV90aGlzMi5yZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGxvYWRlcidzIHJlcXVlc3QgcmVmZXJlbmNlXG4gICAgICAgIF90aGlzMi5yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBfdGhpczIuZXJyb3IgPSB7XG4gICAgICAgICAgICBzdGF0dXM6IHJlcS5zdGF0dXMsXG4gICAgICAgICAgICBtZXNzYWdlOiAnREFTSCBwbGF5bGlzdCByZXF1ZXN0IGVycm9yIGF0IFVSTDogJyArIF90aGlzMi5zcmNVcmwsXG4gICAgICAgICAgICByZXNwb25zZVRleHQ6IHJlcS5yZXNwb25zZVRleHQsXG4gICAgICAgICAgICAvLyBNRURJQV9FUlJfTkVUV09SS1xuICAgICAgICAgICAgY29kZTogMlxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKF90aGlzMi5zdGF0ZSA9PT0gJ0hBVkVfTk9USElORycpIHtcbiAgICAgICAgICAgIF90aGlzMi5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfdGhpczIudHJpZ2dlcignZXJyb3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi5tYXN0ZXJYbWxfID0gcmVxLnJlc3BvbnNlVGV4dDtcblxuICAgICAgICBpZiAocmVxLnJlc3BvbnNlSGVhZGVycyAmJiByZXEucmVzcG9uc2VIZWFkZXJzLmRhdGUpIHtcbiAgICAgICAgICBfdGhpczIubWFzdGVyTG9hZGVkXyA9IERhdGUucGFyc2UocmVxLnJlc3BvbnNlSGVhZGVycy5kYXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIubWFzdGVyTG9hZGVkXyA9IERhdGUubm93KCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczIuc3luY0NsaWVudFNlcnZlckNsb2NrXyhfdGhpczIub25DbGllbnRTZXJ2ZXJDbG9ja1N5bmNfLmJpbmQoX3RoaXMyKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIG1hc3RlciB4bWwgZm9yIFVUQ1RpbWluZyBub2RlIHRvIHN5bmMgdGhlIGNsaWVudCBjbG9jayB0byB0aGUgc2VydmVyXG4gICAgICogY2xvY2suIElmIHRoZSBVVENUaW1pbmcgbm9kZSByZXF1aXJlcyBhIEhFQUQgb3IgR0VUIHJlcXVlc3QsIHRoYXQgcmVxdWVzdCBpcyBtYWRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgICAqICAgICAgICBGdW5jdGlvbiB0byBjYWxsIHdoZW4gY2xvY2sgc3luYyBoYXMgY29tcGxldGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N5bmNDbGllbnRTZXJ2ZXJDbG9ja18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeW5jQ2xpZW50U2VydmVyQ2xvY2tfKGRvbmUpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgdXRjVGltaW5nID0gcGFyc2VVVENUaW1pbmcodGhpcy5tYXN0ZXJYbWxfKTtcblxuICAgICAgLy8gTm8gVVRDVGltaW5nIGVsZW1lbnQgZm91bmQgaW4gdGhlIG1wZC4gVXNlIERhdGUgaGVhZGVyIGZyb20gbXBkIHJlcXVlc3QgYXMgdGhlXG4gICAgICAvLyBzZXJ2ZXIgY2xvY2tcbiAgICAgIGlmICh1dGNUaW1pbmcgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jbGllbnRPZmZzZXRfID0gdGhpcy5tYXN0ZXJMb2FkZWRfIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0Y1RpbWluZy5tZXRob2QgPT09ICdESVJFQ1QnKSB7XG4gICAgICAgIHRoaXMuY2xpZW50T2Zmc2V0XyA9IHV0Y1RpbWluZy52YWx1ZSAtIERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVxdWVzdCA9IHRoaXMuaGxzXy54aHIoe1xuICAgICAgICB1cmk6IHJlc29sdmVVcmwodGhpcy5zcmNVcmwsIHV0Y1RpbWluZy52YWx1ZSksXG4gICAgICAgIG1ldGhvZDogdXRjVGltaW5nLm1ldGhvZCxcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0aGlzLndpdGhDcmVkZW50aWFsc1xuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yLCByZXEpIHtcbiAgICAgICAgLy8gZGlzcG9zZWRcbiAgICAgICAgaWYgKCFfdGhpczMucmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIC8vIHN5bmMgcmVxdWVzdCBmYWlsZWQsIGZhbGwgYmFjayB0byB1c2luZyBkYXRlIGhlYWRlciBmcm9tIG1wZFxuICAgICAgICAgIC8vIFRPRE86IGxvZyB3YXJuaW5nXG4gICAgICAgICAgX3RoaXMzLmNsaWVudE9mZnNldF8gPSBfdGhpczMubWFzdGVyTG9hZGVkXyAtIERhdGUubm93KCk7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZXJ2ZXJUaW1lID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh1dGNUaW1pbmcubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAgICAgICBpZiAoIXJlcS5yZXNwb25zZUhlYWRlcnMgfHwgIXJlcS5yZXNwb25zZUhlYWRlcnMuZGF0ZSkge1xuICAgICAgICAgICAgLy8gZXhwZWN0ZWQgZGF0ZSBoZWFkZXIgbm90IHByZXNldCwgZmFsbCBiYWNrIHRvIHVzaW5nIGRhdGUgaGVhZGVyIGZyb20gbXBkXG4gICAgICAgICAgICAvLyBUT0RPOiBsb2cgd2FybmluZ1xuICAgICAgICAgICAgc2VydmVyVGltZSA9IF90aGlzMy5tYXN0ZXJMb2FkZWRfO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXJ2ZXJUaW1lID0gRGF0ZS5wYXJzZShyZXEucmVzcG9uc2VIZWFkZXJzLmRhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJ2ZXJUaW1lID0gRGF0ZS5wYXJzZShyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMy5jbGllbnRPZmZzZXRfID0gc2VydmVyVGltZSAtIERhdGUubm93KCk7XG5cbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgYWZ0ZXIgY2xpZW50L3NlcnZlciBjbG9jayBzeW5jaHJvbml6YXRpb24gaGFzIGhhcHBlbmVkLiBTZXRzIHVwXG4gICAgICogeG1sIHJlZnJlc2ggdGltZXIgaWYgc3BlY2lmaWNlZCBieSB0aGUgbWFuaWZlc3QuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uQ2xpZW50U2VydmVyQ2xvY2tTeW5jXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2xpZW50U2VydmVyQ2xvY2tTeW5jXygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLm1hc3RlciA9IHRoaXMucGFyc2VNYXN0ZXJYbWwoKTtcblxuICAgICAgdGhpcy5zdGF0ZSA9ICdIQVZFX01BU1RFUic7XG5cbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZGVkcGxheWxpc3QnKTtcblxuICAgICAgaWYgKCF0aGlzLm1lZGlhXykge1xuICAgICAgICAvLyBubyBtZWRpYSBwbGF5bGlzdCB3YXMgc3BlY2lmaWNhbGx5IHNlbGVjdGVkIHNvIHN0YXJ0XG4gICAgICAgIC8vIGZyb20gdGhlIGZpcnN0IGxpc3RlZCBvbmVcbiAgICAgICAgdGhpcy5tZWRpYSh0aGlzLm1hc3Rlci5wbGF5bGlzdHNbMF0pO1xuICAgICAgfVxuICAgICAgLy8gdHJpZ2dlciBsb2FkZWRtZXRhZGF0YSB0byByZXNvbHZlIHNldHVwIG9mIG1lZGlhIGdyb3Vwc1xuICAgICAgLy8gdHJpZ2dlciBhc3luYyB0byBtaW1pYyBiZWhhdmlvciBvZiBITFMsIHdoZXJlIGl0IG11c3QgcmVxdWVzdCBhIHBsYXlsaXN0XG4gICAgICB3aW5kb3ckMS5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM0LnRyaWdnZXIoJ2xvYWRlZG1ldGFkYXRhJyk7XG4gICAgICB9LCAwKTtcblxuICAgICAgLy8gVE9ETzogbWluaW11bVVwZGF0ZVBlcmlvZCBjYW4gaGF2ZSBhIHZhbHVlIG9mIDAuIEN1cnJlbnRseSB0aGUgbWFuaWZlc3Qgd2lsbCBub3RcbiAgICAgIC8vIGJlIHJlZnJlc2hlZCB3aGVuIHRoaXMgaXMgdGhlIGNhc2UuIFRoZSBpbnRlci1vcCBndWlkZSBzYXlzIHRoYXQgd2hlbiB0aGVcbiAgICAgIC8vIG1pbmltdW1VcGRhdGVQZXJpb2QgaXMgMCwgdGhlIG1hbmlmZXN0IHNob3VsZCBvdXRsaW5lIGFsbCBjdXJyZW50bHkgYXZhaWxhYmxlXG4gICAgICAvLyBzZWdtZW50cywgYnV0IGZ1dHVyZSBzZWdtZW50cyBtYXkgcmVxdWlyZSBhbiB1cGRhdGUuIEkgdGhpbmsgYSBnb29kIHNvbHV0aW9uXG4gICAgICAvLyB3b3VsZCBiZSB0byB1cGRhdGUgdGhlIG1hbmlmZXN0IGF0IHRoZSBzYW1lIHJhdGUgdGhhdCB0aGUgbWVkaWEgcGxheWxpc3RzXG4gICAgICAvLyBhcmUgXCJyZWZyZXNoZWRcIiwgaS5lLiBldmVyeSB0YXJnZXREdXJhdGlvbi5cbiAgICAgIGlmICh0aGlzLm1hc3Rlci5taW5pbXVtVXBkYXRlUGVyaW9kKSB7XG4gICAgICAgIHdpbmRvdyQxLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNC50cmlnZ2VyKCdtaW5pbXVtVXBkYXRlUGVyaW9kJyk7XG4gICAgICAgIH0sIHRoaXMubWFzdGVyLm1pbmltdW1VcGRhdGVQZXJpb2QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmRzIHJlcXVlc3QgdG8gcmVmcmVzaCB0aGUgbWFzdGVyIHhtbCBhbmQgdXBkYXRlcyB0aGUgcGFyc2VkIG1hc3RlciBtYW5pZmVzdFxuICAgICAqIFRPRE86IERvZXMgdGhlIGNsaWVudCBvZmZzZXQgbmVlZCB0byBiZSByZWNhbGN1bGF0ZWQgd2hlbiB0aGUgeG1sIGlzIHJlZnJlc2hlZD9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVmcmVzaFhtbF8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoWG1sXygpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB0aGlzLnJlcXVlc3QgPSB0aGlzLmhsc18ueGhyKHtcbiAgICAgICAgdXJpOiB0aGlzLnNyY1VybCxcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0aGlzLndpdGhDcmVkZW50aWFsc1xuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yLCByZXEpIHtcbiAgICAgICAgLy8gZGlzcG9zZWRcbiAgICAgICAgaWYgKCFfdGhpczUucmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBsb2FkZXIncyByZXF1ZXN0IHJlZmVyZW5jZVxuICAgICAgICBfdGhpczUucmVxdWVzdCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgX3RoaXM1LmVycm9yID0ge1xuICAgICAgICAgICAgc3RhdHVzOiByZXEuc3RhdHVzLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0RBU0ggcGxheWxpc3QgcmVxdWVzdCBlcnJvciBhdCBVUkw6ICcgKyBfdGhpczUuc3JjVXJsLFxuICAgICAgICAgICAgcmVzcG9uc2VUZXh0OiByZXEucmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgLy8gTUVESUFfRVJSX05FVFdPUktcbiAgICAgICAgICAgIGNvZGU6IDJcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChfdGhpczUuc3RhdGUgPT09ICdIQVZFX05PVEhJTkcnKSB7XG4gICAgICAgICAgICBfdGhpczUuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3RoaXM1LnRyaWdnZXIoJ2Vycm9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczUubWFzdGVyWG1sXyA9IHJlcS5yZXNwb25zZVRleHQ7XG5cbiAgICAgICAgdmFyIG5ld01hc3RlciA9IF90aGlzNS5wYXJzZU1hc3RlclhtbCgpO1xuXG4gICAgICAgIF90aGlzNS5tYXN0ZXIgPSB1cGRhdGVNYXN0ZXIkMShfdGhpczUubWFzdGVyLCBuZXdNYXN0ZXIpO1xuXG4gICAgICAgIHdpbmRvdyQxLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNS50cmlnZ2VyKCdtaW5pbXVtVXBkYXRlUGVyaW9kJyk7XG4gICAgICAgIH0sIF90aGlzNS5tYXN0ZXIubWluaW11bVVwZGF0ZVBlcmlvZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIG1lZGlhIHBsYXlsaXN0IGJ5IHJlLXBhcnNpbmcgdGhlIG1hc3RlciB4bWwgYW5kIHVwZGF0aW5nIHBsYXlsaXN0XG4gICAgICogcmVmZXJlbmNlcy4gSWYgdGhpcyBpcyBhbiBhbHRlcm5hdGUgbG9hZGVyLCB0aGUgdXBkYXRlZCBwYXJzZWQgbWFuaWZlc3QgaXMgcmV0cmlldmVkXG4gICAgICogZnJvbSB0aGUgbWFzdGVyIGxvYWRlci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVmcmVzaE1lZGlhXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2hNZWRpYV8oKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdmFyIG9sZE1hc3RlciA9IHZvaWQgMDtcbiAgICAgIHZhciBuZXdNYXN0ZXIgPSB2b2lkIDA7XG5cbiAgICAgIGlmICh0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXykge1xuICAgICAgICBvbGRNYXN0ZXIgPSB0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5tYXN0ZXI7XG4gICAgICAgIG5ld01hc3RlciA9IHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLnBhcnNlTWFzdGVyWG1sKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGRNYXN0ZXIgPSB0aGlzLm1hc3RlcjtcbiAgICAgICAgbmV3TWFzdGVyID0gdGhpcy5wYXJzZU1hc3RlclhtbCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlZE1hc3RlciA9IHVwZGF0ZU1hc3RlciQxKG9sZE1hc3RlciwgbmV3TWFzdGVyKTtcblxuICAgICAgaWYgKHVwZGF0ZWRNYXN0ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfKSB7XG4gICAgICAgICAgdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWFzdGVyID0gdXBkYXRlZE1hc3RlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1hc3RlciA9IHVwZGF0ZWRNYXN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWRpYV8gPSB1cGRhdGVkTWFzdGVyLnBsYXlsaXN0c1t0aGlzLm1lZGlhXy51cmldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwbGF5bGlzdHVuY2hhbmdlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMubWVkaWEoKS5lbmRMaXN0KSB7XG4gICAgICAgIHRoaXMubWVkaWFVcGRhdGVUaW1lb3V0ID0gd2luZG93JDEuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM2LnRyaWdnZXIoJ21lZGlhdXBkYXRldGltZW91dCcpO1xuICAgICAgICB9LCByZWZyZXNoRGVsYXkodGhpcy5tZWRpYSgpLCAhIXVwZGF0ZWRNYXN0ZXIpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmlnZ2VyKCdsb2FkZWRwbGF5bGlzdCcpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRGFzaFBsYXlsaXN0TG9hZGVyO1xufShFdmVudFRhcmdldCQxJDEpO1xuXG52YXIgbG9nZ2VyID0gZnVuY3Rpb24gbG9nZ2VyKHNvdXJjZSkge1xuICBpZiAodmlkZW9qcyQxLmxvZy5kZWJ1Zykge1xuICAgIHJldHVybiB2aWRlb2pzJDEubG9nLmRlYnVnLmJpbmQodmlkZW9qcyQxLCAnVkhTOicsIHNvdXJjZSArICcgPicpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xufTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8qKlxuICogQGZpbGUgc291cmNlLXVwZGF0ZXIuanNcbiAqL1xuXG4vKipcbiAqIEEgcXVldWUgb2YgY2FsbGJhY2tzIHRvIGJlIHNlcmlhbGl6ZWQgYW5kIGFwcGxpZWQgd2hlbiBhXG4gKiBNZWRpYVNvdXJjZSBhbmQgaXRzIGFzc29jaWF0ZWQgU291cmNlQnVmZmVycyBhcmUgbm90IGluIHRoZVxuICogdXBkYXRpbmcgc3RhdGUuIEl0IGlzIHVzZWQgYnkgdGhlIHNlZ21lbnQgbG9hZGVyIHRvIHVwZGF0ZSB0aGVcbiAqIHVuZGVybHlpbmcgU291cmNlQnVmZmVycyB3aGVuIG5ldyBkYXRhIGlzIGxvYWRlZCwgZm9yIGluc3RhbmNlLlxuICpcbiAqIEBjbGFzcyBTb3VyY2VVcGRhdGVyXG4gKiBAcGFyYW0ge01lZGlhU291cmNlfSBtZWRpYVNvdXJjZSB0aGUgTWVkaWFTb3VyY2UgdG8gY3JlYXRlIHRoZVxuICogU291cmNlQnVmZmVyIGZyb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZSB0aGUgZGVzaXJlZCBNSU1FIHR5cGUgb2YgdGhlIHVuZGVybHlpbmdcbiAqIFNvdXJjZUJ1ZmZlclxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZUJ1ZmZlckVtaXR0ZXIgYW4gZXZlbnQgZW1pdHRlciB0aGF0IGZpcmVzIHdoZW4gYSBzb3VyY2UgYnVmZmVyIGlzXG4gKiBhZGRlZCB0byB0aGUgbWVkaWEgc291cmNlXG4gKi9cblxudmFyIFNvdXJjZVVwZGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNvdXJjZVVwZGF0ZXIobWVkaWFTb3VyY2UsIG1pbWVUeXBlLCB0eXBlLCBzb3VyY2VCdWZmZXJFbWl0dGVyKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2skMSh0aGlzLCBTb3VyY2VVcGRhdGVyKTtcblxuICAgIHRoaXMuY2FsbGJhY2tzXyA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0NhbGxiYWNrXyA9IG51bGw7XG4gICAgdGhpcy50aW1lc3RhbXBPZmZzZXRfID0gMDtcbiAgICB0aGlzLm1lZGlhU291cmNlID0gbWVkaWFTb3VyY2U7XG4gICAgdGhpcy5wcm9jZXNzZWRBcHBlbmRfID0gZmFsc2U7XG4gICAgdGhpcy50eXBlXyA9IHR5cGU7XG4gICAgdGhpcy5taW1lVHlwZV8gPSBtaW1lVHlwZTtcbiAgICB0aGlzLmxvZ2dlcl8gPSBsb2dnZXIoJ1NvdXJjZVVwZGF0ZXJbJyArIHR5cGUgKyAnXVsnICsgbWltZVR5cGUgKyAnXScpO1xuXG4gICAgaWYgKG1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICBtZWRpYVNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5jcmVhdGVTb3VyY2VCdWZmZXJfLmJpbmQodGhpcywgbWltZVR5cGUsIHNvdXJjZUJ1ZmZlckVtaXR0ZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcmVhdGVTb3VyY2VCdWZmZXJfKG1pbWVUeXBlLCBzb3VyY2VCdWZmZXJFbWl0dGVyKTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGVDbGFzcyQxKFNvdXJjZVVwZGF0ZXIsIFt7XG4gICAga2V5OiAnY3JlYXRlU291cmNlQnVmZmVyXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVNvdXJjZUJ1ZmZlcl8obWltZVR5cGUsIHNvdXJjZUJ1ZmZlckVtaXR0ZXIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc291cmNlQnVmZmVyXyA9IHRoaXMubWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKG1pbWVUeXBlKTtcblxuICAgICAgdGhpcy5sb2dnZXJfKCdjcmVhdGVkIFNvdXJjZUJ1ZmZlcicpO1xuXG4gICAgICBpZiAoc291cmNlQnVmZmVyRW1pdHRlcikge1xuICAgICAgICBzb3VyY2VCdWZmZXJFbWl0dGVyLnRyaWdnZXIoJ3NvdXJjZWJ1ZmZlcmFkZGVkJyk7XG5cbiAgICAgICAgaWYgKHRoaXMubWVkaWFTb3VyY2Uuc291cmNlQnVmZmVycy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgLy8gVGhlcmUncyBhbm90aGVyIHNvdXJjZSBidWZmZXIgd2UgbXVzdCB3YWl0IGZvciBiZWZvcmUgd2UgY2FuIHN0YXJ0IHVwZGF0aW5nXG4gICAgICAgICAgLy8gb3VyIG93biAob3IgZWxzZSB3ZSBjYW4gZ2V0IGludG8gYSBiYWQgc3RhdGUsIGkuZS4sIGFwcGVuZGluZyB2aWRlby9hdWRpbyBkYXRhXG4gICAgICAgICAgLy8gYmVmb3JlIHRoZSBvdGhlciB2aWRlby9hdWRpbyBzb3VyY2UgYnVmZmVyIGlzIGF2YWlsYWJsZSBhbmQgbGVhZGluZyB0byBhIHZpZGVvXG4gICAgICAgICAgLy8gb3IgYXVkaW8gb25seSBidWZmZXIpLlxuICAgICAgICAgIHNvdXJjZUJ1ZmZlckVtaXR0ZXIub24oJ3NvdXJjZWJ1ZmZlcmFkZGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc3RhcnRfKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhcnRfKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RhcnRfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRfKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc3RhcnRlZF8gPSB0cnVlO1xuXG4gICAgICAvLyBydW4gY29tcGxldGlvbiBoYW5kbGVycyBhbmQgcHJvY2VzcyBjYWxsYmFja3MgYXMgdXBkYXRlZW5kXG4gICAgICAvLyBldmVudHMgZmlyZVxuICAgICAgdGhpcy5vblVwZGF0ZWVuZENhbGxiYWNrXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBlbmRpbmdDYWxsYmFjayA9IF90aGlzMi5wZW5kaW5nQ2FsbGJhY2tfO1xuXG4gICAgICAgIF90aGlzMi5wZW5kaW5nQ2FsbGJhY2tfID0gbnVsbDtcblxuICAgICAgICBfdGhpczIubG9nZ2VyXygnYnVmZmVyZWQgWycgKyBwcmludGFibGVSYW5nZShfdGhpczIuYnVmZmVyZWQoKSkgKyAnXScpO1xuXG4gICAgICAgIGlmIChwZW5kaW5nQ2FsbGJhY2spIHtcbiAgICAgICAgICBwZW5kaW5nQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi5ydW5DYWxsYmFja18oKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuc291cmNlQnVmZmVyXy5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLm9uVXBkYXRlZW5kQ2FsbGJhY2tfKTtcblxuICAgICAgdGhpcy5ydW5DYWxsYmFja18oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBYm9ydHMgdGhlIGN1cnJlbnQgc2VnbWVudCBhbmQgcmVzZXRzIHRoZSBzZWdtZW50IHBhcnNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGRvbmVcbiAgICAgKiBAc2VlIGh0dHA6Ly93M2MuZ2l0aHViLmlvL21lZGlhLXNvdXJjZS8jd2lkbC1Tb3VyY2VCdWZmZXItYWJvcnQtdm9pZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhYm9ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KGRvbmUpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5wcm9jZXNzZWRBcHBlbmRfKSB7XG4gICAgICAgIHRoaXMucXVldWVDYWxsYmFja18oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMy5zb3VyY2VCdWZmZXJfLmFib3J0KCk7XG4gICAgICAgIH0sIGRvbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFF1ZXVlIGFuIHVwZGF0ZSB0byBhcHBlbmQgYW4gQXJyYXlCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBieXRlc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgdGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBkb25lXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3dpZGwtU291cmNlQnVmZmVyLWFwcGVuZEJ1ZmZlci12b2lkLUFycmF5QnVmZmVyLWRhdGFcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXBwZW5kQnVmZmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kQnVmZmVyKGJ5dGVzLCBkb25lKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdGhpcy5wcm9jZXNzZWRBcHBlbmRfID0gdHJ1ZTtcbiAgICAgIHRoaXMucXVldWVDYWxsYmFja18oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczQuc291cmNlQnVmZmVyXy5hcHBlbmRCdWZmZXIoYnl0ZXMpO1xuICAgICAgfSwgZG9uZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoYXQgVGltZVJhbmdlcyBhcmUgYnVmZmVyZWQgaW4gdGhlIG1hbmFnZWQgU291cmNlQnVmZmVyLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3dpZGwtU291cmNlQnVmZmVyLWJ1ZmZlcmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2J1ZmZlcmVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVmZmVyZWQoKSB7XG4gICAgICBpZiAoIXRoaXMuc291cmNlQnVmZmVyXykge1xuICAgICAgICByZXR1cm4gdmlkZW9qcyQxLmNyZWF0ZVRpbWVSYW5nZXMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZUJ1ZmZlcl8uYnVmZmVyZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVldWUgYW4gdXBkYXRlIHRvIHJlbW92ZSBhIHRpbWUgcmFuZ2UgZnJvbSB0aGUgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHdoZXJlIHRvIHN0YXJ0IHRoZSByZW1vdmFsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCB3aGVyZSB0byBlbmQgdGhlIHJlbW92YWxcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jd2lkbC1Tb3VyY2VCdWZmZXItcmVtb3ZlLXZvaWQtZG91YmxlLXN0YXJ0LXVucmVzdHJpY3RlZC1kb3VibGUtZW5kXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkQXBwZW5kXykge1xuICAgICAgICB0aGlzLnF1ZXVlQ2FsbGJhY2tfKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczUubG9nZ2VyXygncmVtb3ZlIFsnICsgc3RhcnQgKyAnID0+ICcgKyBlbmQgKyAnXScpO1xuICAgICAgICAgIF90aGlzNS5zb3VyY2VCdWZmZXJfLnJlbW92ZShzdGFydCwgZW5kKTtcbiAgICAgICAgfSwgbm9vcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgdW5kZXJseWluZyBzb3VyY2VCdWZmZXIgaXMgdXBkYXRpbmcgb3Igbm90XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0aGUgdXBkYXRpbmcgc3RhdHVzIG9mIHRoZSBTb3VyY2VCdWZmZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGluZygpIHtcbiAgICAgIHJldHVybiAhdGhpcy5zb3VyY2VCdWZmZXJfIHx8IHRoaXMuc291cmNlQnVmZmVyXy51cGRhdGluZyB8fCB0aGlzLnBlbmRpbmdDYWxsYmFja187XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0L2dldCB0aGUgdGltZXN0YW1wb2Zmc2V0IG9uIHRoZSBTb3VyY2VCdWZmZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gdGhlIHRpbWVzdGFtcCBvZmZzZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndGltZXN0YW1wT2Zmc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGltZXN0YW1wT2Zmc2V0KG9mZnNldCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnF1ZXVlQ2FsbGJhY2tfKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczYuc291cmNlQnVmZmVyXy50aW1lc3RhbXBPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcE9mZnNldF8gPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXBPZmZzZXRfO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFF1ZXVlIGEgY2FsbGJhY2sgdG8gcnVuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3F1ZXVlQ2FsbGJhY2tfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcXVldWVDYWxsYmFja18oY2FsbGJhY2ssIGRvbmUpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzXy5wdXNoKFtjYWxsYmFjay5iaW5kKHRoaXMpLCBkb25lXSk7XG4gICAgICB0aGlzLnJ1bkNhbGxiYWNrXygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1biBhIHF1ZXVlZCBjYWxsYmFja1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdydW5DYWxsYmFja18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW5DYWxsYmFja18oKSB7XG4gICAgICB2YXIgY2FsbGJhY2tzID0gdm9pZCAwO1xuXG4gICAgICBpZiAoIXRoaXMudXBkYXRpbmcoKSAmJiB0aGlzLmNhbGxiYWNrc18ubGVuZ3RoICYmIHRoaXMuc3RhcnRlZF8pIHtcbiAgICAgICAgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3NfLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0NhbGxiYWNrXyA9IGNhbGxiYWNrc1sxXTtcbiAgICAgICAgY2FsbGJhY2tzWzBdKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZGlzcG9zZSBvZiB0aGUgc291cmNlIHVwZGF0ZXIgYW5kIHRoZSB1bmRlcmx5aW5nIHNvdXJjZUJ1ZmZlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXNwb3NlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuc291cmNlQnVmZmVyXy5yZW1vdmVFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLm9uVXBkYXRlZW5kQ2FsbGJhY2tfKTtcbiAgICAgIGlmICh0aGlzLnNvdXJjZUJ1ZmZlcl8gJiYgdGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJfLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTb3VyY2VVcGRhdGVyO1xufSgpO1xuXG52YXIgQ29uZmlnID0ge1xuICBHT0FMX0JVRkZFUl9MRU5HVEg6IDMwLFxuICBNQVhfR09BTF9CVUZGRVJfTEVOR1RIOiA2MCxcbiAgR09BTF9CVUZGRVJfTEVOR1RIX1JBVEU6IDEsXG4gIC8vIEEgZnVkZ2UgZmFjdG9yIHRvIGFwcGx5IHRvIGFkdmVydGlzZWQgcGxheWxpc3QgYml0cmF0ZXMgdG8gYWNjb3VudCBmb3JcbiAgLy8gdGVtcG9yYXJ5IGZsdWNhdGlvbnMgaW4gY2xpZW50IGJhbmR3aWR0aFxuICBCQU5EV0lEVEhfVkFSSUFOQ0U6IDEuMixcbiAgLy8gSG93IG11Y2ggb2YgdGhlIGJ1ZmZlciBtdXN0IGJlIGZpbGxlZCBiZWZvcmUgd2UgY29uc2lkZXIgdXBzd2l0Y2hpbmdcbiAgQlVGRkVSX0xPV19XQVRFUl9MSU5FOiAwLFxuICBNQVhfQlVGRkVSX0xPV19XQVRFUl9MSU5FOiAzMCxcbiAgQlVGRkVSX0xPV19XQVRFUl9MSU5FX1JBVEU6IDFcbn07XG5cbnZhciBSRVFVRVNUX0VSUk9SUyA9IHtcbiAgRkFJTFVSRTogMixcbiAgVElNRU9VVDogLTEwMSxcbiAgQUJPUlRFRDogLTEwMlxufTtcblxuLyoqXG4gKiBUdXJucyBzZWdtZW50IGJ5dGVyYW5nZSBpbnRvIGEgc3RyaW5nIHN1aXRhYmxlIGZvciB1c2UgaW5cbiAqIEhUVFAgUmFuZ2UgcmVxdWVzdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYnl0ZXJhbmdlIC0gYW4gb2JqZWN0IHdpdGggdHdvIHZhbHVlcyBkZWZpbmluZyB0aGUgc3RhcnQgYW5kIGVuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGEgYnl0ZS1yYW5nZVxuICovXG52YXIgYnl0ZXJhbmdlU3RyID0gZnVuY3Rpb24gYnl0ZXJhbmdlU3RyKGJ5dGVyYW5nZSkge1xuICB2YXIgYnl0ZXJhbmdlU3RhcnQgPSB2b2lkIDA7XG4gIHZhciBieXRlcmFuZ2VFbmQgPSB2b2lkIDA7XG5cbiAgLy8gYGJ5dGVyYW5nZUVuZGAgaXMgb25lIGxlc3MgdGhhbiBgb2Zmc2V0ICsgbGVuZ3RoYCBiZWNhdXNlIHRoZSBIVFRQIHJhbmdlXG4gIC8vIGhlYWRlciB1c2VzIGluY2x1c2l2ZSByYW5nZXNcbiAgYnl0ZXJhbmdlRW5kID0gYnl0ZXJhbmdlLm9mZnNldCArIGJ5dGVyYW5nZS5sZW5ndGggLSAxO1xuICBieXRlcmFuZ2VTdGFydCA9IGJ5dGVyYW5nZS5vZmZzZXQ7XG4gIHJldHVybiAnYnl0ZXM9JyArIGJ5dGVyYW5nZVN0YXJ0ICsgJy0nICsgYnl0ZXJhbmdlRW5kO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGhlYWRlcnMgZm9yIHVzZSBpbiB0aGUgeGhyIHJlcXVlc3QgZm9yIGEgcGFydGljdWxhciBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWdtZW50IC0gYSBzaW1wbGlmaWVkIGNvcHkgb2YgdGhlIHNlZ21lbnRJbmZvIG9iamVjdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIFNlZ21lbnRMb2FkZXJcbiAqL1xudmFyIHNlZ21lbnRYaHJIZWFkZXJzID0gZnVuY3Rpb24gc2VnbWVudFhockhlYWRlcnMoc2VnbWVudCkge1xuICB2YXIgaGVhZGVycyA9IHt9O1xuXG4gIGlmIChzZWdtZW50LmJ5dGVyYW5nZSkge1xuICAgIGhlYWRlcnMuUmFuZ2UgPSBieXRlcmFuZ2VTdHIoc2VnbWVudC5ieXRlcmFuZ2UpO1xuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufTtcblxuLyoqXG4gKiBBYm9ydCBhbGwgcmVxdWVzdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aXZlWGhycyAtIGFuIG9iamVjdCB0aGF0IHRyYWNrcyBhbGwgWEhSIHJlcXVlc3RzXG4gKi9cbnZhciBhYm9ydEFsbCA9IGZ1bmN0aW9uIGFib3J0QWxsKGFjdGl2ZVhocnMpIHtcbiAgYWN0aXZlWGhycy5mb3JFYWNoKGZ1bmN0aW9uICh4aHIkJDEpIHtcbiAgICB4aHIkJDEuYWJvcnQoKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdhdGhlciBpbXBvcnRhbnQgYmFuZHdpZHRoIHN0YXRzIG9uY2UgYSByZXF1ZXN0IGhhcyBjb21wbGV0ZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCAtIHRoZSBYSFIgcmVxdWVzdCBmcm9tIHdoaWNoIHRvIGdhdGhlciBzdGF0c1xuICovXG52YXIgZ2V0UmVxdWVzdFN0YXRzID0gZnVuY3Rpb24gZ2V0UmVxdWVzdFN0YXRzKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHtcbiAgICBiYW5kd2lkdGg6IHJlcXVlc3QuYmFuZHdpZHRoLFxuICAgIGJ5dGVzUmVjZWl2ZWQ6IHJlcXVlc3QuYnl0ZXNSZWNlaXZlZCB8fCAwLFxuICAgIHJvdW5kVHJpcFRpbWU6IHJlcXVlc3Qucm91bmRUcmlwVGltZSB8fCAwXG4gIH07XG59O1xuXG4vKipcbiAqIElmIHBvc3NpYmxlIGdhdGhlciBiYW5kd2lkdGggc3RhdHMgYXMgYSByZXF1ZXN0IGlzIGluXG4gKiBwcm9ncmVzc1xuICpcbiAqIEBwYXJhbSB7RXZlbnR9IHByb2dyZXNzRXZlbnQgLSBhbiBldmVudCBvYmplY3QgZnJvbSBhbiBYSFIncyBwcm9ncmVzcyBldmVudFxuICovXG52YXIgZ2V0UHJvZ3Jlc3NTdGF0cyA9IGZ1bmN0aW9uIGdldFByb2dyZXNzU3RhdHMocHJvZ3Jlc3NFdmVudCkge1xuICB2YXIgcmVxdWVzdCA9IHByb2dyZXNzRXZlbnQudGFyZ2V0O1xuICB2YXIgcm91bmRUcmlwVGltZSA9IERhdGUubm93KCkgLSByZXF1ZXN0LnJlcXVlc3RUaW1lO1xuICB2YXIgc3RhdHMgPSB7XG4gICAgYmFuZHdpZHRoOiBJbmZpbml0eSxcbiAgICBieXRlc1JlY2VpdmVkOiAwLFxuICAgIHJvdW5kVHJpcFRpbWU6IHJvdW5kVHJpcFRpbWUgfHwgMFxuICB9O1xuXG4gIHN0YXRzLmJ5dGVzUmVjZWl2ZWQgPSBwcm9ncmVzc0V2ZW50LmxvYWRlZDtcbiAgLy8gVGhpcyBjYW4gcmVzdWx0IGluIEluZmluaXR5IGlmIHN0YXRzLnJvdW5kVHJpcFRpbWUgaXMgMCBidXQgdGhhdCBpcyBva1xuICAvLyBiZWNhdXNlIHdlIHNob3VsZCBvbmx5IHVzZSBiYW5kd2lkdGggc3RhdHMgb24gcHJvZ3Jlc3MgdG8gZGV0ZXJtaW5lIHdoZW5cbiAgLy8gYWJvcnQgYSByZXF1ZXN0IGVhcmx5IGR1ZSB0byBpbnN1ZmZpY2llbnQgYmFuZHdpZHRoXG4gIHN0YXRzLmJhbmR3aWR0aCA9IE1hdGguZmxvb3Ioc3RhdHMuYnl0ZXNSZWNlaXZlZCAvIHN0YXRzLnJvdW5kVHJpcFRpbWUgKiA4ICogMTAwMCk7XG5cbiAgcmV0dXJuIHN0YXRzO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgYWxsIGVycm9yIGNvbmRpdGlvbnMgaW4gb25lIHBsYWNlIGFuZCByZXR1cm4gYW4gb2JqZWN0XG4gKiB3aXRoIGFsbCB0aGUgaW5mb3JtYXRpb25cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIC0gaWYgbm9uLW51bGwgc2lnbmFscyBhbiBlcnJvciBvY2N1cmVkIHdpdGggdGhlIFhIUlxuICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgLSAgdGhlIFhIUiByZXF1ZXN0IHRoYXQgcG9zc2libHkgZ2VuZXJhdGVkIHRoZSBlcnJvclxuICovXG52YXIgaGFuZGxlRXJyb3JzID0gZnVuY3Rpb24gaGFuZGxlRXJyb3JzKGVycm9yLCByZXF1ZXN0KSB7XG4gIGlmIChyZXF1ZXN0LnRpbWVkb3V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICBtZXNzYWdlOiAnSExTIHJlcXVlc3QgdGltZWQtb3V0IGF0IFVSTDogJyArIHJlcXVlc3QudXJpLFxuICAgICAgY29kZTogUkVRVUVTVF9FUlJPUlMuVElNRU9VVCxcbiAgICAgIHhocjogcmVxdWVzdFxuICAgIH07XG4gIH1cblxuICBpZiAocmVxdWVzdC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICBtZXNzYWdlOiAnSExTIHJlcXVlc3QgYWJvcnRlZCBhdCBVUkw6ICcgKyByZXF1ZXN0LnVyaSxcbiAgICAgIGNvZGU6IFJFUVVFU1RfRVJST1JTLkFCT1JURUQsXG4gICAgICB4aHI6IHJlcXVlc3RcbiAgICB9O1xuICB9XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICBtZXNzYWdlOiAnSExTIHJlcXVlc3QgZXJyb3JlZCBhdCBVUkw6ICcgKyByZXF1ZXN0LnVyaSxcbiAgICAgIGNvZGU6IFJFUVVFU1RfRVJST1JTLkZBSUxVUkUsXG4gICAgICB4aHI6IHJlcXVlc3RcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEhhbmRsZSByZXNwb25zZXMgZm9yIGtleSBkYXRhIGFuZCBjb252ZXJ0IHRoZSBrZXkgZGF0YSB0byB0aGUgY29ycmVjdCBmb3JtYXRcbiAqIGZvciB0aGUgZGVjcnlwdGlvbiBzdGVwIGxhdGVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNlZ21lbnQgLSBhIHNpbXBsaWZpZWQgY29weSBvZiB0aGUgc2VnbWVudEluZm8gb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gU2VnbWVudExvYWRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZmluaXNoUHJvY2Vzc2luZ0ZuIC0gYSBjYWxsYmFjayB0byBleGVjdXRlIHRvIGNvbnRpbnVlIHByb2Nlc3NpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgcmVxdWVzdFxuICovXG52YXIgaGFuZGxlS2V5UmVzcG9uc2UgPSBmdW5jdGlvbiBoYW5kbGVLZXlSZXNwb25zZShzZWdtZW50LCBmaW5pc2hQcm9jZXNzaW5nRm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgcmVxdWVzdCkge1xuICAgIHZhciByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgdmFyIGVycm9yT2JqID0gaGFuZGxlRXJyb3JzKGVycm9yLCByZXF1ZXN0KTtcblxuICAgIGlmIChlcnJvck9iaikge1xuICAgICAgcmV0dXJuIGZpbmlzaFByb2Nlc3NpbmdGbihlcnJvck9iaiwgc2VnbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICByZXR1cm4gZmluaXNoUHJvY2Vzc2luZ0ZuKHtcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgSExTIGtleSBhdCBVUkw6ICcgKyByZXF1ZXN0LnVyaSxcbiAgICAgICAgY29kZTogUkVRVUVTVF9FUlJPUlMuRkFJTFVSRSxcbiAgICAgICAgeGhyOiByZXF1ZXN0XG4gICAgICB9LCBzZWdtZW50KTtcbiAgICB9XG5cbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhyZXNwb25zZSk7XG5cbiAgICBzZWdtZW50LmtleS5ieXRlcyA9IG5ldyBVaW50MzJBcnJheShbdmlldy5nZXRVaW50MzIoMCksIHZpZXcuZ2V0VWludDMyKDQpLCB2aWV3LmdldFVpbnQzMig4KSwgdmlldy5nZXRVaW50MzIoMTIpXSk7XG4gICAgcmV0dXJuIGZpbmlzaFByb2Nlc3NpbmdGbihudWxsLCBzZWdtZW50KTtcbiAgfTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGluaXQtc2VnbWVudCByZXNwb25zZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudCAtIGEgc2ltcGxpZmllZCBjb3B5IG9mIHRoZSBzZWdtZW50SW5mbyBvYmplY3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSBTZWdtZW50TG9hZGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5pc2hQcm9jZXNzaW5nRm4gLSBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgdG8gY29udGludWUgcHJvY2Vzc2luZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyByZXF1ZXN0XG4gKi9cbnZhciBoYW5kbGVJbml0U2VnbWVudFJlc3BvbnNlID0gZnVuY3Rpb24gaGFuZGxlSW5pdFNlZ21lbnRSZXNwb25zZShzZWdtZW50LCBmaW5pc2hQcm9jZXNzaW5nRm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgcmVxdWVzdCkge1xuICAgIHZhciByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgdmFyIGVycm9yT2JqID0gaGFuZGxlRXJyb3JzKGVycm9yLCByZXF1ZXN0KTtcblxuICAgIGlmIChlcnJvck9iaikge1xuICAgICAgcmV0dXJuIGZpbmlzaFByb2Nlc3NpbmdGbihlcnJvck9iaiwgc2VnbWVudCk7XG4gICAgfVxuXG4gICAgLy8gc3RvcCBwcm9jZXNzaW5nIGlmIHJlY2VpdmVkIGVtcHR5IGNvbnRlbnRcbiAgICBpZiAocmVzcG9uc2UuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZpbmlzaFByb2Nlc3NpbmdGbih7XG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIG1lc3NhZ2U6ICdFbXB0eSBITFMgc2VnbWVudCBjb250ZW50IGF0IFVSTDogJyArIHJlcXVlc3QudXJpLFxuICAgICAgICBjb2RlOiBSRVFVRVNUX0VSUk9SUy5GQUlMVVJFLFxuICAgICAgICB4aHI6IHJlcXVlc3RcbiAgICAgIH0sIHNlZ21lbnQpO1xuICAgIH1cblxuICAgIHNlZ21lbnQubWFwLmJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgcmV0dXJuIGZpbmlzaFByb2Nlc3NpbmdGbihudWxsLCBzZWdtZW50KTtcbiAgfTtcbn07XG5cbi8qKlxuICogUmVzcG9uc2UgaGFuZGxlciBmb3Igc2VnbWVudC1yZXF1ZXN0cyBiZWluZyBzdXJlIHRvIHNldCB0aGUgY29ycmVjdFxuICogcHJvcGVydHkgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIHNlZ21lbnQgaXMgZW5jcnlwZWQgb3Igbm90XG4gKiBBbHNvIHJlY29yZHMgYW5kIGtlZXBzIHRyYWNrIG9mIHN0YXRzIHRoYXQgYXJlIHVzZWQgZm9yIEFCUiBwdXJwb3Nlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWdtZW50IC0gYSBzaW1wbGlmaWVkIGNvcHkgb2YgdGhlIHNlZ21lbnRJbmZvIG9iamVjdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIFNlZ21lbnRMb2FkZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmlzaFByb2Nlc3NpbmdGbiAtIGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB0byBjb250aW51ZSBwcm9jZXNzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHJlcXVlc3RcbiAqL1xudmFyIGhhbmRsZVNlZ21lbnRSZXNwb25zZSA9IGZ1bmN0aW9uIGhhbmRsZVNlZ21lbnRSZXNwb25zZShzZWdtZW50LCBmaW5pc2hQcm9jZXNzaW5nRm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgcmVxdWVzdCkge1xuICAgIHZhciByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgdmFyIGVycm9yT2JqID0gaGFuZGxlRXJyb3JzKGVycm9yLCByZXF1ZXN0KTtcblxuICAgIGlmIChlcnJvck9iaikge1xuICAgICAgcmV0dXJuIGZpbmlzaFByb2Nlc3NpbmdGbihlcnJvck9iaiwgc2VnbWVudCk7XG4gICAgfVxuXG4gICAgLy8gc3RvcCBwcm9jZXNzaW5nIGlmIHJlY2VpdmVkIGVtcHR5IGNvbnRlbnRcbiAgICBpZiAocmVzcG9uc2UuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZpbmlzaFByb2Nlc3NpbmdGbih7XG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIG1lc3NhZ2U6ICdFbXB0eSBITFMgc2VnbWVudCBjb250ZW50IGF0IFVSTDogJyArIHJlcXVlc3QudXJpLFxuICAgICAgICBjb2RlOiBSRVFVRVNUX0VSUk9SUy5GQUlMVVJFLFxuICAgICAgICB4aHI6IHJlcXVlc3RcbiAgICAgIH0sIHNlZ21lbnQpO1xuICAgIH1cblxuICAgIHNlZ21lbnQuc3RhdHMgPSBnZXRSZXF1ZXN0U3RhdHMocmVxdWVzdCk7XG5cbiAgICBpZiAoc2VnbWVudC5rZXkpIHtcbiAgICAgIHNlZ21lbnQuZW5jcnlwdGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VnbWVudC5ieXRlcyA9IG5ldyBVaW50OEFycmF5KHJlcXVlc3QucmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBmaW5pc2hQcm9jZXNzaW5nRm4obnVsbCwgc2VnbWVudCk7XG4gIH07XG59O1xuXG4vKipcbiAqIERlY3J5cHQgdGhlIHNlZ21lbnQgdmlhIHRoZSBkZWNyeXB0aW9uIHdlYiB3b3JrZXJcbiAqXG4gKiBAcGFyYW0ge1dlYldvcmtlcn0gZGVjcnlwdGVyIC0gYSBXZWJXb3JrZXIgaW50ZXJmYWNlIHRvIEFFUy0xMjggZGVjcnlwdGlvbiByb3V0aW5lc1xuICogQHBhcmFtIHtPYmplY3R9IHNlZ21lbnQgLSBhIHNpbXBsaWZpZWQgY29weSBvZiB0aGUgc2VnbWVudEluZm8gb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gU2VnbWVudExvYWRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZUZuIC0gYSBjYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIGFmdGVyIGRlY3J5cHRpb24gaGFzIGNvbXBsZXRlZFxuICovXG52YXIgZGVjcnlwdFNlZ21lbnQgPSBmdW5jdGlvbiBkZWNyeXB0U2VnbWVudChkZWNyeXB0ZXIsIHNlZ21lbnQsIGRvbmVGbikge1xuICB2YXIgZGVjcnlwdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiBkZWNyeXB0aW9uSGFuZGxlcihldmVudCkge1xuICAgIGlmIChldmVudC5kYXRhLnNvdXJjZSA9PT0gc2VnbWVudC5yZXF1ZXN0SWQpIHtcbiAgICAgIGRlY3J5cHRlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZGVjcnlwdGlvbkhhbmRsZXIpO1xuICAgICAgdmFyIGRlY3J5cHRlZCA9IGV2ZW50LmRhdGEuZGVjcnlwdGVkO1xuXG4gICAgICBzZWdtZW50LmJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkLmJ5dGVzLCBkZWNyeXB0ZWQuYnl0ZU9mZnNldCwgZGVjcnlwdGVkLmJ5dGVMZW5ndGgpO1xuICAgICAgcmV0dXJuIGRvbmVGbihudWxsLCBzZWdtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgZGVjcnlwdGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBkZWNyeXB0aW9uSGFuZGxlcik7XG5cbiAgLy8gdGhpcyBpcyBhbiBlbmNyeXB0ZWQgc2VnbWVudFxuICAvLyBpbmNyZW1lbnRhbGx5IGRlY3J5cHQgdGhlIHNlZ21lbnRcbiAgZGVjcnlwdGVyLnBvc3RNZXNzYWdlKGNyZWF0ZVRyYW5zZmVyYWJsZU1lc3NhZ2Uoe1xuICAgIHNvdXJjZTogc2VnbWVudC5yZXF1ZXN0SWQsXG4gICAgZW5jcnlwdGVkOiBzZWdtZW50LmVuY3J5cHRlZEJ5dGVzLFxuICAgIGtleTogc2VnbWVudC5rZXkuYnl0ZXMsXG4gICAgaXY6IHNlZ21lbnQua2V5Lml2XG4gIH0pLCBbc2VnbWVudC5lbmNyeXB0ZWRCeXRlcy5idWZmZXIsIHNlZ21lbnQua2V5LmJ5dGVzLmJ1ZmZlcl0pO1xufTtcblxuLyoqXG4gKiBUaGUgcHVycG9zZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGdldCB0aGUgbW9zdCBwZXJ0aW5lbnQgZXJyb3IgZnJvbSB0aGVcbiAqIGFycmF5IG9mIGVycm9ycy5cbiAqIEZvciBpbnN0YW5jZSBpZiBhIHRpbWVvdXQgYW5kIHR3byBhYm9ydHMgb2NjdXIsIHRoZW4gdGhlIGFib3J0cyB3ZXJlXG4gKiBsaWtlbHkgdHJpZ2dlcmVkIGJ5IHRoZSB0aW1lb3V0IHNvIHJldHVybiB0aGF0IGVycm9yIG9iamVjdC5cbiAqL1xudmFyIGdldE1vc3RJbXBvcnRhbnRFcnJvciA9IGZ1bmN0aW9uIGdldE1vc3RJbXBvcnRhbnRFcnJvcihlcnJvcnMpIHtcbiAgcmV0dXJuIGVycm9ycy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGVycikge1xuICAgIHJldHVybiBlcnIuY29kZSA+IHByZXYuY29kZSA/IGVyciA6IHByZXY7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdhaXRzIGZvciBhbGwgWEhScyB0byBmaW5pc2ggKHdpdGggZWl0aGVyIHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAqIGJlZm9yZSBjb250aW51ZWluZyBwcm9jZXNzaW5nIHZpYSBpdCdzIGNhbGxiYWNrLiBUaGUgZnVuY3Rpb24gZ2F0aGVycyBlcnJvcnNcbiAqIGZyb20gZWFjaCByZXF1ZXN0IGludG8gYSBzaW5nbGUgZXJyb3JzIGFycmF5IHNvIHRoYXQgdGhlIGVycm9yIHN0YXR1cyBmb3JcbiAqIGVhY2ggcmVxdWVzdCBjYW4gYmUgZXhhbWluZWQgbGF0ZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFjdGl2ZVhocnMgLSBhbiBvYmplY3QgdGhhdCB0cmFja3MgYWxsIFhIUiByZXF1ZXN0c1xuICogQHBhcmFtIHtXZWJXb3JrZXJ9IGRlY3J5cHRlciAtIGEgV2ViV29ya2VyIGludGVyZmFjZSB0byBBRVMtMTI4IGRlY3J5cHRpb24gcm91dGluZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVGbiAtIGEgY2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCBhZnRlciBhbGwgcmVzb3VyY2VzIGhhdmUgYmVlblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRlZCBhbmQgYW55IGRlY3J5cHRpb24gY29tcGxldGVkXG4gKi9cbnZhciB3YWl0Rm9yQ29tcGxldGlvbiA9IGZ1bmN0aW9uIHdhaXRGb3JDb21wbGV0aW9uKGFjdGl2ZVhocnMsIGRlY3J5cHRlciwgZG9uZUZuKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIGNvdW50ID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24gKGVycm9yLCBzZWdtZW50KSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgZXJyb3JzLCB3ZSBoYXZlIHRvIGFib3J0IGFueSBvdXRzdGFuZGluZyByZXF1ZXN0c1xuICAgICAgYWJvcnRBbGwoYWN0aXZlWGhycyk7XG4gICAgICBlcnJvcnMucHVzaChlcnJvcik7XG4gICAgfVxuICAgIGNvdW50ICs9IDE7XG5cbiAgICBpZiAoY291bnQgPT09IGFjdGl2ZVhocnMubGVuZ3RoKSB7XG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHdoZW4gKmFsbCogb2YgdGhlIHJlcXVlc3RzIGhhdmUgY29tcGxldGVkXG4gICAgICBzZWdtZW50LmVuZE9mQWxsUmVxdWVzdHMgPSBEYXRlLm5vdygpO1xuXG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHdvcnN0RXJyb3IgPSBnZXRNb3N0SW1wb3J0YW50RXJyb3IoZXJyb3JzKTtcblxuICAgICAgICByZXR1cm4gZG9uZUZuKHdvcnN0RXJyb3IsIHNlZ21lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHNlZ21lbnQuZW5jcnlwdGVkQnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGRlY3J5cHRTZWdtZW50KGRlY3J5cHRlciwgc2VnbWVudCwgZG9uZUZuKTtcbiAgICAgIH1cbiAgICAgIC8vIE90aGVyd2lzZSwgZXZlcnl0aGluZyBpcyByZWFkeSBqdXN0IGNvbnRpbnVlXG4gICAgICByZXR1cm4gZG9uZUZuKG51bGwsIHNlZ21lbnQpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogU2ltcGxlIHByb2dyZXNzIGV2ZW50IGNhbGxiYWNrIGhhbmRsZXIgdGhhdCBnYXRoZXJzIHNvbWUgc3RhdHMgYmVmb3JlXG4gKiBleGVjdXRpbmcgYSBwcm92aWRlZCBjYWxsYmFjayB3aXRoIHRoZSBgc2VnbWVudGAgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNlZ21lbnQgLSBhIHNpbXBsaWZpZWQgY29weSBvZiB0aGUgc2VnbWVudEluZm8gb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gU2VnbWVudExvYWRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvZ3Jlc3NGbiAtIGEgY2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCBlYWNoIHRpbWUgYSBwcm9ncmVzcyBldmVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHJlY2VpdmVkXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIHRoZSBwcm9ncmVzcyBldmVudCBvYmplY3QgZnJvbSBYTUxIdHRwUmVxdWVzdFxuICovXG52YXIgaGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiBoYW5kbGVQcm9ncmVzcyhzZWdtZW50LCBwcm9ncmVzc0ZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBzZWdtZW50LnN0YXRzID0gdmlkZW9qcyQxLm1lcmdlT3B0aW9ucyhzZWdtZW50LnN0YXRzLCBnZXRQcm9ncmVzc1N0YXRzKGV2ZW50KSk7XG5cbiAgICAvLyByZWNvcmQgdGhlIHRpbWUgdGhhdCB3ZSByZWNlaXZlIHRoZSBmaXJzdCBieXRlIG9mIGRhdGFcbiAgICBpZiAoIXNlZ21lbnQuc3RhdHMuZmlyc3RCeXRlc1JlY2VpdmVkQXQgJiYgc2VnbWVudC5zdGF0cy5ieXRlc1JlY2VpdmVkKSB7XG4gICAgICBzZWdtZW50LnN0YXRzLmZpcnN0Qnl0ZXNSZWNlaXZlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3Jlc3NGbihldmVudCwgc2VnbWVudCk7XG4gIH07XG59O1xuXG4vKipcbiAqIExvYWQgYWxsIHJlc291cmNlcyBhbmQgZG9lcyBhbnkgcHJvY2Vzc2luZyBuZWNlc3NhcnkgZm9yIGEgbWVkaWEtc2VnbWVudFxuICpcbiAqIEZlYXR1cmVzOlxuICogICBkZWNyeXB0cyB0aGUgbWVkaWEtc2VnbWVudCBpZiBpdCBoYXMgYSBrZXkgdXJpIGFuZCBhbiBpdlxuICogICBhYm9ydHMgKmFsbCogcmVxdWVzdHMgaWYgKmFueSogb25lIHJlcXVlc3QgZmFpbHNcbiAqXG4gKiBUaGUgc2VnbWVudCBvYmplY3QsIGF0IG1pbmltdW0sIGhhcyB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiAqIHtcbiAqICAgcmVzb2x2ZWRVcmk6IFN0cmluZyxcbiAqICAgW2J5dGVyYW5nZV06IHtcbiAqICAgICBvZmZzZXQ6IE51bWJlcixcbiAqICAgICBsZW5ndGg6IE51bWJlclxuICogICB9LFxuICogICBba2V5XToge1xuICogICAgIHJlc29sdmVkVXJpOiBTdHJpbmdcbiAqICAgICBbYnl0ZXJhbmdlXToge1xuICogICAgICAgb2Zmc2V0OiBOdW1iZXIsXG4gKiAgICAgICBsZW5ndGg6IE51bWJlclxuICogICAgIH0sXG4gKiAgICAgaXY6IHtcbiAqICAgICAgIGJ5dGVzOiBVaW50MzJBcnJheVxuICogICAgIH1cbiAqICAgfSxcbiAqICAgW21hcF06IHtcbiAqICAgICByZXNvbHZlZFVyaTogU3RyaW5nLFxuICogICAgIFtieXRlcmFuZ2VdOiB7XG4gKiAgICAgICBvZmZzZXQ6IE51bWJlcixcbiAqICAgICAgIGxlbmd0aDogTnVtYmVyXG4gKiAgICAgfSxcbiAqICAgICBbYnl0ZXNdOiBVaW50OEFycmF5XG4gKiAgIH1cbiAqIH1cbiAqIC4uLndoZXJlIFtuYW1lXSBkZW5vdGVzIG9wdGlvbmFsIHByb3BlcnRpZXNcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB4aHIgLSBhbiBpbnN0YW5jZSBvZiB0aGUgeGhyIHdyYXBwZXIgaW4geGhyLmpzXG4gKiBAcGFyYW0ge09iamVjdH0geGhyT3B0aW9ucyAtIHRoZSBiYXNlIG9wdGlvbnMgdG8gcHJvdmlkZSB0byBhbGwgeGhyIHJlcXVlc3RzXG4gKiBAcGFyYW0ge1dlYldvcmtlcn0gZGVjcnlwdGlvbldvcmtlciAtIGEgV2ViV29ya2VyIGludGVyZmFjZSB0byBBRVMtMTI4XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3J5cHRpb24gcm91dGluZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWdtZW50IC0gYSBzaW1wbGlmaWVkIGNvcHkgb2YgdGhlIHNlZ21lbnRJbmZvIG9iamVjdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIFNlZ21lbnRMb2FkZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb2dyZXNzRm4gLSBhIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgcHJvZ3Jlc3MgZXZlbnRzIGZyb20gdGhlIG1haW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50J3MgeGhyIHJlcXVlc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVGbiAtIGEgY2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCBvbmx5IG9uY2UgYWxsIHJlcXVlc3RzIGhhdmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2NlZWRlZCBvciBmYWlsZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGludm9rZWQsIGltbWVkaWF0ZWx5IGFib3J0cyBhbGxcbiAqICAgICAgICAgICAgICAgICAgICAgb3V0c3RhbmRpbmcgcmVxdWVzdHNcbiAqL1xudmFyIG1lZGlhU2VnbWVudFJlcXVlc3QgPSBmdW5jdGlvbiBtZWRpYVNlZ21lbnRSZXF1ZXN0KHhociQkMSwgeGhyT3B0aW9ucywgZGVjcnlwdGlvbldvcmtlciwgc2VnbWVudCwgcHJvZ3Jlc3NGbiwgZG9uZUZuKSB7XG4gIHZhciBhY3RpdmVYaHJzID0gW107XG4gIHZhciBmaW5pc2hQcm9jZXNzaW5nRm4gPSB3YWl0Rm9yQ29tcGxldGlvbihhY3RpdmVYaHJzLCBkZWNyeXB0aW9uV29ya2VyLCBkb25lRm4pO1xuXG4gIC8vIG9wdGlvbmFsbHksIHJlcXVlc3QgdGhlIGRlY3J5cHRpb24ga2V5XG4gIGlmIChzZWdtZW50LmtleSkge1xuICAgIHZhciBrZXlSZXF1ZXN0T3B0aW9ucyA9IHZpZGVvanMkMS5tZXJnZU9wdGlvbnMoeGhyT3B0aW9ucywge1xuICAgICAgdXJpOiBzZWdtZW50LmtleS5yZXNvbHZlZFVyaSxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJ1xuICAgIH0pO1xuICAgIHZhciBrZXlSZXF1ZXN0Q2FsbGJhY2sgPSBoYW5kbGVLZXlSZXNwb25zZShzZWdtZW50LCBmaW5pc2hQcm9jZXNzaW5nRm4pO1xuICAgIHZhciBrZXlYaHIgPSB4aHIkJDEoa2V5UmVxdWVzdE9wdGlvbnMsIGtleVJlcXVlc3RDYWxsYmFjayk7XG5cbiAgICBhY3RpdmVYaHJzLnB1c2goa2V5WGhyKTtcbiAgfVxuXG4gIC8vIG9wdGlvbmFsbHksIHJlcXVlc3QgdGhlIGFzc29jaWF0ZWQgbWVkaWEgaW5pdCBzZWdtZW50XG4gIGlmIChzZWdtZW50Lm1hcCAmJiAhc2VnbWVudC5tYXAuYnl0ZXMpIHtcbiAgICB2YXIgaW5pdFNlZ21lbnRPcHRpb25zID0gdmlkZW9qcyQxLm1lcmdlT3B0aW9ucyh4aHJPcHRpb25zLCB7XG4gICAgICB1cmk6IHNlZ21lbnQubWFwLnJlc29sdmVkVXJpLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgICAgaGVhZGVyczogc2VnbWVudFhockhlYWRlcnMoc2VnbWVudC5tYXApXG4gICAgfSk7XG4gICAgdmFyIGluaXRTZWdtZW50UmVxdWVzdENhbGxiYWNrID0gaGFuZGxlSW5pdFNlZ21lbnRSZXNwb25zZShzZWdtZW50LCBmaW5pc2hQcm9jZXNzaW5nRm4pO1xuICAgIHZhciBpbml0U2VnbWVudFhociA9IHhociQkMShpbml0U2VnbWVudE9wdGlvbnMsIGluaXRTZWdtZW50UmVxdWVzdENhbGxiYWNrKTtcblxuICAgIGFjdGl2ZVhocnMucHVzaChpbml0U2VnbWVudFhocik7XG4gIH1cblxuICB2YXIgc2VnbWVudFJlcXVlc3RPcHRpb25zID0gdmlkZW9qcyQxLm1lcmdlT3B0aW9ucyh4aHJPcHRpb25zLCB7XG4gICAgdXJpOiBzZWdtZW50LnJlc29sdmVkVXJpLFxuICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICBoZWFkZXJzOiBzZWdtZW50WGhySGVhZGVycyhzZWdtZW50KVxuICB9KTtcbiAgdmFyIHNlZ21lbnRSZXF1ZXN0Q2FsbGJhY2sgPSBoYW5kbGVTZWdtZW50UmVzcG9uc2Uoc2VnbWVudCwgZmluaXNoUHJvY2Vzc2luZ0ZuKTtcbiAgdmFyIHNlZ21lbnRYaHIgPSB4aHIkJDEoc2VnbWVudFJlcXVlc3RPcHRpb25zLCBzZWdtZW50UmVxdWVzdENhbGxiYWNrKTtcblxuICBzZWdtZW50WGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgaGFuZGxlUHJvZ3Jlc3Moc2VnbWVudCwgcHJvZ3Jlc3NGbikpO1xuICBhY3RpdmVYaHJzLnB1c2goc2VnbWVudFhocik7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWJvcnRBbGwoYWN0aXZlWGhycyk7XG4gIH07XG59O1xuXG4vKipcbiAqIEBmaWxlIC0gY29kZWNzLmpzIC0gSGFuZGxlcyB0YXNrcyByZWdhcmRpbmcgY29kZWMgc3RyaW5ncyBzdWNoIGFzIHRyYW5zbGF0aW5nIHRoZW0gdG9cbiAqIGNvZGVjIHN0cmluZ3MsIG9yIHRyYW5zbGF0aW5nIGNvZGVjIHN0cmluZ3MgaW50byBvYmplY3RzIHRoYXQgY2FuIGJlIGV4YW1pbmVkLlxuICovXG5cbi8vIERlZmF1bHQgY29kZWMgcGFyYW1ldGVycyBpZiBub25lIHdlcmUgcHJvdmlkZWQgZm9yIHZpZGVvIGFuZC9vciBhdWRpb1xudmFyIGRlZmF1bHRDb2RlY3MgPSB7XG4gIHZpZGVvQ29kZWM6ICdhdmMxJyxcbiAgdmlkZW9PYmplY3RUeXBlSW5kaWNhdG9yOiAnLjRkNDAwZCcsXG4gIC8vIEFBQy1MQ1xuICBhdWRpb1Byb2ZpbGU6ICcyJ1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBjb2RlYyBzdHJpbmcgdG8gcmV0cmlldmUgdGhlIG51bWJlciBvZiBjb2RlY3Mgc3BlY2lmaWVkLFxuICogdGhlIHZpZGVvIGNvZGVjIGFuZCBvYmplY3QgdHlwZSBpbmRpY2F0b3IsIGFuZCB0aGUgYXVkaW8gcHJvZmlsZS5cbiAqL1xuXG52YXIgcGFyc2VDb2RlY3MgPSBmdW5jdGlvbiBwYXJzZUNvZGVjcygpIHtcbiAgdmFyIGNvZGVjcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBjb2RlY0NvdW50OiAwXG4gIH07XG4gIHZhciBwYXJzZWQgPSB2b2lkIDA7XG5cbiAgcmVzdWx0LmNvZGVjQ291bnQgPSBjb2RlY3Muc3BsaXQoJywnKS5sZW5ndGg7XG4gIHJlc3VsdC5jb2RlY0NvdW50ID0gcmVzdWx0LmNvZGVjQ291bnQgfHwgMjtcblxuICAvLyBwYXJzZSB0aGUgdmlkZW8gY29kZWNcbiAgcGFyc2VkID0gLyhefFxcc3wsKSsoYXZjWzEzXSkoW14gLF0qKS9pLmV4ZWMoY29kZWNzKTtcbiAgaWYgKHBhcnNlZCkge1xuICAgIHJlc3VsdC52aWRlb0NvZGVjID0gcGFyc2VkWzJdO1xuICAgIHJlc3VsdC52aWRlb09iamVjdFR5cGVJbmRpY2F0b3IgPSBwYXJzZWRbM107XG4gIH1cblxuICAvLyBwYXJzZSB0aGUgbGFzdCBmaWVsZCBvZiB0aGUgYXVkaW8gY29kZWNcbiAgcmVzdWx0LmF1ZGlvUHJvZmlsZSA9IC8oXnxcXHN8LCkrbXA0YS5bMC05QS1GYS1mXStcXC4oWzAtOUEtRmEtZl0rKS9pLmV4ZWMoY29kZWNzKTtcbiAgcmVzdWx0LmF1ZGlvUHJvZmlsZSA9IHJlc3VsdC5hdWRpb1Byb2ZpbGUgJiYgcmVzdWx0LmF1ZGlvUHJvZmlsZVsyXTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIGNvZGVjcyBpbiB0aGUgY29kZWMgc3RyaW5nIHdpdGggdGhlIG9sZCBhcHBsZS1zdHlsZSBgYXZjMS48ZGQ+LjxkZD5gIHRvIHRoZVxuICogc3RhbmRhcmQgYGF2YzEuPGhoaGhoaD5gLlxuICpcbiAqIEBwYXJhbSBjb2RlY1N0cmluZyB7U3RyaW5nfSB0aGUgY29kZWMgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBjb2RlYyBzdHJpbmcgd2l0aCBvbGQgYXBwbGUtc3R5bGUgY29kZWNzIHJlcGxhY2VkXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIG1hcExlZ2FjeUF2Y0NvZGVjcyA9IGZ1bmN0aW9uIG1hcExlZ2FjeUF2Y0NvZGVjcyhjb2RlY1N0cmluZykge1xuICByZXR1cm4gY29kZWNTdHJpbmcucmVwbGFjZSgvYXZjMVxcLihcXGQrKVxcLihcXGQrKS9pLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gdHJhbnNsYXRlTGVnYWN5Q29kZWNzKFttYXRjaF0pWzBdO1xuICB9KTtcbn07XG5cbi8qKlxuICogQnVpbGQgYSBtZWRpYSBtaW1lLXR5cGUgc3RyaW5nIGZyb20gYSBzZXQgb2YgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgZWl0aGVyICdhdWRpbycgb3IgJ3ZpZGVvJ1xuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRhaW5lciBlaXRoZXIgJ21wMnQnIG9yICdtcDQnXG4gKiBAcGFyYW0ge0FycmF5fSBjb2RlY3MgYW4gYXJyYXkgb2YgY29kZWMgc3RyaW5ncyB0byBhZGRcbiAqIEByZXR1cm4ge1N0cmluZ30gYSB2YWxpZCBtZWRpYSBtaW1lLXR5cGVcbiAqL1xudmFyIG1ha2VNaW1lVHlwZVN0cmluZyA9IGZ1bmN0aW9uIG1ha2VNaW1lVHlwZVN0cmluZyh0eXBlLCBjb250YWluZXIsIGNvZGVjcykge1xuICAvLyBUaGUgY29kZWNzIGFycmF5IGlzIGZpbHRlcmVkIHNvIHRoYXQgZmFsc2V5IHZhbHVlcyBhcmVcbiAgLy8gZHJvcHBlZCBhbmQgZG9uJ3QgY2F1c2UgQXJyYXkjam9pbiB0byBjcmVhdGUgc3B1cmlvdXNcbiAgLy8gY29tbWFzXG4gIHJldHVybiB0eXBlICsgJy8nICsgY29udGFpbmVyICsgJzsgY29kZWNzPVwiJyArIGNvZGVjcy5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gISFjO1xuICB9KS5qb2luKCcsICcpICsgJ1wiJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHlwZSBjb250YWluZXIgYmFzZWQgb24gaW5mb3JtYXRpb24gaW4gdGhlIHBsYXlsaXN0XG4gKiBAcGFyYW0ge1BsYXlsaXN0fSBtZWRpYSB0aGUgY3VycmVudCBtZWRpYSBwbGF5bGlzdFxuICogQHJldHVybiB7U3RyaW5nfSBhIHZhbGlkIG1lZGlhIGNvbnRhaW5lciB0eXBlXG4gKi9cbnZhciBnZXRDb250YWluZXJUeXBlID0gZnVuY3Rpb24gZ2V0Q29udGFpbmVyVHlwZShtZWRpYSkge1xuICAvLyBBbiBpbml0aWFsaXphdGlvbiBzZWdtZW50IG1lYW5zIHRoZSBtZWRpYSBwbGF5bGlzdCBpcyBhbiBpZnJhbWVcbiAgLy8gcGxheWxpc3Qgb3IgaXMgdXNpbmcgdGhlIG1wNCBjb250YWluZXIuIFdlIGRvbid0IGN1cnJlbnRseVxuICAvLyBzdXBwb3J0IGlmcmFtZSBwbGF5bGlzdHMsIHNvIGFzc3VtZSB0aGlzIGlzIHNpZ25hbGxpbmcgbXA0XG4gIC8vIGZyYWdtZW50cy5cbiAgaWYgKG1lZGlhLnNlZ21lbnRzICYmIG1lZGlhLnNlZ21lbnRzLmxlbmd0aCAmJiBtZWRpYS5zZWdtZW50c1swXS5tYXApIHtcbiAgICByZXR1cm4gJ21wNCc7XG4gIH1cbiAgcmV0dXJuICdtcDJ0Jztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHNldCBvZiBjb2RlYyBzdHJpbmdzIHBhcnNlZCBmcm9tIHRoZSBwbGF5bGlzdCBvciB0aGUgZGVmYXVsdFxuICogY29kZWMgc3RyaW5ncyBpZiBubyBjb2RlY3Mgd2VyZSBzcGVjaWZpZWQgaW4gdGhlIHBsYXlsaXN0XG4gKiBAcGFyYW0ge1BsYXlsaXN0fSBtZWRpYSB0aGUgY3VycmVudCBtZWRpYSBwbGF5bGlzdFxuICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3Qgd2l0aCB0aGUgdmlkZW8gYW5kIGF1ZGlvIGNvZGVjc1xuICovXG52YXIgZ2V0Q29kZWNzID0gZnVuY3Rpb24gZ2V0Q29kZWNzKG1lZGlhKSB7XG4gIC8vIGlmIHRoZSBjb2RlY3Mgd2VyZSBleHBsaWNpdGx5IHNwZWNpZmllZCwgdXNlIHRoZW0gaW5zdGVhZCBvZiB0aGVcbiAgLy8gZGVmYXVsdHNcbiAgdmFyIG1lZGlhQXR0cmlidXRlcyA9IG1lZGlhLmF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKG1lZGlhQXR0cmlidXRlcy5DT0RFQ1MpIHtcbiAgICByZXR1cm4gcGFyc2VDb2RlY3MobWVkaWFBdHRyaWJ1dGVzLkNPREVDUyk7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRDb2RlY3M7XG59O1xuXG52YXIgYXVkaW9Qcm9maWxlRnJvbURlZmF1bHQgPSBmdW5jdGlvbiBhdWRpb1Byb2ZpbGVGcm9tRGVmYXVsdChtYXN0ZXIsIGF1ZGlvR3JvdXBJZCkge1xuICBpZiAoIW1hc3Rlci5tZWRpYUdyb3Vwcy5BVURJTyB8fCAhYXVkaW9Hcm91cElkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYXVkaW9Hcm91cCA9IG1hc3Rlci5tZWRpYUdyb3Vwcy5BVURJT1thdWRpb0dyb3VwSWRdO1xuXG4gIGlmICghYXVkaW9Hcm91cCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBhdWRpb0dyb3VwKSB7XG4gICAgdmFyIGF1ZGlvVHlwZSA9IGF1ZGlvR3JvdXBbbmFtZV07XG5cbiAgICBpZiAoYXVkaW9UeXBlLmRlZmF1bHQgJiYgYXVkaW9UeXBlLnBsYXlsaXN0cykge1xuICAgICAgLy8gY29kZWMgc2hvdWxkIGJlIHRoZSBzYW1lIGZvciBhbGwgcGxheWxpc3RzIHdpdGhpbiB0aGUgYXVkaW8gdHlwZVxuICAgICAgcmV0dXJuIHBhcnNlQ29kZWNzKGF1ZGlvVHlwZS5wbGF5bGlzdHNbMF0uYXR0cmlidXRlcy5DT0RFQ1MpLmF1ZGlvUHJvZmlsZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgTUlNRSB0eXBlIHN0cmluZ3MgZm9yIGEgd29ya2luZyBjb25maWd1cmF0aW9uIG9mXG4gKiBTb3VyY2VCdWZmZXJzIHRvIHBsYXkgdmFyaWFudCBzdHJlYW1zIGluIGEgbWFzdGVyIHBsYXlsaXN0LiBJZlxuICogdGhlcmUgaXMgbm8gcG9zc2libGUgd29ya2luZyBjb25maWd1cmF0aW9uLCBhbiBlbXB0eSBhcnJheSB3aWxsIGJlXG4gKiByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gbWFzdGVyIHtPYmplY3R9IHRoZSBtM3U4IG9iamVjdCBmb3IgdGhlIG1hc3RlciBwbGF5bGlzdFxuICogQHBhcmFtIG1lZGlhIHtPYmplY3R9IHRoZSBtM3U4IG9iamVjdCBmb3IgdGhlIHZhcmlhbnQgcGxheWxpc3RcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgTUlNRSB0eXBlIHN0cmluZ3MuIElmIHRoZSBhcnJheSBoYXMgbW9yZSB0aGFuXG4gKiBvbmUgZW50cnksIHRoZSBmaXJzdCBlbGVtZW50IHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSB2aWRlb1xuICogU291cmNlQnVmZmVyIGFuZCB0aGUgc2Vjb25kIHRvIHRoZSBhdWRpbyBTb3VyY2VCdWZmZXIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIG1pbWVUeXBlc0ZvclBsYXlsaXN0ID0gZnVuY3Rpb24gbWltZVR5cGVzRm9yUGxheWxpc3QobWFzdGVyLCBtZWRpYSkge1xuICB2YXIgY29udGFpbmVyVHlwZSA9IGdldENvbnRhaW5lclR5cGUobWVkaWEpO1xuICB2YXIgY29kZWNJbmZvID0gZ2V0Q29kZWNzKG1lZGlhKTtcbiAgdmFyIG1lZGlhQXR0cmlidXRlcyA9IG1lZGlhLmF0dHJpYnV0ZXMgfHwge307XG4gIC8vIERlZmF1bHQgY29uZGl0aW9uIGZvciBhIHRyYWRpdGlvbmFsIEhMUyAobm8gZGVtdXhlZCBhdWRpby92aWRlbylcbiAgdmFyIGlzTXV4ZWQgPSB0cnVlO1xuICB2YXIgaXNNYWF0ID0gZmFsc2U7XG5cbiAgaWYgKCFtZWRpYSkge1xuICAgIC8vIE5vdCBlbm91Z2ggaW5mb3JtYXRpb25cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAobWFzdGVyLm1lZGlhR3JvdXBzLkFVRElPICYmIG1lZGlhQXR0cmlidXRlcy5BVURJTykge1xuICAgIHZhciBhdWRpb0dyb3VwID0gbWFzdGVyLm1lZGlhR3JvdXBzLkFVRElPW21lZGlhQXR0cmlidXRlcy5BVURJT107XG5cbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgYXJlIGluIGEgbXVsdGlwbGUtYXVkaW8gdHJhY2sgc2NlbmFyaW9cbiAgICBpZiAoYXVkaW9Hcm91cCkge1xuICAgICAgaXNNYWF0ID0gdHJ1ZTtcbiAgICAgIC8vIFN0YXJ0IHdpdGggdGhlIGV2ZXJ5dGhpbmcgZGVtdXhlZCB0aGVuLi4uXG4gICAgICBpc011eGVkID0gZmFsc2U7XG4gICAgICAvLyAuLi5jaGVjayB0byBzZWUgaWYgYW55IGF1ZGlvIGdyb3VwIHRyYWNrcyBhcmUgbXV4ZWQgKGllLiBsYWNraW5nIGEgdXJpKVxuICAgICAgZm9yICh2YXIgZ3JvdXBJZCBpbiBhdWRpb0dyb3VwKSB7XG4gICAgICAgIC8vIGVpdGhlciBhIHVyaSBpcyBwcmVzZW50IChpZiB0aGUgY2FzZSBvZiBITFMgYW5kIGFuIGV4dGVybmFsIHBsYXlsaXN0KSwgb3JcbiAgICAgICAgLy8gcGxheWxpc3RzIGlzIHByZXNlbnQgKGluIHRoZSBjYXNlIG9mIERBU0ggd2hlcmUgd2UgZG9uJ3QgaGF2ZSBleHRlcm5hbCBhdWRpb1xuICAgICAgICAvLyBwbGF5bGlzdHMpXG4gICAgICAgIGlmICghYXVkaW9Hcm91cFtncm91cElkXS51cmkgJiYgIWF1ZGlvR3JvdXBbZ3JvdXBJZF0ucGxheWxpc3RzKSB7XG4gICAgICAgICAgaXNNdXhlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBITFMgd2l0aCBtdWx0aXBsZS1hdWRpbyB0cmFja3MgbXVzdCBhbHdheXMgZ2V0IGFuIGF1ZGlvIGNvZGVjLlxuICAvLyBQdXQgYW5vdGhlciB3YXksIHRoZXJlIGlzIG5vIHdheSB0byBoYXZlIGEgdmlkZW8tb25seSBtdWx0aXBsZS1hdWRpbyBITFMhXG4gIGlmIChpc01hYXQgJiYgIWNvZGVjSW5mby5hdWRpb1Byb2ZpbGUpIHtcbiAgICBpZiAoIWlzTXV4ZWQpIHtcbiAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIGZvciBjb2RlY3MgdG8gYmUgc3BlY2lmaWVkIG9uIHRoZSBhdWRpbyBtZWRpYSBncm91cCBwbGF5bGlzdCBidXRcbiAgICAgIC8vIG5vdCBvbiB0aGUgcmVuZGl0aW9uIHBsYXlsaXN0LiBUaGlzIGlzIG1vc3RseSB0aGUgY2FzZSBmb3IgREFTSCwgd2hlcmUgYXVkaW8gYW5kXG4gICAgICAvLyB2aWRlbyBhcmUgYWx3YXlzIHNlcGFyYXRlIChhbmQgc2VwYXJhdGVseSBzcGVjaWZpZWQpLlxuICAgICAgY29kZWNJbmZvLmF1ZGlvUHJvZmlsZSA9IGF1ZGlvUHJvZmlsZUZyb21EZWZhdWx0KG1hc3RlciwgbWVkaWFBdHRyaWJ1dGVzLkFVRElPKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvZGVjSW5mby5hdWRpb1Byb2ZpbGUpIHtcbiAgICAgIHZpZGVvanMkMS5sb2cud2FybignTXVsdGlwbGUgYXVkaW8gdHJhY2tzIHByZXNlbnQgYnV0IG5vIGF1ZGlvIGNvZGVjIHN0cmluZyBpcyBzcGVjaWZpZWQuICcgKyAnQXR0ZW1wdGluZyB0byB1c2UgdGhlIGRlZmF1bHQgYXVkaW8gY29kZWMgKG1wNGEuNDAuMiknKTtcbiAgICAgIGNvZGVjSW5mby5hdWRpb1Byb2ZpbGUgPSBkZWZhdWx0Q29kZWNzLmF1ZGlvUHJvZmlsZTtcbiAgICB9XG4gIH1cblxuICAvLyBHZW5lcmF0ZSB0aGUgZmluYWwgY29kZWMgc3RyaW5ncyBmcm9tIHRoZSBjb2RlYyBvYmplY3QgZ2VuZXJhdGVkIGFib3ZlXG4gIHZhciBjb2RlY1N0cmluZ3MgPSB7fTtcblxuICBpZiAoY29kZWNJbmZvLnZpZGVvQ29kZWMpIHtcbiAgICBjb2RlY1N0cmluZ3MudmlkZW8gPSAnJyArIGNvZGVjSW5mby52aWRlb0NvZGVjICsgY29kZWNJbmZvLnZpZGVvT2JqZWN0VHlwZUluZGljYXRvcjtcbiAgfVxuXG4gIGlmIChjb2RlY0luZm8uYXVkaW9Qcm9maWxlKSB7XG4gICAgY29kZWNTdHJpbmdzLmF1ZGlvID0gJ21wNGEuNDAuJyArIGNvZGVjSW5mby5hdWRpb1Byb2ZpbGU7XG4gIH1cblxuICAvLyBGaW5hbGx5LCBtYWtlIGFuZCByZXR1cm4gYW4gYXJyYXkgd2l0aCBwcm9wZXIgbWltZS10eXBlcyBkZXBlbmRpbmcgb25cbiAgLy8gdGhlIGNvbmZpZ3VyYXRpb25cbiAgdmFyIGp1c3RBdWRpbyA9IG1ha2VNaW1lVHlwZVN0cmluZygnYXVkaW8nLCBjb250YWluZXJUeXBlLCBbY29kZWNTdHJpbmdzLmF1ZGlvXSk7XG4gIHZhciBqdXN0VmlkZW8gPSBtYWtlTWltZVR5cGVTdHJpbmcoJ3ZpZGVvJywgY29udGFpbmVyVHlwZSwgW2NvZGVjU3RyaW5ncy52aWRlb10pO1xuICB2YXIgYm90aFZpZGVvQXVkaW8gPSBtYWtlTWltZVR5cGVTdHJpbmcoJ3ZpZGVvJywgY29udGFpbmVyVHlwZSwgW2NvZGVjU3RyaW5ncy52aWRlbywgY29kZWNTdHJpbmdzLmF1ZGlvXSk7XG5cbiAgaWYgKGlzTWFhdCkge1xuICAgIGlmICghaXNNdXhlZCAmJiBjb2RlY1N0cmluZ3MudmlkZW8pIHtcbiAgICAgIHJldHVybiBbanVzdFZpZGVvLCBqdXN0QXVkaW9dO1xuICAgIH1cblxuICAgIGlmICghaXNNdXhlZCAmJiAhY29kZWNTdHJpbmdzLnZpZGVvKSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBtdXhlZCBjb250ZW50IGFuZCBubyB2aWRlbyBjb2RlYyBzdHJpbmcsIHNvIHRoaXMgaXMgYW4gYXVkaW8gb25seVxuICAgICAgLy8gc3RyZWFtIHdpdGggYWx0ZXJuYXRlIGF1ZGlvLlxuICAgICAgcmV0dXJuIFtqdXN0QXVkaW8sIGp1c3RBdWRpb107XG4gICAgfVxuXG4gICAgLy8gVGhlcmUgZXhpc3RzIHRoZSBwb3NzaWJsaXR5IHRoYXQgdGhpcyB3aWxsIHJldHVybiBhIGB2aWRlby9jb250YWluZXJgXG4gICAgLy8gbWltZS10eXBlIGZvciB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIGFycmF5IGV2ZW4gd2hlbiB0aGVyZSBpcyBvbmx5IGF1ZGlvLlxuICAgIC8vIFRoaXMgZG9lc24ndCBhcHBlYXIgdG8gYmUgYSBwcm9ibGVtIGFuZCBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICAgIHJldHVybiBbYm90aFZpZGVvQXVkaW8sIGp1c3RBdWRpb107XG4gIH1cblxuICAvLyBJZiB0aGVyZSBpcyBubyB2aWRlbyBjb2RlYyBhdCBhbGwsIGFsd2F5cyBqdXN0IHJldHVybiBhIHNpbmdsZVxuICAvLyBhdWRpby88Y29udGFpbmVyPiBtaW1lLXR5cGVcbiAgaWYgKCFjb2RlY1N0cmluZ3MudmlkZW8pIHtcbiAgICByZXR1cm4gW2p1c3RBdWRpb107XG4gIH1cblxuICAvLyBXaGVuIG5vdCB1c2luZyBzZXBhcmF0ZSBhdWRpbyBtZWRpYSBncm91cHMsIGF1ZGlvIGFuZCB2aWRlbyBpc1xuICAvLyAqYWx3YXlzKiBtdXhlZFxuICByZXR1cm4gW2JvdGhWaWRlb0F1ZGlvXTtcbn07XG5cbi8vIFV0aWxpdGllc1xuXG4vKipcbiAqIFJldHVybnMgdGhlIENTUyB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBvbiBhbiBlbGVtZW50XG4gKiB1c2luZyBgZ2V0Q29tcHV0ZWRTdHlsZWAuIEZpcmVmb3ggaGFzIGEgbG9uZy1zdGFuZGluZyBpc3N1ZSB3aGVyZVxuICogZ2V0Q29tcHV0ZWRTdHlsZSgpIG1heSByZXR1cm4gbnVsbCB3aGVuIHJ1bm5pbmcgaW4gYW4gaWZyYW1lIHdpdGhcbiAqIGBkaXNwbGF5OiBub25lYC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIGh0bWxlbGVtZW50IHRvIHdvcmsgb25cbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGUgcHJvcHJldHkgdG8gZ2V0IHRoZSBzdHlsZSBmb3JcbiAqL1xudmFyIHNhZmVHZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24gc2FmZUdldENvbXB1dGVkU3R5bGUoZWwsIHByb3BlcnR5KSB7XG4gIHZhciByZXN1bHQgPSB2b2lkIDA7XG5cbiAgaWYgKCFlbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJlc3VsdCA9IHdpbmRvdyQxLmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBpZiAoIXJlc3VsdCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHRbcHJvcGVydHldO1xufTtcblxuLyoqXG4gKiBSZXN1YWJsZSBzdGFibGUgc29ydCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7UGxheWxpc3RzfSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydEZuIERpZmZlcmVudCBjb21wYXJhdG9yc1xuICogQGZ1bmN0aW9uIHN0YWJsZVNvcnRcbiAqL1xudmFyIHN0YWJsZVNvcnQgPSBmdW5jdGlvbiBzdGFibGVTb3J0KGFycmF5LCBzb3J0Rm4pIHtcbiAgdmFyIG5ld0FycmF5ID0gYXJyYXkuc2xpY2UoKTtcblxuICBhcnJheS5zb3J0KGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIHZhciBjbXAgPSBzb3J0Rm4obGVmdCwgcmlnaHQpO1xuXG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ld0FycmF5LmluZGV4T2YobGVmdCkgLSBuZXdBcnJheS5pbmRleE9mKHJpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNtcDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBzb3J0IHR3byBwbGF5bGlzdCBvYmplY3QgYnkgYmFuZHdpZHRoLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBsZWZ0IGEgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gcmlnaHQgYSBtZWRpYSBwbGF5bGlzdCBvYmplY3RcbiAqIEByZXR1cm4ge051bWJlcn0gR3JlYXRlciB0aGFuIHplcm8gaWYgdGhlIGJhbmR3aWR0aCBhdHRyaWJ1dGUgb2ZcbiAqIGxlZnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZSBvZiByaWdodC4gTGVzc1xuICogdGhhbiB6ZXJvIGlmIHRoZSBiYW5kd2lkdGggb2YgcmlnaHQgaXMgZ3JlYXRlciB0aGFuIGxlZnQgYW5kXG4gKiBleGFjdGx5IHplcm8gaWYgdGhlIHR3byBhcmUgZXF1YWwuXG4gKi9cbnZhciBjb21wYXJlUGxheWxpc3RCYW5kd2lkdGggPSBmdW5jdGlvbiBjb21wYXJlUGxheWxpc3RCYW5kd2lkdGgobGVmdCwgcmlnaHQpIHtcbiAgdmFyIGxlZnRCYW5kd2lkdGggPSB2b2lkIDA7XG4gIHZhciByaWdodEJhbmR3aWR0aCA9IHZvaWQgMDtcblxuICBpZiAobGVmdC5hdHRyaWJ1dGVzLkJBTkRXSURUSCkge1xuICAgIGxlZnRCYW5kd2lkdGggPSBsZWZ0LmF0dHJpYnV0ZXMuQkFORFdJRFRIO1xuICB9XG4gIGxlZnRCYW5kd2lkdGggPSBsZWZ0QmFuZHdpZHRoIHx8IHdpbmRvdyQxLk51bWJlci5NQVhfVkFMVUU7XG4gIGlmIChyaWdodC5hdHRyaWJ1dGVzLkJBTkRXSURUSCkge1xuICAgIHJpZ2h0QmFuZHdpZHRoID0gcmlnaHQuYXR0cmlidXRlcy5CQU5EV0lEVEg7XG4gIH1cbiAgcmlnaHRCYW5kd2lkdGggPSByaWdodEJhbmR3aWR0aCB8fCB3aW5kb3ckMS5OdW1iZXIuTUFYX1ZBTFVFO1xuXG4gIHJldHVybiBsZWZ0QmFuZHdpZHRoIC0gcmlnaHRCYW5kd2lkdGg7XG59O1xuXG4vKipcbiAqIEEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBzb3J0IHR3byBwbGF5bGlzdCBvYmplY3QgYnkgcmVzb2x1dGlvbiAod2lkdGgpLlxuICogQHBhcmFtIHtPYmplY3R9IGxlZnQgYSBtZWRpYSBwbGF5bGlzdCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSByaWdodCBhIG1lZGlhIHBsYXlsaXN0IG9iamVjdFxuICogQHJldHVybiB7TnVtYmVyfSBHcmVhdGVyIHRoYW4gemVybyBpZiB0aGUgcmVzb2x1dGlvbi53aWR0aCBhdHRyaWJ1dGUgb2ZcbiAqIGxlZnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZSBvZiByaWdodC4gTGVzc1xuICogdGhhbiB6ZXJvIGlmIHRoZSByZXNvbHV0aW9uLndpZHRoIG9mIHJpZ2h0IGlzIGdyZWF0ZXIgdGhhbiBsZWZ0IGFuZFxuICogZXhhY3RseSB6ZXJvIGlmIHRoZSB0d28gYXJlIGVxdWFsLlxuICovXG52YXIgY29tcGFyZVBsYXlsaXN0UmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGNvbXBhcmVQbGF5bGlzdFJlc29sdXRpb24obGVmdCwgcmlnaHQpIHtcbiAgdmFyIGxlZnRXaWR0aCA9IHZvaWQgMDtcbiAgdmFyIHJpZ2h0V2lkdGggPSB2b2lkIDA7XG5cbiAgaWYgKGxlZnQuYXR0cmlidXRlcy5SRVNPTFVUSU9OICYmIGxlZnQuYXR0cmlidXRlcy5SRVNPTFVUSU9OLndpZHRoKSB7XG4gICAgbGVmdFdpZHRoID0gbGVmdC5hdHRyaWJ1dGVzLlJFU09MVVRJT04ud2lkdGg7XG4gIH1cblxuICBsZWZ0V2lkdGggPSBsZWZ0V2lkdGggfHwgd2luZG93JDEuTnVtYmVyLk1BWF9WQUxVRTtcblxuICBpZiAocmlnaHQuYXR0cmlidXRlcy5SRVNPTFVUSU9OICYmIHJpZ2h0LmF0dHJpYnV0ZXMuUkVTT0xVVElPTi53aWR0aCkge1xuICAgIHJpZ2h0V2lkdGggPSByaWdodC5hdHRyaWJ1dGVzLlJFU09MVVRJT04ud2lkdGg7XG4gIH1cblxuICByaWdodFdpZHRoID0gcmlnaHRXaWR0aCB8fCB3aW5kb3ckMS5OdW1iZXIuTUFYX1ZBTFVFO1xuXG4gIC8vIE5PVEUgLSBGYWxsYmFjayB0byBiYW5kd2lkdGggc29ydCBhcyBhcHByb3ByaWF0ZSBpbiBjYXNlcyB3aGVyZSBtdWx0aXBsZSByZW5kaXRpb25zXG4gIC8vIGhhdmUgdGhlIHNhbWUgbWVkaWEgZGltZW5zaW9ucy8gcmVzb2x1dGlvblxuICBpZiAobGVmdFdpZHRoID09PSByaWdodFdpZHRoICYmIGxlZnQuYXR0cmlidXRlcy5CQU5EV0lEVEggJiYgcmlnaHQuYXR0cmlidXRlcy5CQU5EV0lEVEgpIHtcbiAgICByZXR1cm4gbGVmdC5hdHRyaWJ1dGVzLkJBTkRXSURUSCAtIHJpZ2h0LmF0dHJpYnV0ZXMuQkFORFdJRFRIO1xuICB9XG4gIHJldHVybiBsZWZ0V2lkdGggLSByaWdodFdpZHRoO1xufTtcblxuLyoqXG4gKiBDaG9vc2VzIHRoZSBhcHByb3ByaWF0ZSBtZWRpYSBwbGF5bGlzdCBiYXNlZCBvbiBiYW5kd2lkdGggYW5kIHBsYXllciBzaXplXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1hc3RlclxuICogICAgICAgIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWFzdGVyIG1hbmlmZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gcGxheWVyQmFuZHdpZHRoXG4gKiAgICAgICAgQ3VycmVudCBjYWxjdWxhdGVkIGJhbmR3aWR0aCBvZiB0aGUgcGxheWVyXG4gKiBAcGFyYW0ge051bWJlcn0gcGxheWVyV2lkdGhcbiAqICAgICAgICBDdXJyZW50IHdpZHRoIG9mIHRoZSBwbGF5ZXIgZWxlbWVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHBsYXllckhlaWdodFxuICogICAgICAgIEN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBwbGF5ZXIgZWxlbWVudFxuICogQHJldHVybiB7UGxheWxpc3R9IHRoZSBoaWdoZXN0IGJpdHJhdGUgcGxheWxpc3QgbGVzcyB0aGFuIHRoZVxuICogY3VycmVudGx5IGRldGVjdGVkIGJhbmR3aWR0aCwgYWNjb3VudGluZyBmb3Igc29tZSBhbW91bnQgb2ZcbiAqIGJhbmR3aWR0aCB2YXJpYW5jZVxuICovXG52YXIgc2ltcGxlU2VsZWN0b3IgPSBmdW5jdGlvbiBzaW1wbGVTZWxlY3RvcihtYXN0ZXIsIHBsYXllckJhbmR3aWR0aCwgcGxheWVyV2lkdGgsIHBsYXllckhlaWdodCkge1xuICAvLyBjb252ZXJ0IHRoZSBwbGF5bGlzdHMgdG8gYW4gaW50ZXJtZWRpYXJ5IHJlcHJlc2VudGF0aW9uIHRvIG1ha2UgY29tcGFyaXNvbnMgZWFzaWVyXG4gIHZhciBzb3J0ZWRQbGF5bGlzdFJlcHMgPSBtYXN0ZXIucGxheWxpc3RzLm1hcChmdW5jdGlvbiAocGxheWxpc3QpIHtcbiAgICB2YXIgd2lkdGggPSB2b2lkIDA7XG4gICAgdmFyIGhlaWdodCA9IHZvaWQgMDtcbiAgICB2YXIgYmFuZHdpZHRoID0gdm9pZCAwO1xuXG4gICAgd2lkdGggPSBwbGF5bGlzdC5hdHRyaWJ1dGVzLlJFU09MVVRJT04gJiYgcGxheWxpc3QuYXR0cmlidXRlcy5SRVNPTFVUSU9OLndpZHRoO1xuICAgIGhlaWdodCA9IHBsYXlsaXN0LmF0dHJpYnV0ZXMuUkVTT0xVVElPTiAmJiBwbGF5bGlzdC5hdHRyaWJ1dGVzLlJFU09MVVRJT04uaGVpZ2h0O1xuICAgIGJhbmR3aWR0aCA9IHBsYXlsaXN0LmF0dHJpYnV0ZXMuQkFORFdJRFRIO1xuXG4gICAgYmFuZHdpZHRoID0gYmFuZHdpZHRoIHx8IHdpbmRvdyQxLk51bWJlci5NQVhfVkFMVUU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYmFuZHdpZHRoOiBiYW5kd2lkdGgsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHBsYXlsaXN0OiBwbGF5bGlzdFxuICAgIH07XG4gIH0pO1xuXG4gIHN0YWJsZVNvcnQoc29ydGVkUGxheWxpc3RSZXBzLCBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdC5iYW5kd2lkdGggLSByaWdodC5iYW5kd2lkdGg7XG4gIH0pO1xuXG4gIC8vIGZpbHRlciBvdXQgYW55IHBsYXlsaXN0cyB0aGF0IGhhdmUgYmVlbiBleGNsdWRlZCBkdWUgdG9cbiAgLy8gaW5jb21wYXRpYmxlIGNvbmZpZ3VyYXRpb25zXG4gIHNvcnRlZFBsYXlsaXN0UmVwcyA9IHNvcnRlZFBsYXlsaXN0UmVwcy5maWx0ZXIoZnVuY3Rpb24gKHJlcCkge1xuICAgIHJldHVybiAhUGxheWxpc3QuaXNJbmNvbXBhdGlibGUocmVwLnBsYXlsaXN0KTtcbiAgfSk7XG5cbiAgLy8gZmlsdGVyIG91dCBhbnkgcGxheWxpc3RzIHRoYXQgaGF2ZSBiZWVuIGRpc2FibGVkIG1hbnVhbGx5IHRocm91Z2ggdGhlIHJlcHJlc2VudGF0aW9uc1xuICAvLyBhcGkgb3IgYmxhY2tsaXN0ZWQgdGVtcG9yYXJpbHkgZHVlIHRvIHBsYXliYWNrIGVycm9ycy5cbiAgdmFyIGVuYWJsZWRQbGF5bGlzdFJlcHMgPSBzb3J0ZWRQbGF5bGlzdFJlcHMuZmlsdGVyKGZ1bmN0aW9uIChyZXApIHtcbiAgICByZXR1cm4gUGxheWxpc3QuaXNFbmFibGVkKHJlcC5wbGF5bGlzdCk7XG4gIH0pO1xuXG4gIGlmICghZW5hYmxlZFBsYXlsaXN0UmVwcy5sZW5ndGgpIHtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gZW5hYmxlZCBwbGF5bGlzdHMsIHRoZW4gdGhleSBoYXZlIGFsbCBiZWVuIGJsYWNrbGlzdGVkIG9yIGRpc2FibGVkXG4gICAgLy8gYnkgdGhlIHVzZXIgdGhyb3VnaCB0aGUgcmVwcmVzZW50YXRpb25zIGFwaS4gSW4gdGhpcyBjYXNlLCBpZ25vcmUgYmxhY2tsaXN0aW5nIGFuZFxuICAgIC8vIGZhbGxiYWNrIHRvIHdoYXQgdGhlIHVzZXIgd2FudHMgYnkgdXNpbmcgcGxheWxpc3RzIHRoZSB1c2VyIGhhcyBub3QgZGlzYWJsZWQuXG4gICAgZW5hYmxlZFBsYXlsaXN0UmVwcyA9IHNvcnRlZFBsYXlsaXN0UmVwcy5maWx0ZXIoZnVuY3Rpb24gKHJlcCkge1xuICAgICAgcmV0dXJuICFQbGF5bGlzdC5pc0Rpc2FibGVkKHJlcC5wbGF5bGlzdCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IGFueSB2YXJpYW50IHRoYXQgaGFzIGdyZWF0ZXIgZWZmZWN0aXZlIGJpdHJhdGVcbiAgLy8gdGhhbiB0aGUgY3VycmVudCBlc3RpbWF0ZWQgYmFuZHdpZHRoXG4gIHZhciBiYW5kd2lkdGhQbGF5bGlzdFJlcHMgPSBlbmFibGVkUGxheWxpc3RSZXBzLmZpbHRlcihmdW5jdGlvbiAocmVwKSB7XG4gICAgcmV0dXJuIHJlcC5iYW5kd2lkdGggKiBDb25maWcuQkFORFdJRFRIX1ZBUklBTkNFIDwgcGxheWVyQmFuZHdpZHRoO1xuICB9KTtcblxuICB2YXIgaGlnaGVzdFJlbWFpbmluZ0JhbmR3aWR0aFJlcCA9IGJhbmR3aWR0aFBsYXlsaXN0UmVwc1tiYW5kd2lkdGhQbGF5bGlzdFJlcHMubGVuZ3RoIC0gMV07XG5cbiAgLy8gZ2V0IGFsbCBvZiB0aGUgcmVuZGl0aW9ucyB3aXRoIHRoZSBzYW1lIChoaWdoZXN0KSBiYW5kd2lkdGhcbiAgLy8gYW5kIHRoZW4gdGFraW5nIHRoZSB2ZXJ5IGZpcnN0IGVsZW1lbnRcbiAgdmFyIGJhbmR3aWR0aEJlc3RSZXAgPSBiYW5kd2lkdGhQbGF5bGlzdFJlcHMuZmlsdGVyKGZ1bmN0aW9uIChyZXApIHtcbiAgICByZXR1cm4gcmVwLmJhbmR3aWR0aCA9PT0gaGlnaGVzdFJlbWFpbmluZ0JhbmR3aWR0aFJlcC5iYW5kd2lkdGg7XG4gIH0pWzBdO1xuXG4gIC8vIGZpbHRlciBvdXQgcGxheWxpc3RzIHdpdGhvdXQgcmVzb2x1dGlvbiBpbmZvcm1hdGlvblxuICB2YXIgaGF2ZVJlc29sdXRpb24gPSBiYW5kd2lkdGhQbGF5bGlzdFJlcHMuZmlsdGVyKGZ1bmN0aW9uIChyZXApIHtcbiAgICByZXR1cm4gcmVwLndpZHRoICYmIHJlcC5oZWlnaHQ7XG4gIH0pO1xuXG4gIC8vIHNvcnQgdmFyaWFudHMgYnkgcmVzb2x1dGlvblxuICBzdGFibGVTb3J0KGhhdmVSZXNvbHV0aW9uLCBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdC53aWR0aCAtIHJpZ2h0LndpZHRoO1xuICB9KTtcblxuICAvLyBpZiB3ZSBoYXZlIHRoZSBleGFjdCByZXNvbHV0aW9uIGFzIHRoZSBwbGF5ZXIgdXNlIGl0XG4gIHZhciByZXNvbHV0aW9uQmVzdFJlcExpc3QgPSBoYXZlUmVzb2x1dGlvbi5maWx0ZXIoZnVuY3Rpb24gKHJlcCkge1xuICAgIHJldHVybiByZXAud2lkdGggPT09IHBsYXllcldpZHRoICYmIHJlcC5oZWlnaHQgPT09IHBsYXllckhlaWdodDtcbiAgfSk7XG5cbiAgaGlnaGVzdFJlbWFpbmluZ0JhbmR3aWR0aFJlcCA9IHJlc29sdXRpb25CZXN0UmVwTGlzdFtyZXNvbHV0aW9uQmVzdFJlcExpc3QubGVuZ3RoIC0gMV07XG4gIC8vIGVuc3VyZSB0aGF0IHdlIHBpY2sgdGhlIGhpZ2hlc3QgYmFuZHdpZHRoIHZhcmlhbnQgdGhhdCBoYXZlIGV4YWN0IHJlc29sdXRpb25cbiAgdmFyIHJlc29sdXRpb25CZXN0UmVwID0gcmVzb2x1dGlvbkJlc3RSZXBMaXN0LmZpbHRlcihmdW5jdGlvbiAocmVwKSB7XG4gICAgcmV0dXJuIHJlcC5iYW5kd2lkdGggPT09IGhpZ2hlc3RSZW1haW5pbmdCYW5kd2lkdGhSZXAuYmFuZHdpZHRoO1xuICB9KVswXTtcblxuICB2YXIgcmVzb2x1dGlvblBsdXNPbmVMaXN0ID0gdm9pZCAwO1xuICB2YXIgcmVzb2x1dGlvblBsdXNPbmVTbWFsbGVzdCA9IHZvaWQgMDtcbiAgdmFyIHJlc29sdXRpb25QbHVzT25lUmVwID0gdm9pZCAwO1xuXG4gIC8vIGZpbmQgdGhlIHNtYWxsZXN0IHZhcmlhbnQgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGUgcGxheWVyXG4gIC8vIGlmIHRoZXJlIGlzIG5vIG1hdGNoIG9mIGV4YWN0IHJlc29sdXRpb25cbiAgaWYgKCFyZXNvbHV0aW9uQmVzdFJlcCkge1xuICAgIHJlc29sdXRpb25QbHVzT25lTGlzdCA9IGhhdmVSZXNvbHV0aW9uLmZpbHRlcihmdW5jdGlvbiAocmVwKSB7XG4gICAgICByZXR1cm4gcmVwLndpZHRoID4gcGxheWVyV2lkdGggfHwgcmVwLmhlaWdodCA+IHBsYXllckhlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIGZpbmQgYWxsIHRoZSB2YXJpYW50cyBoYXZlIHRoZSBzYW1lIHNtYWxsZXN0IHJlc29sdXRpb25cbiAgICByZXNvbHV0aW9uUGx1c09uZVNtYWxsZXN0ID0gcmVzb2x1dGlvblBsdXNPbmVMaXN0LmZpbHRlcihmdW5jdGlvbiAocmVwKSB7XG4gICAgICByZXR1cm4gcmVwLndpZHRoID09PSByZXNvbHV0aW9uUGx1c09uZUxpc3RbMF0ud2lkdGggJiYgcmVwLmhlaWdodCA9PT0gcmVzb2x1dGlvblBsdXNPbmVMaXN0WzBdLmhlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIGVuc3VyZSB0aGF0IHdlIGFsc28gcGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggdmFyaWFudCB0aGF0XG4gICAgLy8gaXMganVzdC1sYXJnZXItdGhhbiB0aGUgdmlkZW8gcGxheWVyXG4gICAgaGlnaGVzdFJlbWFpbmluZ0JhbmR3aWR0aFJlcCA9IHJlc29sdXRpb25QbHVzT25lU21hbGxlc3RbcmVzb2x1dGlvblBsdXNPbmVTbWFsbGVzdC5sZW5ndGggLSAxXTtcbiAgICByZXNvbHV0aW9uUGx1c09uZVJlcCA9IHJlc29sdXRpb25QbHVzT25lU21hbGxlc3QuZmlsdGVyKGZ1bmN0aW9uIChyZXApIHtcbiAgICAgIHJldHVybiByZXAuYmFuZHdpZHRoID09PSBoaWdoZXN0UmVtYWluaW5nQmFuZHdpZHRoUmVwLmJhbmR3aWR0aDtcbiAgICB9KVswXTtcbiAgfVxuXG4gIC8vIGZhbGxiYWNrIGNoYWluIG9mIHZhcmlhbnRzXG4gIHZhciBjaG9zZW5SZXAgPSByZXNvbHV0aW9uUGx1c09uZVJlcCB8fCByZXNvbHV0aW9uQmVzdFJlcCB8fCBiYW5kd2lkdGhCZXN0UmVwIHx8IGVuYWJsZWRQbGF5bGlzdFJlcHNbMF0gfHwgc29ydGVkUGxheWxpc3RSZXBzWzBdO1xuXG4gIHJldHVybiBjaG9zZW5SZXAgPyBjaG9zZW5SZXAucGxheWxpc3QgOiBudWxsO1xufTtcblxuLy8gUGxheWxpc3QgU2VsZWN0b3JzXG5cbi8qKlxuICogQ2hvb3NlcyB0aGUgYXBwcm9wcmlhdGUgbWVkaWEgcGxheWxpc3QgYmFzZWQgb24gdGhlIG1vc3QgcmVjZW50XG4gKiBiYW5kd2lkdGggZXN0aW1hdGUgYW5kIHRoZSBwbGF5ZXIgc2l6ZS5cbiAqXG4gKiBFeHBlY3RzIHRvIGJlIGNhbGxlZCB3aXRoaW4gdGhlIGNvbnRleHQgb2YgYW4gaW5zdGFuY2Ugb2YgSGxzSGFuZGxlclxuICpcbiAqIEByZXR1cm4ge1BsYXlsaXN0fSB0aGUgaGlnaGVzdCBiaXRyYXRlIHBsYXlsaXN0IGxlc3MgdGhhbiB0aGVcbiAqIGN1cnJlbnRseSBkZXRlY3RlZCBiYW5kd2lkdGgsIGFjY291bnRpbmcgZm9yIHNvbWUgYW1vdW50IG9mXG4gKiBiYW5kd2lkdGggdmFyaWFuY2VcbiAqL1xudmFyIGxhc3RCYW5kd2lkdGhTZWxlY3RvciA9IGZ1bmN0aW9uIGxhc3RCYW5kd2lkdGhTZWxlY3RvcigpIHtcbiAgcmV0dXJuIHNpbXBsZVNlbGVjdG9yKHRoaXMucGxheWxpc3RzLm1hc3RlciwgdGhpcy5zeXN0ZW1CYW5kd2lkdGgsIHBhcnNlSW50KHNhZmVHZXRDb21wdXRlZFN0eWxlKHRoaXMudGVjaF8uZWwoKSwgJ3dpZHRoJyksIDEwKSwgcGFyc2VJbnQoc2FmZUdldENvbXB1dGVkU3R5bGUodGhpcy50ZWNoXy5lbCgpLCAnaGVpZ2h0JyksIDEwKSk7XG59O1xuXG4vKipcbiAqIENob29zZXMgdGhlIGFwcHJvcHJpYXRlIG1lZGlhIHBsYXlsaXN0IGJhc2VkIG9uIHRoZSBwb3RlbnRpYWwgdG8gcmVidWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3NcbiAqICAgICAgICBPYmplY3Qgb2YgaW5mb3JtYXRpb24gcmVxdWlyZWQgdG8gdXNlIHRoaXMgc2VsZWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncy5tYXN0ZXJcbiAqICAgICAgICBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hc3RlciBtYW5pZmVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IHNldHRpbmdzLmN1cnJlbnRUaW1lXG4gKiAgICAgICAgVGhlIGN1cnJlbnQgdGltZSBvZiB0aGUgcGxheWVyXG4gKiBAcGFyYW0ge051bWJlcn0gc2V0dGluZ3MuYmFuZHdpZHRoXG4gKiAgICAgICAgQ3VycmVudCBtZWFzdXJlZCBiYW5kd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBzZXR0aW5ncy5kdXJhdGlvblxuICogICAgICAgIER1cmF0aW9uIG9mIHRoZSBtZWRpYVxuICogQHBhcmFtIHtOdW1iZXJ9IHNldHRpbmdzLnNlZ21lbnREdXJhdGlvblxuICogICAgICAgIFNlZ21lbnQgZHVyYXRpb24gdG8gYmUgdXNlZCBpbiByb3VuZCB0cmlwIHRpbWUgY2FsY3VsYXRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gc2V0dGluZ3MudGltZVVudGlsUmVidWZmZXJcbiAqICAgICAgICBUaW1lIGxlZnQgaW4gc2Vjb25kcyB1bnRpbCB0aGUgcGxheWVyIGhhcyB0byByZWJ1ZmZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHNldHRpbmdzLmN1cnJlbnRUaW1lbGluZVxuICogICAgICAgIFRoZSBjdXJyZW50IHRpbWVsaW5lIHNlZ21lbnRzIGFyZSBiZWluZyBsb2FkZWQgZnJvbVxuICogQHBhcmFtIHtTeW5jQ29udHJvbGxlcn0gc2V0dGluZ3Muc3luY0NvbnRyb2xsZXJcbiAqICAgICAgICBTeW5jQ29udHJvbGxlciBmb3IgZGV0ZXJtaW5pbmcgaWYgd2UgaGF2ZSBhIHN5bmMgcG9pbnQgZm9yIGEgZ2l2ZW4gcGxheWxpc3RcbiAqIEByZXR1cm4ge09iamVjdHxudWxsfVxuICogICAgICAgICB7T2JqZWN0fSByZXR1cm4ucGxheWxpc3RcbiAqICAgICAgICAgVGhlIGhpZ2hlc3QgYmFuZHdpZHRoIHBsYXlsaXN0IHdpdGggdGhlIGxlYXN0IGFtb3VudCBvZiByZWJ1ZmZlcmluZ1xuICogICAgICAgICB7TnVtYmVyfSByZXR1cm4ucmVidWZmZXJpbmdJbXBhY3RcbiAqICAgICAgICAgVGhlIGFtb3VudCBvZiB0aW1lIGluIHNlY29uZHMgc3dpdGNoaW5nIHRvIHRoaXMgcGxheWxpc3Qgd2lsbCByZWJ1ZmZlci4gQVxuICogICAgICAgICBuZWdhdGl2ZSB2YWx1ZSBtZWFucyB0aGF0IHN3aXRjaGluZyB3aWxsIGNhdXNlIHplcm8gcmVidWZmZXJpbmcuXG4gKi9cbnZhciBtaW5SZWJ1ZmZlck1heEJhbmR3aWR0aFNlbGVjdG9yID0gZnVuY3Rpb24gbWluUmVidWZmZXJNYXhCYW5kd2lkdGhTZWxlY3RvcihzZXR0aW5ncykge1xuICB2YXIgbWFzdGVyID0gc2V0dGluZ3MubWFzdGVyLFxuICAgICAgY3VycmVudFRpbWUgPSBzZXR0aW5ncy5jdXJyZW50VGltZSxcbiAgICAgIGJhbmR3aWR0aCA9IHNldHRpbmdzLmJhbmR3aWR0aCxcbiAgICAgIGR1cmF0aW9uJCQxID0gc2V0dGluZ3MuZHVyYXRpb24sXG4gICAgICBzZWdtZW50RHVyYXRpb24gPSBzZXR0aW5ncy5zZWdtZW50RHVyYXRpb24sXG4gICAgICB0aW1lVW50aWxSZWJ1ZmZlciA9IHNldHRpbmdzLnRpbWVVbnRpbFJlYnVmZmVyLFxuICAgICAgY3VycmVudFRpbWVsaW5lID0gc2V0dGluZ3MuY3VycmVudFRpbWVsaW5lLFxuICAgICAgc3luY0NvbnRyb2xsZXIgPSBzZXR0aW5ncy5zeW5jQ29udHJvbGxlcjtcblxuICAvLyBmaWx0ZXIgb3V0IGFueSBwbGF5bGlzdHMgdGhhdCBoYXZlIGJlZW4gZXhjbHVkZWQgZHVlIHRvXG4gIC8vIGluY29tcGF0aWJsZSBjb25maWd1cmF0aW9uc1xuXG4gIHZhciBjb21wYXRpYmxlUGxheWxpc3RzID0gbWFzdGVyLnBsYXlsaXN0cy5maWx0ZXIoZnVuY3Rpb24gKHBsYXlsaXN0KSB7XG4gICAgcmV0dXJuICFQbGF5bGlzdC5pc0luY29tcGF0aWJsZShwbGF5bGlzdCk7XG4gIH0pO1xuXG4gIC8vIGZpbHRlciBvdXQgYW55IHBsYXlsaXN0cyB0aGF0IGhhdmUgYmVlbiBkaXNhYmxlZCBtYW51YWxseSB0aHJvdWdoIHRoZSByZXByZXNlbnRhdGlvbnNcbiAgLy8gYXBpIG9yIGJsYWNrbGlzdGVkIHRlbXBvcmFyaWx5IGR1ZSB0byBwbGF5YmFjayBlcnJvcnMuXG4gIHZhciBlbmFibGVkUGxheWxpc3RzID0gY29tcGF0aWJsZVBsYXlsaXN0cy5maWx0ZXIoUGxheWxpc3QuaXNFbmFibGVkKTtcblxuICBpZiAoIWVuYWJsZWRQbGF5bGlzdHMubGVuZ3RoKSB7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIGVuYWJsZWQgcGxheWxpc3RzLCB0aGVuIHRoZXkgaGF2ZSBhbGwgYmVlbiBibGFja2xpc3RlZCBvciBkaXNhYmxlZFxuICAgIC8vIGJ5IHRoZSB1c2VyIHRocm91Z2ggdGhlIHJlcHJlc2VudGF0aW9ucyBhcGkuIEluIHRoaXMgY2FzZSwgaWdub3JlIGJsYWNrbGlzdGluZyBhbmRcbiAgICAvLyBmYWxsYmFjayB0byB3aGF0IHRoZSB1c2VyIHdhbnRzIGJ5IHVzaW5nIHBsYXlsaXN0cyB0aGUgdXNlciBoYXMgbm90IGRpc2FibGVkLlxuICAgIGVuYWJsZWRQbGF5bGlzdHMgPSBjb21wYXRpYmxlUGxheWxpc3RzLmZpbHRlcihmdW5jdGlvbiAocGxheWxpc3QpIHtcbiAgICAgIHJldHVybiAhUGxheWxpc3QuaXNEaXNhYmxlZChwbGF5bGlzdCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgYmFuZHdpZHRoUGxheWxpc3RzID0gZW5hYmxlZFBsYXlsaXN0cy5maWx0ZXIoUGxheWxpc3QuaGFzQXR0cmlidXRlLmJpbmQobnVsbCwgJ0JBTkRXSURUSCcpKTtcblxuICB2YXIgcmVidWZmZXJpbmdFc3RpbWF0ZXMgPSBiYW5kd2lkdGhQbGF5bGlzdHMubWFwKGZ1bmN0aW9uIChwbGF5bGlzdCkge1xuICAgIHZhciBzeW5jUG9pbnQgPSBzeW5jQ29udHJvbGxlci5nZXRTeW5jUG9pbnQocGxheWxpc3QsIGR1cmF0aW9uJCQxLCBjdXJyZW50VGltZWxpbmUsIGN1cnJlbnRUaW1lKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBzeW5jIHBvaW50IGZvciB0aGlzIHBsYXlsaXN0LCBzd2l0Y2hpbmcgdG8gaXQgd2lsbCByZXF1aXJlIGFcbiAgICAvLyBzeW5jIHJlcXVlc3QgZmlyc3QuIFRoaXMgd2lsbCBkb3VibGUgdGhlIHJlcXVlc3QgdGltZVxuICAgIHZhciBudW1SZXF1ZXN0cyA9IHN5bmNQb2ludCA/IDEgOiAyO1xuICAgIHZhciByZXF1ZXN0VGltZUVzdGltYXRlID0gUGxheWxpc3QuZXN0aW1hdGVTZWdtZW50UmVxdWVzdFRpbWUoc2VnbWVudER1cmF0aW9uLCBiYW5kd2lkdGgsIHBsYXlsaXN0KTtcbiAgICB2YXIgcmVidWZmZXJpbmdJbXBhY3QgPSByZXF1ZXN0VGltZUVzdGltYXRlICogbnVtUmVxdWVzdHMgLSB0aW1lVW50aWxSZWJ1ZmZlcjtcblxuICAgIHJldHVybiB7XG4gICAgICBwbGF5bGlzdDogcGxheWxpc3QsXG4gICAgICByZWJ1ZmZlcmluZ0ltcGFjdDogcmVidWZmZXJpbmdJbXBhY3RcbiAgICB9O1xuICB9KTtcblxuICB2YXIgbm9SZWJ1ZmZlcmluZ1BsYXlsaXN0cyA9IHJlYnVmZmVyaW5nRXN0aW1hdGVzLmZpbHRlcihmdW5jdGlvbiAoZXN0aW1hdGUpIHtcbiAgICByZXR1cm4gZXN0aW1hdGUucmVidWZmZXJpbmdJbXBhY3QgPD0gMDtcbiAgfSk7XG5cbiAgLy8gU29ydCBieSBiYW5kd2lkdGggREVTQ1xuICBzdGFibGVTb3J0KG5vUmVidWZmZXJpbmdQbGF5bGlzdHMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVQbGF5bGlzdEJhbmR3aWR0aChiLnBsYXlsaXN0LCBhLnBsYXlsaXN0KTtcbiAgfSk7XG5cbiAgaWYgKG5vUmVidWZmZXJpbmdQbGF5bGlzdHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5vUmVidWZmZXJpbmdQbGF5bGlzdHNbMF07XG4gIH1cblxuICBzdGFibGVTb3J0KHJlYnVmZmVyaW5nRXN0aW1hdGVzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnJlYnVmZmVyaW5nSW1wYWN0IC0gYi5yZWJ1ZmZlcmluZ0ltcGFjdDtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlYnVmZmVyaW5nRXN0aW1hdGVzWzBdIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIENob29zZXMgdGhlIGFwcHJvcHJpYXRlIG1lZGlhIHBsYXlsaXN0LCB3aGljaCBpbiB0aGlzIGNhc2UgaXMgdGhlIGxvd2VzdCBiaXRyYXRlXG4gKiBvbmUgd2l0aCB2aWRlby4gIElmIG5vIHJlbmRpdGlvbnMgd2l0aCB2aWRlbyBleGlzdCwgcmV0dXJuIHRoZSBsb3dlc3QgYXVkaW8gcmVuZGl0aW9uLlxuICpcbiAqIEV4cGVjdHMgdG8gYmUgY2FsbGVkIHdpdGhpbiB0aGUgY29udGV4dCBvZiBhbiBpbnN0YW5jZSBvZiBIbHNIYW5kbGVyXG4gKlxuICogQHJldHVybiB7T2JqZWN0fG51bGx9XG4gKiAgICAgICAgIHtPYmplY3R9IHJldHVybi5wbGF5bGlzdFxuICogICAgICAgICBUaGUgbG93ZXN0IGJpdHJhdGUgcGxheWxpc3QgdGhhdCBjb250YWlucyBhIHZpZGVvIGNvZGVjLiAgSWYgbm8gc3VjaCByZW5kaXRpb25cbiAqICAgICAgICAgZXhpc3RzIHBpY2sgdGhlIGxvd2VzdCBhdWRpbyByZW5kaXRpb24uXG4gKi9cbnZhciBsb3dlc3RCaXRyYXRlQ29tcGF0aWJsZVZhcmlhbnRTZWxlY3RvciA9IGZ1bmN0aW9uIGxvd2VzdEJpdHJhdGVDb21wYXRpYmxlVmFyaWFudFNlbGVjdG9yKCkge1xuICAvLyBmaWx0ZXIgb3V0IGFueSBwbGF5bGlzdHMgdGhhdCBoYXZlIGJlZW4gZXhjbHVkZWQgZHVlIHRvXG4gIC8vIGluY29tcGF0aWJsZSBjb25maWd1cmF0aW9ucyBvciBwbGF5YmFjayBlcnJvcnNcbiAgdmFyIHBsYXlsaXN0cyA9IHRoaXMucGxheWxpc3RzLm1hc3Rlci5wbGF5bGlzdHMuZmlsdGVyKFBsYXlsaXN0LmlzRW5hYmxlZCk7XG5cbiAgLy8gU29ydCBhc2NlbmRpbmcgYnkgYml0cmF0ZVxuICBzdGFibGVTb3J0KHBsYXlsaXN0cywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcGFyZVBsYXlsaXN0QmFuZHdpZHRoKGEsIGIpO1xuICB9KTtcblxuICAvLyBQYXJzZSBhbmQgYXNzdW1lIHRoYXQgcGxheWxpc3RzIHdpdGggbm8gdmlkZW8gY29kZWMgaGF2ZSBubyB2aWRlb1xuICAvLyAodGhpcyBpcyBub3QgbmVjZXNzYXJpbHkgdHJ1ZSwgYWx0aG91Z2ggaXQgaXMgZ2VuZXJhbGx5IHRydWUpLlxuICAvL1xuICAvLyBJZiBhbiBlbnRpcmUgbWFuaWZlc3QgaGFzIG5vIHZhbGlkIHZpZGVvcyBldmVyeXRoaW5nIHdpbGwgZ2V0IGZpbHRlcmVkXG4gIC8vIG91dC5cbiAgdmFyIHBsYXlsaXN0c1dpdGhWaWRlbyA9IHBsYXlsaXN0cy5maWx0ZXIoZnVuY3Rpb24gKHBsYXlsaXN0KSB7XG4gICAgcmV0dXJuIHBhcnNlQ29kZWNzKHBsYXlsaXN0LmF0dHJpYnV0ZXMuQ09ERUNTKS52aWRlb0NvZGVjO1xuICB9KTtcblxuICByZXR1cm4gcGxheWxpc3RzV2l0aFZpZGVvWzBdIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEBmaWxlIHNlZ21lbnQtbG9hZGVyLmpzXG4gKi9cblxuLy8gaW4gbXNcbnZhciBDSEVDS19CVUZGRVJfREVMQVkgPSA1MDA7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB3ZSBzaG91bGQgY2FsbCBlbmRPZlN0cmVhbSBvbiB0aGUgbWVkaWEgc291cmNlIGJhc2VkXG4gKiBvbiB0aGUgc3RhdGUgb2YgdGhlIGJ1ZmZlciBvciBpZiBhcHBlbmVkIHNlZ21lbnQgd2FzIHRoZSBmaW5hbFxuICogc2VnbWVudCBpbiB0aGUgcGxheWxpc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBsYXlsaXN0IGEgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gbWVkaWFTb3VyY2UgdGhlIE1lZGlhU291cmNlIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IHNlZ21lbnRJbmRleCB0aGUgaW5kZXggb2Ygc2VnbWVudCB3ZSBsYXN0IGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZG8gd2UgbmVlZCB0byBjYWxsIGVuZE9mU3RyZWFtIG9uIHRoZSBNZWRpYVNvdXJjZVxuICovXG52YXIgZGV0ZWN0RW5kT2ZTdHJlYW0gPSBmdW5jdGlvbiBkZXRlY3RFbmRPZlN0cmVhbShwbGF5bGlzdCwgbWVkaWFTb3VyY2UsIHNlZ21lbnRJbmRleCkge1xuICBpZiAoIXBsYXlsaXN0IHx8ICFtZWRpYVNvdXJjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBzZWdtZW50cyA9IHBsYXlsaXN0LnNlZ21lbnRzO1xuXG4gIC8vIGRldGVybWluZSBhIGZldyBib29sZWFuIHZhbHVlcyB0byBoZWxwIG1ha2UgdGhlIGJyYW5jaCBiZWxvdyBlYXNpZXJcbiAgLy8gdG8gcmVhZFxuICB2YXIgYXBwZW5kZWRMYXN0U2VnbWVudCA9IHNlZ21lbnRJbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoO1xuXG4gIC8vIGlmIHdlJ3ZlIGJ1ZmZlcmVkIHRvIHRoZSBlbmQgb2YgdGhlIHZpZGVvLCB3ZSBuZWVkIHRvIGNhbGwgZW5kT2ZTdHJlYW1cbiAgLy8gc28gdGhhdCBNZWRpYVNvdXJjZXMgY2FuIHRyaWdnZXIgdGhlIGBlbmRlZGAgZXZlbnQgd2hlbiBpdCBydW5zIG91dCBvZlxuICAvLyBidWZmZXJlZCBkYXRhIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgbWVcbiAgcmV0dXJuIHBsYXlsaXN0LmVuZExpc3QgJiYgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nICYmIGFwcGVuZGVkTGFzdFNlZ21lbnQ7XG59O1xuXG52YXIgZmluaXRlID0gZnVuY3Rpb24gZmluaXRlKG51bSkge1xuICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUobnVtKTtcbn07XG5cbnZhciBpbGxlZ2FsTWVkaWFTd2l0Y2ggPSBmdW5jdGlvbiBpbGxlZ2FsTWVkaWFTd2l0Y2gobG9hZGVyVHlwZSwgc3RhcnRpbmdNZWRpYSwgbmV3U2VnbWVudE1lZGlhKSB7XG4gIC8vIEFsdGhvdWdoIHRoZXNlIGNoZWNrcyBzaG91bGQgbW9zdCBsaWtlbHkgY292ZXIgbm9uICdtYWluJyB0eXBlcywgZm9yIG5vdyBpdCBuYXJyb3dzXG4gIC8vIHRoZSBzY29wZSBvZiBvdXIgY2hlY2tzLlxuICBpZiAobG9hZGVyVHlwZSAhPT0gJ21haW4nIHx8ICFzdGFydGluZ01lZGlhIHx8ICFuZXdTZWdtZW50TWVkaWEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghbmV3U2VnbWVudE1lZGlhLmNvbnRhaW5zQXVkaW8gJiYgIW5ld1NlZ21lbnRNZWRpYS5jb250YWluc1ZpZGVvKSB7XG4gICAgcmV0dXJuICdOZWl0aGVyIGF1ZGlvIG5vciB2aWRlbyBmb3VuZCBpbiBzZWdtZW50Lic7XG4gIH1cblxuICBpZiAoc3RhcnRpbmdNZWRpYS5jb250YWluc1ZpZGVvICYmICFuZXdTZWdtZW50TWVkaWEuY29udGFpbnNWaWRlbykge1xuICAgIHJldHVybiAnT25seSBhdWRpbyBmb3VuZCBpbiBzZWdtZW50IHdoZW4gd2UgZXhwZWN0ZWQgdmlkZW8uJyArICcgV2UgY2FuXFwndCBzd2l0Y2ggdG8gYXVkaW8gb25seSBmcm9tIGEgc3RyZWFtIHRoYXQgaGFkIHZpZGVvLicgKyAnIFRvIGdldCByaWQgb2YgdGhpcyBtZXNzYWdlLCBwbGVhc2UgYWRkIGNvZGVjIGluZm9ybWF0aW9uIHRvIHRoZSBtYW5pZmVzdC4nO1xuICB9XG5cbiAgaWYgKCFzdGFydGluZ01lZGlhLmNvbnRhaW5zVmlkZW8gJiYgbmV3U2VnbWVudE1lZGlhLmNvbnRhaW5zVmlkZW8pIHtcbiAgICByZXR1cm4gJ1ZpZGVvIGZvdW5kIGluIHNlZ21lbnQgd2hlbiB3ZSBleHBlY3RlZCBvbmx5IGF1ZGlvLicgKyAnIFdlIGNhblxcJ3Qgc3dpdGNoIHRvIGEgc3RyZWFtIHdpdGggdmlkZW8gZnJvbSBhbiBhdWRpbyBvbmx5IHN0cmVhbS4nICsgJyBUbyBnZXQgcmlkIG9mIHRoaXMgbWVzc2FnZSwgcGxlYXNlIGFkZCBjb2RlYyBpbmZvcm1hdGlvbiB0byB0aGUgbWFuaWZlc3QuJztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgdGltZSB2YWx1ZSB0aGF0IGlzIHNhZmUgdG8gcmVtb3ZlIGZyb20gdGhlIGJhY2sgYnVmZmVyIHdpdGhvdXQgaW50ZXJ1cHRpbmdcbiAqIHBsYXliYWNrLlxuICpcbiAqIEBwYXJhbSB7VGltZVJhbmdlfSBzZWVrYWJsZVxuICogICAgICAgIFRoZSBjdXJyZW50IHNlZWthYmxlIHJhbmdlXG4gKiBAcGFyYW0ge051bWJlcn0gY3VycmVudFRpbWVcbiAqICAgICAgICBUaGUgY3VycmVudCB0aW1lIG9mIHRoZSBwbGF5ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXREdXJhdGlvblxuICogICAgICAgIFRoZSB0YXJnZXQgZHVyYXRpb24gb2YgdGhlIGN1cnJlbnQgcGxheWxpc3RcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqICAgICAgICAgVGltZSB0aGF0IGlzIHNhZmUgdG8gcmVtb3ZlIGZyb20gdGhlIGJhY2sgYnVmZmVyIHdpdGhvdXQgaW50ZXJ1cHRpbmcgcGxheWJhY2tcbiAqL1xudmFyIHNhZmVCYWNrQnVmZmVyVHJpbVRpbWUgPSBmdW5jdGlvbiBzYWZlQmFja0J1ZmZlclRyaW1UaW1lKHNlZWthYmxlJCQxLCBjdXJyZW50VGltZSwgdGFyZ2V0RHVyYXRpb24pIHtcbiAgdmFyIHJlbW92ZVRvVGltZSA9IHZvaWQgMDtcblxuICBpZiAoc2Vla2FibGUkJDEubGVuZ3RoICYmIHNlZWthYmxlJCQxLnN0YXJ0KDApID4gMCAmJiBzZWVrYWJsZSQkMS5zdGFydCgwKSA8IGN1cnJlbnRUaW1lKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhIHNlZWthYmxlIHJhbmdlIHVzZSB0aGF0IGFzIHRoZSBsaW1pdCBmb3Igd2hhdCBjYW4gYmUgcmVtb3ZlZCBzYWZlbHlcbiAgICByZW1vdmVUb1RpbWUgPSBzZWVrYWJsZSQkMS5zdGFydCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UgcmVtb3ZlIGFueXRoaW5nIG9sZGVyIHRoYW4gMzAgc2Vjb25kcyBiZWZvcmUgdGhlIGN1cnJlbnQgcGxheSBoZWFkXG4gICAgcmVtb3ZlVG9UaW1lID0gY3VycmVudFRpbWUgLSAzMDtcbiAgfVxuXG4gIC8vIERvbid0IGFsbG93IHJlbW92aW5nIGZyb20gdGhlIGJ1ZmZlciB3aXRoaW4gdGFyZ2V0IGR1cmF0aW9uIG9mIGN1cnJlbnQgdGltZVxuICAvLyB0byBhdm9pZCB0aGUgcG9zc2liaWxpdHkgb2YgcmVtb3ZpbmcgdGhlIEdPUCBjdXJyZW50bHkgYmVpbmcgcGxheWVkIHdoaWNoIGNvdWxkXG4gIC8vIGNhdXNlIHBsYXliYWNrIHN0YWxscy5cbiAgcmV0dXJuIE1hdGgubWluKHJlbW92ZVRvVGltZSwgY3VycmVudFRpbWUgLSB0YXJnZXREdXJhdGlvbik7XG59O1xuXG52YXIgc2VnbWVudEluZm9TdHJpbmcgPSBmdW5jdGlvbiBzZWdtZW50SW5mb1N0cmluZyhzZWdtZW50SW5mbykge1xuICB2YXIgX3NlZ21lbnRJbmZvJHNlZ21lbnQgPSBzZWdtZW50SW5mby5zZWdtZW50LFxuICAgICAgc3RhcnQgPSBfc2VnbWVudEluZm8kc2VnbWVudC5zdGFydCxcbiAgICAgIGVuZCA9IF9zZWdtZW50SW5mbyRzZWdtZW50LmVuZCxcbiAgICAgIF9zZWdtZW50SW5mbyRwbGF5bGlzdCA9IHNlZ21lbnRJbmZvLnBsYXlsaXN0LFxuICAgICAgc2VxID0gX3NlZ21lbnRJbmZvJHBsYXlsaXN0Lm1lZGlhU2VxdWVuY2UsXG4gICAgICBpZCA9IF9zZWdtZW50SW5mbyRwbGF5bGlzdC5pZCxcbiAgICAgIF9zZWdtZW50SW5mbyRwbGF5bGlzdDIgPSBfc2VnbWVudEluZm8kcGxheWxpc3Quc2VnbWVudHMsXG4gICAgICBzZWdtZW50cyA9IF9zZWdtZW50SW5mbyRwbGF5bGlzdDIgPT09IHVuZGVmaW5lZCA/IFtdIDogX3NlZ21lbnRJbmZvJHBsYXlsaXN0MixcbiAgICAgIGluZGV4ID0gc2VnbWVudEluZm8ubWVkaWFJbmRleCxcbiAgICAgIHRpbWVsaW5lID0gc2VnbWVudEluZm8udGltZWxpbmU7XG5cbiAgcmV0dXJuIFsnYXBwZW5kaW5nIFsnICsgaW5kZXggKyAnXSBvZiBbJyArIHNlcSArICcsICcgKyAoc2VxICsgc2VnbWVudHMubGVuZ3RoKSArICddIGZyb20gcGxheWxpc3QgWycgKyBpZCArICddJywgJ1snICsgc3RhcnQgKyAnID0+ICcgKyBlbmQgKyAnXSBpbiB0aW1lbGluZSBbJyArIHRpbWVsaW5lICsgJ10nXS5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IG1hbmFnZXMgc2VnbWVudCBsb2FkaW5nIGFuZCBhcHBlbmRpbmcuXG4gKlxuICogQGNsYXNzIFNlZ21lbnRMb2FkZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHJlcXVpcmVkIGFuZCBvcHRpb25hbCBvcHRpb25zXG4gKiBAZXh0ZW5kcyB2aWRlb2pzLkV2ZW50VGFyZ2V0XG4gKi9cblxudmFyIFNlZ21lbnRMb2FkZXIgPSBmdW5jdGlvbiAoX3ZpZGVvanMkRXZlbnRUYXJnZXQpIHtcbiAgaW5oZXJpdHMkMShTZWdtZW50TG9hZGVyLCBfdmlkZW9qcyRFdmVudFRhcmdldCk7XG5cbiAgZnVuY3Rpb24gU2VnbWVudExvYWRlcihzZXR0aW5ncykge1xuICAgIGNsYXNzQ2FsbENoZWNrJDEodGhpcywgU2VnbWVudExvYWRlcik7XG5cbiAgICAvLyBjaGVjayBwcmUtY29uZGl0aW9uc1xuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4kMSh0aGlzLCAoU2VnbWVudExvYWRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNlZ21lbnRMb2FkZXIpKS5jYWxsKHRoaXMpKTtcblxuICAgIGlmICghc2V0dGluZ3MpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0luaXRpYWxpemF0aW9uIHNldHRpbmdzIGFyZSByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNldHRpbmdzLmN1cnJlbnRUaW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBjdXJyZW50VGltZSBnZXR0ZXIgc3BlY2lmaWVkJyk7XG4gICAgfVxuICAgIGlmICghc2V0dGluZ3MubWVkaWFTb3VyY2UpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIE1lZGlhU291cmNlIHNwZWNpZmllZCcpO1xuICAgIH1cbiAgICAvLyBwdWJsaWMgcHJvcGVydGllc1xuICAgIF90aGlzLmJhbmR3aWR0aCA9IHNldHRpbmdzLmJhbmR3aWR0aDtcbiAgICBfdGhpcy50aHJvdWdocHV0ID0geyByYXRlOiAwLCBjb3VudDogMCB9O1xuICAgIF90aGlzLnJvdW5kVHJpcCA9IE5hTjtcbiAgICBfdGhpcy5yZXNldFN0YXRzXygpO1xuICAgIF90aGlzLm1lZGlhSW5kZXggPSBudWxsO1xuXG4gICAgLy8gcHJpdmF0ZSBzZXR0aW5nc1xuICAgIF90aGlzLmhhc1BsYXllZF8gPSBzZXR0aW5ncy5oYXNQbGF5ZWQ7XG4gICAgX3RoaXMuY3VycmVudFRpbWVfID0gc2V0dGluZ3MuY3VycmVudFRpbWU7XG4gICAgX3RoaXMuc2Vla2FibGVfID0gc2V0dGluZ3Muc2Vla2FibGU7XG4gICAgX3RoaXMuc2Vla2luZ18gPSBzZXR0aW5ncy5zZWVraW5nO1xuICAgIF90aGlzLmR1cmF0aW9uXyA9IHNldHRpbmdzLmR1cmF0aW9uO1xuICAgIF90aGlzLm1lZGlhU291cmNlXyA9IHNldHRpbmdzLm1lZGlhU291cmNlO1xuICAgIF90aGlzLmhsc18gPSBzZXR0aW5ncy5obHM7XG4gICAgX3RoaXMubG9hZGVyVHlwZV8gPSBzZXR0aW5ncy5sb2FkZXJUeXBlO1xuICAgIF90aGlzLnN0YXJ0aW5nTWVkaWFfID0gdm9pZCAwO1xuICAgIF90aGlzLnNlZ21lbnRNZXRhZGF0YVRyYWNrXyA9IHNldHRpbmdzLnNlZ21lbnRNZXRhZGF0YVRyYWNrO1xuICAgIF90aGlzLmdvYWxCdWZmZXJMZW5ndGhfID0gc2V0dGluZ3MuZ29hbEJ1ZmZlckxlbmd0aDtcbiAgICBfdGhpcy5zb3VyY2VUeXBlXyA9IHNldHRpbmdzLnNvdXJjZVR5cGU7XG4gICAgX3RoaXMuc3RhdGVfID0gJ0lOSVQnO1xuXG4gICAgLy8gcHJpdmF0ZSBpbnN0YW5jZSB2YXJpYWJsZXNcbiAgICBfdGhpcy5jaGVja0J1ZmZlclRpbWVvdXRfID0gbnVsbDtcbiAgICBfdGhpcy5lcnJvcl8gPSB2b2lkIDA7XG4gICAgX3RoaXMuY3VycmVudFRpbWVsaW5lXyA9IC0xO1xuICAgIF90aGlzLnBlbmRpbmdTZWdtZW50XyA9IG51bGw7XG4gICAgX3RoaXMubWltZVR5cGVfID0gbnVsbDtcbiAgICBfdGhpcy5zb3VyY2VVcGRhdGVyXyA9IG51bGw7XG4gICAgX3RoaXMueGhyT3B0aW9uc18gPSBudWxsO1xuXG4gICAgLy8gRnJhZ21lbnRlZCBtcDQgcGxheWJhY2tcbiAgICBfdGhpcy5hY3RpdmVJbml0U2VnbWVudElkXyA9IG51bGw7XG4gICAgX3RoaXMuaW5pdFNlZ21lbnRzXyA9IHt9O1xuXG4gICAgX3RoaXMuZGVjcnlwdGVyXyA9IHNldHRpbmdzLmRlY3J5cHRlcjtcblxuICAgIC8vIE1hbmFnZXMgdGhlIHRyYWNraW5nIGFuZCBnZW5lcmF0aW9uIG9mIHN5bmMtcG9pbnRzLCBtYXBwaW5nc1xuICAgIC8vIGJldHdlZW4gYSB0aW1lIGluIHRoZSBkaXNwbGF5IHRpbWUgYW5kIGEgc2VnbWVudCBpbmRleCB3aXRoaW5cbiAgICAvLyBhIHBsYXlsaXN0XG4gICAgX3RoaXMuc3luY0NvbnRyb2xsZXJfID0gc2V0dGluZ3Muc3luY0NvbnRyb2xsZXI7XG4gICAgX3RoaXMuc3luY1BvaW50XyA9IHtcbiAgICAgIHNlZ21lbnRJbmRleDogMCxcbiAgICAgIHRpbWU6IDBcbiAgICB9O1xuXG4gICAgX3RoaXMuc3luY0NvbnRyb2xsZXJfLm9uKCdzeW5jaW5mb3VwZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy50cmlnZ2VyKCdzeW5jaW5mb3VwZGF0ZScpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMubWVkaWFTb3VyY2VfLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZW5kZWRfID0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvLyAuLi5mb3IgZGV0ZXJtaW5pbmcgdGhlIGZldGNoIGxvY2F0aW9uXG4gICAgX3RoaXMuZmV0Y2hBdEJ1ZmZlcl8gPSBmYWxzZTtcblxuICAgIF90aGlzLmxvZ2dlcl8gPSBsb2dnZXIoJ1NlZ21lbnRMb2FkZXJbJyArIF90aGlzLmxvYWRlclR5cGVfICsgJ10nKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgJ3N0YXRlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlXztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShuZXdTdGF0ZSkge1xuICAgICAgICBpZiAobmV3U3RhdGUgIT09IHRoaXMuc3RhdGVfKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXJfKHRoaXMuc3RhdGVfICsgJyAtPiAnICsgbmV3U3RhdGUpO1xuICAgICAgICAgIHRoaXMuc3RhdGVfID0gbmV3U3RhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogcmVzZXQgYWxsIG9mIG91ciBtZWRpYSBzdGF0c1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBjcmVhdGVDbGFzcyQxKFNlZ21lbnRMb2FkZXIsIFt7XG4gICAga2V5OiAncmVzZXRTdGF0c18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFN0YXRzXygpIHtcbiAgICAgIHRoaXMubWVkaWFCeXRlc1RyYW5zZmVycmVkID0gMDtcbiAgICAgIHRoaXMubWVkaWFSZXF1ZXN0cyA9IDA7XG4gICAgICB0aGlzLm1lZGlhUmVxdWVzdHNBYm9ydGVkID0gMDtcbiAgICAgIHRoaXMubWVkaWFSZXF1ZXN0c1RpbWVkb3V0ID0gMDtcbiAgICAgIHRoaXMubWVkaWFSZXF1ZXN0c0Vycm9yZWQgPSAwO1xuICAgICAgdGhpcy5tZWRpYVRyYW5zZmVyRHVyYXRpb24gPSAwO1xuICAgICAgdGhpcy5tZWRpYVNlY29uZHNMb2FkZWQgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRpc3Bvc2Ugb2YgdGhlIFNlZ21lbnRMb2FkZXIgYW5kIHJlc2V0IHRvIHRoZSBkZWZhdWx0IHN0YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3Bvc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5zdGF0ZSA9ICdESVNQT1NFRCc7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB0aGlzLmFib3J0XygpO1xuICAgICAgaWYgKHRoaXMuc291cmNlVXBkYXRlcl8pIHtcbiAgICAgICAgdGhpcy5zb3VyY2VVcGRhdGVyXy5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0U3RhdHNfKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWJvcnQgYW55dGhpbmcgdGhhdCBpcyBjdXJyZW50bHkgZG9pbmcgb24gd2l0aCB0aGUgU2VnbWVudExvYWRlclxuICAgICAqIGFuZCByZXNldCB0byBhIGRlZmF1bHQgc3RhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWJvcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnV0FJVElORycpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1NlZ21lbnRfKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nU2VnbWVudF8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hYm9ydF8oKTtcblxuICAgICAgLy8gV2UgYWJvcnRlZCB0aGUgcmVxdWVzdHMgd2Ugd2VyZSB3YWl0aW5nIG9uLCBzbyByZXNldCB0aGUgbG9hZGVyJ3Mgc3RhdGUgdG8gUkVBRFlcbiAgICAgIC8vIHNpbmNlIHdlIGFyZSBubyBsb25nZXIgXCJ3YWl0aW5nXCIgb24gYW55IHJlcXVlc3RzLiBYSFIgY2FsbGJhY2sgaXMgbm90IGFsd2F5cyBydW5cbiAgICAgIC8vIHdoZW4gdGhlIHJlcXVlc3QgaXMgYWJvcnRlZC4gVGhpcyB3aWxsIHByZXZlbnQgdGhlIGxvYWRlciBmcm9tIGJlaW5nIHN0dWNrIGluIHRoZVxuICAgICAgLy8gV0FJVElORyBzdGF0ZSBpbmRlZmluaXRlbHkuXG4gICAgICB0aGlzLnN0YXRlID0gJ1JFQURZJztcblxuICAgICAgLy8gZG9uJ3Qgd2FpdCBmb3IgYnVmZmVyIGNoZWNrIHRpbWVvdXRzIHRvIGJlZ2luIGZldGNoaW5nIHRoZVxuICAgICAgLy8gbmV4dCBzZWdtZW50XG4gICAgICBpZiAoIXRoaXMucGF1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5tb25pdG9yQnVmZmVyXygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFib3J0IGFsbCBwZW5kaW5nIHhociByZXF1ZXN0cyBhbmQgbnVsbCBhbnkgcGVuZGluZyBzZWdlbWVudHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Fib3J0XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0XygpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdTZWdtZW50Xykge1xuICAgICAgICB0aGlzLnBlbmRpbmdTZWdtZW50Xy5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFyIG91dCB0aGUgc2VnbWVudCBiZWluZyBwcm9jZXNzZWRcbiAgICAgIHRoaXMucGVuZGluZ1NlZ21lbnRfID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgYW4gZXJyb3Igb24gdGhlIHNlZ21lbnQgbG9hZGVyIGFuZCBudWxsIG91dCBhbnkgcGVuZGluZyBzZWdlbWVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIHRoZSBlcnJvciB0byBzZXQgb24gdGhlIFNlZ21lbnRMb2FkZXJcbiAgICAgKiBAcmV0dXJuIHtFcnJvcn0gdGhlIGVycm9yIHRoYXQgd2FzIHNldCBvciB0aGF0IGlzIGN1cnJlbnRseSBzZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICAgIGlmICh0eXBlb2YgX2Vycm9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmVycm9yXyA9IF9lcnJvcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wZW5kaW5nU2VnbWVudF8gPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuZXJyb3JfO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuZE9mU3RyZWFtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kT2ZTdHJlYW0oKSB7XG4gICAgICB0aGlzLmVuZGVkXyA9IHRydWU7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2VuZGVkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIHRpbWUgcmFuZ2VzIGFyZSBidWZmZXJlZFxuICAgICAqXG4gICAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgICAqICAgICAgICAgVGltZVJhbmdlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgYnVmZmVyZWQgcmFuZ2VzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2J1ZmZlcmVkXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1ZmZlcmVkXygpIHtcbiAgICAgIGlmICghdGhpcy5zb3VyY2VVcGRhdGVyXykge1xuICAgICAgICByZXR1cm4gdmlkZW9qcyQxLmNyZWF0ZVRpbWVSYW5nZXMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlVXBkYXRlcl8uYnVmZmVyZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFuZCBzZXRzIGluaXQgc2VnbWVudCBmb3IgdGhlIHByb3ZpZGVkIG1hcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAgICAqICAgICAgICBUaGUgbWFwIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluaXQgc2VnbWVudCB0byBnZXQgb3Igc2V0XG4gICAgICogQHBhcmFtIHtCb29sZWFuPX0gc2V0XG4gICAgICogICAgICAgIElmIHRydWUsIHRoZSBpbml0IHNlZ21lbnQgZm9yIHRoZSBwcm92aWRlZCBtYXAgc2hvdWxkIGJlIHNhdmVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqICAgICAgICAgbWFwIG9iamVjdCBmb3IgZGVzaXJlZCBpbml0IHNlZ21lbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5pdFNlZ21lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0U2VnbWVudChtYXApIHtcbiAgICAgIHZhciBzZXQkJDEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoIW1hcCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkID0gaW5pdFNlZ21lbnRJZChtYXApO1xuICAgICAgdmFyIHN0b3JlZE1hcCA9IHRoaXMuaW5pdFNlZ21lbnRzX1tpZF07XG5cbiAgICAgIGlmIChzZXQkJDEgJiYgIXN0b3JlZE1hcCAmJiBtYXAuYnl0ZXMpIHtcbiAgICAgICAgdGhpcy5pbml0U2VnbWVudHNfW2lkXSA9IHN0b3JlZE1hcCA9IHtcbiAgICAgICAgICByZXNvbHZlZFVyaTogbWFwLnJlc29sdmVkVXJpLFxuICAgICAgICAgIGJ5dGVyYW5nZTogbWFwLmJ5dGVyYW5nZSxcbiAgICAgICAgICBieXRlczogbWFwLmJ5dGVzXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9yZWRNYXAgfHwgbWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbGwgY29uZmlndXJhdGlvbiByZXF1aXJlZCBmb3IgbG9hZGluZyBpcyBwcmVzZW50LCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBhbGwgY29uZmlndXJhdGlvbiBpcyByZWFkeSBmb3IgbG9hZGluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NvdWxkQmVnaW5Mb2FkaW5nXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvdWxkQmVnaW5Mb2FkaW5nXygpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsYXlsaXN0XyAmJiAoXG4gICAgICAvLyB0aGUgc291cmNlIHVwZGF0ZXIgaXMgY3JlYXRlZCB3aGVuIGluaXRfIGlzIGNhbGxlZCwgc28gZWl0aGVyIGhhdmluZyBhXG4gICAgICAvLyBzb3VyY2UgdXBkYXRlciBvciBiZWluZyBpbiB0aGUgSU5JVCBzdGF0ZSB3aXRoIGEgbWltZVR5cGUgaXMgZW5vdWdoXG4gICAgICAvLyB0byBzYXkgd2UgaGF2ZSBhbGwgdGhlIG5lZWRlZCBjb25maWd1cmF0aW9uIHRvIHN0YXJ0IGxvYWRpbmcuXG4gICAgICB0aGlzLnNvdXJjZVVwZGF0ZXJfIHx8IHRoaXMubWltZVR5cGVfICYmIHRoaXMuc3RhdGUgPT09ICdJTklUJykgJiYgIXRoaXMucGF1c2VkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbG9hZCBhIHBsYXlsaXN0IGFuZCBzdGFydCB0byBmaWxsIHRoZSBidWZmZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbG9hZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICAvLyB1bi1wYXVzZVxuICAgICAgdGhpcy5tb25pdG9yQnVmZmVyXygpO1xuXG4gICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIGEgcGxheWxpc3QgeWV0LCBrZWVwIHdhaXRpbmcgZm9yIG9uZSB0byBiZVxuICAgICAgLy8gc3BlY2lmaWVkXG4gICAgICBpZiAoIXRoaXMucGxheWxpc3RfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdCBwbGFjZSBmb3IgdGhpc1xuICAgICAgdGhpcy5zeW5jQ29udHJvbGxlcl8uc2V0RGF0ZVRpbWVNYXBwaW5nKHRoaXMucGxheWxpc3RfKTtcblxuICAgICAgLy8gaWYgYWxsIHRoZSBjb25maWd1cmF0aW9uIGlzIHJlYWR5LCBpbml0aWFsaXplIGFuZCBiZWdpbiBsb2FkaW5nXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0lOSVQnICYmIHRoaXMuY291bGRCZWdpbkxvYWRpbmdfKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdF8oKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBwcm9jZXNzaW5nIGEgc2VnbWVudCBhbHJlYWR5LCBkb24ndFxuICAgICAgLy8ga2ljayBvZmYgYW4gYWRkaXRpb25hbCBzZWdtZW50IHJlcXVlc3RcbiAgICAgIGlmICghdGhpcy5jb3VsZEJlZ2luTG9hZGluZ18oKSB8fCB0aGlzLnN0YXRlICE9PSAnUkVBRFknICYmIHRoaXMuc3RhdGUgIT09ICdJTklUJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGUgPSAnUkVBRFknO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uY2UgYWxsIHRoZSBzdGFydGluZyBwYXJhbWV0ZXJzIGhhdmUgYmVlbiBzcGVjaWZpZWQsIGJlZ2luXG4gICAgICogb3BlcmF0aW9uLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBpbnZva2VkIGZyb20gdGhlIElOSVRcbiAgICAgKiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luaXRfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdF8oKSB7XG4gICAgICB0aGlzLnN0YXRlID0gJ1JFQURZJztcbiAgICAgIHRoaXMuc291cmNlVXBkYXRlcl8gPSBuZXcgU291cmNlVXBkYXRlcih0aGlzLm1lZGlhU291cmNlXywgdGhpcy5taW1lVHlwZV8sIHRoaXMubG9hZGVyVHlwZV8sIHRoaXMuc291cmNlQnVmZmVyRW1pdHRlcl8pO1xuICAgICAgdGhpcy5yZXNldEV2ZXJ5dGhpbmcoKTtcbiAgICAgIHJldHVybiB0aGlzLm1vbml0b3JCdWZmZXJfKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IGEgcGxheWxpc3Qgb24gdGhlIHNlZ21lbnQgbG9hZGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BsYXlsaXN0TG9hZGVyfSBtZWRpYSB0aGUgcGxheWxpc3QgdG8gc2V0IG9uIHRoZSBzZWdtZW50IGxvYWRlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwbGF5bGlzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXlsaXN0KG5ld1BsYXlsaXN0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGlmICghbmV3UGxheWxpc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2xkUGxheWxpc3QgPSB0aGlzLnBsYXlsaXN0XztcbiAgICAgIHZhciBzZWdtZW50SW5mbyA9IHRoaXMucGVuZGluZ1NlZ21lbnRfO1xuXG4gICAgICB0aGlzLnBsYXlsaXN0XyA9IG5ld1BsYXlsaXN0O1xuICAgICAgdGhpcy54aHJPcHRpb25zXyA9IG9wdGlvbnM7XG5cbiAgICAgIC8vIHdoZW4gd2UgaGF2ZW4ndCBzdGFydGVkIHBsYXlpbmcgeWV0LCB0aGUgc3RhcnQgb2YgYSBsaXZlIHBsYXlsaXN0XG4gICAgICAvLyBpcyBhbHdheXMgb3VyIHplcm8tdGltZSBzbyBmb3JjZSBhIHN5bmMgdXBkYXRlIGVhY2ggdGltZSB0aGUgcGxheWxpc3RcbiAgICAgIC8vIGlzIHJlZnJlc2hlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgIGlmICghdGhpcy5oYXNQbGF5ZWRfKCkpIHtcbiAgICAgICAgbmV3UGxheWxpc3Quc3luY0luZm8gPSB7XG4gICAgICAgICAgbWVkaWFTZXF1ZW5jZTogbmV3UGxheWxpc3QubWVkaWFTZXF1ZW5jZSxcbiAgICAgICAgICB0aW1lOiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBvbGRJZCA9IG9sZFBsYXlsaXN0ID8gb2xkUGxheWxpc3QuaWQgOiBudWxsO1xuXG4gICAgICB0aGlzLmxvZ2dlcl8oJ3BsYXlsaXN0IHVwZGF0ZSBbJyArIG9sZElkICsgJyA9PiAnICsgbmV3UGxheWxpc3QuaWQgKyAnXScpO1xuXG4gICAgICAvLyBpbiBWT0QsIHRoaXMgaXMgYWx3YXlzIGEgcmVuZGl0aW9uIHN3aXRjaCAob3Igd2UgdXBkYXRlZCBvdXIgc3luY0luZm8gYWJvdmUpXG4gICAgICAvLyBpbiBMSVZFLCB3ZSBhbHdheXMgd2FudCB0byB1cGRhdGUgd2l0aCBuZXcgcGxheWxpc3RzIChpbmNsdWRpbmcgcmVmcmVzaGVzKVxuICAgICAgdGhpcy50cmlnZ2VyKCdzeW5jaW5mb3VwZGF0ZScpO1xuXG4gICAgICAvLyBpZiB3ZSB3ZXJlIHVucGF1c2VkIGJ1dCB3YWl0aW5nIGZvciBhIHBsYXlsaXN0LCBzdGFydFxuICAgICAgLy8gYnVmZmVyaW5nIG5vd1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdJTklUJyAmJiB0aGlzLmNvdWxkQmVnaW5Mb2FkaW5nXygpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXRfKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb2xkUGxheWxpc3QgfHwgb2xkUGxheWxpc3QudXJpICE9PSBuZXdQbGF5bGlzdC51cmkpIHtcbiAgICAgICAgaWYgKHRoaXMubWVkaWFJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHdlIG11c3QgXCJyZXN5bmNcIiB0aGUgc2VnbWVudCBsb2FkZXIgd2hlbiB3ZSBzd2l0Y2ggcmVuZGl0aW9ucyBhbmRcbiAgICAgICAgICAvLyB0aGUgc2VnbWVudCBsb2FkZXIgaXMgYWxyZWFkeSBzeW5jZWQgdG8gdGhlIHByZXZpb3VzIHJlbmRpdGlvblxuICAgICAgICAgIHRoaXMucmVzeW5jTG9hZGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgcmVzdCBvZiB0aGlzIGZ1bmN0aW9uIGRlcGVuZHMgb24gYG9sZFBsYXlsaXN0YCBiZWluZyBkZWZpbmVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgcmVsb2FkZWQgdGhlIHNhbWUgcGxheWxpc3Qgc28gd2UgYXJlIGluIGEgbGl2ZSBzY2VuYXJpb1xuICAgICAgLy8gYW5kIHdlIHdpbGwgbGlrZWx5IG5lZWQgdG8gYWRqdXN0IHRoZSBtZWRpYUluZGV4XG4gICAgICB2YXIgbWVkaWFTZXF1ZW5jZURpZmYgPSBuZXdQbGF5bGlzdC5tZWRpYVNlcXVlbmNlIC0gb2xkUGxheWxpc3QubWVkaWFTZXF1ZW5jZTtcblxuICAgICAgdGhpcy5sb2dnZXJfKCdsaXZlIHdpbmRvdyBzaGlmdCBbJyArIG1lZGlhU2VxdWVuY2VEaWZmICsgJ10nKTtcblxuICAgICAgLy8gdXBkYXRlIHRoZSBtZWRpYUluZGV4IG9uIHRoZSBTZWdtZW50TG9hZGVyXG4gICAgICAvLyB0aGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHdlIGNhbiBhYm9ydCBhIHJlcXVlc3QgYW5kIHRoaXMgdmFsdWUgbXVzdCBiZVxuICAgICAgLy8gZXF1YWwgdG8gdGhlIGxhc3QgYXBwZW5kZWQgbWVkaWFJbmRleFxuICAgICAgaWYgKHRoaXMubWVkaWFJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm1lZGlhSW5kZXggLT0gbWVkaWFTZXF1ZW5jZURpZmY7XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgbWVkaWFJbmRleCBvbiB0aGUgU2VnbWVudEluZm8gb2JqZWN0XG4gICAgICAvLyB0aGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHdlIHdpbGwgdXBkYXRlIHRoaXMubWVkaWFJbmRleCB3aXRoIHRoaXMgdmFsdWVcbiAgICAgIC8vIGluIGBoYW5kbGVVcGRhdGVFbmRfYCBhZnRlciB0aGUgc2VnbWVudCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgYXBwZW5kZWRcbiAgICAgIGlmIChzZWdtZW50SW5mbykge1xuICAgICAgICBzZWdtZW50SW5mby5tZWRpYUluZGV4IC09IG1lZGlhU2VxdWVuY2VEaWZmO1xuXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSByZWZlcmVuY2VkIHNlZ21lbnQgc28gdGhhdCB0aW1pbmcgaW5mb3JtYXRpb24gaXNcbiAgICAgICAgLy8gc2F2ZWQgZm9yIHRoZSBuZXcgcGxheWxpc3QncyBzZWdtZW50LCBob3dldmVyLCBpZiB0aGUgc2VnbWVudCBmZWxsIG9mZiB0aGVcbiAgICAgICAgLy8gcGxheWxpc3QsIHdlIGNhbiBsZWF2ZSB0aGUgb2xkIHJlZmVyZW5jZSBhbmQganVzdCBsb3NlIHRoZSB0aW1pbmcgaW5mb1xuICAgICAgICBpZiAoc2VnbWVudEluZm8ubWVkaWFJbmRleCA+PSAwKSB7XG4gICAgICAgICAgc2VnbWVudEluZm8uc2VnbWVudCA9IG5ld1BsYXlsaXN0LnNlZ21lbnRzW3NlZ21lbnRJbmZvLm1lZGlhSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3luY0NvbnRyb2xsZXJfLnNhdmVFeHBpcmVkU2VnbWVudEluZm8ob2xkUGxheWxpc3QsIG5ld1BsYXlsaXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50IHRoZSBsb2FkZXIgZnJvbSBmZXRjaGluZyBhZGRpdGlvbmFsIHNlZ21lbnRzLiBJZiB0aGVyZVxuICAgICAqIGlzIGEgc2VnbWVudCByZXF1ZXN0IG91dHN0YW5kaW5nLCBpdCB3aWxsIGZpbmlzaCBwcm9jZXNzaW5nXG4gICAgICogYmVmb3JlIHRoZSBsb2FkZXIgaGFsdHMuIEEgc2VnbWVudCBsb2FkZXIgY2FuIGJlIHVucGF1c2VkIGJ5XG4gICAgICogY2FsbGluZyBsb2FkKCkuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BhdXNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICBpZiAodGhpcy5jaGVja0J1ZmZlclRpbWVvdXRfKSB7XG4gICAgICAgIHdpbmRvdyQxLmNsZWFyVGltZW91dCh0aGlzLmNoZWNrQnVmZmVyVGltZW91dF8pO1xuXG4gICAgICAgIHRoaXMuY2hlY2tCdWZmZXJUaW1lb3V0XyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBzZWdtZW50IGxvYWRlciBpcyBmZXRjaGluZyBhZGRpdGlvbmFsXG4gICAgICogc2VnbWVudHMgd2hlbiBnaXZlbiB0aGUgb3Bwb3J0dW5pdHkuIFRoaXMgcHJvcGVydHkgY2FuIGJlXG4gICAgICogbW9kaWZpZWQgdGhyb3VnaCBjYWxscyB0byBwYXVzZSgpIGFuZCBsb2FkKCkuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BhdXNlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdXNlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoZWNrQnVmZmVyVGltZW91dF8gPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlL3NldCB0aGUgZm9sbG93aW5nIG1pbWV0eXBlIG9uIHRoZSBTb3VyY2VCdWZmZXIgdGhyb3VnaCBhXG4gICAgICogU291cmNlVXBkYXRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBtaW1lIHR5cGUgc3RyaW5nIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VCdWZmZXJFbWl0dGVyIGFuIGV2ZW50IGVtaXR0ZXIgdGhhdCBmaXJlcyB3aGVuIGEgc291cmNlIGJ1ZmZlclxuICAgICAqIGlzIGFkZGVkIHRvIHRoZSBtZWRpYSBzb3VyY2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWltZVR5cGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW1lVHlwZShfbWltZVR5cGUsIHNvdXJjZUJ1ZmZlckVtaXR0ZXIpIHtcbiAgICAgIGlmICh0aGlzLm1pbWVUeXBlXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWltZVR5cGVfID0gX21pbWVUeXBlO1xuICAgICAgdGhpcy5zb3VyY2VCdWZmZXJFbWl0dGVyXyA9IHNvdXJjZUJ1ZmZlckVtaXR0ZXI7XG4gICAgICAvLyBpZiB3ZSB3ZXJlIHVucGF1c2VkIGJ1dCB3YWl0aW5nIGZvciBhIHNvdXJjZVVwZGF0ZXIsIHN0YXJ0XG4gICAgICAvLyBidWZmZXJpbmcgbm93XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0lOSVQnICYmIHRoaXMuY291bGRCZWdpbkxvYWRpbmdfKCkpIHtcbiAgICAgICAgdGhpcy5pbml0XygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbGwgdGhlIGJ1ZmZlcmVkIGRhdGEgYW5kIHJlc2V0IHRoZSBTZWdtZW50TG9hZGVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0RXZlcnl0aGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0RXZlcnl0aGluZygpIHtcbiAgICAgIHRoaXMuZW5kZWRfID0gZmFsc2U7XG4gICAgICB0aGlzLnJlc2V0TG9hZGVyKCk7XG4gICAgICB0aGlzLnJlbW92ZSgwLCB0aGlzLmR1cmF0aW9uXygpKTtcbiAgICAgIHRoaXMudHJpZ2dlcigncmVzZXRldmVyeXRoaW5nJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yY2UgdGhlIFNlZ21lbnRMb2FkZXIgdG8gcmVzeW5jIGFuZCBzdGFydCBsb2FkaW5nIGFyb3VuZCB0aGUgY3VycmVudFRpbWUgaW5zdGVhZFxuICAgICAqIG9mIHN0YXJ0aW5nIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICAgICAqXG4gICAgICogVXNlZnVsIGZvciBmYXN0IHF1YWxpdHkgY2hhbmdlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldExvYWRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0TG9hZGVyKCkge1xuICAgICAgdGhpcy5mZXRjaEF0QnVmZmVyXyA9IGZhbHNlO1xuICAgICAgdGhpcy5yZXN5bmNMb2FkZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZSB0aGUgU2VnbWVudExvYWRlciB0byByZXN0YXJ0IHN5bmNocm9uaXphdGlvbiBhbmQgbWFrZSBhIGNvbnNlcnZhdGl2ZSBndWVzc1xuICAgICAqIGJlZm9yZSByZXR1cm5pbmcgdG8gdGhlIHNpbXBsZSB3YWxrLWZvcndhcmQgbWV0aG9kXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlc3luY0xvYWRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3luY0xvYWRlcigpIHtcbiAgICAgIHRoaXMubWVkaWFJbmRleCA9IG51bGw7XG4gICAgICB0aGlzLnN5bmNQb2ludF8gPSBudWxsO1xuICAgICAgdGhpcy5hYm9ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbnkgZGF0YSBpbiB0aGUgc291cmNlIGJ1ZmZlciBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgdGltZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgLSB0aGUgc3RhcnQgdGltZSBvZiB0aGUgcmVnaW9uIHRvIHJlbW92ZSBmcm9tIHRoZSBidWZmZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIC0gdGhlIGVuZCB0aW1lIG9mIHRoZSByZWdpb24gdG8gcmVtb3ZlIGZyb20gdGhlIGJ1ZmZlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKHRoaXMuc291cmNlVXBkYXRlcl8pIHtcbiAgICAgICAgdGhpcy5zb3VyY2VVcGRhdGVyXy5yZW1vdmUoc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICByZW1vdmVDdWVzRnJvbVRyYWNrKHN0YXJ0LCBlbmQsIHRoaXMuc2VnbWVudE1ldGFkYXRhVHJhY2tfKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAocmUtKXNjaGVkdWxlIG1vbml0b3JCdWZmZXJUaWNrXyB0byBydW4gYXMgc29vbiBhcyBwb3NzaWJsZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbW9uaXRvckJ1ZmZlcl8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb25pdG9yQnVmZmVyXygpIHtcbiAgICAgIGlmICh0aGlzLmNoZWNrQnVmZmVyVGltZW91dF8pIHtcbiAgICAgICAgd2luZG93JDEuY2xlYXJUaW1lb3V0KHRoaXMuY2hlY2tCdWZmZXJUaW1lb3V0Xyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hlY2tCdWZmZXJUaW1lb3V0XyA9IHdpbmRvdyQxLnNldFRpbWVvdXQodGhpcy5tb25pdG9yQnVmZmVyVGlja18uYmluZCh0aGlzKSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXMgbG9uZyBhcyB0aGUgU2VnbWVudExvYWRlciBpcyBpbiB0aGUgUkVBRFkgc3RhdGUsIHBlcmlvZGljYWxseVxuICAgICAqIGludm9rZSBmaWxsQnVmZmVyXygpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbW9uaXRvckJ1ZmZlclRpY2tfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9uaXRvckJ1ZmZlclRpY2tfKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdSRUFEWScpIHtcbiAgICAgICAgdGhpcy5maWxsQnVmZmVyXygpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jaGVja0J1ZmZlclRpbWVvdXRfKSB7XG4gICAgICAgIHdpbmRvdyQxLmNsZWFyVGltZW91dCh0aGlzLmNoZWNrQnVmZmVyVGltZW91dF8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoZWNrQnVmZmVyVGltZW91dF8gPSB3aW5kb3ckMS5zZXRUaW1lb3V0KHRoaXMubW9uaXRvckJ1ZmZlclRpY2tfLmJpbmQodGhpcyksIENIRUNLX0JVRkZFUl9ERUxBWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmlsbCB0aGUgYnVmZmVyIHdpdGggc2VnZW1lbnRzIHVubGVzcyB0aGUgc291cmNlQnVmZmVycyBhcmVcbiAgICAgKiBjdXJyZW50bHkgdXBkYXRpbmdcbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgZXZlciBiZSBjYWxsZWQgYnkgbW9uaXRvckJ1ZmZlcl9cbiAgICAgKiBhbmQgbmV2ZXIgZGlyZWN0bHlcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbGxCdWZmZXJfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsbEJ1ZmZlcl8oKSB7XG4gICAgICBpZiAodGhpcy5zb3VyY2VVcGRhdGVyXy51cGRhdGluZygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnN5bmNQb2ludF8pIHtcbiAgICAgICAgdGhpcy5zeW5jUG9pbnRfID0gdGhpcy5zeW5jQ29udHJvbGxlcl8uZ2V0U3luY1BvaW50KHRoaXMucGxheWxpc3RfLCB0aGlzLmR1cmF0aW9uXygpLCB0aGlzLmN1cnJlbnRUaW1lbGluZV8sIHRoaXMuY3VycmVudFRpbWVfKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZWUgaWYgd2UgbmVlZCB0byBiZWdpbiBsb2FkaW5nIGltbWVkaWF0ZWx5XG4gICAgICB2YXIgc2VnbWVudEluZm8gPSB0aGlzLmNoZWNrQnVmZmVyXyh0aGlzLmJ1ZmZlcmVkXygpLCB0aGlzLnBsYXlsaXN0XywgdGhpcy5tZWRpYUluZGV4LCB0aGlzLmhhc1BsYXllZF8oKSwgdGhpcy5jdXJyZW50VGltZV8oKSwgdGhpcy5zeW5jUG9pbnRfKTtcblxuICAgICAgaWYgKCFzZWdtZW50SW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0VuZE9mU3RyZWFtID0gZGV0ZWN0RW5kT2ZTdHJlYW0odGhpcy5wbGF5bGlzdF8sIHRoaXMubWVkaWFTb3VyY2VfLCBzZWdtZW50SW5mby5tZWRpYUluZGV4KTtcblxuICAgICAgaWYgKGlzRW5kT2ZTdHJlYW0pIHtcbiAgICAgICAgdGhpcy5lbmRPZlN0cmVhbSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWdtZW50SW5mby5tZWRpYUluZGV4ID09PSB0aGlzLnBsYXlsaXN0Xy5zZWdtZW50cy5sZW5ndGggLSAxICYmIHRoaXMubWVkaWFTb3VyY2VfLnJlYWR5U3RhdGUgPT09ICdlbmRlZCcgJiYgIXRoaXMuc2Vla2luZ18oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHdpbGwgbmVlZCB0byBjaGFuZ2UgdGltZXN0YW1wT2Zmc2V0IG9mIHRoZSBzb3VyY2VCdWZmZXIgaWYgZWl0aGVyIG9mXG4gICAgICAvLyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gICAgICAvLyAtIFRoZSBzZWdtZW50LnRpbWVsaW5lICE9PSB0aGlzLmN1cnJlbnRUaW1lbGluZVxuICAgICAgLy8gICAod2UgYXJlIGNyb3NzaW5nIGEgZGlzY29udGludWl0eSBzb21laG93KVxuICAgICAgLy8gLSBUaGUgXCJ0aW1lc3RhbXBPZmZzZXRcIiBmb3IgdGhlIHN0YXJ0IG9mIHRoaXMgc2VnbWVudCBpcyBsZXNzIHRoYW5cbiAgICAgIC8vICAgdGhlIGN1cnJlbnRseSBzZXQgdGltZXN0YW1wT2Zmc2V0XG4gICAgICBpZiAoc2VnbWVudEluZm8udGltZWxpbmUgIT09IHRoaXMuY3VycmVudFRpbWVsaW5lXyB8fCBzZWdtZW50SW5mby5zdGFydE9mU2VnbWVudCAhPT0gbnVsbCAmJiBzZWdtZW50SW5mby5zdGFydE9mU2VnbWVudCA8IHRoaXMuc291cmNlVXBkYXRlcl8udGltZXN0YW1wT2Zmc2V0KCkpIHtcbiAgICAgICAgdGhpcy5zeW5jQ29udHJvbGxlcl8ucmVzZXQoKTtcbiAgICAgICAgc2VnbWVudEluZm8udGltZXN0YW1wT2Zmc2V0ID0gc2VnbWVudEluZm8uc3RhcnRPZlNlZ21lbnQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9hZFNlZ21lbnRfKHNlZ21lbnRJbmZvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoYXQgc2VnbWVudCByZXF1ZXN0IHNob3VsZCBiZSBtYWRlLCBnaXZlbiBjdXJyZW50IHBsYXliYWNrXG4gICAgICogc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RpbWVSYW5nZXN9IGJ1ZmZlcmVkIC0gdGhlIHN0YXRlIG9mIHRoZSBidWZmZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgLSB0aGUgcGxheWxpc3Qgb2JqZWN0IHRvIGZldGNoIHNlZ21lbnRzIGZyb21cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWVkaWFJbmRleCAtIHRoZSBwcmV2aW91cyBtZWRpYUluZGV4IGZldGNoZWQgb3IgbnVsbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaGFzUGxheWVkIC0gYSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB3ZSBoYXZlIHBsYXllZCBvciBub3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3VycmVudFRpbWUgLSB0aGUgcGxheWJhY2sgcG9zaXRpb24gaW4gc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW5jUG9pbnQgLSBhIHNlZ21lbnQgaW5mbyBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlXG4gICAgICogQHJldHVybnMge09iamVjdH0gYSBzZWdtZW50IHJlcXVlc3Qgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBzZWdtZW50IHRvIGxvYWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2hlY2tCdWZmZXJfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tCdWZmZXJfKGJ1ZmZlcmVkLCBwbGF5bGlzdCwgbWVkaWFJbmRleCwgaGFzUGxheWVkLCBjdXJyZW50VGltZSwgc3luY1BvaW50KSB7XG4gICAgICB2YXIgbGFzdEJ1ZmZlcmVkRW5kID0gMDtcbiAgICAgIHZhciBzdGFydE9mU2VnbWVudCA9IHZvaWQgMDtcblxuICAgICAgaWYgKGJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgICBsYXN0QnVmZmVyZWRFbmQgPSBidWZmZXJlZC5lbmQoYnVmZmVyZWQubGVuZ3RoIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBidWZmZXJlZFRpbWUgPSBNYXRoLm1heCgwLCBsYXN0QnVmZmVyZWRFbmQgLSBjdXJyZW50VGltZSk7XG5cbiAgICAgIGlmICghcGxheWxpc3Quc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGVyZSBpcyBwbGVudHkgb2YgY29udGVudCBidWZmZXJlZCwgYW5kIHRoZSB2aWRlbyBoYXNcbiAgICAgIC8vIGJlZW4gcGxheWVkIGJlZm9yZSByZWxheCBmb3IgYXdoaWxlXG4gICAgICBpZiAoYnVmZmVyZWRUaW1lID49IHRoaXMuZ29hbEJ1ZmZlckxlbmd0aF8oKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIHZpZGVvIGhhcyBub3QgeWV0IHBsYXllZCBvbmNlLCBhbmQgd2UgYWxyZWFkeSBoYXZlXG4gICAgICAvLyBvbmUgc2VnbWVudCBkb3dubG9hZGVkIGRvIG5vdGhpbmdcbiAgICAgIGlmICghaGFzUGxheWVkICYmIGJ1ZmZlcmVkVGltZSA+PSAxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBXaGVuIHRoZSBzeW5jUG9pbnQgaXMgbnVsbCwgdGhlcmUgaXMgbm8gd2F5IG9mIGRldGVybWluaW5nIGEgZ29vZFxuICAgICAgLy8gY29uc2VydmF0aXZlIHNlZ21lbnQgaW5kZXggdG8gZmV0Y2ggZnJvbVxuICAgICAgLy8gVGhlIGJlc3QgdGhpbmcgdG8gZG8gaGVyZSBpcyB0byBnZXQgdGhlIGtpbmQgb2Ygc3luYy1wb2ludCBkYXRhIGJ5XG4gICAgICAvLyBtYWtpbmcgYSByZXF1ZXN0XG4gICAgICBpZiAoc3luY1BvaW50ID09PSBudWxsKSB7XG4gICAgICAgIG1lZGlhSW5kZXggPSB0aGlzLmdldFN5bmNTZWdtZW50Q2FuZGlkYXRlXyhwbGF5bGlzdCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlU2VnbWVudEluZm9fKHBsYXlsaXN0LCBtZWRpYUluZGV4LCBudWxsLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gVW5kZXIgbm9ybWFsIHBsYXliYWNrIGNvbmRpdGlvbnMgZmV0Y2hpbmcgaXMgYSBzaW1wbGUgd2FsayBmb3J3YXJkXG4gICAgICBpZiAobWVkaWFJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHBsYXlsaXN0LnNlZ21lbnRzW21lZGlhSW5kZXhdO1xuXG4gICAgICAgIGlmIChzZWdtZW50ICYmIHNlZ21lbnQuZW5kKSB7XG4gICAgICAgICAgc3RhcnRPZlNlZ21lbnQgPSBzZWdtZW50LmVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydE9mU2VnbWVudCA9IGxhc3RCdWZmZXJlZEVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVNlZ21lbnRJbmZvXyhwbGF5bGlzdCwgbWVkaWFJbmRleCArIDEsIHN0YXJ0T2ZTZWdtZW50LCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZXJlIGlzIGEgc3luYy1wb2ludCBidXQgdGhlIGxhY2sgb2YgYSBtZWRpYUluZGV4IGluZGljYXRlcyB0aGF0XG4gICAgICAvLyB3ZSBuZWVkIHRvIG1ha2UgYSBnb29kIGNvbnNlcnZhdGl2ZSBndWVzcyBhYm91dCB3aGljaCBzZWdtZW50IHRvXG4gICAgICAvLyBmZXRjaFxuICAgICAgaWYgKHRoaXMuZmV0Y2hBdEJ1ZmZlcl8pIHtcbiAgICAgICAgLy8gRmluZCB0aGUgc2VnbWVudCBjb250YWluaW5nIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICAgICAgICB2YXIgbWVkaWFTb3VyY2VJbmZvID0gUGxheWxpc3QuZ2V0TWVkaWFJbmZvRm9yVGltZShwbGF5bGlzdCwgbGFzdEJ1ZmZlcmVkRW5kLCBzeW5jUG9pbnQuc2VnbWVudEluZGV4LCBzeW5jUG9pbnQudGltZSk7XG5cbiAgICAgICAgbWVkaWFJbmRleCA9IG1lZGlhU291cmNlSW5mby5tZWRpYUluZGV4O1xuICAgICAgICBzdGFydE9mU2VnbWVudCA9IG1lZGlhU291cmNlSW5mby5zdGFydFRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaW5kIHRoZSBzZWdtZW50IGNvbnRhaW5pbmcgY3VycmVudFRpbWVcbiAgICAgICAgdmFyIF9tZWRpYVNvdXJjZUluZm8gPSBQbGF5bGlzdC5nZXRNZWRpYUluZm9Gb3JUaW1lKHBsYXlsaXN0LCBjdXJyZW50VGltZSwgc3luY1BvaW50LnNlZ21lbnRJbmRleCwgc3luY1BvaW50LnRpbWUpO1xuXG4gICAgICAgIG1lZGlhSW5kZXggPSBfbWVkaWFTb3VyY2VJbmZvLm1lZGlhSW5kZXg7XG4gICAgICAgIHN0YXJ0T2ZTZWdtZW50ID0gX21lZGlhU291cmNlSW5mby5zdGFydFRpbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlU2VnbWVudEluZm9fKHBsYXlsaXN0LCBtZWRpYUluZGV4LCBzdGFydE9mU2VnbWVudCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWdtZW50IGxvYWRlciBoYXMgbm8gcmVjb3Vyc2UgZXhjZXB0IHRvIGZldGNoIGEgc2VnbWVudCBpbiB0aGVcbiAgICAgKiBjdXJyZW50IHBsYXlsaXN0IGFuZCB1c2UgdGhlIGludGVybmFsIHRpbWVzdGFtcHMgaW4gdGhhdCBzZWdtZW50IHRvXG4gICAgICogZ2VuZXJhdGUgYSBzeW5jUG9pbnQuIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGdvb2QgY2FuZGlkYXRlIGluZGV4XG4gICAgICogZm9yIHRoYXQgcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5bGlzdCAtIHRoZSBwbGF5bGlzdCBvYmplY3QgdG8gbG9vayBmb3IgYVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IEFuIGluZGV4IG9mIGEgc2VnbWVudCBmcm9tIHRoZSBwbGF5bGlzdCB0byBsb2FkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFN5bmNTZWdtZW50Q2FuZGlkYXRlXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN5bmNTZWdtZW50Q2FuZGlkYXRlXyhwbGF5bGlzdCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lbGluZV8gPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VnbWVudEluZGV4QXJyYXkgPSBwbGF5bGlzdC5zZWdtZW50cy5tYXAoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0aW1lbGluZTogcy50aW1lbGluZSxcbiAgICAgICAgICBzZWdtZW50SW5kZXg6IGlcbiAgICAgICAgfTtcbiAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcy50aW1lbGluZSA9PT0gX3RoaXMyLmN1cnJlbnRUaW1lbGluZV87XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNlZ21lbnRJbmRleEFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc2VnbWVudEluZGV4QXJyYXlbTWF0aC5taW4oc2VnbWVudEluZGV4QXJyYXkubGVuZ3RoIC0gMSwgMSldLnNlZ21lbnRJbmRleDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGgubWF4KHBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aCAtIDEsIDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dlbmVyYXRlU2VnbWVudEluZm9fJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVTZWdtZW50SW5mb18ocGxheWxpc3QsIG1lZGlhSW5kZXgsIHN0YXJ0T2ZTZWdtZW50LCBpc1N5bmNSZXF1ZXN0KSB7XG4gICAgICBpZiAobWVkaWFJbmRleCA8IDAgfHwgbWVkaWFJbmRleCA+PSBwbGF5bGlzdC5zZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdtZW50ID0gcGxheWxpc3Quc2VnbWVudHNbbWVkaWFJbmRleF07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3RJZDogJ3NlZ21lbnQtbG9hZGVyLScgKyBNYXRoLnJhbmRvbSgpLFxuICAgICAgICAvLyByZXNvbHZlIHRoZSBzZWdtZW50IFVSTCByZWxhdGl2ZSB0byB0aGUgcGxheWxpc3RcbiAgICAgICAgdXJpOiBzZWdtZW50LnJlc29sdmVkVXJpLFxuICAgICAgICAvLyB0aGUgc2VnbWVudCdzIG1lZGlhSW5kZXggYXQgdGhlIHRpbWUgaXQgd2FzIHJlcXVlc3RlZFxuICAgICAgICBtZWRpYUluZGV4OiBtZWRpYUluZGV4LFxuICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCB0byB1cGRhdGUgdGhlIFNlZ21lbnRMb2FkZXIncyBzdGF0ZSB3aXRoIHRoaXNcbiAgICAgICAgLy8gc2VnbWVudCdzIG1lZGlhSW5kZXhcbiAgICAgICAgaXNTeW5jUmVxdWVzdDogaXNTeW5jUmVxdWVzdCxcbiAgICAgICAgc3RhcnRPZlNlZ21lbnQ6IHN0YXJ0T2ZTZWdtZW50LFxuICAgICAgICAvLyB0aGUgc2VnbWVudCdzIHBsYXlsaXN0XG4gICAgICAgIHBsYXlsaXN0OiBwbGF5bGlzdCxcbiAgICAgICAgLy8gdW5lbmNyeXB0ZWQgYnl0ZXMgb2YgdGhlIHNlZ21lbnRcbiAgICAgICAgYnl0ZXM6IG51bGwsXG4gICAgICAgIC8vIHdoZW4gYSBrZXkgaXMgZGVmaW5lZCBmb3IgdGhpcyBzZWdtZW50LCB0aGUgZW5jcnlwdGVkIGJ5dGVzXG4gICAgICAgIGVuY3J5cHRlZEJ5dGVzOiBudWxsLFxuICAgICAgICAvLyBUaGUgdGFyZ2V0IHRpbWVzdGFtcE9mZnNldCBmb3IgdGhpcyBzZWdtZW50IHdoZW4gd2UgYXBwZW5kIGl0XG4gICAgICAgIC8vIHRvIHRoZSBzb3VyY2UgYnVmZmVyXG4gICAgICAgIHRpbWVzdGFtcE9mZnNldDogbnVsbCxcbiAgICAgICAgLy8gVGhlIHRpbWVsaW5lIHRoYXQgdGhlIHNlZ21lbnQgaXMgaW5cbiAgICAgICAgdGltZWxpbmU6IHNlZ21lbnQudGltZWxpbmUsXG4gICAgICAgIC8vIFRoZSBleHBlY3RlZCBkdXJhdGlvbiBvZiB0aGUgc2VnbWVudCBpbiBzZWNvbmRzXG4gICAgICAgIGR1cmF0aW9uOiBzZWdtZW50LmR1cmF0aW9uLFxuICAgICAgICAvLyByZXRhaW4gdGhlIHNlZ21lbnQgaW4gY2FzZSB0aGUgcGxheWxpc3QgdXBkYXRlcyB3aGlsZSBkb2luZyBhbiBhc3luYyBwcm9jZXNzXG4gICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbmV0d29yayBoYXMgZW5vdWdoIGJhbmR3aWR0aCB0byBjb21wbGV0ZSB0aGUgY3VycmVudCBzZWdtZW50XG4gICAgICogcmVxdWVzdCBpbiBhIHRpbWVseSBtYW5uZXIuIElmIG5vdCwgdGhlIHJlcXVlc3Qgd2lsbCBiZSBhYm9ydGVkIGVhcmx5IGFuZCBiYW5kd2lkdGhcbiAgICAgKiB1cGRhdGVkIHRvIHRyaWdnZXIgYSBwbGF5bGlzdCBzd2l0Y2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdHNcbiAgICAgKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgc3RhdHMgYWJvdXQgdGhlIHJlcXVlc3QgdGltaW5nIGFuZCBzaXplXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmVxdWVzdCB3YXMgYWJvcnRlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWJvcnRSZXF1ZXN0RWFybHlfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnRSZXF1ZXN0RWFybHlfKHN0YXRzKSB7XG4gICAgICBpZiAodGhpcy5obHNfLnRlY2hfLnBhdXNlZCgpIHx8XG4gICAgICAvLyBEb24ndCBhYm9ydCBpZiB0aGUgY3VycmVudCBwbGF5bGlzdCBpcyBvbiB0aGUgbG93ZXN0RW5hYmxlZFJlbmRpdGlvblxuICAgICAgLy8gVE9ETzogUmVwbGFjZSB1c2luZyB0aW1lb3V0IHdpdGggYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIHBsYXlsaXN0IGlzXG4gICAgICAvLyAgICAgICB0aGUgbG93ZXN0RW5hYmxlZFJlbmRpdGlvbi5cbiAgICAgICF0aGlzLnhock9wdGlvbnNfLnRpbWVvdXQgfHxcbiAgICAgIC8vIERvbid0IGFib3J0IGlmIHdlIGhhdmUgbm8gYmFuZHdpZHRoIGluZm9ybWF0aW9uIHRvIGVzdGltYXRlIHNlZ21lbnQgc2l6ZXNcbiAgICAgICF0aGlzLnBsYXlsaXN0Xy5hdHRyaWJ1dGVzLkJBTkRXSURUSCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhaXQgYXQgbGVhc3QgMSBzZWNvbmQgc2luY2UgdGhlIGZpcnN0IGJ5dGUgb2YgZGF0YSBoYXMgYmVlbiByZWNlaXZlZCBiZWZvcmVcbiAgICAgIC8vIHVzaW5nIHRoZSBjYWxjdWxhdGVkIGJhbmR3aWR0aCBmcm9tIHRoZSBwcm9ncmVzcyBldmVudCB0byBhbGxvdyB0aGUgYml0cmF0ZVxuICAgICAgLy8gdG8gc3RhYmlsaXplXG4gICAgICBpZiAoRGF0ZS5ub3coKSAtIChzdGF0cy5maXJzdEJ5dGVzUmVjZWl2ZWRBdCB8fCBEYXRlLm5vdygpKSA8IDEwMDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lXygpO1xuICAgICAgdmFyIG1lYXN1cmVkQmFuZHdpZHRoID0gc3RhdHMuYmFuZHdpZHRoO1xuICAgICAgdmFyIHNlZ21lbnREdXJhdGlvbiA9IHRoaXMucGVuZGluZ1NlZ21lbnRfLmR1cmF0aW9uO1xuXG4gICAgICB2YXIgcmVxdWVzdFRpbWVSZW1haW5pbmcgPSBQbGF5bGlzdC5lc3RpbWF0ZVNlZ21lbnRSZXF1ZXN0VGltZShzZWdtZW50RHVyYXRpb24sIG1lYXN1cmVkQmFuZHdpZHRoLCB0aGlzLnBsYXlsaXN0Xywgc3RhdHMuYnl0ZXNSZWNlaXZlZCk7XG5cbiAgICAgIC8vIFN1YnRyYWN0IDEgZnJvbSB0aGUgdGltZVVudGlsUmVidWZmZXIgc28gd2Ugc3RpbGwgY29uc2lkZXIgYW4gZWFybHkgYWJvcnRcbiAgICAgIC8vIGlmIHdlIGFyZSBvbmx5IGxlZnQgd2l0aCBsZXNzIHRoYW4gMSBzZWNvbmQgd2hlbiB0aGUgcmVxdWVzdCBjb21wbGV0ZXMuXG4gICAgICAvLyBBIG5lZ2F0aXZlIHRpbWVVbnRpbFJlYnVmZmVyaW5nIGluZGljYXRlcyB3ZSBhcmUgYWxyZWFkeSByZWJ1ZmZlcmluZ1xuICAgICAgdmFyIHRpbWVVbnRpbFJlYnVmZmVyJCQxID0gdGltZVVudGlsUmVidWZmZXIodGhpcy5idWZmZXJlZF8oKSwgY3VycmVudFRpbWUsIHRoaXMuaGxzXy50ZWNoXy5wbGF5YmFja1JhdGUoKSkgLSAxO1xuXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIGFib3J0aW5nIGVhcmx5IGlmIHRoZSBlc3RpbWF0ZWQgdGltZSB0byBmaW5pc2ggdGhlIGRvd25sb2FkXG4gICAgICAvLyBpcyBsYXJnZXIgdGhhbiB0aGUgZXN0aW1hdGVkIHRpbWUgdW50aWwgdGhlIHBsYXllciBydW5zIG91dCBvZiBmb3J3YXJkIGJ1ZmZlclxuICAgICAgaWYgKHJlcXVlc3RUaW1lUmVtYWluaW5nIDw9IHRpbWVVbnRpbFJlYnVmZmVyJCQxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN3aXRjaENhbmRpZGF0ZSA9IG1pblJlYnVmZmVyTWF4QmFuZHdpZHRoU2VsZWN0b3Ioe1xuICAgICAgICBtYXN0ZXI6IHRoaXMuaGxzXy5wbGF5bGlzdHMubWFzdGVyLFxuICAgICAgICBjdXJyZW50VGltZTogY3VycmVudFRpbWUsXG4gICAgICAgIGJhbmR3aWR0aDogbWVhc3VyZWRCYW5kd2lkdGgsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXygpLFxuICAgICAgICBzZWdtZW50RHVyYXRpb246IHNlZ21lbnREdXJhdGlvbixcbiAgICAgICAgdGltZVVudGlsUmVidWZmZXI6IHRpbWVVbnRpbFJlYnVmZmVyJCQxLFxuICAgICAgICBjdXJyZW50VGltZWxpbmU6IHRoaXMuY3VycmVudFRpbWVsaW5lXyxcbiAgICAgICAgc3luY0NvbnRyb2xsZXI6IHRoaXMuc3luY0NvbnRyb2xsZXJfXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFzd2l0Y2hDYW5kaWRhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVidWZmZXJpbmdJbXBhY3QgPSByZXF1ZXN0VGltZVJlbWFpbmluZyAtIHRpbWVVbnRpbFJlYnVmZmVyJCQxO1xuXG4gICAgICB2YXIgdGltZVNhdmVkQnlTd2l0Y2hpbmcgPSByZWJ1ZmZlcmluZ0ltcGFjdCAtIHN3aXRjaENhbmRpZGF0ZS5yZWJ1ZmZlcmluZ0ltcGFjdDtcblxuICAgICAgdmFyIG1pbmltdW1UaW1lU2F2aW5nID0gMC41O1xuXG4gICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSByZWJ1ZmZlcmluZywgaW5jcmVhc2UgdGhlIGFtb3VudCBvZiB2YXJpYW5jZSB3ZSBhZGQgdG8gdGhlXG4gICAgICAvLyBwb3RlbnRpYWwgcm91bmQgdHJpcCB0aW1lIG9mIHRoZSBuZXcgcmVxdWVzdCBzbyB0aGF0IHdlIGFyZSBub3QgdG9vIGFnZ3Jlc3NpdmVcbiAgICAgIC8vIHdpdGggc3dpdGNoaW5nIHRvIGEgcGxheWxpc3QgdGhhdCBtaWdodCBzYXZlIHVzIGEgZnJhY3Rpb24gb2YgYSBzZWNvbmQuXG4gICAgICBpZiAodGltZVVudGlsUmVidWZmZXIkJDEgPD0gVElNRV9GVURHRV9GQUNUT1IpIHtcbiAgICAgICAgbWluaW11bVRpbWVTYXZpbmcgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN3aXRjaENhbmRpZGF0ZS5wbGF5bGlzdCB8fCBzd2l0Y2hDYW5kaWRhdGUucGxheWxpc3QudXJpID09PSB0aGlzLnBsYXlsaXN0Xy51cmkgfHwgdGltZVNhdmVkQnlTd2l0Y2hpbmcgPCBtaW5pbXVtVGltZVNhdmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB0aGUgYmFuZHdpZHRoIHRvIHRoYXQgb2YgdGhlIGRlc2lyZWQgcGxheWxpc3QgYmVpbmcgc3VyZSB0byBzY2FsZSBieVxuICAgICAgLy8gQkFORFdJRFRIX1ZBUklBTkNFIGFuZCBhZGQgb25lIHNvIHRoZSBwbGF5bGlzdCBzZWxlY3RvciBkb2VzIG5vdCBleGNsdWRlIGl0XG4gICAgICAvLyBkb24ndCB0cmlnZ2VyIGEgYmFuZHdpZHRodXBkYXRlIGFzIHRoZSBiYW5kd2lkdGggaXMgYXJ0aWZpYWxcbiAgICAgIHRoaXMuYmFuZHdpZHRoID0gc3dpdGNoQ2FuZGlkYXRlLnBsYXlsaXN0LmF0dHJpYnV0ZXMuQkFORFdJRFRIICogQ29uZmlnLkJBTkRXSURUSF9WQVJJQU5DRSArIDE7XG4gICAgICB0aGlzLmFib3J0KCk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2Vhcmx5YWJvcnQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFhIUiBgcHJvZ3Jlc3NgIGV2ZW50IGhhbmRsZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9XG4gICAgICogICAgICAgIFRoZSBYSFIgYHByb2dyZXNzYCBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzaW1wbGVTZWdtZW50XG4gICAgICogICAgICAgIEEgc2ltcGxpZmllZCBzZWdtZW50IG9iamVjdCBjb3B5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlUHJvZ3Jlc3NfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlUHJvZ3Jlc3NfKGV2ZW50LCBzaW1wbGVTZWdtZW50KSB7XG4gICAgICBpZiAoIXRoaXMucGVuZGluZ1NlZ21lbnRfIHx8IHNpbXBsZVNlZ21lbnQucmVxdWVzdElkICE9PSB0aGlzLnBlbmRpbmdTZWdtZW50Xy5yZXF1ZXN0SWQgfHwgdGhpcy5hYm9ydFJlcXVlc3RFYXJseV8oc2ltcGxlU2VnbWVudC5zdGF0cykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyaWdnZXIoJ3Byb2dyZXNzJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbG9hZCBhIHNwZWNpZmljIHNlZ21lbnQgZnJvbSBhIHJlcXVlc3QgaW50byB0aGUgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkU2VnbWVudF8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkU2VnbWVudF8oc2VnbWVudEluZm8pIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAnV0FJVElORyc7XG4gICAgICB0aGlzLnBlbmRpbmdTZWdtZW50XyA9IHNlZ21lbnRJbmZvO1xuICAgICAgdGhpcy50cmltQmFja0J1ZmZlcl8oc2VnbWVudEluZm8pO1xuXG4gICAgICBzZWdtZW50SW5mby5hYm9ydFJlcXVlc3RzID0gbWVkaWFTZWdtZW50UmVxdWVzdCh0aGlzLmhsc18ueGhyLCB0aGlzLnhock9wdGlvbnNfLCB0aGlzLmRlY3J5cHRlcl8sIHRoaXMuY3JlYXRlU2ltcGxpZmllZFNlZ21lbnRPYmpfKHNlZ21lbnRJbmZvKSxcbiAgICAgIC8vIHByb2dyZXNzIGNhbGxiYWNrXG4gICAgICB0aGlzLmhhbmRsZVByb2dyZXNzXy5iaW5kKHRoaXMpLCB0aGlzLnNlZ21lbnRSZXF1ZXN0RmluaXNoZWRfLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRyaW0gdGhlIGJhY2sgYnVmZmVyIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0b28gbXVjaCBkYXRhXG4gICAgICogaW4gdGhlIHNvdXJjZSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudEluZm8gLSB0aGUgY3VycmVudCBzZWdtZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RyaW1CYWNrQnVmZmVyXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyaW1CYWNrQnVmZmVyXyhzZWdtZW50SW5mbykge1xuICAgICAgdmFyIHJlbW92ZVRvVGltZSA9IHNhZmVCYWNrQnVmZmVyVHJpbVRpbWUodGhpcy5zZWVrYWJsZV8oKSwgdGhpcy5jdXJyZW50VGltZV8oKSwgdGhpcy5wbGF5bGlzdF8udGFyZ2V0RHVyYXRpb24gfHwgMTApO1xuXG4gICAgICAvLyBDaHJvbWUgaGFzIGEgaGFyZCBsaW1pdCBvZiAxNTBNQiBvZlxuICAgICAgLy8gYnVmZmVyIGFuZCBhIHZlcnkgY29uc2VydmF0aXZlIFwiZ2FyYmFnZSBjb2xsZWN0b3JcIlxuICAgICAgLy8gV2UgbWFudWFsbHkgY2xlYXIgb3V0IHRoZSBvbGQgYnVmZmVyIHRvIGVuc3VyZVxuICAgICAgLy8gd2UgZG9uJ3QgdHJpZ2dlciB0aGUgUXVvdGFFeGNlZWRlZCBlcnJvclxuICAgICAgLy8gb24gdGhlIHNvdXJjZSBidWZmZXIgZHVyaW5nIHN1YnNlcXVlbnQgYXBwZW5kc1xuXG4gICAgICBpZiAocmVtb3ZlVG9UaW1lID4gMCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgwLCByZW1vdmVUb1RpbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZWQgYSBzaW1wbGlmaWVkIGNvcHkgb2YgdGhlIHNlZ21lbnQgb2JqZWN0IHdpdGgganVzdCB0aGVcbiAgICAgKiBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gcGVyZm9ybSB0aGUgWEhSIGFuZCBkZWNyeXB0aW9uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlZ21lbnRJbmZvIC0gdGhlIGN1cnJlbnQgc2VnbWVudFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGEgc2ltcGxpZmllZCBzZWdtZW50IG9iamVjdCBjb3B5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZVNpbXBsaWZpZWRTZWdtZW50T2JqXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVNpbXBsaWZpZWRTZWdtZW50T2JqXyhzZWdtZW50SW5mbykge1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50SW5mby5zZWdtZW50O1xuICAgICAgdmFyIHNpbXBsZVNlZ21lbnQgPSB7XG4gICAgICAgIHJlc29sdmVkVXJpOiBzZWdtZW50LnJlc29sdmVkVXJpLFxuICAgICAgICBieXRlcmFuZ2U6IHNlZ21lbnQuYnl0ZXJhbmdlLFxuICAgICAgICByZXF1ZXN0SWQ6IHNlZ21lbnRJbmZvLnJlcXVlc3RJZFxuICAgICAgfTtcblxuICAgICAgaWYgKHNlZ21lbnQua2V5KSB7XG4gICAgICAgIC8vIGlmIHRoZSBtZWRpYSBzZXF1ZW5jZSBpcyBncmVhdGVyIHRoYW4gMl4zMiwgdGhlIElWIHdpbGwgYmUgaW5jb3JyZWN0XG4gICAgICAgIC8vIGFzc3VtaW5nIDEwcyBzZWdtZW50cywgdGhhdCB3b3VsZCBiZSBhYm91dCAxMzAwIHllYXJzXG4gICAgICAgIHZhciBpdiA9IHNlZ21lbnQua2V5Lml2IHx8IG5ldyBVaW50MzJBcnJheShbMCwgMCwgMCwgc2VnbWVudEluZm8ubWVkaWFJbmRleCArIHNlZ21lbnRJbmZvLnBsYXlsaXN0Lm1lZGlhU2VxdWVuY2VdKTtcblxuICAgICAgICBzaW1wbGVTZWdtZW50LmtleSA9IHtcbiAgICAgICAgICByZXNvbHZlZFVyaTogc2VnbWVudC5rZXkucmVzb2x2ZWRVcmksXG4gICAgICAgICAgaXY6IGl2XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWdtZW50Lm1hcCkge1xuICAgICAgICBzaW1wbGVTZWdtZW50Lm1hcCA9IHRoaXMuaW5pdFNlZ21lbnQoc2VnbWVudC5tYXApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2ltcGxlU2VnbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGNhbGxiYWNrIGZyb20gdGhlIHNlZ21lbnRSZXF1ZXN0IGZ1bmN0aW9uIGFuZCBzZXQgdGhlXG4gICAgICogYXNzb2NpYXRlZCBTZWdtZW50TG9hZGVyIHN0YXRlIGFuZCBlcnJvcnMgaWYgbmVjZXNzYXJ5XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZWdtZW50UmVxdWVzdEZpbmlzaGVkXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlZ21lbnRSZXF1ZXN0RmluaXNoZWRfKGVycm9yLCBzaW1wbGVTZWdtZW50KSB7XG4gICAgICAvLyBldmVyeSByZXF1ZXN0IGNvdW50cyBhcyBhIG1lZGlhIHJlcXVlc3QgZXZlbiBpZiBpdCBoYXMgYmVlbiBhYm9ydGVkXG4gICAgICAvLyBvciBjYW5jZWxlZCBkdWUgdG8gYSB0aW1lb3V0XG4gICAgICB0aGlzLm1lZGlhUmVxdWVzdHMgKz0gMTtcblxuICAgICAgaWYgKHNpbXBsZVNlZ21lbnQuc3RhdHMpIHtcbiAgICAgICAgdGhpcy5tZWRpYUJ5dGVzVHJhbnNmZXJyZWQgKz0gc2ltcGxlU2VnbWVudC5zdGF0cy5ieXRlc1JlY2VpdmVkO1xuICAgICAgICB0aGlzLm1lZGlhVHJhbnNmZXJEdXJhdGlvbiArPSBzaW1wbGVTZWdtZW50LnN0YXRzLnJvdW5kVHJpcFRpbWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkIGFuZCB0aGUgU2VnbWVudExvYWRlciBoYXMgYWxyZWFkeSBiZWVuIHJlc2V0XG4gICAgICBpZiAoIXRoaXMucGVuZGluZ1NlZ21lbnRfKSB7XG4gICAgICAgIHRoaXMubWVkaWFSZXF1ZXN0c0Fib3J0ZWQgKz0gMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGUgcmVxdWVzdCB3YXMgYWJvcnRlZCBhbmQgdGhlIFNlZ21lbnRMb2FkZXIgaGFzIGFscmVhZHkgc3RhcnRlZFxuICAgICAgLy8gYW5vdGhlciByZXF1ZXN0LiB0aGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgdGltZW91dCBmb3IgYW4gYWJvcnRlZFxuICAgICAgLy8gcmVxdWVzdCB0cmlnZ2VycyBkdWUgdG8gYSBsaW1pdGF0aW9uIGluIHRoZSBYSFIgbGlicmFyeVxuICAgICAgLy8gZG8gbm90IGNvdW50IHRoaXMgYXMgYW55IHNvcnQgb2YgcmVxdWVzdCBvciB3ZSByaXNrIGRvdWJsZS1jb3VudGluZ1xuICAgICAgaWYgKHNpbXBsZVNlZ21lbnQucmVxdWVzdElkICE9PSB0aGlzLnBlbmRpbmdTZWdtZW50Xy5yZXF1ZXN0SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhbiBlcnJvciBvY2N1cnJlZCBmcm9tIHRoZSBhY3RpdmUgcGVuZGluZ1NlZ21lbnRfIHNvIHJlc2V0IGV2ZXJ5dGhpbmdcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aGlzLnBlbmRpbmdTZWdtZW50XyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnUkVBRFknO1xuXG4gICAgICAgIC8vIHRoZSByZXF1ZXN0cyB3ZXJlIGFib3J0ZWQganVzdCByZWNvcmQgdGhlIGFib3J0ZWQgc3RhdCBhbmQgZXhpdFxuICAgICAgICAvLyB0aGlzIGlzIG5vdCBhIHRydWUgZXJyb3IgY29uZGl0aW9uIGFuZCBub3RoaW5nIGNvcnJlY3RpdmUgbmVlZHNcbiAgICAgICAgLy8gdG8gYmUgZG9uZVxuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gUkVRVUVTVF9FUlJPUlMuQUJPUlRFRCkge1xuICAgICAgICAgIHRoaXMubWVkaWFSZXF1ZXN0c0Fib3J0ZWQgKz0gMTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhdXNlKCk7XG5cbiAgICAgICAgLy8gdGhlIGVycm9yIGlzIHJlYWxseSBqdXN0IHRoYXQgYXQgbGVhc3Qgb25lIG9mIHRoZSByZXF1ZXN0cyB0aW1lZC1vdXRcbiAgICAgICAgLy8gc2V0IHRoZSBiYW5kd2lkdGggdG8gYSB2ZXJ5IGxvdyB2YWx1ZSBhbmQgdHJpZ2dlciBhbiBBQlIgc3dpdGNoIHRvXG4gICAgICAgIC8vIHRha2UgZW1lcmdlbmN5IGFjdGlvblxuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gUkVRVUVTVF9FUlJPUlMuVElNRU9VVCkge1xuICAgICAgICAgIHRoaXMubWVkaWFSZXF1ZXN0c1RpbWVkb3V0ICs9IDE7XG4gICAgICAgICAgdGhpcy5iYW5kd2lkdGggPSAxO1xuICAgICAgICAgIHRoaXMucm91bmRUcmlwID0gTmFOO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignYmFuZHdpZHRodXBkYXRlJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgY29udHJvbC1mbG93IGhhcyBhcnJpdmVkIGhlcmUsIHRoZW4gdGhlIGVycm9yIGlzIHJlYWxcbiAgICAgICAgLy8gZW1pdCBhbiBlcnJvciBldmVudCB0byBibGFja2xpc3QgdGhlIGN1cnJlbnQgcGxheWxpc3RcbiAgICAgICAgdGhpcy5tZWRpYVJlcXVlc3RzRXJyb3JlZCArPSAxO1xuICAgICAgICB0aGlzLmVycm9yKGVycm9yKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdlcnJvcicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSByZXNwb25zZSB3YXMgYSBzdWNjZXNzIHNvIHNldCBhbnkgYmFuZHdpZHRoIHN0YXRzIHRoZSByZXF1ZXN0XG4gICAgICAvLyBnZW5lcmF0ZWQgZm9yIEFCUiBwdXJwb3Nlc1xuICAgICAgdGhpcy5iYW5kd2lkdGggPSBzaW1wbGVTZWdtZW50LnN0YXRzLmJhbmR3aWR0aDtcbiAgICAgIHRoaXMucm91bmRUcmlwID0gc2ltcGxlU2VnbWVudC5zdGF0cy5yb3VuZFRyaXBUaW1lO1xuXG4gICAgICAvLyBpZiB0aGlzIHJlcXVlc3QgaW5jbHVkZWQgYW4gaW5pdGlhbGl6YXRpb24gc2VnbWVudCwgc2F2ZSB0aGF0IGRhdGFcbiAgICAgIC8vIHRvIHRoZSBpbml0U2VnbWVudCBjYWNoZVxuICAgICAgaWYgKHNpbXBsZVNlZ21lbnQubWFwKSB7XG4gICAgICAgIHNpbXBsZVNlZ21lbnQubWFwID0gdGhpcy5pbml0U2VnbWVudChzaW1wbGVTZWdtZW50Lm1hcCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvY2Vzc1NlZ21lbnRSZXNwb25zZV8oc2ltcGxlU2VnbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSBhbnkgaW1wb3J0YW50IGRhdGEgZnJvbSB0aGUgc2ltcGxpZmllZCBzZWdtZW50IG9iamVjdFxuICAgICAqIGJhY2sgdG8gdGhlIHJlYWwgc2VnbWVudCBvYmplY3QgZm9yIGZ1dHVyZSBwaGFzZXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NTZWdtZW50UmVzcG9uc2VfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1NlZ21lbnRSZXNwb25zZV8oc2ltcGxlU2VnbWVudCkge1xuICAgICAgdmFyIHNlZ21lbnRJbmZvID0gdGhpcy5wZW5kaW5nU2VnbWVudF87XG5cbiAgICAgIHNlZ21lbnRJbmZvLmJ5dGVzID0gc2ltcGxlU2VnbWVudC5ieXRlcztcbiAgICAgIGlmIChzaW1wbGVTZWdtZW50Lm1hcCkge1xuICAgICAgICBzZWdtZW50SW5mby5zZWdtZW50Lm1hcC5ieXRlcyA9IHNpbXBsZVNlZ21lbnQubWFwLmJ5dGVzO1xuICAgICAgfVxuXG4gICAgICBzZWdtZW50SW5mby5lbmRPZkFsbFJlcXVlc3RzID0gc2ltcGxlU2VnbWVudC5lbmRPZkFsbFJlcXVlc3RzO1xuICAgICAgdGhpcy5oYW5kbGVTZWdtZW50XygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFwcGVuZCBhIGRlY3J5cHRlZCBzZWdlbWVudCB0byB0aGUgU291cmNlQnVmZmVyIHRocm91Z2ggYSBTb3VyY2VVcGRhdGVyXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVTZWdtZW50XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVNlZ21lbnRfKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5wZW5kaW5nU2VnbWVudF8pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdSRUFEWSc7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlZ21lbnRJbmZvID0gdGhpcy5wZW5kaW5nU2VnbWVudF87XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRJbmZvLnNlZ21lbnQ7XG4gICAgICB2YXIgdGltaW5nSW5mbyA9IHRoaXMuc3luY0NvbnRyb2xsZXJfLnByb2JlU2VnbWVudEluZm8oc2VnbWVudEluZm8pO1xuXG4gICAgICAvLyBXaGVuIHdlIGhhdmUgb3VyIGZpcnN0IHRpbWluZyBpbmZvLCBkZXRlcm1pbmUgd2hhdCBtZWRpYSB0eXBlcyB0aGlzIGxvYWRlciBpc1xuICAgICAgLy8gZGVhbGluZyB3aXRoLiBBbHRob3VnaCB3ZSdyZSBtYWludGFpbmluZyBleHRyYSBzdGF0ZSwgaXQgaGVscHMgdG8gcHJlc2VydmUgdGhlXG4gICAgICAvLyBzZXBhcmF0aW9uIG9mIHNlZ21lbnQgbG9hZGVyIGZyb20gdGhlIGFjdHVhbCBzb3VyY2UgYnVmZmVycy5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zdGFydGluZ01lZGlhXyA9PT0gJ3VuZGVmaW5lZCcgJiYgdGltaW5nSW5mbyAmJiAoXG4gICAgICAvLyBHdWFyZCBhZ2FpbnN0IGNhc2VzIHdoZXJlIHdlJ3JlIG5vdCBnZXR0aW5nIHRpbWluZyBpbmZvIGF0IGFsbCB1bnRpbCB3ZSBhcmVcbiAgICAgIC8vIGNlcnRhaW4gdGhhdCBhbGwgc3RyZWFtcyB3aWxsIHByb3ZpZGUgaXQuXG4gICAgICB0aW1pbmdJbmZvLmNvbnRhaW5zQXVkaW8gfHwgdGltaW5nSW5mby5jb250YWluc1ZpZGVvKSkge1xuICAgICAgICB0aGlzLnN0YXJ0aW5nTWVkaWFfID0ge1xuICAgICAgICAgIGNvbnRhaW5zQXVkaW86IHRpbWluZ0luZm8uY29udGFpbnNBdWRpbyxcbiAgICAgICAgICBjb250YWluc1ZpZGVvOiB0aW1pbmdJbmZvLmNvbnRhaW5zVmlkZW9cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlsbGVnYWxNZWRpYVN3aXRjaEVycm9yID0gaWxsZWdhbE1lZGlhU3dpdGNoKHRoaXMubG9hZGVyVHlwZV8sIHRoaXMuc3RhcnRpbmdNZWRpYV8sIHRpbWluZ0luZm8pO1xuXG4gICAgICBpZiAoaWxsZWdhbE1lZGlhU3dpdGNoRXJyb3IpIHtcbiAgICAgICAgdGhpcy5lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogaWxsZWdhbE1lZGlhU3dpdGNoRXJyb3IsXG4gICAgICAgICAgYmxhY2tsaXN0RHVyYXRpb246IEluZmluaXR5XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlZ21lbnRJbmZvLmlzU3luY1JlcXVlc3QpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzeW5jaW5mb3VwZGF0ZScpO1xuICAgICAgICB0aGlzLnBlbmRpbmdTZWdtZW50XyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnUkVBRFknO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWdtZW50SW5mby50aW1lc3RhbXBPZmZzZXQgIT09IG51bGwgJiYgc2VnbWVudEluZm8udGltZXN0YW1wT2Zmc2V0ICE9PSB0aGlzLnNvdXJjZVVwZGF0ZXJfLnRpbWVzdGFtcE9mZnNldCgpKSB7XG4gICAgICAgIHRoaXMuc291cmNlVXBkYXRlcl8udGltZXN0YW1wT2Zmc2V0KHNlZ21lbnRJbmZvLnRpbWVzdGFtcE9mZnNldCk7XG4gICAgICAgIC8vIGZpcmVkIHdoZW4gYSB0aW1lc3RhbXAgb2Zmc2V0IGlzIHNldCBpbiBITFMgKGNhbiBhbHNvIGlkZW50aWZ5IGRpc2NvbnRpbnVpdGllcylcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd0aW1lc3RhbXBvZmZzZXQnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWVsaW5lTWFwcGluZyA9IHRoaXMuc3luY0NvbnRyb2xsZXJfLm1hcHBpbmdGb3JUaW1lbGluZShzZWdtZW50SW5mby50aW1lbGluZSk7XG5cbiAgICAgIGlmICh0aW1lbGluZU1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKHtcbiAgICAgICAgICB0eXBlOiAnc2VnbWVudHRpbWVtYXBwaW5nJyxcbiAgICAgICAgICBtYXBwaW5nOiB0aW1lbGluZU1hcHBpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGUgPSAnQVBQRU5ESU5HJztcblxuICAgICAgLy8gaWYgdGhlIG1lZGlhIGluaXRpYWxpemF0aW9uIHNlZ21lbnQgaXMgY2hhbmdpbmcsIGFwcGVuZCBpdFxuICAgICAgLy8gYmVmb3JlIHRoZSBjb250ZW50IHNlZ21lbnRcbiAgICAgIGlmIChzZWdtZW50Lm1hcCkge1xuICAgICAgICB2YXIgaW5pdElkID0gaW5pdFNlZ21lbnRJZChzZWdtZW50Lm1hcCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUluaXRTZWdtZW50SWRfIHx8IHRoaXMuYWN0aXZlSW5pdFNlZ21lbnRJZF8gIT09IGluaXRJZCkge1xuICAgICAgICAgIHZhciBpbml0U2VnbWVudCA9IHRoaXMuaW5pdFNlZ21lbnQoc2VnbWVudC5tYXApO1xuXG4gICAgICAgICAgdGhpcy5zb3VyY2VVcGRhdGVyXy5hcHBlbmRCdWZmZXIoaW5pdFNlZ21lbnQuYnl0ZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5hY3RpdmVJbml0U2VnbWVudElkXyA9IGluaXRJZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50SW5mby5ieXRlTGVuZ3RoID0gc2VnbWVudEluZm8uYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgIGlmICh0eXBlb2Ygc2VnbWVudC5zdGFydCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHNlZ21lbnQuZW5kID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLm1lZGlhU2Vjb25kc0xvYWRlZCArPSBzZWdtZW50LmVuZCAtIHNlZ21lbnQuc3RhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1lZGlhU2Vjb25kc0xvYWRlZCArPSBzZWdtZW50LmR1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZ2dlcl8oc2VnbWVudEluZm9TdHJpbmcoc2VnbWVudEluZm8pKTtcblxuICAgICAgdGhpcy5zb3VyY2VVcGRhdGVyXy5hcHBlbmRCdWZmZXIoc2VnbWVudEluZm8uYnl0ZXMsIHRoaXMuaGFuZGxlVXBkYXRlRW5kXy5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYWxsYmFjayB0byBydW4gd2hlbiBhcHBlbmRCdWZmZXIgaXMgZmluaXNoZWQuIGRldGVjdHMgaWYgd2UgYXJlXG4gICAgICogaW4gYSBnb29kIHN0YXRlIHRvIGRvIHRoaW5ncyB3aXRoIHRoZSBkYXRhIHdlIGdvdCwgb3IgaWYgd2UgbmVlZFxuICAgICAqIHRvIHdhaXQgZm9yIG1vcmVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZVVwZGF0ZUVuZF8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVVcGRhdGVFbmRfKCkge1xuICAgICAgaWYgKCF0aGlzLnBlbmRpbmdTZWdtZW50Xykge1xuICAgICAgICB0aGlzLnN0YXRlID0gJ1JFQURZJztcbiAgICAgICAgaWYgKCF0aGlzLnBhdXNlZCgpKSB7XG4gICAgICAgICAgdGhpcy5tb25pdG9yQnVmZmVyXygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlZ21lbnRJbmZvID0gdGhpcy5wZW5kaW5nU2VnbWVudF87XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRJbmZvLnNlZ21lbnQ7XG4gICAgICB2YXIgaXNXYWxraW5nRm9yd2FyZCA9IHRoaXMubWVkaWFJbmRleCAhPT0gbnVsbDtcblxuICAgICAgdGhpcy5wZW5kaW5nU2VnbWVudF8gPSBudWxsO1xuICAgICAgdGhpcy5yZWNvcmRUaHJvdWdocHV0XyhzZWdtZW50SW5mbyk7XG4gICAgICB0aGlzLmFkZFNlZ21lbnRNZXRhZGF0YUN1ZV8oc2VnbWVudEluZm8pO1xuXG4gICAgICB0aGlzLnN0YXRlID0gJ1JFQURZJztcblxuICAgICAgdGhpcy5tZWRpYUluZGV4ID0gc2VnbWVudEluZm8ubWVkaWFJbmRleDtcbiAgICAgIHRoaXMuZmV0Y2hBdEJ1ZmZlcl8gPSB0cnVlO1xuICAgICAgdGhpcy5jdXJyZW50VGltZWxpbmVfID0gc2VnbWVudEluZm8udGltZWxpbmU7XG5cbiAgICAgIC8vIFdlIG11c3QgdXBkYXRlIHRoZSBzeW5jaW5mbyB0byByZWNhbGN1bGF0ZSB0aGUgc2Vla2FibGUgcmFuZ2UgYmVmb3JlXG4gICAgICAvLyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbmFsIG90aGVyd2lzZSBpdCBtYXkgY29uc2lkZXIgdGhpcyBhIGJhZCBcImd1ZXNzXCJcbiAgICAgIC8vIGFuZCBhdHRlbXB0IHRvIHJlc3luYyB3aGVuIHRoZSBwb3N0LXVwZGF0ZSBzZWVrYWJsZSB3aW5kb3cgYW5kIGxpdmVcbiAgICAgIC8vIHBvaW50IHdvdWxkIG1lYW4gdGhhdCB0aGlzIHdhcyB0aGUgcGVyZmVjdCBzZWdtZW50IHRvIGZldGNoXG4gICAgICB0aGlzLnRyaWdnZXIoJ3N5bmNpbmZvdXBkYXRlJyk7XG5cbiAgICAgIC8vIElmIHdlIHByZXZpb3VzbHkgYXBwZW5kZWQgYSBzZWdtZW50IHRoYXQgZW5kcyBtb3JlIHRoYW4gMyB0YXJnZXREdXJhdGlvbnMgYmVmb3JlXG4gICAgICAvLyB0aGUgY3VycmVudFRpbWVfIHRoYXQgbWVhbnMgdGhhdCBvdXIgY29uc2VydmF0aXZlIGd1ZXNzIHdhcyB0b28gY29uc2VydmF0aXZlLlxuICAgICAgLy8gSW4gdGhhdCBjYXNlLCByZXNldCB0aGUgbG9hZGVyIHN0YXRlIHNvIHRoYXQgd2UgdHJ5IHRvIHVzZSBhbnkgaW5mb3JtYXRpb24gZ2FpbmVkXG4gICAgICAvLyBmcm9tIHRoZSBwcmV2aW91cyByZXF1ZXN0IHRvIGNyZWF0ZSBhIG5ldywgbW9yZSBhY2N1cmF0ZSwgc3luYy1wb2ludC5cbiAgICAgIGlmIChzZWdtZW50LmVuZCAmJiB0aGlzLmN1cnJlbnRUaW1lXygpIC0gc2VnbWVudC5lbmQgPiBzZWdtZW50SW5mby5wbGF5bGlzdC50YXJnZXREdXJhdGlvbiAqIDMpIHtcbiAgICAgICAgdGhpcy5yZXNldEV2ZXJ5dGhpbmcoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBkbyBhIHJlbmRpdGlvbiBzd2l0Y2ggdW5sZXNzIHdlIGhhdmUgZW5vdWdoIHRpbWUgdG8gZ2V0IGEgc3luYyBzZWdtZW50XG4gICAgICAvLyBhbmQgY29uc2VydmF0aXZlbHkgZ3Vlc3NcbiAgICAgIGlmIChpc1dhbGtpbmdGb3J3YXJkKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignYmFuZHdpZHRodXBkYXRlJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoJ3Byb2dyZXNzJyk7XG5cbiAgICAgIC8vIGFueSB0aW1lIGFuIHVwZGF0ZSBmaW5pc2hlcyBhbmQgdGhlIGxhc3Qgc2VnbWVudCBpcyBpbiB0aGVcbiAgICAgIC8vIGJ1ZmZlciwgZW5kIHRoZSBzdHJlYW0uIHRoaXMgZW5zdXJlcyB0aGUgXCJlbmRlZFwiIGV2ZW50IHdpbGxcbiAgICAgIC8vIGZpcmUgaWYgcGxheWJhY2sgcmVhY2hlcyB0aGF0IHBvaW50LlxuICAgICAgdmFyIGlzRW5kT2ZTdHJlYW0gPSBkZXRlY3RFbmRPZlN0cmVhbShzZWdtZW50SW5mby5wbGF5bGlzdCwgdGhpcy5tZWRpYVNvdXJjZV8sIHNlZ21lbnRJbmZvLm1lZGlhSW5kZXggKyAxKTtcblxuICAgICAgaWYgKGlzRW5kT2ZTdHJlYW0pIHtcbiAgICAgICAgdGhpcy5lbmRPZlN0cmVhbSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMucGF1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5tb25pdG9yQnVmZmVyXygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY29yZHMgdGhlIGN1cnJlbnQgdGhyb3VnaHB1dCBvZiB0aGUgZGVjcnlwdCwgdHJhbnNtdXgsIGFuZCBhcHBlbmRcbiAgICAgKiBwb3J0aW9uIG9mIHRoZSBzZW1nbWVudCBwaXBlbGluZS4gYHRocm91Z2hwdXQucmF0ZWAgaXMgYSB0aGUgY3VtdWxhdGl2ZVxuICAgICAqIG1vdmluZyBhdmVyYWdlIG9mIHRoZSB0aHJvdWdocHV0LiBgdGhyb3VnaHB1dC5jb3VudGAgaXMgdGhlIG51bWJlciBvZlxuICAgICAqIGRhdGEgcG9pbnRzIGluIHRoZSBhdmVyYWdlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudEluZm8gdGhlIG9iamVjdCByZXR1cm5lZCBieSBsb2FkU2VnbWVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWNvcmRUaHJvdWdocHV0XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29yZFRocm91Z2hwdXRfKHNlZ21lbnRJbmZvKSB7XG4gICAgICB2YXIgcmF0ZSA9IHRoaXMudGhyb3VnaHB1dC5yYXRlO1xuICAgICAgLy8gQWRkIG9uZSB0byB0aGUgdGltZSB0byBlbnN1cmUgdGhhdCB3ZSBkb24ndCBhY2NpZGVudGFsbHkgYXR0ZW1wdCB0byBkaXZpZGVcbiAgICAgIC8vIGJ5IHplcm8gaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHRocm91Z2hwdXQgaXMgcmlkaWN1bG91c2x5IGhpZ2hcbiAgICAgIHZhciBzZWdtZW50UHJvY2Vzc2luZ1RpbWUgPSBEYXRlLm5vdygpIC0gc2VnbWVudEluZm8uZW5kT2ZBbGxSZXF1ZXN0cyArIDE7XG4gICAgICAvLyBNdWx0aXBseSBieSA4MDAwIHRvIGNvbnZlcnQgZnJvbSBieXRlcy9taWxsaXNlY29uZCB0byBiaXRzL3NlY29uZFxuICAgICAgdmFyIHNlZ21lbnRQcm9jZXNzaW5nVGhyb3VnaHB1dCA9IE1hdGguZmxvb3Ioc2VnbWVudEluZm8uYnl0ZUxlbmd0aCAvIHNlZ21lbnRQcm9jZXNzaW5nVGltZSAqIDggKiAxMDAwKTtcblxuICAgICAgLy8gVGhpcyBpcyBqdXN0IGEgY3VtdWxhdGl2ZSBtb3ZpbmcgYXZlcmFnZSBjYWxjdWxhdGlvbjpcbiAgICAgIC8vICAgbmV3QXZnID0gb2xkQXZnICsgKHNhbXBsZSAtIG9sZEF2ZykgLyAoc2FtcGxlQ291bnQgKyAxKVxuICAgICAgdGhpcy50aHJvdWdocHV0LnJhdGUgKz0gKHNlZ21lbnRQcm9jZXNzaW5nVGhyb3VnaHB1dCAtIHJhdGUpIC8gKyt0aGlzLnRocm91Z2hwdXQuY291bnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGN1ZSB0byB0aGUgc2VnbWVudC1tZXRhZGF0YSB0cmFjayB3aXRoIHNvbWUgbWV0YWRhdGEgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gICAgICogc2VnbWVudFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudEluZm9cbiAgICAgKiAgICAgICAgdGhlIG9iamVjdCByZXR1cm5lZCBieSBsb2FkU2VnbWVudFxuICAgICAqIEBtZXRob2QgYWRkU2VnbWVudE1ldGFkYXRhQ3VlX1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRTZWdtZW50TWV0YWRhdGFDdWVfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU2VnbWVudE1ldGFkYXRhQ3VlXyhzZWdtZW50SW5mbykge1xuICAgICAgaWYgKCF0aGlzLnNlZ21lbnRNZXRhZGF0YVRyYWNrXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudEluZm8uc2VnbWVudDtcbiAgICAgIHZhciBzdGFydCA9IHNlZ21lbnQuc3RhcnQ7XG4gICAgICB2YXIgZW5kID0gc2VnbWVudC5lbmQ7XG5cbiAgICAgIC8vIERvIG5vdCB0cnkgYWRkaW5nIHRoZSBjdWUgaWYgdGhlIHN0YXJ0IGFuZCBlbmQgdGltZXMgYXJlIGludmFsaWQuXG4gICAgICBpZiAoIWZpbml0ZShzdGFydCkgfHwgIWZpbml0ZShlbmQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlQ3Vlc0Zyb21UcmFjayhzdGFydCwgZW5kLCB0aGlzLnNlZ21lbnRNZXRhZGF0YVRyYWNrXyk7XG5cbiAgICAgIHZhciBDdWUgPSB3aW5kb3ckMS5XZWJLaXREYXRhQ3VlIHx8IHdpbmRvdyQxLlZUVEN1ZTtcbiAgICAgIHZhciB2YWx1ZSA9IHtcbiAgICAgICAgYmFuZHdpZHRoOiBzZWdtZW50SW5mby5wbGF5bGlzdC5hdHRyaWJ1dGVzLkJBTkRXSURUSCxcbiAgICAgICAgcmVzb2x1dGlvbjogc2VnbWVudEluZm8ucGxheWxpc3QuYXR0cmlidXRlcy5SRVNPTFVUSU9OLFxuICAgICAgICBjb2RlY3M6IHNlZ21lbnRJbmZvLnBsYXlsaXN0LmF0dHJpYnV0ZXMuQ09ERUNTLFxuICAgICAgICBieXRlTGVuZ3RoOiBzZWdtZW50SW5mby5ieXRlTGVuZ3RoLFxuICAgICAgICB1cmk6IHNlZ21lbnRJbmZvLnVyaSxcbiAgICAgICAgdGltZWxpbmU6IHNlZ21lbnRJbmZvLnRpbWVsaW5lLFxuICAgICAgICBwbGF5bGlzdDogc2VnbWVudEluZm8ucGxheWxpc3QudXJpLFxuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kXG4gICAgICB9O1xuICAgICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICB2YXIgY3VlID0gbmV3IEN1ZShzdGFydCwgZW5kLCBkYXRhKTtcblxuICAgICAgLy8gQXR0YWNoIHRoZSBtZXRhZGF0YSB0byB0aGUgdmFsdWUgcHJvcGVydHkgb2YgdGhlIGN1ZSB0byBrZWVwIGNvbnNpc3RlbmN5IGJldHdlZW5cbiAgICAgIC8vIHRoZSBkaWZmZXJlbmNlcyBvZiBXZWJLaXREYXRhQ3VlIGluIHNhZmFyaSBhbmQgVlRUQ3VlIGluIG90aGVyIGJyb3dzZXJzXG4gICAgICBjdWUudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgdGhpcy5zZWdtZW50TWV0YWRhdGFUcmFja18uYWRkQ3VlKGN1ZSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTZWdtZW50TG9hZGVyO1xufSh2aWRlb2pzJDEuRXZlbnRUYXJnZXQpO1xuXG4vKipcbiAqIEBmaWxlIHZ0dC1zZWdtZW50LWxvYWRlci5qc1xuICovXG5cbnZhciBWVFRfTElORV9URVJNSU5BVE9SUyA9IG5ldyBVaW50OEFycmF5KCdcXG5cXG4nLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGNoYXIpIHtcbiAgcmV0dXJuIGNoYXIuY2hhckNvZGVBdCgwKTtcbn0pKTtcblxudmFyIHVpbnRUb1N0cmluZyA9IGZ1bmN0aW9uIHVpbnRUb1N0cmluZyh1aW50QXJyYXkpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdWludEFycmF5KTtcbn07XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgbWFuYWdlcyBzZWdtZW50IGxvYWRpbmcgYW5kIGFwcGVuZGluZy5cbiAqXG4gKiBAY2xhc3MgVlRUU2VnbWVudExvYWRlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgcmVxdWlyZWQgYW5kIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEBleHRlbmRzIHZpZGVvanMuRXZlbnRUYXJnZXRcbiAqL1xuXG52YXIgVlRUU2VnbWVudExvYWRlciA9IGZ1bmN0aW9uIChfU2VnbWVudExvYWRlcikge1xuICBpbmhlcml0cyQxKFZUVFNlZ21lbnRMb2FkZXIsIF9TZWdtZW50TG9hZGVyKTtcblxuICBmdW5jdGlvbiBWVFRTZWdtZW50TG9hZGVyKHNldHRpbmdzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrJDEodGhpcywgVlRUU2VnbWVudExvYWRlcik7XG5cbiAgICAvLyBTZWdtZW50TG9hZGVyIHJlcXVpcmVzIGEgTWVkaWFTb3VyY2UgYmUgc3BlY2lmaWVkIG9yIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3I7XG4gICAgLy8gaG93ZXZlciwgVlRUU2VnbWVudExvYWRlciBoYXMgbm8gbmVlZCBvZiBhIG1lZGlhIHNvdXJjZSwgc28gZGVsZXRlIHRoZSByZWZlcmVuY2VcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJDEodGhpcywgKFZUVFNlZ21lbnRMb2FkZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihWVFRTZWdtZW50TG9hZGVyKSkuY2FsbCh0aGlzLCBzZXR0aW5ncywgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMubWVkaWFTb3VyY2VfID0gbnVsbDtcblxuICAgIF90aGlzLnN1YnRpdGxlc1RyYWNrXyA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGljaCB0aW1lIHJhbmdlcyBhcmUgYnVmZmVyZWRcbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIFRpbWVSYW5nZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlc1xuICAgKi9cblxuICBjcmVhdGVDbGFzcyQxKFZUVFNlZ21lbnRMb2FkZXIsIFt7XG4gICAga2V5OiAnYnVmZmVyZWRfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVmZmVyZWRfKCkge1xuICAgICAgaWYgKCF0aGlzLnN1YnRpdGxlc1RyYWNrXyB8fCAhdGhpcy5zdWJ0aXRsZXNUcmFja18uY3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHZpZGVvanMkMS5jcmVhdGVUaW1lUmFuZ2VzKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdWVzID0gdGhpcy5zdWJ0aXRsZXNUcmFja18uY3VlcztcbiAgICAgIHZhciBzdGFydCA9IGN1ZXNbMF0uc3RhcnRUaW1lO1xuICAgICAgdmFyIGVuZCA9IGN1ZXNbY3Vlcy5sZW5ndGggLSAxXS5zdGFydFRpbWU7XG5cbiAgICAgIHJldHVybiB2aWRlb2pzJDEuY3JlYXRlVGltZVJhbmdlcyhbW3N0YXJ0LCBlbmRdXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbmQgc2V0cyBpbml0IHNlZ21lbnQgZm9yIHRoZSBwcm92aWRlZCBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBcbiAgICAgKiAgICAgICAgVGhlIG1hcCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbml0IHNlZ21lbnQgdG8gZ2V0IG9yIHNldFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbj19IHNldFxuICAgICAqICAgICAgICBJZiB0cnVlLCB0aGUgaW5pdCBzZWdtZW50IGZvciB0aGUgcHJvdmlkZWQgbWFwIHNob3VsZCBiZSBzYXZlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiAgICAgICAgIG1hcCBvYmplY3QgZm9yIGRlc2lyZWQgaW5pdCBzZWdtZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luaXRTZWdtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFNlZ21lbnQobWFwKSB7XG4gICAgICB2YXIgc2V0JCQxID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZCA9IGluaXRTZWdtZW50SWQobWFwKTtcbiAgICAgIHZhciBzdG9yZWRNYXAgPSB0aGlzLmluaXRTZWdtZW50c19baWRdO1xuXG4gICAgICBpZiAoc2V0JCQxICYmICFzdG9yZWRNYXAgJiYgbWFwLmJ5dGVzKSB7XG4gICAgICAgIC8vIGFwcGVuZCBXZWJWVFQgbGluZSB0ZXJtaW5hdG9ycyB0byB0aGUgbWVkaWEgaW5pdGlhbGl6YXRpb24gc2VnbWVudCBpZiBpdCBleGlzdHNcbiAgICAgICAgLy8gdG8gZm9sbG93IHRoZSBXZWJWVFQgc3BlYyAoaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnZ0dC8jZmlsZS1zdHJ1Y3R1cmUpIHRoYXRcbiAgICAgICAgLy8gcmVxdWlyZXMgdHdvIG9yIG1vcmUgV2ViVlRUIGxpbmUgdGVybWluYXRvcnMgYmV0d2VlbiB0aGUgV2ViVlRUIGhlYWRlciBhbmQgdGhlXG4gICAgICAgIC8vIHJlc3Qgb2YgdGhlIGZpbGVcbiAgICAgICAgdmFyIGNvbWJpbmVkQnl0ZUxlbmd0aCA9IFZUVF9MSU5FX1RFUk1JTkFUT1JTLmJ5dGVMZW5ndGggKyBtYXAuYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgdmFyIGNvbWJpbmVkU2VnbWVudCA9IG5ldyBVaW50OEFycmF5KGNvbWJpbmVkQnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgY29tYmluZWRTZWdtZW50LnNldChtYXAuYnl0ZXMpO1xuICAgICAgICBjb21iaW5lZFNlZ21lbnQuc2V0KFZUVF9MSU5FX1RFUk1JTkFUT1JTLCBtYXAuYnl0ZXMuYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgdGhpcy5pbml0U2VnbWVudHNfW2lkXSA9IHN0b3JlZE1hcCA9IHtcbiAgICAgICAgICByZXNvbHZlZFVyaTogbWFwLnJlc29sdmVkVXJpLFxuICAgICAgICAgIGJ5dGVyYW5nZTogbWFwLmJ5dGVyYW5nZSxcbiAgICAgICAgICBieXRlczogY29tYmluZWRTZWdtZW50XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9yZWRNYXAgfHwgbWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbGwgY29uZmlndXJhdGlvbiByZXF1aXJlZCBmb3IgbG9hZGluZyBpcyBwcmVzZW50LCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBhbGwgY29uZmlndXJhdGlvbiBpcyByZWFkeSBmb3IgbG9hZGluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NvdWxkQmVnaW5Mb2FkaW5nXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvdWxkQmVnaW5Mb2FkaW5nXygpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsYXlsaXN0XyAmJiB0aGlzLnN1YnRpdGxlc1RyYWNrXyAmJiAhdGhpcy5wYXVzZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbmNlIGFsbCB0aGUgc3RhcnRpbmcgcGFyYW1ldGVycyBoYXZlIGJlZW4gc3BlY2lmaWVkLCBiZWdpblxuICAgICAqIG9wZXJhdGlvbi4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCBmcm9tIHRoZSBJTklUXG4gICAgICogc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbml0XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRfKCkge1xuICAgICAgdGhpcy5zdGF0ZSA9ICdSRUFEWSc7XG4gICAgICB0aGlzLnJlc2V0RXZlcnl0aGluZygpO1xuICAgICAgcmV0dXJuIHRoaXMubW9uaXRvckJ1ZmZlcl8oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBzdWJ0aXRsZSB0cmFjayBvbiB0aGUgc2VnbWVudCBsb2FkZXIgdG8gYWRkIHN1YnRpdGxlcyB0b1xuICAgICAqXG4gICAgICogQHBhcmFtIHtUZXh0VHJhY2s9fSB0cmFja1xuICAgICAqICAgICAgICBUaGUgdGV4dCB0cmFjayB0byBhZGQgbG9hZGVkIHN1YnRpdGxlcyB0b1xuICAgICAqIEByZXR1cm4ge1RleHRUcmFja31cbiAgICAgKiAgICAgICAgUmV0dXJucyB0aGUgc3VidGl0bGVzIHRyYWNrXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RyYWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhY2soX3RyYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIF90cmFjayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidGl0bGVzVHJhY2tfO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN1YnRpdGxlc1RyYWNrXyA9IF90cmFjaztcblxuICAgICAgLy8gaWYgd2Ugd2VyZSB1bnBhdXNlZCBidXQgd2FpdGluZyBmb3IgYSBzb3VyY2VVcGRhdGVyLCBzdGFydFxuICAgICAgLy8gYnVmZmVyaW5nIG5vd1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdJTklUJyAmJiB0aGlzLmNvdWxkQmVnaW5Mb2FkaW5nXygpKSB7XG4gICAgICAgIHRoaXMuaW5pdF8oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3VidGl0bGVzVHJhY2tfO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbnkgZGF0YSBpbiB0aGUgc291cmNlIGJ1ZmZlciBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgdGltZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgLSB0aGUgc3RhcnQgdGltZSBvZiB0aGUgcmVnaW9uIHRvIHJlbW92ZSBmcm9tIHRoZSBidWZmZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIC0gdGhlIGVuZCB0aW1lIG9mIHRoZSByZWdpb24gdG8gcmVtb3ZlIGZyb20gdGhlIGJ1ZmZlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoc3RhcnQsIGVuZCkge1xuICAgICAgcmVtb3ZlQ3Vlc0Zyb21UcmFjayhzdGFydCwgZW5kLCB0aGlzLnN1YnRpdGxlc1RyYWNrXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmlsbCB0aGUgYnVmZmVyIHdpdGggc2VnZW1lbnRzIHVubGVzcyB0aGUgc291cmNlQnVmZmVycyBhcmVcbiAgICAgKiBjdXJyZW50bHkgdXBkYXRpbmdcbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgZXZlciBiZSBjYWxsZWQgYnkgbW9uaXRvckJ1ZmZlcl9cbiAgICAgKiBhbmQgbmV2ZXIgZGlyZWN0bHlcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbGxCdWZmZXJfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsbEJ1ZmZlcl8oKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLnN5bmNQb2ludF8pIHtcbiAgICAgICAgdGhpcy5zeW5jUG9pbnRfID0gdGhpcy5zeW5jQ29udHJvbGxlcl8uZ2V0U3luY1BvaW50KHRoaXMucGxheWxpc3RfLCB0aGlzLmR1cmF0aW9uXygpLCB0aGlzLmN1cnJlbnRUaW1lbGluZV8sIHRoaXMuY3VycmVudFRpbWVfKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZWUgaWYgd2UgbmVlZCB0byBiZWdpbiBsb2FkaW5nIGltbWVkaWF0ZWx5XG4gICAgICB2YXIgc2VnbWVudEluZm8gPSB0aGlzLmNoZWNrQnVmZmVyXyh0aGlzLmJ1ZmZlcmVkXygpLCB0aGlzLnBsYXlsaXN0XywgdGhpcy5tZWRpYUluZGV4LCB0aGlzLmhhc1BsYXllZF8oKSwgdGhpcy5jdXJyZW50VGltZV8oKSwgdGhpcy5zeW5jUG9pbnRfKTtcblxuICAgICAgc2VnbWVudEluZm8gPSB0aGlzLnNraXBFbXB0eVNlZ21lbnRzXyhzZWdtZW50SW5mbyk7XG5cbiAgICAgIGlmICghc2VnbWVudEluZm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zeW5jQ29udHJvbGxlcl8udGltZXN0YW1wT2Zmc2V0Rm9yVGltZWxpbmUoc2VnbWVudEluZm8udGltZWxpbmUpID09PSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgdGhlIHRpbWVzdGFtcCBvZmZzZXQgdGhhdCB3ZSBuZWVkIHRvIHN5bmMgc3VidGl0bGVzLlxuICAgICAgICAvLyBSZXJ1biBvbiBhIHRpbWVzdGFtcCBvZmZzZXQgb3IgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgICAgdmFyIGNoZWNrVGltZXN0YW1wT2Zmc2V0ID0gZnVuY3Rpb24gY2hlY2tUaW1lc3RhbXBPZmZzZXQoKSB7XG4gICAgICAgICAgX3RoaXMyLnN0YXRlID0gJ1JFQURZJztcbiAgICAgICAgICBpZiAoIV90aGlzMi5wYXVzZWQoKSkge1xuICAgICAgICAgICAgLy8gaWYgbm90IHBhdXNlZCwgcXVldWUgYSBidWZmZXIgY2hlY2sgYXMgc29vbiBhcyBwb3NzaWJsZVxuICAgICAgICAgICAgX3RoaXMyLm1vbml0b3JCdWZmZXJfKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc3luY0NvbnRyb2xsZXJfLm9uZSgndGltZXN0YW1wb2Zmc2V0JywgY2hlY2tUaW1lc3RhbXBPZmZzZXQpO1xuICAgICAgICB0aGlzLnN0YXRlID0gJ1dBSVRJTkdfT05fVElNRUxJTkUnO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9hZFNlZ21lbnRfKHNlZ21lbnRJbmZvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyB0aGUgc2VnbWVudCBsb2FkZXIgZnJvbSByZXF1ZXN0aW5nIHNlZ21lbnRzIHdlIGtub3cgY29udGFpbiBubyBzdWJ0aXRsZXNcbiAgICAgKiBieSB3YWxraW5nIGZvcndhcmQgdW50aWwgd2UgZmluZCB0aGUgbmV4dCBzZWdtZW50IHRoYXQgd2UgZG9uJ3Qga25vdyB3aGV0aGVyIGl0IGlzXG4gICAgICogZW1wdHkgb3Igbm90LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlZ21lbnRJbmZvXG4gICAgICogICAgICAgIGEgc2VnbWVudCBpbmZvIG9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgY3VycmVudCBzZWdtZW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqICAgICAgICAgYSBzZWdtZW50IGluZm8gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBjdXJyZW50IHNlZ21lbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2tpcEVtcHR5U2VnbWVudHNfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2tpcEVtcHR5U2VnbWVudHNfKHNlZ21lbnRJbmZvKSB7XG4gICAgICB3aGlsZSAoc2VnbWVudEluZm8gJiYgc2VnbWVudEluZm8uc2VnbWVudC5lbXB0eSkge1xuICAgICAgICBzZWdtZW50SW5mbyA9IHRoaXMuZ2VuZXJhdGVTZWdtZW50SW5mb18oc2VnbWVudEluZm8ucGxheWxpc3QsIHNlZ21lbnRJbmZvLm1lZGlhSW5kZXggKyAxLCBzZWdtZW50SW5mby5zdGFydE9mU2VnbWVudCArIHNlZ21lbnRJbmZvLmR1cmF0aW9uLCBzZWdtZW50SW5mby5pc1N5bmNSZXF1ZXN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWdtZW50SW5mbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhcHBlbmQgYSBkZWNyeXB0ZWQgc2VnZW1lbnQgdG8gdGhlIFNvdXJjZUJ1ZmZlciB0aHJvdWdoIGEgU291cmNlVXBkYXRlclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlU2VnbWVudF8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVTZWdtZW50XygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMucGVuZGluZ1NlZ21lbnRfIHx8ICF0aGlzLnN1YnRpdGxlc1RyYWNrXykge1xuICAgICAgICB0aGlzLnN0YXRlID0gJ1JFQURZJztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0gJ0FQUEVORElORyc7XG5cbiAgICAgIHZhciBzZWdtZW50SW5mbyA9IHRoaXMucGVuZGluZ1NlZ21lbnRfO1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50SW5mby5zZWdtZW50O1xuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCB2dHRqcyBoYXMgbG9hZGVkLCBvdGhlcndpc2UsIHdhaXQgdGlsbCBpdCBmaW5pc2hlZCBsb2FkaW5nXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyQxLldlYlZUVCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN1YnRpdGxlc1RyYWNrXyAmJiB0aGlzLnN1YnRpdGxlc1RyYWNrXy50ZWNoXykge1xuXG4gICAgICAgIHZhciBsb2FkSGFuZGxlciA9IGZ1bmN0aW9uIGxvYWRIYW5kbGVyKCkge1xuICAgICAgICAgIF90aGlzMy5oYW5kbGVTZWdtZW50XygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSAnV0FJVElOR19PTl9WVFRKUyc7XG4gICAgICAgIHRoaXMuc3VidGl0bGVzVHJhY2tfLnRlY2hfLm9uZSgndnR0anNsb2FkZWQnLCBsb2FkSGFuZGxlcik7XG4gICAgICAgIHRoaXMuc3VidGl0bGVzVHJhY2tfLnRlY2hfLm9uZSgndnR0anNlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczMuc3VidGl0bGVzVHJhY2tfLnRlY2hfLm9mZigndnR0anNsb2FkZWQnLCBsb2FkSGFuZGxlcik7XG4gICAgICAgICAgX3RoaXMzLmVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdFcnJvciBsb2FkaW5nIHZ0dC5qcydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfdGhpczMuc3RhdGUgPSAnUkVBRFknO1xuICAgICAgICAgIF90aGlzMy5wYXVzZSgpO1xuICAgICAgICAgIF90aGlzMy50cmlnZ2VyKCdlcnJvcicpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQucmVxdWVzdGVkID0gdHJ1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5wYXJzZVZUVEN1ZXNfKHNlZ21lbnRJbmZvKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogZS5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXRlID0gJ1JFQURZJztcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdlcnJvcicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZVRpbWVNYXBwaW5nXyhzZWdtZW50SW5mbywgdGhpcy5zeW5jQ29udHJvbGxlcl8udGltZWxpbmVzW3NlZ21lbnRJbmZvLnRpbWVsaW5lXSwgdGhpcy5wbGF5bGlzdF8pO1xuXG4gICAgICBpZiAoc2VnbWVudEluZm8uaXNTeW5jUmVxdWVzdCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3N5bmNpbmZvdXBkYXRlJyk7XG4gICAgICAgIHRoaXMucGVuZGluZ1NlZ21lbnRfID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdSRUFEWSc7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VnbWVudEluZm8uYnl0ZUxlbmd0aCA9IHNlZ21lbnRJbmZvLmJ5dGVzLmJ5dGVMZW5ndGg7XG5cbiAgICAgIHRoaXMubWVkaWFTZWNvbmRzTG9hZGVkICs9IHNlZ21lbnQuZHVyYXRpb247XG5cbiAgICAgIGlmIChzZWdtZW50SW5mby5jdWVzLmxlbmd0aCkge1xuICAgICAgICAvLyByZW1vdmUgYW55IG92ZXJsYXBwaW5nIGN1ZXMgdG8gcHJldmVudCBkb3VibGluZ1xuICAgICAgICB0aGlzLnJlbW92ZShzZWdtZW50SW5mby5jdWVzWzBdLmVuZFRpbWUsIHNlZ21lbnRJbmZvLmN1ZXNbc2VnbWVudEluZm8uY3Vlcy5sZW5ndGggLSAxXS5lbmRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgc2VnbWVudEluZm8uY3Vlcy5mb3JFYWNoKGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgICAgX3RoaXMzLnN1YnRpdGxlc1RyYWNrXy5hZGRDdWUoY3VlKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmhhbmRsZVVwZGF0ZUVuZF8oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIHRoZSBXZWJWVFQgcGFyc2VyIHRvIHBhcnNlIHRoZSBzZWdtZW50IHJlc3BvbnNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudEluZm9cbiAgICAgKiAgICAgICAgYSBzZWdtZW50IGluZm8gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBjdXJyZW50IHNlZ21lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwYXJzZVZUVEN1ZXNfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VWVFRDdWVzXyhzZWdtZW50SW5mbykge1xuICAgICAgdmFyIGRlY29kZXIgPSB2b2lkIDA7XG4gICAgICB2YXIgZGVjb2RlQnl0ZXNUb1N0cmluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyQxLlRleHREZWNvZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRlY29kZXIgPSBuZXcgd2luZG93JDEuVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlY29kZXIgPSB3aW5kb3ckMS5XZWJWVFQuU3RyaW5nRGVjb2RlcigpO1xuICAgICAgICBkZWNvZGVCeXRlc1RvU3RyaW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnNlciA9IG5ldyB3aW5kb3ckMS5XZWJWVFQuUGFyc2VyKHdpbmRvdyQxLCB3aW5kb3ckMS52dHRqcywgZGVjb2Rlcik7XG5cbiAgICAgIHNlZ21lbnRJbmZvLmN1ZXMgPSBbXTtcbiAgICAgIHNlZ21lbnRJbmZvLnRpbWVzdGFtcG1hcCA9IHsgTVBFR1RTOiAwLCBMT0NBTDogMCB9O1xuXG4gICAgICBwYXJzZXIub25jdWUgPSBzZWdtZW50SW5mby5jdWVzLnB1c2guYmluZChzZWdtZW50SW5mby5jdWVzKTtcbiAgICAgIHBhcnNlci5vbnRpbWVzdGFtcG1hcCA9IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnRJbmZvLnRpbWVzdGFtcG1hcCA9IG1hcDtcbiAgICAgIH07XG4gICAgICBwYXJzZXIub25wYXJzaW5nZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdmlkZW9qcyQxLmxvZy53YXJuKCdFcnJvciBlbmNvdW50ZXJlZCB3aGVuIHBhcnNpbmcgY3VlczogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfTtcblxuICAgICAgaWYgKHNlZ21lbnRJbmZvLnNlZ21lbnQubWFwKSB7XG4gICAgICAgIHZhciBtYXBEYXRhID0gc2VnbWVudEluZm8uc2VnbWVudC5tYXAuYnl0ZXM7XG5cbiAgICAgICAgaWYgKGRlY29kZUJ5dGVzVG9TdHJpbmcpIHtcbiAgICAgICAgICBtYXBEYXRhID0gdWludFRvU3RyaW5nKG1hcERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VyLnBhcnNlKG1hcERhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VnbWVudERhdGEgPSBzZWdtZW50SW5mby5ieXRlcztcblxuICAgICAgaWYgKGRlY29kZUJ5dGVzVG9TdHJpbmcpIHtcbiAgICAgICAgc2VnbWVudERhdGEgPSB1aW50VG9TdHJpbmcoc2VnbWVudERhdGEpO1xuICAgICAgfVxuXG4gICAgICBwYXJzZXIucGFyc2Uoc2VnbWVudERhdGEpO1xuICAgICAgcGFyc2VyLmZsdXNoKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgc3RhcnQgYW5kIGVuZCB0aW1lcyBvZiBhbnkgY3VlcyBwYXJzZWQgYnkgdGhlIFdlYlZUVCBwYXJzZXIgdXNpbmdcbiAgICAgKiB0aGUgaW5mb3JtYXRpb24gcGFyc2VkIGZyb20gdGhlIFgtVElNRVNUQU1QLU1BUCBoZWFkZXIgYW5kIGEgVFMgdG8gbWVkaWEgdGltZSBtYXBwaW5nXG4gICAgICogZnJvbSB0aGUgU3luY0NvbnRyb2xsZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWdtZW50SW5mb1xuICAgICAqICAgICAgICBhIHNlZ21lbnQgaW5mbyBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIGN1cnJlbnQgc2VnbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBwaW5nT2JqXG4gICAgICogICAgICAgIG9iamVjdCBjb250YWluaW5nIGEgbWFwcGluZyBmcm9tIFRTIHRvIG1lZGlhIHRpbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3RcbiAgICAgKiAgICAgICAgdGhlIHBsYXlsaXN0IG9iamVjdCBjb250YWluaW5nIHRoZSBzZWdtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlVGltZU1hcHBpbmdfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVGltZU1hcHBpbmdfKHNlZ21lbnRJbmZvLCBtYXBwaW5nT2JqLCBwbGF5bGlzdCkge1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50SW5mby5zZWdtZW50O1xuXG4gICAgICBpZiAoIW1hcHBpbmdPYmopIHtcbiAgICAgICAgLy8gSWYgdGhlIHN5bmMgY29udHJvbGxlciBkb2VzIG5vdCBoYXZlIGEgbWFwcGluZyBvZiBUUyB0byBNZWRpYSBUaW1lIGZvciB0aGVcbiAgICAgICAgLy8gdGltZWxpbmUsIHRoZW4gd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggaW5mb3JtYXRpb24gdG8gdXBkYXRlIHRoZSBjdWVcbiAgICAgICAgLy8gc3RhcnQvZW5kIHRpbWVzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWdtZW50SW5mby5jdWVzLmxlbmd0aCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gY3Vlcywgd2UgYWxzbyBkbyBub3QgaGF2ZSBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZmlndXJlIG91dFxuICAgICAgICAvLyBzZWdtZW50IHRpbWluZy4gTWFyayB0aGF0IHRoZSBzZWdtZW50IGNvbnRhaW5zIG5vIGN1ZXMgc28gd2UgZG9uJ3QgcmUtcmVxdWVzdFxuICAgICAgICAvLyBhbiBlbXB0eSBzZWdtZW50LlxuICAgICAgICBzZWdtZW50LmVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZXN0YW1wbWFwID0gc2VnbWVudEluZm8udGltZXN0YW1wbWFwO1xuICAgICAgdmFyIGRpZmYgPSB0aW1lc3RhbXBtYXAuTVBFR1RTIC8gOTAwMDAgLSB0aW1lc3RhbXBtYXAuTE9DQUwgKyBtYXBwaW5nT2JqLm1hcHBpbmc7XG5cbiAgICAgIHNlZ21lbnRJbmZvLmN1ZXMuZm9yRWFjaChmdW5jdGlvbiAoY3VlKSB7XG4gICAgICAgIC8vIEZpcnN0IGNvbnZlcnQgY3VlIHRpbWUgdG8gVFMgdGltZSB1c2luZyB0aGUgdGltZXN0YW1wLW1hcCBwcm92aWRlZCB3aXRoaW4gdGhlIHZ0dFxuICAgICAgICBjdWUuc3RhcnRUaW1lICs9IGRpZmY7XG4gICAgICAgIGN1ZS5lbmRUaW1lICs9IGRpZmY7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFwbGF5bGlzdC5zeW5jSW5mbykge1xuICAgICAgICB2YXIgZmlyc3RTdGFydCA9IHNlZ21lbnRJbmZvLmN1ZXNbMF0uc3RhcnRUaW1lO1xuICAgICAgICB2YXIgbGFzdFN0YXJ0ID0gc2VnbWVudEluZm8uY3Vlc1tzZWdtZW50SW5mby5jdWVzLmxlbmd0aCAtIDFdLnN0YXJ0VGltZTtcblxuICAgICAgICBwbGF5bGlzdC5zeW5jSW5mbyA9IHtcbiAgICAgICAgICBtZWRpYVNlcXVlbmNlOiBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlICsgc2VnbWVudEluZm8ubWVkaWFJbmRleCxcbiAgICAgICAgICB0aW1lOiBNYXRoLm1pbihmaXJzdFN0YXJ0LCBsYXN0U3RhcnQgLSBzZWdtZW50LmR1cmF0aW9uKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVlRUU2VnbWVudExvYWRlcjtcbn0oU2VnbWVudExvYWRlcik7XG5cbi8qKlxuICogQGZpbGUgYWQtY3VlLXRhZ3MuanNcbiAqL1xuXG4vKipcbiAqIFNlYXJjaGVzIGZvciBhbiBhZCBjdWUgdGhhdCBvdmVybGFwcyB3aXRoIHRoZSBnaXZlbiBtZWRpYVRpbWVcbiAqL1xudmFyIGZpbmRBZEN1ZSA9IGZ1bmN0aW9uIGZpbmRBZEN1ZSh0cmFjaywgbWVkaWFUaW1lKSB7XG4gIHZhciBjdWVzID0gdHJhY2suY3VlcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3VlID0gY3Vlc1tpXTtcblxuICAgIGlmIChtZWRpYVRpbWUgPj0gY3VlLmFkU3RhcnRUaW1lICYmIG1lZGlhVGltZSA8PSBjdWUuYWRFbmRUaW1lKSB7XG4gICAgICByZXR1cm4gY3VlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciB1cGRhdGVBZEN1ZXMgPSBmdW5jdGlvbiB1cGRhdGVBZEN1ZXMobWVkaWEsIHRyYWNrKSB7XG4gIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG5cbiAgaWYgKCFtZWRpYS5zZWdtZW50cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtZWRpYVRpbWUgPSBvZmZzZXQ7XG4gIHZhciBjdWUgPSB2b2lkIDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWRpYS5zZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gbWVkaWEuc2VnbWVudHNbaV07XG5cbiAgICBpZiAoIWN1ZSkge1xuICAgICAgLy8gU2luY2UgdGhlIGN1ZXMgd2lsbCBzcGFuIGZvciBhdCBsZWFzdCB0aGUgc2VnbWVudCBkdXJhdGlvbiwgYWRkaW5nIGEgZnVkZ2VcbiAgICAgIC8vIGZhY3RvciBvZiBoYWxmIHNlZ21lbnQgZHVyYXRpb24gd2lsbCBwcmV2ZW50IGR1cGxpY2F0ZSBjdWVzIGZyb20gYmVpbmdcbiAgICAgIC8vIGNyZWF0ZWQgd2hlbiB0aW1pbmcgaW5mbyBpcyBub3QgZXhhY3QgKGUuZy4gY3VlIHN0YXJ0IHRpbWUgaW5pdGlhbGl6ZWRcbiAgICAgIC8vIGF0IDEwLjAwNjY3NywgYnV0IG5leHQgY2FsbCBtZWRpYVRpbWUgaXMgMTAuMDAzMzMyIClcbiAgICAgIGN1ZSA9IGZpbmRBZEN1ZSh0cmFjaywgbWVkaWFUaW1lICsgc2VnbWVudC5kdXJhdGlvbiAvIDIpO1xuICAgIH1cblxuICAgIGlmIChjdWUpIHtcbiAgICAgIGlmICgnY3VlSW4nIGluIHNlZ21lbnQpIHtcbiAgICAgICAgLy8gRm91bmQgYSBDVUUtSU4gc28gZW5kIHRoZSBjdWVcbiAgICAgICAgY3VlLmVuZFRpbWUgPSBtZWRpYVRpbWU7XG4gICAgICAgIGN1ZS5hZEVuZFRpbWUgPSBtZWRpYVRpbWU7XG4gICAgICAgIG1lZGlhVGltZSArPSBzZWdtZW50LmR1cmF0aW9uO1xuICAgICAgICBjdWUgPSBudWxsO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhVGltZSA8IGN1ZS5lbmRUaW1lKSB7XG4gICAgICAgIC8vIEFscmVhZHkgcHJvY2Vzc2VkIHRoaXMgbWVkaWFUaW1lIGZvciB0aGlzIGN1ZVxuICAgICAgICBtZWRpYVRpbWUgKz0gc2VnbWVudC5kdXJhdGlvbjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIG90aGVyd2lzZSBleHRlbmQgY3VlIHVudGlsIGEgQ1VFLUlOIGlzIGZvdW5kXG4gICAgICBjdWUuZW5kVGltZSArPSBzZWdtZW50LmR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJ2N1ZU91dCcgaW4gc2VnbWVudCkge1xuICAgICAgICBjdWUgPSBuZXcgd2luZG93JDEuVlRUQ3VlKG1lZGlhVGltZSwgbWVkaWFUaW1lICsgc2VnbWVudC5kdXJhdGlvbiwgc2VnbWVudC5jdWVPdXQpO1xuICAgICAgICBjdWUuYWRTdGFydFRpbWUgPSBtZWRpYVRpbWU7XG4gICAgICAgIC8vIEFzc3VtZXMgdGFnIGZvcm1hdCB0byBiZVxuICAgICAgICAvLyAjRVhULVgtQ1VFLU9VVDozMFxuICAgICAgICBjdWUuYWRFbmRUaW1lID0gbWVkaWFUaW1lICsgcGFyc2VGbG9hdChzZWdtZW50LmN1ZU91dCk7XG4gICAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ2N1ZU91dENvbnQnIGluIHNlZ21lbnQpIHtcbiAgICAgICAgLy8gRW50ZXJlZCBpbnRvIHRoZSBtaWRkbGUgb2YgYW4gYWQgY3VlXG4gICAgICAgIHZhciBhZE9mZnNldCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGFkVG90YWwgPSB2b2lkIDA7XG5cbiAgICAgICAgLy8gQXNzdW1lcyB0YWcgZm9ybWF0ZSB0byBiZVxuICAgICAgICAvLyAjRVhULVgtQ1VFLU9VVC1DT05UOjEwLzMwXG5cbiAgICAgICAgdmFyIF9zZWdtZW50JGN1ZU91dENvbnQkcyA9IHNlZ21lbnQuY3VlT3V0Q29udC5zcGxpdCgnLycpLm1hcChwYXJzZUZsb2F0KTtcblxuICAgICAgICB2YXIgX3NlZ21lbnQkY3VlT3V0Q29udCRzMiA9IHNsaWNlZFRvQXJyYXkkMShfc2VnbWVudCRjdWVPdXRDb250JHMsIDIpO1xuXG4gICAgICAgIGFkT2Zmc2V0ID0gX3NlZ21lbnQkY3VlT3V0Q29udCRzMlswXTtcbiAgICAgICAgYWRUb3RhbCA9IF9zZWdtZW50JGN1ZU91dENvbnQkczJbMV07XG5cbiAgICAgICAgY3VlID0gbmV3IHdpbmRvdyQxLlZUVEN1ZShtZWRpYVRpbWUsIG1lZGlhVGltZSArIHNlZ21lbnQuZHVyYXRpb24sICcnKTtcbiAgICAgICAgY3VlLmFkU3RhcnRUaW1lID0gbWVkaWFUaW1lIC0gYWRPZmZzZXQ7XG4gICAgICAgIGN1ZS5hZEVuZFRpbWUgPSBjdWUuYWRTdGFydFRpbWUgKyBhZFRvdGFsO1xuICAgICAgICB0cmFjay5hZGRDdWUoY3VlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWVkaWFUaW1lICs9IHNlZ21lbnQuZHVyYXRpb247XG4gIH1cbn07XG5cbi8qKlxuICogQGZpbGUgc3luYy1jb250cm9sbGVyLmpzXG4gKi9cblxudmFyIHRzcHJvYmUgPSB0c0luc3BlY3Rvci5pbnNwZWN0O1xuXG52YXIgc3luY1BvaW50U3RyYXRlZ2llcyA9IFtcbi8vIFN0YXRlZ3kgXCJWT0RcIjogSGFuZGxlIHRoZSBWT0QtY2FzZSB3aGVyZSB0aGUgc3luYy1wb2ludCBpcyAqYWx3YXlzKlxuLy8gICAgICAgICAgICAgICAgdGhlIGVxdWl2YWxlbmNlIGRpc3BsYXktdGltZSAwID09PSBzZWdtZW50LWluZGV4IDBcbntcbiAgbmFtZTogJ1ZPRCcsXG4gIHJ1bjogZnVuY3Rpb24gcnVuKHN5bmNDb250cm9sbGVyLCBwbGF5bGlzdCwgZHVyYXRpb24kJDEsIGN1cnJlbnRUaW1lbGluZSwgY3VycmVudFRpbWUpIHtcbiAgICBpZiAoZHVyYXRpb24kJDEgIT09IEluZmluaXR5KSB7XG4gICAgICB2YXIgc3luY1BvaW50ID0ge1xuICAgICAgICB0aW1lOiAwLFxuICAgICAgICBzZWdtZW50SW5kZXg6IDBcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBzeW5jUG9pbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59LFxuLy8gU3RhdGVneSBcIlByb2dyYW1EYXRlVGltZVwiOiBXZSBoYXZlIGEgcHJvZ3JhbS1kYXRlLXRpbWUgdGFnIGluIHRoaXMgcGxheWxpc3RcbntcbiAgbmFtZTogJ1Byb2dyYW1EYXRlVGltZScsXG4gIHJ1bjogZnVuY3Rpb24gcnVuKHN5bmNDb250cm9sbGVyLCBwbGF5bGlzdCwgZHVyYXRpb24kJDEsIGN1cnJlbnRUaW1lbGluZSwgY3VycmVudFRpbWUpIHtcbiAgICBpZiAoIXN5bmNDb250cm9sbGVyLmRhdGV0aW1lVG9EaXNwbGF5VGltZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHNlZ21lbnRzID0gcGxheWxpc3Quc2VnbWVudHMgfHwgW107XG4gICAgdmFyIHN5bmNQb2ludCA9IG51bGw7XG4gICAgdmFyIGxhc3REaXN0YW5jZSA9IG51bGw7XG5cbiAgICBjdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lIHx8IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXG4gICAgICBpZiAoc2VnbWVudC5kYXRlVGltZU9iamVjdCkge1xuICAgICAgICB2YXIgc2VnbWVudFRpbWUgPSBzZWdtZW50LmRhdGVUaW1lT2JqZWN0LmdldFRpbWUoKSAvIDEwMDA7XG4gICAgICAgIHZhciBzZWdtZW50U3RhcnQgPSBzZWdtZW50VGltZSArIHN5bmNDb250cm9sbGVyLmRhdGV0aW1lVG9EaXNwbGF5VGltZTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5hYnMoY3VycmVudFRpbWUgLSBzZWdtZW50U3RhcnQpO1xuXG4gICAgICAgIC8vIE9uY2UgdGhlIGRpc3RhbmNlIGJlZ2lucyB0byBpbmNyZWFzZSwgd2UgaGF2ZSBwYXNzZWRcbiAgICAgICAgLy8gY3VycmVudFRpbWUgYW5kIGNhbiBzdG9wIGxvb2tpbmcgZm9yIGJldHRlciBjYW5kaWRhdGVzXG4gICAgICAgIGlmIChsYXN0RGlzdGFuY2UgIT09IG51bGwgJiYgbGFzdERpc3RhbmNlIDwgZGlzdGFuY2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICBzeW5jUG9pbnQgPSB7XG4gICAgICAgICAgdGltZTogc2VnbWVudFN0YXJ0LFxuICAgICAgICAgIHNlZ21lbnRJbmRleDogaVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3luY1BvaW50O1xuICB9XG59LFxuLy8gU3RhdGVneSBcIlNlZ21lbnRcIjogV2UgaGF2ZSBhIGtub3duIHRpbWUgbWFwcGluZyBmb3IgYSB0aW1lbGluZSBhbmQgYVxuLy8gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQgaW4gdGhlIGN1cnJlbnQgdGltZWxpbmUgd2l0aCB0aW1pbmcgZGF0YVxue1xuICBuYW1lOiAnU2VnbWVudCcsXG4gIHJ1bjogZnVuY3Rpb24gcnVuKHN5bmNDb250cm9sbGVyLCBwbGF5bGlzdCwgZHVyYXRpb24kJDEsIGN1cnJlbnRUaW1lbGluZSwgY3VycmVudFRpbWUpIHtcbiAgICB2YXIgc2VnbWVudHMgPSBwbGF5bGlzdC5zZWdtZW50cyB8fCBbXTtcbiAgICB2YXIgc3luY1BvaW50ID0gbnVsbDtcbiAgICB2YXIgbGFzdERpc3RhbmNlID0gbnVsbDtcblxuICAgIGN1cnJlbnRUaW1lID0gY3VycmVudFRpbWUgfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cbiAgICAgIGlmIChzZWdtZW50LnRpbWVsaW5lID09PSBjdXJyZW50VGltZWxpbmUgJiYgdHlwZW9mIHNlZ21lbnQuc3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKGN1cnJlbnRUaW1lIC0gc2VnbWVudC5zdGFydCk7XG5cbiAgICAgICAgLy8gT25jZSB0aGUgZGlzdGFuY2UgYmVnaW5zIHRvIGluY3JlYXNlLCB3ZSBoYXZlIHBhc3NlZFxuICAgICAgICAvLyBjdXJyZW50VGltZSBhbmQgY2FuIHN0b3AgbG9va2luZyBmb3IgYmV0dGVyIGNhbmRpZGF0ZXNcbiAgICAgICAgaWYgKGxhc3REaXN0YW5jZSAhPT0gbnVsbCAmJiBsYXN0RGlzdGFuY2UgPCBkaXN0YW5jZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzeW5jUG9pbnQgfHwgbGFzdERpc3RhbmNlID09PSBudWxsIHx8IGxhc3REaXN0YW5jZSA+PSBkaXN0YW5jZSkge1xuICAgICAgICAgIGxhc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgIHN5bmNQb2ludCA9IHtcbiAgICAgICAgICAgIHRpbWU6IHNlZ21lbnQuc3RhcnQsXG4gICAgICAgICAgICBzZWdtZW50SW5kZXg6IGlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzeW5jUG9pbnQ7XG4gIH1cbn0sXG4vLyBTdGF0ZWd5IFwiRGlzY29udGludWl0eVwiOiBXZSBoYXZlIGEgZGlzY29udGludWl0eSB3aXRoIGEga25vd25cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LXRpbWVcbntcbiAgbmFtZTogJ0Rpc2NvbnRpbnVpdHknLFxuICBydW46IGZ1bmN0aW9uIHJ1bihzeW5jQ29udHJvbGxlciwgcGxheWxpc3QsIGR1cmF0aW9uJCQxLCBjdXJyZW50VGltZWxpbmUsIGN1cnJlbnRUaW1lKSB7XG4gICAgdmFyIHN5bmNQb2ludCA9IG51bGw7XG5cbiAgICBjdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lIHx8IDA7XG5cbiAgICBpZiAocGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0cyAmJiBwbGF5bGlzdC5kaXNjb250aW51aXR5U3RhcnRzLmxlbmd0aCkge1xuICAgICAgdmFyIGxhc3REaXN0YW5jZSA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VnbWVudEluZGV4ID0gcGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0c1tpXTtcbiAgICAgICAgdmFyIGRpc2NvbnRpbnVpdHkgPSBwbGF5bGlzdC5kaXNjb250aW51aXR5U2VxdWVuY2UgKyBpICsgMTtcbiAgICAgICAgdmFyIGRpc2NvbnRpbnVpdHlTeW5jID0gc3luY0NvbnRyb2xsZXIuZGlzY29udGludWl0aWVzW2Rpc2NvbnRpbnVpdHldO1xuXG4gICAgICAgIGlmIChkaXNjb250aW51aXR5U3luYykge1xuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKGN1cnJlbnRUaW1lIC0gZGlzY29udGludWl0eVN5bmMudGltZSk7XG5cbiAgICAgICAgICAvLyBPbmNlIHRoZSBkaXN0YW5jZSBiZWdpbnMgdG8gaW5jcmVhc2UsIHdlIGhhdmUgcGFzc2VkXG4gICAgICAgICAgLy8gY3VycmVudFRpbWUgYW5kIGNhbiBzdG9wIGxvb2tpbmcgZm9yIGJldHRlciBjYW5kaWRhdGVzXG4gICAgICAgICAgaWYgKGxhc3REaXN0YW5jZSAhPT0gbnVsbCAmJiBsYXN0RGlzdGFuY2UgPCBkaXN0YW5jZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFzeW5jUG9pbnQgfHwgbGFzdERpc3RhbmNlID09PSBudWxsIHx8IGxhc3REaXN0YW5jZSA+PSBkaXN0YW5jZSkge1xuICAgICAgICAgICAgbGFzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICBzeW5jUG9pbnQgPSB7XG4gICAgICAgICAgICAgIHRpbWU6IGRpc2NvbnRpbnVpdHlTeW5jLnRpbWUsXG4gICAgICAgICAgICAgIHNlZ21lbnRJbmRleDogc2VnbWVudEluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3luY1BvaW50O1xuICB9XG59LFxuLy8gU3RhdGVneSBcIlBsYXlsaXN0XCI6IFdlIGhhdmUgYSBwbGF5bGlzdCB3aXRoIGEga25vd24gbWFwcGluZyBvZlxuLy8gICAgICAgICAgICAgICAgICAgICBzZWdtZW50IGluZGV4IHRvIGRpc3BsYXkgdGltZVxue1xuICBuYW1lOiAnUGxheWxpc3QnLFxuICBydW46IGZ1bmN0aW9uIHJ1bihzeW5jQ29udHJvbGxlciwgcGxheWxpc3QsIGR1cmF0aW9uJCQxLCBjdXJyZW50VGltZWxpbmUsIGN1cnJlbnRUaW1lKSB7XG4gICAgaWYgKHBsYXlsaXN0LnN5bmNJbmZvKSB7XG4gICAgICB2YXIgc3luY1BvaW50ID0ge1xuICAgICAgICB0aW1lOiBwbGF5bGlzdC5zeW5jSW5mby50aW1lLFxuICAgICAgICBzZWdtZW50SW5kZXg6IHBsYXlsaXN0LnN5bmNJbmZvLm1lZGlhU2VxdWVuY2UgLSBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gc3luY1BvaW50O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufV07XG5cbnZhciBTeW5jQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfdmlkZW9qcyRFdmVudFRhcmdldCkge1xuICBpbmhlcml0cyQxKFN5bmNDb250cm9sbGVyLCBfdmlkZW9qcyRFdmVudFRhcmdldCk7XG5cbiAgZnVuY3Rpb24gU3luY0NvbnRyb2xsZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2skMSh0aGlzLCBTeW5jQ29udHJvbGxlcik7XG5cbiAgICAvLyBTZWdtZW50IExvYWRlciBzdGF0ZSB2YXJpYWJsZXMuLi5cbiAgICAvLyAuLi5mb3Igc3luY2hpbmcgYWNyb3NzIHZhcmlhbnRzXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiQxKHRoaXMsIChTeW5jQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN5bmNDb250cm9sbGVyKSkuY2FsbCh0aGlzKSk7XG5cbiAgICBfdGhpcy5pbnNwZWN0Q2FjaGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gLi4uZm9yIHN5bmNoaW5nIGFjcm9zcyB2YXJpYW50c1xuICAgIF90aGlzLnRpbWVsaW5lcyA9IFtdO1xuICAgIF90aGlzLmRpc2NvbnRpbnVpdGllcyA9IFtdO1xuICAgIF90aGlzLmRhdGV0aW1lVG9EaXNwbGF5VGltZSA9IG51bGw7XG5cbiAgICBfdGhpcy5sb2dnZXJfID0gbG9nZ2VyKCdTeW5jQ29udHJvbGxlcicpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGEgc3luYy1wb2ludCBmb3IgdGhlIHBsYXlsaXN0IHNwZWNpZmllZFxuICAgKlxuICAgKiBBIHN5bmMtcG9pbnQgaXMgZGVmaW5lZCBhcyBhIGtub3duIG1hcHBpbmcgZnJvbSBkaXNwbGF5LXRpbWUgdG9cbiAgICogYSBzZWdtZW50LWluZGV4IGluIHRoZSBjdXJyZW50IHBsYXlsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXlsaXN0fSBwbGF5bGlzdFxuICAgKiAgICAgICAgVGhlIHBsYXlsaXN0IHRoYXQgbmVlZHMgYSBzeW5jLXBvaW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvblxuICAgKiAgICAgICAgRHVyYXRpb24gb2YgdGhlIE1lZGlhU291cmNlIChJbmZpbml0ZSBpZiBwbGF5aW5nIGEgbGl2ZSBzb3VyY2UpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50VGltZWxpbmVcbiAgICogICAgICAgIFRoZSBsYXN0IHRpbWVsaW5lIGZyb20gd2hpY2ggYSBzZWdtZW50IHdhcyBsb2FkZWRcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogICAgICAgICAgQSBzeW5jLXBvaW50IG9iamVjdFxuICAgKi9cblxuICBjcmVhdGVDbGFzcyQxKFN5bmNDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ2dldFN5bmNQb2ludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN5bmNQb2ludChwbGF5bGlzdCwgZHVyYXRpb24kJDEsIGN1cnJlbnRUaW1lbGluZSwgY3VycmVudFRpbWUpIHtcbiAgICAgIHZhciBzeW5jUG9pbnRzID0gdGhpcy5ydW5TdHJhdGVnaWVzXyhwbGF5bGlzdCwgZHVyYXRpb24kJDEsIGN1cnJlbnRUaW1lbGluZSwgY3VycmVudFRpbWUpO1xuXG4gICAgICBpZiAoIXN5bmNQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIFNpZ25hbCB0aGF0IHdlIG5lZWQgdG8gYXR0ZW1wdCB0byBnZXQgYSBzeW5jLXBvaW50IG1hbnVhbGx5XG4gICAgICAgIC8vIGJ5IGZldGNoaW5nIGEgc2VnbWVudCBpbiB0aGUgcGxheWxpc3QgYW5kIGNvbnN0cnVjdGluZ1xuICAgICAgICAvLyBhIHN5bmMtcG9pbnQgZnJvbSB0aGF0IGluZm9ybWF0aW9uXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3cgZmluZCB0aGUgc3luYy1wb2ludCB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIGN1cnJlbnRUaW1lIGJlY2F1c2VcbiAgICAgIC8vIHRoYXQgc2hvdWxkIHJlc3VsdCBpbiB0aGUgbW9zdCBhY2N1cmF0ZSBndWVzcyBhYm91dCB3aGljaCBzZWdtZW50XG4gICAgICAvLyB0byBmZXRjaFxuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0U3luY1BvaW50XyhzeW5jUG9pbnRzLCB7IGtleTogJ3RpbWUnLCB2YWx1ZTogY3VycmVudFRpbWUgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGhhcyBleHBpcmVkIG9mZiB0aGUgcGxheWxpc3QgZHVyaW5nIHBsYXliYWNrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BsYXlsaXN0fSBwbGF5bGlzdFxuICAgICAqICAgICAgICBQbGF5bGlzdCBvYmplY3QgdG8gY2FsY3VsYXRlIGV4cGlyZWQgZnJvbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvblxuICAgICAqICAgICAgICBEdXJhdGlvbiBvZiB0aGUgTWVkaWFTb3VyY2UgKEluZmluaXR5IGlmIHBsYXlsaW5nIGEgbGl2ZSBzb3VyY2UpXG4gICAgICogQHJldHVybnMge051bWJlcnxudWxsfVxuICAgICAqICAgICAgICAgIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGhhcyBleHBpcmVkIG9mZiB0aGUgcGxheWxpc3QgZHVyaW5nIHBsYXliYWNrLiBOdWxsXG4gICAgICogICAgICAgICAgaWYgbm8gc3luYy1wb2ludHMgZm9yIHRoZSBwbGF5bGlzdCBjYW4gYmUgZm91bmQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEV4cGlyZWRUaW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RXhwaXJlZFRpbWUocGxheWxpc3QsIGR1cmF0aW9uJCQxKSB7XG4gICAgICBpZiAoIXBsYXlsaXN0IHx8ICFwbGF5bGlzdC5zZWdtZW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHN5bmNQb2ludHMgPSB0aGlzLnJ1blN0cmF0ZWdpZXNfKHBsYXlsaXN0LCBkdXJhdGlvbiQkMSwgcGxheWxpc3QuZGlzY29udGludWl0eVNlcXVlbmNlLCAwKTtcblxuICAgICAgLy8gV2l0aG91dCBzeW5jLXBvaW50cywgdGhlcmUgaXMgbm90IGVub3VnaCBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgdGhlIGV4cGlyZWQgdGltZVxuICAgICAgaWYgKCFzeW5jUG9pbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHN5bmNQb2ludCA9IHRoaXMuc2VsZWN0U3luY1BvaW50XyhzeW5jUG9pbnRzLCB7XG4gICAgICAgIGtleTogJ3NlZ21lbnRJbmRleCcsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgdGhlIHN5bmMtcG9pbnQgaXMgYmV5b25kIHRoZSBzdGFydCBvZiB0aGUgcGxheWxpc3QsIHdlIHdhbnQgdG8gc3VidHJhY3QgdGhlXG4gICAgICAvLyBkdXJhdGlvbiBmcm9tIGluZGV4IDAgdG8gc3luY1BvaW50LnNlZ21lbnRJbmRleCBpbnN0ZWFkIG9mIGFkZGluZy5cbiAgICAgIGlmIChzeW5jUG9pbnQuc2VnbWVudEluZGV4ID4gMCkge1xuICAgICAgICBzeW5jUG9pbnQudGltZSAqPSAtMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGguYWJzKHN5bmNQb2ludC50aW1lICsgc3VtRHVyYXRpb25zKHBsYXlsaXN0LCBzeW5jUG9pbnQuc2VnbWVudEluZGV4LCAwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBlYWNoIHN5bmMtcG9pbnQgc3RyYXRlZ3kgYW5kIHJldHVybnMgYSBsaXN0IG9mIHN5bmMtcG9pbnRzIHJldHVybmVkIGJ5IHRoZVxuICAgICAqIHN0cmF0ZWdpZXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQbGF5bGlzdH0gcGxheWxpc3RcbiAgICAgKiAgICAgICAgVGhlIHBsYXlsaXN0IHRoYXQgbmVlZHMgYSBzeW5jLXBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uXG4gICAgICogICAgICAgIER1cmF0aW9uIG9mIHRoZSBNZWRpYVNvdXJjZSAoSW5maW5pdHkgaWYgcGxheWluZyBhIGxpdmUgc291cmNlKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50VGltZWxpbmVcbiAgICAgKiAgICAgICAgVGhlIGxhc3QgdGltZWxpbmUgZnJvbSB3aGljaCBhIHNlZ21lbnQgd2FzIGxvYWRlZFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiAgICAgICAgICBBIGxpc3Qgb2Ygc3luYy1wb2ludCBvYmplY3RzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3J1blN0cmF0ZWdpZXNfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuU3RyYXRlZ2llc18ocGxheWxpc3QsIGR1cmF0aW9uJCQxLCBjdXJyZW50VGltZWxpbmUsIGN1cnJlbnRUaW1lKSB7XG4gICAgICB2YXIgc3luY1BvaW50cyA9IFtdO1xuXG4gICAgICAvLyBUcnkgdG8gZmluZCBhIHN5bmMtcG9pbnQgaW4gYnkgdXRpbGl6aW5nIHZhcmlvdXMgc3RyYXRlZ2llcy4uLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzeW5jUG9pbnRTdHJhdGVnaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdHJhdGVneSA9IHN5bmNQb2ludFN0cmF0ZWdpZXNbaV07XG4gICAgICAgIHZhciBzeW5jUG9pbnQgPSBzdHJhdGVneS5ydW4odGhpcywgcGxheWxpc3QsIGR1cmF0aW9uJCQxLCBjdXJyZW50VGltZWxpbmUsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgICBpZiAoc3luY1BvaW50KSB7XG4gICAgICAgICAgc3luY1BvaW50LnN0cmF0ZWd5ID0gc3RyYXRlZ3kubmFtZTtcbiAgICAgICAgICBzeW5jUG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgc3RyYXRlZ3k6IHN0cmF0ZWd5Lm5hbWUsXG4gICAgICAgICAgICBzeW5jUG9pbnQ6IHN5bmNQb2ludFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzeW5jUG9pbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIHN5bmMtcG9pbnQgbmVhcmVzdCB0aGUgc3BlY2lmaWVkIHRhcmdldFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzeW5jUG9pbnRzXG4gICAgICogICAgICAgIExpc3Qgb2Ygc3luYy1wb2ludHMgdG8gc2VsZWN0IGZyb21cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICogICAgICAgIE9iamVjdCBzcGVjaWZ5aW5nIHRoZSBwcm9wZXJ0eSBhbmQgdmFsdWUgd2UgYXJlIHRhcmdldGluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXQua2V5XG4gICAgICogICAgICAgIFNwZWNpZmllcyB0aGUgcHJvcGVydHkgdG8gdGFyZ2V0LiBNdXN0IGJlIGVpdGhlciAndGltZScgb3IgJ3NlZ21lbnRJbmRleCdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGFyZ2V0LnZhbHVlXG4gICAgICogICAgICAgIFRoZSB2YWx1ZSB0byB0YXJnZXQgZm9yIHRoZSBzcGVjaWZpZWQga2V5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogICAgICAgICAgVGhlIHN5bmMtcG9pbnQgbmVhcmVzdCB0aGUgdGFyZ2V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdFN5bmNQb2ludF8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RTeW5jUG9pbnRfKHN5bmNQb2ludHMsIHRhcmdldCkge1xuICAgICAgdmFyIGJlc3RTeW5jUG9pbnQgPSBzeW5jUG9pbnRzWzBdLnN5bmNQb2ludDtcbiAgICAgIHZhciBiZXN0RGlzdGFuY2UgPSBNYXRoLmFicyhzeW5jUG9pbnRzWzBdLnN5bmNQb2ludFt0YXJnZXQua2V5XSAtIHRhcmdldC52YWx1ZSk7XG4gICAgICB2YXIgYmVzdFN0cmF0ZWd5ID0gc3luY1BvaW50c1swXS5zdHJhdGVneTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzeW5jUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdEaXN0YW5jZSA9IE1hdGguYWJzKHN5bmNQb2ludHNbaV0uc3luY1BvaW50W3RhcmdldC5rZXldIC0gdGFyZ2V0LnZhbHVlKTtcblxuICAgICAgICBpZiAobmV3RGlzdGFuY2UgPCBiZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICBiZXN0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICBiZXN0U3luY1BvaW50ID0gc3luY1BvaW50c1tpXS5zeW5jUG9pbnQ7XG4gICAgICAgICAgYmVzdFN0cmF0ZWd5ID0gc3luY1BvaW50c1tpXS5zdHJhdGVneTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZ2dlcl8oJ3N5bmNQb2ludCBmb3IgWycgKyB0YXJnZXQua2V5ICsgJzogJyArIHRhcmdldC52YWx1ZSArICddIGNob3NlbiB3aXRoIHN0cmF0ZWd5JyArICgnIFsnICsgYmVzdFN0cmF0ZWd5ICsgJ106IFt0aW1lOicgKyBiZXN0U3luY1BvaW50LnRpbWUgKyAnLCcpICsgKCcgc2VnbWVudEluZGV4OicgKyBiZXN0U3luY1BvaW50LnNlZ21lbnRJbmRleCArICddJykpO1xuXG4gICAgICByZXR1cm4gYmVzdFN5bmNQb2ludDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIGFueSBtZXRhLWRhdGEgcHJlc2VudCBvbiB0aGUgc2VnbWVudHMgd2hlbiBzZWdtZW50cyBsZWF2ZVxuICAgICAqIHRoZSBsaXZlIHdpbmRvdyB0byB0aGUgcGxheWxpc3QgdG8gYWxsb3cgZm9yIHN5bmNocm9uaXphdGlvbiBhdCB0aGVcbiAgICAgKiBwbGF5bGlzdCBsZXZlbCBsYXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGxheWxpc3R9IG9sZFBsYXlsaXN0IC0gVGhlIHByZXZpb3VzIGFjdGl2ZSBwbGF5bGlzdFxuICAgICAqIEBwYXJhbSB7UGxheWxpc3R9IG5ld1BsYXlsaXN0IC0gVGhlIHVwZGF0ZWQgYW5kIG1vc3QgY3VycmVudCBwbGF5bGlzdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzYXZlRXhwaXJlZFNlZ21lbnRJbmZvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZUV4cGlyZWRTZWdtZW50SW5mbyhvbGRQbGF5bGlzdCwgbmV3UGxheWxpc3QpIHtcbiAgICAgIHZhciBtZWRpYVNlcXVlbmNlRGlmZiA9IG5ld1BsYXlsaXN0Lm1lZGlhU2VxdWVuY2UgLSBvbGRQbGF5bGlzdC5tZWRpYVNlcXVlbmNlO1xuXG4gICAgICAvLyBXaGVuIGEgc2VnbWVudCBleHBpcmVzIGZyb20gdGhlIHBsYXlsaXN0IGFuZCBpdCBoYXMgYSBzdGFydCB0aW1lXG4gICAgICAvLyBzYXZlIHRoYXQgaW5mb3JtYXRpb24gYXMgYSBwb3NzaWJsZSBzeW5jLXBvaW50IHJlZmVyZW5jZSBpbiBmdXR1cmVcbiAgICAgIGZvciAodmFyIGkgPSBtZWRpYVNlcXVlbmNlRGlmZiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBsYXN0UmVtb3ZlZFNlZ21lbnQgPSBvbGRQbGF5bGlzdC5zZWdtZW50c1tpXTtcblxuICAgICAgICBpZiAobGFzdFJlbW92ZWRTZWdtZW50ICYmIHR5cGVvZiBsYXN0UmVtb3ZlZFNlZ21lbnQuc3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbmV3UGxheWxpc3Quc3luY0luZm8gPSB7XG4gICAgICAgICAgICBtZWRpYVNlcXVlbmNlOiBvbGRQbGF5bGlzdC5tZWRpYVNlcXVlbmNlICsgaSxcbiAgICAgICAgICAgIHRpbWU6IGxhc3RSZW1vdmVkU2VnbWVudC5zdGFydFxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5sb2dnZXJfKCdwbGF5bGlzdCByZWZyZXNoIHN5bmM6IFt0aW1lOicgKyBuZXdQbGF5bGlzdC5zeW5jSW5mby50aW1lICsgJywnICsgKCcgbWVkaWFTZXF1ZW5jZTogJyArIG5ld1BsYXlsaXN0LnN5bmNJbmZvLm1lZGlhU2VxdWVuY2UgKyAnXScpKTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3N5bmNpbmZvdXBkYXRlJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSBtYXBwaW5nIGZyb20gcGxheWxpc3QncyBQcm9ncmFtRGF0ZVRpbWUgdG8gZGlzcGxheS4gVGhpcyBzaG91bGRcbiAgICAgKiBvbmx5IGV2ZXIgaGFwcGVuIG9uY2UgYXQgdGhlIHN0YXJ0IG9mIHBsYXliYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQbGF5bGlzdH0gcGxheWxpc3QgLSBUaGUgY3VycmVudGx5IGFjdGl2ZSBwbGF5bGlzdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXREYXRlVGltZU1hcHBpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRlVGltZU1hcHBpbmcocGxheWxpc3QpIHtcbiAgICAgIGlmICghdGhpcy5kYXRldGltZVRvRGlzcGxheVRpbWUgJiYgcGxheWxpc3Quc2VnbWVudHMgJiYgcGxheWxpc3Quc2VnbWVudHMubGVuZ3RoICYmIHBsYXlsaXN0LnNlZ21lbnRzWzBdLmRhdGVUaW1lT2JqZWN0KSB7XG4gICAgICAgIHZhciBwbGF5bGlzdFRpbWVzdGFtcCA9IHBsYXlsaXN0LnNlZ21lbnRzWzBdLmRhdGVUaW1lT2JqZWN0LmdldFRpbWUoKSAvIDEwMDA7XG5cbiAgICAgICAgdGhpcy5kYXRldGltZVRvRGlzcGxheVRpbWUgPSAtcGxheWxpc3RUaW1lc3RhbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHN0YXRlIG9mIHRoZSBpbnNwZWN0aW9uIGNhY2hlIHdoZW4gd2UgZG8gYSByZW5kaXRpb25cbiAgICAgKiBzd2l0Y2hcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuaW5zcGVjdENhY2hlXyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9iZSBvciBpbnNwZWN0IGEgZm1wNCBvciBhbiBtcGVnMi10cyBzZWdtZW50IHRvIGRldGVybWluZSB0aGUgc3RhcnRcbiAgICAgKiBhbmQgZW5kIG9mIHRoZSBzZWdtZW50IGluIGl0J3MgaW50ZXJuYWwgXCJtZWRpYSB0aW1lXCIuIFVzZWQgdG8gZ2VuZXJhdGVcbiAgICAgKiBtYXBwaW5ncyBmcm9tIHRoYXQgaW50ZXJuYWwgXCJtZWRpYSB0aW1lXCIgdG8gdGhlIGRpc3BsYXkgdGltZSB0aGF0IGlzXG4gICAgICogc2hvd24gb24gdGhlIHBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VnbWVudEluZm99IHNlZ21lbnRJbmZvIC0gVGhlIGN1cnJlbnQgYWN0aXZlIHJlcXVlc3QgaW5mb3JtYXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvYmVTZWdtZW50SW5mbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2JlU2VnbWVudEluZm8oc2VnbWVudEluZm8pIHtcbiAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudEluZm8uc2VnbWVudDtcbiAgICAgIHZhciBwbGF5bGlzdCA9IHNlZ21lbnRJbmZvLnBsYXlsaXN0O1xuICAgICAgdmFyIHRpbWluZ0luZm8gPSB2b2lkIDA7XG5cbiAgICAgIGlmIChzZWdtZW50Lm1hcCkge1xuICAgICAgICB0aW1pbmdJbmZvID0gdGhpcy5wcm9iZU1wNFNlZ21lbnRfKHNlZ21lbnRJbmZvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWluZ0luZm8gPSB0aGlzLnByb2JlVHNTZWdtZW50XyhzZWdtZW50SW5mbyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aW1pbmdJbmZvKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGN1bGF0ZVNlZ21lbnRUaW1lTWFwcGluZ18oc2VnbWVudEluZm8sIHRpbWluZ0luZm8pKSB7XG4gICAgICAgICAgdGhpcy5zYXZlRGlzY29udGludWl0eVN5bmNJbmZvXyhzZWdtZW50SW5mbyk7XG5cbiAgICAgICAgICAvLyBJZiB0aGUgcGxheWxpc3QgZG9lcyBub3QgaGF2ZSBzeW5jIGluZm9ybWF0aW9uIHlldCwgcmVjb3JkIHRoYXQgaW5mb3JtYXRpb25cbiAgICAgICAgICAvLyBub3cgd2l0aCBzZWdtZW50IHRpbWluZyBpbmZvcm1hdGlvblxuICAgICAgICAgIGlmICghcGxheWxpc3Quc3luY0luZm8pIHtcbiAgICAgICAgICAgIHBsYXlsaXN0LnN5bmNJbmZvID0ge1xuICAgICAgICAgICAgICBtZWRpYVNlcXVlbmNlOiBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlICsgc2VnbWVudEluZm8ubWVkaWFJbmRleCxcbiAgICAgICAgICAgICAgdGltZTogc2VnbWVudC5zdGFydFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRpbWluZ0luZm87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvYmUgYW4gZm1wNCBvciBhbiBtcGVnMi10cyBzZWdtZW50IHRvIGRldGVybWluZSB0aGUgc3RhcnQgb2YgdGhlIHNlZ21lbnRcbiAgICAgKiBpbiBpdCdzIGludGVybmFsIFwibWVkaWEgdGltZVwiLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1NlZ21lbnRJbmZvfSBzZWdtZW50SW5mbyAtIFRoZSBjdXJyZW50IGFjdGl2ZSByZXF1ZXN0IGluZm9ybWF0aW9uXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgc3RhcnQgYW5kIGVuZCB0aW1lIG9mIHRoZSBjdXJyZW50IHNlZ21lbnQgaW4gXCJtZWRpYSB0aW1lXCJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvYmVNcDRTZWdtZW50XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2JlTXA0U2VnbWVudF8oc2VnbWVudEluZm8pIHtcbiAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudEluZm8uc2VnbWVudDtcbiAgICAgIHZhciB0aW1lc2NhbGVzID0gbXA0cHJvYmUudGltZXNjYWxlKHNlZ21lbnQubWFwLmJ5dGVzKTtcbiAgICAgIHZhciBzdGFydFRpbWUgPSBtcDRwcm9iZS5zdGFydFRpbWUodGltZXNjYWxlcywgc2VnbWVudEluZm8uYnl0ZXMpO1xuXG4gICAgICBpZiAoc2VnbWVudEluZm8udGltZXN0YW1wT2Zmc2V0ICE9PSBudWxsKSB7XG4gICAgICAgIHNlZ21lbnRJbmZvLnRpbWVzdGFtcE9mZnNldCAtPSBzdGFydFRpbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydFRpbWUsXG4gICAgICAgIGVuZDogc3RhcnRUaW1lICsgc2VnbWVudC5kdXJhdGlvblxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9iZSBhbiBtcGVnMi10cyBzZWdtZW50IHRvIGRldGVybWluZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgc2VnbWVudFxuICAgICAqIGluIGl0J3MgaW50ZXJuYWwgXCJtZWRpYSB0aW1lXCIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U2VnbWVudEluZm99IHNlZ21lbnRJbmZvIC0gVGhlIGN1cnJlbnQgYWN0aXZlIHJlcXVlc3QgaW5mb3JtYXRpb25cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBzdGFydCBhbmQgZW5kIHRpbWUgb2YgdGhlIGN1cnJlbnQgc2VnbWVudCBpbiBcIm1lZGlhIHRpbWVcIlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9iZVRzU2VnbWVudF8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9iZVRzU2VnbWVudF8oc2VnbWVudEluZm8pIHtcbiAgICAgIHZhciB0aW1lSW5mbyA9IHRzcHJvYmUoc2VnbWVudEluZm8uYnl0ZXMsIHRoaXMuaW5zcGVjdENhY2hlXyk7XG4gICAgICB2YXIgc2VnbWVudFN0YXJ0VGltZSA9IHZvaWQgMDtcbiAgICAgIHZhciBzZWdtZW50RW5kVGltZSA9IHZvaWQgMDtcblxuICAgICAgaWYgKCF0aW1lSW5mbykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWVJbmZvLnZpZGVvICYmIHRpbWVJbmZvLnZpZGVvLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLmluc3BlY3RDYWNoZV8gPSB0aW1lSW5mby52aWRlb1sxXS5kdHM7XG4gICAgICAgIHNlZ21lbnRTdGFydFRpbWUgPSB0aW1lSW5mby52aWRlb1swXS5kdHNUaW1lO1xuICAgICAgICBzZWdtZW50RW5kVGltZSA9IHRpbWVJbmZvLnZpZGVvWzFdLmR0c1RpbWU7XG4gICAgICB9IGVsc2UgaWYgKHRpbWVJbmZvLmF1ZGlvICYmIHRpbWVJbmZvLmF1ZGlvLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLmluc3BlY3RDYWNoZV8gPSB0aW1lSW5mby5hdWRpb1sxXS5kdHM7XG4gICAgICAgIHNlZ21lbnRTdGFydFRpbWUgPSB0aW1lSW5mby5hdWRpb1swXS5kdHNUaW1lO1xuICAgICAgICBzZWdtZW50RW5kVGltZSA9IHRpbWVJbmZvLmF1ZGlvWzFdLmR0c1RpbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzZWdtZW50U3RhcnRUaW1lLFxuICAgICAgICBlbmQ6IHNlZ21lbnRFbmRUaW1lLFxuICAgICAgICBjb250YWluc1ZpZGVvOiB0aW1lSW5mby52aWRlbyAmJiB0aW1lSW5mby52aWRlby5sZW5ndGggPT09IDIsXG4gICAgICAgIGNvbnRhaW5zQXVkaW86IHRpbWVJbmZvLmF1ZGlvICYmIHRpbWVJbmZvLmF1ZGlvLmxlbmd0aCA9PT0gMlxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0aW1lc3RhbXBPZmZzZXRGb3JUaW1lbGluZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVzdGFtcE9mZnNldEZvclRpbWVsaW5lKHRpbWVsaW5lKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMudGltZWxpbmVzW3RpbWVsaW5lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aW1lbGluZXNbdGltZWxpbmVdLnRpbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWFwcGluZ0ZvclRpbWVsaW5lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwcGluZ0ZvclRpbWVsaW5lKHRpbWVsaW5lKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMudGltZWxpbmVzW3RpbWVsaW5lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aW1lbGluZXNbdGltZWxpbmVdLm1hcHBpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoZSBcIm1lZGlhIHRpbWVcIiBmb3IgYSBzZWdtZW50IHRvIGdlbmVyYXRlIGEgbWFwcGluZyB0byBcImRpc3BsYXkgdGltZVwiIGFuZFxuICAgICAqIHNhdmUgdGhhdCBkaXNwbGF5IHRpbWUgdG8gdGhlIHNlZ21lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U2VnbWVudEluZm99IHNlZ21lbnRJbmZvXG4gICAgICogICAgICAgIFRoZSBjdXJyZW50IGFjdGl2ZSByZXF1ZXN0IGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRpbWluZ0luZm9cbiAgICAgKiAgICAgICAgVGhlIHN0YXJ0IGFuZCBlbmQgdGltZSBvZiB0aGUgY3VycmVudCBzZWdtZW50IGluIFwibWVkaWEgdGltZVwiXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogICAgICAgICAgUmV0dXJucyBmYWxzZSBpZiBzZWdtZW50IHRpbWUgbWFwcGluZyBjb3VsZCBub3QgYmUgY2FsY3VsYXRlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVTZWdtZW50VGltZU1hcHBpbmdfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlU2VnbWVudFRpbWVNYXBwaW5nXyhzZWdtZW50SW5mbywgdGltaW5nSW5mbykge1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50SW5mby5zZWdtZW50O1xuICAgICAgdmFyIG1hcHBpbmdPYmogPSB0aGlzLnRpbWVsaW5lc1tzZWdtZW50SW5mby50aW1lbGluZV07XG5cbiAgICAgIGlmIChzZWdtZW50SW5mby50aW1lc3RhbXBPZmZzZXQgIT09IG51bGwpIHtcbiAgICAgICAgbWFwcGluZ09iaiA9IHtcbiAgICAgICAgICB0aW1lOiBzZWdtZW50SW5mby5zdGFydE9mU2VnbWVudCxcbiAgICAgICAgICBtYXBwaW5nOiBzZWdtZW50SW5mby5zdGFydE9mU2VnbWVudCAtIHRpbWluZ0luZm8uc3RhcnRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50aW1lbGluZXNbc2VnbWVudEluZm8udGltZWxpbmVdID0gbWFwcGluZ09iajtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd0aW1lc3RhbXBvZmZzZXQnKTtcblxuICAgICAgICB0aGlzLmxvZ2dlcl8oJ3RpbWUgbWFwcGluZyBmb3IgdGltZWxpbmUgJyArIHNlZ21lbnRJbmZvLnRpbWVsaW5lICsgJzogJyArICgnW3RpbWU6ICcgKyBtYXBwaW5nT2JqLnRpbWUgKyAnXSBbbWFwcGluZzogJyArIG1hcHBpbmdPYmoubWFwcGluZyArICddJykpO1xuXG4gICAgICAgIHNlZ21lbnQuc3RhcnQgPSBzZWdtZW50SW5mby5zdGFydE9mU2VnbWVudDtcbiAgICAgICAgc2VnbWVudC5lbmQgPSB0aW1pbmdJbmZvLmVuZCArIG1hcHBpbmdPYmoubWFwcGluZztcbiAgICAgIH0gZWxzZSBpZiAobWFwcGluZ09iaikge1xuICAgICAgICBzZWdtZW50LnN0YXJ0ID0gdGltaW5nSW5mby5zdGFydCArIG1hcHBpbmdPYmoubWFwcGluZztcbiAgICAgICAgc2VnbWVudC5lbmQgPSB0aW1pbmdJbmZvLmVuZCArIG1hcHBpbmdPYmoubWFwcGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWFjaCB0aW1lIHdlIGhhdmUgZGlzY29udGludWl0eSBpbiB0aGUgcGxheWxpc3QsIGF0dGVtcHQgdG8gY2FsY3VsYXRlIHRoZSBsb2NhdGlvblxuICAgICAqIGluIGRpc3BsYXkgb2YgdGhlIHN0YXJ0IG9mIHRoZSBkaXNjb250aW51aXR5IGFuZCBzYXZlIHRoYXQuIFdlIGFsc28gc2F2ZSBhbiBhY2N1cmFjeVxuICAgICAqIHZhbHVlIHNvIHRoYXQgd2Ugc2F2ZSB2YWx1ZXMgd2l0aCB0aGUgbW9zdCBhY2N1cmFjeSAoY2xvc2VzdCB0byAwLilcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTZWdtZW50SW5mb30gc2VnbWVudEluZm8gLSBUaGUgY3VycmVudCBhY3RpdmUgcmVxdWVzdCBpbmZvcm1hdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzYXZlRGlzY29udGludWl0eVN5bmNJbmZvXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhdmVEaXNjb250aW51aXR5U3luY0luZm9fKHNlZ21lbnRJbmZvKSB7XG4gICAgICB2YXIgcGxheWxpc3QgPSBzZWdtZW50SW5mby5wbGF5bGlzdDtcbiAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudEluZm8uc2VnbWVudDtcblxuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgc2VnbWVudCBpcyBhIGRpc2NvbnRpbnVpdHkgdGhlbiB3ZSBrbm93IGV4YWN0bHkgd2hlcmVcbiAgICAgIC8vIHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgYW5kIGl0J3MgYWNjdXJhY3kgaXMgMCAoZ3JlYXRlciBhY2N1cmFjeSB2YWx1ZXNcbiAgICAgIC8vIG1lYW4gbW9yZSBhcHByb3hpbWF0aW9uKVxuICAgICAgaWYgKHNlZ21lbnQuZGlzY29udGludWl0eSkge1xuICAgICAgICB0aGlzLmRpc2NvbnRpbnVpdGllc1tzZWdtZW50LnRpbWVsaW5lXSA9IHtcbiAgICAgICAgICB0aW1lOiBzZWdtZW50LnN0YXJ0LFxuICAgICAgICAgIGFjY3VyYWN5OiAwXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHBsYXlsaXN0LmRpc2NvbnRpbnVpdHlTdGFydHMgJiYgcGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gU2VhcmNoIGZvciBmdXR1cmUgZGlzY29udGludWl0aWVzIHRoYXQgd2UgY2FuIHByb3ZpZGUgYmV0dGVyIHRpbWluZ1xuICAgICAgICAvLyBpbmZvcm1hdGlvbiBmb3IgYW5kIHNhdmUgdGhhdCBpbmZvcm1hdGlvbiBmb3Igc3luYyBwdXJwb3Nlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYXlsaXN0LmRpc2NvbnRpbnVpdHlTdGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc2VnbWVudEluZGV4ID0gcGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0c1tpXTtcbiAgICAgICAgICB2YXIgZGlzY29udGludWl0eSA9IHBsYXlsaXN0LmRpc2NvbnRpbnVpdHlTZXF1ZW5jZSArIGkgKyAxO1xuICAgICAgICAgIHZhciBtZWRpYUluZGV4RGlmZiA9IHNlZ21lbnRJbmRleCAtIHNlZ21lbnRJbmZvLm1lZGlhSW5kZXg7XG4gICAgICAgICAgdmFyIGFjY3VyYWN5ID0gTWF0aC5hYnMobWVkaWFJbmRleERpZmYpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmRpc2NvbnRpbnVpdGllc1tkaXNjb250aW51aXR5XSB8fCB0aGlzLmRpc2NvbnRpbnVpdGllc1tkaXNjb250aW51aXR5XS5hY2N1cmFjeSA+IGFjY3VyYWN5KSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKG1lZGlhSW5kZXhEaWZmIDwgMCkge1xuICAgICAgICAgICAgICB0aW1lID0gc2VnbWVudC5zdGFydCAtIHN1bUR1cmF0aW9ucyhwbGF5bGlzdCwgc2VnbWVudEluZm8ubWVkaWFJbmRleCwgc2VnbWVudEluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRpbWUgPSBzZWdtZW50LmVuZCArIHN1bUR1cmF0aW9ucyhwbGF5bGlzdCwgc2VnbWVudEluZm8ubWVkaWFJbmRleCArIDEsIHNlZ21lbnRJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlzY29udGludWl0aWVzW2Rpc2NvbnRpbnVpdHldID0ge1xuICAgICAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgICAgICBhY2N1cmFjeTogYWNjdXJhY3lcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTeW5jQ29udHJvbGxlcjtcbn0odmlkZW9qcyQxLkV2ZW50VGFyZ2V0KTtcblxudmFyIERlY3J5cHRlciQxID0gbmV3IHNoaW1Xb3JrZXIoXCIuL2RlY3J5cHRlci13b3JrZXIud29ya2VyLmpzXCIsIGZ1bmN0aW9uICh3aW5kb3csIGRvY3VtZW50JCQxKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGRlY3J5cHRlcldvcmtlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbiAgICB2YXIgd2luO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbiA9IHdpbmRvdztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb21tb25qc0dsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luID0gY29tbW9uanNHbG9iYWw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luID0gc2VsZjtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luID0ge307XG4gICAgfVxuXG4gICAgdmFyIHdpbmRvd18xID0gd2luO1xuXG4gICAgLypcbiAgICAgKiBwa2NzNy5wYWRcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vYnJpZ2h0Y292ZS9wa2NzN1xuICAgICAqXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDE0IEJyaWdodGNvdmVcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgYXBhY2hlMiBsaWNlbnNlLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3ViYXJyYXkgb2YgYSBVaW50OEFycmF5IHdpdGhvdXQgUEtDUyM3IHBhZGRpbmcuXG4gICAgICogQHBhcmFtIHBhZGRlZCB7VWludDhBcnJheX0gdW5lbmNyeXB0ZWQgYnl0ZXMgdGhhdCBoYXZlIGJlZW4gcGFkZGVkXG4gICAgICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIHVucGFkZGVkIGJ5dGVzXG4gICAgICogQHNlZSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1NjUyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5wYWQocGFkZGVkKSB7XG4gICAgICByZXR1cm4gcGFkZGVkLnN1YmFycmF5KDAsIHBhZGRlZC5ieXRlTGVuZ3RoIC0gcGFkZGVkW3BhZGRlZC5ieXRlTGVuZ3RoIC0gMV0pO1xuICAgIH1cblxuICAgIHZhciBjbGFzc0NhbGxDaGVjayQkMSA9IGZ1bmN0aW9uIGNsYXNzQ2FsbENoZWNrJCQxKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUNsYXNzJCQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICAgICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgdmFyIGluaGVyaXRzJCQxID0gZnVuY3Rpb24gaW5oZXJpdHMkJDEoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyAodHlwZW9mIHN1cGVyQ2xhc3MgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN1cGVyQ2xhc3MpKSk7XG4gICAgICB9XG5cbiAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG4gICAgfTtcblxuICAgIHZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJCQxID0gZnVuY3Rpb24gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiQkMShzZWxmLCBjYWxsKSB7XG4gICAgICBpZiAoIXNlbGYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjYWxsKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGZpbGUgYWVzLmpzXG4gICAgICpcbiAgICAgKiBUaGlzIGZpbGUgY29udGFpbnMgYW4gYWRhcHRhdGlvbiBvZiB0aGUgQUVTIGRlY3J5cHRpb24gYWxnb3JpdGhtXG4gICAgICogZnJvbSB0aGUgU3RhbmRmb3JkIEphdmFzY3JpcHQgQ3J5cHRvZ3JhcGh5IExpYnJhcnkuIFRoYXQgd29yayBpc1xuICAgICAqIGNvdmVyZWQgYnkgdGhlIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIHBlcm1pc3Npb25zIG5vdGljZTpcbiAgICAgKlxuICAgICAqIENvcHlyaWdodCAyMDA5LTIwMTAgRW1pbHkgU3RhcmssIE1pa2UgSGFtYnVyZywgRGFuIEJvbmVoLlxuICAgICAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICAgKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gICAgICogbWV0OlxuICAgICAqXG4gICAgICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgICpcbiAgICAgKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAgICAgKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gICAgICpcbiAgICAgKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBBVVRIT1JTIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICAgICAqIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAgICAgKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gT1IgQ09OVFJJQlVUT1JTIEJFXG4gICAgICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICAgICAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gICAgICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SXG4gICAgICogQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gICAgICogV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0VcbiAgICAgKiBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOXG4gICAgICogSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gICAgICpcbiAgICAgKiBUaGUgdmlld3MgYW5kIGNvbmNsdXNpb25zIGNvbnRhaW5lZCBpbiB0aGUgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb25cbiAgICAgKiBhcmUgdGhvc2Ugb2YgdGhlIGF1dGhvcnMgYW5kIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgcmVwcmVzZW50aW5nXG4gICAgICogb2ZmaWNpYWwgcG9saWNpZXMsIGVpdGhlciBleHByZXNzZWQgb3IgaW1wbGllZCwgb2YgdGhlIGF1dGhvcnMuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmQgdGhlIFMtYm94IHRhYmxlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdmFyIHByZWNvbXB1dGUgPSBmdW5jdGlvbiBwcmVjb21wdXRlKCkge1xuICAgICAgdmFyIHRhYmxlcyA9IFtbW10sIFtdLCBbXSwgW10sIFtdXSwgW1tdLCBbXSwgW10sIFtdLCBbXV1dO1xuICAgICAgdmFyIGVuY1RhYmxlID0gdGFibGVzWzBdO1xuICAgICAgdmFyIGRlY1RhYmxlID0gdGFibGVzWzFdO1xuICAgICAgdmFyIHNib3ggPSBlbmNUYWJsZVs0XTtcbiAgICAgIHZhciBzYm94SW52ID0gZGVjVGFibGVbNF07XG4gICAgICB2YXIgaSA9IHZvaWQgMDtcbiAgICAgIHZhciB4ID0gdm9pZCAwO1xuICAgICAgdmFyIHhJbnYgPSB2b2lkIDA7XG4gICAgICB2YXIgZCA9IFtdO1xuICAgICAgdmFyIHRoID0gW107XG4gICAgICB2YXIgeDIgPSB2b2lkIDA7XG4gICAgICB2YXIgeDQgPSB2b2lkIDA7XG4gICAgICB2YXIgeDggPSB2b2lkIDA7XG4gICAgICB2YXIgcyA9IHZvaWQgMDtcbiAgICAgIHZhciB0RW5jID0gdm9pZCAwO1xuICAgICAgdmFyIHREZWMgPSB2b2lkIDA7XG5cbiAgICAgIC8vIENvbXB1dGUgZG91YmxlIGFuZCB0aGlyZCB0YWJsZXNcbiAgICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICB0aFsoZFtpXSA9IGkgPDwgMSBeIChpID4+IDcpICogMjgzKSBeIGldID0gaTtcbiAgICAgIH1cblxuICAgICAgZm9yICh4ID0geEludiA9IDA7ICFzYm94W3hdOyB4IF49IHgyIHx8IDEsIHhJbnYgPSB0aFt4SW52XSB8fCAxKSB7XG4gICAgICAgIC8vIENvbXB1dGUgc2JveFxuICAgICAgICBzID0geEludiBeIHhJbnYgPDwgMSBeIHhJbnYgPDwgMiBeIHhJbnYgPDwgMyBeIHhJbnYgPDwgNDtcbiAgICAgICAgcyA9IHMgPj4gOCBeIHMgJiAyNTUgXiA5OTtcbiAgICAgICAgc2JveFt4XSA9IHM7XG4gICAgICAgIHNib3hJbnZbc10gPSB4O1xuXG4gICAgICAgIC8vIENvbXB1dGUgTWl4Q29sdW1uc1xuICAgICAgICB4OCA9IGRbeDQgPSBkW3gyID0gZFt4XV1dO1xuICAgICAgICB0RGVjID0geDggKiAweDEwMTAxMDEgXiB4NCAqIDB4MTAwMDEgXiB4MiAqIDB4MTAxIF4geCAqIDB4MTAxMDEwMDtcbiAgICAgICAgdEVuYyA9IGRbc10gKiAweDEwMSBeIHMgKiAweDEwMTAxMDA7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgIGVuY1RhYmxlW2ldW3hdID0gdEVuYyA9IHRFbmMgPDwgMjQgXiB0RW5jID4+PiA4O1xuICAgICAgICAgIGRlY1RhYmxlW2ldW3NdID0gdERlYyA9IHREZWMgPDwgMjQgXiB0RGVjID4+PiA4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENvbXBhY3RpZnkuIENvbnNpZGVyYWJsZSBzcGVlZHVwIG9uIEZpcmVmb3guXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgIGVuY1RhYmxlW2ldID0gZW5jVGFibGVbaV0uc2xpY2UoMCk7XG4gICAgICAgIGRlY1RhYmxlW2ldID0gZGVjVGFibGVbaV0uc2xpY2UoMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGVzO1xuICAgIH07XG4gICAgdmFyIGFlc1RhYmxlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSBvdXQgYW4gQUVTIGtleSBmb3IgYm90aCBlbmNyeXB0aW9uIGFuZCBkZWNyeXB0aW9uLiBUaGlzXG4gICAgICogaXMgYSBsb3ctbGV2ZWwgY2xhc3MuIFVzZSBhIGNpcGhlciBtb2RlIHRvIGRvIGJ1bGsgZW5jcnlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBBRVNcbiAgICAgKiBAcGFyYW0ga2V5IHtBcnJheX0gVGhlIGtleSBhcyBhbiBhcnJheSBvZiA0LCA2IG9yIDggd29yZHMuXG4gICAgICovXG5cbiAgICB2YXIgQUVTID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQUVTKGtleSkge1xuICAgICAgICBjbGFzc0NhbGxDaGVjayQkMSh0aGlzLCBBRVMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXhwYW5kZWQgUy1ib3ggYW5kIGludmVyc2UgUy1ib3ggdGFibGVzLiBUaGVzZSB3aWxsIGJlIGNvbXB1dGVkXG4gICAgICAgICAqIG9uIHRoZSBjbGllbnQgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIHNlbmQgdGhlbSBkb3duIHRoZSB3aXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGVyZSBhcmUgdHdvIHRhYmxlcywgX3RhYmxlc1swXSBpcyBmb3IgZW5jcnlwdGlvbiBhbmRcbiAgICAgICAgICogX3RhYmxlc1sxXSBpcyBmb3IgZGVjcnlwdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGZpcnN0IDQgc3ViLXRhYmxlcyBhcmUgdGhlIGV4cGFuZGVkIFMtYm94IHdpdGggTWl4Q29sdW1ucy4gVGhlXG4gICAgICAgICAqIGxhc3QgKF90YWJsZXNbMDFdWzRdKSBpcyB0aGUgUy1ib3ggaXRzZWxmLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSB5ZXQgdG8gcHJlY29tcHV0ZSB0aGUgUy1ib3ggdGFibGVzXG4gICAgICAgIC8vIGRvIHNvIG5vd1xuICAgICAgICBpZiAoIWFlc1RhYmxlcykge1xuICAgICAgICAgIGFlc1RhYmxlcyA9IHByZWNvbXB1dGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGVuIG1ha2UgYSBjb3B5IG9mIHRoYXQgb2JqZWN0IGZvciB1c2VcbiAgICAgICAgdGhpcy5fdGFibGVzID0gW1thZXNUYWJsZXNbMF1bMF0uc2xpY2UoKSwgYWVzVGFibGVzWzBdWzFdLnNsaWNlKCksIGFlc1RhYmxlc1swXVsyXS5zbGljZSgpLCBhZXNUYWJsZXNbMF1bM10uc2xpY2UoKSwgYWVzVGFibGVzWzBdWzRdLnNsaWNlKCldLCBbYWVzVGFibGVzWzFdWzBdLnNsaWNlKCksIGFlc1RhYmxlc1sxXVsxXS5zbGljZSgpLCBhZXNUYWJsZXNbMV1bMl0uc2xpY2UoKSwgYWVzVGFibGVzWzFdWzNdLnNsaWNlKCksIGFlc1RhYmxlc1sxXVs0XS5zbGljZSgpXV07XG4gICAgICAgIHZhciBpID0gdm9pZCAwO1xuICAgICAgICB2YXIgaiA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHRtcCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGVuY0tleSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGRlY0tleSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHNib3ggPSB0aGlzLl90YWJsZXNbMF1bNF07XG4gICAgICAgIHZhciBkZWNUYWJsZSA9IHRoaXMuX3RhYmxlc1sxXTtcbiAgICAgICAgdmFyIGtleUxlbiA9IGtleS5sZW5ndGg7XG4gICAgICAgIHZhciByY29uID0gMTtcblxuICAgICAgICBpZiAoa2V5TGVuICE9PSA0ICYmIGtleUxlbiAhPT0gNiAmJiBrZXlMZW4gIT09IDgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWVzIGtleSBzaXplJyk7XG4gICAgICAgIH1cblxuICAgICAgICBlbmNLZXkgPSBrZXkuc2xpY2UoMCk7XG4gICAgICAgIGRlY0tleSA9IFtdO1xuICAgICAgICB0aGlzLl9rZXkgPSBbZW5jS2V5LCBkZWNLZXldO1xuXG4gICAgICAgIC8vIHNjaGVkdWxlIGVuY3J5cHRpb24ga2V5c1xuICAgICAgICBmb3IgKGkgPSBrZXlMZW47IGkgPCA0ICoga2V5TGVuICsgMjg7IGkrKykge1xuICAgICAgICAgIHRtcCA9IGVuY0tleVtpIC0gMV07XG5cbiAgICAgICAgICAvLyBhcHBseSBzYm94XG4gICAgICAgICAgaWYgKGkgJSBrZXlMZW4gPT09IDAgfHwga2V5TGVuID09PSA4ICYmIGkgJSBrZXlMZW4gPT09IDQpIHtcbiAgICAgICAgICAgIHRtcCA9IHNib3hbdG1wID4+PiAyNF0gPDwgMjQgXiBzYm94W3RtcCA+PiAxNiAmIDI1NV0gPDwgMTYgXiBzYm94W3RtcCA+PiA4ICYgMjU1XSA8PCA4IF4gc2JveFt0bXAgJiAyNTVdO1xuXG4gICAgICAgICAgICAvLyBzaGlmdCByb3dzIGFuZCBhZGQgcmNvblxuICAgICAgICAgICAgaWYgKGkgJSBrZXlMZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgdG1wID0gdG1wIDw8IDggXiB0bXAgPj4+IDI0IF4gcmNvbiA8PCAyNDtcbiAgICAgICAgICAgICAgcmNvbiA9IHJjb24gPDwgMSBeIChyY29uID4+IDcpICogMjgzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGVuY0tleVtpXSA9IGVuY0tleVtpIC0ga2V5TGVuXSBeIHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjaGVkdWxlIGRlY3J5cHRpb24ga2V5c1xuICAgICAgICBmb3IgKGogPSAwOyBpOyBqKyssIGktLSkge1xuICAgICAgICAgIHRtcCA9IGVuY0tleVtqICYgMyA/IGkgOiBpIC0gNF07XG4gICAgICAgICAgaWYgKGkgPD0gNCB8fCBqIDwgNCkge1xuICAgICAgICAgICAgZGVjS2V5W2pdID0gdG1wO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWNLZXlbal0gPSBkZWNUYWJsZVswXVtzYm94W3RtcCA+Pj4gMjRdXSBeIGRlY1RhYmxlWzFdW3Nib3hbdG1wID4+IDE2ICYgMjU1XV0gXiBkZWNUYWJsZVsyXVtzYm94W3RtcCA+PiA4ICYgMjU1XV0gXiBkZWNUYWJsZVszXVtzYm94W3RtcCAmIDI1NV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlY3J5cHQgMTYgYnl0ZXMsIHNwZWNpZmllZCBhcyBmb3VyIDMyLWJpdCB3b3Jkcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5jcnlwdGVkMCB0aGUgZmlyc3Qgd29yZCB0byBkZWNyeXB0XG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5jcnlwdGVkMSB0aGUgc2Vjb25kIHdvcmQgdG8gZGVjcnlwdFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuY3J5cHRlZDIgdGhlIHRoaXJkIHdvcmQgdG8gZGVjcnlwdFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuY3J5cHRlZDMgdGhlIGZvdXJ0aCB3b3JkIHRvIGRlY3J5cHRcbiAgICAgICAqIEBwYXJhbSB7SW50MzJBcnJheX0gb3V0IHRoZSBhcnJheSB0byB3cml0ZSB0aGUgZGVjcnlwdGVkIHdvcmRzXG4gICAgICAgKiBpbnRvXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IHRoZSBvZmZzZXQgaW50byB0aGUgb3V0cHV0IGFycmF5IHRvIHN0YXJ0XG4gICAgICAgKiB3cml0aW5nIHJlc3VsdHNcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgcGxhaW50ZXh0LlxuICAgICAgICovXG5cbiAgICAgIEFFUy5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uIGRlY3J5cHQkJDEoZW5jcnlwdGVkMCwgZW5jcnlwdGVkMSwgZW5jcnlwdGVkMiwgZW5jcnlwdGVkMywgb3V0LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleVsxXTtcbiAgICAgICAgLy8gc3RhdGUgdmFyaWFibGVzIGEsYixjLGQgYXJlIGxvYWRlZCB3aXRoIHByZS13aGl0ZW5lZCBkYXRhXG4gICAgICAgIHZhciBhID0gZW5jcnlwdGVkMCBeIGtleVswXTtcbiAgICAgICAgdmFyIGIgPSBlbmNyeXB0ZWQzIF4ga2V5WzFdO1xuICAgICAgICB2YXIgYyA9IGVuY3J5cHRlZDIgXiBrZXlbMl07XG4gICAgICAgIHZhciBkID0gZW5jcnlwdGVkMSBeIGtleVszXTtcbiAgICAgICAgdmFyIGEyID0gdm9pZCAwO1xuICAgICAgICB2YXIgYjIgPSB2b2lkIDA7XG4gICAgICAgIHZhciBjMiA9IHZvaWQgMDtcblxuICAgICAgICAvLyBrZXkubGVuZ3RoID09PSAyID9cbiAgICAgICAgdmFyIG5Jbm5lclJvdW5kcyA9IGtleS5sZW5ndGggLyA0IC0gMjtcbiAgICAgICAgdmFyIGkgPSB2b2lkIDA7XG4gICAgICAgIHZhciBrSW5kZXggPSA0O1xuICAgICAgICB2YXIgdGFibGUgPSB0aGlzLl90YWJsZXNbMV07XG5cbiAgICAgICAgLy8gbG9hZCB1cCB0aGUgdGFibGVzXG4gICAgICAgIHZhciB0YWJsZTAgPSB0YWJsZVswXTtcbiAgICAgICAgdmFyIHRhYmxlMSA9IHRhYmxlWzFdO1xuICAgICAgICB2YXIgdGFibGUyID0gdGFibGVbMl07XG4gICAgICAgIHZhciB0YWJsZTMgPSB0YWJsZVszXTtcbiAgICAgICAgdmFyIHNib3ggPSB0YWJsZVs0XTtcblxuICAgICAgICAvLyBJbm5lciByb3VuZHMuIENyaWJiZWQgZnJvbSBPcGVuU1NMLlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbklubmVyUm91bmRzOyBpKyspIHtcbiAgICAgICAgICBhMiA9IHRhYmxlMFthID4+PiAyNF0gXiB0YWJsZTFbYiA+PiAxNiAmIDI1NV0gXiB0YWJsZTJbYyA+PiA4ICYgMjU1XSBeIHRhYmxlM1tkICYgMjU1XSBeIGtleVtrSW5kZXhdO1xuICAgICAgICAgIGIyID0gdGFibGUwW2IgPj4+IDI0XSBeIHRhYmxlMVtjID4+IDE2ICYgMjU1XSBeIHRhYmxlMltkID4+IDggJiAyNTVdIF4gdGFibGUzW2EgJiAyNTVdIF4ga2V5W2tJbmRleCArIDFdO1xuICAgICAgICAgIGMyID0gdGFibGUwW2MgPj4+IDI0XSBeIHRhYmxlMVtkID4+IDE2ICYgMjU1XSBeIHRhYmxlMlthID4+IDggJiAyNTVdIF4gdGFibGUzW2IgJiAyNTVdIF4ga2V5W2tJbmRleCArIDJdO1xuICAgICAgICAgIGQgPSB0YWJsZTBbZCA+Pj4gMjRdIF4gdGFibGUxW2EgPj4gMTYgJiAyNTVdIF4gdGFibGUyW2IgPj4gOCAmIDI1NV0gXiB0YWJsZTNbYyAmIDI1NV0gXiBrZXlba0luZGV4ICsgM107XG4gICAgICAgICAga0luZGV4ICs9IDQ7XG4gICAgICAgICAgYSA9IGEyO2IgPSBiMjtjID0gYzI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMYXN0IHJvdW5kLlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgb3V0WygzICYgLWkpICsgb2Zmc2V0XSA9IHNib3hbYSA+Pj4gMjRdIDw8IDI0IF4gc2JveFtiID4+IDE2ICYgMjU1XSA8PCAxNiBeIHNib3hbYyA+PiA4ICYgMjU1XSA8PCA4IF4gc2JveFtkICYgMjU1XSBeIGtleVtrSW5kZXgrK107XG4gICAgICAgICAgYTIgPSBhO2EgPSBiO2IgPSBjO2MgPSBkO2QgPSBhMjtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIEFFUztcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAZmlsZSBzdHJlYW0uanNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBIGxpZ2h0d2VpZ2h0IHJlYWRhYmxlIHN0cmVhbSBpbXBsZW1lbnRpb24gdGhhdCBoYW5kbGVzIGV2ZW50IGRpc3BhdGNoaW5nLlxuICAgICAqXG4gICAgICogQGNsYXNzIFN0cmVhbVxuICAgICAqL1xuICAgIHZhciBTdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHJlYW0oKSB7XG4gICAgICAgIGNsYXNzQ2FsbENoZWNrJCQxKHRoaXMsIFN0cmVhbSk7XG5cbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBzcGVjaWZpZWQgZXZlbnQgdHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgZXZlbnQgbmFtZVxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBhbiBldmVudCBvZlxuICAgICAgICogdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vyc1xuICAgICAgICovXG5cbiAgICAgIFN0cmVhbS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIGEgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIGV2ZW50IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyICBhIGZ1bmN0aW9uIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBmb3IgdGhpc1xuICAgICAgICogdHlwZSBvZiBldmVudCB0aHJvdWdoIGBvbmBcbiAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGlmIHdlIGNvdWxkIHR1cm4gaXQgb2ZmIG9yIG5vdFxuICAgICAgICovXG5cbiAgICAgIFN0cmVhbS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGxpc3RlbmVyKTtcblxuICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlciBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb24gdGhpcyBzdHJlYW0uIEFueSBhZGRpdGlvbmFsXG4gICAgICAgKiBhcmd1bWVudHMgdG8gdGhpcyBmdW5jdGlvbiBhcmUgcGFzc2VkIGFzIHBhcmFtZXRlcnMgdG8gZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBldmVudCBuYW1lXG4gICAgICAgKi9cblxuICAgICAgU3RyZWFtLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlcih0eXBlKSB7XG4gICAgICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLmxpc3RlbmVyc1t0eXBlXTtcblxuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsaWNpbmcgdGhlIGFyZ3VtZW50cyBvbiBldmVyeSBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kXG4gICAgICAgIC8vIGNhbiBhZGQgYSBzaWduaWZpY2FudCBhbW91bnQgb2Ygb3ZlcmhlYWQuIEF2b2lkIHRoZVxuICAgICAgICAvLyBpbnRlcm1lZGlhdGUgb2JqZWN0IGNyZWF0aW9uIGZvciB0aGUgY29tbW9uIGNhc2Ugb2YgYVxuICAgICAgICAvLyBzaW5nbGUgY2FsbGJhY2sgYXJndW1lbnRcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gY2FsbGJhY2tzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICB2YXIgX2xlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2xlbmd0aDsgKytfaSkge1xuICAgICAgICAgICAgY2FsbGJhY2tzW19pXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzdHJveXMgdGhlIHN0cmVhbSBhbmQgY2xlYW5zIHVwLlxuICAgICAgICovXG5cbiAgICAgIFN0cmVhbS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBGb3J3YXJkcyBhbGwgYGRhdGFgIGV2ZW50cyBvbiB0aGlzIHN0cmVhbSB0byB0aGUgZGVzdGluYXRpb24gc3RyZWFtLiBUaGVcbiAgICAgICAqIGRlc3RpbmF0aW9uIHN0cmVhbSBzaG91bGQgcHJvdmlkZSBhIG1ldGhvZCBgcHVzaGAgdG8gcmVjZWl2ZSB0aGUgZGF0YVxuICAgICAgICogZXZlbnRzIGFzIHRoZXkgYXJyaXZlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyZWFtfSBkZXN0aW5hdGlvbiB0aGUgc3RyZWFtIHRoYXQgd2lsbCByZWNlaXZlIGFsbCBgZGF0YWAgZXZlbnRzXG4gICAgICAgKiBAc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fcmVhZGFibGVfcGlwZV9kZXN0aW5hdGlvbl9vcHRpb25zXG4gICAgICAgKi9cblxuICAgICAgU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gcGlwZShkZXN0aW5hdGlvbikge1xuICAgICAgICB0aGlzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBTdHJlYW07XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQGZpbGUgYXN5bmMtc3RyZWFtLmpzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgU3RyZWFtIGNsYXNzIHRvIHVzZSBzZXRUaWVtb3V0XG4gICAgICogYW5kIHJ1biBzdHJlYW0gXCJqb2JzXCIgQXN5bmNocm9ub3VzbHlcbiAgICAgKlxuICAgICAqIEBjbGFzcyBBc3luY1N0cmVhbVxuICAgICAqIEBleHRlbmRzIFN0cmVhbVxuICAgICAqL1xuXG4gICAgdmFyIEFzeW5jU3RyZWFtJCQxID0gZnVuY3Rpb24gKF9TdHJlYW0pIHtcbiAgICAgIGluaGVyaXRzJCQxKEFzeW5jU3RyZWFtJCQxLCBfU3RyZWFtKTtcblxuICAgICAgZnVuY3Rpb24gQXN5bmNTdHJlYW0kJDEoKSB7XG4gICAgICAgIGNsYXNzQ2FsbENoZWNrJCQxKHRoaXMsIEFzeW5jU3RyZWFtJCQxKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJCQxKHRoaXMsIF9TdHJlYW0uY2FsbCh0aGlzLCBTdHJlYW0pKTtcblxuICAgICAgICBfdGhpcy5qb2JzID0gW107XG4gICAgICAgIF90aGlzLmRlbGF5ID0gMTtcbiAgICAgICAgX3RoaXMudGltZW91dF8gPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcHJvY2VzcyBhbiBhc3luYyBqb2JcbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIEFzeW5jU3RyZWFtJCQxLnByb3RvdHlwZS5wcm9jZXNzSm9iXyA9IGZ1bmN0aW9uIHByb2Nlc3NKb2JfKCkge1xuICAgICAgICB0aGlzLmpvYnMuc2hpZnQoKSgpO1xuICAgICAgICBpZiAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMudGltZW91dF8gPSBzZXRUaW1lb3V0KHRoaXMucHJvY2Vzc0pvYl8uYmluZCh0aGlzKSwgdGhpcy5kZWxheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50aW1lb3V0XyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogcHVzaCBhIGpvYiBpbnRvIHRoZSBzdHJlYW1cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2IgdGhlIGpvYiB0byBwdXNoIGludG8gdGhlIHN0cmVhbVxuICAgICAgICovXG5cbiAgICAgIEFzeW5jU3RyZWFtJCQxLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaChqb2IpIHtcbiAgICAgICAgdGhpcy5qb2JzLnB1c2goam9iKTtcbiAgICAgICAgaWYgKCF0aGlzLnRpbWVvdXRfKSB7XG4gICAgICAgICAgdGhpcy50aW1lb3V0XyA9IHNldFRpbWVvdXQodGhpcy5wcm9jZXNzSm9iXy5iaW5kKHRoaXMpLCB0aGlzLmRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIEFzeW5jU3RyZWFtJCQxO1xuICAgIH0oU3RyZWFtKTtcblxuICAgIC8qKlxuICAgICAqIEBmaWxlIGRlY3J5cHRlci5qc1xuICAgICAqXG4gICAgICogQW4gYXN5bmNocm9ub3VzIGltcGxlbWVudGF0aW9uIG9mIEFFUy0xMjggQ0JDIGRlY3J5cHRpb24gd2l0aFxuICAgICAqIFBLQ1MjNyBwYWRkaW5nLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBuZXR3b3JrLW9yZGVyIChiaWctZW5kaWFuKSBieXRlcyBpbnRvIHRoZWlyIGxpdHRsZS1lbmRpYW5cbiAgICAgKiByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgbnRvaCA9IGZ1bmN0aW9uIG50b2god29yZCkge1xuICAgICAgcmV0dXJuIHdvcmQgPDwgMjQgfCAod29yZCAmIDB4ZmYwMCkgPDwgOCB8ICh3b3JkICYgMHhmZjAwMDApID4+IDggfCB3b3JkID4+PiAyNDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVjcnlwdCBieXRlcyB1c2luZyBBRVMtMTI4IHdpdGggQ0JDIGFuZCBQS0NTIzcgcGFkZGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gZW5jcnlwdGVkIHRoZSBlbmNyeXB0ZWQgYnl0ZXNcbiAgICAgKiBAcGFyYW0ge1VpbnQzMkFycmF5fSBrZXkgdGhlIGJ5dGVzIG9mIHRoZSBkZWNyeXB0aW9uIGtleVxuICAgICAqIEBwYXJhbSB7VWludDMyQXJyYXl9IGluaXRWZWN0b3IgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciAoSVYpIHRvXG4gICAgICogdXNlIGZvciB0aGUgZmlyc3Qgcm91bmQgb2YgQ0JDLlxuICAgICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSBkZWNyeXB0ZWQgYnl0ZXNcbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BZHZhbmNlZF9FbmNyeXB0aW9uX1N0YW5kYXJkXG4gICAgICogQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jsb2NrX2NpcGhlcl9tb2RlX29mX29wZXJhdGlvbiNDaXBoZXJfQmxvY2tfQ2hhaW5pbmdfLjI4Q0JDLjI5XG4gICAgICogQHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjMxNVxuICAgICAqL1xuICAgIHZhciBkZWNyeXB0JCQxID0gZnVuY3Rpb24gZGVjcnlwdCQkMShlbmNyeXB0ZWQsIGtleSwgaW5pdFZlY3Rvcikge1xuICAgICAgLy8gd29yZC1sZXZlbCBhY2Nlc3MgdG8gdGhlIGVuY3J5cHRlZCBieXRlc1xuICAgICAgdmFyIGVuY3J5cHRlZDMyID0gbmV3IEludDMyQXJyYXkoZW5jcnlwdGVkLmJ1ZmZlciwgZW5jcnlwdGVkLmJ5dGVPZmZzZXQsIGVuY3J5cHRlZC5ieXRlTGVuZ3RoID4+IDIpO1xuXG4gICAgICB2YXIgZGVjaXBoZXIgPSBuZXcgQUVTKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGtleSkpO1xuXG4gICAgICAvLyBieXRlIGFuZCB3b3JkLWxldmVsIGFjY2VzcyBmb3IgdGhlIGRlY3J5cHRlZCBvdXRwdXRcbiAgICAgIHZhciBkZWNyeXB0ZWQgPSBuZXcgVWludDhBcnJheShlbmNyeXB0ZWQuYnl0ZUxlbmd0aCk7XG4gICAgICB2YXIgZGVjcnlwdGVkMzIgPSBuZXcgSW50MzJBcnJheShkZWNyeXB0ZWQuYnVmZmVyKTtcblxuICAgICAgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlcyBmb3Igd29ya2luZyB3aXRoIHRoZSBJViwgZW5jcnlwdGVkLCBhbmRcbiAgICAgIC8vIGRlY3J5cHRlZCBkYXRhXG4gICAgICB2YXIgaW5pdDAgPSB2b2lkIDA7XG4gICAgICB2YXIgaW5pdDEgPSB2b2lkIDA7XG4gICAgICB2YXIgaW5pdDIgPSB2b2lkIDA7XG4gICAgICB2YXIgaW5pdDMgPSB2b2lkIDA7XG4gICAgICB2YXIgZW5jcnlwdGVkMCA9IHZvaWQgMDtcbiAgICAgIHZhciBlbmNyeXB0ZWQxID0gdm9pZCAwO1xuICAgICAgdmFyIGVuY3J5cHRlZDIgPSB2b2lkIDA7XG4gICAgICB2YXIgZW5jcnlwdGVkMyA9IHZvaWQgMDtcblxuICAgICAgLy8gaXRlcmF0aW9uIHZhcmlhYmxlXG4gICAgICB2YXIgd29yZEl4ID0gdm9pZCAwO1xuXG4gICAgICAvLyBwdWxsIG91dCB0aGUgd29yZHMgb2YgdGhlIElWIHRvIGVuc3VyZSB3ZSBkb24ndCBtb2RpZnkgdGhlXG4gICAgICAvLyBwYXNzZWQtaW4gcmVmZXJlbmNlIGFuZCBlYXNpZXIgYWNjZXNzXG4gICAgICBpbml0MCA9IGluaXRWZWN0b3JbMF07XG4gICAgICBpbml0MSA9IGluaXRWZWN0b3JbMV07XG4gICAgICBpbml0MiA9IGluaXRWZWN0b3JbMl07XG4gICAgICBpbml0MyA9IGluaXRWZWN0b3JbM107XG5cbiAgICAgIC8vIGRlY3J5cHQgZm91ciB3b3JkIHNlcXVlbmNlcywgYXBwbHlpbmcgY2lwaGVyLWJsb2NrIGNoYWluaW5nIChDQkMpXG4gICAgICAvLyB0byBlYWNoIGRlY3J5cHRlZCBibG9ja1xuICAgICAgZm9yICh3b3JkSXggPSAwOyB3b3JkSXggPCBlbmNyeXB0ZWQzMi5sZW5ndGg7IHdvcmRJeCArPSA0KSB7XG4gICAgICAgIC8vIGNvbnZlcnQgYmlnLWVuZGlhbiAobmV0d29yayBvcmRlcikgd29yZHMgaW50byBsaXR0bGUtZW5kaWFuXG4gICAgICAgIC8vIChqYXZhc2NyaXB0IG9yZGVyKVxuICAgICAgICBlbmNyeXB0ZWQwID0gbnRvaChlbmNyeXB0ZWQzMlt3b3JkSXhdKTtcbiAgICAgICAgZW5jcnlwdGVkMSA9IG50b2goZW5jcnlwdGVkMzJbd29yZEl4ICsgMV0pO1xuICAgICAgICBlbmNyeXB0ZWQyID0gbnRvaChlbmNyeXB0ZWQzMlt3b3JkSXggKyAyXSk7XG4gICAgICAgIGVuY3J5cHRlZDMgPSBudG9oKGVuY3J5cHRlZDMyW3dvcmRJeCArIDNdKTtcblxuICAgICAgICAvLyBkZWNyeXB0IHRoZSBibG9ja1xuICAgICAgICBkZWNpcGhlci5kZWNyeXB0KGVuY3J5cHRlZDAsIGVuY3J5cHRlZDEsIGVuY3J5cHRlZDIsIGVuY3J5cHRlZDMsIGRlY3J5cHRlZDMyLCB3b3JkSXgpO1xuXG4gICAgICAgIC8vIFhPUiB3aXRoIHRoZSBJViwgYW5kIHJlc3RvcmUgbmV0d29yayBieXRlLW9yZGVyIHRvIG9idGFpbiB0aGVcbiAgICAgICAgLy8gcGxhaW50ZXh0XG4gICAgICAgIGRlY3J5cHRlZDMyW3dvcmRJeF0gPSBudG9oKGRlY3J5cHRlZDMyW3dvcmRJeF0gXiBpbml0MCk7XG4gICAgICAgIGRlY3J5cHRlZDMyW3dvcmRJeCArIDFdID0gbnRvaChkZWNyeXB0ZWQzMlt3b3JkSXggKyAxXSBeIGluaXQxKTtcbiAgICAgICAgZGVjcnlwdGVkMzJbd29yZEl4ICsgMl0gPSBudG9oKGRlY3J5cHRlZDMyW3dvcmRJeCArIDJdIF4gaW5pdDIpO1xuICAgICAgICBkZWNyeXB0ZWQzMlt3b3JkSXggKyAzXSA9IG50b2goZGVjcnlwdGVkMzJbd29yZEl4ICsgM10gXiBpbml0Myk7XG5cbiAgICAgICAgLy8gc2V0dXAgdGhlIElWIGZvciB0aGUgbmV4dCByb3VuZFxuICAgICAgICBpbml0MCA9IGVuY3J5cHRlZDA7XG4gICAgICAgIGluaXQxID0gZW5jcnlwdGVkMTtcbiAgICAgICAgaW5pdDIgPSBlbmNyeXB0ZWQyO1xuICAgICAgICBpbml0MyA9IGVuY3J5cHRlZDM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWNyeXB0ZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBgRGVjcnlwdGVyYCBjbGFzcyB0aGF0IG1hbmFnZXMgZGVjcnlwdGlvbiBvZiBBRVNcbiAgICAgKiBkYXRhIHRocm91Z2ggYEFzeW5jU3RyZWFtYCBvYmplY3RzIGFuZCB0aGUgYGRlY3J5cHRgXG4gICAgICogZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gZW5jcnlwdGVkIHRoZSBlbmNyeXB0ZWQgYnl0ZXNcbiAgICAgKiBAcGFyYW0ge1VpbnQzMkFycmF5fSBrZXkgdGhlIGJ5dGVzIG9mIHRoZSBkZWNyeXB0aW9uIGtleVxuICAgICAqIEBwYXJhbSB7VWludDMyQXJyYXl9IGluaXRWZWN0b3IgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciAoSVYpIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSB0aGUgZnVuY3Rpb24gdG8gcnVuIHdoZW4gZG9uZVxuICAgICAqIEBjbGFzcyBEZWNyeXB0ZXJcbiAgICAgKi9cblxuICAgIHZhciBEZWNyeXB0ZXIkJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBEZWNyeXB0ZXIkJDEoZW5jcnlwdGVkLCBrZXksIGluaXRWZWN0b3IsIGRvbmUpIHtcbiAgICAgICAgY2xhc3NDYWxsQ2hlY2skJDEodGhpcywgRGVjcnlwdGVyJCQxKTtcblxuICAgICAgICB2YXIgc3RlcCA9IERlY3J5cHRlciQkMS5TVEVQO1xuICAgICAgICB2YXIgZW5jcnlwdGVkMzIgPSBuZXcgSW50MzJBcnJheShlbmNyeXB0ZWQuYnVmZmVyKTtcbiAgICAgICAgdmFyIGRlY3J5cHRlZCA9IG5ldyBVaW50OEFycmF5KGVuY3J5cHRlZC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIHRoaXMuYXN5bmNTdHJlYW1fID0gbmV3IEFzeW5jU3RyZWFtJCQxKCk7XG5cbiAgICAgICAgLy8gc3BsaXQgdXAgdGhlIGVuY3J5cHRpb24gam9iIGFuZCBkbyB0aGUgaW5kaXZpZHVhbCBjaHVua3MgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgdGhpcy5hc3luY1N0cmVhbV8ucHVzaCh0aGlzLmRlY3J5cHRDaHVua18oZW5jcnlwdGVkMzIuc3ViYXJyYXkoaSwgaSArIHN0ZXApLCBrZXksIGluaXRWZWN0b3IsIGRlY3J5cHRlZCkpO1xuICAgICAgICBmb3IgKGkgPSBzdGVwOyBpIDwgZW5jcnlwdGVkMzIubGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICBpbml0VmVjdG9yID0gbmV3IFVpbnQzMkFycmF5KFtudG9oKGVuY3J5cHRlZDMyW2kgLSA0XSksIG50b2goZW5jcnlwdGVkMzJbaSAtIDNdKSwgbnRvaChlbmNyeXB0ZWQzMltpIC0gMl0pLCBudG9oKGVuY3J5cHRlZDMyW2kgLSAxXSldKTtcbiAgICAgICAgICB0aGlzLmFzeW5jU3RyZWFtXy5wdXNoKHRoaXMuZGVjcnlwdENodW5rXyhlbmNyeXB0ZWQzMi5zdWJhcnJheShpLCBpICsgc3RlcCksIGtleSwgaW5pdFZlY3RvciwgZGVjcnlwdGVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW52b2tlIHRoZSBkb25lKCkgY2FsbGJhY2sgd2hlbiBldmVyeXRoaW5nIGlzIGZpbmlzaGVkXG4gICAgICAgIHRoaXMuYXN5bmNTdHJlYW1fLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIHJlbW92ZSBwa2NzIzcgcGFkZGluZyBmcm9tIHRoZSBkZWNyeXB0ZWQgYnl0ZXNcbiAgICAgICAgICBkb25lKG51bGwsIHVucGFkKGRlY3J5cHRlZCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBhIGdldHRlciBmb3Igc3RlcCB0aGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdG8gcHJvY2VzcyBhdCBvbmUgdGltZVxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge051bWJlcn0gdGhlIHZhbHVlIG9mIHN0ZXAgMzIwMDBcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIERlY3J5cHRlciQkMS5wcm90b3R5cGUuZGVjcnlwdENodW5rXyA9IGZ1bmN0aW9uIGRlY3J5cHRDaHVua18oZW5jcnlwdGVkLCBrZXksIGluaXRWZWN0b3IsIGRlY3J5cHRlZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBieXRlcyA9IGRlY3J5cHQkJDEoZW5jcnlwdGVkLCBrZXksIGluaXRWZWN0b3IpO1xuXG4gICAgICAgICAgZGVjcnlwdGVkLnNldChieXRlcywgZW5jcnlwdGVkLmJ5dGVPZmZzZXQpO1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgY3JlYXRlQ2xhc3MkJDEoRGVjcnlwdGVyJCQxLCBudWxsLCBbe1xuICAgICAgICBrZXk6ICdTVEVQJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgLy8gNCAqIDgwMDA7XG4gICAgICAgICAgcmV0dXJuIDMyMDAwO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICByZXR1cm4gRGVjcnlwdGVyJCQxO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEBmaWxlIGJpbi11dGlscy5qc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgZm9yIHNlbmRpbmcgdG8gYSB3ZWIgd29ya2VyIG1vZGlmeWluZyBwcm9wZXJ0aWVzIHRoYXQgYXJlIFR5cGVkQXJyYXlzXG4gICAgICogaW50byBhIG5ldyBvYmplY3Qgd2l0aCBzZXBlcmF0ZWQgcHJvcGVydGllcyBmb3IgdGhlIGJ1ZmZlciwgYnl0ZU9mZnNldCwgYW5kIGJ5dGVMZW5ndGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZVxuICAgICAqICAgICAgICBPYmplY3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHRvIHNlbmQgdG8gdGhlIHdlYiB3b3JrZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICogICAgICAgICBNb2RpZmllZCBtZXNzYWdlIHdpdGggVHlwZWRBcnJheSB2YWx1ZXMgZXhwYW5kZWRcbiAgICAgKiBAZnVuY3Rpb24gY3JlYXRlVHJhbnNmZXJhYmxlTWVzc2FnZVxuICAgICAqL1xuICAgIHZhciBjcmVhdGVUcmFuc2ZlcmFibGVNZXNzYWdlID0gZnVuY3Rpb24gY3JlYXRlVHJhbnNmZXJhYmxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICB2YXIgdHJhbnNmZXJhYmxlID0ge307XG5cbiAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBtZXNzYWdlW2tleV07XG5cbiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgICAgICB0cmFuc2ZlcmFibGVba2V5XSA9IHtcbiAgICAgICAgICAgIGJ5dGVzOiB2YWx1ZS5idWZmZXIsXG4gICAgICAgICAgICBieXRlT2Zmc2V0OiB2YWx1ZS5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgYnl0ZUxlbmd0aDogdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhbnNmZXJhYmxlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0cmFuc2ZlcmFibGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE91ciB3ZWIgd29ya2VyIGludGVyZmFjZSBzbyB0aGF0IHRoaW5ncyBjYW4gdGFsayB0byBhZXMtZGVjcnlwdGVyXG4gICAgICogdGhhdCB3aWxsIGJlIHJ1bm5pbmcgaW4gYSB3ZWIgd29ya2VyLiB0aGUgc2NvcGUgaXMgcGFzc2VkIHRvIHRoaXMgYnlcbiAgICAgKiB3ZWJ3b3JraWZ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlbGZcbiAgICAgKiAgICAgICAgdGhlIHNjb3BlIGZvciB0aGUgd2ViIHdvcmtlclxuICAgICAqL1xuICAgIHZhciBEZWNyeXB0ZXJXb3JrZXIgPSBmdW5jdGlvbiBEZWNyeXB0ZXJXb3JrZXIoc2VsZikge1xuICAgICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICB2YXIgZW5jcnlwdGVkID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5lbmNyeXB0ZWQuYnl0ZXMsIGRhdGEuZW5jcnlwdGVkLmJ5dGVPZmZzZXQsIGRhdGEuZW5jcnlwdGVkLmJ5dGVMZW5ndGgpO1xuICAgICAgICB2YXIga2V5ID0gbmV3IFVpbnQzMkFycmF5KGRhdGEua2V5LmJ5dGVzLCBkYXRhLmtleS5ieXRlT2Zmc2V0LCBkYXRhLmtleS5ieXRlTGVuZ3RoIC8gNCk7XG4gICAgICAgIHZhciBpdiA9IG5ldyBVaW50MzJBcnJheShkYXRhLml2LmJ5dGVzLCBkYXRhLml2LmJ5dGVPZmZzZXQsIGRhdGEuaXYuYnl0ZUxlbmd0aCAvIDQpO1xuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldywgaGFuZGxlLWNhbGxiYWNrLWVyciAqL1xuICAgICAgICBuZXcgRGVjcnlwdGVyJCQxKGVuY3J5cHRlZCwga2V5LCBpdiwgZnVuY3Rpb24gKGVyciwgYnl0ZXMpIHtcbiAgICAgICAgICB3aW5kb3dfMS5wb3N0TWVzc2FnZShjcmVhdGVUcmFuc2ZlcmFibGVNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZTogZGF0YS5zb3VyY2UsXG4gICAgICAgICAgICBkZWNyeXB0ZWQ6IGJ5dGVzXG4gICAgICAgICAgfSksIFtieXRlcy5idWZmZXJdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBkZWNyeXB0ZXJXb3JrZXIgPSBuZXcgRGVjcnlwdGVyV29ya2VyKHNlbGYpO1xuXG4gICAgcmV0dXJuIGRlY3J5cHRlcldvcmtlcjtcbiAgfSgpO1xufSk7XG5cbi8qKlxuICogQ29udmVydCB0aGUgcHJvcGVydGllcyBvZiBhbiBITFMgdHJhY2sgaW50byBhbiBhdWRpb1RyYWNrS2luZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYXVkaW9UcmFja0tpbmRfID0gZnVuY3Rpb24gYXVkaW9UcmFja0tpbmRfKHByb3BlcnRpZXMpIHtcbiAgdmFyIGtpbmQgPSBwcm9wZXJ0aWVzLmRlZmF1bHQgPyAnbWFpbicgOiAnYWx0ZXJuYXRpdmUnO1xuXG4gIGlmIChwcm9wZXJ0aWVzLmNoYXJhY3RlcmlzdGljcyAmJiBwcm9wZXJ0aWVzLmNoYXJhY3RlcmlzdGljcy5pbmRleE9mKCdwdWJsaWMuYWNjZXNzaWJpbGl0eS5kZXNjcmliZXMtdmlkZW8nKSA+PSAwKSB7XG4gICAga2luZCA9ICdtYWluLWRlc2MnO1xuICB9XG5cbiAgcmV0dXJuIGtpbmQ7XG59O1xuXG4vKipcbiAqIFBhdXNlIHByb3ZpZGVkIHNlZ21lbnQgbG9hZGVyIGFuZCBwbGF5bGlzdCBsb2FkZXIgaWYgYWN0aXZlXG4gKlxuICogQHBhcmFtIHtTZWdtZW50TG9hZGVyfSBzZWdtZW50TG9hZGVyXG4gKiAgICAgICAgU2VnbWVudExvYWRlciB0byBwYXVzZVxuICogQHBhcmFtIHtPYmplY3R9IG1lZGlhVHlwZVxuICogICAgICAgIEFjdGl2ZSBtZWRpYSB0eXBlXG4gKiBAZnVuY3Rpb24gc3RvcExvYWRlcnNcbiAqL1xudmFyIHN0b3BMb2FkZXJzID0gZnVuY3Rpb24gc3RvcExvYWRlcnMoc2VnbWVudExvYWRlciwgbWVkaWFUeXBlKSB7XG4gIHNlZ21lbnRMb2FkZXIuYWJvcnQoKTtcbiAgc2VnbWVudExvYWRlci5wYXVzZSgpO1xuXG4gIGlmIChtZWRpYVR5cGUgJiYgbWVkaWFUeXBlLmFjdGl2ZVBsYXlsaXN0TG9hZGVyKSB7XG4gICAgbWVkaWFUeXBlLmFjdGl2ZVBsYXlsaXN0TG9hZGVyLnBhdXNlKCk7XG4gICAgbWVkaWFUeXBlLmFjdGl2ZVBsYXlsaXN0TG9hZGVyID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydCBsb2FkaW5nIHByb3ZpZGVkIHNlZ21lbnQgbG9hZGVyIGFuZCBwbGF5bGlzdCBsb2FkZXJcbiAqXG4gKiBAcGFyYW0ge1BsYXlsaXN0TG9hZGVyfSBwbGF5bGlzdExvYWRlclxuICogICAgICAgIFBsYXlsaXN0TG9hZGVyIHRvIHN0YXJ0IGxvYWRpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZWRpYVR5cGVcbiAqICAgICAgICBBY3RpdmUgbWVkaWEgdHlwZVxuICogQGZ1bmN0aW9uIHN0YXJ0TG9hZGVyc1xuICovXG52YXIgc3RhcnRMb2FkZXJzID0gZnVuY3Rpb24gc3RhcnRMb2FkZXJzKHBsYXlsaXN0TG9hZGVyLCBtZWRpYVR5cGUpIHtcbiAgLy8gU2VnbWVudCBsb2FkZXIgd2lsbCBiZSBzdGFydGVkIGFmdGVyIGBsb2FkZWRtZXRhZGF0YWAgb3IgYGxvYWRlZHBsYXlsaXN0YCBmcm9tIHRoZVxuICAvLyBwbGF5bGlzdCBsb2FkZXJcbiAgbWVkaWFUeXBlLmFjdGl2ZVBsYXlsaXN0TG9hZGVyID0gcGxheWxpc3RMb2FkZXI7XG4gIHBsYXlsaXN0TG9hZGVyLmxvYWQoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBtZWRpYSBncm91cCBjaGFuZ2VzLiBJdCBwZXJmb3JtcyBhXG4gKiBub24tZGVzdHJ1Y3RpdmUgKHByZXNlcnZlIHRoZSBidWZmZXIpIHJlc3luYyBvZiB0aGUgU2VnbWVudExvYWRlci4gVGhpcyBpcyBiZWNhdXNlIGFcbiAqIGNoYW5nZSBvZiBncm91cCBpcyBtZXJlbHkgYSByZW5kaXRpb24gc3dpdGNoIG9mIHRoZSBzYW1lIGNvbnRlbnQgYXQgYW5vdGhlciBlbmNvZGluZyxcbiAqIHJhdGhlciB0aGFuIGEgY2hhbmdlIG9mIGNvbnRlbnQsIHN1Y2ggYXMgc3dpdGNoaW5nIGF1ZGlvIGZyb20gRW5nbGlzaCB0byBTcGFuaXNoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiAgICAgICAgTWVkaWFHcm91cCB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3NcbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyByZXF1aXJlZCBpbmZvcm1hdGlvbiBmb3IgbWVkaWEgZ3JvdXBzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqICAgICAgICAgSGFuZGxlciBmb3IgYSBub24tZGVzdHJ1Y3RpdmUgcmVzeW5jIG9mIFNlZ21lbnRMb2FkZXIgd2hlbiB0aGUgYWN0aXZlIG1lZGlhXG4gKiAgICAgICAgIGdyb3VwIGNoYW5nZXMuXG4gKiBAZnVuY3Rpb24gb25Hcm91cENoYW5nZWRcbiAqL1xudmFyIG9uR3JvdXBDaGFuZ2VkID0gZnVuY3Rpb24gb25Hcm91cENoYW5nZWQodHlwZSwgc2V0dGluZ3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3NldHRpbmdzJHNlZ21lbnRMb2FkID0gc2V0dGluZ3Muc2VnbWVudExvYWRlcnMsXG4gICAgICAgIHNlZ21lbnRMb2FkZXIgPSBfc2V0dGluZ3Mkc2VnbWVudExvYWRbdHlwZV0sXG4gICAgICAgIG1haW5TZWdtZW50TG9hZGVyID0gX3NldHRpbmdzJHNlZ21lbnRMb2FkLm1haW4sXG4gICAgICAgIG1lZGlhVHlwZSA9IHNldHRpbmdzLm1lZGlhVHlwZXNbdHlwZV07XG5cbiAgICB2YXIgYWN0aXZlVHJhY2sgPSBtZWRpYVR5cGUuYWN0aXZlVHJhY2soKTtcbiAgICB2YXIgYWN0aXZlR3JvdXAgPSBtZWRpYVR5cGUuYWN0aXZlR3JvdXAoYWN0aXZlVHJhY2spO1xuICAgIHZhciBwcmV2aW91c0FjdGl2ZUxvYWRlciA9IG1lZGlhVHlwZS5hY3RpdmVQbGF5bGlzdExvYWRlcjtcblxuICAgIHN0b3BMb2FkZXJzKHNlZ21lbnRMb2FkZXIsIG1lZGlhVHlwZSk7XG5cbiAgICBpZiAoIWFjdGl2ZUdyb3VwKSB7XG4gICAgICAvLyB0aGVyZSBpcyBubyBncm91cCBhY3RpdmVcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWFjdGl2ZUdyb3VwLnBsYXlsaXN0TG9hZGVyKSB7XG4gICAgICBpZiAocHJldmlvdXNBY3RpdmVMb2FkZXIpIHtcbiAgICAgICAgLy8gVGhlIHByZXZpb3VzIGdyb3VwIGhhZCBhIHBsYXlsaXN0IGxvYWRlciBidXQgdGhlIG5ldyBhY3RpdmUgZ3JvdXAgZG9lcyBub3RcbiAgICAgICAgLy8gdGhpcyBtZWFucyB3ZSBhcmUgc3dpdGNoaW5nIGZyb20gZGVtdXhlZCB0byBtdXhlZCBhdWRpby4gSW4gdGhpcyBjYXNlIHdlIHdhbnQgdG9cbiAgICAgICAgLy8gZG8gYSBkZXN0cnVjdGl2ZSByZXNldCBvZiB0aGUgbWFpbiBzZWdtZW50IGxvYWRlciBhbmQgbm90IHJlc3RhcnQgdGhlIGF1ZGlvXG4gICAgICAgIC8vIGxvYWRlcnMuXG4gICAgICAgIG1haW5TZWdtZW50TG9hZGVyLnJlc2V0RXZlcnl0aGluZygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5vbi1kZXN0cnVjdGl2ZSByZXN5bmNcbiAgICBzZWdtZW50TG9hZGVyLnJlc3luY0xvYWRlcigpO1xuXG4gICAgc3RhcnRMb2FkZXJzKGFjdGl2ZUdyb3VwLnBsYXlsaXN0TG9hZGVyLCBtZWRpYVR5cGUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIG1lZGlhIHRyYWNrIGNoYW5nZXMuIEl0IHBlcmZvcm1zIGFcbiAqIGRlc3RydWN0aXZlIHJlc2V0IG9mIHRoZSBTZWdtZW50TG9hZGVyIHRvIGVuc3VyZSB3ZSBzdGFydCBsb2FkaW5nIGFzIGNsb3NlIHRvXG4gKiBjdXJyZW50VGltZSBhcyBwb3NzaWJsZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogICAgICAgIE1lZGlhR3JvdXAgdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4gKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcmVxdWlyZWQgaW5mb3JtYXRpb24gZm9yIG1lZGlhIGdyb3Vwc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiAgICAgICAgIEhhbmRsZXIgZm9yIGEgZGVzdHJ1Y3RpdmUgcmVzZXQgb2YgU2VnbWVudExvYWRlciB3aGVuIHRoZSBhY3RpdmUgbWVkaWFcbiAqICAgICAgICAgdHJhY2sgY2hhbmdlcy5cbiAqIEBmdW5jdGlvbiBvblRyYWNrQ2hhbmdlZFxuICovXG52YXIgb25UcmFja0NoYW5nZWQgPSBmdW5jdGlvbiBvblRyYWNrQ2hhbmdlZCh0eXBlLCBzZXR0aW5ncykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfc2V0dGluZ3Mkc2VnbWVudExvYWQyID0gc2V0dGluZ3Muc2VnbWVudExvYWRlcnMsXG4gICAgICAgIHNlZ21lbnRMb2FkZXIgPSBfc2V0dGluZ3Mkc2VnbWVudExvYWQyW3R5cGVdLFxuICAgICAgICBtYWluU2VnbWVudExvYWRlciA9IF9zZXR0aW5ncyRzZWdtZW50TG9hZDIubWFpbixcbiAgICAgICAgbWVkaWFUeXBlID0gc2V0dGluZ3MubWVkaWFUeXBlc1t0eXBlXTtcblxuICAgIHZhciBhY3RpdmVUcmFjayA9IG1lZGlhVHlwZS5hY3RpdmVUcmFjaygpO1xuICAgIHZhciBhY3RpdmVHcm91cCA9IG1lZGlhVHlwZS5hY3RpdmVHcm91cChhY3RpdmVUcmFjayk7XG4gICAgdmFyIHByZXZpb3VzQWN0aXZlTG9hZGVyID0gbWVkaWFUeXBlLmFjdGl2ZVBsYXlsaXN0TG9hZGVyO1xuXG4gICAgc3RvcExvYWRlcnMoc2VnbWVudExvYWRlciwgbWVkaWFUeXBlKTtcblxuICAgIGlmICghYWN0aXZlR3JvdXApIHtcbiAgICAgIC8vIHRoZXJlIGlzIG5vIGdyb3VwIGFjdGl2ZSBzbyB3ZSBkbyBub3Qgd2FudCB0byByZXN0YXJ0IGxvYWRlcnNcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWFjdGl2ZUdyb3VwLnBsYXlsaXN0TG9hZGVyKSB7XG4gICAgICAvLyB3aGVuIHN3aXRjaGluZyBmcm9tIGRlbXV4ZWQgYXVkaW8vdmlkZW8gdG8gbXV4ZWQgYXVkaW8vdmlkZW8gKG5vdGVkIGJ5IG5vIHBsYXlsaXN0XG4gICAgICAvLyBsb2FkZXIgZm9yIHRoZSBhdWRpbyBncm91cCksIHdlIHdhbnQgdG8gZG8gYSBkZXN0cnVjdGl2ZSByZXNldCBvZiB0aGUgbWFpbiBzZWdtZW50XG4gICAgICAvLyBsb2FkZXIgYW5kIG5vdCByZXN0YXJ0IHRoZSBhdWRpbyBsb2FkZXJzXG4gICAgICBtYWluU2VnbWVudExvYWRlci5yZXNldEV2ZXJ5dGhpbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXNBY3RpdmVMb2FkZXIgPT09IGFjdGl2ZUdyb3VwLnBsYXlsaXN0TG9hZGVyKSB7XG4gICAgICAvLyBOb3RoaW5nIGhhcyBhY3R1YWxseSBjaGFuZ2VkLiBUaGlzIGNhbiBoYXBwZW4gYmVjYXVzZSB0cmFjayBjaGFuZ2UgZXZlbnRzIGNhbiBmaXJlXG4gICAgICAvLyBtdWx0aXBsZSB0aW1lcyBmb3IgYSBcInNpbmdsZVwiIGNoYW5nZS4gT25lIGZvciBlbmFibGluZyB0aGUgbmV3IGFjdGl2ZSB0cmFjaywgYW5kXG4gICAgICAvLyBvbmUgZm9yIGRpc2FibGluZyB0aGUgdHJhY2sgdGhhdCB3YXMgYWN0aXZlXG4gICAgICBzdGFydExvYWRlcnMoYWN0aXZlR3JvdXAucGxheWxpc3RMb2FkZXIsIG1lZGlhVHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnRMb2FkZXIudHJhY2spIHtcbiAgICAgIC8vIEZvciBXZWJWVFQsIHNldCB0aGUgbmV3IHRleHQgdHJhY2sgaW4gdGhlIHNlZ21lbnRsb2FkZXJcbiAgICAgIHNlZ21lbnRMb2FkZXIudHJhY2soYWN0aXZlVHJhY2spO1xuICAgIH1cblxuICAgIC8vIGRlc3RydWN0aXZlIHJlc2V0XG4gICAgc2VnbWVudExvYWRlci5yZXNldEV2ZXJ5dGhpbmcoKTtcblxuICAgIHN0YXJ0TG9hZGVycyhhY3RpdmVHcm91cC5wbGF5bGlzdExvYWRlciwgbWVkaWFUeXBlKTtcbiAgfTtcbn07XG5cbnZhciBvbkVycm9yID0ge1xuICAvKipcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIGEgU2VnbWVudExvYWRlciBvciBQbGF5bGlzdExvYWRlciBlbmNvdW50ZXJzXG4gICAqIGFuIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgTWVkaWFHcm91cCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICAgKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcmVxdWlyZWQgaW5mb3JtYXRpb24gZm9yIG1lZGlhIGdyb3Vwc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICogICAgICAgICBFcnJvciBoYW5kbGVyLiBMb2dzIHdhcm5pbmcgKG9yIGVycm9yIGlmIHRoZSBwbGF5bGlzdCBpcyBibGFja2xpc3RlZCkgdG9cbiAgICogICAgICAgICBjb25zb2xlIGFuZCBzd2l0Y2hlcyBiYWNrIHRvIGRlZmF1bHQgYXVkaW8gdHJhY2suXG4gICAqIEBmdW5jdGlvbiBvbkVycm9yLkFVRElPXG4gICAqL1xuICBBVURJTzogZnVuY3Rpb24gQVVESU8odHlwZSwgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlZ21lbnRMb2FkZXIgPSBzZXR0aW5ncy5zZWdtZW50TG9hZGVyc1t0eXBlXSxcbiAgICAgICAgICBtZWRpYVR5cGUgPSBzZXR0aW5ncy5tZWRpYVR5cGVzW3R5cGVdLFxuICAgICAgICAgIGJsYWNrbGlzdEN1cnJlbnRQbGF5bGlzdCA9IHNldHRpbmdzLmJsYWNrbGlzdEN1cnJlbnRQbGF5bGlzdDtcblxuICAgICAgc3RvcExvYWRlcnMoc2VnbWVudExvYWRlciwgbWVkaWFUeXBlKTtcblxuICAgICAgLy8gc3dpdGNoIGJhY2sgdG8gZGVmYXVsdCBhdWRpbyB0cmFja1xuICAgICAgdmFyIGFjdGl2ZVRyYWNrID0gbWVkaWFUeXBlLmFjdGl2ZVRyYWNrKCk7XG4gICAgICB2YXIgYWN0aXZlR3JvdXAgPSBtZWRpYVR5cGUuYWN0aXZlR3JvdXAoKTtcbiAgICAgIHZhciBpZCA9IChhY3RpdmVHcm91cC5maWx0ZXIoZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBncm91cC5kZWZhdWx0O1xuICAgICAgfSlbMF0gfHwgYWN0aXZlR3JvdXBbMF0pLmlkO1xuICAgICAgdmFyIGRlZmF1bHRUcmFjayA9IG1lZGlhVHlwZS50cmFja3NbaWRdO1xuXG4gICAgICBpZiAoYWN0aXZlVHJhY2sgPT09IGRlZmF1bHRUcmFjaykge1xuICAgICAgICAvLyBEZWZhdWx0IHRyYWNrIGVuY291bnRlcmVkIGFuIGVycm9yLiBBbGwgd2UgY2FuIGRvIG5vdyBpcyBibGFja2xpc3QgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gcmVuZGl0aW9uIGFuZCBob3BlIGFub3RoZXIgd2lsbCBzd2l0Y2ggYXVkaW8gZ3JvdXBzXG4gICAgICAgIGJsYWNrbGlzdEN1cnJlbnRQbGF5bGlzdCh7XG4gICAgICAgICAgbWVzc2FnZTogJ1Byb2JsZW0gZW5jb3VudGVyZWQgbG9hZGluZyB0aGUgZGVmYXVsdCBhdWRpbyB0cmFjay4nXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZpZGVvanMkMS5sb2cud2FybignUHJvYmxlbSBlbmNvdW50ZXJlZCBsb2FkaW5nIHRoZSBhbHRlcm5hdGUgYXVkaW8gdHJhY2suJyArICdTd2l0Y2hpbmcgYmFjayB0byBkZWZhdWx0LicpO1xuXG4gICAgICBmb3IgKHZhciB0cmFja0lkIGluIG1lZGlhVHlwZS50cmFja3MpIHtcbiAgICAgICAgbWVkaWFUeXBlLnRyYWNrc1t0cmFja0lkXS5lbmFibGVkID0gbWVkaWFUeXBlLnRyYWNrc1t0cmFja0lkXSA9PT0gZGVmYXVsdFRyYWNrO1xuICAgICAgfVxuXG4gICAgICBtZWRpYVR5cGUub25UcmFja0NoYW5nZWQoKTtcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIGEgU2VnbWVudExvYWRlciBvciBQbGF5bGlzdExvYWRlciBlbmNvdW50ZXJzXG4gICAqIGFuIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgTWVkaWFHcm91cCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICAgKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcmVxdWlyZWQgaW5mb3JtYXRpb24gZm9yIG1lZGlhIGdyb3Vwc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICogICAgICAgICBFcnJvciBoYW5kbGVyLiBMb2dzIHdhcm5pbmcgdG8gY29uc29sZSBhbmQgZGlzYWJsZXMgdGhlIGFjdGl2ZSBzdWJ0aXRsZSB0cmFja1xuICAgKiBAZnVuY3Rpb24gb25FcnJvci5TVUJUSVRMRVNcbiAgICovXG4gIFNVQlRJVExFUzogZnVuY3Rpb24gU1VCVElUTEVTKHR5cGUsIHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWdtZW50TG9hZGVyID0gc2V0dGluZ3Muc2VnbWVudExvYWRlcnNbdHlwZV0sXG4gICAgICAgICAgbWVkaWFUeXBlID0gc2V0dGluZ3MubWVkaWFUeXBlc1t0eXBlXTtcblxuICAgICAgdmlkZW9qcyQxLmxvZy53YXJuKCdQcm9ibGVtIGVuY291bnRlcmVkIGxvYWRpbmcgdGhlIHN1YnRpdGxlIHRyYWNrLicgKyAnRGlzYWJsaW5nIHN1YnRpdGxlIHRyYWNrLicpO1xuXG4gICAgICBzdG9wTG9hZGVycyhzZWdtZW50TG9hZGVyLCBtZWRpYVR5cGUpO1xuXG4gICAgICB2YXIgdHJhY2sgPSBtZWRpYVR5cGUuYWN0aXZlVHJhY2soKTtcblxuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgfVxuXG4gICAgICBtZWRpYVR5cGUub25UcmFja0NoYW5nZWQoKTtcbiAgICB9O1xuICB9XG59O1xuXG52YXIgc2V0dXBMaXN0ZW5lcnMgPSB7XG4gIC8qKlxuICAgKiBTZXR1cCBldmVudCBsaXN0ZW5lcnMgZm9yIGF1ZGlvIHBsYXlsaXN0IGxvYWRlclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgTWVkaWFHcm91cCB0eXBlXG4gICAqIEBwYXJhbSB7UGxheWxpc3RMb2FkZXJ8bnVsbH0gcGxheWxpc3RMb2FkZXJcbiAgICogICAgICAgIFBsYXlsaXN0TG9hZGVyIHRvIHJlZ2lzdGVyIGxpc3RlbmVycyBvblxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3NcbiAgICogICAgICAgIE9iamVjdCBjb250YWluaW5nIHJlcXVpcmVkIGluZm9ybWF0aW9uIGZvciBtZWRpYSBncm91cHNcbiAgICogQGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzLkFVRElPXG4gICAqL1xuICBBVURJTzogZnVuY3Rpb24gQVVESU8odHlwZSwgcGxheWxpc3RMb2FkZXIsIHNldHRpbmdzKSB7XG4gICAgaWYgKCFwbGF5bGlzdExvYWRlcikge1xuICAgICAgLy8gbm8gcGxheWxpc3QgbG9hZGVyIG1lYW5zIGF1ZGlvIHdpbGwgYmUgbXV4ZWQgd2l0aCB0aGUgdmlkZW9cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGVjaCA9IHNldHRpbmdzLnRlY2gsXG4gICAgICAgIHJlcXVlc3RPcHRpb25zID0gc2V0dGluZ3MucmVxdWVzdE9wdGlvbnMsXG4gICAgICAgIHNlZ21lbnRMb2FkZXIgPSBzZXR0aW5ncy5zZWdtZW50TG9hZGVyc1t0eXBlXTtcblxuICAgIHBsYXlsaXN0TG9hZGVyLm9uKCdsb2FkZWRtZXRhZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtZWRpYSA9IHBsYXlsaXN0TG9hZGVyLm1lZGlhKCk7XG5cbiAgICAgIHNlZ21lbnRMb2FkZXIucGxheWxpc3QobWVkaWEsIHJlcXVlc3RPcHRpb25zKTtcblxuICAgICAgLy8gaWYgdGhlIHZpZGVvIGlzIGFscmVhZHkgcGxheWluZywgb3IgaWYgdGhpcyBpc24ndCBhIGxpdmUgdmlkZW8gYW5kIHByZWxvYWRcbiAgICAgIC8vIHBlcm1pdHMsIHN0YXJ0IGRvd25sb2FkaW5nIHNlZ21lbnRzXG4gICAgICBpZiAoIXRlY2gucGF1c2VkKCkgfHwgbWVkaWEuZW5kTGlzdCAmJiB0ZWNoLnByZWxvYWQoKSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIHNlZ21lbnRMb2FkZXIubG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcGxheWxpc3RMb2FkZXIub24oJ2xvYWRlZHBsYXlsaXN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VnbWVudExvYWRlci5wbGF5bGlzdChwbGF5bGlzdExvYWRlci5tZWRpYSgpLCByZXF1ZXN0T3B0aW9ucyk7XG5cbiAgICAgIC8vIElmIHRoZSBwbGF5ZXIgaXNuJ3QgcGF1c2VkLCBlbnN1cmUgdGhhdCB0aGUgc2VnbWVudCBsb2FkZXIgaXMgcnVubmluZ1xuICAgICAgaWYgKCF0ZWNoLnBhdXNlZCgpKSB7XG4gICAgICAgIHNlZ21lbnRMb2FkZXIubG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcGxheWxpc3RMb2FkZXIub24oJ2Vycm9yJywgb25FcnJvclt0eXBlXSh0eXBlLCBzZXR0aW5ncykpO1xuICB9LFxuICAvKipcbiAgICogU2V0dXAgZXZlbnQgbGlzdGVuZXJzIGZvciBzdWJ0aXRsZSBwbGF5bGlzdCBsb2FkZXJcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogICAgICAgIE1lZGlhR3JvdXAgdHlwZVxuICAgKiBAcGFyYW0ge1BsYXlsaXN0TG9hZGVyfG51bGx9IHBsYXlsaXN0TG9hZGVyXG4gICAqICAgICAgICBQbGF5bGlzdExvYWRlciB0byByZWdpc3RlciBsaXN0ZW5lcnMgb25cbiAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4gICAqICAgICAgICBPYmplY3QgY29udGFpbmluZyByZXF1aXJlZCBpbmZvcm1hdGlvbiBmb3IgbWVkaWEgZ3JvdXBzXG4gICAqIEBmdW5jdGlvbiBzZXR1cExpc3RlbmVycy5TVUJUSVRMRVNcbiAgICovXG4gIFNVQlRJVExFUzogZnVuY3Rpb24gU1VCVElUTEVTKHR5cGUsIHBsYXlsaXN0TG9hZGVyLCBzZXR0aW5ncykge1xuICAgIHZhciB0ZWNoID0gc2V0dGluZ3MudGVjaCxcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMgPSBzZXR0aW5ncy5yZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgc2VnbWVudExvYWRlciA9IHNldHRpbmdzLnNlZ21lbnRMb2FkZXJzW3R5cGVdLFxuICAgICAgICBtZWRpYVR5cGUgPSBzZXR0aW5ncy5tZWRpYVR5cGVzW3R5cGVdO1xuXG4gICAgcGxheWxpc3RMb2FkZXIub24oJ2xvYWRlZG1ldGFkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1lZGlhID0gcGxheWxpc3RMb2FkZXIubWVkaWEoKTtcblxuICAgICAgc2VnbWVudExvYWRlci5wbGF5bGlzdChtZWRpYSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgc2VnbWVudExvYWRlci50cmFjayhtZWRpYVR5cGUuYWN0aXZlVHJhY2soKSk7XG5cbiAgICAgIC8vIGlmIHRoZSB2aWRlbyBpcyBhbHJlYWR5IHBsYXlpbmcsIG9yIGlmIHRoaXMgaXNuJ3QgYSBsaXZlIHZpZGVvIGFuZCBwcmVsb2FkXG4gICAgICAvLyBwZXJtaXRzLCBzdGFydCBkb3dubG9hZGluZyBzZWdtZW50c1xuICAgICAgaWYgKCF0ZWNoLnBhdXNlZCgpIHx8IG1lZGlhLmVuZExpc3QgJiYgdGVjaC5wcmVsb2FkKCkgIT09ICdub25lJykge1xuICAgICAgICBzZWdtZW50TG9hZGVyLmxvYWQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHBsYXlsaXN0TG9hZGVyLm9uKCdsb2FkZWRwbGF5bGlzdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlZ21lbnRMb2FkZXIucGxheWxpc3QocGxheWxpc3RMb2FkZXIubWVkaWEoKSwgcmVxdWVzdE9wdGlvbnMpO1xuXG4gICAgICAvLyBJZiB0aGUgcGxheWVyIGlzbid0IHBhdXNlZCwgZW5zdXJlIHRoYXQgdGhlIHNlZ21lbnQgbG9hZGVyIGlzIHJ1bm5pbmdcbiAgICAgIGlmICghdGVjaC5wYXVzZWQoKSkge1xuICAgICAgICBzZWdtZW50TG9hZGVyLmxvYWQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHBsYXlsaXN0TG9hZGVyLm9uKCdlcnJvcicsIG9uRXJyb3JbdHlwZV0odHlwZSwgc2V0dGluZ3MpKTtcbiAgfVxufTtcblxudmFyIGJ5R3JvdXBJZCA9IGZ1bmN0aW9uIGJ5R3JvdXBJZCh0eXBlLCBncm91cElkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocGxheWxpc3QpIHtcbiAgICByZXR1cm4gcGxheWxpc3QuYXR0cmlidXRlc1t0eXBlXSA9PT0gZ3JvdXBJZDtcbiAgfTtcbn07XG5cbnZhciBieVJlc29sdmVkVXJpID0gZnVuY3Rpb24gYnlSZXNvbHZlZFVyaShyZXNvbHZlZFVyaSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHBsYXlsaXN0KSB7XG4gICAgcmV0dXJuIHBsYXlsaXN0LnJlc29sdmVkVXJpID09PSByZXNvbHZlZFVyaTtcbiAgfTtcbn07XG5cbnZhciBpbml0aWFsaXplID0ge1xuICAvKipcbiAgICogU2V0dXAgUGxheWxpc3RMb2FkZXJzIGFuZCBBdWRpb1RyYWNrcyBmb3IgdGhlIGF1ZGlvIGdyb3Vwc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgTWVkaWFHcm91cCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICAgKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcmVxdWlyZWQgaW5mb3JtYXRpb24gZm9yIG1lZGlhIGdyb3Vwc1xuICAgKiBAZnVuY3Rpb24gaW5pdGlhbGl6ZS5BVURJT1xuICAgKi9cbiAgJ0FVRElPJzogZnVuY3Rpb24gQVVESU8odHlwZSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgaGxzID0gc2V0dGluZ3MuaGxzLFxuICAgICAgICBzb3VyY2VUeXBlID0gc2V0dGluZ3Muc291cmNlVHlwZSxcbiAgICAgICAgc2VnbWVudExvYWRlciA9IHNldHRpbmdzLnNlZ21lbnRMb2FkZXJzW3R5cGVdLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHMgPSBzZXR0aW5ncy5yZXF1ZXN0T3B0aW9ucy53aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgIF9zZXR0aW5ncyRtYXN0ZXIgPSBzZXR0aW5ncy5tYXN0ZXIsXG4gICAgICAgIG1lZGlhR3JvdXBzID0gX3NldHRpbmdzJG1hc3Rlci5tZWRpYUdyb3VwcyxcbiAgICAgICAgcGxheWxpc3RzID0gX3NldHRpbmdzJG1hc3Rlci5wbGF5bGlzdHMsXG4gICAgICAgIF9zZXR0aW5ncyRtZWRpYVR5cGVzJCA9IHNldHRpbmdzLm1lZGlhVHlwZXNbdHlwZV0sXG4gICAgICAgIGdyb3VwcyA9IF9zZXR0aW5ncyRtZWRpYVR5cGVzJC5ncm91cHMsXG4gICAgICAgIHRyYWNrcyA9IF9zZXR0aW5ncyRtZWRpYVR5cGVzJC50cmFja3MsXG4gICAgICAgIG1hc3RlclBsYXlsaXN0TG9hZGVyID0gc2V0dGluZ3MubWFzdGVyUGxheWxpc3RMb2FkZXI7XG5cbiAgICAvLyBmb3JjZSBhIGRlZmF1bHQgaWYgd2UgaGF2ZSBub25lXG5cbiAgICBpZiAoIW1lZGlhR3JvdXBzW3R5cGVdIHx8IE9iamVjdC5rZXlzKG1lZGlhR3JvdXBzW3R5cGVdKS5sZW5ndGggPT09IDApIHtcbiAgICAgIG1lZGlhR3JvdXBzW3R5cGVdID0geyBtYWluOiB7IGRlZmF1bHQ6IHsgZGVmYXVsdDogdHJ1ZSB9IH0gfTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBncm91cElkIGluIG1lZGlhR3JvdXBzW3R5cGVdKSB7XG4gICAgICBpZiAoIWdyb3Vwc1tncm91cElkXSkge1xuICAgICAgICBncm91cHNbZ3JvdXBJZF0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gTGlzdCBvZiBwbGF5bGlzdHMgdGhhdCBoYXZlIGFuIEFVRElPIGF0dHJpYnV0ZSB2YWx1ZSBtYXRjaGluZyB0aGUgY3VycmVudFxuICAgICAgLy8gZ3JvdXAgSURcbiAgICAgIHZhciBncm91cFBsYXlsaXN0cyA9IHBsYXlsaXN0cy5maWx0ZXIoYnlHcm91cElkKHR5cGUsIGdyb3VwSWQpKTtcblxuICAgICAgZm9yICh2YXIgdmFyaWFudExhYmVsIGluIG1lZGlhR3JvdXBzW3R5cGVdW2dyb3VwSWRdKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gbWVkaWFHcm91cHNbdHlwZV1bZ3JvdXBJZF1bdmFyaWFudExhYmVsXTtcblxuICAgICAgICAvLyBMaXN0IG9mIHBsYXlsaXN0cyBmb3IgdGhlIGN1cnJlbnQgZ3JvdXAgSUQgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgdXJpIHdpdGhcbiAgICAgICAgLy8gdGhpcyBhbHRlcm5hdGUgYXVkaW8gdmFyaWFudFxuICAgICAgICB2YXIgbWF0Y2hpbmdQbGF5bGlzdHMgPSBncm91cFBsYXlsaXN0cy5maWx0ZXIoYnlSZXNvbHZlZFVyaShwcm9wZXJ0aWVzLnJlc29sdmVkVXJpKSk7XG5cbiAgICAgICAgaWYgKG1hdGNoaW5nUGxheWxpc3RzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcGxheWxpc3QgdGhhdCBoYXMgdGhlIHNhbWUgdXJpIGFzIHRoaXMgYXVkaW8gdmFyaWFudCwgYXNzdW1lXG4gICAgICAgICAgLy8gdGhhdCB0aGUgcGxheWxpc3QgaXMgYXVkaW8gb25seS4gV2UgZGVsZXRlIHRoZSByZXNvbHZlZFVyaSBwcm9wZXJ0eSBoZXJlXG4gICAgICAgICAgLy8gdG8gcHJldmVudCBhIHBsYXlsaXN0IGxvYWRlciBmcm9tIGJlaW5nIGNyZWF0ZWQgc28gdGhhdCB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgLy8gYm90aCB0aGUgbWFpbiBhbmQgYXVkaW8gc2VnbWVudCBsb2FkZXJzIGxvYWRpbmcgdGhlIHNhbWUgYXVkaW8gc2VnbWVudHNcbiAgICAgICAgICAvLyBmcm9tIHRoZSBzYW1lIHBsYXlsaXN0LlxuICAgICAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzLnJlc29sdmVkVXJpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBsYXlsaXN0TG9hZGVyID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLnJlc29sdmVkVXJpKSB7XG4gICAgICAgICAgcGxheWxpc3RMb2FkZXIgPSBuZXcgUGxheWxpc3RMb2FkZXIocHJvcGVydGllcy5yZXNvbHZlZFVyaSwgaGxzLCB3aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnRpZXMucGxheWxpc3RzICYmIHNvdXJjZVR5cGUgPT09ICdkYXNoJykge1xuICAgICAgICAgIHBsYXlsaXN0TG9hZGVyID0gbmV3IERhc2hQbGF5bGlzdExvYWRlcihwcm9wZXJ0aWVzLnBsYXlsaXN0c1swXSwgaGxzLCB3aXRoQ3JlZGVudGlhbHMsIG1hc3RlclBsYXlsaXN0TG9hZGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyByZXNvbHZlZFVyaSBtZWFucyB0aGUgYXVkaW8gaXMgbXV4ZWQgd2l0aCB0aGUgdmlkZW8gd2hlbiB1c2luZyB0aGlzXG4gICAgICAgICAgLy8gYXVkaW8gdHJhY2tcbiAgICAgICAgICBwbGF5bGlzdExvYWRlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wZXJ0aWVzID0gdmlkZW9qcyQxLm1lcmdlT3B0aW9ucyh7IGlkOiB2YXJpYW50TGFiZWwsIHBsYXlsaXN0TG9hZGVyOiBwbGF5bGlzdExvYWRlciB9LCBwcm9wZXJ0aWVzKTtcblxuICAgICAgICBzZXR1cExpc3RlbmVyc1t0eXBlXSh0eXBlLCBwcm9wZXJ0aWVzLnBsYXlsaXN0TG9hZGVyLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgZ3JvdXBzW2dyb3VwSWRdLnB1c2gocHJvcGVydGllcyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFja3NbdmFyaWFudExhYmVsXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgdHJhY2sgPSBuZXcgdmlkZW9qcyQxLkF1ZGlvVHJhY2soe1xuICAgICAgICAgICAgaWQ6IHZhcmlhbnRMYWJlbCxcbiAgICAgICAgICAgIGtpbmQ6IGF1ZGlvVHJhY2tLaW5kXyhwcm9wZXJ0aWVzKSxcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHByb3BlcnRpZXMubGFuZ3VhZ2UsXG4gICAgICAgICAgICBkZWZhdWx0OiBwcm9wZXJ0aWVzLmRlZmF1bHQsXG4gICAgICAgICAgICBsYWJlbDogdmFyaWFudExhYmVsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0cmFja3NbdmFyaWFudExhYmVsXSA9IHRyYWNrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgc2luZ2xlIGVycm9yIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBzZWdtZW50IGxvYWRlclxuICAgIHNlZ21lbnRMb2FkZXIub24oJ2Vycm9yJywgb25FcnJvclt0eXBlXSh0eXBlLCBzZXR0aW5ncykpO1xuICB9LFxuICAvKipcbiAgICogU2V0dXAgUGxheWxpc3RMb2FkZXJzIGFuZCBUZXh0VHJhY2tzIGZvciB0aGUgc3VidGl0bGUgZ3JvdXBzXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBNZWRpYUdyb3VwIHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4gICAqICAgICAgICBPYmplY3QgY29udGFpbmluZyByZXF1aXJlZCBpbmZvcm1hdGlvbiBmb3IgbWVkaWEgZ3JvdXBzXG4gICAqIEBmdW5jdGlvbiBpbml0aWFsaXplLlNVQlRJVExFU1xuICAgKi9cbiAgJ1NVQlRJVExFUyc6IGZ1bmN0aW9uIFNVQlRJVExFUyh0eXBlLCBzZXR0aW5ncykge1xuICAgIHZhciB0ZWNoID0gc2V0dGluZ3MudGVjaCxcbiAgICAgICAgaGxzID0gc2V0dGluZ3MuaGxzLFxuICAgICAgICBzb3VyY2VUeXBlID0gc2V0dGluZ3Muc291cmNlVHlwZSxcbiAgICAgICAgc2VnbWVudExvYWRlciA9IHNldHRpbmdzLnNlZ21lbnRMb2FkZXJzW3R5cGVdLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHMgPSBzZXR0aW5ncy5yZXF1ZXN0T3B0aW9ucy53aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgIG1lZGlhR3JvdXBzID0gc2V0dGluZ3MubWFzdGVyLm1lZGlhR3JvdXBzLFxuICAgICAgICBfc2V0dGluZ3MkbWVkaWFUeXBlcyQyID0gc2V0dGluZ3MubWVkaWFUeXBlc1t0eXBlXSxcbiAgICAgICAgZ3JvdXBzID0gX3NldHRpbmdzJG1lZGlhVHlwZXMkMi5ncm91cHMsXG4gICAgICAgIHRyYWNrcyA9IF9zZXR0aW5ncyRtZWRpYVR5cGVzJDIudHJhY2tzLFxuICAgICAgICBtYXN0ZXJQbGF5bGlzdExvYWRlciA9IHNldHRpbmdzLm1hc3RlclBsYXlsaXN0TG9hZGVyO1xuXG4gICAgZm9yICh2YXIgZ3JvdXBJZCBpbiBtZWRpYUdyb3Vwc1t0eXBlXSkge1xuICAgICAgaWYgKCFncm91cHNbZ3JvdXBJZF0pIHtcbiAgICAgICAgZ3JvdXBzW2dyb3VwSWRdID0gW107XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHZhcmlhbnRMYWJlbCBpbiBtZWRpYUdyb3Vwc1t0eXBlXVtncm91cElkXSkge1xuICAgICAgICBpZiAobWVkaWFHcm91cHNbdHlwZV1bZ3JvdXBJZF1bdmFyaWFudExhYmVsXS5mb3JjZWQpIHtcbiAgICAgICAgICAvLyBTdWJ0aXRsZSBwbGF5bGlzdHMgd2l0aCB0aGUgZm9yY2VkIGF0dHJpYnV0ZSBhcmUgbm90IHNlbGVjdGFibGUgaW4gU2FmYXJpLlxuICAgICAgICAgIC8vIEFjY29yZGluZyB0byBBcHBsZSdzIEhMUyBBdXRob3JpbmcgU3BlY2lmaWNhdGlvbjpcbiAgICAgICAgICAvLyAgIElmIGNvbnRlbnQgaGFzIGZvcmNlZCBzdWJ0aXRsZXMgYW5kIHJlZ3VsYXIgc3VidGl0bGVzIGluIGEgZ2l2ZW4gbGFuZ3VhZ2UsXG4gICAgICAgICAgLy8gICB0aGUgcmVndWxhciBzdWJ0aXRsZXMgdHJhY2sgaW4gdGhhdCBsYW5ndWFnZSBNVVNUIGNvbnRhaW4gYm90aCB0aGUgZm9yY2VkXG4gICAgICAgICAgLy8gICBzdWJ0aXRsZXMgYW5kIHRoZSByZWd1bGFyIHN1YnRpdGxlcyBmb3IgdGhhdCBsYW5ndWFnZS5cbiAgICAgICAgICAvLyBCZWNhdXNlIG9mIHRoaXMgcmVxdWlyZW1lbnQgYW5kIHRoYXQgU2FmYXJpIGRvZXMgbm90IGFkZCBmb3JjZWQgc3VidGl0bGVzLFxuICAgICAgICAgIC8vIGZvcmNlZCBzdWJ0aXRsZXMgYXJlIHNraXBwZWQgaGVyZSB0byBtYWludGFpbiBjb25zaXN0ZW50IGV4cGVyaWVuY2UgYWNyb3NzXG4gICAgICAgICAgLy8gYWxsIHBsYXRmb3Jtc1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBtZWRpYUdyb3Vwc1t0eXBlXVtncm91cElkXVt2YXJpYW50TGFiZWxdO1xuXG4gICAgICAgIHZhciBwbGF5bGlzdExvYWRlciA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoc291cmNlVHlwZSA9PT0gJ2hscycpIHtcbiAgICAgICAgICBwbGF5bGlzdExvYWRlciA9IG5ldyBQbGF5bGlzdExvYWRlcihwcm9wZXJ0aWVzLnJlc29sdmVkVXJpLCBobHMsIHdpdGhDcmVkZW50aWFscyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSA9PT0gJ2Rhc2gnKSB7XG4gICAgICAgICAgcGxheWxpc3RMb2FkZXIgPSBuZXcgRGFzaFBsYXlsaXN0TG9hZGVyKHByb3BlcnRpZXMucGxheWxpc3RzWzBdLCBobHMsIHdpdGhDcmVkZW50aWFscywgbWFzdGVyUGxheWxpc3RMb2FkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcGVydGllcyA9IHZpZGVvanMkMS5tZXJnZU9wdGlvbnMoe1xuICAgICAgICAgIGlkOiB2YXJpYW50TGFiZWwsXG4gICAgICAgICAgcGxheWxpc3RMb2FkZXI6IHBsYXlsaXN0TG9hZGVyXG4gICAgICAgIH0sIHByb3BlcnRpZXMpO1xuXG4gICAgICAgIHNldHVwTGlzdGVuZXJzW3R5cGVdKHR5cGUsIHByb3BlcnRpZXMucGxheWxpc3RMb2FkZXIsIHNldHRpbmdzKTtcblxuICAgICAgICBncm91cHNbZ3JvdXBJZF0ucHVzaChwcm9wZXJ0aWVzKTtcblxuICAgICAgICBpZiAodHlwZW9mIHRyYWNrc1t2YXJpYW50TGFiZWxdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHZhciB0cmFjayA9IHRlY2guYWRkUmVtb3RlVGV4dFRyYWNrKHtcbiAgICAgICAgICAgIGlkOiB2YXJpYW50TGFiZWwsXG4gICAgICAgICAgICBraW5kOiAnc3VidGl0bGVzJyxcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHByb3BlcnRpZXMubGFuZ3VhZ2UsXG4gICAgICAgICAgICBsYWJlbDogdmFyaWFudExhYmVsXG4gICAgICAgICAgfSwgZmFsc2UpLnRyYWNrO1xuXG4gICAgICAgICAgdHJhY2tzW3ZhcmlhbnRMYWJlbF0gPSB0cmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldHVwIHNpbmdsZSBlcnJvciBldmVudCBoYW5kbGVyIGZvciB0aGUgc2VnbWVudCBsb2FkZXJcbiAgICBzZWdtZW50TG9hZGVyLm9uKCdlcnJvcicsIG9uRXJyb3JbdHlwZV0odHlwZSwgc2V0dGluZ3MpKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNldHVwIFRleHRUcmFja3MgZm9yIHRoZSBjbG9zZWQtY2FwdGlvbiBncm91cHNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogICAgICAgIE1lZGlhR3JvdXAgdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3NcbiAgICogICAgICAgIE9iamVjdCBjb250YWluaW5nIHJlcXVpcmVkIGluZm9ybWF0aW9uIGZvciBtZWRpYSBncm91cHNcbiAgICogQGZ1bmN0aW9uIGluaXRpYWxpemVbJ0NMT1NFRC1DQVBUSU9OUyddXG4gICAqL1xuICAnQ0xPU0VELUNBUFRJT05TJzogZnVuY3Rpb24gQ0xPU0VEQ0FQVElPTlModHlwZSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgdGVjaCA9IHNldHRpbmdzLnRlY2gsXG4gICAgICAgIG1lZGlhR3JvdXBzID0gc2V0dGluZ3MubWFzdGVyLm1lZGlhR3JvdXBzLFxuICAgICAgICBfc2V0dGluZ3MkbWVkaWFUeXBlcyQzID0gc2V0dGluZ3MubWVkaWFUeXBlc1t0eXBlXSxcbiAgICAgICAgZ3JvdXBzID0gX3NldHRpbmdzJG1lZGlhVHlwZXMkMy5ncm91cHMsXG4gICAgICAgIHRyYWNrcyA9IF9zZXR0aW5ncyRtZWRpYVR5cGVzJDMudHJhY2tzO1xuXG4gICAgZm9yICh2YXIgZ3JvdXBJZCBpbiBtZWRpYUdyb3Vwc1t0eXBlXSkge1xuICAgICAgaWYgKCFncm91cHNbZ3JvdXBJZF0pIHtcbiAgICAgICAgZ3JvdXBzW2dyb3VwSWRdID0gW107XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHZhcmlhbnRMYWJlbCBpbiBtZWRpYUdyb3Vwc1t0eXBlXVtncm91cElkXSkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IG1lZGlhR3JvdXBzW3R5cGVdW2dyb3VwSWRdW3ZhcmlhbnRMYWJlbF07XG5cbiAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IENFQTYwOCBjYXB0aW9ucyBmb3Igbm93LCBzbyBpZ25vcmUgYW55dGhpbmcgdGhhdFxuICAgICAgICAvLyBkb2Vzbid0IHVzZSBhIENDeCBJTlNUUkVBTS1JRFxuICAgICAgICBpZiAoIXByb3BlcnRpZXMuaW5zdHJlYW1JZC5tYXRjaCgvQ0NcXGQvKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm8gUGxheWxpc3RMb2FkZXIgaXMgcmVxdWlyZWQgZm9yIENsb3NlZC1DYXB0aW9ucyBiZWNhdXNlIHRoZSBjYXB0aW9ucyBhcmVcbiAgICAgICAgLy8gZW1iZWRkZWQgd2l0aGluIHRoZSB2aWRlbyBzdHJlYW1cbiAgICAgICAgZ3JvdXBzW2dyb3VwSWRdLnB1c2godmlkZW9qcyQxLm1lcmdlT3B0aW9ucyh7IGlkOiB2YXJpYW50TGFiZWwgfSwgcHJvcGVydGllcykpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdHJhY2tzW3ZhcmlhbnRMYWJlbF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFyIHRyYWNrID0gdGVjaC5hZGRSZW1vdGVUZXh0VHJhY2soe1xuICAgICAgICAgICAgaWQ6IHByb3BlcnRpZXMuaW5zdHJlYW1JZCxcbiAgICAgICAgICAgIGtpbmQ6ICdjYXB0aW9ucycsXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBwcm9wZXJ0aWVzLmxhbmd1YWdlLFxuICAgICAgICAgICAgbGFiZWw6IHZhcmlhbnRMYWJlbFxuICAgICAgICAgIH0sIGZhbHNlKS50cmFjaztcblxuICAgICAgICAgIHRyYWNrc1t2YXJpYW50TGFiZWxdID0gdHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHVzZWQgdG8gZ2V0IHRoZSBhY3RpdmUgZ3JvdXAgb2YgdGhlIHByb3ZpZGVkIHR5cGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogICAgICAgIE1lZGlhR3JvdXAgdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4gKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcmVxdWlyZWQgaW5mb3JtYXRpb24gZm9yIG1lZGlhIGdyb3Vwc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiAgICAgICAgIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYWN0aXZlIG1lZGlhIGdyb3VwIGZvciB0aGUgcHJvdmlkZWQgdHlwZS4gVGFrZXMgYW5cbiAqICAgICAgICAgb3B0aW9uYWwgcGFyYW1ldGVyIHtUZXh0VHJhY2t9IHRyYWNrLiBJZiBubyB0cmFjayBpcyBwcm92aWRlZCwgYSBsaXN0IG9mIGFsbFxuICogICAgICAgICB2YXJpYW50cyBpbiB0aGUgZ3JvdXAsIG90aGVyd2lzZSB0aGUgdmFyaWFudCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZFxuICogICAgICAgICB0cmFjayBpcyByZXR1cm5lZC5cbiAqIEBmdW5jdGlvbiBhY3RpdmVHcm91cFxuICovXG52YXIgYWN0aXZlR3JvdXAgPSBmdW5jdGlvbiBhY3RpdmVHcm91cCh0eXBlLCBzZXR0aW5ncykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgdmFyIG1hc3RlclBsYXlsaXN0TG9hZGVyID0gc2V0dGluZ3MubWFzdGVyUGxheWxpc3RMb2FkZXIsXG4gICAgICAgIGdyb3VwcyA9IHNldHRpbmdzLm1lZGlhVHlwZXNbdHlwZV0uZ3JvdXBzO1xuXG4gICAgdmFyIG1lZGlhID0gbWFzdGVyUGxheWxpc3RMb2FkZXIubWVkaWEoKTtcblxuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB2YXJpYW50cyA9IG51bGw7XG5cbiAgICBpZiAobWVkaWEuYXR0cmlidXRlc1t0eXBlXSkge1xuICAgICAgdmFyaWFudHMgPSBncm91cHNbbWVkaWEuYXR0cmlidXRlc1t0eXBlXV07XG4gICAgfVxuXG4gICAgdmFyaWFudHMgPSB2YXJpYW50cyB8fCBncm91cHMubWFpbjtcblxuICAgIGlmICh0eXBlb2YgdHJhY2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdmFyaWFudHM7XG4gICAgfVxuXG4gICAgaWYgKHRyYWNrID09PSBudWxsKSB7XG4gICAgICAvLyBBbiBhY3RpdmUgdHJhY2sgd2FzIHNwZWNpZmllZCBzbyBhIGNvcnJlc3BvbmRpbmcgZ3JvdXAgaXMgZXhwZWN0ZWQuIHRyYWNrID09PSBudWxsXG4gICAgICAvLyBtZWFucyBubyB0cmFjayBpcyBjdXJyZW50bHkgYWN0aXZlIHNvIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgZ3JvdXBcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB2YXJpYW50cy5maWx0ZXIoZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICByZXR1cm4gcHJvcHMuaWQgPT09IHRyYWNrLmlkO1xuICAgIH0pWzBdIHx8IG51bGw7XG4gIH07XG59O1xuXG52YXIgYWN0aXZlVHJhY2sgPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdXNlZCB0byBnZXQgdGhlIGFjdGl2ZSB0cmFjayBvZiB0eXBlIHByb3ZpZGVkXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBNZWRpYUdyb3VwIHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4gICAqICAgICAgICBPYmplY3QgY29udGFpbmluZyByZXF1aXJlZCBpbmZvcm1hdGlvbiBmb3IgbWVkaWEgZ3JvdXBzXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKiAgICAgICAgIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYWN0aXZlIG1lZGlhIHRyYWNrIGZvciB0aGUgcHJvdmlkZWQgdHlwZS4gUmV0dXJuc1xuICAgKiAgICAgICAgIG51bGwgaWYgbm8gdHJhY2sgaXMgYWN0aXZlXG4gICAqIEBmdW5jdGlvbiBhY3RpdmVUcmFjay5BVURJT1xuICAgKi9cbiAgQVVESU86IGZ1bmN0aW9uIEFVRElPKHR5cGUsIHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0cmFja3MgPSBzZXR0aW5ncy5tZWRpYVR5cGVzW3R5cGVdLnRyYWNrcztcblxuICAgICAgZm9yICh2YXIgaWQgaW4gdHJhY2tzKSB7XG4gICAgICAgIGlmICh0cmFja3NbaWRdLmVuYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2tzW2lkXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHVzZWQgdG8gZ2V0IHRoZSBhY3RpdmUgdHJhY2sgb2YgdHlwZSBwcm92aWRlZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgTWVkaWFHcm91cCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICAgKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcmVxdWlyZWQgaW5mb3JtYXRpb24gZm9yIG1lZGlhIGdyb3Vwc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICogICAgICAgICBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGFjdGl2ZSBtZWRpYSB0cmFjayBmb3IgdGhlIHByb3ZpZGVkIHR5cGUuIFJldHVybnNcbiAgICogICAgICAgICBudWxsIGlmIG5vIHRyYWNrIGlzIGFjdGl2ZVxuICAgKiBAZnVuY3Rpb24gYWN0aXZlVHJhY2suU1VCVElUTEVTXG4gICAqL1xuICBTVUJUSVRMRVM6IGZ1bmN0aW9uIFNVQlRJVExFUyh0eXBlLCBzZXR0aW5ncykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdHJhY2tzID0gc2V0dGluZ3MubWVkaWFUeXBlc1t0eXBlXS50cmFja3M7XG5cbiAgICAgIGZvciAodmFyIGlkIGluIHRyYWNrcykge1xuICAgICAgICBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2tzW2lkXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIFNldHVwIFBsYXlsaXN0TG9hZGVycyBhbmQgVHJhY2tzIGZvciBtZWRpYSBncm91cHMgKEF1ZGlvLCBTdWJ0aXRsZXMsXG4gKiBDbG9zZWQtQ2FwdGlvbnMpIHNwZWNpZmllZCBpbiB0aGUgbWFzdGVyIG1hbmlmZXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIHJlcXVpcmVkIGluZm9ybWF0aW9uIGZvciBzZXR0aW5nIHVwIHRoZSBtZWRpYSBncm91cHNcbiAqIEBwYXJhbSB7U2VnbWVudExvYWRlcn0gc2V0dGluZ3Muc2VnbWVudExvYWRlcnMuQVVESU9cbiAqICAgICAgICBBdWRpbyBzZWdtZW50IGxvYWRlclxuICogQHBhcmFtIHtTZWdtZW50TG9hZGVyfSBzZXR0aW5ncy5zZWdtZW50TG9hZGVycy5TVUJUSVRMRVNcbiAqICAgICAgICBTdWJ0aXRsZSBzZWdtZW50IGxvYWRlclxuICogQHBhcmFtIHtTZWdtZW50TG9hZGVyfSBzZXR0aW5ncy5zZWdtZW50TG9hZGVycy5tYWluXG4gKiAgICAgICAgTWFpbiBzZWdtZW50IGxvYWRlclxuICogQHBhcmFtIHtUZWNofSBzZXR0aW5ncy50ZWNoXG4gKiAgICAgICAgVGhlIHRlY2ggb2YgdGhlIHBsYXllclxuICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLnJlcXVlc3RPcHRpb25zXG4gKiAgICAgICAgWEhSIHJlcXVlc3Qgb3B0aW9ucyB1c2VkIGJ5IHRoZSBzZWdtZW50IGxvYWRlcnNcbiAqIEBwYXJhbSB7UGxheWxpc3RMb2FkZXJ9IHNldHRpbmdzLm1hc3RlclBsYXlsaXN0TG9hZGVyXG4gKiAgICAgICAgUGxheWxpc3RMb2FkZXIgZm9yIHRoZSBtYXN0ZXIgc291cmNlXG4gKiBAcGFyYW0ge0hsc0hhbmRsZXJ9IHNldHRpbmdzLmhsc1xuICogICAgICAgIEhMUyBTb3VyY2VIYW5kbGVyXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MubWFzdGVyXG4gKiAgICAgICAgVGhlIHBhcnNlZCBtYXN0ZXIgbWFuaWZlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncy5tZWRpYVR5cGVzXG4gKiAgICAgICAgT2JqZWN0IHRvIHN0b3JlIHRoZSBsb2FkZXJzLCB0cmFja3MsIGFuZCB1dGlsaXR5IG1ldGhvZHMgZm9yIGVhY2ggbWVkaWEgdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGluZ3MuYmxhY2tsaXN0Q3VycmVudFBsYXlsaXN0XG4gKiAgICAgICAgQmxhY2tsaXN0cyB0aGUgY3VycmVudCByZW5kaXRpb24gYW5kIGZvcmNlcyBhIHJlbmRpdGlvbiBzd2l0Y2guXG4gKiBAZnVuY3Rpb24gc2V0dXBNZWRpYUdyb3Vwc1xuICovXG52YXIgc2V0dXBNZWRpYUdyb3VwcyA9IGZ1bmN0aW9uIHNldHVwTWVkaWFHcm91cHMoc2V0dGluZ3MpIHtcbiAgWydBVURJTycsICdTVUJUSVRMRVMnLCAnQ0xPU0VELUNBUFRJT05TJ10uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGluaXRpYWxpemVbdHlwZV0odHlwZSwgc2V0dGluZ3MpO1xuICB9KTtcblxuICB2YXIgbWVkaWFUeXBlcyA9IHNldHRpbmdzLm1lZGlhVHlwZXMsXG4gICAgICBtYXN0ZXJQbGF5bGlzdExvYWRlciA9IHNldHRpbmdzLm1hc3RlclBsYXlsaXN0TG9hZGVyLFxuICAgICAgdGVjaCA9IHNldHRpbmdzLnRlY2gsXG4gICAgICBobHMgPSBzZXR0aW5ncy5obHM7XG5cbiAgLy8gc2V0dXAgYWN0aXZlIGdyb3VwIGFuZCB0cmFjayBnZXR0ZXJzIGFuZCBjaGFuZ2UgZXZlbnQgaGFuZGxlcnNcblxuICBbJ0FVRElPJywgJ1NVQlRJVExFUyddLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBtZWRpYVR5cGVzW3R5cGVdLmFjdGl2ZUdyb3VwID0gYWN0aXZlR3JvdXAodHlwZSwgc2V0dGluZ3MpO1xuICAgIG1lZGlhVHlwZXNbdHlwZV0uYWN0aXZlVHJhY2sgPSBhY3RpdmVUcmFja1t0eXBlXSh0eXBlLCBzZXR0aW5ncyk7XG4gICAgbWVkaWFUeXBlc1t0eXBlXS5vbkdyb3VwQ2hhbmdlZCA9IG9uR3JvdXBDaGFuZ2VkKHR5cGUsIHNldHRpbmdzKTtcbiAgICBtZWRpYVR5cGVzW3R5cGVdLm9uVHJhY2tDaGFuZ2VkID0gb25UcmFja0NoYW5nZWQodHlwZSwgc2V0dGluZ3MpO1xuICB9KTtcblxuICAvLyBETyBOT1QgZW5hYmxlIHRoZSBkZWZhdWx0IHN1YnRpdGxlIG9yIGNhcHRpb24gdHJhY2suXG4gIC8vIERPIGVuYWJsZSB0aGUgZGVmYXVsdCBhdWRpbyB0cmFja1xuICB2YXIgYXVkaW9Hcm91cCA9IG1lZGlhVHlwZXMuQVVESU8uYWN0aXZlR3JvdXAoKTtcbiAgdmFyIGdyb3VwSWQgPSAoYXVkaW9Hcm91cC5maWx0ZXIoZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLmRlZmF1bHQ7XG4gIH0pWzBdIHx8IGF1ZGlvR3JvdXBbMF0pLmlkO1xuXG4gIG1lZGlhVHlwZXMuQVVESU8udHJhY2tzW2dyb3VwSWRdLmVuYWJsZWQgPSB0cnVlO1xuICBtZWRpYVR5cGVzLkFVRElPLm9uVHJhY2tDaGFuZ2VkKCk7XG5cbiAgbWFzdGVyUGxheWxpc3RMb2FkZXIub24oJ21lZGlhY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIFsnQVVESU8nLCAnU1VCVElUTEVTJ10uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgcmV0dXJuIG1lZGlhVHlwZXNbdHlwZV0ub25Hcm91cENoYW5nZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gY3VzdG9tIGF1ZGlvIHRyYWNrIGNoYW5nZSBldmVudCBoYW5kbGVyIGZvciB1c2FnZSBldmVudFxuICB2YXIgb25BdWRpb1RyYWNrQ2hhbmdlZCA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja0NoYW5nZWQoKSB7XG4gICAgbWVkaWFUeXBlcy5BVURJTy5vblRyYWNrQ2hhbmdlZCgpO1xuICAgIHRlY2gudHJpZ2dlcih7IHR5cGU6ICd1c2FnZScsIG5hbWU6ICdobHMtYXVkaW8tY2hhbmdlJyB9KTtcbiAgfTtcblxuICB0ZWNoLmF1ZGlvVHJhY2tzKCkuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25BdWRpb1RyYWNrQ2hhbmdlZCk7XG4gIHRlY2gucmVtb3RlVGV4dFRyYWNrcygpLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG1lZGlhVHlwZXMuU1VCVElUTEVTLm9uVHJhY2tDaGFuZ2VkKTtcblxuICBobHMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGVjaC5hdWRpb1RyYWNrcygpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQXVkaW9UcmFja0NoYW5nZWQpO1xuICAgIHRlY2gucmVtb3RlVGV4dFRyYWNrcygpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG1lZGlhVHlwZXMuU1VCVElUTEVTLm9uVHJhY2tDaGFuZ2VkKTtcbiAgfSk7XG5cbiAgLy8gY2xlYXIgZXhpc3RpbmcgYXVkaW8gdHJhY2tzIGFuZCBhZGQgdGhlIG9uZXMgd2UganVzdCBjcmVhdGVkXG4gIHRlY2guY2xlYXJUcmFja3MoJ2F1ZGlvJyk7XG5cbiAgZm9yICh2YXIgaWQgaW4gbWVkaWFUeXBlcy5BVURJTy50cmFja3MpIHtcbiAgICB0ZWNoLmF1ZGlvVHJhY2tzKCkuYWRkVHJhY2sobWVkaWFUeXBlcy5BVURJTy50cmFja3NbaWRdKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIHNrZWxldG9uIG9iamVjdCB1c2VkIHRvIHN0b3JlIHRoZSBsb2FkZXJzLCB0cmFja3MsIGFuZCB1dGlsaXR5IG1ldGhvZHMgZm9yIGVhY2hcbiAqIG1lZGlhIHR5cGVcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIE9iamVjdCB0byBzdG9yZSB0aGUgbG9hZGVycywgdHJhY2tzLCBhbmQgdXRpbGl0eSBtZXRob2RzIGZvciBlYWNoIG1lZGlhIHR5cGVcbiAqIEBmdW5jdGlvbiBjcmVhdGVNZWRpYVR5cGVzXG4gKi9cbnZhciBjcmVhdGVNZWRpYVR5cGVzID0gZnVuY3Rpb24gY3JlYXRlTWVkaWFUeXBlcygpIHtcbiAgdmFyIG1lZGlhVHlwZXMgPSB7fTtcblxuICBbJ0FVRElPJywgJ1NVQlRJVExFUycsICdDTE9TRUQtQ0FQVElPTlMnXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgbWVkaWFUeXBlc1t0eXBlXSA9IHtcbiAgICAgIGdyb3Vwczoge30sXG4gICAgICB0cmFja3M6IHt9LFxuICAgICAgYWN0aXZlUGxheWxpc3RMb2FkZXI6IG51bGwsXG4gICAgICBhY3RpdmVHcm91cDogbm9vcCxcbiAgICAgIGFjdGl2ZVRyYWNrOiBub29wLFxuICAgICAgb25Hcm91cENoYW5nZWQ6IG5vb3AsXG4gICAgICBvblRyYWNrQ2hhbmdlZDogbm9vcFxuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBtZWRpYVR5cGVzO1xufTtcblxuLyoqXG4gKiBAZmlsZSBtYXN0ZXItcGxheWxpc3QtY29udHJvbGxlci5qc1xuICovXG5cbnZhciBBQk9SVF9FQVJMWV9CTEFDS0xJU1RfU0VDT05EUyA9IDYwICogMjtcblxudmFyIEhscyA9IHZvaWQgMDtcblxuLy8gU2VnbWVudExvYWRlciBzdGF0cyB0aGF0IG5lZWQgdG8gaGF2ZSBlYWNoIGxvYWRlcidzXG4vLyB2YWx1ZXMgc3VtbWVkIHRvIGNhbGN1bGF0ZSB0aGUgZmluYWwgdmFsdWVcbnZhciBsb2FkZXJTdGF0cyA9IFsnbWVkaWFSZXF1ZXN0cycsICdtZWRpYVJlcXVlc3RzQWJvcnRlZCcsICdtZWRpYVJlcXVlc3RzVGltZWRvdXQnLCAnbWVkaWFSZXF1ZXN0c0Vycm9yZWQnLCAnbWVkaWFUcmFuc2ZlckR1cmF0aW9uJywgJ21lZGlhQnl0ZXNUcmFuc2ZlcnJlZCddO1xudmFyIHN1bUxvYWRlclN0YXQgPSBmdW5jdGlvbiBzdW1Mb2FkZXJTdGF0KHN0YXQpIHtcbiAgcmV0dXJuIHRoaXMuYXVkaW9TZWdtZW50TG9hZGVyX1tzdGF0XSArIHRoaXMubWFpblNlZ21lbnRMb2FkZXJfW3N0YXRdO1xufTtcblxuLyoqXG4gKiB0aGUgbWFzdGVyIHBsYXlsaXN0IGNvbnRyb2xsZXIgY29udHJvbGxlciBhbGwgaW50ZXJhY3RvbnNcbiAqIGJldHdlZW4gcGxheWxpc3RzIGFuZCBzZWdtZW50bG9hZGVycy4gQXQgdGhpcyB0aW1lIHRoaXMgbWFpbmx5XG4gKiBpbnZvbHZlcyBhIG1hc3RlciBwbGF5bGlzdCBhbmQgYSBzZXJpZXMgb2YgYXVkaW8gcGxheWxpc3RzXG4gKiBpZiB0aGV5IGFyZSBhdmFpbGFibGVcbiAqXG4gKiBAY2xhc3MgTWFzdGVyUGxheWxpc3RDb250cm9sbGVyXG4gKiBAZXh0ZW5kcyB2aWRlb2pzLkV2ZW50VGFyZ2V0XG4gKi9cbnZhciBNYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX3ZpZGVvanMkRXZlbnRUYXJnZXQpIHtcbiAgaW5oZXJpdHMkMShNYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXIsIF92aWRlb2pzJEV2ZW50VGFyZ2V0KTtcblxuICBmdW5jdGlvbiBNYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXIob3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrJDEodGhpcywgTWFzdGVyUGxheWxpc3RDb250cm9sbGVyKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4kMSh0aGlzLCAoTWFzdGVyUGxheWxpc3RDb250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFzdGVyUGxheWxpc3RDb250cm9sbGVyKSkuY2FsbCh0aGlzKSk7XG5cbiAgICB2YXIgdXJsID0gb3B0aW9ucy51cmwsXG4gICAgICAgIHdpdGhDcmVkZW50aWFscyA9IG9wdGlvbnMud2l0aENyZWRlbnRpYWxzLFxuICAgICAgICB0ZWNoID0gb3B0aW9ucy50ZWNoLFxuICAgICAgICBiYW5kd2lkdGggPSBvcHRpb25zLmJhbmR3aWR0aCxcbiAgICAgICAgZXh0ZXJuSGxzID0gb3B0aW9ucy5leHRlcm5IbHMsXG4gICAgICAgIHVzZUN1ZVRhZ3MgPSBvcHRpb25zLnVzZUN1ZVRhZ3MsXG4gICAgICAgIGJsYWNrbGlzdER1cmF0aW9uID0gb3B0aW9ucy5ibGFja2xpc3REdXJhdGlvbixcbiAgICAgICAgZW5hYmxlTG93SW5pdGlhbFBsYXlsaXN0ID0gb3B0aW9ucy5lbmFibGVMb3dJbml0aWFsUGxheWxpc3QsXG4gICAgICAgIHNvdXJjZVR5cGUgPSBvcHRpb25zLnNvdXJjZVR5cGU7XG5cbiAgICBpZiAoIXVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIG5vbi1lbXB0eSBwbGF5bGlzdCBVUkwgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBIbHMgPSBleHRlcm5IbHM7XG5cbiAgICBfdGhpcy53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHM7XG4gICAgX3RoaXMudGVjaF8gPSB0ZWNoO1xuICAgIF90aGlzLmhsc18gPSB0ZWNoLmhscztcbiAgICBfdGhpcy5zb3VyY2VUeXBlXyA9IHNvdXJjZVR5cGU7XG4gICAgX3RoaXMudXNlQ3VlVGFnc18gPSB1c2VDdWVUYWdzO1xuICAgIF90aGlzLmJsYWNrbGlzdER1cmF0aW9uID0gYmxhY2tsaXN0RHVyYXRpb247XG4gICAgX3RoaXMuZW5hYmxlTG93SW5pdGlhbFBsYXlsaXN0ID0gZW5hYmxlTG93SW5pdGlhbFBsYXlsaXN0O1xuICAgIGlmIChfdGhpcy51c2VDdWVUYWdzXykge1xuICAgICAgX3RoaXMuY3VlVGFnc1RyYWNrXyA9IF90aGlzLnRlY2hfLmFkZFRleHRUcmFjaygnbWV0YWRhdGEnLCAnYWQtY3VlcycpO1xuICAgICAgX3RoaXMuY3VlVGFnc1RyYWNrXy5pbkJhbmRNZXRhZGF0YVRyYWNrRGlzcGF0Y2hUeXBlID0gJyc7XG4gICAgfVxuXG4gICAgX3RoaXMucmVxdWVzdE9wdGlvbnNfID0ge1xuICAgICAgd2l0aENyZWRlbnRpYWxzOiBfdGhpcy53aXRoQ3JlZGVudGlhbHMsXG4gICAgICB0aW1lb3V0OiBudWxsXG4gICAgfTtcblxuICAgIF90aGlzLm1lZGlhVHlwZXNfID0gY3JlYXRlTWVkaWFUeXBlcygpO1xuXG4gICAgX3RoaXMubWVkaWFTb3VyY2UgPSBuZXcgdmlkZW9qcyQxLk1lZGlhU291cmNlKCk7XG5cbiAgICAvLyBsb2FkIHRoZSBtZWRpYSBzb3VyY2UgaW50byB0aGUgcGxheWVyXG4gICAgX3RoaXMubWVkaWFTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIF90aGlzLmhhbmRsZVNvdXJjZU9wZW5fLmJpbmQoX3RoaXMpKTtcblxuICAgIF90aGlzLnNlZWthYmxlXyA9IHZpZGVvanMkMS5jcmVhdGVUaW1lUmFuZ2VzKCk7XG4gICAgX3RoaXMuaGFzUGxheWVkXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX3RoaXMuc3luY0NvbnRyb2xsZXJfID0gbmV3IFN5bmNDb250cm9sbGVyKG9wdGlvbnMpO1xuICAgIF90aGlzLnNlZ21lbnRNZXRhZGF0YVRyYWNrXyA9IHRlY2guYWRkUmVtb3RlVGV4dFRyYWNrKHtcbiAgICAgIGtpbmQ6ICdtZXRhZGF0YScsXG4gICAgICBsYWJlbDogJ3NlZ21lbnQtbWV0YWRhdGEnXG4gICAgfSwgZmFsc2UpLnRyYWNrO1xuXG4gICAgX3RoaXMuZGVjcnlwdGVyXyA9IG5ldyBEZWNyeXB0ZXIkMSgpO1xuXG4gICAgdmFyIHNlZ21lbnRMb2FkZXJTZXR0aW5ncyA9IHtcbiAgICAgIGhsczogX3RoaXMuaGxzXyxcbiAgICAgIG1lZGlhU291cmNlOiBfdGhpcy5tZWRpYVNvdXJjZSxcbiAgICAgIGN1cnJlbnRUaW1lOiBfdGhpcy50ZWNoXy5jdXJyZW50VGltZS5iaW5kKF90aGlzLnRlY2hfKSxcbiAgICAgIHNlZWthYmxlOiBmdW5jdGlvbiBzZWVrYWJsZSQkMSgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnNlZWthYmxlKCk7XG4gICAgICB9LFxuICAgICAgc2Vla2luZzogZnVuY3Rpb24gc2Vla2luZygpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnRlY2hfLnNlZWtpbmcoKTtcbiAgICAgIH0sXG4gICAgICBkdXJhdGlvbjogZnVuY3Rpb24gZHVyYXRpb24kJDEoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbjtcbiAgICAgIH0sXG4gICAgICBoYXNQbGF5ZWQ6IGZ1bmN0aW9uIGhhc1BsYXllZCgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhc1BsYXllZF8oKTtcbiAgICAgIH0sXG4gICAgICBnb2FsQnVmZmVyTGVuZ3RoOiBmdW5jdGlvbiBnb2FsQnVmZmVyTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuZ29hbEJ1ZmZlckxlbmd0aCgpO1xuICAgICAgfSxcbiAgICAgIGJhbmR3aWR0aDogYmFuZHdpZHRoLFxuICAgICAgc3luY0NvbnRyb2xsZXI6IF90aGlzLnN5bmNDb250cm9sbGVyXyxcbiAgICAgIGRlY3J5cHRlcjogX3RoaXMuZGVjcnlwdGVyXyxcbiAgICAgIHNvdXJjZVR5cGU6IF90aGlzLnNvdXJjZVR5cGVfXG4gICAgfTtcblxuICAgIF90aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXyA9IF90aGlzLnNvdXJjZVR5cGVfID09PSAnZGFzaCcgPyBuZXcgRGFzaFBsYXlsaXN0TG9hZGVyKHVybCwgX3RoaXMuaGxzXywgX3RoaXMud2l0aENyZWRlbnRpYWxzKSA6IG5ldyBQbGF5bGlzdExvYWRlcih1cmwsIF90aGlzLmhsc18sIF90aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgX3RoaXMuc2V0dXBNYXN0ZXJQbGF5bGlzdExvYWRlckxpc3RlbmVyc18oKTtcblxuICAgIC8vIHNldHVwIHNlZ21lbnQgbG9hZGVyc1xuICAgIC8vIGNvbWJpbmVkIGF1ZGlvL3ZpZGVvIG9yIGp1c3QgdmlkZW8gd2hlbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2sgaXMgc2VsZWN0ZWRcbiAgICBfdGhpcy5tYWluU2VnbWVudExvYWRlcl8gPSBuZXcgU2VnbWVudExvYWRlcih2aWRlb2pzJDEubWVyZ2VPcHRpb25zKHNlZ21lbnRMb2FkZXJTZXR0aW5ncywge1xuICAgICAgc2VnbWVudE1ldGFkYXRhVHJhY2s6IF90aGlzLnNlZ21lbnRNZXRhZGF0YVRyYWNrXyxcbiAgICAgIGxvYWRlclR5cGU6ICdtYWluJ1xuICAgIH0pLCBvcHRpb25zKTtcblxuICAgIC8vIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgIF90aGlzLmF1ZGlvU2VnbWVudExvYWRlcl8gPSBuZXcgU2VnbWVudExvYWRlcih2aWRlb2pzJDEubWVyZ2VPcHRpb25zKHNlZ21lbnRMb2FkZXJTZXR0aW5ncywge1xuICAgICAgbG9hZGVyVHlwZTogJ2F1ZGlvJ1xuICAgIH0pLCBvcHRpb25zKTtcblxuICAgIF90aGlzLnN1YnRpdGxlU2VnbWVudExvYWRlcl8gPSBuZXcgVlRUU2VnbWVudExvYWRlcih2aWRlb2pzJDEubWVyZ2VPcHRpb25zKHNlZ21lbnRMb2FkZXJTZXR0aW5ncywge1xuICAgICAgbG9hZGVyVHlwZTogJ3Z0dCdcbiAgICB9KSwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5zZXR1cFNlZ21lbnRMb2FkZXJMaXN0ZW5lcnNfKCk7XG5cbiAgICAvLyBDcmVhdGUgU2VnbWVudExvYWRlciBzdGF0LWdldHRlcnNcbiAgICBsb2FkZXJTdGF0cy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0KSB7XG4gICAgICBfdGhpc1tzdGF0ICsgJ18nXSA9IHN1bUxvYWRlclN0YXQuYmluZChfdGhpcywgc3RhdCk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5sb2dnZXJfID0gbG9nZ2VyKCdNUEMnKTtcblxuICAgIF90aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5sb2FkKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzIG9uIHRoZSBtYXN0ZXIgcGxheWxpc3QgbG9hZGVyLiBBIGhlbHBlclxuICAgKiBmdW5jdGlvbiBmb3IgY29uc3RydWN0aW9uIHRpbWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIGNyZWF0ZUNsYXNzJDEoTWFzdGVyUGxheWxpc3RDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ3NldHVwTWFzdGVyUGxheWxpc3RMb2FkZXJMaXN0ZW5lcnNfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBNYXN0ZXJQbGF5bGlzdExvYWRlckxpc3RlbmVyc18oKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ub24oJ2xvYWRlZG1ldGFkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVkaWEgPSBfdGhpczIubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1lZGlhKCk7XG4gICAgICAgIHZhciByZXF1ZXN0VGltZW91dCA9IF90aGlzMi5tYXN0ZXJQbGF5bGlzdExvYWRlcl8udGFyZ2V0RHVyYXRpb24gKiAxLjUgKiAxMDAwO1xuXG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgYXZhaWxhYmxlIHBsYXlsaXN0cywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyB0aW1lb3V0IHRoZSByZXF1ZXN0LlxuICAgICAgICBpZiAoaXNMb3dlc3RFbmFibGVkUmVuZGl0aW9uKF90aGlzMi5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWFzdGVyLCBfdGhpczIubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1lZGlhKCkpKSB7XG4gICAgICAgICAgX3RoaXMyLnJlcXVlc3RPcHRpb25zXy50aW1lb3V0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIucmVxdWVzdE9wdGlvbnNfLnRpbWVvdXQgPSByZXF1ZXN0VGltZW91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoaXMgaXNuJ3QgYSBsaXZlIHZpZGVvIGFuZCBwcmVsb2FkIHBlcm1pdHMsIHN0YXJ0XG4gICAgICAgIC8vIGRvd25sb2FkaW5nIHNlZ21lbnRzXG4gICAgICAgIGlmIChtZWRpYS5lbmRMaXN0ICYmIF90aGlzMi50ZWNoXy5wcmVsb2FkKCkgIT09ICdub25lJykge1xuICAgICAgICAgIF90aGlzMi5tYWluU2VnbWVudExvYWRlcl8ucGxheWxpc3QobWVkaWEsIF90aGlzMi5yZXF1ZXN0T3B0aW9uc18pO1xuICAgICAgICAgIF90aGlzMi5tYWluU2VnbWVudExvYWRlcl8ubG9hZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dXBNZWRpYUdyb3Vwcyh7XG4gICAgICAgICAgc291cmNlVHlwZTogX3RoaXMyLnNvdXJjZVR5cGVfLFxuICAgICAgICAgIHNlZ21lbnRMb2FkZXJzOiB7XG4gICAgICAgICAgICBBVURJTzogX3RoaXMyLmF1ZGlvU2VnbWVudExvYWRlcl8sXG4gICAgICAgICAgICBTVUJUSVRMRVM6IF90aGlzMi5zdWJ0aXRsZVNlZ21lbnRMb2FkZXJfLFxuICAgICAgICAgICAgbWFpbjogX3RoaXMyLm1haW5TZWdtZW50TG9hZGVyX1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGVjaDogX3RoaXMyLnRlY2hfLFxuICAgICAgICAgIHJlcXVlc3RPcHRpb25zOiBfdGhpczIucmVxdWVzdE9wdGlvbnNfLFxuICAgICAgICAgIG1hc3RlclBsYXlsaXN0TG9hZGVyOiBfdGhpczIubWFzdGVyUGxheWxpc3RMb2FkZXJfLFxuICAgICAgICAgIGhsczogX3RoaXMyLmhsc18sXG4gICAgICAgICAgbWFzdGVyOiBfdGhpczIubWFzdGVyKCksXG4gICAgICAgICAgbWVkaWFUeXBlczogX3RoaXMyLm1lZGlhVHlwZXNfLFxuICAgICAgICAgIGJsYWNrbGlzdEN1cnJlbnRQbGF5bGlzdDogX3RoaXMyLmJsYWNrbGlzdEN1cnJlbnRQbGF5bGlzdC5iaW5kKF90aGlzMilcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMyLnRyaWdnZXJQcmVzZW5jZVVzYWdlXyhfdGhpczIubWFzdGVyKCksIG1lZGlhKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIF90aGlzMi5zZXR1cFNvdXJjZUJ1ZmZlcnNfKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB2aWRlb2pzJDEubG9nLndhcm4oJ0ZhaWxlZCB0byBjcmVhdGUgU291cmNlQnVmZmVycycsIGUpO1xuICAgICAgICAgIHJldHVybiBfdGhpczIubWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oJ2RlY29kZScpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzMi5zZXR1cEZpcnN0UGxheSgpO1xuXG4gICAgICAgIF90aGlzMi50cmlnZ2VyKCdzZWxlY3RlZGluaXRpYWxtZWRpYScpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm9uKCdsb2FkZWRwbGF5bGlzdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVwZGF0ZWRQbGF5bGlzdCA9IF90aGlzMi5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKTtcblxuICAgICAgICBpZiAoIXVwZGF0ZWRQbGF5bGlzdCkge1xuICAgICAgICAgIC8vIGJsYWNrbGlzdCBhbnkgdmFyaWFudHMgdGhhdCBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciBiZWZvcmUgc2VsZWN0aW5nXG4gICAgICAgICAgLy8gYW4gaW5pdGlhbCBtZWRpYSBhcyB0aGUgcGxheWxpc3Qgc2VsZWN0b3JzIGRvIG5vdCBjb25zaWRlciBicm93c2VyIHN1cHBvcnRcbiAgICAgICAgICBfdGhpczIuZXhjbHVkZVVuc3VwcG9ydGVkVmFyaWFudHNfKCk7XG5cbiAgICAgICAgICB2YXIgc2VsZWN0ZWRNZWRpYSA9IHZvaWQgMDtcblxuICAgICAgICAgIGlmIChfdGhpczIuZW5hYmxlTG93SW5pdGlhbFBsYXlsaXN0KSB7XG4gICAgICAgICAgICBzZWxlY3RlZE1lZGlhID0gX3RoaXMyLnNlbGVjdEluaXRpYWxQbGF5bGlzdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghc2VsZWN0ZWRNZWRpYSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRNZWRpYSA9IF90aGlzMi5zZWxlY3RQbGF5bGlzdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzMi5pbml0aWFsTWVkaWFfID0gc2VsZWN0ZWRNZWRpYTtcbiAgICAgICAgICBfdGhpczIubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1lZGlhKF90aGlzMi5pbml0aWFsTWVkaWFfKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMyLnVzZUN1ZVRhZ3NfKSB7XG4gICAgICAgICAgX3RoaXMyLnVwZGF0ZUFkQ3Vlc18odXBkYXRlZFBsYXlsaXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IENyZWF0ZSBhIG5ldyBldmVudCBvbiB0aGUgUGxheWxpc3RMb2FkZXIgdGhhdCBzaWduYWxzXG4gICAgICAgIC8vIHRoYXQgdGhlIHNlZ21lbnRzIGhhdmUgY2hhbmdlZCBpbiBzb21lIHdheSBhbmQgdXNlIHRoYXQgdG9cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBTZWdtZW50TG9hZGVyIGluc3RlYWQgb2YgZG9pbmcgaXQgdHdpY2UgaGVyZSBhbmRcbiAgICAgICAgLy8gb24gYG1lZGlhY2hhbmdlYFxuICAgICAgICBfdGhpczIubWFpblNlZ21lbnRMb2FkZXJfLnBsYXlsaXN0KHVwZGF0ZWRQbGF5bGlzdCwgX3RoaXMyLnJlcXVlc3RPcHRpb25zXyk7XG4gICAgICAgIF90aGlzMi51cGRhdGVEdXJhdGlvbigpO1xuXG4gICAgICAgIC8vIElmIHRoZSBwbGF5ZXIgaXNuJ3QgcGF1c2VkLCBlbnN1cmUgdGhhdCB0aGUgc2VnbWVudCBsb2FkZXIgaXMgcnVubmluZyxcbiAgICAgICAgLy8gYXMgaXQgaXMgcG9zc2libGUgdGhhdCBpdCB3YXMgdGVtcG9yYXJpbHkgc3RvcHBlZCB3aGlsZSB3YWl0aW5nIGZvclxuICAgICAgICAvLyBhIHBsYXlsaXN0IChlLmcuLCBpbiBjYXNlIHRoZSBwbGF5bGlzdCBlcnJvcmVkIGFuZCB3ZSByZS1yZXF1ZXN0ZWQgaXQpLlxuICAgICAgICBpZiAoIV90aGlzMi50ZWNoXy5wYXVzZWQoKSkge1xuICAgICAgICAgIF90aGlzMi5tYWluU2VnbWVudExvYWRlcl8ubG9hZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1cGRhdGVkUGxheWxpc3QuZW5kTGlzdCkge1xuICAgICAgICAgIHZhciBhZGRTZWVrYWJsZVJhbmdlID0gZnVuY3Rpb24gYWRkU2Vla2FibGVSYW5nZSgpIHtcbiAgICAgICAgICAgIHZhciBzZWVrYWJsZSQkMSA9IF90aGlzMi5zZWVrYWJsZSgpO1xuXG4gICAgICAgICAgICBpZiAoc2Vla2FibGUkJDEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5tZWRpYVNvdXJjZS5hZGRTZWVrYWJsZVJhbmdlXyhzZWVrYWJsZSQkMS5zdGFydCgwKSwgc2Vla2FibGUkJDEuZW5kKDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKF90aGlzMi5kdXJhdGlvbigpICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgdmFyIG9uRHVyYXRpb25jaGFuZ2UgPSBmdW5jdGlvbiBvbkR1cmF0aW9uY2hhbmdlKCkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMyLmR1cmF0aW9uKCkgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgYWRkU2Vla2FibGVSYW5nZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzMi50ZWNoXy5vbmUoJ2R1cmF0aW9uY2hhbmdlJywgb25EdXJhdGlvbmNoYW5nZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF90aGlzMi50ZWNoXy5vbmUoJ2R1cmF0aW9uY2hhbmdlJywgb25EdXJhdGlvbmNoYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZFNlZWthYmxlUmFuZ2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5vbignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5ibGFja2xpc3RDdXJyZW50UGxheWxpc3QoX3RoaXMyLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5lcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ub24oJ21lZGlhY2hhbmdpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5tYWluU2VnbWVudExvYWRlcl8uYWJvcnQoKTtcbiAgICAgICAgX3RoaXMyLm1haW5TZWdtZW50TG9hZGVyXy5wYXVzZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm9uKCdtZWRpYWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lZGlhID0gX3RoaXMyLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5tZWRpYSgpO1xuICAgICAgICB2YXIgcmVxdWVzdFRpbWVvdXQgPSBfdGhpczIubWFzdGVyUGxheWxpc3RMb2FkZXJfLnRhcmdldER1cmF0aW9uICogMS41ICogMTAwMDtcblxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGF2YWlsYWJsZSBwbGF5bGlzdHMsIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gdGltZW91dCB0aGUgcmVxdWVzdC5cbiAgICAgICAgaWYgKGlzTG93ZXN0RW5hYmxlZFJlbmRpdGlvbihfdGhpczIubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1hc3RlciwgX3RoaXMyLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5tZWRpYSgpKSkge1xuICAgICAgICAgIF90aGlzMi5yZXF1ZXN0T3B0aW9uc18udGltZW91dCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMyLnJlcXVlc3RPcHRpb25zXy50aW1lb3V0ID0gcmVxdWVzdFRpbWVvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBDcmVhdGUgYSBuZXcgZXZlbnQgb24gdGhlIFBsYXlsaXN0TG9hZGVyIHRoYXQgc2lnbmFsc1xuICAgICAgICAvLyB0aGF0IHRoZSBzZWdtZW50cyBoYXZlIGNoYW5nZWQgaW4gc29tZSB3YXkgYW5kIHVzZSB0aGF0IHRvXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgU2VnbWVudExvYWRlciBpbnN0ZWFkIG9mIGRvaW5nIGl0IHR3aWNlIGhlcmUgYW5kXG4gICAgICAgIC8vIG9uIGBsb2FkZWRwbGF5bGlzdGBcbiAgICAgICAgX3RoaXMyLm1haW5TZWdtZW50TG9hZGVyXy5wbGF5bGlzdChtZWRpYSwgX3RoaXMyLnJlcXVlc3RPcHRpb25zXyk7XG4gICAgICAgIF90aGlzMi5tYWluU2VnbWVudExvYWRlcl8ubG9hZCgpO1xuXG4gICAgICAgIF90aGlzMi50ZWNoXy50cmlnZ2VyKHtcbiAgICAgICAgICB0eXBlOiAnbWVkaWFjaGFuZ2UnLFxuICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ub24oJ3BsYXlsaXN0dW5jaGFuZ2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXBkYXRlZFBsYXlsaXN0ID0gX3RoaXMyLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5tZWRpYSgpO1xuICAgICAgICB2YXIgcGxheWxpc3RPdXRkYXRlZCA9IF90aGlzMi5zdHVja0F0UGxheWxpc3RFbmRfKHVwZGF0ZWRQbGF5bGlzdCk7XG5cbiAgICAgICAgaWYgKHBsYXlsaXN0T3V0ZGF0ZWQpIHtcbiAgICAgICAgICAvLyBQbGF5bGlzdCBoYXMgc3RvcHBlZCB1cGRhdGluZyBhbmQgd2UncmUgc3R1Y2sgYXQgaXRzIGVuZC4gVHJ5IHRvXG4gICAgICAgICAgLy8gYmxhY2tsaXN0IGl0IGFuZCBzd2l0Y2ggdG8gYW5vdGhlciBwbGF5bGlzdCBpbiB0aGUgaG9wZSB0aGF0IHRoYXRcbiAgICAgICAgICAvLyBvbmUgaXMgdXBkYXRpbmcgKGFuZCBnaXZlIHRoZSBwbGF5ZXIgYSBjaGFuY2UgdG8gcmUtYWRqdXN0IHRvIHRoZVxuICAgICAgICAgIC8vIHNhZmUgbGl2ZSBwb2ludCkuXG4gICAgICAgICAgX3RoaXMyLmJsYWNrbGlzdEN1cnJlbnRQbGF5bGlzdCh7XG4gICAgICAgICAgICBtZXNzYWdlOiAnUGxheWxpc3Qgbm8gbG9uZ2VyIHVwZGF0aW5nLidcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyB1c2VmdWwgZm9yIG1vbml0b3JpbmcgUW9TXG4gICAgICAgICAgX3RoaXMyLnRlY2hfLnRyaWdnZXIoJ3BsYXlsaXN0c3R1Y2snKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm9uKCdyZW5kaXRpb25kaXNhYmxlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnRlY2hfLnRyaWdnZXIoeyB0eXBlOiAndXNhZ2UnLCBuYW1lOiAnaGxzLXJlbmRpdGlvbi1kaXNhYmxlZCcgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm9uKCdyZW5kaXRpb25lbmFibGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIudGVjaF8udHJpZ2dlcih7IHR5cGU6ICd1c2FnZScsIG5hbWU6ICdobHMtcmVuZGl0aW9uLWVuYWJsZWQnIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgZnVuY3Rpb24gZm9yIHRyaWdnZXJyaW5nIHByZXNlbmNlIHVzYWdlIGV2ZW50cyBvbmNlIHBlciBzb3VyY2VcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RyaWdnZXJQcmVzZW5jZVVzYWdlXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyaWdnZXJQcmVzZW5jZVVzYWdlXyhtYXN0ZXIsIG1lZGlhKSB7XG4gICAgICB2YXIgbWVkaWFHcm91cHMgPSBtYXN0ZXIubWVkaWFHcm91cHMgfHwge307XG4gICAgICB2YXIgZGVmYXVsdERlbXV4ZWQgPSB0cnVlO1xuICAgICAgdmFyIGF1ZGlvR3JvdXBLZXlzID0gT2JqZWN0LmtleXMobWVkaWFHcm91cHMuQVVESU8pO1xuXG4gICAgICBmb3IgKHZhciBtZWRpYUdyb3VwIGluIG1lZGlhR3JvdXBzLkFVRElPKSB7XG4gICAgICAgIGZvciAodmFyIGxhYmVsIGluIG1lZGlhR3JvdXBzLkFVRElPW21lZGlhR3JvdXBdKSB7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBtZWRpYUdyb3Vwcy5BVURJT1ttZWRpYUdyb3VwXVtsYWJlbF07XG5cbiAgICAgICAgICBpZiAoIXByb3BlcnRpZXMudXJpKSB7XG4gICAgICAgICAgICBkZWZhdWx0RGVtdXhlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGVmYXVsdERlbXV4ZWQpIHtcbiAgICAgICAgdGhpcy50ZWNoXy50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy1kZW11eGVkJyB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5rZXlzKG1lZGlhR3JvdXBzLlNVQlRJVExFUykubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudGVjaF8udHJpZ2dlcih7IHR5cGU6ICd1c2FnZScsIG5hbWU6ICdobHMtd2VidnR0JyB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKEhscy5QbGF5bGlzdC5pc0FlcyhtZWRpYSkpIHtcbiAgICAgICAgdGhpcy50ZWNoXy50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy1hZXMnIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoSGxzLlBsYXlsaXN0LmlzRm1wNChtZWRpYSkpIHtcbiAgICAgICAgdGhpcy50ZWNoXy50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy1mbXA0JyB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF1ZGlvR3JvdXBLZXlzLmxlbmd0aCAmJiBPYmplY3Qua2V5cyhtZWRpYUdyb3Vwcy5BVURJT1thdWRpb0dyb3VwS2V5c1swXV0pLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy50ZWNoXy50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy1hbHRlcm5hdGUtYXVkaW8nIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy51c2VDdWVUYWdzXykge1xuICAgICAgICB0aGlzLnRlY2hfLnRyaWdnZXIoeyB0eXBlOiAndXNhZ2UnLCBuYW1lOiAnaGxzLXBsYXlsaXN0LWN1ZS10YWdzJyB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnMgb24gdGhlIHNlZ21lbnQgbG9hZGVycy4gQSBoZWxwZXIgZnVuY3Rpb25cbiAgICAgKiBmb3IgY29uc3RydWN0aW9uIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXR1cFNlZ21lbnRMb2FkZXJMaXN0ZW5lcnNfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBTZWdtZW50TG9hZGVyTGlzdGVuZXJzXygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5vbignYmFuZHdpZHRodXBkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFBsYXlsaXN0ID0gX3RoaXMzLnNlbGVjdFBsYXlsaXN0KCk7XG4gICAgICAgIHZhciBjdXJyZW50UGxheWxpc3QgPSBfdGhpczMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1lZGlhKCk7XG4gICAgICAgIHZhciBidWZmZXJlZCA9IF90aGlzMy50ZWNoXy5idWZmZXJlZCgpO1xuICAgICAgICB2YXIgZm9yd2FyZEJ1ZmZlciA9IGJ1ZmZlcmVkLmxlbmd0aCA/IGJ1ZmZlcmVkLmVuZChidWZmZXJlZC5sZW5ndGggLSAxKSAtIF90aGlzMy50ZWNoXy5jdXJyZW50VGltZSgpIDogMDtcblxuICAgICAgICB2YXIgYnVmZmVyTG93V2F0ZXJMaW5lID0gX3RoaXMzLmJ1ZmZlckxvd1dhdGVyTGluZSgpO1xuXG4gICAgICAgIC8vIElmIHRoZSBwbGF5bGlzdCBpcyBsaXZlLCB0aGVuIHdlIHdhbnQgdG8gbm90IHRha2UgbG93IHdhdGVyIGxpbmUgaW50byBhY2NvdW50LlxuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgaW4gTElWRSwgdGhlIHBsYXllciBwbGF5cyAzIHNlZ21lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgLy8gcGxheWxpc3QsIGFuZCBpZiBgQlVGRkVSX0xPV19XQVRFUl9MSU5FYCBpcyBncmVhdGVyIHRoYW4gdGhlIGR1cmF0aW9uIGF2YWlsYmxlXG4gICAgICAgIC8vIGluIHRob3NlIHNlZ21lbnRzLCBhIHZpZXdlciB3aWxsIG5ldmVyIGV4cGVyaWVuY2UgYSByZW5kaXRpb24gdXBzd2l0Y2guXG4gICAgICAgIGlmICghY3VycmVudFBsYXlsaXN0LmVuZExpc3QgfHxcbiAgICAgICAgLy8gRm9yIHRoZSBzYW1lIHJlYXNvbiBhcyBMSVZFLCB3ZSBpZ25vcmUgdGhlIGxvdyB3YXRlciBsaW5lIHdoZW4gdGhlIFZPRFxuICAgICAgICAvLyBkdXJhdGlvbiBpcyBiZWxvdyB0aGUgbWF4IHBvdGVudGlhbCBsb3cgd2F0ZXIgbGluZVxuICAgICAgICBfdGhpczMuZHVyYXRpb24oKSA8IENvbmZpZy5NQVhfQlVGRkVSX0xPV19XQVRFUl9MSU5FIHx8XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gc3dpdGNoIGRvd24gdG8gbG93ZXIgcmVzb2x1dGlvbnMgcXVpY2tseSB0byBjb250aW51ZSBwbGF5YmFjaywgYnV0XG4gICAgICAgIG5leHRQbGF5bGlzdC5hdHRyaWJ1dGVzLkJBTkRXSURUSCA8IGN1cnJlbnRQbGF5bGlzdC5hdHRyaWJ1dGVzLkJBTkRXSURUSCB8fFxuICAgICAgICAvLyBlbnN1cmUgd2UgaGF2ZSBzb21lIGJ1ZmZlciBiZWZvcmUgd2Ugc3dpdGNoIHVwIHRvIHByZXZlbnQgdXMgcnVubmluZyBvdXQgb2ZcbiAgICAgICAgLy8gYnVmZmVyIHdoaWxlIGxvYWRpbmcgYSBoaWdoZXIgcmVuZGl0aW9uLlxuICAgICAgICBmb3J3YXJkQnVmZmVyID49IGJ1ZmZlckxvd1dhdGVyTGluZSkge1xuICAgICAgICAgIF90aGlzMy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEobmV4dFBsYXlsaXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMy50ZWNoXy50cmlnZ2VyKCdiYW5kd2lkdGh1cGRhdGUnKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tYWluU2VnbWVudExvYWRlcl8ub24oJ3Byb2dyZXNzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMudHJpZ2dlcigncHJvZ3Jlc3MnKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5vbignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5ibGFja2xpc3RDdXJyZW50UGxheWxpc3QoX3RoaXMzLm1haW5TZWdtZW50TG9hZGVyXy5lcnJvcigpKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5vbignc3luY2luZm91cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5vblN5bmNJbmZvVXBkYXRlXygpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubWFpblNlZ21lbnRMb2FkZXJfLm9uKCd0aW1lc3RhbXBvZmZzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy50ZWNoXy50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy10aW1lc3RhbXAtb2Zmc2V0JyB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hdWRpb1NlZ21lbnRMb2FkZXJfLm9uKCdzeW5jaW5mb3VwZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLm9uU3luY0luZm9VcGRhdGVfKCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5tYWluU2VnbWVudExvYWRlcl8ub24oJ2VuZGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMub25FbmRPZlN0cmVhbSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubWFpblNlZ21lbnRMb2FkZXJfLm9uKCdlYXJseWFib3J0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuYmxhY2tsaXN0Q3VycmVudFBsYXlsaXN0KHtcbiAgICAgICAgICBtZXNzYWdlOiAnQWJvcnRlZCBlYXJseSBiZWNhdXNlIHRoZXJlIGlzblxcJ3QgZW5vdWdoIGJhbmR3aWR0aCB0byBjb21wbGV0ZSB0aGUgJyArICdyZXF1ZXN0IHdpdGhvdXQgcmVidWZmZXJpbmcuJ1xuICAgICAgICB9LCBBQk9SVF9FQVJMWV9CTEFDS0xJU1RfU0VDT05EUyk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5tYWluU2VnbWVudExvYWRlcl8ub24oJ3Jlc2V0ZXZlcnl0aGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSWYgcGxheWluZyBhbiBNVFMgc3RyZWFtLCBhIHZpZGVvanMuTWVkaWFTb3VyY2UgaXMgbGlzdGVuaW5nIGZvclxuICAgICAgICAvLyBobHMtcmVzZXQgdG8gcmVzZXQgY2FwdGlvbiBwYXJzaW5nIHN0YXRlIGluIHRoZSB0cmFuc211eGVyXG4gICAgICAgIF90aGlzMy50ZWNoXy50cmlnZ2VyKCdobHMtcmVzZXQnKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5vbignc2VnbWVudHRpbWVtYXBwaW5nJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIElmIHBsYXlpbmcgYW4gTVRTIHN0cmVhbSBpbiBodG1sLCBhIHZpZGVvanMuTWVkaWFTb3VyY2UgaXMgbGlzdGVuaW5nIGZvclxuICAgICAgICAvLyBobHMtc2VnbWVudC10aW1lLW1hcHBpbmcgdXBkYXRlIGl0cyBpbnRlcm5hbCBtYXBwaW5nIG9mIHN0cmVhbSB0byBkaXNwbGF5IHRpbWVcbiAgICAgICAgX3RoaXMzLnRlY2hfLnRyaWdnZXIoe1xuICAgICAgICAgIHR5cGU6ICdobHMtc2VnbWVudC10aW1lLW1hcHBpbmcnLFxuICAgICAgICAgIG1hcHBpbmc6IGV2ZW50Lm1hcHBpbmdcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5hdWRpb1NlZ21lbnRMb2FkZXJfLm9uKCdlbmRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLm9uRW5kT2ZTdHJlYW0oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21lZGlhU2Vjb25kc0xvYWRlZF8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZWRpYVNlY29uZHNMb2FkZWRfKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuYXVkaW9TZWdtZW50TG9hZGVyXy5tZWRpYVNlY29uZHNMb2FkZWQgKyB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5tZWRpYVNlY29uZHNMb2FkZWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgbG9hZCBvbiBvdXIgU2VnbWVudExvYWRlcnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbG9hZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5sb2FkKCk7XG4gICAgICBpZiAodGhpcy5tZWRpYVR5cGVzXy5BVURJTy5hY3RpdmVQbGF5bGlzdExvYWRlcikge1xuICAgICAgICB0aGlzLmF1ZGlvU2VnbWVudExvYWRlcl8ubG9hZCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWVkaWFUeXBlc18uU1VCVElUTEVTLmFjdGl2ZVBsYXlsaXN0TG9hZGVyKSB7XG4gICAgICAgIHRoaXMuc3VidGl0bGVTZWdtZW50TG9hZGVyXy5sb2FkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmUtdHVuZSBwbGF5YmFjayBxdWFsaXR5IGxldmVsIGZvciB0aGUgY3VycmVudCBwbGF5ZXJcbiAgICAgKiBjb25kaXRpb25zLiBUaGlzIG1ldGhvZCBtYXkgcGVyZm9ybSBkZXN0cnVjdGl2ZSBhY3Rpb25zLCBsaWtlXG4gICAgICogcmVtb3ZpbmcgYWxyZWFkeSBidWZmZXJlZCBjb250ZW50LCB0byByZWFkanVzdCB0aGUgY3VycmVudGx5XG4gICAgICogYWN0aXZlIHBsYXlsaXN0IHF1aWNrbHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmYXN0UXVhbGl0eUNoYW5nZV8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYXN0UXVhbGl0eUNoYW5nZV8oKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLnNlbGVjdFBsYXlsaXN0KCk7XG5cbiAgICAgIGlmIChtZWRpYSAhPT0gdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKSkge1xuICAgICAgICB0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5tZWRpYShtZWRpYSk7XG5cbiAgICAgICAgdGhpcy5tYWluU2VnbWVudExvYWRlcl8ucmVzZXRMb2FkZXIoKTtcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byByZXNldCBhdWRpbyBhcyBpdCBpcyByZXNldCB3aGVuIG1lZGlhIGNoYW5nZXNcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCZWdpbiBwbGF5YmFjay5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICBpZiAodGhpcy5zZXR1cEZpcnN0UGxheSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudGVjaF8uZW5kZWQoKSkge1xuICAgICAgICB0aGlzLnRlY2hfLnNldEN1cnJlbnRUaW1lKDApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYXNQbGF5ZWRfKCkpIHtcbiAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWVrYWJsZSQkMSA9IHRoaXMudGVjaF8uc2Vla2FibGUoKTtcblxuICAgICAgLy8gaWYgdGhlIHZpZXdlciBoYXMgcGF1c2VkIGFuZCB3ZSBmZWxsIG91dCBvZiB0aGUgbGl2ZSB3aW5kb3csXG4gICAgICAvLyBzZWVrIGZvcndhcmQgdG8gdGhlIGxpdmUgcG9pbnRcbiAgICAgIGlmICh0aGlzLnRlY2hfLmR1cmF0aW9uKCkgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGlmICh0aGlzLnRlY2hfLmN1cnJlbnRUaW1lKCkgPCBzZWVrYWJsZSQkMS5zdGFydCgwKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRlY2hfLnNldEN1cnJlbnRUaW1lKHNlZWthYmxlJCQxLmVuZChzZWVrYWJsZSQkMS5sZW5ndGggLSAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWVrIHRvIHRoZSBsYXRlc3QgbWVkaWEgcG9zaXRpb24gaWYgdGhpcyBpcyBhIGxpdmUgdmlkZW8gYW5kIHRoZVxuICAgICAqIHBsYXllciBhbmQgdmlkZW8gYXJlIGxvYWRlZCBhbmQgaW5pdGlhbGl6ZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldHVwRmlyc3RQbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBGaXJzdFBsYXkoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKTtcblxuICAgICAgLy8gQ2hlY2sgdGhhdCBldmVyeXRoaW5nIGlzIHJlYWR5IHRvIGJlZ2luIGJ1ZmZlcmluZyBmb3IgdGhlIGZpcnN0IGNhbGwgdG8gcGxheVxuICAgICAgLy8gIElmIDEpIHRoZXJlIGlzIG5vIGFjdGl2ZSBtZWRpYVxuICAgICAgLy8gICAgIDIpIHRoZSBwbGF5ZXIgaXMgcGF1c2VkXG4gICAgICAvLyAgICAgMykgdGhlIGZpcnN0IHBsYXkgaGFzIGFscmVhZHkgYmVlbiBzZXR1cFxuICAgICAgLy8gdGhlbiBleGl0IGVhcmx5XG4gICAgICBpZiAoIW1lZGlhIHx8IHRoaXMudGVjaF8ucGF1c2VkKCkgfHwgdGhpcy5oYXNQbGF5ZWRfKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyB3aGVuIHRoZSB2aWRlbyBpcyBhIGxpdmUgc3RyZWFtXG4gICAgICBpZiAoIW1lZGlhLmVuZExpc3QpIHtcbiAgICAgICAgdmFyIHNlZWthYmxlJCQxID0gdGhpcy5zZWVrYWJsZSgpO1xuXG4gICAgICAgIGlmICghc2Vla2FibGUkJDEubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gd2l0aG91dCBhIHNlZWthYmxlIHJhbmdlLCB0aGUgcGxheWVyIGNhbm5vdCBzZWVrIHRvIGJlZ2luIGJ1ZmZlcmluZyBhdCB0aGUgbGl2ZVxuICAgICAgICAgIC8vIHBvaW50XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZpZGVvanMkMS5icm93c2VyLklFX1ZFUlNJT04gJiYgdGhpcy50ZWNoXy5yZWFkeVN0YXRlKCkgPT09IDApIHtcbiAgICAgICAgICAvLyBJRTExIHRocm93cyBhbiBJbnZhbGlkU3RhdGVFcnJvciBpZiB5b3UgdHJ5IHRvIHNldCBjdXJyZW50VGltZSB3aGlsZSB0aGVcbiAgICAgICAgICAvLyByZWFkeVN0YXRlIGlzIDAsIHNvIGl0IG11c3QgYmUgZGVsYXllZCB1bnRpbCB0aGUgdGVjaCBmaXJlcyBsb2FkZWRtZXRhZGF0YS5cbiAgICAgICAgICB0aGlzLnRlY2hfLm9uZSgnbG9hZGVkbWV0YWRhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczQudHJpZ2dlcignZmlyc3RwbGF5Jyk7XG4gICAgICAgICAgICBfdGhpczQudGVjaF8uc2V0Q3VycmVudFRpbWUoc2Vla2FibGUkJDEuZW5kKDApKTtcbiAgICAgICAgICAgIF90aGlzNC5oYXNQbGF5ZWRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIGZpcnN0cGxheSB0byBpbmZvcm0gdGhlIHNvdXJjZSBoYW5kbGVyIHRvIGlnbm9yZSB0aGUgbmV4dCBzZWVrIGV2ZW50XG4gICAgICAgIHRoaXMudHJpZ2dlcignZmlyc3RwbGF5Jyk7XG4gICAgICAgIC8vIHNlZWsgdG8gdGhlIGxpdmUgcG9pbnRcbiAgICAgICAgdGhpcy50ZWNoXy5zZXRDdXJyZW50VGltZShzZWVrYWJsZSQkMS5lbmQoMCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhhc1BsYXllZF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIC8vIHdlIGNhbiBiZWdpbiBsb2FkaW5nIG5vdyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVhZHlcbiAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIHRoZSBzb3VyY2VvcGVuIGV2ZW50IG9uIHRoZSBNZWRpYVNvdXJjZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlU291cmNlT3Blbl8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVTb3VyY2VPcGVuXygpIHtcbiAgICAgIC8vIE9ubHkgYXR0ZW1wdCB0byBjcmVhdGUgdGhlIHNvdXJjZSBidWZmZXIgaWYgbm9uZSBhbHJlYWR5IGV4aXN0LlxuICAgICAgLy8gaGFuZGxlU291cmNlT3BlbiBpcyBhbHNvIGNhbGxlZCB3aGVuIHdlIGFyZSBcInJlLW9wZW5pbmdcIiBhIHNvdXJjZSBidWZmZXJcbiAgICAgIC8vIGFmdGVyIGBlbmRPZlN0cmVhbWAgaGFzIGJlZW4gY2FsbGVkIChpbiByZXNwb25zZSB0byBhIHNlZWsgZm9yIGluc3RhbmNlKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZXR1cFNvdXJjZUJ1ZmZlcnNfKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHZpZGVvanMkMS5sb2cud2FybignRmFpbGVkIHRvIGNyZWF0ZSBTb3VyY2UgQnVmZmVycycsIGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgnZGVjb2RlJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGF1dG9wbGF5IGlzIGVuYWJsZWQsIGJlZ2luIHBsYXliYWNrLiBUaGlzIGlzIGR1cGxpY2F0aXZlIG9mXG4gICAgICAvLyBjb2RlIGluIHZpZGVvLmpzIGJ1dCBpcyByZXF1aXJlZCBiZWNhdXNlIHBsYXkoKSBtdXN0IGJlIGludm9rZWRcbiAgICAgIC8vICphZnRlciogdGhlIG1lZGlhIHNvdXJjZSBoYXMgb3BlbmVkLlxuICAgICAgaWYgKHRoaXMudGVjaF8uYXV0b3BsYXkoKSkge1xuICAgICAgICB2YXIgcGxheVByb21pc2UgPSB0aGlzLnRlY2hfLnBsYXkoKTtcblxuICAgICAgICAvLyBDYXRjaC9zaWxlbmNlIGVycm9yIHdoZW4gYSBwYXVzZSBpbnRlcnJ1cHRzIGEgcGxheSByZXF1ZXN0XG4gICAgICAgIC8vIG9uIGJyb3dzZXJzIHdoaWNoIHJldHVybiBhIHByb21pc2VcbiAgICAgICAgaWYgKHR5cGVvZiBwbGF5UHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBsYXlQcm9taXNlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBwbGF5UHJvbWlzZS50aGVuKG51bGwsIGZ1bmN0aW9uIChlKSB7fSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50cmlnZ2VyKCdzb3VyY2VvcGVuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgZW5kT2ZTdHJlYW0gb24gdGhlIG1lZGlhIHNvdXJjZSB3aGVuIGFsbCBhY3RpdmUgc3RyZWFtIHR5cGVzIGhhdmUgY2FsbGVkXG4gICAgICogZW5kT2ZTdHJlYW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJlYW1UeXBlXG4gICAgICogICAgICAgIFN0cmVhbSB0eXBlIG9mIHRoZSBzZWdtZW50IGxvYWRlciB0aGF0IGNhbGxlZCBlbmRPZlN0cmVhbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uRW5kT2ZTdHJlYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVuZE9mU3RyZWFtKCkge1xuICAgICAgdmFyIGlzRW5kT2ZTdHJlYW0gPSB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5lbmRlZF87XG5cbiAgICAgIGlmICh0aGlzLm1lZGlhVHlwZXNfLkFVRElPLmFjdGl2ZVBsYXlsaXN0TG9hZGVyKSB7XG4gICAgICAgIC8vIGlmIHRoZSBhdWRpbyBwbGF5bGlzdCBsb2FkZXIgZXhpc3RzLCB0aGVuIGFsdGVybmF0ZSBhdWRpbyBpcyBhY3RpdmVcbiAgICAgICAgaWYgKCF0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5zdGFydGluZ01lZGlhXyB8fCB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5zdGFydGluZ01lZGlhXy5jb250YWluc1ZpZGVvKSB7XG4gICAgICAgICAgLy8gaWYgd2UgZG8gbm90IGtub3cgaWYgdGhlIG1haW4gc2VnbWVudCBsb2FkZXIgY29udGFpbnMgdmlkZW8geWV0IG9yIGlmIHdlXG4gICAgICAgICAgLy8gZGVmaW5pdGl2ZWx5IGtub3cgdGhlIG1haW4gc2VnbWVudCBsb2FkZXIgY29udGFpbnMgdmlkZW8sIHRoZW4gd2UgbmVlZCB0byB3YWl0XG4gICAgICAgICAgLy8gZm9yIGJvdGggbWFpbiBhbmQgYXVkaW8gc2VnbWVudCBsb2FkZXJzIHRvIGNhbGwgZW5kT2ZTdHJlYW1cbiAgICAgICAgICBpc0VuZE9mU3RyZWFtID0gaXNFbmRPZlN0cmVhbSAmJiB0aGlzLmF1ZGlvU2VnbWVudExvYWRlcl8uZW5kZWRfO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHJlbHkgb24gdGhlIGF1ZGlvIGxvYWRlclxuICAgICAgICAgIGlzRW5kT2ZTdHJlYW0gPSB0aGlzLmF1ZGlvU2VnbWVudExvYWRlcl8uZW5kZWRfO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VuZE9mU3RyZWFtKSB7XG4gICAgICAgIHRoaXMubWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHBsYXlsaXN0IGhhcyBzdG9wcGVkIGJlaW5nIHVwZGF0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgdGhlIG1lZGlhIHBsYXlsaXN0IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHBsYXlsaXN0IGhhcyBzdG9wcGVkIGJlaW5nIHVwZGF0ZWQgb3Igbm90XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0dWNrQXRQbGF5bGlzdEVuZF8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdHVja0F0UGxheWxpc3RFbmRfKHBsYXlsaXN0KSB7XG4gICAgICB2YXIgc2Vla2FibGUkJDEgPSB0aGlzLnNlZWthYmxlKCk7XG5cbiAgICAgIGlmICghc2Vla2FibGUkJDEubGVuZ3RoKSB7XG4gICAgICAgIC8vIHBsYXlsaXN0IGRvZXNuJ3QgaGF2ZSBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2UgYXJlIHN0dWNrXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4cGlyZWQgPSB0aGlzLnN5bmNDb250cm9sbGVyXy5nZXRFeHBpcmVkVGltZShwbGF5bGlzdCwgdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbik7XG5cbiAgICAgIGlmIChleHBpcmVkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gZG9lcyBub3QgdXNlIHRoZSBzYWZlIGxpdmUgZW5kIHRvIGNhbGN1bGF0ZSBwbGF5bGlzdCBlbmQsIHNpbmNlIHdlXG4gICAgICAvLyBkb24ndCB3YW50IHRvIHNheSB3ZSBhcmUgc3R1Y2sgd2hpbGUgdGhlcmUgaXMgc3RpbGwgY29udGVudFxuICAgICAgdmFyIGFic29sdXRlUGxheWxpc3RFbmQgPSBIbHMuUGxheWxpc3QucGxheWxpc3RFbmQocGxheWxpc3QsIGV4cGlyZWQpO1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy50ZWNoXy5jdXJyZW50VGltZSgpO1xuICAgICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy50ZWNoXy5idWZmZXJlZCgpO1xuXG4gICAgICBpZiAoIWJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgICAvLyByZXR1cm4gdHJ1ZSBpZiB0aGUgcGxheWhlYWQgcmVhY2hlZCB0aGUgYWJzb2x1dGUgZW5kIG9mIHRoZSBwbGF5bGlzdFxuICAgICAgICByZXR1cm4gYWJzb2x1dGVQbGF5bGlzdEVuZCAtIGN1cnJlbnRUaW1lIDw9IFNBRkVfVElNRV9ERUxUQTtcbiAgICAgIH1cbiAgICAgIHZhciBidWZmZXJlZEVuZCA9IGJ1ZmZlcmVkLmVuZChidWZmZXJlZC5sZW5ndGggLSAxKTtcblxuICAgICAgLy8gcmV0dXJuIHRydWUgaWYgdGhlcmUgaXMgdG9vIGxpdHRsZSBidWZmZXIgbGVmdCBhbmQgYnVmZmVyIGhhcyByZWFjaGVkIGFic29sdXRlXG4gICAgICAvLyBlbmQgb2YgcGxheWxpc3RcbiAgICAgIHJldHVybiBidWZmZXJlZEVuZCAtIGN1cnJlbnRUaW1lIDw9IFNBRkVfVElNRV9ERUxUQSAmJiBhYnNvbHV0ZVBsYXlsaXN0RW5kIC0gYnVmZmVyZWRFbmQgPD0gU0FGRV9USU1FX0RFTFRBO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJsYWNrbGlzdHMgYSBwbGF5bGlzdCB3aGVuIGFuIGVycm9yIG9jY3VycyBmb3IgYSBzZXQgYW1vdW50IG9mIHRpbWVcbiAgICAgKiBtYWtpbmcgaXQgdW5hdmFpbGFibGUgZm9yIHNlbGVjdGlvbiBieSB0aGUgcmVuZGl0aW9uIHNlbGVjdGlvbiBhbGdvcml0aG1cbiAgICAgKiBhbmQgdGhlbiBmb3JjZXMgYSBuZXcgcGxheWxpc3QgKHJlbmRpdGlvbikgc2VsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlcnJvciBhbiBvcHRpb25hbCBlcnJvciB0aGF0IG1heSBpbmNsdWRlIHRoZSBwbGF5bGlzdFxuICAgICAqIHRvIGJsYWNrbGlzdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYmxhY2tsaXN0RHVyYXRpb24gYW4gb3B0aW9uYWwgbnVtYmVyIG9mIHNlY29uZHMgdG8gYmxhY2tsaXN0IHRoZVxuICAgICAqIHBsYXlsaXN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2JsYWNrbGlzdEN1cnJlbnRQbGF5bGlzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJsYWNrbGlzdEN1cnJlbnRQbGF5bGlzdCgpIHtcbiAgICAgIHZhciBlcnJvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB2YXIgYmxhY2tsaXN0RHVyYXRpb24gPSBhcmd1bWVudHNbMV07XG5cbiAgICAgIHZhciBjdXJyZW50UGxheWxpc3QgPSB2b2lkIDA7XG4gICAgICB2YXIgbmV4dFBsYXlsaXN0ID0gdm9pZCAwO1xuXG4gICAgICAvLyBJZiB0aGUgYGVycm9yYCB3YXMgZ2VuZXJhdGVkIGJ5IHRoZSBwbGF5bGlzdCBsb2FkZXIsIGl0IHdpbGwgY29udGFpblxuICAgICAgLy8gdGhlIHBsYXlsaXN0IHdlIHdlcmUgdHJ5aW5nIHRvIGxvYWQgKGJ1dCBmYWlsZWQpIGFuZCB0aGF0IHNob3VsZCBiZVxuICAgICAgLy8gYmxhY2tsaXN0ZWQgaW5zdGVhZCBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHBsYXlsaXN0IHdoaWNoIGlzIGxpa2VseVxuICAgICAgLy8gb3V0LW9mLWRhdGUgaW4gdGhpcyBzY2VuYXJpb1xuICAgICAgY3VycmVudFBsYXlsaXN0ID0gZXJyb3IucGxheWxpc3QgfHwgdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKTtcblxuICAgICAgYmxhY2tsaXN0RHVyYXRpb24gPSBibGFja2xpc3REdXJhdGlvbiB8fCBlcnJvci5ibGFja2xpc3REdXJhdGlvbiB8fCB0aGlzLmJsYWNrbGlzdER1cmF0aW9uO1xuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBjdXJyZW50IHBsYXlsaXN0LCB0aGVuIGFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHdlIHdlcmVcbiAgICAgIC8vIHRyeWluZyB0byBsb2FkIHRoZSBtYXN0ZXIgT1Igd2hpbGUgd2Ugd2VyZSBkaXNwb3Npbmcgb2YgdGhlIHRlY2hcbiAgICAgIGlmICghY3VycmVudFBsYXlsaXN0KSB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCduZXR3b3JrJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdlcnJvcicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0ZpbmFsUmVuZGl0aW9uID0gdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWFzdGVyLnBsYXlsaXN0cy5maWx0ZXIoaXNFbmFibGVkKS5sZW5ndGggPT09IDE7XG5cbiAgICAgIGlmIChpc0ZpbmFsUmVuZGl0aW9uKSB7XG4gICAgICAgIC8vIE5ldmVyIGJsYWNrbGlzdGluZyB0aGlzIHBsYXlsaXN0IGJlY2F1c2UgaXQncyBmaW5hbCByZW5kaXRpb25cbiAgICAgICAgdmlkZW9qcyQxLmxvZy53YXJuKCdQcm9ibGVtIGVuY291bnRlcmVkIHdpdGggdGhlIGN1cnJlbnQgJyArICdITFMgcGxheWxpc3QuIFRyeWluZyBhZ2FpbiBzaW5jZSBpdCBpcyB0aGUgZmluYWwgcGxheWxpc3QuJyk7XG5cbiAgICAgICAgdGhpcy50ZWNoXy50cmlnZ2VyKCdyZXRyeXBsYXlsaXN0Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5sb2FkKGlzRmluYWxSZW5kaXRpb24pO1xuICAgICAgfVxuICAgICAgLy8gQmxhY2tsaXN0IHRoaXMgcGxheWxpc3RcbiAgICAgIGN1cnJlbnRQbGF5bGlzdC5leGNsdWRlVW50aWwgPSBEYXRlLm5vdygpICsgYmxhY2tsaXN0RHVyYXRpb24gKiAxMDAwO1xuICAgICAgdGhpcy50ZWNoXy50cmlnZ2VyKCdibGFja2xpc3RwbGF5bGlzdCcpO1xuICAgICAgdGhpcy50ZWNoXy50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy1yZW5kaXRpb24tYmxhY2tsaXN0ZWQnIH0pO1xuXG4gICAgICAvLyBTZWxlY3QgYSBuZXcgcGxheWxpc3RcbiAgICAgIG5leHRQbGF5bGlzdCA9IHRoaXMuc2VsZWN0UGxheWxpc3QoKTtcbiAgICAgIHZpZGVvanMkMS5sb2cud2FybignUHJvYmxlbSBlbmNvdW50ZXJlZCB3aXRoIHRoZSBjdXJyZW50IEhMUyBwbGF5bGlzdC4nICsgKGVycm9yLm1lc3NhZ2UgPyAnICcgKyBlcnJvci5tZXNzYWdlIDogJycpICsgJyBTd2l0Y2hpbmcgdG8gYW5vdGhlciBwbGF5bGlzdC4nKTtcblxuICAgICAgcmV0dXJuIHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1lZGlhKG5leHRQbGF5bGlzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF1c2UgYWxsIHNlZ21lbnQgbG9hZGVyc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwYXVzZUxvYWRpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZUxvYWRpbmcoKSB7XG4gICAgICB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5wYXVzZSgpO1xuICAgICAgaWYgKHRoaXMubWVkaWFUeXBlc18uQVVESU8uYWN0aXZlUGxheWxpc3RMb2FkZXIpIHtcbiAgICAgICAgdGhpcy5hdWRpb1NlZ21lbnRMb2FkZXJfLnBhdXNlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tZWRpYVR5cGVzXy5TVUJUSVRMRVMuYWN0aXZlUGxheWxpc3RMb2FkZXIpIHtcbiAgICAgICAgdGhpcy5zdWJ0aXRsZVNlZ21lbnRMb2FkZXJfLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHRoZSBjdXJyZW50IHRpbWUgb24gYWxsIHNlZ21lbnQgbG9hZGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtUaW1lUmFuZ2V9IGN1cnJlbnRUaW1lIHRoZSBjdXJyZW50IHRpbWUgdG8gc2V0XG4gICAgICogQHJldHVybiB7VGltZVJhbmdlfSB0aGUgY3VycmVudCB0aW1lXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldEN1cnJlbnRUaW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VycmVudFRpbWUoY3VycmVudFRpbWUpIHtcbiAgICAgIHZhciBidWZmZXJlZCA9IGZpbmRSYW5nZSh0aGlzLnRlY2hfLmJ1ZmZlcmVkKCksIGN1cnJlbnRUaW1lKTtcblxuICAgICAgaWYgKCEodGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8gJiYgdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKSkpIHtcbiAgICAgICAgLy8gcmV0dXJuIGltbWVkaWF0ZWx5IGlmIHRoZSBtZXRhZGF0YSBpcyBub3QgcmVhZHkgeWV0XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICAvLyBpdCdzIGNsZWFybHkgYW4gZWRnZS1jYXNlIGJ1dCBkb24ndCB0aHJvd24gYW4gZXJyb3IgaWYgYXNrZWQgdG9cbiAgICAgIC8vIHNlZWsgd2l0aGluIGFuIGVtcHR5IHBsYXlsaXN0XG4gICAgICBpZiAoIXRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1lZGlhKCkuc2VnbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIEluIGZsYXNoIHBsYXliYWNrLCB0aGUgc2VnbWVudCBsb2FkZXJzIHNob3VsZCBiZSByZXNldCBvbiBldmVyeSBzZWVrLCBldmVuXG4gICAgICAvLyBpbiBidWZmZXIgc2Vla3MuIElmIHRoZSBzZWVrIGxvY2F0aW9uIGlzIGFscmVhZHkgYnVmZmVyZWQsIGNvbnRpbnVlIGJ1ZmZlcmluZyBhc1xuICAgICAgLy8gdXN1YWxcbiAgICAgIC8vIFRPRE86IHJlZG8gdGhpcyBjb21tZW50XG4gICAgICBpZiAoYnVmZmVyZWQgJiYgYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50VGltZTtcbiAgICAgIH1cblxuICAgICAgLy8gY2FuY2VsIG91dHN0YW5kaW5nIHJlcXVlc3RzIHNvIHdlIGJlZ2luIGJ1ZmZlcmluZyBhdCB0aGUgbmV3XG4gICAgICAvLyBsb2NhdGlvblxuICAgICAgdGhpcy5tYWluU2VnbWVudExvYWRlcl8ucmVzZXRFdmVyeXRoaW5nKCk7XG4gICAgICB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5hYm9ydCgpO1xuICAgICAgaWYgKHRoaXMubWVkaWFUeXBlc18uQVVESU8uYWN0aXZlUGxheWxpc3RMb2FkZXIpIHtcbiAgICAgICAgdGhpcy5hdWRpb1NlZ21lbnRMb2FkZXJfLnJlc2V0RXZlcnl0aGluZygpO1xuICAgICAgICB0aGlzLmF1ZGlvU2VnbWVudExvYWRlcl8uYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1lZGlhVHlwZXNfLlNVQlRJVExFUy5hY3RpdmVQbGF5bGlzdExvYWRlcikge1xuICAgICAgICB0aGlzLnN1YnRpdGxlU2VnbWVudExvYWRlcl8ucmVzZXRFdmVyeXRoaW5nKCk7XG4gICAgICAgIHRoaXMuc3VidGl0bGVTZWdtZW50TG9hZGVyXy5hYm9ydCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBzdGFydCBzZWdtZW50IGxvYWRlciBsb2FkaW5nIGluIGNhc2UgdGhleSBhcmUgcGF1c2VkXG4gICAgICB0aGlzLmxvYWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGN1cnJlbnQgZHVyYXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1RpbWVSYW5nZX0gdGhlIGR1cmF0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2R1cmF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHVyYXRpb24kJDEoKSB7XG4gICAgICBpZiAoIXRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tZWRpYVNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEhscy5QbGF5bGlzdC5kdXJhdGlvbih0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5tZWRpYSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjaGVjayB0aGUgc2Vla2FibGUgcmFuZ2VcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1RpbWVSYW5nZX0gdGhlIHNlZWthYmxlIHJhbmdlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlZWthYmxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Vla2FibGUkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWVrYWJsZV87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25TeW5jSW5mb1VwZGF0ZV8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblN5bmNJbmZvVXBkYXRlXygpIHtcbiAgICAgIHZhciBtYWluU2Vla2FibGUgPSB2b2lkIDA7XG4gICAgICB2YXIgYXVkaW9TZWVrYWJsZSA9IHZvaWQgMDtcblxuICAgICAgaWYgKCF0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1lZGlhKCk7XG5cbiAgICAgIGlmICghbWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXhwaXJlZCA9IHRoaXMuc3luY0NvbnRyb2xsZXJfLmdldEV4cGlyZWRUaW1lKG1lZGlhLCB0aGlzLm1lZGlhU291cmNlLmR1cmF0aW9uKTtcblxuICAgICAgaWYgKGV4cGlyZWQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gbm90IGVub3VnaCBpbmZvcm1hdGlvbiB0byB1cGRhdGUgc2Vla2FibGVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYWluU2Vla2FibGUgPSBIbHMuUGxheWxpc3Quc2Vla2FibGUobWVkaWEsIGV4cGlyZWQpO1xuXG4gICAgICBpZiAobWFpblNlZWthYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1lZGlhVHlwZXNfLkFVRElPLmFjdGl2ZVBsYXlsaXN0TG9hZGVyKSB7XG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYVR5cGVzXy5BVURJTy5hY3RpdmVQbGF5bGlzdExvYWRlci5tZWRpYSgpO1xuICAgICAgICBleHBpcmVkID0gdGhpcy5zeW5jQ29udHJvbGxlcl8uZ2V0RXhwaXJlZFRpbWUobWVkaWEsIHRoaXMubWVkaWFTb3VyY2UuZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChleHBpcmVkID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXVkaW9TZWVrYWJsZSA9IEhscy5QbGF5bGlzdC5zZWVrYWJsZShtZWRpYSwgZXhwaXJlZCk7XG5cbiAgICAgICAgaWYgKGF1ZGlvU2Vla2FibGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYXVkaW9TZWVrYWJsZSkge1xuICAgICAgICAvLyBzZWVrYWJsZSBoYXMgYmVlbiBjYWxjdWxhdGVkIGJhc2VkIG9uIGJ1ZmZlcmluZyB2aWRlbyBkYXRhIHNvIGl0XG4gICAgICAgIC8vIGNhbiBiZSByZXR1cm5lZCBkaXJlY3RseVxuICAgICAgICB0aGlzLnNlZWthYmxlXyA9IG1haW5TZWVrYWJsZTtcbiAgICAgIH0gZWxzZSBpZiAoYXVkaW9TZWVrYWJsZS5zdGFydCgwKSA+IG1haW5TZWVrYWJsZS5lbmQoMCkgfHwgbWFpblNlZWthYmxlLnN0YXJ0KDApID4gYXVkaW9TZWVrYWJsZS5lbmQoMCkpIHtcbiAgICAgICAgLy8gc2Vla2FibGVzIGFyZSBwcmV0dHkgZmFyIG9mZiwgcmVseSBvbiBtYWluXG4gICAgICAgIHRoaXMuc2Vla2FibGVfID0gbWFpblNlZWthYmxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWVrYWJsZV8gPSB2aWRlb2pzJDEuY3JlYXRlVGltZVJhbmdlcyhbW2F1ZGlvU2Vla2FibGUuc3RhcnQoMCkgPiBtYWluU2Vla2FibGUuc3RhcnQoMCkgPyBhdWRpb1NlZWthYmxlLnN0YXJ0KDApIDogbWFpblNlZWthYmxlLnN0YXJ0KDApLCBhdWRpb1NlZWthYmxlLmVuZCgwKSA8IG1haW5TZWVrYWJsZS5lbmQoMCkgPyBhdWRpb1NlZWthYmxlLmVuZCgwKSA6IG1haW5TZWVrYWJsZS5lbmQoMCldXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nZ2VyXygnc2Vla2FibGUgdXBkYXRlZCBbJyArIHByaW50YWJsZVJhbmdlKHRoaXMuc2Vla2FibGVfKSArICddJyk7XG5cbiAgICAgIHRoaXMudGVjaF8udHJpZ2dlcignc2Vla2FibGVjaGFuZ2VkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBwbGF5ZXIgZHVyYXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRHVyYXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEdXJhdGlvbigpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgb2xkRHVyYXRpb24gPSB0aGlzLm1lZGlhU291cmNlLmR1cmF0aW9uO1xuICAgICAgdmFyIG5ld0R1cmF0aW9uID0gSGxzLlBsYXlsaXN0LmR1cmF0aW9uKHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1lZGlhKCkpO1xuICAgICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy50ZWNoXy5idWZmZXJlZCgpO1xuICAgICAgdmFyIHNldER1cmF0aW9uID0gZnVuY3Rpb24gc2V0RHVyYXRpb24oKSB7XG4gICAgICAgIF90aGlzNS5tZWRpYVNvdXJjZS5kdXJhdGlvbiA9IG5ld0R1cmF0aW9uO1xuICAgICAgICBfdGhpczUudGVjaF8udHJpZ2dlcignZHVyYXRpb25jaGFuZ2UnKTtcblxuICAgICAgICBfdGhpczUubWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHNldER1cmF0aW9uKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChidWZmZXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5ld0R1cmF0aW9uID0gTWF0aC5tYXgobmV3RHVyYXRpb24sIGJ1ZmZlcmVkLmVuZChidWZmZXJlZC5sZW5ndGggLSAxKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSBkdXJhdGlvbiBoYXMgY2hhbmdlZCwgaW52YWxpZGF0ZSB0aGUgY2FjaGVkIHZhbHVlXG4gICAgICBpZiAob2xkRHVyYXRpb24gIT09IG5ld0R1cmF0aW9uKSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZHVyYXRpb25cbiAgICAgICAgaWYgKHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICAgICAgdGhpcy5tZWRpYVNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgc2V0RHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldER1cmF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkaXNwb3NlIG9mIHRoZSBNYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXIgYW5kIGV2ZXJ5dGhpbmdcbiAgICAgKiB0aGF0IGl0IGNvbnRyb2xzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3Bvc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGVjcnlwdGVyXy50ZXJtaW5hdGUoKTtcbiAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMubWFpblNlZ21lbnRMb2FkZXJfLmRpc3Bvc2UoKTtcblxuICAgICAgWydBVURJTycsICdTVUJUSVRMRVMnXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBncm91cHMgPSBfdGhpczYubWVkaWFUeXBlc19bdHlwZV0uZ3JvdXBzO1xuXG4gICAgICAgIGZvciAodmFyIGlkIGluIGdyb3Vwcykge1xuICAgICAgICAgIGdyb3Vwc1tpZF0uZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGlmIChncm91cC5wbGF5bGlzdExvYWRlcikge1xuICAgICAgICAgICAgICBncm91cC5wbGF5bGlzdExvYWRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmF1ZGlvU2VnbWVudExvYWRlcl8uZGlzcG9zZSgpO1xuICAgICAgdGhpcy5zdWJ0aXRsZVNlZ21lbnRMb2FkZXJfLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIG1hc3RlciBwbGF5bGlzdCBvYmplY3QgaWYgd2UgaGF2ZSBvbmVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIG1hc3RlciBwbGF5bGlzdCBvYmplY3QgdGhhdCB3ZSBwYXJzZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWFzdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFzdGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1hc3RlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBwbGF5bGlzdFxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHBsYXlsaXN0IG9iamVjdCB0aGF0IHdlIHBhcnNlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtZWRpYScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lZGlhKCkge1xuICAgICAgLy8gcGxheWxpc3QgbG9hZGVyIHdpbGwgbm90IHJldHVybiBtZWRpYSBpZiBpdCBoYXMgbm90IGJlZW4gZnVsbHkgbG9hZGVkXG4gICAgICByZXR1cm4gdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKSB8fCB0aGlzLmluaXRpYWxNZWRpYV87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0dXAgb3VyIGludGVybmFsIHNvdXJjZSBidWZmZXJzIG9uIG91ciBzZWdtZW50IExvYWRlcnNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldHVwU291cmNlQnVmZmVyc18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFNvdXJjZUJ1ZmZlcnNfKCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKTtcbiAgICAgIHZhciBtaW1lVHlwZXMgPSB2b2lkIDA7XG5cbiAgICAgIC8vIHdhaXQgdW50aWwgYSBtZWRpYSBwbGF5bGlzdCBpcyBhdmFpbGFibGUgYW5kIHRoZSBNZWRpYSBTb3VyY2UgaXNcbiAgICAgIC8vIGF0dGFjaGVkXG4gICAgICBpZiAoIW1lZGlhIHx8IHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWltZVR5cGVzID0gbWltZVR5cGVzRm9yUGxheWxpc3QodGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWFzdGVyLCBtZWRpYSk7XG4gICAgICBpZiAobWltZVR5cGVzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9ICdObyBjb21wYXRpYmxlIFNvdXJjZUJ1ZmZlciBjb25maWd1cmF0aW9uIGZvciB0aGUgdmFyaWFudCBzdHJlYW06JyArIG1lZGlhLnJlc29sdmVkVXJpO1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgnZGVjb2RlJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29uZmlndXJlTG9hZGVyTWltZVR5cGVzXyhtaW1lVHlwZXMpO1xuICAgICAgLy8gZXhjbHVkZSBhbnkgaW5jb21wYXRpYmxlIHZhcmlhbnQgc3RyZWFtcyBmcm9tIGZ1dHVyZSBwbGF5bGlzdFxuICAgICAgLy8gc2VsZWN0aW9uXG4gICAgICB0aGlzLmV4Y2x1ZGVJbmNvbXBhdGlibGVWYXJpYW50c18obWVkaWEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbmZpZ3VyZUxvYWRlck1pbWVUeXBlc18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25maWd1cmVMb2FkZXJNaW1lVHlwZXNfKG1pbWVUeXBlcykge1xuICAgICAgLy8gSWYgdGhlIGNvbnRlbnQgaXMgZGVtdXhlZCwgd2UgY2FuJ3Qgc3RhcnQgYXBwZW5kaW5nIHNlZ21lbnRzIHRvIGEgc291cmNlIGJ1ZmZlclxuICAgICAgLy8gdW50aWwgYm90aCBzb3VyY2UgYnVmZmVycyBhcmUgc2V0IHVwLCBvciBlbHNlIHRoZSBicm93c2VyIG1heSBub3QgbGV0IHVzIGFkZCB0aGVcbiAgICAgIC8vIHNlY29uZCBzb3VyY2UgYnVmZmVyIChpdCB3aWxsIGFzc3VtZSB3ZSBhcmUgcGxheWluZyBlaXRoZXIgYXVkaW8gb25seSBvciB2aWRlb1xuICAgICAgLy8gb25seSkuXG4gICAgICB2YXIgc291cmNlQnVmZmVyRW1pdHRlciA9XG4gICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIG1pbWUgdHlwZVxuICAgICAgbWltZVR5cGVzLmxlbmd0aCA+IDEgJiZcbiAgICAgIC8vIGFuZCB0aGUgZmlyc3QgbWltZSB0eXBlIGRvZXMgbm90IGhhdmUgbXV4ZWQgdmlkZW8gYW5kIGF1ZGlvXG4gICAgICBtaW1lVHlwZXNbMF0uaW5kZXhPZignLCcpID09PSAtMSAmJlxuICAgICAgLy8gYW5kIHRoZSB0d28gbWltZSB0eXBlcyBhcmUgZGlmZmVyZW50ICh0aGV5IGNhbiBiZSB0aGUgc2FtZSBpbiB0aGUgY2FzZSBvZiBhdWRpb1xuICAgICAgLy8gb25seSB3aXRoIGFsdGVybmF0ZSBhdWRpbylcbiAgICAgIG1pbWVUeXBlc1swXSAhPT0gbWltZVR5cGVzWzFdID9cbiAgICAgIC8vIHRoZW4gd2Ugd2FudCB0byB3YWl0IG9uIHRoZSBzZWNvbmQgc291cmNlIGJ1ZmZlclxuICAgICAgbmV3IHZpZGVvanMkMS5FdmVudFRhcmdldCgpIDpcbiAgICAgIC8vIG90aGVyd2lzZSB0aGVyZSBpcyBubyBuZWVkIHRvIHdhaXQgYXMgdGhlIGNvbnRlbnQgaXMgZWl0aGVyIGF1ZGlvIG9ubHksXG4gICAgICAvLyB2aWRlbyBvbmx5LCBvciBtdXhlZCBjb250ZW50LlxuICAgICAgbnVsbDtcblxuICAgICAgdGhpcy5tYWluU2VnbWVudExvYWRlcl8ubWltZVR5cGUobWltZVR5cGVzWzBdLCBzb3VyY2VCdWZmZXJFbWl0dGVyKTtcbiAgICAgIGlmIChtaW1lVHlwZXNbMV0pIHtcbiAgICAgICAgdGhpcy5hdWRpb1NlZ21lbnRMb2FkZXJfLm1pbWVUeXBlKG1pbWVUeXBlc1sxXSwgc291cmNlQnVmZmVyRW1pdHRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmxhY2tsaXN0cyBwbGF5bGlzdHMgd2l0aCBjb2RlY3MgdGhhdCBhcmUgdW5zdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2V4Y2x1ZGVVbnN1cHBvcnRlZFZhcmlhbnRzXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4Y2x1ZGVVbnN1cHBvcnRlZFZhcmlhbnRzXygpIHtcbiAgICAgIHRoaXMubWFzdGVyKCkucGxheWxpc3RzLmZvckVhY2goZnVuY3Rpb24gKHZhcmlhbnQpIHtcbiAgICAgICAgaWYgKHZhcmlhbnQuYXR0cmlidXRlcy5DT0RFQ1MgJiYgd2luZG93JDEuTWVkaWFTb3VyY2UgJiYgd2luZG93JDEuTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkICYmICF3aW5kb3ckMS5NZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNDsgY29kZWNzPVwiJyArIG1hcExlZ2FjeUF2Y0NvZGVjcyh2YXJpYW50LmF0dHJpYnV0ZXMuQ09ERUNTKSArICdcIicpKSB7XG4gICAgICAgICAgdmFyaWFudC5leGNsdWRlVW50aWwgPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmxhY2tsaXN0IHBsYXlsaXN0cyB0aGF0IGFyZSBrbm93biB0byBiZSBjb2RlYyBvclxuICAgICAqIHN0cmVhbS1pbmNvbXBhdGlibGUgd2l0aCB0aGUgU291cmNlQnVmZmVyIGNvbmZpZ3VyYXRpb24uIEZvclxuICAgICAqIGluc3RhbmNlLCBNZWRpYSBTb3VyY2UgRXh0ZW5zaW9ucyB3b3VsZCBjYXVzZSB0aGUgdmlkZW8gZWxlbWVudCB0b1xuICAgICAqIHN0YWxsIHdhaXRpbmcgZm9yIHZpZGVvIGRhdGEgaWYgeW91IHN3aXRjaGVkIGZyb20gYSB2YXJpYW50IHdpdGhcbiAgICAgKiB2aWRlbyBhbmQgYXVkaW8gdG8gYW4gYXVkaW8tb25seSBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWVkaWEgYSBtZWRpYSBwbGF5bGlzdCBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnRcbiAgICAgKiBzZXQgb2YgU291cmNlQnVmZmVycy4gVmFyaWFudHMgaW4gdGhlIGN1cnJlbnQgbWFzdGVyIHBsYXlsaXN0IHRoYXRcbiAgICAgKiBkbyBub3QgYXBwZWFyIHRvIGhhdmUgY29tcGF0aWJsZSBjb2RlYyBvciBzdHJlYW0gY29uZmlndXJhdGlvbnNcbiAgICAgKiB3aWxsIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGRlZmF1bHQgcGxheWxpc3Qgc2VsZWN0aW9uIGFsZ29yaXRobVxuICAgICAqIGluZGVmaW5pdGVseS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdleGNsdWRlSW5jb21wYXRpYmxlVmFyaWFudHNfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhjbHVkZUluY29tcGF0aWJsZVZhcmlhbnRzXyhtZWRpYSkge1xuICAgICAgdmFyIGNvZGVjQ291bnQgPSAyO1xuICAgICAgdmFyIHZpZGVvQ29kZWMgPSBudWxsO1xuICAgICAgdmFyIGNvZGVjcyA9IHZvaWQgMDtcblxuICAgICAgaWYgKG1lZGlhLmF0dHJpYnV0ZXMuQ09ERUNTKSB7XG4gICAgICAgIGNvZGVjcyA9IHBhcnNlQ29kZWNzKG1lZGlhLmF0dHJpYnV0ZXMuQ09ERUNTKTtcbiAgICAgICAgdmlkZW9Db2RlYyA9IGNvZGVjcy52aWRlb0NvZGVjO1xuICAgICAgICBjb2RlY0NvdW50ID0gY29kZWNzLmNvZGVjQ291bnQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFzdGVyKCkucGxheWxpc3RzLmZvckVhY2goZnVuY3Rpb24gKHZhcmlhbnQpIHtcbiAgICAgICAgdmFyIHZhcmlhbnRDb2RlY3MgPSB7XG4gICAgICAgICAgY29kZWNDb3VudDogMixcbiAgICAgICAgICB2aWRlb0NvZGVjOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHZhcmlhbnQuYXR0cmlidXRlcy5DT0RFQ1MpIHtcbiAgICAgICAgICB2YXJpYW50Q29kZWNzID0gcGFyc2VDb2RlY3ModmFyaWFudC5hdHRyaWJ1dGVzLkNPREVDUyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgc3RyZWFtcyBkaWZmZXIgaW4gdGhlIHByZXNlbmNlIG9yIGFic2VuY2Ugb2YgYXVkaW8gb3JcbiAgICAgICAgLy8gdmlkZW8sIHRoZXkgYXJlIGluY29tcGF0aWJsZVxuICAgICAgICBpZiAodmFyaWFudENvZGVjcy5jb2RlY0NvdW50ICE9PSBjb2RlY0NvdW50KSB7XG4gICAgICAgICAgdmFyaWFudC5leGNsdWRlVW50aWwgPSBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGguMjY0IGlzIHNwZWNpZmllZCBvbiB0aGUgY3VycmVudCBwbGF5bGlzdCwgc29tZSBmbGF2b3Igb2ZcbiAgICAgICAgLy8gaXQgbXVzdCBiZSBzcGVjaWZpZWQgb24gYWxsIGNvbXBhdGlibGUgdmFyaWFudHNcbiAgICAgICAgaWYgKHZhcmlhbnRDb2RlY3MudmlkZW9Db2RlYyAhPT0gdmlkZW9Db2RlYykge1xuICAgICAgICAgIHZhcmlhbnQuZXhjbHVkZVVudGlsID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUFkQ3Vlc18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVBZEN1ZXNfKG1lZGlhKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBzZWVrYWJsZSQkMSA9IHRoaXMuc2Vla2FibGUoKTtcblxuICAgICAgaWYgKHNlZWthYmxlJCQxLmxlbmd0aCkge1xuICAgICAgICBvZmZzZXQgPSBzZWVrYWJsZSQkMS5zdGFydCgwKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlQWRDdWVzKG1lZGlhLCB0aGlzLmN1ZVRhZ3NUcmFja18sIG9mZnNldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZGVzaXJlZCBmb3J3YXJkIGJ1ZmZlciBsZW5ndGggYmFzZWQgb24gY3VycmVudCB0aW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IERlc2lyZWQgZm9yd2FyZCBidWZmZXIgbGVuZ3RoIGluIHNlY29uZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ29hbEJ1ZmZlckxlbmd0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdvYWxCdWZmZXJMZW5ndGgoKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLnRlY2hfLmN1cnJlbnRUaW1lKCk7XG4gICAgICB2YXIgaW5pdGlhbCA9IENvbmZpZy5HT0FMX0JVRkZFUl9MRU5HVEg7XG4gICAgICB2YXIgcmF0ZSA9IENvbmZpZy5HT0FMX0JVRkZFUl9MRU5HVEhfUkFURTtcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heChpbml0aWFsLCBDb25maWcuTUFYX0dPQUxfQlVGRkVSX0xFTkdUSCk7XG5cbiAgICAgIHJldHVybiBNYXRoLm1pbihpbml0aWFsICsgY3VycmVudFRpbWUgKiByYXRlLCBtYXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGRlc2lyZWQgYnVmZmVyIGxvdyB3YXRlciBsaW5lIGJhc2VkIG9uIGN1cnJlbnQgdGltZVxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBEZXNpcmVkIGJ1ZmZlciBsb3cgd2F0ZXIgbGluZSBpbiBzZWNvbmRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2J1ZmZlckxvd1dhdGVyTGluZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1ZmZlckxvd1dhdGVyTGluZSgpIHtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMudGVjaF8uY3VycmVudFRpbWUoKTtcbiAgICAgIHZhciBpbml0aWFsID0gQ29uZmlnLkJVRkZFUl9MT1dfV0FURVJfTElORTtcbiAgICAgIHZhciByYXRlID0gQ29uZmlnLkJVRkZFUl9MT1dfV0FURVJfTElORV9SQVRFO1xuICAgICAgdmFyIG1heCA9IE1hdGgubWF4KGluaXRpYWwsIENvbmZpZy5NQVhfQlVGRkVSX0xPV19XQVRFUl9MSU5FKTtcblxuICAgICAgcmV0dXJuIE1hdGgubWluKGluaXRpYWwgKyBjdXJyZW50VGltZSAqIHJhdGUsIG1heCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXI7XG59KHZpZGVvanMkMS5FdmVudFRhcmdldCk7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWN0cyBhcyB0aGUgRW5hYmxlL2Rpc2FibGUgcGxheWxpc3QgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtQbGF5bGlzdExvYWRlcn0gbG9hZGVyIC0gVGhlIG1hc3RlciBwbGF5bGlzdCBsb2FkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF5bGlzdFVyaSAtIHVyaSBvZiB0aGUgcGxheWxpc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoYW5nZVBsYXlsaXN0Rm4gLSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciBhXG4gKiBwbGF5bGlzdCdzIGVuYWJsZWQtc3RhdGUgaGFzIGJlZW4gY2hhbmdlZC4gV2lsbCBOT1QgYmUgY2FsbGVkIGlmIGFcbiAqIHBsYXlsaXN0J3MgZW5hYmxlZC1zdGF0ZSBpcyB1bmNoYW5nZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbj19IGVuYWJsZSAtIFZhbHVlIHRvIHNldCB0aGUgcGxheWxpc3QgZW5hYmxlZC1zdGF0ZSB0b1xuICogb3IgaWYgdW5kZWZpbmVkIHJldHVybnMgdGhlIGN1cnJlbnQgZW5hYmxlZC1zdGF0ZSBmb3IgdGhlIHBsYXlsaXN0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gRnVuY3Rpb24gZm9yIHNldHRpbmcvZ2V0dGluZyBlbmFibGVkXG4gKi9cbnZhciBlbmFibGVGdW5jdGlvbiA9IGZ1bmN0aW9uIGVuYWJsZUZ1bmN0aW9uKGxvYWRlciwgcGxheWxpc3RVcmksIGNoYW5nZVBsYXlsaXN0Rm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbmFibGUpIHtcbiAgICB2YXIgcGxheWxpc3QgPSBsb2FkZXIubWFzdGVyLnBsYXlsaXN0c1twbGF5bGlzdFVyaV07XG4gICAgdmFyIGluY29tcGF0aWJsZSA9IGlzSW5jb21wYXRpYmxlKHBsYXlsaXN0KTtcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9IGlzRW5hYmxlZChwbGF5bGlzdCk7XG5cbiAgICBpZiAodHlwZW9mIGVuYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBjdXJyZW50bHlFbmFibGVkO1xuICAgIH1cblxuICAgIGlmIChlbmFibGUpIHtcbiAgICAgIGRlbGV0ZSBwbGF5bGlzdC5kaXNhYmxlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGxheWxpc3QuZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChlbmFibGUgIT09IGN1cnJlbnRseUVuYWJsZWQgJiYgIWluY29tcGF0aWJsZSkge1xuICAgICAgLy8gRW5zdXJlIHRoZSBvdXRzaWRlIHdvcmxkIGtub3dzIGFib3V0IG91ciBjaGFuZ2VzXG4gICAgICBjaGFuZ2VQbGF5bGlzdEZuKCk7XG4gICAgICBpZiAoZW5hYmxlKSB7XG4gICAgICAgIGxvYWRlci50cmlnZ2VyKCdyZW5kaXRpb25lbmFibGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkZXIudHJpZ2dlcigncmVuZGl0aW9uZGlzYWJsZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuYWJsZTtcbiAgfTtcbn07XG5cbi8qKlxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9iamVjdCBlbmNhcHN1bGF0ZXMgdGhlIHB1YmxpY2x5IHZpc2libGUgaW5mb3JtYXRpb25cbiAqIGluIGEgbWVkaWEgcGxheWxpc3QgYWxvbmcgd2l0aCBhIHNldHRlci9nZXR0ZXItdHlwZSBmdW5jdGlvbiAoZW5hYmxlZClcbiAqIGZvciBjaGFuZ2luZyB0aGUgZW5hYmxlZC1zdGF0ZSBvZiBhIHBhcnRpY3VsYXIgcGxheWxpc3QgZW50cnlcbiAqXG4gKiBAY2xhc3MgUmVwcmVzZW50YXRpb25cbiAqL1xuXG52YXIgUmVwcmVzZW50YXRpb24gPSBmdW5jdGlvbiBSZXByZXNlbnRhdGlvbihobHNIYW5kbGVyLCBwbGF5bGlzdCwgaWQpIHtcbiAgY2xhc3NDYWxsQ2hlY2skMSh0aGlzLCBSZXByZXNlbnRhdGlvbik7XG5cbiAgLy8gR2V0IGEgcmVmZXJlbmNlIHRvIGEgYm91bmQgdmVyc2lvbiBvZiBmYXN0UXVhbGl0eUNoYW5nZV9cbiAgdmFyIGZhc3RDaGFuZ2VGdW5jdGlvbiA9IGhsc0hhbmRsZXIubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5mYXN0UXVhbGl0eUNoYW5nZV8uYmluZChobHNIYW5kbGVyLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8pO1xuXG4gIC8vIHNvbWUgcGxheWxpc3QgYXR0cmlidXRlcyBhcmUgb3B0aW9uYWxcbiAgaWYgKHBsYXlsaXN0LmF0dHJpYnV0ZXMuUkVTT0xVVElPTikge1xuICAgIHZhciByZXNvbHV0aW9uID0gcGxheWxpc3QuYXR0cmlidXRlcy5SRVNPTFVUSU9OO1xuXG4gICAgdGhpcy53aWR0aCA9IHJlc29sdXRpb24ud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgfVxuXG4gIHRoaXMuYmFuZHdpZHRoID0gcGxheWxpc3QuYXR0cmlidXRlcy5CQU5EV0lEVEg7XG5cbiAgLy8gVGhlIGlkIGlzIHNpbXBseSB0aGUgb3JkaW5hbGl0eSBvZiB0aGUgbWVkaWEgcGxheWxpc3RcbiAgLy8gd2l0aGluIHRoZSBtYXN0ZXIgcGxheWxpc3RcbiAgdGhpcy5pZCA9IGlkO1xuXG4gIC8vIFBhcnRpYWxseS1hcHBseSB0aGUgZW5hYmxlRnVuY3Rpb24gdG8gY3JlYXRlIGEgcGxheWxpc3QtXG4gIC8vIHNwZWNpZmljIHZhcmlhbnRcbiAgdGhpcy5lbmFibGVkID0gZW5hYmxlRnVuY3Rpb24oaGxzSGFuZGxlci5wbGF5bGlzdHMsIHBsYXlsaXN0LnVyaSwgZmFzdENoYW5nZUZ1bmN0aW9uKTtcbn07XG5cbi8qKlxuICogQSBtaXhpbiBmdW5jdGlvbiB0aGF0IGFkZHMgdGhlIGByZXByZXNlbnRhdGlvbnNgIGFwaSB0byBhbiBpbnN0YW5jZVxuICogb2YgdGhlIEhsc0hhbmRsZXIgY2xhc3NcbiAqIEBwYXJhbSB7SGxzSGFuZGxlcn0gaGxzSGFuZGxlciAtIEFuIGluc3RhbmNlIG9mIEhsc0hhbmRsZXIgdG8gYWRkIHRoZVxuICogcmVwcmVzZW50YXRpb24gQVBJIGludG9cbiAqL1xuXG52YXIgcmVuZGl0aW9uU2VsZWN0aW9uTWl4aW4gPSBmdW5jdGlvbiByZW5kaXRpb25TZWxlY3Rpb25NaXhpbihobHNIYW5kbGVyKSB7XG4gIHZhciBwbGF5bGlzdHMgPSBobHNIYW5kbGVyLnBsYXlsaXN0cztcblxuICAvLyBBZGQgYSBzaW5nbGUgQVBJLXNwZWNpZmljIGZ1bmN0aW9uIHRvIHRoZSBIbHNIYW5kbGVyIGluc3RhbmNlXG4gIGhsc0hhbmRsZXIucmVwcmVzZW50YXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwbGF5bGlzdHMubWFzdGVyLnBsYXlsaXN0cy5maWx0ZXIoZnVuY3Rpb24gKG1lZGlhKSB7XG4gICAgICByZXR1cm4gIWlzSW5jb21wYXRpYmxlKG1lZGlhKTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIHJldHVybiBuZXcgUmVwcmVzZW50YXRpb24oaGxzSGFuZGxlciwgZSwgZS51cmkpO1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5YmFjay13YXRjaGVyLmpzXG4gKlxuICogUGxheWJhY2sgc3RhcnRzLCBhbmQgbm93IG15IHdhdGNoIGJlZ2lucy4gSXQgc2hhbGwgbm90IGVuZCB1bnRpbCBteSBkZWF0aC4gSSBzaGFsbFxuICogdGFrZSBubyB3YWl0LCBob2xkIG5vIHVuY2xlYXJlZCB0aW1lb3V0cywgZmF0aGVyIG5vIGJhZCBzZWVrcy4gSSBzaGFsbCB3ZWFyIG5vIGNyb3duc1xuICogYW5kIHdpbiBubyBnbG9yeS4gSSBzaGFsbCBsaXZlIGFuZCBkaWUgYXQgbXkgcG9zdC4gSSBhbSB0aGUgY29ycmVjdG9yIG9mIHRoZSB1bmRlcmZsb3cuXG4gKiBJIGFtIHRoZSB3YXRjaGVyIG9mIGdhcHMuIEkgYW0gdGhlIHNoaWVsZCB0aGF0IGd1YXJkcyB0aGUgcmVhbG1zIG9mIHNlZWthYmxlLiBJIHBsZWRnZVxuICogbXkgbGlmZSBhbmQgaG9ub3IgdG8gdGhlIFBsYXliYWNrIFdhdGNoLCBmb3IgdGhpcyBQbGF5ZXIgYW5kIGFsbCB0aGUgUGxheWVycyB0byBjb21lLlxuICovXG5cbi8vIFNldCBvZiBldmVudHMgdGhhdCByZXNldCB0aGUgcGxheWJhY2std2F0Y2hlciB0aW1lIGNoZWNrIGxvZ2ljIGFuZCBjbGVhciB0aGUgdGltZW91dFxudmFyIHRpbWVyQ2FuY2VsRXZlbnRzID0gWydzZWVraW5nJywgJ3NlZWtlZCcsICdwYXVzZScsICdwbGF5aW5nJywgJ2Vycm9yJ107XG5cbi8qKlxuICogQGNsYXNzIFBsYXliYWNrV2F0Y2hlclxuICovXG5cbnZhciBQbGF5YmFja1dhdGNoZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGFuIFBsYXliYWNrV2F0Y2hlciBvYmplY3QuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBhbiBvYmplY3QgdGhhdCBpbmNsdWRlcyB0aGUgdGVjaCBhbmQgc2V0dGluZ3NcbiAgICovXG4gIGZ1bmN0aW9uIFBsYXliYWNrV2F0Y2hlcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGNsYXNzQ2FsbENoZWNrJDEodGhpcywgUGxheWJhY2tXYXRjaGVyKTtcblxuICAgIHRoaXMudGVjaF8gPSBvcHRpb25zLnRlY2g7XG4gICAgdGhpcy5zZWVrYWJsZSA9IG9wdGlvbnMuc2Vla2FibGU7XG5cbiAgICB0aGlzLmNvbnNlY3V0aXZlVXBkYXRlcyA9IDA7XG4gICAgdGhpcy5sYXN0UmVjb3JkZWRUaW1lID0gbnVsbDtcbiAgICB0aGlzLnRpbWVyXyA9IG51bGw7XG4gICAgdGhpcy5jaGVja0N1cnJlbnRUaW1lVGltZW91dF8gPSBudWxsO1xuICAgIHRoaXMubG9nZ2VyXyA9IGxvZ2dlcignUGxheWJhY2tXYXRjaGVyJyk7XG5cbiAgICB0aGlzLmxvZ2dlcl8oJ2luaXRpYWxpemUnKTtcblxuICAgIHZhciBjYW5QbGF5SGFuZGxlciA9IGZ1bmN0aW9uIGNhblBsYXlIYW5kbGVyKCkge1xuICAgICAgcmV0dXJuIF90aGlzLm1vbml0b3JDdXJyZW50VGltZV8oKTtcbiAgICB9O1xuICAgIHZhciB3YWl0aW5nSGFuZGxlciA9IGZ1bmN0aW9uIHdhaXRpbmdIYW5kbGVyKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnRlY2hXYWl0aW5nXygpO1xuICAgIH07XG4gICAgdmFyIGNhbmNlbFRpbWVySGFuZGxlciA9IGZ1bmN0aW9uIGNhbmNlbFRpbWVySGFuZGxlcigpIHtcbiAgICAgIHJldHVybiBfdGhpcy5jYW5jZWxUaW1lcl8oKTtcbiAgICB9O1xuICAgIHZhciBmaXhlc0JhZFNlZWtzSGFuZGxlciA9IGZ1bmN0aW9uIGZpeGVzQmFkU2Vla3NIYW5kbGVyKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmZpeGVzQmFkU2Vla3NfKCk7XG4gICAgfTtcblxuICAgIHRoaXMudGVjaF8ub24oJ3NlZWthYmxlY2hhbmdlZCcsIGZpeGVzQmFkU2Vla3NIYW5kbGVyKTtcbiAgICB0aGlzLnRlY2hfLm9uKCd3YWl0aW5nJywgd2FpdGluZ0hhbmRsZXIpO1xuICAgIHRoaXMudGVjaF8ub24odGltZXJDYW5jZWxFdmVudHMsIGNhbmNlbFRpbWVySGFuZGxlcik7XG4gICAgdGhpcy50ZWNoXy5vbignY2FucGxheScsIGNhblBsYXlIYW5kbGVyKTtcblxuICAgIC8vIERlZmluZSB0aGUgZGlzcG9zZSBmdW5jdGlvbiB0byBjbGVhbiB1cCBvdXIgZXZlbnRzXG4gICAgdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMubG9nZ2VyXygnZGlzcG9zZScpO1xuICAgICAgX3RoaXMudGVjaF8ub2ZmKCdzZWVrYWJsZWNoYW5nZWQnLCBmaXhlc0JhZFNlZWtzSGFuZGxlcik7XG4gICAgICBfdGhpcy50ZWNoXy5vZmYoJ3dhaXRpbmcnLCB3YWl0aW5nSGFuZGxlcik7XG4gICAgICBfdGhpcy50ZWNoXy5vZmYodGltZXJDYW5jZWxFdmVudHMsIGNhbmNlbFRpbWVySGFuZGxlcik7XG4gICAgICBfdGhpcy50ZWNoXy5vZmYoJ2NhbnBsYXknLCBjYW5QbGF5SGFuZGxlcik7XG4gICAgICBpZiAoX3RoaXMuY2hlY2tDdXJyZW50VGltZVRpbWVvdXRfKSB7XG4gICAgICAgIHdpbmRvdyQxLmNsZWFyVGltZW91dChfdGhpcy5jaGVja0N1cnJlbnRUaW1lVGltZW91dF8pO1xuICAgICAgfVxuICAgICAgX3RoaXMuY2FuY2VsVGltZXJfKCk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJpb2RpY2FsbHkgY2hlY2sgY3VycmVudCB0aW1lIHRvIHNlZSBpZiBwbGF5YmFjayBzdG9wcGVkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIGNyZWF0ZUNsYXNzJDEoUGxheWJhY2tXYXRjaGVyLCBbe1xuICAgIGtleTogJ21vbml0b3JDdXJyZW50VGltZV8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb25pdG9yQ3VycmVudFRpbWVfKCkge1xuICAgICAgdGhpcy5jaGVja0N1cnJlbnRUaW1lXygpO1xuXG4gICAgICBpZiAodGhpcy5jaGVja0N1cnJlbnRUaW1lVGltZW91dF8pIHtcbiAgICAgICAgd2luZG93JDEuY2xlYXJUaW1lb3V0KHRoaXMuY2hlY2tDdXJyZW50VGltZVRpbWVvdXRfKTtcbiAgICAgIH1cblxuICAgICAgLy8gNDIgPSAyNCBmcHMgLy8gMjUwIGlzIHdoYXQgV2Via2l0IHVzZXMgLy8gRkYgdXNlcyAxNVxuICAgICAgdGhpcy5jaGVja0N1cnJlbnRUaW1lVGltZW91dF8gPSB3aW5kb3ckMS5zZXRUaW1lb3V0KHRoaXMubW9uaXRvckN1cnJlbnRUaW1lXy5iaW5kKHRoaXMpLCAyNTApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdG8gZW11bGF0ZSB0aGUgXCJ3YWl0aW5nXCIgZXZlbnQgb25cbiAgICAgKiBicm93c2VycyB0aGF0IGRvIG5vdCBlbWl0IGl0IHdoZW4gdGhleSBhcmUgd2FpdGluZyBmb3IgbW9yZVxuICAgICAqIGRhdGEgdG8gY29udGludWUgcGxheWJhY2tcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NoZWNrQ3VycmVudFRpbWVfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tDdXJyZW50VGltZV8oKSB7XG4gICAgICBpZiAodGhpcy50ZWNoXy5zZWVraW5nKCkgJiYgdGhpcy5maXhlc0JhZFNlZWtzXygpKSB7XG4gICAgICAgIHRoaXMuY29uc2VjdXRpdmVVcGRhdGVzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0UmVjb3JkZWRUaW1lID0gdGhpcy50ZWNoXy5jdXJyZW50VGltZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRlY2hfLnBhdXNlZCgpIHx8IHRoaXMudGVjaF8uc2Vla2luZygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy50ZWNoXy5jdXJyZW50VGltZSgpO1xuICAgICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy50ZWNoXy5idWZmZXJlZCgpO1xuXG4gICAgICBpZiAodGhpcy5sYXN0UmVjb3JkZWRUaW1lID09PSBjdXJyZW50VGltZSAmJiAoIWJ1ZmZlcmVkLmxlbmd0aCB8fCBjdXJyZW50VGltZSArIFNBRkVfVElNRV9ERUxUQSA+PSBidWZmZXJlZC5lbmQoYnVmZmVyZWQubGVuZ3RoIC0gMSkpKSB7XG4gICAgICAgIC8vIElmIGN1cnJlbnQgdGltZSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBmaW5hbCBidWZmZXJlZCByZWdpb24sIHRoZW4gYW55IHBsYXliYWNrXG4gICAgICAgIC8vIHN0YWxsIGlzIG1vc3QgbGlrZWx5IGNhdXNlZCBieSBidWZmZXJpbmcgaW4gYSBsb3cgYmFuZHdpZHRoIGVudmlyb25tZW50LiBUaGUgdGVjaFxuICAgICAgICAvLyBzaG91bGQgZmlyZSBhIGB3YWl0aW5nYCBldmVudCBpbiB0aGlzIHNjZW5hcmlvLCBidXQgZHVlIHRvIGJyb3dzZXIgYW5kIHRlY2hcbiAgICAgICAgLy8gaW5jb25zaXN0ZW5jaWVzLiBDYWxsaW5nIGB0ZWNoV2FpdGluZ19gIGhlcmUgYWxsb3dzIHVzIHRvIHNpbXVsYXRlXG4gICAgICAgIC8vIHJlc3BvbmRpbmcgdG8gYSBuYXRpdmUgYHdhaXRpbmdgIGV2ZW50IHdoZW4gdGhlIHRlY2ggZmFpbHMgdG8gZW1pdCBvbmUuXG4gICAgICAgIHJldHVybiB0aGlzLnRlY2hXYWl0aW5nXygpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb25zZWN1dGl2ZVVwZGF0ZXMgPj0gNSAmJiBjdXJyZW50VGltZSA9PT0gdGhpcy5sYXN0UmVjb3JkZWRUaW1lKSB7XG4gICAgICAgIHRoaXMuY29uc2VjdXRpdmVVcGRhdGVzKys7XG4gICAgICAgIHRoaXMud2FpdGluZ18oKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudFRpbWUgPT09IHRoaXMubGFzdFJlY29yZGVkVGltZSkge1xuICAgICAgICB0aGlzLmNvbnNlY3V0aXZlVXBkYXRlcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb25zZWN1dGl2ZVVwZGF0ZXMgPSAwO1xuICAgICAgICB0aGlzLmxhc3RSZWNvcmRlZFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGFueSBwZW5kaW5nIHRpbWVycyBhbmQgcmVzZXRzIHRoZSAndGltZXVwZGF0ZScgbWVjaGFuaXNtXG4gICAgICogZGVzaWduZWQgdG8gZGV0ZWN0IHRoYXQgd2UgYXJlIHN0YWxsZWRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NhbmNlbFRpbWVyXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbFRpbWVyXygpIHtcbiAgICAgIHRoaXMuY29uc2VjdXRpdmVVcGRhdGVzID0gMDtcblxuICAgICAgaWYgKHRoaXMudGltZXJfKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyXygnY2FuY2VsVGltZXJfJyk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyXyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGltZXJfID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXhlcyBzaXR1YXRpb25zIHdoZXJlIHRoZXJlJ3MgYSBiYWQgc2Vla1xuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBhbiBhY3Rpb24gd2FzIHRha2VuIHRvIGZpeCB0aGUgc2Vla1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpeGVzQmFkU2Vla3NfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml4ZXNCYWRTZWVrc18oKSB7XG4gICAgICB2YXIgc2Vla2luZyA9IHRoaXMudGVjaF8uc2Vla2luZygpO1xuICAgICAgdmFyIHNlZWthYmxlID0gdGhpcy5zZWVrYWJsZSgpO1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy50ZWNoXy5jdXJyZW50VGltZSgpO1xuICAgICAgdmFyIHNlZWtUbyA9IHZvaWQgMDtcblxuICAgICAgaWYgKHNlZWtpbmcgJiYgdGhpcy5hZnRlclNlZWthYmxlV2luZG93XyhzZWVrYWJsZSwgY3VycmVudFRpbWUpKSB7XG4gICAgICAgIHZhciBzZWVrYWJsZUVuZCA9IHNlZWthYmxlLmVuZChzZWVrYWJsZS5sZW5ndGggLSAxKTtcblxuICAgICAgICAvLyBzeW5jIHRvIGxpdmUgcG9pbnQgKGlmIFZPRCwgb3VyIHNlZWthYmxlIHdhcyB1cGRhdGVkIGFuZCB3ZSdyZSBzaW1wbHkgYWRqdXN0aW5nKVxuICAgICAgICBzZWVrVG8gPSBzZWVrYWJsZUVuZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlZWtpbmcgJiYgdGhpcy5iZWZvcmVTZWVrYWJsZVdpbmRvd18oc2Vla2FibGUsIGN1cnJlbnRUaW1lKSkge1xuICAgICAgICB2YXIgc2Vla2FibGVTdGFydCA9IHNlZWthYmxlLnN0YXJ0KDApO1xuXG4gICAgICAgIC8vIHN5bmMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGl2ZSB3aW5kb3dcbiAgICAgICAgLy8gcHJvdmlkZSBhIGJ1ZmZlciBvZiAuMSBzZWNvbmRzIHRvIGhhbmRsZSByb3VuZGluZy9pbXByZWNpc2UgbnVtYmVyc1xuICAgICAgICBzZWVrVG8gPSBzZWVrYWJsZVN0YXJ0ICsgU0FGRV9USU1FX0RFTFRBO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNlZWtUbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5sb2dnZXJfKCdUcnlpbmcgdG8gc2VlayBvdXRzaWRlIG9mIHNlZWthYmxlIGF0IHRpbWUgJyArIGN1cnJlbnRUaW1lICsgJyB3aXRoICcgKyAoJ3NlZWthYmxlIHJhbmdlICcgKyBwcmludGFibGVSYW5nZShzZWVrYWJsZSkgKyAnLiBTZWVraW5nIHRvICcpICsgKHNlZWtUbyArICcuJykpO1xuXG4gICAgICAgIHRoaXMudGVjaF8uc2V0Q3VycmVudFRpbWUoc2Vla1RvKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciBzaXR1YXRpb25zIHdoZW4gd2UgZGV0ZXJtaW5lIHRoZSBwbGF5ZXIgaXMgd2FpdGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3dhaXRpbmdfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2FpdGluZ18oKSB7XG4gICAgICBpZiAodGhpcy50ZWNoV2FpdGluZ18oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbCB0ZWNoIHdhaXRpbmcgY2hlY2tzIGZhaWxlZC4gVXNlIGxhc3QgcmVzb3J0IGNvcnJlY3Rpb25cbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMudGVjaF8uY3VycmVudFRpbWUoKTtcbiAgICAgIHZhciBidWZmZXJlZCA9IHRoaXMudGVjaF8uYnVmZmVyZWQoKTtcbiAgICAgIHZhciBjdXJyZW50UmFuZ2UgPSBmaW5kUmFuZ2UoYnVmZmVyZWQsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgLy8gU29tZXRpbWVzIHRoZSBwbGF5ZXIgY2FuIHN0YWxsIGZvciB1bmtub3duIHJlYXNvbnMgd2l0aGluIGEgY29udGlndW91cyBidWZmZXJlZFxuICAgICAgLy8gcmVnaW9uIHdpdGggbm8gaW5kaWNhdGlvbiB0aGF0IGFueXRoaW5nIGlzIGFtaXNzIChzZWVuIGluIEZpcmVmb3gpLiBTZWVraW5nIHRvXG4gICAgICAvLyBjdXJyZW50VGltZSBpcyB1c3VhbGx5IGVub3VnaCB0byBraWNrc3RhcnQgdGhlIHBsYXllci4gVGhpcyBjaGVja3MgdGhhdCB0aGUgcGxheWVyXG4gICAgICAvLyBpcyBjdXJyZW50bHkgd2l0aGluIGEgYnVmZmVyZWQgcmVnaW9uIGJlZm9yZSBhdHRlbXB0aW5nIGEgY29ycmVjdGl2ZSBzZWVrLlxuICAgICAgLy8gQ2hyb21lIGRvZXMgbm90IGFwcGVhciB0byBjb250aW51ZSBgdGltZXVwZGF0ZWAgZXZlbnRzIGFmdGVyIGEgYHdhaXRpbmdgIGV2ZW50XG4gICAgICAvLyB1bnRpbCB0aGVyZSBpcyB+IDMgc2Vjb25kcyBvZiBmb3J3YXJkIGJ1ZmZlciBhdmFpbGFibGUuIFBsYXliYWNrV2F0Y2hlciBzaG91bGQgYWxzb1xuICAgICAgLy8gbWFrZSBzdXJlIHRoZXJlIGlzIH4zIHNlY29uZHMgb2YgZm9yd2FyZCBidWZmZXIgYmVmb3JlIHRha2luZyBhbnkgY29ycmVjdGl2ZSBhY3Rpb25cbiAgICAgIC8vIHRvIGF2b2lkIHRyaWdnZXJpbmcgYW4gYHVua25vd253YWl0aW5nYCBldmVudCB3aGVuIHRoZSBuZXR3b3JrIGlzIHNsb3cuXG4gICAgICBpZiAoY3VycmVudFJhbmdlLmxlbmd0aCAmJiBjdXJyZW50VGltZSArIDMgPD0gY3VycmVudFJhbmdlLmVuZCgwKSkge1xuICAgICAgICB0aGlzLmNhbmNlbFRpbWVyXygpO1xuICAgICAgICB0aGlzLnRlY2hfLnNldEN1cnJlbnRUaW1lKGN1cnJlbnRUaW1lKTtcblxuICAgICAgICB0aGlzLmxvZ2dlcl8oJ1N0b3BwZWQgYXQgJyArIGN1cnJlbnRUaW1lICsgJyB3aGlsZSBpbnNpZGUgYSBidWZmZXJlZCByZWdpb24gJyArICgnWycgKyBjdXJyZW50UmFuZ2Uuc3RhcnQoMCkgKyAnIC0+ICcgKyBjdXJyZW50UmFuZ2UuZW5kKDApICsgJ10uIEF0dGVtcHRpbmcgdG8gcmVzdW1lICcpICsgJ3BsYXliYWNrIGJ5IHNlZWtpbmcgdG8gdGhlIGN1cnJlbnQgdGltZS4nKTtcblxuICAgICAgICAvLyB1bmtub3duIHdhaXRpbmcgY29ycmVjdGlvbnMgbWF5IGJlIHVzZWZ1bCBmb3IgbW9uaXRvcmluZyBRb1NcbiAgICAgICAgdGhpcy50ZWNoXy50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy11bmtub3duLXdhaXRpbmcnIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3Igc2l0dWF0aW9ucyB3aGVuIHRoZSB0ZWNoIGZpcmVzIGEgYHdhaXRpbmdgIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqICAgICAgICAgVHJ1ZSBpZiBhbiBhY3Rpb24gKG9yIG5vbmUpIHdhcyBuZWVkZWQgdG8gY29ycmVjdCB0aGUgd2FpdGluZy4gRmFsc2UgaWYgbm9cbiAgICAgKiAgICAgICAgIGNoZWNrcyBwYXNzZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0ZWNoV2FpdGluZ18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZWNoV2FpdGluZ18oKSB7XG4gICAgICB2YXIgc2Vla2FibGUgPSB0aGlzLnNlZWthYmxlKCk7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLnRlY2hfLmN1cnJlbnRUaW1lKCk7XG5cbiAgICAgIGlmICh0aGlzLnRlY2hfLnNlZWtpbmcoKSAmJiB0aGlzLmZpeGVzQmFkU2Vla3NfKCkpIHtcbiAgICAgICAgLy8gVGVjaCBpcyBzZWVraW5nIG9yIGJhZCBzZWVrIGZpeGVkLCBubyBhY3Rpb24gbmVlZGVkXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50ZWNoXy5zZWVraW5nKCkgfHwgdGhpcy50aW1lcl8gIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGVjaCBpcyBzZWVraW5nIG9yIGFscmVhZHkgd2FpdGluZyBvbiBhbm90aGVyIGFjdGlvbiwgbm8gYWN0aW9uIG5lZWRlZFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmVmb3JlU2Vla2FibGVXaW5kb3dfKHNlZWthYmxlLCBjdXJyZW50VGltZSkpIHtcbiAgICAgICAgdmFyIGxpdmVQb2ludCA9IHNlZWthYmxlLmVuZChzZWVrYWJsZS5sZW5ndGggLSAxKTtcblxuICAgICAgICB0aGlzLmxvZ2dlcl8oJ0ZlbGwgb3V0IG9mIGxpdmUgd2luZG93IGF0IHRpbWUgJyArIGN1cnJlbnRUaW1lICsgJy4gU2Vla2luZyB0byAnICsgKCdsaXZlIHBvaW50IChzZWVrYWJsZSBlbmQpICcgKyBsaXZlUG9pbnQpKTtcbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lcl8oKTtcbiAgICAgICAgdGhpcy50ZWNoXy5zZXRDdXJyZW50VGltZShsaXZlUG9pbnQpO1xuXG4gICAgICAgIC8vIGxpdmUgd2luZG93IHJlc3luY3MgbWF5IGJlIHVzZWZ1bCBmb3IgbW9uaXRvcmluZyBRb1NcbiAgICAgICAgdGhpcy50ZWNoXy50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy1saXZlLXJlc3luYycgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnRlY2hfLmJ1ZmZlcmVkKCk7XG4gICAgICB2YXIgbmV4dFJhbmdlID0gZmluZE5leHRSYW5nZShidWZmZXJlZCwgY3VycmVudFRpbWUpO1xuXG4gICAgICBpZiAodGhpcy52aWRlb1VuZGVyZmxvd18obmV4dFJhbmdlLCBidWZmZXJlZCwgY3VycmVudFRpbWUpKSB7XG4gICAgICAgIC8vIEV2ZW4gdGhvdWdoIHRoZSB2aWRlbyB1bmRlcmZsb3dlZCBhbmQgd2FzIHN0dWNrIGluIGEgZ2FwLCB0aGUgYXVkaW8gb3ZlcnBsYXllZFxuICAgICAgICAvLyB0aGUgZ2FwLCBsZWFkaW5nIGN1cnJlbnRUaW1lIGludG8gYSBidWZmZXJlZCByYW5nZS4gU2Vla2luZyB0byBjdXJyZW50VGltZVxuICAgICAgICAvLyBhbGxvd3MgdGhlIHZpZGVvIHRvIGNhdGNoIHVwIHRvIHRoZSBhdWRpbyBwb3NpdGlvbiB3aXRob3V0IGxvc2luZyBhbnkgYXVkaW9cbiAgICAgICAgLy8gKG9ubHkgc3VmZmVyaW5nIH4zIHNlY29uZHMgb2YgZnJvemVuIHZpZGVvIGFuZCBhIHBhdXNlIGluIGF1ZGlvIHBsYXliYWNrKS5cbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lcl8oKTtcbiAgICAgICAgdGhpcy50ZWNoXy5zZXRDdXJyZW50VGltZShjdXJyZW50VGltZSk7XG5cbiAgICAgICAgLy8gdmlkZW8gdW5kZXJmbG93IG1heSBiZSB1c2VmdWwgZm9yIG1vbml0b3JpbmcgUW9TXG4gICAgICAgIHRoaXMudGVjaF8udHJpZ2dlcih7IHR5cGU6ICd1c2FnZScsIG5hbWU6ICdobHMtdmlkZW8tdW5kZXJmbG93JyB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvciBnYXBcbiAgICAgIGlmIChuZXh0UmFuZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IG5leHRSYW5nZS5zdGFydCgwKSAtIGN1cnJlbnRUaW1lO1xuXG4gICAgICAgIHRoaXMubG9nZ2VyXygnU3RvcHBlZCBhdCAnICsgY3VycmVudFRpbWUgKyAnLCBzZXR0aW5nIHRpbWVyIGZvciAnICsgZGlmZmVyZW5jZSArICcsIHNlZWtpbmcgJyArICgndG8gJyArIG5leHRSYW5nZS5zdGFydCgwKSkpO1xuXG4gICAgICAgIHRoaXMudGltZXJfID0gc2V0VGltZW91dCh0aGlzLnNraXBUaGVHYXBfLmJpbmQodGhpcyksIGRpZmZlcmVuY2UgKiAxMDAwLCBjdXJyZW50VGltZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGwgY2hlY2tzIGZhaWxlZC4gUmV0dXJuaW5nIGZhbHNlIHRvIGluZGljYXRlIGZhaWx1cmUgdG8gY29ycmVjdCB3YWl0aW5nXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWZ0ZXJTZWVrYWJsZVdpbmRvd18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZnRlclNlZWthYmxlV2luZG93XyhzZWVrYWJsZSwgY3VycmVudFRpbWUpIHtcbiAgICAgIGlmICghc2Vla2FibGUubGVuZ3RoKSB7XG4gICAgICAgIC8vIHdlIGNhbid0IG1ha2UgYSBzb2xpZCBjYXNlIGlmIHRoZXJlJ3Mgbm8gc2Vla2FibGUsIGRlZmF1bHQgdG8gZmFsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudFRpbWUgPiBzZWVrYWJsZS5lbmQoc2Vla2FibGUubGVuZ3RoIC0gMSkgKyBTQUZFX1RJTUVfREVMVEEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdiZWZvcmVTZWVrYWJsZVdpbmRvd18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmVTZWVrYWJsZVdpbmRvd18oc2Vla2FibGUsIGN1cnJlbnRUaW1lKSB7XG4gICAgICBpZiAoc2Vla2FibGUubGVuZ3RoICYmXG4gICAgICAvLyBjYW4ndCBmYWxsIGJlZm9yZSAwIGFuZCAwIHNlZWthYmxlIHN0YXJ0IGlkZW50aWZpZXMgVk9EIHN0cmVhbVxuICAgICAgc2Vla2FibGUuc3RhcnQoMCkgPiAwICYmIGN1cnJlbnRUaW1lIDwgc2Vla2FibGUuc3RhcnQoMCkgLSBTQUZFX1RJTUVfREVMVEEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd2aWRlb1VuZGVyZmxvd18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlb1VuZGVyZmxvd18obmV4dFJhbmdlLCBidWZmZXJlZCwgY3VycmVudFRpbWUpIHtcbiAgICAgIGlmIChuZXh0UmFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIEV2ZW4gaWYgdGhlcmUgaXMgbm8gYXZhaWxhYmxlIG5leHQgcmFuZ2UsIHRoZXJlIGlzIHN0aWxsIGEgcG9zc2liaWxpdHkgd2UgYXJlXG4gICAgICAgIC8vIHN0dWNrIGluIGEgZ2FwIGR1ZSB0byB2aWRlbyB1bmRlcmZsb3cuXG4gICAgICAgIHZhciBnYXAgPSB0aGlzLmdhcEZyb21WaWRlb1VuZGVyZmxvd18oYnVmZmVyZWQsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgICBpZiAoZ2FwKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXJfKCdFbmNvdW50ZXJlZCBhIGdhcCBpbiB2aWRlbyBmcm9tICcgKyBnYXAuc3RhcnQgKyAnIHRvICcgKyBnYXAuZW5kICsgJy4gJyArICgnU2Vla2luZyB0byBjdXJyZW50IHRpbWUgJyArIGN1cnJlbnRUaW1lKSk7XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGltZXIgY2FsbGJhY2suIElmIHBsYXliYWNrIHN0aWxsIGhhcyBub3QgcHJvY2VlZGVkLCB0aGVuIHdlIHNlZWtcbiAgICAgKiB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHQgYnVmZmVyZWQgcmVnaW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2tpcFRoZUdhcF8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBza2lwVGhlR2FwXyhzY2hlZHVsZWRDdXJyZW50VGltZSkge1xuICAgICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy50ZWNoXy5idWZmZXJlZCgpO1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy50ZWNoXy5jdXJyZW50VGltZSgpO1xuICAgICAgdmFyIG5leHRSYW5nZSA9IGZpbmROZXh0UmFuZ2UoYnVmZmVyZWQsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgdGhpcy5jYW5jZWxUaW1lcl8oKTtcblxuICAgICAgaWYgKG5leHRSYW5nZS5sZW5ndGggPT09IDAgfHwgY3VycmVudFRpbWUgIT09IHNjaGVkdWxlZEN1cnJlbnRUaW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2dnZXJfKCdza2lwVGhlR2FwXzonLCAnY3VycmVudFRpbWU6JywgY3VycmVudFRpbWUsICdzY2hlZHVsZWQgY3VycmVudFRpbWU6Jywgc2NoZWR1bGVkQ3VycmVudFRpbWUsICduZXh0UmFuZ2Ugc3RhcnQ6JywgbmV4dFJhbmdlLnN0YXJ0KDApKTtcblxuICAgICAgLy8gb25seSBzZWVrIGlmIHdlIHN0aWxsIGhhdmUgbm90IHBsYXllZFxuICAgICAgdGhpcy50ZWNoXy5zZXRDdXJyZW50VGltZShuZXh0UmFuZ2Uuc3RhcnQoMCkgKyBUSU1FX0ZVREdFX0ZBQ1RPUik7XG5cbiAgICAgIHRoaXMudGVjaF8udHJpZ2dlcih7IHR5cGU6ICd1c2FnZScsIG5hbWU6ICdobHMtZ2FwLXNraXAnIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dhcEZyb21WaWRlb1VuZGVyZmxvd18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnYXBGcm9tVmlkZW9VbmRlcmZsb3dfKGJ1ZmZlcmVkLCBjdXJyZW50VGltZSkge1xuICAgICAgLy8gQXQgbGVhc3QgaW4gQ2hyb21lLCBpZiB0aGVyZSBpcyBhIGdhcCBpbiB0aGUgdmlkZW8gYnVmZmVyLCB0aGUgYXVkaW8gd2lsbCBjb250aW51ZVxuICAgICAgLy8gcGxheWluZyBmb3IgfjMgc2Vjb25kcyBhZnRlciB0aGUgdmlkZW8gZ2FwIHN0YXJ0cy4gVGhpcyBpcyBkb25lIHRvIGFjY291bnQgZm9yXG4gICAgICAvLyB2aWRlbyBidWZmZXIgdW5kZXJmbG93L3VuZGVycnVuIChub3RlIHRoYXQgdGhpcyBpcyBub3QgZG9uZSB3aGVuIHRoZXJlIGlzIGF1ZGlvXG4gICAgICAvLyBidWZmZXIgdW5kZXJmbG93L3VuZGVycnVuIC0tIGluIHRoYXQgY2FzZSB0aGUgdmlkZW8gd2lsbCBzdG9wIGFzIHNvb24gYXMgaXRcbiAgICAgIC8vIGVuY291bnRlcnMgdGhlIGdhcCwgYXMgYXVkaW8gc3RhbGxzIGFyZSBtb3JlIG5vdGljZWFibGUvamFycmluZyB0byBhIHVzZXIgdGhhblxuICAgICAgLy8gdmlkZW8gc3RhbGxzKS4gVGhlIHBsYXllcidzIHRpbWUgd2lsbCByZWZsZWN0IHRoZSBwbGF5dGhyb3VnaCBvZiBhdWRpbywgc28gdGhlXG4gICAgICAvLyB0aW1lIHdpbGwgYXBwZWFyIGFzIGlmIHdlIGFyZSBpbiBhIGJ1ZmZlcmVkIHJlZ2lvbiwgZXZlbiBpZiB3ZSBhcmUgc3R1Y2sgaW4gYVxuICAgICAgLy8gXCJnYXAuXCJcbiAgICAgIC8vXG4gICAgICAvLyBFeGFtcGxlOlxuICAgICAgLy8gdmlkZW8gYnVmZmVyOiAgIDAgPT4gMTAuMSwgMTAuMiA9PiAyMFxuICAgICAgLy8gYXVkaW8gYnVmZmVyOiAgIDAgPT4gMjBcbiAgICAgIC8vIG92ZXJhbGwgYnVmZmVyOiAwID0+IDEwLjEsIDEwLjIgPT4gMjBcbiAgICAgIC8vIGN1cnJlbnQgdGltZTogMTNcbiAgICAgIC8vXG4gICAgICAvLyBDaHJvbWUncyB2aWRlbyBmcm96ZSBhdCAxMCBzZWNvbmRzLCB3aGVyZSB0aGUgdmlkZW8gYnVmZmVyIGVuY291bnRlcmVkIHRoZSBnYXAsXG4gICAgICAvLyBob3dldmVyLCB0aGUgYXVkaW8gY29udGludWVkIHBsYXlpbmcgdW50aWwgaXQgcmVhY2hlZCB+MyBzZWNvbmRzIHBhc3QgdGhlIGdhcFxuICAgICAgLy8gKDEzIHNlY29uZHMpLCBhdCB3aGljaCBwb2ludCBpdCBzdG9wcyBhcyB3ZWxsLiBTaW5jZSBjdXJyZW50IHRpbWUgaXMgcGFzdCB0aGVcbiAgICAgIC8vIGdhcCwgZmluZE5leHRSYW5nZSB3aWxsIHJldHVybiBubyByYW5nZXMuXG4gICAgICAvL1xuICAgICAgLy8gVG8gY2hlY2sgZm9yIHRoaXMgaXNzdWUsIHdlIHNlZSBpZiB0aGVyZSBpcyBhIGdhcCB0aGF0IHN0YXJ0cyBzb21ld2hlcmUgd2l0aGluXG4gICAgICAvLyBhIDMgc2Vjb25kIHJhbmdlICgzIHNlY29uZHMgKy8tIDEgc2Vjb25kKSBiYWNrIGZyb20gb3VyIGN1cnJlbnQgdGltZS5cbiAgICAgIHZhciBnYXBzID0gZmluZEdhcHMoYnVmZmVyZWQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdhcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZ2Fwcy5zdGFydChpKTtcbiAgICAgICAgdmFyIGVuZCA9IGdhcHMuZW5kKGkpO1xuXG4gICAgICAgIC8vIGdhcCBpcyBzdGFydHMgbm8gbW9yZSB0aGFuIDQgc2Vjb25kcyBiYWNrXG4gICAgICAgIGlmIChjdXJyZW50VGltZSAtIHN0YXJ0IDwgNCAmJiBjdXJyZW50VGltZSAtIHN0YXJ0ID4gMikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQbGF5YmFja1dhdGNoZXI7XG59KCk7XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZXJyb3JJbnRlcnZhbDogMzAsXG4gIGdldFNvdXJjZTogZnVuY3Rpb24gZ2V0U291cmNlKG5leHQpIHtcbiAgICB2YXIgdGVjaCA9IHRoaXMudGVjaCh7IElXaWxsTm90VXNlVGhpc0luUGx1Z2luczogdHJ1ZSB9KTtcbiAgICB2YXIgc291cmNlT2JqID0gdGVjaC5jdXJyZW50U291cmNlXztcblxuICAgIHJldHVybiBuZXh0KHNvdXJjZU9iaik7XG4gIH1cbn07XG5cbi8qKlxuICogTWFpbiBlbnRyeSBwb2ludCBmb3IgdGhlIHBsdWdpblxuICpcbiAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXIgYSByZWZlcmVuY2UgdG8gYSB2aWRlb2pzIFBsYXllciBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBhbiBvYmplY3Qgd2l0aCBwbHVnaW4gb3B0aW9uc1xuICogQHByaXZhdGVcbiAqL1xudmFyIGluaXRQbHVnaW4gPSBmdW5jdGlvbiBpbml0UGx1Z2luKHBsYXllciwgb3B0aW9ucykge1xuICB2YXIgbGFzdENhbGxlZCA9IDA7XG4gIHZhciBzZWVrVG8gPSAwO1xuICB2YXIgbG9jYWxPcHRpb25zID0gdmlkZW9qcyQxLm1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgcGxheWVyLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICBwbGF5ZXIudHJpZ2dlcih7IHR5cGU6ICd1c2FnZScsIG5hbWU6ICdobHMtZXJyb3ItcmVsb2FkLWluaXRpYWxpemVkJyB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFBsYXllciBtb2RpZmljYXRpb25zIHRvIHBlcmZvcm0gdGhhdCBtdXN0IHdhaXQgdW50aWwgYGxvYWRlZG1ldGFkYXRhYFxuICAgKiBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBsb2FkZWRNZXRhZGF0YUhhbmRsZXIgPSBmdW5jdGlvbiBsb2FkZWRNZXRhZGF0YUhhbmRsZXIoKSB7XG4gICAgaWYgKHNlZWtUbykge1xuICAgICAgcGxheWVyLmN1cnJlbnRUaW1lKHNlZWtUbyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBvbiB0aGUgcGxheWVyIGVsZW1lbnQsIHBsYXksIGFuZCBzZWVrIGlmIG5lY2Vzc2FyeVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlT2JqIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBzb3VyY2UgdXJsIGFuZCBtaW1lLXR5cGUgdG8gcGxheVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIHNldFNvdXJjZSA9IGZ1bmN0aW9uIHNldFNvdXJjZShzb3VyY2VPYmopIHtcbiAgICBpZiAoc291cmNlT2JqID09PSBudWxsIHx8IHNvdXJjZU9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlZWtUbyA9IHBsYXllci5kdXJhdGlvbigpICE9PSBJbmZpbml0eSAmJiBwbGF5ZXIuY3VycmVudFRpbWUoKSB8fCAwO1xuXG4gICAgcGxheWVyLm9uZSgnbG9hZGVkbWV0YWRhdGEnLCBsb2FkZWRNZXRhZGF0YUhhbmRsZXIpO1xuXG4gICAgcGxheWVyLnNyYyhzb3VyY2VPYmopO1xuICAgIHBsYXllci50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy1lcnJvci1yZWxvYWQnIH0pO1xuICAgIHBsYXllci5wbGF5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gZ2V0IGEgc291cmNlIGZyb20gZWl0aGVyIHRoZSBidWlsdC1pbiBnZXRTb3VyY2UgZnVuY3Rpb25cbiAgICogb3IgYSBjdXN0b20gZnVuY3Rpb24gcHJvdmlkZWQgdmlhIHRoZSBvcHRpb25zXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gZXJyb3JIYW5kbGVyKCkge1xuICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHJlbG9hZCB0aGUgc291cmNlIGlmIGEgc291cmNlLXJlbG9hZCBvY2N1cnJlZCBiZWZvcmVcbiAgICAvLyAnZXJyb3JJbnRlcnZhbCcgdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBzb3VyY2UtcmVsb2FkXG4gICAgaWYgKERhdGUubm93KCkgLSBsYXN0Q2FsbGVkIDwgbG9jYWxPcHRpb25zLmVycm9ySW50ZXJ2YWwgKiAxMDAwKSB7XG4gICAgICBwbGF5ZXIudHJpZ2dlcih7IHR5cGU6ICd1c2FnZScsIG5hbWU6ICdobHMtZXJyb3ItcmVsb2FkLWNhbmNlbGVkJyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWxvY2FsT3B0aW9ucy5nZXRTb3VyY2UgfHwgdHlwZW9mIGxvY2FsT3B0aW9ucy5nZXRTb3VyY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZpZGVvanMkMS5sb2cuZXJyb3IoJ0VSUk9SOiByZWxvYWRTb3VyY2VPbkVycm9yIC0gVGhlIG9wdGlvbiBnZXRTb3VyY2UgbXVzdCBiZSBhIGZ1bmN0aW9uIScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXN0Q2FsbGVkID0gRGF0ZS5ub3coKTtcblxuICAgIHJldHVybiBsb2NhbE9wdGlvbnMuZ2V0U291cmNlLmNhbGwocGxheWVyLCBzZXRTb3VyY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbmJpbmQgYW55IGV2ZW50IGhhbmRsZXJzIHRoYXQgd2VyZSBib3VuZCBieSB0aGUgcGx1Z2luXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgY2xlYW51cEV2ZW50cyA9IGZ1bmN0aW9uIGNsZWFudXBFdmVudHMoKSB7XG4gICAgcGxheWVyLm9mZignbG9hZGVkbWV0YWRhdGEnLCBsb2FkZWRNZXRhZGF0YUhhbmRsZXIpO1xuICAgIHBsYXllci5vZmYoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcbiAgICBwbGF5ZXIub2ZmKCdkaXNwb3NlJywgY2xlYW51cEV2ZW50cyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFudXAgYmVmb3JlIHJlLWluaXRpYWxpemluZyB0aGUgcGx1Z2luXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbbmV3T3B0aW9uc10gYW4gb2JqZWN0IHdpdGggcGx1Z2luIG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciByZWluaXRQbHVnaW4gPSBmdW5jdGlvbiByZWluaXRQbHVnaW4obmV3T3B0aW9ucykge1xuICAgIGNsZWFudXBFdmVudHMoKTtcbiAgICBpbml0UGx1Z2luKHBsYXllciwgbmV3T3B0aW9ucyk7XG4gIH07XG5cbiAgcGxheWVyLm9uKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG4gIHBsYXllci5vbignZGlzcG9zZScsIGNsZWFudXBFdmVudHMpO1xuXG4gIC8vIE92ZXJ3cml0ZSB0aGUgcGx1Z2luIGZ1bmN0aW9uIHNvIHRoYXQgd2UgY2FuIGNvcnJlY3RseSBjbGVhbnVwIGJlZm9yZVxuICAvLyBpbml0aWFsaXppbmcgdGhlIHBsdWdpblxuICBwbGF5ZXIucmVsb2FkU291cmNlT25FcnJvciA9IHJlaW5pdFBsdWdpbjtcbn07XG5cbi8qKlxuICogUmVsb2FkIHRoZSBzb3VyY2Ugd2hlbiBhbiBlcnJvciBpcyBkZXRlY3RlZCBhcyBsb25nIGFzIHRoZXJlXG4gKiB3YXNuJ3QgYW4gZXJyb3IgcHJldmlvdXNseSB3aXRoaW4gdGhlIGxhc3QgMzAgc2Vjb25kc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gYW4gb2JqZWN0IHdpdGggcGx1Z2luIG9wdGlvbnNcbiAqL1xudmFyIHJlbG9hZFNvdXJjZU9uRXJyb3IgPSBmdW5jdGlvbiByZWxvYWRTb3VyY2VPbkVycm9yKG9wdGlvbnMpIHtcbiAgaW5pdFBsdWdpbih0aGlzLCBvcHRpb25zKTtcbn07XG5cbnZhciB2ZXJzaW9uJDEgPSBcIjEuMS4wXCI7XG5cbi8qKlxuICogQGZpbGUgdmlkZW9qcy1odHRwLXN0cmVhbWluZy5qc1xuICpcbiAqIFRoZSBtYWluIGZpbGUgZm9yIHRoZSBITFMgcHJvamVjdC5cbiAqIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvanMtaHR0cC1zdHJlYW1pbmcvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbnZhciBIbHMkMSA9IHtcbiAgUGxheWxpc3RMb2FkZXI6IFBsYXlsaXN0TG9hZGVyLFxuICBQbGF5bGlzdDogUGxheWxpc3QsXG4gIERlY3J5cHRlcjogRGVjcnlwdGVyLFxuICBBc3luY1N0cmVhbTogQXN5bmNTdHJlYW0sXG4gIGRlY3J5cHQ6IGRlY3J5cHQsXG4gIHV0aWxzOiB1dGlscyxcblxuICBTVEFOREFSRF9QTEFZTElTVF9TRUxFQ1RPUjogbGFzdEJhbmR3aWR0aFNlbGVjdG9yLFxuICBJTklUSUFMX1BMQVlMSVNUX1NFTEVDVE9SOiBsb3dlc3RCaXRyYXRlQ29tcGF0aWJsZVZhcmlhbnRTZWxlY3RvcixcbiAgY29tcGFyZVBsYXlsaXN0QmFuZHdpZHRoOiBjb21wYXJlUGxheWxpc3RCYW5kd2lkdGgsXG4gIGNvbXBhcmVQbGF5bGlzdFJlc29sdXRpb246IGNvbXBhcmVQbGF5bGlzdFJlc29sdXRpb24sXG5cbiAgeGhyOiB4aHJGYWN0b3J5KClcbn07XG5cbi8vIDAuNSBNQi9zXG52YXIgSU5JVElBTF9CQU5EV0lEVEggPSA0MTk0MzA0O1xuXG4vLyBEZWZpbmUgZ2V0dGVyL3NldHRlcnMgZm9yIGNvbmZpZyBwcm9wZXJpdGVzXG5bJ0dPQUxfQlVGRkVSX0xFTkdUSCcsICdNQVhfR09BTF9CVUZGRVJfTEVOR1RIJywgJ0dPQUxfQlVGRkVSX0xFTkdUSF9SQVRFJywgJ0JVRkZFUl9MT1dfV0FURVJfTElORScsICdNQVhfQlVGRkVSX0xPV19XQVRFUl9MSU5FJywgJ0JVRkZFUl9MT1dfV0FURVJfTElORV9SQVRFJywgJ0JBTkRXSURUSF9WQVJJQU5DRSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscyQxLCBwcm9wLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICB2aWRlb2pzJDEubG9nLndhcm4oJ3VzaW5nIEhscy4nICsgcHJvcCArICcgaXMgVU5TQUZFIGJlIHN1cmUgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nJyk7XG4gICAgICByZXR1cm4gQ29uZmlnW3Byb3BdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodmFsdWUpIHtcbiAgICAgIHZpZGVvanMkMS5sb2cud2FybigndXNpbmcgSGxzLicgKyBwcm9wICsgJyBpcyBVTlNBRkUgYmUgc3VyZSB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcnKTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgIHZpZGVvanMkMS5sb2cud2FybigndmFsdWUgb2YgSGxzLicgKyBwcm9wICsgJyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgQ29uZmlnW3Byb3BdID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgc2ltcGxlVHlwZUZyb21Tb3VyY2VUeXBlID0gZnVuY3Rpb24gc2ltcGxlVHlwZUZyb21Tb3VyY2VUeXBlKHR5cGUpIHtcbiAgdmFyIG1wZWd1cmxSRSA9IC9eKGF1ZGlvfHZpZGVvfGFwcGxpY2F0aW9uKVxcLyh4LXx2bmRcXC5hcHBsZVxcLik/bXBlZ3VybC9pO1xuXG4gIGlmIChtcGVndXJsUkUudGVzdCh0eXBlKSkge1xuICAgIHJldHVybiAnaGxzJztcbiAgfVxuXG4gIHZhciBkYXNoUkUgPSAvXmFwcGxpY2F0aW9uXFwvZGFzaFxcK3htbC9pO1xuXG4gIGlmIChkYXNoUkUudGVzdCh0eXBlKSkge1xuICAgIHJldHVybiAnZGFzaCc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgc2VsZWN0ZWRJbmRleCBvZiB0aGUgUXVhbGl0eUxldmVsTGlzdCB3aGVuIGEgbWVkaWFjaGFuZ2UgaGFwcGVucyBpbiBobHMuXG4gKlxuICogQHBhcmFtIHtRdWFsaXR5TGV2ZWxMaXN0fSBxdWFsaXR5TGV2ZWxzIFRoZSBRdWFsaXR5TGV2ZWxMaXN0IHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7UGxheWxpc3RMb2FkZXJ9IHBsYXlsaXN0TG9hZGVyIFBsYXlsaXN0TG9hZGVyIGNvbnRhaW5pbmcgdGhlIG5ldyBtZWRpYSBpbmZvLlxuICogQGZ1bmN0aW9uIGhhbmRsZUhsc01lZGlhQ2hhbmdlXG4gKi9cbnZhciBoYW5kbGVIbHNNZWRpYUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhsc01lZGlhQ2hhbmdlKHF1YWxpdHlMZXZlbHMsIHBsYXlsaXN0TG9hZGVyKSB7XG4gIHZhciBuZXdQbGF5bGlzdCA9IHBsYXlsaXN0TG9hZGVyLm1lZGlhKCk7XG4gIHZhciBzZWxlY3RlZEluZGV4ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWFsaXR5TGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHF1YWxpdHlMZXZlbHNbaV0uaWQgPT09IG5ld1BsYXlsaXN0LnVyaSkge1xuICAgICAgc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBxdWFsaXR5TGV2ZWxzLnNlbGVjdGVkSW5kZXhfID0gc2VsZWN0ZWRJbmRleDtcbiAgcXVhbGl0eUxldmVscy50cmlnZ2VyKHtcbiAgICBzZWxlY3RlZEluZGV4OiBzZWxlY3RlZEluZGV4LFxuICAgIHR5cGU6ICdjaGFuZ2UnXG4gIH0pO1xufTtcblxuLyoqXG4gKiBBZGRzIHF1YWxpdHkgbGV2ZWxzIHRvIGxpc3Qgb25jZSBwbGF5bGlzdCBtZXRhZGF0YSBpcyBhdmFpbGFibGVcbiAqXG4gKiBAcGFyYW0ge1F1YWxpdHlMZXZlbExpc3R9IHF1YWxpdHlMZXZlbHMgVGhlIFF1YWxpdHlMZXZlbExpc3QgdG8gYXR0YWNoIGV2ZW50cyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBobHMgSGxzIG9iamVjdCB0byBsaXN0ZW4gdG8gZm9yIG1lZGlhIGV2ZW50cy5cbiAqIEBmdW5jdGlvbiBoYW5kbGVIbHNMb2FkZWRNZXRhZGF0YVxuICovXG52YXIgaGFuZGxlSGxzTG9hZGVkTWV0YWRhdGEgPSBmdW5jdGlvbiBoYW5kbGVIbHNMb2FkZWRNZXRhZGF0YShxdWFsaXR5TGV2ZWxzLCBobHMpIHtcbiAgaGxzLnJlcHJlc2VudGF0aW9ucygpLmZvckVhY2goZnVuY3Rpb24gKHJlcCkge1xuICAgIHF1YWxpdHlMZXZlbHMuYWRkUXVhbGl0eUxldmVsKHJlcCk7XG4gIH0pO1xuICBoYW5kbGVIbHNNZWRpYUNoYW5nZShxdWFsaXR5TGV2ZWxzLCBobHMucGxheWxpc3RzKTtcbn07XG5cbi8vIEhMUyBpcyBhIHNvdXJjZSBoYW5kbGVyLCBub3QgYSB0ZWNoLiBNYWtlIHN1cmUgYXR0ZW1wdHMgdG8gdXNlIGl0XG4vLyBhcyBvbmUgZG8gbm90IGNhdXNlIGV4Y2VwdGlvbnMuXG5IbHMkMS5jYW5QbGF5U291cmNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdmlkZW9qcyQxLmxvZy53YXJuKCdITFMgaXMgbm8gbG9uZ2VyIGEgdGVjaC4gUGxlYXNlIHJlbW92ZSBpdCBmcm9tICcgKyAneW91ciBwbGF5ZXJcXCdzIHRlY2hPcmRlci4nKTtcbn07XG5cbnZhciBlbWVLZXlTeXN0ZW1zID0gZnVuY3Rpb24gZW1lS2V5U3lzdGVtcyhrZXlTeXN0ZW1PcHRpb25zLCB2aWRlb1BsYXlsaXN0LCBhdWRpb1BsYXlsaXN0KSB7XG4gIGlmICgha2V5U3lzdGVtT3B0aW9ucykge1xuICAgIHJldHVybiBrZXlTeXN0ZW1PcHRpb25zO1xuICB9XG5cbiAgLy8gdXBzZXJ0IHRoZSBjb250ZW50IHR5cGVzIGJhc2VkIG9uIHRoZSBzZWxlY3RlZCBwbGF5bGlzdFxuICB2YXIga2V5U3lzdGVtQ29udGVudFR5cGVzID0ge307XG5cbiAgZm9yICh2YXIga2V5U3lzdGVtIGluIGtleVN5c3RlbU9wdGlvbnMpIHtcbiAgICBrZXlTeXN0ZW1Db250ZW50VHlwZXNba2V5U3lzdGVtXSA9IHtcbiAgICAgIGF1ZGlvQ29udGVudFR5cGU6ICdhdWRpby9tcDQ7IGNvZGVjcz1cIicgKyBhdWRpb1BsYXlsaXN0LmF0dHJpYnV0ZXMuQ09ERUNTICsgJ1wiJyxcbiAgICAgIHZpZGVvQ29udGVudFR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIicgKyB2aWRlb1BsYXlsaXN0LmF0dHJpYnV0ZXMuQ09ERUNTICsgJ1wiJ1xuICAgIH07XG5cbiAgICBpZiAodmlkZW9QbGF5bGlzdC5jb250ZW50UHJvdGVjdGlvbiAmJiB2aWRlb1BsYXlsaXN0LmNvbnRlbnRQcm90ZWN0aW9uW2tleVN5c3RlbV0gJiYgdmlkZW9QbGF5bGlzdC5jb250ZW50UHJvdGVjdGlvbltrZXlTeXN0ZW1dLnBzc2gpIHtcbiAgICAgIGtleVN5c3RlbUNvbnRlbnRUeXBlc1trZXlTeXN0ZW1dLnBzc2ggPSB2aWRlb1BsYXlsaXN0LmNvbnRlbnRQcm90ZWN0aW9uW2tleVN5c3RlbV0ucHNzaDtcbiAgICB9XG5cbiAgICAvLyB2aWRlb2pzLWNvbnRyaWItZW1lIGFjY2VwdHMgdGhlIG9wdGlvbiBvZiBzcGVjaWZ5aW5nOiAnY29tLnNvbWUuY2RtJzogJ3VybCdcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIHByZXZlbnQgb3ZlcndyaXRpbmcgdGhlIFVSTCBlbnRpcmVseVxuICAgIGlmICh0eXBlb2Yga2V5U3lzdGVtT3B0aW9uc1trZXlTeXN0ZW1dID09PSAnc3RyaW5nJykge1xuICAgICAga2V5U3lzdGVtQ29udGVudFR5cGVzW2tleVN5c3RlbV0udXJsID0ga2V5U3lzdGVtT3B0aW9uc1trZXlTeXN0ZW1dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2aWRlb2pzJDEubWVyZ2VPcHRpb25zKGtleVN5c3RlbU9wdGlvbnMsIGtleVN5c3RlbUNvbnRlbnRUeXBlcyk7XG59O1xuXG52YXIgc2V0dXBFbWVPcHRpb25zID0gZnVuY3Rpb24gc2V0dXBFbWVPcHRpb25zKGhsc0hhbmRsZXIpIHtcbiAgaWYgKGhsc0hhbmRsZXIub3B0aW9uc18uc291cmNlVHlwZSAhPT0gJ2Rhc2gnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwbGF5ZXIgPSB2aWRlb2pzJDEucGxheWVyc1tobHNIYW5kbGVyLnRlY2hfLm9wdGlvbnNfLnBsYXllcklkXTtcblxuICBpZiAocGxheWVyLmVtZSkge1xuICAgIHZhciBzb3VyY2VPcHRpb25zID0gZW1lS2V5U3lzdGVtcyhobHNIYW5kbGVyLnNvdXJjZV8ua2V5U3lzdGVtcywgaGxzSGFuZGxlci5wbGF5bGlzdHMubWVkaWEoKSwgaGxzSGFuZGxlci5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1lZGlhVHlwZXNfLkFVRElPLmFjdGl2ZVBsYXlsaXN0TG9hZGVyLm1lZGlhKCkpO1xuXG4gICAgaWYgKHNvdXJjZU9wdGlvbnMpIHtcbiAgICAgIHBsYXllci5jdXJyZW50U291cmNlKCkua2V5U3lzdGVtcyA9IHNvdXJjZU9wdGlvbnM7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgaGFzIGJ1aWx0LWluIEhMUyBzdXBwb3J0LlxuICovXG5IbHMkMS5zdXBwb3J0c05hdGl2ZUhscyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcblxuICAvLyBuYXRpdmUgSExTIGlzIGRlZmluaXRlbHkgbm90IHN1cHBvcnRlZCBpZiBIVE1MNSB2aWRlbyBpc24ndFxuICBpZiAoIXZpZGVvanMkMS5nZXRUZWNoKCdIdG1sNScpLmlzU3VwcG9ydGVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBITFMgbWFuaWZlc3RzIGNhbiBnbyBieSBtYW55IG1pbWUtdHlwZXNcbiAgdmFyIGNhblBsYXkgPSBbXG4gIC8vIEFwcGxlIHNhbnRpb25lZFxuICAnYXBwbGljYXRpb24vdm5kLmFwcGxlLm1wZWd1cmwnLFxuICAvLyBBcHBsZSBzYW5jdGlvbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAnYXVkaW8vbXBlZ3VybCcsXG4gIC8vIFZlcnkgY29tbW9uXG4gICdhdWRpby94LW1wZWd1cmwnLFxuICAvLyBWZXJ5IGNvbW1vblxuICAnYXBwbGljYXRpb24veC1tcGVndXJsJyxcbiAgLy8gSW5jbHVkZWQgZm9yIGNvbXBsZXRlbmVzc1xuICAndmlkZW8veC1tcGVndXJsJywgJ3ZpZGVvL21wZWd1cmwnLCAnYXBwbGljYXRpb24vbXBlZ3VybCddO1xuXG4gIHJldHVybiBjYW5QbGF5LnNvbWUoZnVuY3Rpb24gKGNhbkl0UGxheSkge1xuICAgIHJldHVybiAoL21heWJlfHByb2JhYmx5L2kudGVzdCh2aWRlby5jYW5QbGF5VHlwZShjYW5JdFBsYXkpKVxuICAgICk7XG4gIH0pO1xufSgpO1xuXG5IbHMkMS5zdXBwb3J0c05hdGl2ZURhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdmlkZW9qcyQxLmdldFRlY2goJ0h0bWw1JykuaXNTdXBwb3J0ZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAoL21heWJlfHByb2JhYmx5L2kudGVzdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpLmNhblBsYXlUeXBlKCdhcHBsaWNhdGlvbi9kYXNoK3htbCcpKVxuICApO1xufSgpO1xuXG5IbHMkMS5zdXBwb3J0c1R5cGVOYXRpdmVseSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnaGxzJykge1xuICAgIHJldHVybiBIbHMkMS5zdXBwb3J0c05hdGl2ZUhscztcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnZGFzaCcpIHtcbiAgICByZXR1cm4gSGxzJDEuc3VwcG9ydHNOYXRpdmVEYXNoO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBITFMgaXMgYSBzb3VyY2UgaGFuZGxlciwgbm90IGEgdGVjaC4gTWFrZSBzdXJlIGF0dGVtcHRzIHRvIHVzZSBpdFxuICogYXMgb25lIGRvIG5vdCBjYXVzZSBleGNlcHRpb25zLlxuICovXG5IbHMkMS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHZpZGVvanMkMS5sb2cud2FybignSExTIGlzIG5vIGxvbmdlciBhIHRlY2guIFBsZWFzZSByZW1vdmUgaXQgZnJvbSAnICsgJ3lvdXIgcGxheWVyXFwncyB0ZWNoT3JkZXIuJyk7XG59O1xuXG52YXIgQ29tcG9uZW50JDEgPSB2aWRlb2pzJDEuZ2V0Q29tcG9uZW50KCdDb21wb25lbnQnKTtcblxuLyoqXG4gKiBUaGUgSGxzIEhhbmRsZXIgb2JqZWN0LCB3aGVyZSB3ZSBvcmNoZXN0cmF0ZSBhbGwgb2YgdGhlIHBhcnRzXG4gKiBvZiBITFMgdG8gaW50ZXJhY3Qgd2l0aCB2aWRlby5qc1xuICpcbiAqIEBjbGFzcyBIbHNIYW5kbGVyXG4gKiBAZXh0ZW5kcyB2aWRlb2pzLkNvbXBvbmVudFxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSB0aGUgc29ydWNlIG9iamVjdFxuICogQHBhcmFtIHtUZWNofSB0ZWNoIHRoZSBwYXJlbnQgdGVjaCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbmFsIGFuZCByZXF1aXJlZCBvcHRpb25zXG4gKi9cblxudmFyIEhsc0hhbmRsZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyQxKEhsc0hhbmRsZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEhsc0hhbmRsZXIoc291cmNlLCB0ZWNoLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2skMSh0aGlzLCBIbHNIYW5kbGVyKTtcblxuICAgIC8vIHRlY2gucGxheWVyKCkgaXMgZGVwcmVjYXRlZCBidXQgc2V0dXAgYSByZWZlcmVuY2UgdG8gSExTIGZvclxuICAgIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiQxKHRoaXMsIChIbHNIYW5kbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSGxzSGFuZGxlcikpLmNhbGwodGhpcywgdGVjaCwgb3B0aW9ucy5obHMpKTtcblxuICAgIGlmICh0ZWNoLm9wdGlvbnNfICYmIHRlY2gub3B0aW9uc18ucGxheWVySWQpIHtcbiAgICAgIHZhciBfcGxheWVyID0gdmlkZW9qcyQxKHRlY2gub3B0aW9uc18ucGxheWVySWQpO1xuXG4gICAgICBpZiAoIV9wbGF5ZXIuaGFzT3duUHJvcGVydHkoJ2hscycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfcGxheWVyLCAnaGxzJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgICAgdmlkZW9qcyQxLmxvZy53YXJuKCdwbGF5ZXIuaGxzIGlzIGRlcHJlY2F0ZWQuIFVzZSBwbGF5ZXIudGVjaF8uaGxzIGluc3RlYWQuJyk7XG4gICAgICAgICAgICB0ZWNoLnRyaWdnZXIoeyB0eXBlOiAndXNhZ2UnLCBuYW1lOiAnaGxzLXBsYXllci1hY2Nlc3MnIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBhIHJlZmVyZW5jZSB0byB0aGUgSGxzSGFuZGxlciBmcm9tIHBsYXllci52aHMuIFRoaXMgYWxsb3dzIHVzZXJzIHRvIHN0YXJ0XG4gICAgICAvLyBtaWdyYXRpbmcgZnJvbSBwbGF5ZXIudGVjaF8uaGxzLi4uIHRvIHBsYXllci52aHMuLi4gZm9yIEFQSSBhY2Nlc3MuIEFsdGhvdWdoIHRoaXNcbiAgICAgIC8vIGlzbid0IHRoZSBtb3N0IGFwcHJvcHJpYXRlIGZvcm0gb2YgcmVmZXJlbmNlIGZvciB2aWRlby5qcyAoc2luY2UgYWxsIEFQSXMgc2hvdWxkXG4gICAgICAvLyBiZSBwcm92aWRlZCB0aHJvdWdoIGNvcmUgdmlkZW8uanMpLCBpdCBpcyBhIGNvbW1vbiBwYXR0ZXJuIGZvciBwbHVnaW5zLCBhbmQgdmhzXG4gICAgICAvLyB3aWxsIGFjdCBhY2NvcmRpbmdseS5cbiAgICAgIF9wbGF5ZXIudmhzID0gX3RoaXM7XG4gICAgICAvLyBkZXByZWNhdGVkLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgIF9wbGF5ZXIuZGFzaCA9IF90aGlzO1xuICAgIH1cblxuICAgIF90aGlzLnRlY2hfID0gdGVjaDtcbiAgICBfdGhpcy5zb3VyY2VfID0gc291cmNlO1xuICAgIF90aGlzLnN0YXRzID0ge307XG4gICAgX3RoaXMuaWdub3JlTmV4dFNlZWtpbmdFdmVudF8gPSBmYWxzZTtcbiAgICBfdGhpcy5zZXRPcHRpb25zXygpO1xuXG4gICAgaWYgKF90aGlzLm9wdGlvbnNfLm92ZXJyaWRlTmF0aXZlICYmIHRlY2gub3ZlcnJpZGVOYXRpdmVBdWRpb1RyYWNrcyAmJiB0ZWNoLm92ZXJyaWRlTmF0aXZlVmlkZW9UcmFja3MpIHtcbiAgICAgIHRlY2gub3ZlcnJpZGVOYXRpdmVBdWRpb1RyYWNrcyh0cnVlKTtcbiAgICAgIHRlY2gub3ZlcnJpZGVOYXRpdmVWaWRlb1RyYWNrcyh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKF90aGlzLm9wdGlvbnNfLm92ZXJyaWRlTmF0aXZlICYmICh0ZWNoLmZlYXR1cmVzTmF0aXZlVmlkZW9UcmFja3MgfHwgdGVjaC5mZWF0dXJlc05hdGl2ZUF1ZGlvVHJhY2tzKSkge1xuICAgICAgLy8gb3ZlcnJpZGluZyBuYXRpdmUgSExTIG9ubHkgd29ya3MgaWYgYXVkaW8gdHJhY2tzIGhhdmUgYmVlbiBlbXVsYXRlZFxuICAgICAgLy8gZXJyb3IgZWFybHkgaWYgd2UncmUgbWlzY29uZmlndXJlZFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVycmlkaW5nIG5hdGl2ZSBITFMgcmVxdWlyZXMgZW11bGF0ZWQgdHJhY2tzLiAnICsgJ1NlZSBodHRwczovL2dpdC5pby92TXBqQicpO1xuICAgIH1cblxuICAgIC8vIGxpc3RlbiBmb3IgZnVsbHNjcmVlbmNoYW5nZSBldmVudHMgZm9yIHRoaXMgcGxheWVyIHNvIHRoYXQgd2VcbiAgICAvLyBjYW4gYWRqdXN0IG91ciBxdWFsaXR5IHNlbGVjdGlvbiBxdWlja2x5XG4gICAgX3RoaXMub24oZG9jdW1lbnQsIFsnZnVsbHNjcmVlbmNoYW5nZScsICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCAnTVNGdWxsc2NyZWVuQ2hhbmdlJ10sIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGZ1bGxzY3JlZW5FbGVtZW50ID0gZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudDtcblxuICAgICAgaWYgKGZ1bGxzY3JlZW5FbGVtZW50ICYmIGZ1bGxzY3JlZW5FbGVtZW50LmNvbnRhaW5zKF90aGlzLnRlY2hfLmVsKCkpKSB7XG4gICAgICAgIF90aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8uZmFzdFF1YWxpdHlDaGFuZ2VfKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfdGhpcy5vbihfdGhpcy50ZWNoXywgJ3NlZWtpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5pZ25vcmVOZXh0U2Vla2luZ0V2ZW50Xykge1xuICAgICAgICB0aGlzLmlnbm9yZU5leHRTZWVraW5nRXZlbnRfID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRDdXJyZW50VGltZSh0aGlzLnRlY2hfLmN1cnJlbnRUaW1lKCkpO1xuICAgIH0pO1xuICAgIF90aGlzLm9uKF90aGlzLnRlY2hfLCAnZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfKSB7XG4gICAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5wYXVzZUxvYWRpbmcoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF90aGlzLm9uKF90aGlzLnRlY2hfLCAncGxheScsIF90aGlzLnBsYXkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzJDEoSGxzSGFuZGxlciwgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnNfKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIGRlZmF1bHRzXG4gICAgICB0aGlzLm9wdGlvbnNfLndpdGhDcmVkZW50aWFscyA9IHRoaXMub3B0aW9uc18ud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc18uYmxhY2tsaXN0RHVyYXRpb24gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc18uYmxhY2tsaXN0RHVyYXRpb24gPSA1ICogNjA7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YXJ0IHBsYXlsaXN0IHNlbGVjdGlvbiBhdCBhIHJlYXNvbmFibGUgYmFuZHdpZHRoIGZvclxuICAgICAgLy8gYnJvYWRiYW5kIGludGVybmV0ICgwLjUgTUIvcykgb3IgbW9iaWxlICgwLjA2MjUgTUIvcylcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zXy5iYW5kd2lkdGggIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc18uYmFuZHdpZHRoID0gSU5JVElBTF9CQU5EV0lEVEg7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBiYW5kd2lkdGggbnVtYmVyIGlzIHVuY2hhbmdlZCBmcm9tIHRoZSBpbml0aWFsIHNldHRpbmdcbiAgICAgIC8vIHRoZW4gdGhpcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIGVuYWJsZUxvd0luaXRpYWxQbGF5bGlzdCBvcHRpb25cbiAgICAgIHRoaXMub3B0aW9uc18uZW5hYmxlTG93SW5pdGlhbFBsYXlsaXN0ID0gdGhpcy5vcHRpb25zXy5lbmFibGVMb3dJbml0aWFsUGxheWxpc3QgJiYgdGhpcy5vcHRpb25zXy5iYW5kd2lkdGggPT09IElOSVRJQUxfQkFORFdJRFRIO1xuXG4gICAgICAvLyBncmFiIG9wdGlvbnMgcGFzc2VkIHRvIHBsYXllci5zcmNcbiAgICAgIFsnd2l0aENyZWRlbnRpYWxzJywgJ2JhbmR3aWR0aCddLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIF90aGlzMi5zb3VyY2VfW29wdGlvbl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgX3RoaXMyLm9wdGlvbnNfW29wdGlvbl0gPSBfdGhpczIuc291cmNlX1tvcHRpb25dO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5iYW5kd2lkdGggPSB0aGlzLm9wdGlvbnNfLmJhbmR3aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2FsbGVkIHdoZW4gcGxheWVyLnNyYyBnZXRzIGNhbGxlZCwgaGFuZGxlIGEgbmV3IHNvdXJjZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyYyB0aGUgc291cmNlIG9iamVjdCB0byBoYW5kbGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3JjJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3JjKF9zcmMsIHR5cGUpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAvLyBkbyBub3RoaW5nIGlmIHRoZSBzcmMgaXMgZmFsc2V5XG4gICAgICBpZiAoIV9zcmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRPcHRpb25zXygpO1xuICAgICAgLy8gYWRkIG1hc3RlciBwbGF5bGlzdCBjb250cm9sbGVyIG9wdGlvbnNcbiAgICAgIHRoaXMub3B0aW9uc18udXJsID0gdGhpcy5zb3VyY2VfLnNyYztcbiAgICAgIHRoaXMub3B0aW9uc18udGVjaCA9IHRoaXMudGVjaF87XG4gICAgICB0aGlzLm9wdGlvbnNfLmV4dGVybkhscyA9IEhscyQxO1xuICAgICAgdGhpcy5vcHRpb25zXy5zb3VyY2VUeXBlID0gc2ltcGxlVHlwZUZyb21Tb3VyY2VUeXBlKHR5cGUpO1xuXG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8gPSBuZXcgTWFzdGVyUGxheWxpc3RDb250cm9sbGVyKHRoaXMub3B0aW9uc18pO1xuICAgICAgdGhpcy5wbGF5YmFja1dhdGNoZXJfID0gbmV3IFBsYXliYWNrV2F0Y2hlcih2aWRlb2pzJDEubWVyZ2VPcHRpb25zKHRoaXMub3B0aW9uc18sIHtcbiAgICAgICAgc2Vla2FibGU6IGZ1bmN0aW9uIHNlZWthYmxlJCQxKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuc2Vla2FibGUoKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8ub24oJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGxheWVyID0gdmlkZW9qcyQxLnBsYXllcnNbX3RoaXMzLnRlY2hfLm9wdGlvbnNfLnBsYXllcklkXTtcblxuICAgICAgICBwbGF5ZXIuZXJyb3IoX3RoaXMzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8uZXJyb3IpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGB0aGlzYCBpbiBzZWxlY3RQbGF5bGlzdCBzaG91bGQgYmUgdGhlIEhsc0hhbmRsZXIgZm9yIGJhY2t3YXJkc1xuICAgICAgLy8gY29tcGF0aWJpbGl0eSB3aXRoIDwgdjJcbiAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5zZWxlY3RQbGF5bGlzdCA9IHRoaXMuc2VsZWN0UGxheWxpc3QgPyB0aGlzLnNlbGVjdFBsYXlsaXN0LmJpbmQodGhpcykgOiBIbHMkMS5TVEFOREFSRF9QTEFZTElTVF9TRUxFQ1RPUi5iaW5kKHRoaXMpO1xuXG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8uc2VsZWN0SW5pdGlhbFBsYXlsaXN0ID0gSGxzJDEuSU5JVElBTF9QTEFZTElTVF9TRUxFQ1RPUi5iaW5kKHRoaXMpO1xuXG4gICAgICAvLyByZS1leHBvc2Ugc29tZSBpbnRlcm5hbCBvYmplY3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDwgdjJcbiAgICAgIHRoaXMucGxheWxpc3RzID0gdGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1hc3RlclBsYXlsaXN0TG9hZGVyXztcbiAgICAgIHRoaXMubWVkaWFTb3VyY2UgPSB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8ubWVkaWFTb3VyY2U7XG5cbiAgICAgIC8vIFByb3h5IGFzc2lnbm1lbnQgb2Ygc29tZSBwcm9wZXJ0aWVzIHRvIHRoZSBtYXN0ZXIgcGxheWxpc3RcbiAgICAgIC8vIGNvbnRyb2xsZXIuIFVzaW5nIGEgY3VzdG9tIHByb3BlcnR5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgLy8gd2l0aCA8IHYyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgIHNlbGVjdFBsYXlsaXN0OiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLnNlbGVjdFBsYXlsaXN0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoc2VsZWN0UGxheWxpc3QpIHtcbiAgICAgICAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5zZWxlY3RQbGF5bGlzdCA9IHNlbGVjdFBsYXlsaXN0LmJpbmQodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0aHJvdWdocHV0OiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1haW5TZWdtZW50TG9hZGVyXy50aHJvdWdocHV0LnJhdGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh0aHJvdWdocHV0KSB7XG4gICAgICAgICAgICB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8ubWFpblNlZ21lbnRMb2FkZXJfLnRocm91Z2hwdXQucmF0ZSA9IHRocm91Z2hwdXQ7XG4gICAgICAgICAgICAvLyBCeSBzZXR0aW5nIGBjb3VudGAgdG8gMSB0aGUgdGhyb3VnaHB1dCB2YWx1ZSBiZWNvbWVzIHRoZSBzdGFydGluZyB2YWx1ZVxuICAgICAgICAgICAgLy8gZm9yIHRoZSBjdW11bGF0aXZlIGF2ZXJhZ2VcbiAgICAgICAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5tYWluU2VnbWVudExvYWRlcl8udGhyb3VnaHB1dC5jb3VudCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBiYW5kd2lkdGg6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8ubWFpblNlZ21lbnRMb2FkZXJfLmJhbmR3aWR0aDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKGJhbmR3aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1haW5TZWdtZW50TG9hZGVyXy5iYW5kd2lkdGggPSBiYW5kd2lkdGg7XG4gICAgICAgICAgICAvLyBzZXR0aW5nIHRoZSBiYW5kd2lkdGggbWFudWFsbHkgcmVzZXRzIHRoZSB0aHJvdWdocHV0IGNvdW50ZXJcbiAgICAgICAgICAgIC8vIGBjb3VudGAgaXMgc2V0IHRvIHplcm8gdGhhdCBjdXJyZW50IHZhbHVlIG9mIGByYXRlYCBpc24ndCBpbmNsdWRlZFxuICAgICAgICAgICAgLy8gaW4gdGhlIGN1bXVsYXRpdmUgYXZlcmFnZVxuICAgICAgICAgICAgdGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1haW5TZWdtZW50TG9hZGVyXy50aHJvdWdocHV0ID0ge1xuICAgICAgICAgICAgICByYXRlOiAwLFxuICAgICAgICAgICAgICBjb3VudDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgc3lzdGVtQmFuZHdpZHRoYCBpcyBhIGNvbWJpbmF0aW9uIG9mIHR3byBzZXJpYWwgcHJvY2Vzc2VzIGJpdC1yYXRlcy4gVGhlIGZpcnN0XG4gICAgICAgICAqIGlzIHRoZSBuZXR3b3JrIGJpdHJhdGUgcHJvdmlkZWQgYnkgYGJhbmR3aWR0aGAgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGJpdHJhdGUgb2ZcbiAgICAgICAgICogdGhlIGVudGlyZSBwcm9jZXNzIGFmdGVyIHRoYXQgLSBkZWNyeXB0aW9uLCB0cmFuc211eGluZywgYW5kIGFwcGVuZGluZyAtIHByb3ZpZGVkXG4gICAgICAgICAqIGJ5IGB0aHJvdWdocHV0YC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2luY2UgdGhlIHR3byBwcm9jZXNzIGFyZSBzZXJpYWwsIHRoZSBvdmVyYWxsIHN5c3RlbSBiYW5kd2lkdGggaXMgZ2l2ZW4gYnk6XG4gICAgICAgICAqICAgc3lzQmFuZHdpZHRoID0gMSAvICgxIC8gYmFuZHdpZHRoICsgMSAvIHRocm91Z2hwdXQpXG4gICAgICAgICAqL1xuICAgICAgICBzeXN0ZW1CYW5kd2lkdGg6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICAgIHZhciBpbnZCYW5kd2lkdGggPSAxIC8gKHRoaXMuYmFuZHdpZHRoIHx8IDEpO1xuICAgICAgICAgICAgdmFyIGludlRocm91Z2hwdXQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRocm91Z2hwdXQgPiAwKSB7XG4gICAgICAgICAgICAgIGludlRocm91Z2hwdXQgPSAxIC8gdGhpcy50aHJvdWdocHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW52VGhyb3VnaHB1dCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzeXN0ZW1CaXRyYXRlID0gTWF0aC5mbG9vcigxIC8gKGludkJhbmR3aWR0aCArIGludlRocm91Z2hwdXQpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHN5c3RlbUJpdHJhdGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHtcbiAgICAgICAgICAgIHZpZGVvanMkMS5sb2cuZXJyb3IoJ1RoZSBcInN5c3RlbUJhbmR3aWR0aFwiIHByb3BlcnR5IGlzIHJlYWQtb25seScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMuc3RhdHMsIHtcbiAgICAgICAgYmFuZHdpZHRoOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmJhbmR3aWR0aCB8fCAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBtZWRpYVJlcXVlc3RzOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8ubWVkaWFSZXF1ZXN0c18oKSB8fCAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBtZWRpYVJlcXVlc3RzQWJvcnRlZDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1lZGlhUmVxdWVzdHNBYm9ydGVkXygpIHx8IDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG1lZGlhUmVxdWVzdHNUaW1lZG91dDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1lZGlhUmVxdWVzdHNUaW1lZG91dF8oKSB8fCAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBtZWRpYVJlcXVlc3RzRXJyb3JlZDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1lZGlhUmVxdWVzdHNFcnJvcmVkXygpIHx8IDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG1lZGlhVHJhbnNmZXJEdXJhdGlvbjoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1lZGlhVHJhbnNmZXJEdXJhdGlvbl8oKSB8fCAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBtZWRpYUJ5dGVzVHJhbnNmZXJyZWQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5tZWRpYUJ5dGVzVHJhbnNmZXJyZWRfKCkgfHwgMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbWVkaWFTZWNvbmRzTG9hZGVkOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8ubWVkaWFTZWNvbmRzTG9hZGVkXygpIHx8IDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGJ1ZmZlcmVkOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZVJhbmdlc1RvQXJyYXkoX3RoaXMzLnRlY2hfLmJ1ZmZlcmVkKCkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50VGltZToge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy50ZWNoXy5jdXJyZW50VGltZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50U291cmNlOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLnRlY2hfLmN1cnJlbnRTb3VyY2VfO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50VGVjaDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy50ZWNoXy5uYW1lXztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZHVyYXRpb246IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMudGVjaF8uZHVyYXRpb24oKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbWFzdGVyOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLnBsYXlsaXN0cy5tYXN0ZXI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHBsYXllckRpbWVuc2lvbnM6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMudGVjaF8uY3VycmVudERpbWVuc2lvbnMoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgc2Vla2FibGU6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aW1lUmFuZ2VzVG9BcnJheShfdGhpczMudGVjaF8uc2Vla2FibGUoKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVzdGFtcDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUubm93KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5OiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLnRlY2hfLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnRlY2hfLm9uZSgnY2FucGxheScsIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5zZXR1cEZpcnN0UGxheS5iaW5kKHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXykpO1xuXG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8ub24oJ3NlbGVjdGVkaW5pdGlhbG1lZGlhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBZGQgdGhlIG1hbnVhbCByZW5kaXRpb24gbWl4LWluIHRvIEhsc0hhbmRsZXJcbiAgICAgICAgcmVuZGl0aW9uU2VsZWN0aW9uTWl4aW4oX3RoaXMzKTtcbiAgICAgICAgc2V0dXBFbWVPcHRpb25zKF90aGlzMyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gdGhlIGJhbmR3aWR0aCBvZiB0aGUgcHJpbWFyeSBzZWdtZW50IGxvYWRlciBpcyBvdXIgYmVzdFxuICAgICAgLy8gZXN0aW1hdGUgb2Ygb3ZlcmFsbCBiYW5kd2lkdGhcbiAgICAgIHRoaXMub24odGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGVjaF8udHJpZ2dlcigncHJvZ3Jlc3MnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJbiB0aGUgbGl2ZSBjYXNlLCB3ZSBuZWVkIHRvIGlnbm9yZSB0aGUgdmVyeSBmaXJzdCBgc2Vla2luZ2AgZXZlbnQgc2luY2VcbiAgICAgIC8vIHRoYXQgd2lsbCBiZSB0aGUgcmVzdWx0IG9mIHRoZSBzZWVrLXRvLWxpdmUgYmVoYXZpb3JcbiAgICAgIHRoaXMub24odGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLCAnZmlyc3RwbGF5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlnbm9yZU5leHRTZWVraW5nRXZlbnRfID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnRlY2hfLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5zZXR1cFF1YWxpdHlMZXZlbHNfKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gZG8gbm90aGluZyBpZiB0aGUgdGVjaCBoYXMgYmVlbiBkaXNwb3NlZCBhbHJlYWR5XG4gICAgICAvLyB0aGlzIGNhbiBvY2N1ciBpZiBzb21lb25lIHNldHMgdGhlIHNyYyBpbiBwbGF5ZXIucmVhZHkoKSwgZm9yIGluc3RhbmNlXG4gICAgICBpZiAoIXRoaXMudGVjaF8uZWwoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGVjaF8uc3JjKHZpZGVvanMkMS5VUkwuY3JlYXRlT2JqZWN0VVJMKHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5tZWRpYVNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBxdWFsaXR5IGxldmVscyBhbmQgc2V0cyBsaXN0ZW5lcnMgdG8gdXBkYXRlIHRoZW0uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNldHVwUXVhbGl0eUxldmVsc19cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXR1cFF1YWxpdHlMZXZlbHNfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBRdWFsaXR5TGV2ZWxzXygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgcGxheWVyID0gdmlkZW9qcyQxLnBsYXllcnNbdGhpcy50ZWNoXy5vcHRpb25zXy5wbGF5ZXJJZF07XG5cbiAgICAgIGlmIChwbGF5ZXIgJiYgcGxheWVyLnF1YWxpdHlMZXZlbHMpIHtcbiAgICAgICAgdGhpcy5xdWFsaXR5TGV2ZWxzXyA9IHBsYXllci5xdWFsaXR5TGV2ZWxzKCk7XG5cbiAgICAgICAgdGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm9uKCdzZWxlY3RlZGluaXRpYWxtZWRpYScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBoYW5kbGVIbHNMb2FkZWRNZXRhZGF0YShfdGhpczQucXVhbGl0eUxldmVsc18sIF90aGlzNCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucGxheWxpc3RzLm9uKCdtZWRpYWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBoYW5kbGVIbHNNZWRpYUNoYW5nZShfdGhpczQucXVhbGl0eUxldmVsc18sIF90aGlzNC5wbGF5bGlzdHMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCZWdpbiBwbGF5aW5nIHRoZSB2aWRlby5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8ucGxheSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGEgd3JhcHBlciBhcm91bmQgdGhlIGZ1bmN0aW9uIGluIE1hc3RlclBsYXlsaXN0Q29udHJvbGxlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRDdXJyZW50VGltZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1cnJlbnRUaW1lKGN1cnJlbnRUaW1lKSB7XG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8uc2V0Q3VycmVudFRpbWUoY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGEgd3JhcHBlciBhcm91bmQgdGhlIGZ1bmN0aW9uIGluIE1hc3RlclBsYXlsaXN0Q29udHJvbGxlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkdXJhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGR1cmF0aW9uJCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5kdXJhdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGEgd3JhcHBlciBhcm91bmQgdGhlIGZ1bmN0aW9uIGluIE1hc3RlclBsYXlsaXN0Q29udHJvbGxlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZWVrYWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlZWthYmxlJCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5zZWVrYWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFib3J0IGFsbCBvdXRzdGFuZGluZyB3b3JrIGFuZCBjbGVhbnVwLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXNwb3NlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIGlmICh0aGlzLnBsYXliYWNrV2F0Y2hlcl8pIHtcbiAgICAgICAgdGhpcy5wbGF5YmFja1dhdGNoZXJfLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8pIHtcbiAgICAgICAgdGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnF1YWxpdHlMZXZlbHNfKSB7XG4gICAgICAgIHRoaXMucXVhbGl0eUxldmVsc18uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgZ2V0JDIoSGxzSGFuZGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihIbHNIYW5kbGVyLnByb3RvdHlwZSksICdkaXNwb3NlJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEhsc0hhbmRsZXI7XG59KENvbXBvbmVudCQxKTtcblxuLyoqXG4gKiBUaGUgU291cmNlIEhhbmRsZXIgb2JqZWN0LCB3aGljaCBpbmZvcm1zIHZpZGVvLmpzIHdoYXQgYWRkaXRpb25hbFxuICogTUlNRSB0eXBlcyBhcmUgc3VwcG9ydGVkIGFuZCBzZXRzIHVwIHBsYXliYWNrLiBJdCBpcyByZWdpc3RlcmVkXG4gKiBhdXRvbWF0aWNhbGx5IHRvIHRoZSBhcHByb3ByaWF0ZSB0ZWNoIGJhc2VkIG9uIHRoZSBjYXBhYmlsaXRpZXMgb2ZcbiAqIHRoZSBicm93c2VyIGl0IGlzIHJ1bm5pbmcgaW4uIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gdXNlIG9yIG1vZGlmeVxuICogdGhpcyBvYmplY3QgaW4gbm9ybWFsIHVzYWdlLlxuICovXG5cbnZhciBIbHNTb3VyY2VIYW5kbGVyID0ge1xuICBuYW1lOiAndmlkZW9qcy1odHRwLXN0cmVhbWluZycsXG4gIFZFUlNJT046IHZlcnNpb24kMSxcbiAgY2FuSGFuZGxlU291cmNlOiBmdW5jdGlvbiBjYW5IYW5kbGVTb3VyY2Uoc3JjT2JqKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIGxvY2FsT3B0aW9ucyA9IHZpZGVvanMkMS5tZXJnZU9wdGlvbnModmlkZW9qcyQxLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIEhsc1NvdXJjZUhhbmRsZXIuY2FuUGxheVR5cGUoc3JjT2JqLnR5cGUsIGxvY2FsT3B0aW9ucyk7XG4gIH0sXG4gIGhhbmRsZVNvdXJjZTogZnVuY3Rpb24gaGFuZGxlU291cmNlKHNvdXJjZSwgdGVjaCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIHZhciBsb2NhbE9wdGlvbnMgPSB2aWRlb2pzJDEubWVyZ2VPcHRpb25zKHZpZGVvanMkMS5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIHRlY2guaGxzID0gbmV3IEhsc0hhbmRsZXIoc291cmNlLCB0ZWNoLCBsb2NhbE9wdGlvbnMpO1xuICAgIHRlY2guaGxzLnhociA9IHhockZhY3RvcnkoKTtcblxuICAgIHRlY2guaGxzLnNyYyhzb3VyY2Uuc3JjLCBzb3VyY2UudHlwZSk7XG4gICAgcmV0dXJuIHRlY2guaGxzO1xuICB9LFxuICBjYW5QbGF5VHlwZTogZnVuY3Rpb24gY2FuUGxheVR5cGUodHlwZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBfdmlkZW9qcyRtZXJnZU9wdGlvbnMgPSB2aWRlb2pzJDEubWVyZ2VPcHRpb25zKHZpZGVvanMkMS5vcHRpb25zLCBvcHRpb25zKSxcbiAgICAgICAgb3ZlcnJpZGVOYXRpdmUgPSBfdmlkZW9qcyRtZXJnZU9wdGlvbnMuaGxzLm92ZXJyaWRlTmF0aXZlO1xuXG4gICAgdmFyIHN1cHBvcnRlZFR5cGUgPSBzaW1wbGVUeXBlRnJvbVNvdXJjZVR5cGUodHlwZSk7XG4gICAgdmFyIGNhblVzZU1zZVBsYXliYWNrID0gc3VwcG9ydGVkVHlwZSAmJiAoIUhscyQxLnN1cHBvcnRzVHlwZU5hdGl2ZWx5KHN1cHBvcnRlZFR5cGUpIHx8IG92ZXJyaWRlTmF0aXZlKTtcblxuICAgIHJldHVybiBjYW5Vc2VNc2VQbGF5YmFjayA/ICdtYXliZScgOiAnJztcbiAgfVxufTtcblxuaWYgKHR5cGVvZiB2aWRlb2pzJDEuTWVkaWFTb3VyY2UgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB2aWRlb2pzJDEuVVJMID09PSAndW5kZWZpbmVkJykge1xuICB2aWRlb2pzJDEuTWVkaWFTb3VyY2UgPSBNZWRpYVNvdXJjZTtcbiAgdmlkZW9qcyQxLlVSTCA9IFVSTCQxO1xufVxuXG4vLyByZWdpc3RlciBzb3VyY2UgaGFuZGxlcnMgd2l0aCB0aGUgYXBwcm9wcmlhdGUgdGVjaHNcbmlmIChNZWRpYVNvdXJjZS5zdXBwb3J0c05hdGl2ZU1lZGlhU291cmNlcygpKSB7XG4gIHZpZGVvanMkMS5nZXRUZWNoKCdIdG1sNScpLnJlZ2lzdGVyU291cmNlSGFuZGxlcihIbHNTb3VyY2VIYW5kbGVyLCAwKTtcbn1cblxudmlkZW9qcyQxLkhsc0hhbmRsZXIgPSBIbHNIYW5kbGVyO1xudmlkZW9qcyQxLkhsc1NvdXJjZUhhbmRsZXIgPSBIbHNTb3VyY2VIYW5kbGVyO1xudmlkZW9qcyQxLkhscyA9IEhscyQxO1xuaWYgKCF2aWRlb2pzJDEudXNlKSB7XG4gIHZpZGVvanMkMS5yZWdpc3RlckNvbXBvbmVudCgnSGxzJywgSGxzJDEpO1xufVxudmlkZW9qcyQxLm9wdGlvbnMuaGxzID0gdmlkZW9qcyQxLm9wdGlvbnMuaGxzIHx8IHt9O1xuXG5pZiAodmlkZW9qcyQxLnJlZ2lzdGVyUGx1Z2luKSB7XG4gIHZpZGVvanMkMS5yZWdpc3RlclBsdWdpbigncmVsb2FkU291cmNlT25FcnJvcicsIHJlbG9hZFNvdXJjZU9uRXJyb3IpO1xufSBlbHNlIHtcbiAgdmlkZW9qcyQxLnBsdWdpbigncmVsb2FkU291cmNlT25FcnJvcicsIHJlbG9hZFNvdXJjZU9uRXJyb3IpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2aWRlb2pzJDE7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/video.js/dist/video.es.js\n");

/***/ }),

/***/ "./node_modules/videojs-vtt.js/lib/browser-index.js":
/*!**********************************************************!*\
  !*** ./node_modules/videojs-vtt.js/lib/browser-index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Default exports for Node. Export the extended versions of VTTCue and\n// VTTRegion in Node since we likely want the capability to convert back and\n// forth between JSON. If we don't then it's not that big of a deal since we're\n// off browser.\n\nvar window = __webpack_require__(/*! global/window */ \"./node_modules/global/window.js\");\n\nvar vttjs = module.exports = {\n  WebVTT: __webpack_require__(/*! ./vtt.js */ \"./node_modules/videojs-vtt.js/lib/vtt.js\"),\n  VTTCue: __webpack_require__(/*! ./vttcue.js */ \"./node_modules/videojs-vtt.js/lib/vttcue.js\"),\n  VTTRegion: __webpack_require__(/*! ./vttregion.js */ \"./node_modules/videojs-vtt.js/lib/vttregion.js\")\n};\n\nwindow.vttjs = vttjs;\nwindow.WebVTT = vttjs.WebVTT;\n\nvar cueShim = vttjs.VTTCue;\nvar regionShim = vttjs.VTTRegion;\nvar nativeVTTCue = window.VTTCue;\nvar nativeVTTRegion = window.VTTRegion;\n\nvttjs.shim = function() {\n  window.VTTCue = cueShim;\n  window.VTTRegion = regionShim;\n};\n\nvttjs.restore = function() {\n  window.VTTCue = nativeVTTCue;\n  window.VTTRegion = nativeVTTRegion;\n};\n\nif (!window.VTTCue) {\n  vttjs.shim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmlkZW9qcy12dHQuanMvbGliL2Jyb3dzZXItaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW9qcy12dHQuanMvbGliL2Jyb3dzZXItaW5kZXguanM/MmI4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8vIERlZmF1bHQgZXhwb3J0cyBmb3IgTm9kZS4gRXhwb3J0IHRoZSBleHRlbmRlZCB2ZXJzaW9ucyBvZiBWVFRDdWUgYW5kXG4vLyBWVFRSZWdpb24gaW4gTm9kZSBzaW5jZSB3ZSBsaWtlbHkgd2FudCB0aGUgY2FwYWJpbGl0eSB0byBjb252ZXJ0IGJhY2sgYW5kXG4vLyBmb3J0aCBiZXR3ZWVuIEpTT04uIElmIHdlIGRvbid0IHRoZW4gaXQncyBub3QgdGhhdCBiaWcgb2YgYSBkZWFsIHNpbmNlIHdlJ3JlXG4vLyBvZmYgYnJvd3Nlci5cblxudmFyIHdpbmRvdyA9IHJlcXVpcmUoJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIHZ0dGpzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYlZUVDogcmVxdWlyZShcIi4vdnR0LmpzXCIpLFxuICBWVFRDdWU6IHJlcXVpcmUoXCIuL3Z0dGN1ZS5qc1wiKSxcbiAgVlRUUmVnaW9uOiByZXF1aXJlKFwiLi92dHRyZWdpb24uanNcIilcbn07XG5cbndpbmRvdy52dHRqcyA9IHZ0dGpzO1xud2luZG93LldlYlZUVCA9IHZ0dGpzLldlYlZUVDtcblxudmFyIGN1ZVNoaW0gPSB2dHRqcy5WVFRDdWU7XG52YXIgcmVnaW9uU2hpbSA9IHZ0dGpzLlZUVFJlZ2lvbjtcbnZhciBuYXRpdmVWVFRDdWUgPSB3aW5kb3cuVlRUQ3VlO1xudmFyIG5hdGl2ZVZUVFJlZ2lvbiA9IHdpbmRvdy5WVFRSZWdpb247XG5cbnZ0dGpzLnNoaW0gPSBmdW5jdGlvbigpIHtcbiAgd2luZG93LlZUVEN1ZSA9IGN1ZVNoaW07XG4gIHdpbmRvdy5WVFRSZWdpb24gPSByZWdpb25TaGltO1xufTtcblxudnR0anMucmVzdG9yZSA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cuVlRUQ3VlID0gbmF0aXZlVlRUQ3VlO1xuICB3aW5kb3cuVlRUUmVnaW9uID0gbmF0aXZlVlRUUmVnaW9uO1xufTtcblxuaWYgKCF3aW5kb3cuVlRUQ3VlKSB7XG4gIHZ0dGpzLnNoaW0oKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/videojs-vtt.js/lib/browser-index.js\n");

/***/ }),

/***/ "./node_modules/videojs-vtt.js/lib/vtt.js":
/*!************************************************!*\
  !*** ./node_modules/videojs-vtt.js/lib/vtt.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\nvar _objCreate = Object.create || (function() {\n  function F() {}\n  return function(o) {\n    if (arguments.length !== 1) {\n      throw new Error('Object.create shim only accepts one parameter.');\n    }\n    F.prototype = o;\n    return new F();\n  };\n})();\n\n// Creates a new ParserError object from an errorData object. The errorData\n// object should have default code and message properties. The default message\n// property can be overriden by passing in a message parameter.\n// See ParsingError.Errors below for acceptable errors.\nfunction ParsingError(errorData, message) {\n  this.name = \"ParsingError\";\n  this.code = errorData.code;\n  this.message = message || errorData.message;\n}\nParsingError.prototype = _objCreate(Error.prototype);\nParsingError.prototype.constructor = ParsingError;\n\n// ParsingError metadata for acceptable ParsingErrors.\nParsingError.Errors = {\n  BadSignature: {\n    code: 0,\n    message: \"Malformed WebVTT signature.\"\n  },\n  BadTimeStamp: {\n    code: 1,\n    message: \"Malformed time stamp.\"\n  }\n};\n\n// Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\n  }\n\n  var m = input.match(/^(\\d+):(\\d{2})(:\\d{2})?\\.(\\d{3})/);\n  if (!m) {\n    return null;\n  }\n\n  if (m[3]) {\n    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\n    return computeSeconds(m[1], m[2], m[3].replace(\":\", \"\"), m[4]);\n  } else if (m[1] > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[1], m[2], 0,  m[4]);\n  } else {\n    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\n    return computeSeconds(0, m[1], m[2], m[4]);\n  }\n}\n\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nfunction Settings() {\n  this.values = _objCreate(null);\n}\n\nSettings.prototype = {\n  // Only accept the first assignment to any key.\n  set: function(k, v) {\n    if (!this.get(k) && v !== \"\") {\n      this.values[k] = v;\n    }\n  },\n  // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  get: function(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n    return this.has(k) ? this.values[k] : dflt;\n  },\n  // Check whether we have a value for a key.\n  has: function(k) {\n    return k in this.values;\n  },\n  // Accept a setting if its one of the given alternatives.\n  alt: function(k, v, a) {\n    for (var n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  },\n  // Accept a setting if its a valid (signed) integer.\n  integer: function(k, v) {\n    if (/^-?\\d+$/.test(v)) { // integer\n      this.set(k, parseInt(v, 10));\n    }\n  },\n  // Accept a setting if its a valid percentage.\n  percent: function(k, v) {\n    var m;\n    if ((m = v.match(/^([\\d]{1,3})(\\.[\\d]*)?%$/))) {\n      v = parseFloat(v);\n      if (v >= 0 && v <= 100) {\n        this.set(k, v);\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\n// Helper function to parse input into groups separated by 'groupDelim', and\n// interprete each group as a key/value pair separated by 'keyValueDelim'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  var groups = groupDelim ? input.split(groupDelim) : [input];\n  for (var i in groups) {\n    if (typeof groups[i] !== \"string\") {\n      continue;\n    }\n    var kv = groups[i].split(keyValueDelim);\n    if (kv.length !== 2) {\n      continue;\n    }\n    var k = kv[0];\n    var v = kv[1];\n    callback(k, v);\n  }\n}\n\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  var oInput = input;\n  // 4.1 WebVTT timestamp\n  function consumeTimeStamp() {\n    var ts = parseTimeStamp(input);\n    if (ts === null) {\n      throw new ParsingError(ParsingError.Errors.BadTimeStamp,\n                            \"Malformed timestamp: \" + oInput);\n    }\n    // Remove time stamp from input.\n    input = input.replace(/^[^\\sa-zA-Z-]+/, \"\");\n    return ts;\n  }\n\n  // 4.4.2 WebVTT cue settings\n  function consumeCueSettings(input, cue) {\n    var settings = new Settings();\n\n    parseOptions(input, function (k, v) {\n      switch (k) {\n      case \"region\":\n        // Find the last region we parsed with the same region id.\n        for (var i = regionList.length - 1; i >= 0; i--) {\n          if (regionList[i].id === v) {\n            settings.set(k, regionList[i].region);\n            break;\n          }\n        }\n        break;\n      case \"vertical\":\n        settings.alt(k, v, [\"rl\", \"lr\"]);\n        break;\n      case \"line\":\n        var vals = v.split(\",\"),\n            vals0 = vals[0];\n        settings.integer(k, vals0);\n        settings.percent(k, vals0) ? settings.set(\"snapToLines\", false) : null;\n        settings.alt(k, vals0, [\"auto\"]);\n        if (vals.length === 2) {\n          settings.alt(\"lineAlign\", vals[1], [\"start\", \"middle\", \"end\"]);\n        }\n        break;\n      case \"position\":\n        vals = v.split(\",\");\n        settings.percent(k, vals[0]);\n        if (vals.length === 2) {\n          settings.alt(\"positionAlign\", vals[1], [\"start\", \"middle\", \"end\"]);\n        }\n        break;\n      case \"size\":\n        settings.percent(k, v);\n        break;\n      case \"align\":\n        settings.alt(k, v, [\"start\", \"middle\", \"end\", \"left\", \"right\"]);\n        break;\n      }\n    }, /:/, /\\s/);\n\n    // Apply default values for any missing fields.\n    cue.region = settings.get(\"region\", null);\n    cue.vertical = settings.get(\"vertical\", \"\");\n    cue.line = settings.get(\"line\", \"auto\");\n    cue.lineAlign = settings.get(\"lineAlign\", \"start\");\n    cue.snapToLines = settings.get(\"snapToLines\", true);\n    cue.size = settings.get(\"size\", 100);\n    cue.align = settings.get(\"align\", \"middle\");\n    cue.position = settings.get(\"position\", {\n      start: 0,\n      left: 0,\n      middle: 50,\n      end: 100,\n      right: 100\n    }, cue.align);\n    cue.positionAlign = settings.get(\"positionAlign\", {\n      start: \"start\",\n      left: \"start\",\n      middle: \"middle\",\n      end: \"end\",\n      right: \"end\"\n    }, cue.align);\n  }\n\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, \"\");\n  }\n\n  // 4.1 WebVTT cue timings.\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp();   // (1) collect cue start time\n  skipWhitespace();\n  if (input.substr(0, 3) !== \"-->\") {     // (3) next characters must match \"-->\"\n    throw new ParsingError(ParsingError.Errors.BadTimeStamp,\n                           \"Malformed time stamp (time stamps must be separated by '-->'): \" +\n                           oInput);\n  }\n  input = input.substr(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp();     // (5) collect cue end time\n\n  // 4.1 WebVTT cue settings list.\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\n\nvar ESCAPE = {\n  \"&amp;\": \"&\",\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\",\n  \"&lrm;\": \"\\u200e\",\n  \"&rlm;\": \"\\u200f\",\n  \"&nbsp;\": \"\\u00a0\"\n};\n\nvar TAG_NAME = {\n  c: \"span\",\n  i: \"i\",\n  b: \"b\",\n  u: \"u\",\n  ruby: \"ruby\",\n  rt: \"rt\",\n  v: \"span\",\n  lang: \"span\"\n};\n\nvar TAG_ANNOTATION = {\n  v: \"title\",\n  lang: \"lang\"\n};\n\nvar NEEDS_PARENT = {\n  rt: \"ruby\"\n};\n\n// Parse content into a document fragment.\nfunction parseContent(window, input) {\n  function nextToken() {\n    // Check for end-of-string.\n    if (!input) {\n      return null;\n    }\n\n    // Consume 'n' characters from the input.\n    function consume(result) {\n      input = input.substr(result.length);\n      return result;\n    }\n\n    var m = input.match(/^([^<]*)(<[^>]*>?)?/);\n    // If there is some text before the next tag, return it, otherwise return\n    // the tag.\n    return consume(m[1] ? m[1] : m[2]);\n  }\n\n  // Unescape a string 's'.\n  function unescape1(e) {\n    return ESCAPE[e];\n  }\n  function unescape(s) {\n    while ((m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/))) {\n      s = s.replace(m[0], unescape1);\n    }\n    return s;\n  }\n\n  function shouldAdd(current, element) {\n    return !NEEDS_PARENT[element.localName] ||\n           NEEDS_PARENT[element.localName] === current.localName;\n  }\n\n  // Create an element for this tag.\n  function createElement(type, annotation) {\n    var tagName = TAG_NAME[type];\n    if (!tagName) {\n      return null;\n    }\n    var element = window.document.createElement(tagName);\n    element.localName = tagName;\n    var name = TAG_ANNOTATION[type];\n    if (name && annotation) {\n      element[name] = annotation.trim();\n    }\n    return element;\n  }\n\n  var rootDiv = window.document.createElement(\"div\"),\n      current = rootDiv,\n      t,\n      tagStack = [];\n\n  while ((t = nextToken()) !== null) {\n    if (t[0] === '<') {\n      if (t[1] === \"/\") {\n        // If the closing tag matches, move back up to the parent node.\n        if (tagStack.length &&\n            tagStack[tagStack.length - 1] === t.substr(2).replace(\">\", \"\")) {\n          tagStack.pop();\n          current = current.parentNode;\n        }\n        // Otherwise just ignore the end tag.\n        continue;\n      }\n      var ts = parseTimeStamp(t.substr(1, t.length - 2));\n      var node;\n      if (ts) {\n        // Timestamps are lead nodes as well.\n        node = window.document.createProcessingInstruction(\"timestamp\", ts);\n        current.appendChild(node);\n        continue;\n      }\n      var m = t.match(/^<([^.\\s/0-9>]+)(\\.[^\\s\\\\>]+)?([^>\\\\]+)?(\\\\?)>?$/);\n      // If we can't parse the tag, skip to the next tag.\n      if (!m) {\n        continue;\n      }\n      // Try to construct an element, and ignore the tag if we couldn't.\n      node = createElement(m[1], m[3]);\n      if (!node) {\n        continue;\n      }\n      // Determine if the tag should be added based on the context of where it\n      // is placed in the cuetext.\n      if (!shouldAdd(current, node)) {\n        continue;\n      }\n      // Set the class list (as a list of classes, separated by space).\n      if (m[2]) {\n        node.className = m[2].substr(1).replace('.', ' ');\n      }\n      // Append the node to the current node, and enter the scope of the new\n      // node.\n      tagStack.push(m[1]);\n      current.appendChild(node);\n      current = node;\n      continue;\n    }\n\n    // Text nodes are leaf nodes.\n    current.appendChild(window.document.createTextNode(unescape(t)));\n  }\n\n  return rootDiv;\n}\n\n// This is a list of all the Unicode characters that have a strong\n// right-to-left category. What this means is that these characters are\n// written right-to-left for sure. It was generated by pulling all the strong\n// right-to-left characters out of the Unicode data table. That table can\n// found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\nvar strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6],\n [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d],\n [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6],\n [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5],\n [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815],\n [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858],\n [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f],\n [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c],\n [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1],\n [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc],\n [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808],\n [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855],\n [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f],\n [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13],\n [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58],\n [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72],\n [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f],\n [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32],\n [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42],\n [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f],\n [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59],\n [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62],\n [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77],\n [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b],\n [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];\n\nfunction isStrongRTLChar(charCode) {\n  for (var i = 0; i < strongRTLRanges.length; i++) {\n    var currentRange = strongRTLRanges[i];\n    if (charCode >= currentRange[0] && charCode <= currentRange[1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction determineBidi(cueDiv) {\n  var nodeStack = [],\n      text = \"\",\n      charCode;\n\n  if (!cueDiv || !cueDiv.childNodes) {\n    return \"ltr\";\n  }\n\n  function pushNodes(nodeStack, node) {\n    for (var i = node.childNodes.length - 1; i >= 0; i--) {\n      nodeStack.push(node.childNodes[i]);\n    }\n  }\n\n  function nextTextNode(nodeStack) {\n    if (!nodeStack || !nodeStack.length) {\n      return null;\n    }\n\n    var node = nodeStack.pop(),\n        text = node.textContent || node.innerText;\n    if (text) {\n      // TODO: This should match all unicode type B characters (paragraph\n      // separator characters). See issue #115.\n      var m = text.match(/^.*(\\n|\\r)/);\n      if (m) {\n        nodeStack.length = 0;\n        return m[0];\n      }\n      return text;\n    }\n    if (node.tagName === \"ruby\") {\n      return nextTextNode(nodeStack);\n    }\n    if (node.childNodes) {\n      pushNodes(nodeStack, node);\n      return nextTextNode(nodeStack);\n    }\n  }\n\n  pushNodes(nodeStack, cueDiv);\n  while ((text = nextTextNode(nodeStack))) {\n    for (var i = 0; i < text.length; i++) {\n      charCode = text.charCodeAt(i);\n      if (isStrongRTLChar(charCode)) {\n        return \"rtl\";\n      }\n    }\n  }\n  return \"ltr\";\n}\n\nfunction computeLinePos(cue) {\n  if (typeof cue.line === \"number\" &&\n      (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {\n    return cue.line;\n  }\n  if (!cue.track || !cue.track.textTrackList ||\n      !cue.track.textTrackList.mediaElement) {\n    return -1;\n  }\n  var track = cue.track,\n      trackList = track.textTrackList,\n      count = 0;\n  for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {\n    if (trackList[i].mode === \"showing\") {\n      count++;\n    }\n  }\n  return ++count * -1;\n}\n\nfunction StyleBox() {\n}\n\n// Apply styles to a div. If there is no div passed then it defaults to the\n// div on 'this'.\nStyleBox.prototype.applyStyles = function(styles, div) {\n  div = div || this.div;\n  for (var prop in styles) {\n    if (styles.hasOwnProperty(prop)) {\n      div.style[prop] = styles[prop];\n    }\n  }\n};\n\nStyleBox.prototype.formatStyle = function(val, unit) {\n  return val === 0 ? 0 : val + unit;\n};\n\n// Constructs the computed display state of the cue (a div). Places the div\n// into the overlay which should be a block level element (usually a div).\nfunction CueStyleBox(window, cue, styleOptions) {\n  StyleBox.call(this);\n  this.cue = cue;\n\n  // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will\n  // have inline positioning and will function as the cue background box.\n  this.cueDiv = parseContent(window, cue.text);\n  var styles = {\n    color: \"rgba(255, 255, 255, 1)\",\n    backgroundColor:  \"rgba(0, 0, 0, 0.8)\",\n    position: \"relative\",\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0,\n    display: \"inline\",\n    writingMode: cue.vertical === \"\" ? \"horizontal-tb\"\n                                     : cue.vertical === \"lr\" ? \"vertical-lr\"\n                                                             : \"vertical-rl\",\n    unicodeBidi: \"plaintext\"\n  };\n\n  this.applyStyles(styles, this.cueDiv);\n\n  // Create an absolutely positioned div that will be used to position the cue\n  // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS\n  // mirrors of them except \"middle\" which is \"center\" in CSS.\n  this.div = window.document.createElement(\"div\");\n  styles = {\n    direction: determineBidi(this.cueDiv),\n    writingMode: cue.vertical === \"\" ? \"horizontal-tb\"\n                                     : cue.vertical === \"lr\" ? \"vertical-lr\"\n                                                             : \"vertical-rl\",\n    unicodeBidi: \"plaintext\",\n    textAlign: cue.align === \"middle\" ? \"center\" : cue.align,\n    font: styleOptions.font,\n    whiteSpace: \"pre-line\",\n    position: \"absolute\"\n  };\n\n  this.applyStyles(styles);\n  this.div.appendChild(this.cueDiv);\n\n  // Calculate the distance from the reference edge of the viewport to the text\n  // position of the cue box. The reference edge will be resolved later when\n  // the box orientation styles are applied.\n  var textPos = 0;\n  switch (cue.positionAlign) {\n  case \"start\":\n    textPos = cue.position;\n    break;\n  case \"middle\":\n    textPos = cue.position - (cue.size / 2);\n    break;\n  case \"end\":\n    textPos = cue.position - cue.size;\n    break;\n  }\n\n  // Horizontal box orientation; textPos is the distance from the left edge of the\n  // area to the left edge of the box and cue.size is the distance extending to\n  // the right from there.\n  if (cue.vertical === \"\") {\n    this.applyStyles({\n      left:  this.formatStyle(textPos, \"%\"),\n      width: this.formatStyle(cue.size, \"%\")\n    });\n  // Vertical box orientation; textPos is the distance from the top edge of the\n  // area to the top edge of the box and cue.size is the height extending\n  // downwards from there.\n  } else {\n    this.applyStyles({\n      top: this.formatStyle(textPos, \"%\"),\n      height: this.formatStyle(cue.size, \"%\")\n    });\n  }\n\n  this.move = function(box) {\n    this.applyStyles({\n      top: this.formatStyle(box.top, \"px\"),\n      bottom: this.formatStyle(box.bottom, \"px\"),\n      left: this.formatStyle(box.left, \"px\"),\n      right: this.formatStyle(box.right, \"px\"),\n      height: this.formatStyle(box.height, \"px\"),\n      width: this.formatStyle(box.width, \"px\")\n    });\n  };\n}\nCueStyleBox.prototype = _objCreate(StyleBox.prototype);\nCueStyleBox.prototype.constructor = CueStyleBox;\n\n// Represents the co-ordinates of an Element in a way that we can easily\n// compute things with such as if it overlaps or intersects with another Element.\n// Can initialize it with either a StyleBox or another BoxPosition.\nfunction BoxPosition(obj) {\n  // Either a BoxPosition was passed in and we need to copy it, or a StyleBox\n  // was passed in and we need to copy the results of 'getBoundingClientRect'\n  // as the object returned is readonly. All co-ordinate values are in reference\n  // to the viewport origin (top left).\n  var lh, height, width, top;\n  if (obj.div) {\n    height = obj.div.offsetHeight;\n    width = obj.div.offsetWidth;\n    top = obj.div.offsetTop;\n\n    var rects = (rects = obj.div.childNodes) && (rects = rects[0]) &&\n                rects.getClientRects && rects.getClientRects();\n    obj = obj.div.getBoundingClientRect();\n    // In certain cases the outter div will be slightly larger then the sum of\n    // the inner div's lines. This could be due to bold text, etc, on some platforms.\n    // In this case we should get the average line height and use that. This will\n    // result in the desired behaviour.\n    lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length)\n               : 0;\n\n  }\n  this.left = obj.left;\n  this.right = obj.right;\n  this.top = obj.top || top;\n  this.height = obj.height || height;\n  this.bottom = obj.bottom || (top + (obj.height || height));\n  this.width = obj.width || width;\n  this.lineHeight = lh !== undefined ? lh : obj.lineHeight;\n}\n\n// Move the box along a particular axis. Optionally pass in an amount to move\n// the box. If no amount is passed then the default is the line height of the\n// box.\nBoxPosition.prototype.move = function(axis, toMove) {\n  toMove = toMove !== undefined ? toMove : this.lineHeight;\n  switch (axis) {\n  case \"+x\":\n    this.left += toMove;\n    this.right += toMove;\n    break;\n  case \"-x\":\n    this.left -= toMove;\n    this.right -= toMove;\n    break;\n  case \"+y\":\n    this.top += toMove;\n    this.bottom += toMove;\n    break;\n  case \"-y\":\n    this.top -= toMove;\n    this.bottom -= toMove;\n    break;\n  }\n};\n\n// Check if this box overlaps another box, b2.\nBoxPosition.prototype.overlaps = function(b2) {\n  return this.left < b2.right &&\n         this.right > b2.left &&\n         this.top < b2.bottom &&\n         this.bottom > b2.top;\n};\n\n// Check if this box overlaps any other boxes in boxes.\nBoxPosition.prototype.overlapsAny = function(boxes) {\n  for (var i = 0; i < boxes.length; i++) {\n    if (this.overlaps(boxes[i])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// Check if this box is within another box.\nBoxPosition.prototype.within = function(container) {\n  return this.top >= container.top &&\n         this.bottom <= container.bottom &&\n         this.left >= container.left &&\n         this.right <= container.right;\n};\n\n// Check if this box is entirely within the container or it is overlapping\n// on the edge opposite of the axis direction passed. For example, if \"+x\" is\n// passed and the box is overlapping on the left edge of the container, then\n// return true.\nBoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {\n  switch (axis) {\n  case \"+x\":\n    return this.left < container.left;\n  case \"-x\":\n    return this.right > container.right;\n  case \"+y\":\n    return this.top < container.top;\n  case \"-y\":\n    return this.bottom > container.bottom;\n  }\n};\n\n// Find the percentage of the area that this box is overlapping with another\n// box.\nBoxPosition.prototype.intersectPercentage = function(b2) {\n  var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),\n      y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),\n      intersectArea = x * y;\n  return intersectArea / (this.height * this.width);\n};\n\n// Convert the positions from this box to CSS compatible positions using\n// the reference container's positions. This has to be done because this\n// box's positions are in reference to the viewport origin, whereas, CSS\n// values are in referecne to their respective edges.\nBoxPosition.prototype.toCSSCompatValues = function(reference) {\n  return {\n    top: this.top - reference.top,\n    bottom: reference.bottom - this.bottom,\n    left: this.left - reference.left,\n    right: reference.right - this.right,\n    height: this.height,\n    width: this.width\n  };\n};\n\n// Get an object that represents the box's position without anything extra.\n// Can pass a StyleBox, HTMLElement, or another BoxPositon.\nBoxPosition.getSimpleBoxPosition = function(obj) {\n  var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;\n  var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;\n  var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;\n\n  obj = obj.div ? obj.div.getBoundingClientRect() :\n                obj.tagName ? obj.getBoundingClientRect() : obj;\n  var ret = {\n    left: obj.left,\n    right: obj.right,\n    top: obj.top || top,\n    height: obj.height || height,\n    bottom: obj.bottom || (top + (obj.height || height)),\n    width: obj.width || width\n  };\n  return ret;\n};\n\n// Move a StyleBox to its specified, or next best, position. The containerBox\n// is the box that contains the StyleBox, such as a div. boxPositions are\n// a list of other boxes that the styleBox can't overlap with.\nfunction moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {\n\n  // Find the best position for a cue box, b, on the video. The axis parameter\n  // is a list of axis, the order of which, it will move the box along. For example:\n  // Passing [\"+x\", \"-x\"] will move the box first along the x axis in the positive\n  // direction. If it doesn't find a good position for it there it will then move\n  // it along the x axis in the negative direction.\n  function findBestPosition(b, axis) {\n    var bestPosition,\n        specifiedPosition = new BoxPosition(b),\n        percentage = 1; // Highest possible so the first thing we get is better.\n\n    for (var i = 0; i < axis.length; i++) {\n      while (b.overlapsOppositeAxis(containerBox, axis[i]) ||\n             (b.within(containerBox) && b.overlapsAny(boxPositions))) {\n        b.move(axis[i]);\n      }\n      // We found a spot where we aren't overlapping anything. This is our\n      // best position.\n      if (b.within(containerBox)) {\n        return b;\n      }\n      var p = b.intersectPercentage(containerBox);\n      // If we're outside the container box less then we were on our last try\n      // then remember this position as the best position.\n      if (percentage > p) {\n        bestPosition = new BoxPosition(b);\n        percentage = p;\n      }\n      // Reset the box position to the specified position.\n      b = new BoxPosition(specifiedPosition);\n    }\n    return bestPosition || specifiedPosition;\n  }\n\n  var boxPosition = new BoxPosition(styleBox),\n      cue = styleBox.cue,\n      linePos = computeLinePos(cue),\n      axis = [];\n\n  // If we have a line number to align the cue to.\n  if (cue.snapToLines) {\n    var size;\n    switch (cue.vertical) {\n    case \"\":\n      axis = [ \"+y\", \"-y\" ];\n      size = \"height\";\n      break;\n    case \"rl\":\n      axis = [ \"+x\", \"-x\" ];\n      size = \"width\";\n      break;\n    case \"lr\":\n      axis = [ \"-x\", \"+x\" ];\n      size = \"width\";\n      break;\n    }\n\n    var step = boxPosition.lineHeight,\n        position = step * Math.round(linePos),\n        maxPosition = containerBox[size] + step,\n        initialAxis = axis[0];\n\n    // If the specified intial position is greater then the max position then\n    // clamp the box to the amount of steps it would take for the box to\n    // reach the max position.\n    if (Math.abs(position) > maxPosition) {\n      position = position < 0 ? -1 : 1;\n      position *= Math.ceil(maxPosition / step) * step;\n    }\n\n    // If computed line position returns negative then line numbers are\n    // relative to the bottom of the video instead of the top. Therefore, we\n    // need to increase our initial position by the length or width of the\n    // video, depending on the writing direction, and reverse our axis directions.\n    if (linePos < 0) {\n      position += cue.vertical === \"\" ? containerBox.height : containerBox.width;\n      axis = axis.reverse();\n    }\n\n    // Move the box to the specified position. This may not be its best\n    // position.\n    boxPosition.move(initialAxis, position);\n\n  } else {\n    // If we have a percentage line value for the cue.\n    var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;\n\n    switch (cue.lineAlign) {\n    case \"middle\":\n      linePos -= (calculatedPercentage / 2);\n      break;\n    case \"end\":\n      linePos -= calculatedPercentage;\n      break;\n    }\n\n    // Apply initial line position to the cue box.\n    switch (cue.vertical) {\n    case \"\":\n      styleBox.applyStyles({\n        top: styleBox.formatStyle(linePos, \"%\")\n      });\n      break;\n    case \"rl\":\n      styleBox.applyStyles({\n        left: styleBox.formatStyle(linePos, \"%\")\n      });\n      break;\n    case \"lr\":\n      styleBox.applyStyles({\n        right: styleBox.formatStyle(linePos, \"%\")\n      });\n      break;\n    }\n\n    axis = [ \"+y\", \"-x\", \"+x\", \"-y\" ];\n\n    // Get the box position again after we've applied the specified positioning\n    // to it.\n    boxPosition = new BoxPosition(styleBox);\n  }\n\n  var bestPosition = findBestPosition(boxPosition, axis);\n  styleBox.move(bestPosition.toCSSCompatValues(containerBox));\n}\n\nfunction WebVTT() {\n  // Nothing\n}\n\n// Helper to allow strings to be decoded instead of the default binary utf8 data.\nWebVTT.StringDecoder = function() {\n  return {\n    decode: function(data) {\n      if (!data) {\n        return \"\";\n      }\n      if (typeof data !== \"string\") {\n        throw new Error(\"Error - expected string data.\");\n      }\n      return decodeURIComponent(encodeURIComponent(data));\n    }\n  };\n};\n\nWebVTT.convertCueToDOMTree = function(window, cuetext) {\n  if (!window || !cuetext) {\n    return null;\n  }\n  return parseContent(window, cuetext);\n};\n\nvar FONT_SIZE_PERCENT = 0.05;\nvar FONT_STYLE = \"sans-serif\";\nvar CUE_BACKGROUND_PADDING = \"1.5%\";\n\n// Runs the processing model over the cues and regions passed to it.\n// @param overlay A block level element (usually a div) that the computed cues\n//                and regions will be placed into.\nWebVTT.processCues = function(window, cues, overlay) {\n  if (!window || !cues || !overlay) {\n    return null;\n  }\n\n  // Remove all previous children.\n  while (overlay.firstChild) {\n    overlay.removeChild(overlay.firstChild);\n  }\n\n  var paddedOverlay = window.document.createElement(\"div\");\n  paddedOverlay.style.position = \"absolute\";\n  paddedOverlay.style.left = \"0\";\n  paddedOverlay.style.right = \"0\";\n  paddedOverlay.style.top = \"0\";\n  paddedOverlay.style.bottom = \"0\";\n  paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;\n  overlay.appendChild(paddedOverlay);\n\n  // Determine if we need to compute the display states of the cues. This could\n  // be the case if a cue's state has been changed since the last computation or\n  // if it has not been computed yet.\n  function shouldCompute(cues) {\n    for (var i = 0; i < cues.length; i++) {\n      if (cues[i].hasBeenReset || !cues[i].displayState) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // We don't need to recompute the cues' display states. Just reuse them.\n  if (!shouldCompute(cues)) {\n    for (var i = 0; i < cues.length; i++) {\n      paddedOverlay.appendChild(cues[i].displayState);\n    }\n    return;\n  }\n\n  var boxPositions = [],\n      containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),\n      fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;\n  var styleOptions = {\n    font: fontSize + \"px \" + FONT_STYLE\n  };\n\n  (function() {\n    var styleBox, cue;\n\n    for (var i = 0; i < cues.length; i++) {\n      cue = cues[i];\n\n      // Compute the intial position and styles of the cue div.\n      styleBox = new CueStyleBox(window, cue, styleOptions);\n      paddedOverlay.appendChild(styleBox.div);\n\n      // Move the cue div to it's correct line position.\n      moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);\n\n      // Remember the computed div so that we don't have to recompute it later\n      // if we don't have too.\n      cue.displayState = styleBox.div;\n\n      boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));\n    }\n  })();\n};\n\nWebVTT.Parser = function(window, vttjs, decoder) {\n  if (!decoder) {\n    decoder = vttjs;\n    vttjs = {};\n  }\n  if (!vttjs) {\n    vttjs = {};\n  }\n\n  this.window = window;\n  this.vttjs = vttjs;\n  this.state = \"INITIAL\";\n  this.buffer = \"\";\n  this.decoder = decoder || new TextDecoder(\"utf8\");\n  this.regionList = [];\n};\n\nWebVTT.Parser.prototype = {\n  // If the error is a ParsingError then report it to the consumer if\n  // possible. If it's not a ParsingError then throw it like normal.\n  reportOrThrowError: function(e) {\n    if (e instanceof ParsingError) {\n      this.onparsingerror && this.onparsingerror(e);\n    } else {\n      throw e;\n    }\n  },\n  parse: function (data) {\n    var self = this;\n\n    // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n    if (data) {\n      // Try to decode the data that we received.\n      self.buffer += self.decoder.decode(data, {stream: true});\n    }\n\n    function collectNextLine() {\n      var buffer = self.buffer;\n      var pos = 0;\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n      var line = buffer.substr(0, pos);\n      // Advance the buffer early in case we fail below.\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n      self.buffer = buffer.substr(pos);\n      return line;\n    }\n\n    // 3.4 WebVTT region and WebVTT region settings syntax\n    function parseRegion(input) {\n      var settings = new Settings();\n\n      parseOptions(input, function (k, v) {\n        switch (k) {\n        case \"id\":\n          settings.set(k, v);\n          break;\n        case \"width\":\n          settings.percent(k, v);\n          break;\n        case \"lines\":\n          settings.integer(k, v);\n          break;\n        case \"regionanchor\":\n        case \"viewportanchor\":\n          var xy = v.split(',');\n          if (xy.length !== 2) {\n            break;\n          }\n          // We have to make sure both x and y parse, so use a temporary\n          // settings object here.\n          var anchor = new Settings();\n          anchor.percent(\"x\", xy[0]);\n          anchor.percent(\"y\", xy[1]);\n          if (!anchor.has(\"x\") || !anchor.has(\"y\")) {\n            break;\n          }\n          settings.set(k + \"X\", anchor.get(\"x\"));\n          settings.set(k + \"Y\", anchor.get(\"y\"));\n          break;\n        case \"scroll\":\n          settings.alt(k, v, [\"up\"]);\n          break;\n        }\n      }, /=/, /\\s/);\n\n      // Create the region, using default values for any values that were not\n      // specified.\n      if (settings.has(\"id\")) {\n        var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();\n        region.width = settings.get(\"width\", 100);\n        region.lines = settings.get(\"lines\", 3);\n        region.regionAnchorX = settings.get(\"regionanchorX\", 0);\n        region.regionAnchorY = settings.get(\"regionanchorY\", 100);\n        region.viewportAnchorX = settings.get(\"viewportanchorX\", 0);\n        region.viewportAnchorY = settings.get(\"viewportanchorY\", 100);\n        region.scroll = settings.get(\"scroll\", \"\");\n        // Register the region.\n        self.onregion && self.onregion(region);\n        // Remember the VTTRegion for later in case we parse any VTTCues that\n        // reference it.\n        self.regionList.push({\n          id: settings.get(\"id\"),\n          region: region\n        });\n      }\n    }\n\n    // draft-pantos-http-live-streaming-20\n    // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5\n    // 3.5 WebVTT\n    function parseTimestampMap(input) {\n      var settings = new Settings();\n\n      parseOptions(input, function(k, v) {\n        switch(k) {\n        case \"MPEGT\":\n          settings.integer(k + 'S', v);\n          break;\n        case \"LOCA\":\n          settings.set(k + 'L', parseTimeStamp(v));\n          break;\n        }\n      }, /[^\\d]:/, /,/);\n\n      self.ontimestampmap && self.ontimestampmap({\n        \"MPEGTS\": settings.get(\"MPEGTS\"),\n        \"LOCAL\": settings.get(\"LOCAL\")\n      });\n    }\n\n    // 3.2 WebVTT metadata header syntax\n    function parseHeader(input) {\n      if (input.match(/X-TIMESTAMP-MAP/)) {\n        // This line contains HLS X-TIMESTAMP-MAP metadata\n        parseOptions(input, function(k, v) {\n          switch(k) {\n          case \"X-TIMESTAMP-MAP\":\n            parseTimestampMap(v);\n            break;\n          }\n        }, /=/);\n      } else {\n        parseOptions(input, function (k, v) {\n          switch (k) {\n          case \"Region\":\n            // 3.3 WebVTT region metadata header syntax\n            parseRegion(v);\n            break;\n          }\n        }, /:/);\n      }\n\n    }\n\n    // 5.1 WebVTT file parsing.\n    try {\n      var line;\n      if (self.state === \"INITIAL\") {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(self.buffer)) {\n          return this;\n        }\n\n        line = collectNextLine();\n\n        var m = line.match(/^WEBVTT([ \\t].*)?$/);\n        if (!m || !m[0]) {\n          throw new ParsingError(ParsingError.Errors.BadSignature);\n        }\n\n        self.state = \"HEADER\";\n      }\n\n      var alreadyCollectedLine = false;\n      while (self.buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(self.buffer)) {\n          return this;\n        }\n\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n\n        switch (self.state) {\n        case \"HEADER\":\n          // 13-18 - Allow a header (metadata) under the WEBVTT line.\n          if (/:/.test(line)) {\n            parseHeader(line);\n          } else if (!line) {\n            // An empty line terminates the header and starts the body (cues).\n            self.state = \"ID\";\n          }\n          continue;\n        case \"NOTE\":\n          // Ignore NOTE blocks.\n          if (!line) {\n            self.state = \"ID\";\n          }\n          continue;\n        case \"ID\":\n          // Check for the start of NOTE blocks.\n          if (/^NOTE($|[ \\t])/.test(line)) {\n            self.state = \"NOTE\";\n            break;\n          }\n          // 19-29 - Allow any number of line terminators, then initialize new cue values.\n          if (!line) {\n            continue;\n          }\n          self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, \"\");\n          self.state = \"CUE\";\n          // 30-39 - Check if self line contains an optional identifier or timing data.\n          if (line.indexOf(\"-->\") === -1) {\n            self.cue.id = line;\n            continue;\n          }\n          // Process line as start of a cue.\n          /*falls through*/\n        case \"CUE\":\n          // 40 - Collect cue timings and settings.\n          try {\n            parseCue(line, self.cue, self.regionList);\n          } catch (e) {\n            self.reportOrThrowError(e);\n            // In case of an error ignore rest of the cue.\n            self.cue = null;\n            self.state = \"BADCUE\";\n            continue;\n          }\n          self.state = \"CUETEXT\";\n          continue;\n        case \"CUETEXT\":\n          var hasSubstring = line.indexOf(\"-->\") !== -1;\n          // 34 - If we have an empty line then report the cue.\n          // 35 - If we have the special substring '-->' then report the cue,\n          // but do not collect the line as we need to process the current\n          // one as a new cue.\n          if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n            // We are done parsing self cue.\n            self.oncue && self.oncue(self.cue);\n            self.cue = null;\n            self.state = \"ID\";\n            continue;\n          }\n          if (self.cue.text) {\n            self.cue.text += \"\\n\";\n          }\n          self.cue.text += line;\n          continue;\n        case \"BADCUE\": // BADCUE\n          // 54-62 - Collect and discard the remaining cue.\n          if (!line) {\n            self.state = \"ID\";\n          }\n          continue;\n        }\n      }\n    } catch (e) {\n      self.reportOrThrowError(e);\n\n      // If we are currently parsing a cue, report what we have.\n      if (self.state === \"CUETEXT\" && self.cue && self.oncue) {\n        self.oncue(self.cue);\n      }\n      self.cue = null;\n      // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n      self.state = self.state === \"INITIAL\" ? \"BADWEBVTT\" : \"BADCUE\";\n    }\n    return this;\n  },\n  flush: function () {\n    var self = this;\n    try {\n      // Finish decoding the stream.\n      self.buffer += self.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (self.cue || self.state === \"HEADER\") {\n        self.buffer += \"\\n\\n\";\n        self.parse();\n      }\n      // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n      if (self.state === \"INITIAL\") {\n        throw new ParsingError(ParsingError.Errors.BadSignature);\n      }\n    } catch(e) {\n      self.reportOrThrowError(e);\n    }\n    self.onflush && self.onflush();\n    return this;\n  }\n};\n\nmodule.exports = WebVTT;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmlkZW9qcy12dHQuanMvbGliL3Z0dC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92aWRlb2pzLXZ0dC5qcy9saWIvdnR0LmpzP2QwMmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiAtKi0gTW9kZTogSmF2YTsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGMtYmFzaWMtb2Zmc2V0OiAyIC0qLSAqL1xuLyogdmltOiBzZXQgc2hpZnR3aWR0aD0yIHRhYnN0b3A9MiBhdXRvaW5kZW50IGNpbmRlbnQgZXhwYW5kdGFiOiAqL1xudmFyIF9vYmpDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRigpIHt9XG4gIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0LmNyZWF0ZSBzaGltIG9ubHkgYWNjZXB0cyBvbmUgcGFyYW1ldGVyLicpO1xuICAgIH1cbiAgICBGLnByb3RvdHlwZSA9IG87XG4gICAgcmV0dXJuIG5ldyBGKCk7XG4gIH07XG59KSgpO1xuXG4vLyBDcmVhdGVzIGEgbmV3IFBhcnNlckVycm9yIG9iamVjdCBmcm9tIGFuIGVycm9yRGF0YSBvYmplY3QuIFRoZSBlcnJvckRhdGFcbi8vIG9iamVjdCBzaG91bGQgaGF2ZSBkZWZhdWx0IGNvZGUgYW5kIG1lc3NhZ2UgcHJvcGVydGllcy4gVGhlIGRlZmF1bHQgbWVzc2FnZVxuLy8gcHJvcGVydHkgY2FuIGJlIG92ZXJyaWRlbiBieSBwYXNzaW5nIGluIGEgbWVzc2FnZSBwYXJhbWV0ZXIuXG4vLyBTZWUgUGFyc2luZ0Vycm9yLkVycm9ycyBiZWxvdyBmb3IgYWNjZXB0YWJsZSBlcnJvcnMuXG5mdW5jdGlvbiBQYXJzaW5nRXJyb3IoZXJyb3JEYXRhLCBtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiUGFyc2luZ0Vycm9yXCI7XG4gIHRoaXMuY29kZSA9IGVycm9yRGF0YS5jb2RlO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IGVycm9yRGF0YS5tZXNzYWdlO1xufVxuUGFyc2luZ0Vycm9yLnByb3RvdHlwZSA9IF9vYmpDcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblBhcnNpbmdFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJzaW5nRXJyb3I7XG5cbi8vIFBhcnNpbmdFcnJvciBtZXRhZGF0YSBmb3IgYWNjZXB0YWJsZSBQYXJzaW5nRXJyb3JzLlxuUGFyc2luZ0Vycm9yLkVycm9ycyA9IHtcbiAgQmFkU2lnbmF0dXJlOiB7XG4gICAgY29kZTogMCxcbiAgICBtZXNzYWdlOiBcIk1hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLlwiXG4gIH0sXG4gIEJhZFRpbWVTdGFtcDoge1xuICAgIGNvZGU6IDEsXG4gICAgbWVzc2FnZTogXCJNYWxmb3JtZWQgdGltZSBzdGFtcC5cIlxuICB9XG59O1xuXG4vLyBUcnkgdG8gcGFyc2UgaW5wdXQgYXMgYSB0aW1lIHN0YW1wLlxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAoaW5wdXQpIHtcblxuICBmdW5jdGlvbiBjb21wdXRlU2Vjb25kcyhoLCBtLCBzLCBmKSB7XG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIChmIHwgMCkgLyAxMDAwO1xuICB9XG5cbiAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihcXGQrKTooXFxkezJ9KSg6XFxkezJ9KT9cXC4oXFxkezN9KS8pO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChtWzNdKSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCBtWzNdLnJlcGxhY2UoXCI6XCIsIFwiXCIpLCBtWzRdKTtcbiAgfSBlbHNlIGlmIChtWzFdID4gNTkpIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc10uW21pbGxpc2Vjb25kc11cbiAgICAvLyBGaXJzdCBwb3NpdGlvbiBpcyBob3VycyBhcyBpdCdzIG92ZXIgNTkuXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIDAsICBtWzRdKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcygwLCBtWzFdLCBtWzJdLCBtWzRdKTtcbiAgfVxufVxuXG4vLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3Rcbi8vIGFzc2lnbm1lbnQgdG8gYSBzcGVjaWZpYyBrZXkuXG5mdW5jdGlvbiBTZXR0aW5ncygpIHtcbiAgdGhpcy52YWx1ZXMgPSBfb2JqQ3JlYXRlKG51bGwpO1xufVxuXG5TZXR0aW5ncy5wcm90b3R5cGUgPSB7XG4gIC8vIE9ubHkgYWNjZXB0IHRoZSBmaXJzdCBhc3NpZ25tZW50IHRvIGFueSBrZXkuXG4gIHNldDogZnVuY3Rpb24oaywgdikge1xuICAgIGlmICghdGhpcy5nZXQoaykgJiYgdiAhPT0gXCJcIikge1xuICAgICAgdGhpcy52YWx1ZXNba10gPSB2O1xuICAgIH1cbiAgfSxcbiAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgYSBrZXksIG9yIGEgZGVmYXVsdCB2YWx1ZS5cbiAgLy8gSWYgJ2RlZmF1bHRLZXknIGlzIHBhc3NlZCB0aGVuICdkZmx0JyBpcyBhc3N1bWVkIHRvIGJlIGFuIG9iamVjdCB3aXRoXG4gIC8vIGEgbnVtYmVyIG9mIHBvc3NpYmxlIGRlZmF1bHQgdmFsdWVzIGFzIHByb3BlcnRpZXMgd2hlcmUgJ2RlZmF1bHRLZXknIGlzXG4gIC8vIHRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBjaG9zZW47IG90aGVyd2lzZSBpdCdzIGFzc3VtZWQgdG8gYmVcbiAgLy8gYSBzaW5nbGUgdmFsdWUuXG4gIGdldDogZnVuY3Rpb24oaywgZGZsdCwgZGVmYXVsdEtleSkge1xuICAgIGlmIChkZWZhdWx0S2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHRbZGVmYXVsdEtleV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdDtcbiAgfSxcbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgdmFsdWUgZm9yIGEga2V5LlxuICBoYXM6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayBpbiB0aGlzLnZhbHVlcztcbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgb25lIG9mIHRoZSBnaXZlbiBhbHRlcm5hdGl2ZXMuXG4gIGFsdDogZnVuY3Rpb24oaywgdiwgYSkge1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYS5sZW5ndGg7ICsrbikge1xuICAgICAgaWYgKHYgPT09IGFbbl0pIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICBpbnRlZ2VyOiBmdW5jdGlvbihrLCB2KSB7XG4gICAgaWYgKC9eLT9cXGQrJC8udGVzdCh2KSkgeyAvLyBpbnRlZ2VyXG4gICAgICB0aGlzLnNldChrLCBwYXJzZUludCh2LCAxMCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCBwZXJjZW50YWdlLlxuICBwZXJjZW50OiBmdW5jdGlvbihrLCB2KSB7XG4gICAgdmFyIG07XG4gICAgaWYgKChtID0gdi5tYXRjaCgvXihbXFxkXXsxLDN9KShcXC5bXFxkXSopPyUkLykpKSB7XG4gICAgICB2ID0gcGFyc2VGbG9hdCh2KTtcbiAgICAgIGlmICh2ID49IDAgJiYgdiA8PSAxMDApIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBpbnB1dCBpbnRvIGdyb3VwcyBzZXBhcmF0ZWQgYnkgJ2dyb3VwRGVsaW0nLCBhbmRcbi8vIGludGVycHJldGUgZWFjaCBncm91cCBhcyBhIGtleS92YWx1ZSBwYWlyIHNlcGFyYXRlZCBieSAna2V5VmFsdWVEZWxpbScuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMoaW5wdXQsIGNhbGxiYWNrLCBrZXlWYWx1ZURlbGltLCBncm91cERlbGltKSB7XG4gIHZhciBncm91cHMgPSBncm91cERlbGltID8gaW5wdXQuc3BsaXQoZ3JvdXBEZWxpbSkgOiBbaW5wdXRdO1xuICBmb3IgKHZhciBpIGluIGdyb3Vwcykge1xuICAgIGlmICh0eXBlb2YgZ3JvdXBzW2ldICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGt2ID0gZ3JvdXBzW2ldLnNwbGl0KGtleVZhbHVlRGVsaW0pO1xuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgayA9IGt2WzBdO1xuICAgIHZhciB2ID0ga3ZbMV07XG4gICAgY2FsbGJhY2soaywgdik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VDdWUoaW5wdXQsIGN1ZSwgcmVnaW9uTGlzdCkge1xuICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgdmFyIG9JbnB1dCA9IGlucHV0O1xuICAvLyA0LjEgV2ViVlRUIHRpbWVzdGFtcFxuICBmdW5jdGlvbiBjb25zdW1lVGltZVN0YW1wKCkge1xuICAgIHZhciB0cyA9IHBhcnNlVGltZVN0YW1wKGlucHV0KTtcbiAgICBpZiAodHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yLkVycm9ycy5CYWRUaW1lU3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNYWxmb3JtZWQgdGltZXN0YW1wOiBcIiArIG9JbnB1dCk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aW1lIHN0YW1wIGZyb20gaW5wdXQuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCBcIlwiKTtcbiAgICByZXR1cm4gdHM7XG4gIH1cblxuICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXG4gIGZ1bmN0aW9uIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKSB7XG4gICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG5cbiAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICBzd2l0Y2ggKGspIHtcbiAgICAgIGNhc2UgXCJyZWdpb25cIjpcbiAgICAgICAgLy8gRmluZCB0aGUgbGFzdCByZWdpb24gd2UgcGFyc2VkIHdpdGggdGhlIHNhbWUgcmVnaW9uIGlkLlxuICAgICAgICBmb3IgKHZhciBpID0gcmVnaW9uTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zZXQoaywgcmVnaW9uTGlzdFtpXS5yZWdpb24pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbXCJybFwiLCBcImxyXCJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICB2YXIgdmFscyA9IHYuc3BsaXQoXCIsXCIpLFxuICAgICAgICAgICAgdmFsczAgPSB2YWxzWzBdO1xuICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHZhbHMwKTtcbiAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzMCkgPyBzZXR0aW5ncy5zZXQoXCJzbmFwVG9MaW5lc1wiLCBmYWxzZSkgOiBudWxsO1xuICAgICAgICBzZXR0aW5ncy5hbHQoaywgdmFsczAsIFtcImF1dG9cIl0pO1xuICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoXCJsaW5lQWxpZ25cIiwgdmFsc1sxXSwgW1wic3RhcnRcIiwgXCJtaWRkbGVcIiwgXCJlbmRcIl0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvc2l0aW9uXCI6XG4gICAgICAgIHZhbHMgPSB2LnNwbGl0KFwiLFwiKTtcbiAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzWzBdKTtcbiAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KFwicG9zaXRpb25BbGlnblwiLCB2YWxzWzFdLCBbXCJzdGFydFwiLCBcIm1pZGRsZVwiLCBcImVuZFwiXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2l6ZVwiOlxuICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhbGlnblwiOlxuICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgW1wic3RhcnRcIiwgXCJtaWRkbGVcIiwgXCJlbmRcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LCAvOi8sIC9cXHMvKTtcblxuICAgIC8vIEFwcGx5IGRlZmF1bHQgdmFsdWVzIGZvciBhbnkgbWlzc2luZyBmaWVsZHMuXG4gICAgY3VlLnJlZ2lvbiA9IHNldHRpbmdzLmdldChcInJlZ2lvblwiLCBudWxsKTtcbiAgICBjdWUudmVydGljYWwgPSBzZXR0aW5ncy5nZXQoXCJ2ZXJ0aWNhbFwiLCBcIlwiKTtcbiAgICBjdWUubGluZSA9IHNldHRpbmdzLmdldChcImxpbmVcIiwgXCJhdXRvXCIpO1xuICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoXCJsaW5lQWxpZ25cIiwgXCJzdGFydFwiKTtcbiAgICBjdWUuc25hcFRvTGluZXMgPSBzZXR0aW5ncy5nZXQoXCJzbmFwVG9MaW5lc1wiLCB0cnVlKTtcbiAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldChcInNpemVcIiwgMTAwKTtcbiAgICBjdWUuYWxpZ24gPSBzZXR0aW5ncy5nZXQoXCJhbGlnblwiLCBcIm1pZGRsZVwiKTtcbiAgICBjdWUucG9zaXRpb24gPSBzZXR0aW5ncy5nZXQoXCJwb3NpdGlvblwiLCB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBtaWRkbGU6IDUwLFxuICAgICAgZW5kOiAxMDAsXG4gICAgICByaWdodDogMTAwXG4gICAgfSwgY3VlLmFsaWduKTtcbiAgICBjdWUucG9zaXRpb25BbGlnbiA9IHNldHRpbmdzLmdldChcInBvc2l0aW9uQWxpZ25cIiwge1xuICAgICAgc3RhcnQ6IFwic3RhcnRcIixcbiAgICAgIGxlZnQ6IFwic3RhcnRcIixcbiAgICAgIG1pZGRsZTogXCJtaWRkbGVcIixcbiAgICAgIGVuZDogXCJlbmRcIixcbiAgICAgIHJpZ2h0OiBcImVuZFwiXG4gICAgfSwgY3VlLmFsaWduKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlxccysvLCBcIlwiKTtcbiAgfVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHRpbWluZ3MuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGN1ZS5zdGFydFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7ICAgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgaWYgKGlucHV0LnN1YnN0cigwLCAzKSAhPT0gXCItLT5cIikgeyAgICAgLy8gKDMpIG5leHQgY2hhcmFjdGVycyBtdXN0IG1hdGNoIFwiLS0+XCJcbiAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvci5FcnJvcnMuQmFkVGltZVN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgJy0tPicpOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvSW5wdXQpO1xuICB9XG4gIGlucHV0ID0gaW5wdXQuc3Vic3RyKDMpO1xuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgICAgIC8vICg1KSBjb2xsZWN0IGN1ZSBlbmQgdGltZVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHNldHRpbmdzIGxpc3QuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKTtcbn1cblxudmFyIEVTQ0FQRSA9IHtcbiAgXCImYW1wO1wiOiBcIiZcIixcbiAgXCImbHQ7XCI6IFwiPFwiLFxuICBcIiZndDtcIjogXCI+XCIsXG4gIFwiJmxybTtcIjogXCJcXHUyMDBlXCIsXG4gIFwiJnJsbTtcIjogXCJcXHUyMDBmXCIsXG4gIFwiJm5ic3A7XCI6IFwiXFx1MDBhMFwiXG59O1xuXG52YXIgVEFHX05BTUUgPSB7XG4gIGM6IFwic3BhblwiLFxuICBpOiBcImlcIixcbiAgYjogXCJiXCIsXG4gIHU6IFwidVwiLFxuICBydWJ5OiBcInJ1YnlcIixcbiAgcnQ6IFwicnRcIixcbiAgdjogXCJzcGFuXCIsXG4gIGxhbmc6IFwic3BhblwiXG59O1xuXG52YXIgVEFHX0FOTk9UQVRJT04gPSB7XG4gIHY6IFwidGl0bGVcIixcbiAgbGFuZzogXCJsYW5nXCJcbn07XG5cbnZhciBORUVEU19QQVJFTlQgPSB7XG4gIHJ0OiBcInJ1YnlcIlxufTtcblxuLy8gUGFyc2UgY29udGVudCBpbnRvIGEgZG9jdW1lbnQgZnJhZ21lbnQuXG5mdW5jdGlvbiBwYXJzZUNvbnRlbnQod2luZG93LCBpbnB1dCkge1xuICBmdW5jdGlvbiBuZXh0VG9rZW4oKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGVuZC1vZi1zdHJpbmcuXG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZSAnbicgY2hhcmFjdGVycyBmcm9tIHRoZSBpbnB1dC5cbiAgICBmdW5jdGlvbiBjb25zdW1lKHJlc3VsdCkge1xuICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHIocmVzdWx0Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBtID0gaW5wdXQubWF0Y2goL14oW148XSopKDxbXj5dKj4/KT8vKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBzb21lIHRleHQgYmVmb3JlIHRoZSBuZXh0IHRhZywgcmV0dXJuIGl0LCBvdGhlcndpc2UgcmV0dXJuXG4gICAgLy8gdGhlIHRhZy5cbiAgICByZXR1cm4gY29uc3VtZShtWzFdID8gbVsxXSA6IG1bMl0pO1xuICB9XG5cbiAgLy8gVW5lc2NhcGUgYSBzdHJpbmcgJ3MnLlxuICBmdW5jdGlvbiB1bmVzY2FwZTEoZSkge1xuICAgIHJldHVybiBFU0NBUEVbZV07XG4gIH1cbiAgZnVuY3Rpb24gdW5lc2NhcGUocykge1xuICAgIHdoaWxlICgobSA9IHMubWF0Y2goLyYoYW1wfGx0fGd0fGxybXxybG18bmJzcCk7LykpKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKG1bMF0sIHVuZXNjYXBlMSk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkQWRkKGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIU5FRURTX1BBUkVOVFtlbGVtZW50LmxvY2FsTmFtZV0gfHxcbiAgICAgICAgICAgTkVFRFNfUEFSRU5UW2VsZW1lbnQubG9jYWxOYW1lXSA9PT0gY3VycmVudC5sb2NhbE5hbWU7XG4gIH1cblxuICAvLyBDcmVhdGUgYW4gZWxlbWVudCBmb3IgdGhpcyB0YWcuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgYW5ub3RhdGlvbikge1xuICAgIHZhciB0YWdOYW1lID0gVEFHX05BTUVbdHlwZV07XG4gICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBlbGVtZW50LmxvY2FsTmFtZSA9IHRhZ05hbWU7XG4gICAgdmFyIG5hbWUgPSBUQUdfQU5OT1RBVElPTlt0eXBlXTtcbiAgICBpZiAobmFtZSAmJiBhbm5vdGF0aW9uKSB7XG4gICAgICBlbGVtZW50W25hbWVdID0gYW5ub3RhdGlvbi50cmltKCk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdmFyIHJvb3REaXYgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgIGN1cnJlbnQgPSByb290RGl2LFxuICAgICAgdCxcbiAgICAgIHRhZ1N0YWNrID0gW107XG5cbiAgd2hpbGUgKCh0ID0gbmV4dFRva2VuKCkpICE9PSBudWxsKSB7XG4gICAgaWYgKHRbMF0gPT09ICc8Jykge1xuICAgICAgaWYgKHRbMV0gPT09IFwiL1wiKSB7XG4gICAgICAgIC8vIElmIHRoZSBjbG9zaW5nIHRhZyBtYXRjaGVzLCBtb3ZlIGJhY2sgdXAgdG8gdGhlIHBhcmVudCBub2RlLlxuICAgICAgICBpZiAodGFnU3RhY2subGVuZ3RoICYmXG4gICAgICAgICAgICB0YWdTdGFja1t0YWdTdGFjay5sZW5ndGggLSAxXSA9PT0gdC5zdWJzdHIoMikucmVwbGFjZShcIj5cIiwgXCJcIikpIHtcbiAgICAgICAgICB0YWdTdGFjay5wb3AoKTtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGlnbm9yZSB0aGUgZW5kIHRhZy5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgdHMgPSBwYXJzZVRpbWVTdGFtcCh0LnN1YnN0cigxLCB0Lmxlbmd0aCAtIDIpKTtcbiAgICAgIHZhciBub2RlO1xuICAgICAgaWYgKHRzKSB7XG4gICAgICAgIC8vIFRpbWVzdGFtcHMgYXJlIGxlYWQgbm9kZXMgYXMgd2VsbC5cbiAgICAgICAgbm9kZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oXCJ0aW1lc3RhbXBcIiwgdHMpO1xuICAgICAgICBjdXJyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtID0gdC5tYXRjaCgvXjwoW14uXFxzLzAtOT5dKykoXFwuW15cXHNcXFxcPl0rKT8oW14+XFxcXF0rKT8oXFxcXD8pPj8kLyk7XG4gICAgICAvLyBJZiB3ZSBjYW4ndCBwYXJzZSB0aGUgdGFnLCBza2lwIHRvIHRoZSBuZXh0IHRhZy5cbiAgICAgIGlmICghbSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRyeSB0byBjb25zdHJ1Y3QgYW4gZWxlbWVudCwgYW5kIGlnbm9yZSB0aGUgdGFnIGlmIHdlIGNvdWxkbid0LlxuICAgICAgbm9kZSA9IGNyZWF0ZUVsZW1lbnQobVsxXSwgbVszXSk7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIHRhZyBzaG91bGQgYmUgYWRkZWQgYmFzZWQgb24gdGhlIGNvbnRleHQgb2Ygd2hlcmUgaXRcbiAgICAgIC8vIGlzIHBsYWNlZCBpbiB0aGUgY3VldGV4dC5cbiAgICAgIGlmICghc2hvdWxkQWRkKGN1cnJlbnQsIG5vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gU2V0IHRoZSBjbGFzcyBsaXN0IChhcyBhIGxpc3Qgb2YgY2xhc3Nlcywgc2VwYXJhdGVkIGJ5IHNwYWNlKS5cbiAgICAgIGlmIChtWzJdKSB7XG4gICAgICAgIG5vZGUuY2xhc3NOYW1lID0gbVsyXS5zdWJzdHIoMSkucmVwbGFjZSgnLicsICcgJyk7XG4gICAgICB9XG4gICAgICAvLyBBcHBlbmQgdGhlIG5vZGUgdG8gdGhlIGN1cnJlbnQgbm9kZSwgYW5kIGVudGVyIHRoZSBzY29wZSBvZiB0aGUgbmV3XG4gICAgICAvLyBub2RlLlxuICAgICAgdGFnU3RhY2sucHVzaChtWzFdKTtcbiAgICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBjdXJyZW50ID0gbm9kZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFRleHQgbm9kZXMgYXJlIGxlYWYgbm9kZXMuXG4gICAgY3VycmVudC5hcHBlbmRDaGlsZCh3aW5kb3cuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodW5lc2NhcGUodCkpKTtcbiAgfVxuXG4gIHJldHVybiByb290RGl2O1xufVxuXG4vLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgdGhlIFVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYSBzdHJvbmdcbi8vIHJpZ2h0LXRvLWxlZnQgY2F0ZWdvcnkuIFdoYXQgdGhpcyBtZWFucyBpcyB0aGF0IHRoZXNlIGNoYXJhY3RlcnMgYXJlXG4vLyB3cml0dGVuIHJpZ2h0LXRvLWxlZnQgZm9yIHN1cmUuIEl0IHdhcyBnZW5lcmF0ZWQgYnkgcHVsbGluZyBhbGwgdGhlIHN0cm9uZ1xuLy8gcmlnaHQtdG8tbGVmdCBjaGFyYWN0ZXJzIG91dCBvZiB0aGUgVW5pY29kZSBkYXRhIHRhYmxlLiBUaGF0IHRhYmxlIGNhblxuLy8gZm91bmQgYXQ6IGh0dHA6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VOSURBVEEvVW5pY29kZURhdGEudHh0XG52YXIgc3Ryb25nUlRMUmFuZ2VzID0gW1sweDViZSwgMHg1YmVdLCBbMHg1YzAsIDB4NWMwXSwgWzB4NWMzLCAweDVjM10sIFsweDVjNiwgMHg1YzZdLFxuIFsweDVkMCwgMHg1ZWFdLCBbMHg1ZjAsIDB4NWY0XSwgWzB4NjA4LCAweDYwOF0sIFsweDYwYiwgMHg2MGJdLCBbMHg2MGQsIDB4NjBkXSxcbiBbMHg2MWIsIDB4NjFiXSwgWzB4NjFlLCAweDY0YV0sIFsweDY2ZCwgMHg2NmZdLCBbMHg2NzEsIDB4NmQ1XSwgWzB4NmU1LCAweDZlNl0sXG4gWzB4NmVlLCAweDZlZl0sIFsweDZmYSwgMHg3MGRdLCBbMHg3MGYsIDB4NzEwXSwgWzB4NzEyLCAweDcyZl0sIFsweDc0ZCwgMHg3YTVdLFxuIFsweDdiMSwgMHg3YjFdLCBbMHg3YzAsIDB4N2VhXSwgWzB4N2Y0LCAweDdmNV0sIFsweDdmYSwgMHg3ZmFdLCBbMHg4MDAsIDB4ODE1XSxcbiBbMHg4MWEsIDB4ODFhXSwgWzB4ODI0LCAweDgyNF0sIFsweDgyOCwgMHg4MjhdLCBbMHg4MzAsIDB4ODNlXSwgWzB4ODQwLCAweDg1OF0sXG4gWzB4ODVlLCAweDg1ZV0sIFsweDhhMCwgMHg4YTBdLCBbMHg4YTIsIDB4OGFjXSwgWzB4MjAwZiwgMHgyMDBmXSxcbiBbMHhmYjFkLCAweGZiMWRdLCBbMHhmYjFmLCAweGZiMjhdLCBbMHhmYjJhLCAweGZiMzZdLCBbMHhmYjM4LCAweGZiM2NdLFxuIFsweGZiM2UsIDB4ZmIzZV0sIFsweGZiNDAsIDB4ZmI0MV0sIFsweGZiNDMsIDB4ZmI0NF0sIFsweGZiNDYsIDB4ZmJjMV0sXG4gWzB4ZmJkMywgMHhmZDNkXSwgWzB4ZmQ1MCwgMHhmZDhmXSwgWzB4ZmQ5MiwgMHhmZGM3XSwgWzB4ZmRmMCwgMHhmZGZjXSxcbiBbMHhmZTcwLCAweGZlNzRdLCBbMHhmZTc2LCAweGZlZmNdLCBbMHgxMDgwMCwgMHgxMDgwNV0sIFsweDEwODA4LCAweDEwODA4XSxcbiBbMHgxMDgwYSwgMHgxMDgzNV0sIFsweDEwODM3LCAweDEwODM4XSwgWzB4MTA4M2MsIDB4MTA4M2NdLCBbMHgxMDgzZiwgMHgxMDg1NV0sXG4gWzB4MTA4NTcsIDB4MTA4NWZdLCBbMHgxMDkwMCwgMHgxMDkxYl0sIFsweDEwOTIwLCAweDEwOTM5XSwgWzB4MTA5M2YsIDB4MTA5M2ZdLFxuIFsweDEwOTgwLCAweDEwOWI3XSwgWzB4MTA5YmUsIDB4MTA5YmZdLCBbMHgxMGEwMCwgMHgxMGEwMF0sIFsweDEwYTEwLCAweDEwYTEzXSxcbiBbMHgxMGExNSwgMHgxMGExN10sIFsweDEwYTE5LCAweDEwYTMzXSwgWzB4MTBhNDAsIDB4MTBhNDddLCBbMHgxMGE1MCwgMHgxMGE1OF0sXG4gWzB4MTBhNjAsIDB4MTBhN2ZdLCBbMHgxMGIwMCwgMHgxMGIzNV0sIFsweDEwYjQwLCAweDEwYjU1XSwgWzB4MTBiNTgsIDB4MTBiNzJdLFxuIFsweDEwYjc4LCAweDEwYjdmXSwgWzB4MTBjMDAsIDB4MTBjNDhdLCBbMHgxZWUwMCwgMHgxZWUwM10sIFsweDFlZTA1LCAweDFlZTFmXSxcbiBbMHgxZWUyMSwgMHgxZWUyMl0sIFsweDFlZTI0LCAweDFlZTI0XSwgWzB4MWVlMjcsIDB4MWVlMjddLCBbMHgxZWUyOSwgMHgxZWUzMl0sXG4gWzB4MWVlMzQsIDB4MWVlMzddLCBbMHgxZWUzOSwgMHgxZWUzOV0sIFsweDFlZTNiLCAweDFlZTNiXSwgWzB4MWVlNDIsIDB4MWVlNDJdLFxuIFsweDFlZTQ3LCAweDFlZTQ3XSwgWzB4MWVlNDksIDB4MWVlNDldLCBbMHgxZWU0YiwgMHgxZWU0Yl0sIFsweDFlZTRkLCAweDFlZTRmXSxcbiBbMHgxZWU1MSwgMHgxZWU1Ml0sIFsweDFlZTU0LCAweDFlZTU0XSwgWzB4MWVlNTcsIDB4MWVlNTddLCBbMHgxZWU1OSwgMHgxZWU1OV0sXG4gWzB4MWVlNWIsIDB4MWVlNWJdLCBbMHgxZWU1ZCwgMHgxZWU1ZF0sIFsweDFlZTVmLCAweDFlZTVmXSwgWzB4MWVlNjEsIDB4MWVlNjJdLFxuIFsweDFlZTY0LCAweDFlZTY0XSwgWzB4MWVlNjcsIDB4MWVlNmFdLCBbMHgxZWU2YywgMHgxZWU3Ml0sIFsweDFlZTc0LCAweDFlZTc3XSxcbiBbMHgxZWU3OSwgMHgxZWU3Y10sIFsweDFlZTdlLCAweDFlZTdlXSwgWzB4MWVlODAsIDB4MWVlODldLCBbMHgxZWU4YiwgMHgxZWU5Yl0sXG4gWzB4MWVlYTEsIDB4MWVlYTNdLCBbMHgxZWVhNSwgMHgxZWVhOV0sIFsweDFlZWFiLCAweDFlZWJiXSwgWzB4MTBmZmZkLCAweDEwZmZmZF1dO1xuXG5mdW5jdGlvbiBpc1N0cm9uZ1JUTENoYXIoY2hhckNvZGUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJvbmdSVExSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3VycmVudFJhbmdlID0gc3Ryb25nUlRMUmFuZ2VzW2ldO1xuICAgIGlmIChjaGFyQ29kZSA+PSBjdXJyZW50UmFuZ2VbMF0gJiYgY2hhckNvZGUgPD0gY3VycmVudFJhbmdlWzFdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUJpZGkoY3VlRGl2KSB7XG4gIHZhciBub2RlU3RhY2sgPSBbXSxcbiAgICAgIHRleHQgPSBcIlwiLFxuICAgICAgY2hhckNvZGU7XG5cbiAgaWYgKCFjdWVEaXYgfHwgIWN1ZURpdi5jaGlsZE5vZGVzKSB7XG4gICAgcmV0dXJuIFwibHRyXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoTm9kZXMobm9kZVN0YWNrLCBub2RlKSB7XG4gICAgZm9yICh2YXIgaSA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbm9kZVN0YWNrLnB1c2gobm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKSB7XG4gICAgaWYgKCFub2RlU3RhY2sgfHwgIW5vZGVTdGFjay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbm9kZVN0YWNrLnBvcCgpLFxuICAgICAgICB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudCB8fCBub2RlLmlubmVyVGV4dDtcbiAgICBpZiAodGV4dCkge1xuICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbWF0Y2ggYWxsIHVuaWNvZGUgdHlwZSBCIGNoYXJhY3RlcnMgKHBhcmFncmFwaFxuICAgICAgLy8gc2VwYXJhdG9yIGNoYXJhY3RlcnMpLiBTZWUgaXNzdWUgIzExNS5cbiAgICAgIHZhciBtID0gdGV4dC5tYXRjaCgvXi4qKFxcbnxcXHIpLyk7XG4gICAgICBpZiAobSkge1xuICAgICAgICBub2RlU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gXCJydWJ5XCIpIHtcbiAgICAgIHJldHVybiBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGROb2Rlcykge1xuICAgICAgcHVzaE5vZGVzKG5vZGVTdGFjaywgbm9kZSk7XG4gICAgICByZXR1cm4gbmV4dFRleHROb2RlKG5vZGVTdGFjayk7XG4gICAgfVxuICB9XG5cbiAgcHVzaE5vZGVzKG5vZGVTdGFjaywgY3VlRGl2KTtcbiAgd2hpbGUgKCh0ZXh0ID0gbmV4dFRleHROb2RlKG5vZGVTdGFjaykpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChpc1N0cm9uZ1JUTENoYXIoY2hhckNvZGUpKSB7XG4gICAgICAgIHJldHVybiBcInJ0bFwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gXCJsdHJcIjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUxpbmVQb3MoY3VlKSB7XG4gIGlmICh0eXBlb2YgY3VlLmxpbmUgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgIChjdWUuc25hcFRvTGluZXMgfHwgKGN1ZS5saW5lID49IDAgJiYgY3VlLmxpbmUgPD0gMTAwKSkpIHtcbiAgICByZXR1cm4gY3VlLmxpbmU7XG4gIH1cbiAgaWYgKCFjdWUudHJhY2sgfHwgIWN1ZS50cmFjay50ZXh0VHJhY2tMaXN0IHx8XG4gICAgICAhY3VlLnRyYWNrLnRleHRUcmFja0xpc3QubWVkaWFFbGVtZW50KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciB0cmFjayA9IGN1ZS50cmFjayxcbiAgICAgIHRyYWNrTGlzdCA9IHRyYWNrLnRleHRUcmFja0xpc3QsXG4gICAgICBjb3VudCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMaXN0Lmxlbmd0aCAmJiB0cmFja0xpc3RbaV0gIT09IHRyYWNrOyBpKyspIHtcbiAgICBpZiAodHJhY2tMaXN0W2ldLm1vZGUgPT09IFwic2hvd2luZ1wiKSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKytjb3VudCAqIC0xO1xufVxuXG5mdW5jdGlvbiBTdHlsZUJveCgpIHtcbn1cblxuLy8gQXBwbHkgc3R5bGVzIHRvIGEgZGl2LiBJZiB0aGVyZSBpcyBubyBkaXYgcGFzc2VkIHRoZW4gaXQgZGVmYXVsdHMgdG8gdGhlXG4vLyBkaXYgb24gJ3RoaXMnLlxuU3R5bGVCb3gucHJvdG90eXBlLmFwcGx5U3R5bGVzID0gZnVuY3Rpb24oc3R5bGVzLCBkaXYpIHtcbiAgZGl2ID0gZGl2IHx8IHRoaXMuZGl2O1xuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlcykge1xuICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGRpdi5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXTtcbiAgICB9XG4gIH1cbn07XG5cblN0eWxlQm94LnByb3RvdHlwZS5mb3JtYXRTdHlsZSA9IGZ1bmN0aW9uKHZhbCwgdW5pdCkge1xuICByZXR1cm4gdmFsID09PSAwID8gMCA6IHZhbCArIHVuaXQ7XG59O1xuXG4vLyBDb25zdHJ1Y3RzIHRoZSBjb21wdXRlZCBkaXNwbGF5IHN0YXRlIG9mIHRoZSBjdWUgKGEgZGl2KS4gUGxhY2VzIHRoZSBkaXZcbi8vIGludG8gdGhlIG92ZXJsYXkgd2hpY2ggc2hvdWxkIGJlIGEgYmxvY2sgbGV2ZWwgZWxlbWVudCAodXN1YWxseSBhIGRpdikuXG5mdW5jdGlvbiBDdWVTdHlsZUJveCh3aW5kb3csIGN1ZSwgc3R5bGVPcHRpb25zKSB7XG4gIFN0eWxlQm94LmNhbGwodGhpcyk7XG4gIHRoaXMuY3VlID0gY3VlO1xuXG4gIC8vIFBhcnNlIG91ciBjdWUncyB0ZXh0IGludG8gYSBET00gdHJlZSByb290ZWQgYXQgJ2N1ZURpdicuIFRoaXMgZGl2IHdpbGxcbiAgLy8gaGF2ZSBpbmxpbmUgcG9zaXRpb25pbmcgYW5kIHdpbGwgZnVuY3Rpb24gYXMgdGhlIGN1ZSBiYWNrZ3JvdW5kIGJveC5cbiAgdGhpcy5jdWVEaXYgPSBwYXJzZUNvbnRlbnQod2luZG93LCBjdWUudGV4dCk7XG4gIHZhciBzdHlsZXMgPSB7XG4gICAgY29sb3I6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAxKVwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogIFwicmdiYSgwLCAwLCAwLCAwLjgpXCIsXG4gICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDAsXG4gICAgZGlzcGxheTogXCJpbmxpbmVcIixcbiAgICB3cml0aW5nTW9kZTogY3VlLnZlcnRpY2FsID09PSBcIlwiID8gXCJob3Jpem9udGFsLXRiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1ZS52ZXJ0aWNhbCA9PT0gXCJsclwiID8gXCJ2ZXJ0aWNhbC1sclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcInZlcnRpY2FsLXJsXCIsXG4gICAgdW5pY29kZUJpZGk6IFwicGxhaW50ZXh0XCJcbiAgfTtcblxuICB0aGlzLmFwcGx5U3R5bGVzKHN0eWxlcywgdGhpcy5jdWVEaXYpO1xuXG4gIC8vIENyZWF0ZSBhbiBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZGl2IHRoYXQgd2lsbCBiZSB1c2VkIHRvIHBvc2l0aW9uIHRoZSBjdWVcbiAgLy8gZGl2LiBOb3RlLCBhbGwgV2ViVlRUIGN1ZS1zZXR0aW5nIGFsaWdubWVudHMgYXJlIGVxdWl2YWxlbnQgdG8gdGhlIENTU1xuICAvLyBtaXJyb3JzIG9mIHRoZW0gZXhjZXB0IFwibWlkZGxlXCIgd2hpY2ggaXMgXCJjZW50ZXJcIiBpbiBDU1MuXG4gIHRoaXMuZGl2ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHN0eWxlcyA9IHtcbiAgICBkaXJlY3Rpb246IGRldGVybWluZUJpZGkodGhpcy5jdWVEaXYpLFxuICAgIHdyaXRpbmdNb2RlOiBjdWUudmVydGljYWwgPT09IFwiXCIgPyBcImhvcml6b250YWwtdGJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VlLnZlcnRpY2FsID09PSBcImxyXCIgPyBcInZlcnRpY2FsLWxyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwidmVydGljYWwtcmxcIixcbiAgICB1bmljb2RlQmlkaTogXCJwbGFpbnRleHRcIixcbiAgICB0ZXh0QWxpZ246IGN1ZS5hbGlnbiA9PT0gXCJtaWRkbGVcIiA/IFwiY2VudGVyXCIgOiBjdWUuYWxpZ24sXG4gICAgZm9udDogc3R5bGVPcHRpb25zLmZvbnQsXG4gICAgd2hpdGVTcGFjZTogXCJwcmUtbGluZVwiLFxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgfTtcblxuICB0aGlzLmFwcGx5U3R5bGVzKHN0eWxlcyk7XG4gIHRoaXMuZGl2LmFwcGVuZENoaWxkKHRoaXMuY3VlRGl2KTtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHJlZmVyZW5jZSBlZGdlIG9mIHRoZSB2aWV3cG9ydCB0byB0aGUgdGV4dFxuICAvLyBwb3NpdGlvbiBvZiB0aGUgY3VlIGJveC4gVGhlIHJlZmVyZW5jZSBlZGdlIHdpbGwgYmUgcmVzb2x2ZWQgbGF0ZXIgd2hlblxuICAvLyB0aGUgYm94IG9yaWVudGF0aW9uIHN0eWxlcyBhcmUgYXBwbGllZC5cbiAgdmFyIHRleHRQb3MgPSAwO1xuICBzd2l0Y2ggKGN1ZS5wb3NpdGlvbkFsaWduKSB7XG4gIGNhc2UgXCJzdGFydFwiOlxuICAgIHRleHRQb3MgPSBjdWUucG9zaXRpb247XG4gICAgYnJlYWs7XG4gIGNhc2UgXCJtaWRkbGVcIjpcbiAgICB0ZXh0UG9zID0gY3VlLnBvc2l0aW9uIC0gKGN1ZS5zaXplIC8gMik7XG4gICAgYnJlYWs7XG4gIGNhc2UgXCJlbmRcIjpcbiAgICB0ZXh0UG9zID0gY3VlLnBvc2l0aW9uIC0gY3VlLnNpemU7XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBIb3Jpem9udGFsIGJveCBvcmllbnRhdGlvbjsgdGV4dFBvcyBpcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZVxuICAvLyBhcmVhIHRvIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGJveCBhbmQgY3VlLnNpemUgaXMgdGhlIGRpc3RhbmNlIGV4dGVuZGluZyB0b1xuICAvLyB0aGUgcmlnaHQgZnJvbSB0aGVyZS5cbiAgaWYgKGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIikge1xuICAgIHRoaXMuYXBwbHlTdHlsZXMoe1xuICAgICAgbGVmdDogIHRoaXMuZm9ybWF0U3R5bGUodGV4dFBvcywgXCIlXCIpLFxuICAgICAgd2lkdGg6IHRoaXMuZm9ybWF0U3R5bGUoY3VlLnNpemUsIFwiJVwiKVxuICAgIH0pO1xuICAvLyBWZXJ0aWNhbCBib3ggb3JpZW50YXRpb247IHRleHRQb3MgaXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHRvcCBlZGdlIG9mIHRoZVxuICAvLyBhcmVhIHRvIHRoZSB0b3AgZWRnZSBvZiB0aGUgYm94IGFuZCBjdWUuc2l6ZSBpcyB0aGUgaGVpZ2h0IGV4dGVuZGluZ1xuICAvLyBkb3dud2FyZHMgZnJvbSB0aGVyZS5cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFwcGx5U3R5bGVzKHtcbiAgICAgIHRvcDogdGhpcy5mb3JtYXRTdHlsZSh0ZXh0UG9zLCBcIiVcIiksXG4gICAgICBoZWlnaHQ6IHRoaXMuZm9ybWF0U3R5bGUoY3VlLnNpemUsIFwiJVwiKVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5tb3ZlID0gZnVuY3Rpb24oYm94KSB7XG4gICAgdGhpcy5hcHBseVN0eWxlcyh7XG4gICAgICB0b3A6IHRoaXMuZm9ybWF0U3R5bGUoYm94LnRvcCwgXCJweFwiKSxcbiAgICAgIGJvdHRvbTogdGhpcy5mb3JtYXRTdHlsZShib3guYm90dG9tLCBcInB4XCIpLFxuICAgICAgbGVmdDogdGhpcy5mb3JtYXRTdHlsZShib3gubGVmdCwgXCJweFwiKSxcbiAgICAgIHJpZ2h0OiB0aGlzLmZvcm1hdFN0eWxlKGJveC5yaWdodCwgXCJweFwiKSxcbiAgICAgIGhlaWdodDogdGhpcy5mb3JtYXRTdHlsZShib3guaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgd2lkdGg6IHRoaXMuZm9ybWF0U3R5bGUoYm94LndpZHRoLCBcInB4XCIpXG4gICAgfSk7XG4gIH07XG59XG5DdWVTdHlsZUJveC5wcm90b3R5cGUgPSBfb2JqQ3JlYXRlKFN0eWxlQm94LnByb3RvdHlwZSk7XG5DdWVTdHlsZUJveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWVTdHlsZUJveDtcblxuLy8gUmVwcmVzZW50cyB0aGUgY28tb3JkaW5hdGVzIG9mIGFuIEVsZW1lbnQgaW4gYSB3YXkgdGhhdCB3ZSBjYW4gZWFzaWx5XG4vLyBjb21wdXRlIHRoaW5ncyB3aXRoIHN1Y2ggYXMgaWYgaXQgb3ZlcmxhcHMgb3IgaW50ZXJzZWN0cyB3aXRoIGFub3RoZXIgRWxlbWVudC5cbi8vIENhbiBpbml0aWFsaXplIGl0IHdpdGggZWl0aGVyIGEgU3R5bGVCb3ggb3IgYW5vdGhlciBCb3hQb3NpdGlvbi5cbmZ1bmN0aW9uIEJveFBvc2l0aW9uKG9iaikge1xuICAvLyBFaXRoZXIgYSBCb3hQb3NpdGlvbiB3YXMgcGFzc2VkIGluIGFuZCB3ZSBuZWVkIHRvIGNvcHkgaXQsIG9yIGEgU3R5bGVCb3hcbiAgLy8gd2FzIHBhc3NlZCBpbiBhbmQgd2UgbmVlZCB0byBjb3B5IHRoZSByZXN1bHRzIG9mICdnZXRCb3VuZGluZ0NsaWVudFJlY3QnXG4gIC8vIGFzIHRoZSBvYmplY3QgcmV0dXJuZWQgaXMgcmVhZG9ubHkuIEFsbCBjby1vcmRpbmF0ZSB2YWx1ZXMgYXJlIGluIHJlZmVyZW5jZVxuICAvLyB0byB0aGUgdmlld3BvcnQgb3JpZ2luICh0b3AgbGVmdCkuXG4gIHZhciBsaCwgaGVpZ2h0LCB3aWR0aCwgdG9wO1xuICBpZiAob2JqLmRpdikge1xuICAgIGhlaWdodCA9IG9iai5kaXYub2Zmc2V0SGVpZ2h0O1xuICAgIHdpZHRoID0gb2JqLmRpdi5vZmZzZXRXaWR0aDtcbiAgICB0b3AgPSBvYmouZGl2Lm9mZnNldFRvcDtcblxuICAgIHZhciByZWN0cyA9IChyZWN0cyA9IG9iai5kaXYuY2hpbGROb2RlcykgJiYgKHJlY3RzID0gcmVjdHNbMF0pICYmXG4gICAgICAgICAgICAgICAgcmVjdHMuZ2V0Q2xpZW50UmVjdHMgJiYgcmVjdHMuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBvYmogPSBvYmouZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIEluIGNlcnRhaW4gY2FzZXMgdGhlIG91dHRlciBkaXYgd2lsbCBiZSBzbGlnaHRseSBsYXJnZXIgdGhlbiB0aGUgc3VtIG9mXG4gICAgLy8gdGhlIGlubmVyIGRpdidzIGxpbmVzLiBUaGlzIGNvdWxkIGJlIGR1ZSB0byBib2xkIHRleHQsIGV0Yywgb24gc29tZSBwbGF0Zm9ybXMuXG4gICAgLy8gSW4gdGhpcyBjYXNlIHdlIHNob3VsZCBnZXQgdGhlIGF2ZXJhZ2UgbGluZSBoZWlnaHQgYW5kIHVzZSB0aGF0LiBUaGlzIHdpbGxcbiAgICAvLyByZXN1bHQgaW4gdGhlIGRlc2lyZWQgYmVoYXZpb3VyLlxuICAgIGxoID0gcmVjdHMgPyBNYXRoLm1heCgocmVjdHNbMF0gJiYgcmVjdHNbMF0uaGVpZ2h0KSB8fCAwLCBvYmouaGVpZ2h0IC8gcmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgOiAwO1xuXG4gIH1cbiAgdGhpcy5sZWZ0ID0gb2JqLmxlZnQ7XG4gIHRoaXMucmlnaHQgPSBvYmoucmlnaHQ7XG4gIHRoaXMudG9wID0gb2JqLnRvcCB8fCB0b3A7XG4gIHRoaXMuaGVpZ2h0ID0gb2JqLmhlaWdodCB8fCBoZWlnaHQ7XG4gIHRoaXMuYm90dG9tID0gb2JqLmJvdHRvbSB8fCAodG9wICsgKG9iai5oZWlnaHQgfHwgaGVpZ2h0KSk7XG4gIHRoaXMud2lkdGggPSBvYmoud2lkdGggfHwgd2lkdGg7XG4gIHRoaXMubGluZUhlaWdodCA9IGxoICE9PSB1bmRlZmluZWQgPyBsaCA6IG9iai5saW5lSGVpZ2h0O1xufVxuXG4vLyBNb3ZlIHRoZSBib3ggYWxvbmcgYSBwYXJ0aWN1bGFyIGF4aXMuIE9wdGlvbmFsbHkgcGFzcyBpbiBhbiBhbW91bnQgdG8gbW92ZVxuLy8gdGhlIGJveC4gSWYgbm8gYW1vdW50IGlzIHBhc3NlZCB0aGVuIHRoZSBkZWZhdWx0IGlzIHRoZSBsaW5lIGhlaWdodCBvZiB0aGVcbi8vIGJveC5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oYXhpcywgdG9Nb3ZlKSB7XG4gIHRvTW92ZSA9IHRvTW92ZSAhPT0gdW5kZWZpbmVkID8gdG9Nb3ZlIDogdGhpcy5saW5lSGVpZ2h0O1xuICBzd2l0Y2ggKGF4aXMpIHtcbiAgY2FzZSBcIit4XCI6XG4gICAgdGhpcy5sZWZ0ICs9IHRvTW92ZTtcbiAgICB0aGlzLnJpZ2h0ICs9IHRvTW92ZTtcbiAgICBicmVhaztcbiAgY2FzZSBcIi14XCI6XG4gICAgdGhpcy5sZWZ0IC09IHRvTW92ZTtcbiAgICB0aGlzLnJpZ2h0IC09IHRvTW92ZTtcbiAgICBicmVhaztcbiAgY2FzZSBcIit5XCI6XG4gICAgdGhpcy50b3AgKz0gdG9Nb3ZlO1xuICAgIHRoaXMuYm90dG9tICs9IHRvTW92ZTtcbiAgICBicmVhaztcbiAgY2FzZSBcIi15XCI6XG4gICAgdGhpcy50b3AgLT0gdG9Nb3ZlO1xuICAgIHRoaXMuYm90dG9tIC09IHRvTW92ZTtcbiAgICBicmVhaztcbiAgfVxufTtcblxuLy8gQ2hlY2sgaWYgdGhpcyBib3ggb3ZlcmxhcHMgYW5vdGhlciBib3gsIGIyLlxuQm94UG9zaXRpb24ucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24oYjIpIHtcbiAgcmV0dXJuIHRoaXMubGVmdCA8IGIyLnJpZ2h0ICYmXG4gICAgICAgICB0aGlzLnJpZ2h0ID4gYjIubGVmdCAmJlxuICAgICAgICAgdGhpcy50b3AgPCBiMi5ib3R0b20gJiZcbiAgICAgICAgIHRoaXMuYm90dG9tID4gYjIudG9wO1xufTtcblxuLy8gQ2hlY2sgaWYgdGhpcyBib3ggb3ZlcmxhcHMgYW55IG90aGVyIGJveGVzIGluIGJveGVzLlxuQm94UG9zaXRpb24ucHJvdG90eXBlLm92ZXJsYXBzQW55ID0gZnVuY3Rpb24oYm94ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLm92ZXJsYXBzKGJveGVzW2ldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIENoZWNrIGlmIHRoaXMgYm94IGlzIHdpdGhpbiBhbm90aGVyIGJveC5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS53aXRoaW4gPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgcmV0dXJuIHRoaXMudG9wID49IGNvbnRhaW5lci50b3AgJiZcbiAgICAgICAgIHRoaXMuYm90dG9tIDw9IGNvbnRhaW5lci5ib3R0b20gJiZcbiAgICAgICAgIHRoaXMubGVmdCA+PSBjb250YWluZXIubGVmdCAmJlxuICAgICAgICAgdGhpcy5yaWdodCA8PSBjb250YWluZXIucmlnaHQ7XG59O1xuXG4vLyBDaGVjayBpZiB0aGlzIGJveCBpcyBlbnRpcmVseSB3aXRoaW4gdGhlIGNvbnRhaW5lciBvciBpdCBpcyBvdmVybGFwcGluZ1xuLy8gb24gdGhlIGVkZ2Ugb3Bwb3NpdGUgb2YgdGhlIGF4aXMgZGlyZWN0aW9uIHBhc3NlZC4gRm9yIGV4YW1wbGUsIGlmIFwiK3hcIiBpc1xuLy8gcGFzc2VkIGFuZCB0aGUgYm94IGlzIG92ZXJsYXBwaW5nIG9uIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGNvbnRhaW5lciwgdGhlblxuLy8gcmV0dXJuIHRydWUuXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUub3ZlcmxhcHNPcHBvc2l0ZUF4aXMgPSBmdW5jdGlvbihjb250YWluZXIsIGF4aXMpIHtcbiAgc3dpdGNoIChheGlzKSB7XG4gIGNhc2UgXCIreFwiOlxuICAgIHJldHVybiB0aGlzLmxlZnQgPCBjb250YWluZXIubGVmdDtcbiAgY2FzZSBcIi14XCI6XG4gICAgcmV0dXJuIHRoaXMucmlnaHQgPiBjb250YWluZXIucmlnaHQ7XG4gIGNhc2UgXCIreVwiOlxuICAgIHJldHVybiB0aGlzLnRvcCA8IGNvbnRhaW5lci50b3A7XG4gIGNhc2UgXCIteVwiOlxuICAgIHJldHVybiB0aGlzLmJvdHRvbSA+IGNvbnRhaW5lci5ib3R0b207XG4gIH1cbn07XG5cbi8vIEZpbmQgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGFyZWEgdGhhdCB0aGlzIGJveCBpcyBvdmVybGFwcGluZyB3aXRoIGFub3RoZXJcbi8vIGJveC5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS5pbnRlcnNlY3RQZXJjZW50YWdlID0gZnVuY3Rpb24oYjIpIHtcbiAgdmFyIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLnJpZ2h0LCBiMi5yaWdodCkgLSBNYXRoLm1heCh0aGlzLmxlZnQsIGIyLmxlZnQpKSxcbiAgICAgIHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLmJvdHRvbSwgYjIuYm90dG9tKSAtIE1hdGgubWF4KHRoaXMudG9wLCBiMi50b3ApKSxcbiAgICAgIGludGVyc2VjdEFyZWEgPSB4ICogeTtcbiAgcmV0dXJuIGludGVyc2VjdEFyZWEgLyAodGhpcy5oZWlnaHQgKiB0aGlzLndpZHRoKTtcbn07XG5cbi8vIENvbnZlcnQgdGhlIHBvc2l0aW9ucyBmcm9tIHRoaXMgYm94IHRvIENTUyBjb21wYXRpYmxlIHBvc2l0aW9ucyB1c2luZ1xuLy8gdGhlIHJlZmVyZW5jZSBjb250YWluZXIncyBwb3NpdGlvbnMuIFRoaXMgaGFzIHRvIGJlIGRvbmUgYmVjYXVzZSB0aGlzXG4vLyBib3gncyBwb3NpdGlvbnMgYXJlIGluIHJlZmVyZW5jZSB0byB0aGUgdmlld3BvcnQgb3JpZ2luLCB3aGVyZWFzLCBDU1Ncbi8vIHZhbHVlcyBhcmUgaW4gcmVmZXJlY25lIHRvIHRoZWlyIHJlc3BlY3RpdmUgZWRnZXMuXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUudG9DU1NDb21wYXRWYWx1ZXMgPSBmdW5jdGlvbihyZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHRoaXMudG9wIC0gcmVmZXJlbmNlLnRvcCxcbiAgICBib3R0b206IHJlZmVyZW5jZS5ib3R0b20gLSB0aGlzLmJvdHRvbSxcbiAgICBsZWZ0OiB0aGlzLmxlZnQgLSByZWZlcmVuY2UubGVmdCxcbiAgICByaWdodDogcmVmZXJlbmNlLnJpZ2h0IC0gdGhpcy5yaWdodCxcbiAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgIHdpZHRoOiB0aGlzLndpZHRoXG4gIH07XG59O1xuXG4vLyBHZXQgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgYm94J3MgcG9zaXRpb24gd2l0aG91dCBhbnl0aGluZyBleHRyYS5cbi8vIENhbiBwYXNzIGEgU3R5bGVCb3gsIEhUTUxFbGVtZW50LCBvciBhbm90aGVyIEJveFBvc2l0b24uXG5Cb3hQb3NpdGlvbi5nZXRTaW1wbGVCb3hQb3NpdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgaGVpZ2h0ID0gb2JqLmRpdiA/IG9iai5kaXYub2Zmc2V0SGVpZ2h0IDogb2JqLnRhZ05hbWUgPyBvYmoub2Zmc2V0SGVpZ2h0IDogMDtcbiAgdmFyIHdpZHRoID0gb2JqLmRpdiA/IG9iai5kaXYub2Zmc2V0V2lkdGggOiBvYmoudGFnTmFtZSA/IG9iai5vZmZzZXRXaWR0aCA6IDA7XG4gIHZhciB0b3AgPSBvYmouZGl2ID8gb2JqLmRpdi5vZmZzZXRUb3AgOiBvYmoudGFnTmFtZSA/IG9iai5vZmZzZXRUb3AgOiAwO1xuXG4gIG9iaiA9IG9iai5kaXYgPyBvYmouZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDpcbiAgICAgICAgICAgICAgICBvYmoudGFnTmFtZSA/IG9iai5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IG9iajtcbiAgdmFyIHJldCA9IHtcbiAgICBsZWZ0OiBvYmoubGVmdCxcbiAgICByaWdodDogb2JqLnJpZ2h0LFxuICAgIHRvcDogb2JqLnRvcCB8fCB0b3AsXG4gICAgaGVpZ2h0OiBvYmouaGVpZ2h0IHx8IGhlaWdodCxcbiAgICBib3R0b206IG9iai5ib3R0b20gfHwgKHRvcCArIChvYmouaGVpZ2h0IHx8IGhlaWdodCkpLFxuICAgIHdpZHRoOiBvYmoud2lkdGggfHwgd2lkdGhcbiAgfTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8vIE1vdmUgYSBTdHlsZUJveCB0byBpdHMgc3BlY2lmaWVkLCBvciBuZXh0IGJlc3QsIHBvc2l0aW9uLiBUaGUgY29udGFpbmVyQm94XG4vLyBpcyB0aGUgYm94IHRoYXQgY29udGFpbnMgdGhlIFN0eWxlQm94LCBzdWNoIGFzIGEgZGl2LiBib3hQb3NpdGlvbnMgYXJlXG4vLyBhIGxpc3Qgb2Ygb3RoZXIgYm94ZXMgdGhhdCB0aGUgc3R5bGVCb3ggY2FuJ3Qgb3ZlcmxhcCB3aXRoLlxuZnVuY3Rpb24gbW92ZUJveFRvTGluZVBvc2l0aW9uKHdpbmRvdywgc3R5bGVCb3gsIGNvbnRhaW5lckJveCwgYm94UG9zaXRpb25zKSB7XG5cbiAgLy8gRmluZCB0aGUgYmVzdCBwb3NpdGlvbiBmb3IgYSBjdWUgYm94LCBiLCBvbiB0aGUgdmlkZW8uIFRoZSBheGlzIHBhcmFtZXRlclxuICAvLyBpcyBhIGxpc3Qgb2YgYXhpcywgdGhlIG9yZGVyIG9mIHdoaWNoLCBpdCB3aWxsIG1vdmUgdGhlIGJveCBhbG9uZy4gRm9yIGV4YW1wbGU6XG4gIC8vIFBhc3NpbmcgW1wiK3hcIiwgXCIteFwiXSB3aWxsIG1vdmUgdGhlIGJveCBmaXJzdCBhbG9uZyB0aGUgeCBheGlzIGluIHRoZSBwb3NpdGl2ZVxuICAvLyBkaXJlY3Rpb24uIElmIGl0IGRvZXNuJ3QgZmluZCBhIGdvb2QgcG9zaXRpb24gZm9yIGl0IHRoZXJlIGl0IHdpbGwgdGhlbiBtb3ZlXG4gIC8vIGl0IGFsb25nIHRoZSB4IGF4aXMgaW4gdGhlIG5lZ2F0aXZlIGRpcmVjdGlvbi5cbiAgZnVuY3Rpb24gZmluZEJlc3RQb3NpdGlvbihiLCBheGlzKSB7XG4gICAgdmFyIGJlc3RQb3NpdGlvbixcbiAgICAgICAgc3BlY2lmaWVkUG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oYiksXG4gICAgICAgIHBlcmNlbnRhZ2UgPSAxOyAvLyBIaWdoZXN0IHBvc3NpYmxlIHNvIHRoZSBmaXJzdCB0aGluZyB3ZSBnZXQgaXMgYmV0dGVyLlxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3aGlsZSAoYi5vdmVybGFwc09wcG9zaXRlQXhpcyhjb250YWluZXJCb3gsIGF4aXNbaV0pIHx8XG4gICAgICAgICAgICAgKGIud2l0aGluKGNvbnRhaW5lckJveCkgJiYgYi5vdmVybGFwc0FueShib3hQb3NpdGlvbnMpKSkge1xuICAgICAgICBiLm1vdmUoYXhpc1tpXSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBmb3VuZCBhIHNwb3Qgd2hlcmUgd2UgYXJlbid0IG92ZXJsYXBwaW5nIGFueXRoaW5nLiBUaGlzIGlzIG91clxuICAgICAgLy8gYmVzdCBwb3NpdGlvbi5cbiAgICAgIGlmIChiLndpdGhpbihjb250YWluZXJCb3gpKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuICAgICAgdmFyIHAgPSBiLmludGVyc2VjdFBlcmNlbnRhZ2UoY29udGFpbmVyQm94KTtcbiAgICAgIC8vIElmIHdlJ3JlIG91dHNpZGUgdGhlIGNvbnRhaW5lciBib3ggbGVzcyB0aGVuIHdlIHdlcmUgb24gb3VyIGxhc3QgdHJ5XG4gICAgICAvLyB0aGVuIHJlbWVtYmVyIHRoaXMgcG9zaXRpb24gYXMgdGhlIGJlc3QgcG9zaXRpb24uXG4gICAgICBpZiAocGVyY2VudGFnZSA+IHApIHtcbiAgICAgICAgYmVzdFBvc2l0aW9uID0gbmV3IEJveFBvc2l0aW9uKGIpO1xuICAgICAgICBwZXJjZW50YWdlID0gcDtcbiAgICAgIH1cbiAgICAgIC8vIFJlc2V0IHRoZSBib3ggcG9zaXRpb24gdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICAgIGIgPSBuZXcgQm94UG9zaXRpb24oc3BlY2lmaWVkUG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdFBvc2l0aW9uIHx8IHNwZWNpZmllZFBvc2l0aW9uO1xuICB9XG5cbiAgdmFyIGJveFBvc2l0aW9uID0gbmV3IEJveFBvc2l0aW9uKHN0eWxlQm94KSxcbiAgICAgIGN1ZSA9IHN0eWxlQm94LmN1ZSxcbiAgICAgIGxpbmVQb3MgPSBjb21wdXRlTGluZVBvcyhjdWUpLFxuICAgICAgYXhpcyA9IFtdO1xuXG4gIC8vIElmIHdlIGhhdmUgYSBsaW5lIG51bWJlciB0byBhbGlnbiB0aGUgY3VlIHRvLlxuICBpZiAoY3VlLnNuYXBUb0xpbmVzKSB7XG4gICAgdmFyIHNpemU7XG4gICAgc3dpdGNoIChjdWUudmVydGljYWwpIHtcbiAgICBjYXNlIFwiXCI6XG4gICAgICBheGlzID0gWyBcIit5XCIsIFwiLXlcIiBdO1xuICAgICAgc2l6ZSA9IFwiaGVpZ2h0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmxcIjpcbiAgICAgIGF4aXMgPSBbIFwiK3hcIiwgXCIteFwiIF07XG4gICAgICBzaXplID0gXCJ3aWR0aFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImxyXCI6XG4gICAgICBheGlzID0gWyBcIi14XCIsIFwiK3hcIiBdO1xuICAgICAgc2l6ZSA9IFwid2lkdGhcIjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBzdGVwID0gYm94UG9zaXRpb24ubGluZUhlaWdodCxcbiAgICAgICAgcG9zaXRpb24gPSBzdGVwICogTWF0aC5yb3VuZChsaW5lUG9zKSxcbiAgICAgICAgbWF4UG9zaXRpb24gPSBjb250YWluZXJCb3hbc2l6ZV0gKyBzdGVwLFxuICAgICAgICBpbml0aWFsQXhpcyA9IGF4aXNbMF07XG5cbiAgICAvLyBJZiB0aGUgc3BlY2lmaWVkIGludGlhbCBwb3NpdGlvbiBpcyBncmVhdGVyIHRoZW4gdGhlIG1heCBwb3NpdGlvbiB0aGVuXG4gICAgLy8gY2xhbXAgdGhlIGJveCB0byB0aGUgYW1vdW50IG9mIHN0ZXBzIGl0IHdvdWxkIHRha2UgZm9yIHRoZSBib3ggdG9cbiAgICAvLyByZWFjaCB0aGUgbWF4IHBvc2l0aW9uLlxuICAgIGlmIChNYXRoLmFicyhwb3NpdGlvbikgPiBtYXhQb3NpdGlvbikge1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA8IDAgPyAtMSA6IDE7XG4gICAgICBwb3NpdGlvbiAqPSBNYXRoLmNlaWwobWF4UG9zaXRpb24gLyBzdGVwKSAqIHN0ZXA7XG4gICAgfVxuXG4gICAgLy8gSWYgY29tcHV0ZWQgbGluZSBwb3NpdGlvbiByZXR1cm5zIG5lZ2F0aXZlIHRoZW4gbGluZSBudW1iZXJzIGFyZVxuICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHZpZGVvIGluc3RlYWQgb2YgdGhlIHRvcC4gVGhlcmVmb3JlLCB3ZVxuICAgIC8vIG5lZWQgdG8gaW5jcmVhc2Ugb3VyIGluaXRpYWwgcG9zaXRpb24gYnkgdGhlIGxlbmd0aCBvciB3aWR0aCBvZiB0aGVcbiAgICAvLyB2aWRlbywgZGVwZW5kaW5nIG9uIHRoZSB3cml0aW5nIGRpcmVjdGlvbiwgYW5kIHJldmVyc2Ugb3VyIGF4aXMgZGlyZWN0aW9ucy5cbiAgICBpZiAobGluZVBvcyA8IDApIHtcbiAgICAgIHBvc2l0aW9uICs9IGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIiA/IGNvbnRhaW5lckJveC5oZWlnaHQgOiBjb250YWluZXJCb3gud2lkdGg7XG4gICAgICBheGlzID0gYXhpcy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgLy8gTW92ZSB0aGUgYm94IHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uIFRoaXMgbWF5IG5vdCBiZSBpdHMgYmVzdFxuICAgIC8vIHBvc2l0aW9uLlxuICAgIGJveFBvc2l0aW9uLm1vdmUoaW5pdGlhbEF4aXMsIHBvc2l0aW9uKTtcblxuICB9IGVsc2Uge1xuICAgIC8vIElmIHdlIGhhdmUgYSBwZXJjZW50YWdlIGxpbmUgdmFsdWUgZm9yIHRoZSBjdWUuXG4gICAgdmFyIGNhbGN1bGF0ZWRQZXJjZW50YWdlID0gKGJveFBvc2l0aW9uLmxpbmVIZWlnaHQgLyBjb250YWluZXJCb3guaGVpZ2h0KSAqIDEwMDtcblxuICAgIHN3aXRjaCAoY3VlLmxpbmVBbGlnbikge1xuICAgIGNhc2UgXCJtaWRkbGVcIjpcbiAgICAgIGxpbmVQb3MgLT0gKGNhbGN1bGF0ZWRQZXJjZW50YWdlIC8gMik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZW5kXCI6XG4gICAgICBsaW5lUG9zIC09IGNhbGN1bGF0ZWRQZXJjZW50YWdlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgaW5pdGlhbCBsaW5lIHBvc2l0aW9uIHRvIHRoZSBjdWUgYm94LlxuICAgIHN3aXRjaCAoY3VlLnZlcnRpY2FsKSB7XG4gICAgY2FzZSBcIlwiOlxuICAgICAgc3R5bGVCb3guYXBwbHlTdHlsZXMoe1xuICAgICAgICB0b3A6IHN0eWxlQm94LmZvcm1hdFN0eWxlKGxpbmVQb3MsIFwiJVwiKVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmxcIjpcbiAgICAgIHN0eWxlQm94LmFwcGx5U3R5bGVzKHtcbiAgICAgICAgbGVmdDogc3R5bGVCb3guZm9ybWF0U3R5bGUobGluZVBvcywgXCIlXCIpXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJsclwiOlxuICAgICAgc3R5bGVCb3guYXBwbHlTdHlsZXMoe1xuICAgICAgICByaWdodDogc3R5bGVCb3guZm9ybWF0U3R5bGUobGluZVBvcywgXCIlXCIpXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGF4aXMgPSBbIFwiK3lcIiwgXCIteFwiLCBcIit4XCIsIFwiLXlcIiBdO1xuXG4gICAgLy8gR2V0IHRoZSBib3ggcG9zaXRpb24gYWdhaW4gYWZ0ZXIgd2UndmUgYXBwbGllZCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uaW5nXG4gICAgLy8gdG8gaXQuXG4gICAgYm94UG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oc3R5bGVCb3gpO1xuICB9XG5cbiAgdmFyIGJlc3RQb3NpdGlvbiA9IGZpbmRCZXN0UG9zaXRpb24oYm94UG9zaXRpb24sIGF4aXMpO1xuICBzdHlsZUJveC5tb3ZlKGJlc3RQb3NpdGlvbi50b0NTU0NvbXBhdFZhbHVlcyhjb250YWluZXJCb3gpKTtcbn1cblxuZnVuY3Rpb24gV2ViVlRUKCkge1xuICAvLyBOb3RoaW5nXG59XG5cbi8vIEhlbHBlciB0byBhbGxvdyBzdHJpbmdzIHRvIGJlIGRlY29kZWQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBiaW5hcnkgdXRmOCBkYXRhLlxuV2ViVlRULlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBkZWNvZGU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcbiAgICB9XG4gIH07XG59O1xuXG5XZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSA9IGZ1bmN0aW9uKHdpbmRvdywgY3VldGV4dCkge1xuICBpZiAoIXdpbmRvdyB8fCAhY3VldGV4dCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwYXJzZUNvbnRlbnQod2luZG93LCBjdWV0ZXh0KTtcbn07XG5cbnZhciBGT05UX1NJWkVfUEVSQ0VOVCA9IDAuMDU7XG52YXIgRk9OVF9TVFlMRSA9IFwic2Fucy1zZXJpZlwiO1xudmFyIENVRV9CQUNLR1JPVU5EX1BBRERJTkcgPSBcIjEuNSVcIjtcblxuLy8gUnVucyB0aGUgcHJvY2Vzc2luZyBtb2RlbCBvdmVyIHRoZSBjdWVzIGFuZCByZWdpb25zIHBhc3NlZCB0byBpdC5cbi8vIEBwYXJhbSBvdmVybGF5IEEgYmxvY2sgbGV2ZWwgZWxlbWVudCAodXN1YWxseSBhIGRpdikgdGhhdCB0aGUgY29tcHV0ZWQgY3Vlc1xuLy8gICAgICAgICAgICAgICAgYW5kIHJlZ2lvbnMgd2lsbCBiZSBwbGFjZWQgaW50by5cbldlYlZUVC5wcm9jZXNzQ3VlcyA9IGZ1bmN0aW9uKHdpbmRvdywgY3Vlcywgb3ZlcmxheSkge1xuICBpZiAoIXdpbmRvdyB8fCAhY3VlcyB8fCAhb3ZlcmxheSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCBwcmV2aW91cyBjaGlsZHJlbi5cbiAgd2hpbGUgKG92ZXJsYXkuZmlyc3RDaGlsZCkge1xuICAgIG92ZXJsYXkucmVtb3ZlQ2hpbGQob3ZlcmxheS5maXJzdENoaWxkKTtcbiAgfVxuXG4gIHZhciBwYWRkZWRPdmVybGF5ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUubGVmdCA9IFwiMFwiO1xuICBwYWRkZWRPdmVybGF5LnN0eWxlLnJpZ2h0ID0gXCIwXCI7XG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUudG9wID0gXCIwXCI7XG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUuYm90dG9tID0gXCIwXCI7XG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUubWFyZ2luID0gQ1VFX0JBQ0tHUk9VTkRfUEFERElORztcbiAgb3ZlcmxheS5hcHBlbmRDaGlsZChwYWRkZWRPdmVybGF5KTtcblxuICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBjb21wdXRlIHRoZSBkaXNwbGF5IHN0YXRlcyBvZiB0aGUgY3Vlcy4gVGhpcyBjb3VsZFxuICAvLyBiZSB0aGUgY2FzZSBpZiBhIGN1ZSdzIHN0YXRlIGhhcyBiZWVuIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgY29tcHV0YXRpb24gb3JcbiAgLy8gaWYgaXQgaGFzIG5vdCBiZWVuIGNvbXB1dGVkIHlldC5cbiAgZnVuY3Rpb24gc2hvdWxkQ29tcHV0ZShjdWVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY3Vlc1tpXS5oYXNCZWVuUmVzZXQgfHwgIWN1ZXNbaV0uZGlzcGxheVN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlY29tcHV0ZSB0aGUgY3VlcycgZGlzcGxheSBzdGF0ZXMuIEp1c3QgcmV1c2UgdGhlbS5cbiAgaWYgKCFzaG91bGRDb21wdXRlKGN1ZXMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWRkZWRPdmVybGF5LmFwcGVuZENoaWxkKGN1ZXNbaV0uZGlzcGxheVN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGJveFBvc2l0aW9ucyA9IFtdLFxuICAgICAgY29udGFpbmVyQm94ID0gQm94UG9zaXRpb24uZ2V0U2ltcGxlQm94UG9zaXRpb24ocGFkZGVkT3ZlcmxheSksXG4gICAgICBmb250U2l6ZSA9IE1hdGgucm91bmQoY29udGFpbmVyQm94LmhlaWdodCAqIEZPTlRfU0laRV9QRVJDRU5UICogMTAwKSAvIDEwMDtcbiAgdmFyIHN0eWxlT3B0aW9ucyA9IHtcbiAgICBmb250OiBmb250U2l6ZSArIFwicHggXCIgKyBGT05UX1NUWUxFXG4gIH07XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHlsZUJveCwgY3VlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdWUgPSBjdWVzW2ldO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBpbnRpYWwgcG9zaXRpb24gYW5kIHN0eWxlcyBvZiB0aGUgY3VlIGRpdi5cbiAgICAgIHN0eWxlQm94ID0gbmV3IEN1ZVN0eWxlQm94KHdpbmRvdywgY3VlLCBzdHlsZU9wdGlvbnMpO1xuICAgICAgcGFkZGVkT3ZlcmxheS5hcHBlbmRDaGlsZChzdHlsZUJveC5kaXYpO1xuXG4gICAgICAvLyBNb3ZlIHRoZSBjdWUgZGl2IHRvIGl0J3MgY29ycmVjdCBsaW5lIHBvc2l0aW9uLlxuICAgICAgbW92ZUJveFRvTGluZVBvc2l0aW9uKHdpbmRvdywgc3R5bGVCb3gsIGNvbnRhaW5lckJveCwgYm94UG9zaXRpb25zKTtcblxuICAgICAgLy8gUmVtZW1iZXIgdGhlIGNvbXB1dGVkIGRpdiBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gcmVjb21wdXRlIGl0IGxhdGVyXG4gICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIHRvby5cbiAgICAgIGN1ZS5kaXNwbGF5U3RhdGUgPSBzdHlsZUJveC5kaXY7XG5cbiAgICAgIGJveFBvc2l0aW9ucy5wdXNoKEJveFBvc2l0aW9uLmdldFNpbXBsZUJveFBvc2l0aW9uKHN0eWxlQm94KSk7XG4gICAgfVxuICB9KSgpO1xufTtcblxuV2ViVlRULlBhcnNlciA9IGZ1bmN0aW9uKHdpbmRvdywgdnR0anMsIGRlY29kZXIpIHtcbiAgaWYgKCFkZWNvZGVyKSB7XG4gICAgZGVjb2RlciA9IHZ0dGpzO1xuICAgIHZ0dGpzID0ge307XG4gIH1cbiAgaWYgKCF2dHRqcykge1xuICAgIHZ0dGpzID0ge307XG4gIH1cblxuICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgdGhpcy52dHRqcyA9IHZ0dGpzO1xuICB0aGlzLnN0YXRlID0gXCJJTklUSUFMXCI7XG4gIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgdGhpcy5kZWNvZGVyID0gZGVjb2RlciB8fCBuZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpO1xuICB0aGlzLnJlZ2lvbkxpc3QgPSBbXTtcbn07XG5cbldlYlZUVC5QYXJzZXIucHJvdG90eXBlID0ge1xuICAvLyBJZiB0aGUgZXJyb3IgaXMgYSBQYXJzaW5nRXJyb3IgdGhlbiByZXBvcnQgaXQgdG8gdGhlIGNvbnN1bWVyIGlmXG4gIC8vIHBvc3NpYmxlLiBJZiBpdCdzIG5vdCBhIFBhcnNpbmdFcnJvciB0aGVuIHRocm93IGl0IGxpa2Ugbm9ybWFsLlxuICByZXBvcnRPclRocm93RXJyb3I6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFBhcnNpbmdFcnJvcikge1xuICAgICAgdGhpcy5vbnBhcnNpbmdlcnJvciAmJiB0aGlzLm9ucGFyc2luZ2Vycm9yKGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfSxcbiAgcGFyc2U6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gZGF0YSB0aGVuIHdlIHdvbid0IGRlY29kZSBpdCwgYnV0IHdpbGwganVzdCB0cnkgdG8gcGFyc2VcbiAgICAvLyB3aGF0ZXZlciBpcyBpbiBidWZmZXIgYWxyZWFkeS4gVGhpcyBtYXkgb2NjdXIgaW4gY2lyY3Vtc3RhbmNlcywgZm9yXG4gICAgLy8gZXhhbXBsZSB3aGVuIGZsdXNoKCkgaXMgY2FsbGVkLlxuICAgIGlmIChkYXRhKSB7XG4gICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBkYXRhIHRoYXQgd2UgcmVjZWl2ZWQuXG4gICAgICBzZWxmLmJ1ZmZlciArPSBzZWxmLmRlY29kZXIuZGVjb2RlKGRhdGEsIHtzdHJlYW06IHRydWV9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0TmV4dExpbmUoKSB7XG4gICAgICB2YXIgYnVmZmVyID0gc2VsZi5idWZmZXI7XG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHdoaWxlIChwb3MgPCBidWZmZXIubGVuZ3RoICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxyJyAmJiBidWZmZXJbcG9zXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICB2YXIgbGluZSA9IGJ1ZmZlci5zdWJzdHIoMCwgcG9zKTtcbiAgICAgIC8vIEFkdmFuY2UgdGhlIGJ1ZmZlciBlYXJseSBpbiBjYXNlIHdlIGZhaWwgYmVsb3cuXG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXHInKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIHNlbGYuYnVmZmVyID0gYnVmZmVyLnN1YnN0cihwb3MpO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG4gICAgLy8gMy40IFdlYlZUVCByZWdpb24gYW5kIFdlYlZUVCByZWdpb24gc2V0dGluZ3Mgc3ludGF4XG4gICAgZnVuY3Rpb24gcGFyc2VSZWdpb24oaW5wdXQpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuXG4gICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICBzZXR0aW5ncy5zZXQoaywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsaW5lc1wiOlxuICAgICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWdpb25hbmNob3JcIjpcbiAgICAgICAgY2FzZSBcInZpZXdwb3J0YW5jaG9yXCI6XG4gICAgICAgICAgdmFyIHh5ID0gdi5zcGxpdCgnLCcpO1xuICAgICAgICAgIGlmICh4eS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBXZSBoYXZlIHRvIG1ha2Ugc3VyZSBib3RoIHggYW5kIHkgcGFyc2UsIHNvIHVzZSBhIHRlbXBvcmFyeVxuICAgICAgICAgIC8vIHNldHRpbmdzIG9iamVjdCBoZXJlLlxuICAgICAgICAgIHZhciBhbmNob3IgPSBuZXcgU2V0dGluZ3MoKTtcbiAgICAgICAgICBhbmNob3IucGVyY2VudChcInhcIiwgeHlbMF0pO1xuICAgICAgICAgIGFuY2hvci5wZXJjZW50KFwieVwiLCB4eVsxXSk7XG4gICAgICAgICAgaWYgKCFhbmNob3IuaGFzKFwieFwiKSB8fCAhYW5jaG9yLmhhcyhcInlcIikpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXR0aW5ncy5zZXQoayArIFwiWFwiLCBhbmNob3IuZ2V0KFwieFwiKSk7XG4gICAgICAgICAgc2V0dGluZ3Muc2V0KGsgKyBcIllcIiwgYW5jaG9yLmdldChcInlcIikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2Nyb2xsXCI6XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFtcInVwXCJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSwgLz0vLCAvXFxzLyk7XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgcmVnaW9uLCB1c2luZyBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IHZhbHVlcyB0aGF0IHdlcmUgbm90XG4gICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICBpZiAoc2V0dGluZ3MuaGFzKFwiaWRcIikpIHtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IG5ldyAoc2VsZi52dHRqcy5WVFRSZWdpb24gfHwgc2VsZi53aW5kb3cuVlRUUmVnaW9uKSgpO1xuICAgICAgICByZWdpb24ud2lkdGggPSBzZXR0aW5ncy5nZXQoXCJ3aWR0aFwiLCAxMDApO1xuICAgICAgICByZWdpb24ubGluZXMgPSBzZXR0aW5ncy5nZXQoXCJsaW5lc1wiLCAzKTtcbiAgICAgICAgcmVnaW9uLnJlZ2lvbkFuY2hvclggPSBzZXR0aW5ncy5nZXQoXCJyZWdpb25hbmNob3JYXCIsIDApO1xuICAgICAgICByZWdpb24ucmVnaW9uQW5jaG9yWSA9IHNldHRpbmdzLmdldChcInJlZ2lvbmFuY2hvcllcIiwgMTAwKTtcbiAgICAgICAgcmVnaW9uLnZpZXdwb3J0QW5jaG9yWCA9IHNldHRpbmdzLmdldChcInZpZXdwb3J0YW5jaG9yWFwiLCAwKTtcbiAgICAgICAgcmVnaW9uLnZpZXdwb3J0QW5jaG9yWSA9IHNldHRpbmdzLmdldChcInZpZXdwb3J0YW5jaG9yWVwiLCAxMDApO1xuICAgICAgICByZWdpb24uc2Nyb2xsID0gc2V0dGluZ3MuZ2V0KFwic2Nyb2xsXCIsIFwiXCIpO1xuICAgICAgICAvLyBSZWdpc3RlciB0aGUgcmVnaW9uLlxuICAgICAgICBzZWxmLm9ucmVnaW9uICYmIHNlbGYub25yZWdpb24ocmVnaW9uKTtcbiAgICAgICAgLy8gUmVtZW1iZXIgdGhlIFZUVFJlZ2lvbiBmb3IgbGF0ZXIgaW4gY2FzZSB3ZSBwYXJzZSBhbnkgVlRUQ3VlcyB0aGF0XG4gICAgICAgIC8vIHJlZmVyZW5jZSBpdC5cbiAgICAgICAgc2VsZi5yZWdpb25MaXN0LnB1c2goe1xuICAgICAgICAgIGlkOiBzZXR0aW5ncy5nZXQoXCJpZFwiKSxcbiAgICAgICAgICByZWdpb246IHJlZ2lvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkcmFmdC1wYW50b3MtaHR0cC1saXZlLXN0cmVhbWluZy0yMFxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1wYW50b3MtaHR0cC1saXZlLXN0cmVhbWluZy0yMCNzZWN0aW9uLTMuNVxuICAgIC8vIDMuNSBXZWJWVFRcbiAgICBmdW5jdGlvbiBwYXJzZVRpbWVzdGFtcE1hcChpbnB1dCkge1xuICAgICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG5cbiAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24oaywgdikge1xuICAgICAgICBzd2l0Y2goaykge1xuICAgICAgICBjYXNlIFwiTVBFR1RcIjpcbiAgICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGsgKyAnUycsIHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTE9DQVwiOlxuICAgICAgICAgIHNldHRpbmdzLnNldChrICsgJ0wnLCBwYXJzZVRpbWVTdGFtcCh2KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sIC9bXlxcZF06LywgLywvKTtcblxuICAgICAgc2VsZi5vbnRpbWVzdGFtcG1hcCAmJiBzZWxmLm9udGltZXN0YW1wbWFwKHtcbiAgICAgICAgXCJNUEVHVFNcIjogc2V0dGluZ3MuZ2V0KFwiTVBFR1RTXCIpLFxuICAgICAgICBcIkxPQ0FMXCI6IHNldHRpbmdzLmdldChcIkxPQ0FMXCIpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyAzLjIgV2ViVlRUIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcihpbnB1dCkge1xuICAgICAgaWYgKGlucHV0Lm1hdGNoKC9YLVRJTUVTVEFNUC1NQVAvKSkge1xuICAgICAgICAvLyBUaGlzIGxpbmUgY29udGFpbnMgSExTIFgtVElNRVNUQU1QLU1BUCBtZXRhZGF0YVxuICAgICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgICBzd2l0Y2goaykge1xuICAgICAgICAgIGNhc2UgXCJYLVRJTUVTVEFNUC1NQVBcIjpcbiAgICAgICAgICAgIHBhcnNlVGltZXN0YW1wTWFwKHYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAvPS8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICAgIGNhc2UgXCJSZWdpb25cIjpcbiAgICAgICAgICAgIC8vIDMuMyBXZWJWVFQgcmVnaW9uIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICAgICAgICAgIHBhcnNlUmVnaW9uKHYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAvOi8pO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBsaW5lO1xuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFwiSU5JVElBTFwiKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHN0YXJ0IHBhcnNpbmcgdW50aWwgd2UgaGF2ZSB0aGUgZmlyc3QgbGluZS5cbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChzZWxmLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcblxuICAgICAgICB2YXIgbSA9IGxpbmUubWF0Y2goL15XRUJWVFQoWyBcXHRdLiopPyQvKTtcbiAgICAgICAgaWYgKCFtIHx8ICFtWzBdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3IuRXJyb3JzLkJhZFNpZ25hdHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnN0YXRlID0gXCJIRUFERVJcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICB3aGlsZSAoc2VsZi5idWZmZXIpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgcGFyc2UgYSBsaW5lIHVudGlsIHdlIGhhdmUgdGhlIGZ1bGwgbGluZS5cbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChzZWxmLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWxyZWFkeUNvbGxlY3RlZExpbmUpIHtcbiAgICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoc2VsZi5zdGF0ZSkge1xuICAgICAgICBjYXNlIFwiSEVBREVSXCI6XG4gICAgICAgICAgLy8gMTMtMTggLSBBbGxvdyBhIGhlYWRlciAobWV0YWRhdGEpIHVuZGVyIHRoZSBXRUJWVFQgbGluZS5cbiAgICAgICAgICBpZiAoLzovLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIHBhcnNlSGVhZGVyKGxpbmUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIC8vIEFuIGVtcHR5IGxpbmUgdGVybWluYXRlcyB0aGUgaGVhZGVyIGFuZCBzdGFydHMgdGhlIGJvZHkgKGN1ZXMpLlxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSURcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgXCJOT1RFXCI6XG4gICAgICAgICAgLy8gSWdub3JlIE5PVEUgYmxvY2tzLlxuICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSURcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgXCJJRFwiOlxuICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgTk9URSBibG9ja3MuXG4gICAgICAgICAgaWYgKC9eTk9URSgkfFsgXFx0XSkvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIk5PVEVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyAxOS0yOSAtIEFsbG93IGFueSBudW1iZXIgb2YgbGluZSB0ZXJtaW5hdG9ycywgdGhlbiBpbml0aWFsaXplIG5ldyBjdWUgdmFsdWVzLlxuICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuY3VlID0gbmV3IChzZWxmLnZ0dGpzLlZUVEN1ZSB8fCBzZWxmLndpbmRvdy5WVFRDdWUpKDAsIDAsIFwiXCIpO1xuICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIkNVRVwiO1xuICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXG4gICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZihcIi0tPlwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHNlbGYuY3VlLmlkID0gbGluZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQcm9jZXNzIGxpbmUgYXMgc3RhcnQgb2YgYSBjdWUuXG4gICAgICAgICAgLypmYWxscyB0aHJvdWdoKi9cbiAgICAgICAgY2FzZSBcIkNVRVwiOlxuICAgICAgICAgIC8vIDQwIC0gQ29sbGVjdCBjdWUgdGltaW5ncyBhbmQgc2V0dGluZ3MuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlQ3VlKGxpbmUsIHNlbGYuY3VlLCBzZWxmLnJlZ2lvbkxpc3QpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHNlbGYucmVwb3J0T3JUaHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBhbiBlcnJvciBpZ25vcmUgcmVzdCBvZiB0aGUgY3VlLlxuICAgICAgICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiQkFEQ1VFXCI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiQ1VFVEVYVFwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlIFwiQ1VFVEVYVFwiOlxuICAgICAgICAgIHZhciBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoXCItLT5cIikgIT09IC0xO1xuICAgICAgICAgIC8vIDM0IC0gSWYgd2UgaGF2ZSBhbiBlbXB0eSBsaW5lIHRoZW4gcmVwb3J0IHRoZSBjdWUuXG4gICAgICAgICAgLy8gMzUgLSBJZiB3ZSBoYXZlIHRoZSBzcGVjaWFsIHN1YnN0cmluZyAnLS0+JyB0aGVuIHJlcG9ydCB0aGUgY3VlLFxuICAgICAgICAgIC8vIGJ1dCBkbyBub3QgY29sbGVjdCB0aGUgbGluZSBhcyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyBvbmUgYXMgYSBuZXcgY3VlLlxuICAgICAgICAgIGlmICghbGluZSB8fCBoYXNTdWJzdHJpbmcgJiYgKGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIHBhcnNpbmcgc2VsZiBjdWUuXG4gICAgICAgICAgICBzZWxmLm9uY3VlICYmIHNlbGYub25jdWUoc2VsZi5jdWUpO1xuICAgICAgICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSURcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VsZi5jdWUudGV4dCkge1xuICAgICAgICAgICAgc2VsZi5jdWUudGV4dCArPSBcIlxcblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9IGxpbmU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgXCJCQURDVUVcIjogLy8gQkFEQ1VFXG4gICAgICAgICAgLy8gNTQtNjIgLSBDb2xsZWN0IGFuZCBkaXNjYXJkIHRoZSByZW1haW5pbmcgY3VlLlxuICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSURcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzZWxmLnJlcG9ydE9yVGhyb3dFcnJvcihlKTtcblxuICAgICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBwYXJzaW5nIGEgY3VlLCByZXBvcnQgd2hhdCB3ZSBoYXZlLlxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFwiQ1VFVEVYVFwiICYmIHNlbGYuY3VlICYmIHNlbGYub25jdWUpIHtcbiAgICAgICAgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XG4gICAgICB9XG4gICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAvLyBFbnRlciBCQURXRUJWVFQgc3RhdGUgaWYgaGVhZGVyIHdhcyBub3QgcGFyc2VkIGNvcnJlY3RseSBvdGhlcndpc2VcbiAgICAgIC8vIGFub3RoZXIgZXhjZXB0aW9uIG9jY3VycmVkIHNvIGVudGVyIEJBRENVRSBzdGF0ZS5cbiAgICAgIHNlbGYuc3RhdGUgPSBzZWxmLnN0YXRlID09PSBcIklOSVRJQUxcIiA/IFwiQkFEV0VCVlRUXCIgOiBcIkJBRENVRVwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpbmlzaCBkZWNvZGluZyB0aGUgc3RyZWFtLlxuICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZSgpO1xuICAgICAgLy8gU3ludGhlc2l6ZSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGN1ZSBvciByZWdpb24uXG4gICAgICBpZiAoc2VsZi5jdWUgfHwgc2VsZi5zdGF0ZSA9PT0gXCJIRUFERVJcIikge1xuICAgICAgICBzZWxmLmJ1ZmZlciArPSBcIlxcblxcblwiO1xuICAgICAgICBzZWxmLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSd2ZSBmbHVzaGVkLCBwYXJzZWQsIGFuZCB3ZSdyZSBzdGlsbCBvbiB0aGUgSU5JVElBTCBzdGF0ZSB0aGVuXG4gICAgICAvLyB0aGF0IG1lYW5zIHdlIGRvbid0IGhhdmUgZW5vdWdoIG9mIHRoZSBzdHJlYW0gdG8gcGFyc2UgdGhlIGZpcnN0XG4gICAgICAvLyBsaW5lLlxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFwiSU5JVElBTFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yLkVycm9ycy5CYWRTaWduYXR1cmUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgc2VsZi5yZXBvcnRPclRocm93RXJyb3IoZSk7XG4gICAgfVxuICAgIHNlbGYub25mbHVzaCAmJiBzZWxmLm9uZmx1c2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJWVFQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/videojs-vtt.js/lib/vtt.js\n");

/***/ }),

/***/ "./node_modules/videojs-vtt.js/lib/vttcue.js":
/*!***************************************************!*\
  !*** ./node_modules/videojs-vtt.js/lib/vttcue.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar autoKeyword = \"auto\";\nvar directionSetting = {\n  \"\": 1,\n  \"lr\": 1,\n  \"rl\": 1\n};\nvar alignSetting = {\n  \"start\": 1,\n  \"middle\": 1,\n  \"end\": 1,\n  \"left\": 1,\n  \"right\": 1\n};\n\nfunction findDirectionSetting(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  var dir = directionSetting[value.toLowerCase()];\n  return dir ? value.toLowerCase() : false;\n}\n\nfunction findAlignSetting(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  var align = alignSetting[value.toLowerCase()];\n  return align ? value.toLowerCase() : false;\n}\n\nfunction VTTCue(startTime, endTime, text) {\n  /**\n   * Shim implementation specific properties. These properties are not in\n   * the spec.\n   */\n\n  // Lets us know when the VTTCue's data has changed in such a way that we need\n  // to recompute its display state. This lets us compute its display state\n  // lazily.\n  this.hasBeenReset = false;\n\n  /**\n   * VTTCue and TextTrackCue properties\n   * http://dev.w3.org/html5/webvtt/#vttcue-interface\n   */\n\n  var _id = \"\";\n  var _pauseOnExit = false;\n  var _startTime = startTime;\n  var _endTime = endTime;\n  var _text = text;\n  var _region = null;\n  var _vertical = \"\";\n  var _snapToLines = true;\n  var _line = \"auto\";\n  var _lineAlign = \"start\";\n  var _position = 50;\n  var _positionAlign = \"middle\";\n  var _size = 50;\n  var _align = \"middle\";\n\n  Object.defineProperties(this, {\n    \"id\": {\n      enumerable: true,\n      get: function() {\n        return _id;\n      },\n      set: function(value) {\n        _id = \"\" + value;\n      }\n    },\n\n    \"pauseOnExit\": {\n      enumerable: true,\n      get: function() {\n        return _pauseOnExit;\n      },\n      set: function(value) {\n        _pauseOnExit = !!value;\n      }\n    },\n\n    \"startTime\": {\n      enumerable: true,\n      get: function() {\n        return _startTime;\n      },\n      set: function(value) {\n        if (typeof value !== \"number\") {\n          throw new TypeError(\"Start time must be set to a number.\");\n        }\n        _startTime = value;\n        this.hasBeenReset = true;\n      }\n    },\n\n    \"endTime\": {\n      enumerable: true,\n      get: function() {\n        return _endTime;\n      },\n      set: function(value) {\n        if (typeof value !== \"number\") {\n          throw new TypeError(\"End time must be set to a number.\");\n        }\n        _endTime = value;\n        this.hasBeenReset = true;\n      }\n    },\n\n    \"text\": {\n      enumerable: true,\n      get: function() {\n        return _text;\n      },\n      set: function(value) {\n        _text = \"\" + value;\n        this.hasBeenReset = true;\n      }\n    },\n\n    \"region\": {\n      enumerable: true,\n      get: function() {\n        return _region;\n      },\n      set: function(value) {\n        _region = value;\n        this.hasBeenReset = true;\n      }\n    },\n\n    \"vertical\": {\n      enumerable: true,\n      get: function() {\n        return _vertical;\n      },\n      set: function(value) {\n        var setting = findDirectionSetting(value);\n        // Have to check for false because the setting an be an empty string.\n        if (setting === false) {\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        }\n        _vertical = setting;\n        this.hasBeenReset = true;\n      }\n    },\n\n    \"snapToLines\": {\n      enumerable: true,\n      get: function() {\n        return _snapToLines;\n      },\n      set: function(value) {\n        _snapToLines = !!value;\n        this.hasBeenReset = true;\n      }\n    },\n\n    \"line\": {\n      enumerable: true,\n      get: function() {\n        return _line;\n      },\n      set: function(value) {\n        if (typeof value !== \"number\" && value !== autoKeyword) {\n          throw new SyntaxError(\"An invalid number or illegal string was specified.\");\n        }\n        _line = value;\n        this.hasBeenReset = true;\n      }\n    },\n\n    \"lineAlign\": {\n      enumerable: true,\n      get: function() {\n        return _lineAlign;\n      },\n      set: function(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        }\n        _lineAlign = setting;\n        this.hasBeenReset = true;\n      }\n    },\n\n    \"position\": {\n      enumerable: true,\n      get: function() {\n        return _position;\n      },\n      set: function(value) {\n        if (value < 0 || value > 100) {\n          throw new Error(\"Position must be between 0 and 100.\");\n        }\n        _position = value;\n        this.hasBeenReset = true;\n      }\n    },\n\n    \"positionAlign\": {\n      enumerable: true,\n      get: function() {\n        return _positionAlign;\n      },\n      set: function(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        }\n        _positionAlign = setting;\n        this.hasBeenReset = true;\n      }\n    },\n\n    \"size\": {\n      enumerable: true,\n      get: function() {\n        return _size;\n      },\n      set: function(value) {\n        if (value < 0 || value > 100) {\n          throw new Error(\"Size must be between 0 and 100.\");\n        }\n        _size = value;\n        this.hasBeenReset = true;\n      }\n    },\n\n    \"align\": {\n      enumerable: true,\n      get: function() {\n        return _align;\n      },\n      set: function(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        }\n        _align = setting;\n        this.hasBeenReset = true;\n      }\n    }\n  });\n\n  /**\n   * Other <track> spec defined properties\n   */\n\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n  this.displayState = undefined;\n}\n\n/**\n * VTTCue methods\n */\n\nVTTCue.prototype.getCueAsHTML = function() {\n  // Assume WebVTT.convertCueToDOMTree is on the global.\n  return WebVTT.convertCueToDOMTree(window, this.text);\n};\n\nmodule.exports = VTTCue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmlkZW9qcy12dHQuanMvbGliL3Z0dGN1ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92aWRlb2pzLXZ0dC5qcy9saWIvdnR0Y3VlLmpzP2IwM2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgYXV0b0tleXdvcmQgPSBcImF1dG9cIjtcbnZhciBkaXJlY3Rpb25TZXR0aW5nID0ge1xuICBcIlwiOiAxLFxuICBcImxyXCI6IDEsXG4gIFwicmxcIjogMVxufTtcbnZhciBhbGlnblNldHRpbmcgPSB7XG4gIFwic3RhcnRcIjogMSxcbiAgXCJtaWRkbGVcIjogMSxcbiAgXCJlbmRcIjogMSxcbiAgXCJsZWZ0XCI6IDEsXG4gIFwicmlnaHRcIjogMVxufTtcblxuZnVuY3Rpb24gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgZGlyID0gZGlyZWN0aW9uU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgcmV0dXJuIGRpciA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmluZEFsaWduU2V0dGluZyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBhbGlnbiA9IGFsaWduU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgcmV0dXJuIGFsaWduID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0KSB7XG4gIC8qKlxuICAgKiBTaGltIGltcGxlbWVudGF0aW9uIHNwZWNpZmljIHByb3BlcnRpZXMuIFRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBpblxuICAgKiB0aGUgc3BlYy5cbiAgICovXG5cbiAgLy8gTGV0cyB1cyBrbm93IHdoZW4gdGhlIFZUVEN1ZSdzIGRhdGEgaGFzIGNoYW5nZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIG5lZWRcbiAgLy8gdG8gcmVjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlLiBUaGlzIGxldHMgdXMgY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZVxuICAvLyBsYXppbHkuXG4gIHRoaXMuaGFzQmVlblJlc2V0ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFZUVEN1ZSBhbmQgVGV4dFRyYWNrQ3VlIHByb3BlcnRpZXNcbiAgICogaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2VidnR0LyN2dHRjdWUtaW50ZXJmYWNlXG4gICAqL1xuXG4gIHZhciBfaWQgPSBcIlwiO1xuICB2YXIgX3BhdXNlT25FeGl0ID0gZmFsc2U7XG4gIHZhciBfc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICB2YXIgX2VuZFRpbWUgPSBlbmRUaW1lO1xuICB2YXIgX3RleHQgPSB0ZXh0O1xuICB2YXIgX3JlZ2lvbiA9IG51bGw7XG4gIHZhciBfdmVydGljYWwgPSBcIlwiO1xuICB2YXIgX3NuYXBUb0xpbmVzID0gdHJ1ZTtcbiAgdmFyIF9saW5lID0gXCJhdXRvXCI7XG4gIHZhciBfbGluZUFsaWduID0gXCJzdGFydFwiO1xuICB2YXIgX3Bvc2l0aW9uID0gNTA7XG4gIHZhciBfcG9zaXRpb25BbGlnbiA9IFwibWlkZGxlXCI7XG4gIHZhciBfc2l6ZSA9IDUwO1xuICB2YXIgX2FsaWduID0gXCJtaWRkbGVcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgXCJpZFwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9pZCA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJwYXVzZU9uRXhpdFwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9wYXVzZU9uRXhpdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9wYXVzZU9uRXhpdCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwic3RhcnRUaW1lXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N0YXJ0VGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3RhcnQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3N0YXJ0VGltZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiZW5kVGltZVwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9lbmRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX2VuZFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBcInRleHRcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdGV4dDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF90ZXh0ID0gXCJcIiArIHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwicmVnaW9uXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2lvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9yZWdpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBcInZlcnRpY2FsXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF92ZXJ0aWNhbCA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJzbmFwVG9MaW5lc1wiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9zbmFwVG9MaW5lcyA9ICEhdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJsaW5lXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2xpbmU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiICYmIHZhbHVlICE9PSBhdXRvS2V5d29yZCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgbnVtYmVyIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9saW5lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJsaW5lQWxpZ25cIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbGluZUFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZUFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwicG9zaXRpb25BbGlnblwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbkFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfcG9zaXRpb25BbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJzaXplXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiYWxpZ25cIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfYWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9hbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBPdGhlciA8dHJhY2s+IHNwZWMgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAqL1xuXG4gIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS12aWRlby1lbGVtZW50Lmh0bWwjdGV4dC10cmFjay1jdWUtZGlzcGxheS1zdGF0ZVxuICB0aGlzLmRpc3BsYXlTdGF0ZSA9IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBWVFRDdWUgbWV0aG9kc1xuICovXG5cblZUVEN1ZS5wcm90b3R5cGUuZ2V0Q3VlQXNIVE1MID0gZnVuY3Rpb24oKSB7XG4gIC8vIEFzc3VtZSBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSBpcyBvbiB0aGUgZ2xvYmFsLlxuICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUod2luZG93LCB0aGlzLnRleHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWVFRDdWU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/videojs-vtt.js/lib/vttcue.js\n");

/***/ }),

/***/ "./node_modules/videojs-vtt.js/lib/vttregion.js":
/*!******************************************************!*\
  !*** ./node_modules/videojs-vtt.js/lib/vttregion.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar scrollSetting = {\n  \"\": true,\n  \"up\": true\n};\n\nfunction findScrollSetting(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  var scroll = scrollSetting[value.toLowerCase()];\n  return scroll ? value.toLowerCase() : false;\n}\n\nfunction isValidPercentValue(value) {\n  return typeof value === \"number\" && (value >= 0 && value <= 100);\n}\n\n// VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface\nfunction VTTRegion() {\n  var _width = 100;\n  var _lines = 3;\n  var _regionAnchorX = 0;\n  var _regionAnchorY = 100;\n  var _viewportAnchorX = 0;\n  var _viewportAnchorY = 100;\n  var _scroll = \"\";\n\n  Object.defineProperties(this, {\n    \"width\": {\n      enumerable: true,\n      get: function() {\n        return _width;\n      },\n      set: function(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"Width must be between 0 and 100.\");\n        }\n        _width = value;\n      }\n    },\n    \"lines\": {\n      enumerable: true,\n      get: function() {\n        return _lines;\n      },\n      set: function(value) {\n        if (typeof value !== \"number\") {\n          throw new TypeError(\"Lines must be set to a number.\");\n        }\n        _lines = value;\n      }\n    },\n    \"regionAnchorY\": {\n      enumerable: true,\n      get: function() {\n        return _regionAnchorY;\n      },\n      set: function(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"RegionAnchorX must be between 0 and 100.\");\n        }\n        _regionAnchorY = value;\n      }\n    },\n    \"regionAnchorX\": {\n      enumerable: true,\n      get: function() {\n        return _regionAnchorX;\n      },\n      set: function(value) {\n        if(!isValidPercentValue(value)) {\n          throw new Error(\"RegionAnchorY must be between 0 and 100.\");\n        }\n        _regionAnchorX = value;\n      }\n    },\n    \"viewportAnchorY\": {\n      enumerable: true,\n      get: function() {\n        return _viewportAnchorY;\n      },\n      set: function(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"ViewportAnchorY must be between 0 and 100.\");\n        }\n        _viewportAnchorY = value;\n      }\n    },\n    \"viewportAnchorX\": {\n      enumerable: true,\n      get: function() {\n        return _viewportAnchorX;\n      },\n      set: function(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"ViewportAnchorX must be between 0 and 100.\");\n        }\n        _viewportAnchorX = value;\n      }\n    },\n    \"scroll\": {\n      enumerable: true,\n      get: function() {\n        return _scroll;\n      },\n      set: function(value) {\n        var setting = findScrollSetting(value);\n        // Have to check for false as an empty string is a legal value.\n        if (setting === false) {\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        }\n        _scroll = setting;\n      }\n    }\n  });\n}\n\nmodule.exports = VTTRegion;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmlkZW9qcy12dHQuanMvbGliL3Z0dHJlZ2lvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92aWRlb2pzLXZ0dC5qcy9saWIvdnR0cmVnaW9uLmpzP2Y5N2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgc2Nyb2xsU2V0dGluZyA9IHtcbiAgXCJcIjogdHJ1ZSxcbiAgXCJ1cFwiOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBmaW5kU2Nyb2xsU2V0dGluZyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzY3JvbGwgPSBzY3JvbGxTZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gc2Nyb2xsID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgKHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTAwKTtcbn1cblxuLy8gVlRUUmVnaW9uIHNoaW0gaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2VidnR0LyN2dHRyZWdpb24taW50ZXJmYWNlXG5mdW5jdGlvbiBWVFRSZWdpb24oKSB7XG4gIHZhciBfd2lkdGggPSAxMDA7XG4gIHZhciBfbGluZXMgPSAzO1xuICB2YXIgX3JlZ2lvbkFuY2hvclggPSAwO1xuICB2YXIgX3JlZ2lvbkFuY2hvclkgPSAxMDA7XG4gIHZhciBfdmlld3BvcnRBbmNob3JYID0gMDtcbiAgdmFyIF92aWV3cG9ydEFuY2hvclkgPSAxMDA7XG4gIHZhciBfc2Nyb2xsID0gXCJcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgXCJ3aWR0aFwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF93aWR0aDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWR0aCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfd2lkdGggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwibGluZXNcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbGluZXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkxpbmVzIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZXMgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicmVnaW9uQW5jaG9yWVwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdpb25BbmNob3JZO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZ2lvbkFuY2hvclggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3JlZ2lvbkFuY2hvclkgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicmVnaW9uQW5jaG9yWFwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdpb25BbmNob3JYO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYoIWlzVmFsaWRQZXJjZW50VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVnaW9uQW5jaG9yWSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfcmVnaW9uQW5jaG9yWCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJ2aWV3cG9ydEFuY2hvcllcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdmlld3BvcnRBbmNob3JZO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZpZXdwb3J0QW5jaG9yWSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfdmlld3BvcnRBbmNob3JZID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInZpZXdwb3J0QW5jaG9yWFwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF92aWV3cG9ydEFuY2hvclg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzVmFsaWRQZXJjZW50VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmlld3BvcnRBbmNob3JYIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF92aWV3cG9ydEFuY2hvclggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwic2Nyb2xsXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3Njcm9sbDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZFNjcm9sbFNldHRpbmcodmFsdWUpO1xuICAgICAgICAvLyBIYXZlIHRvIGNoZWNrIGZvciBmYWxzZSBhcyBhbiBlbXB0eSBzdHJpbmcgaXMgYSBsZWdhbCB2YWx1ZS5cbiAgICAgICAgaWYgKHNldHRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfc2Nyb2xsID0gc2V0dGluZztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZUVFJlZ2lvbjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/videojs-vtt.js/lib/vttregion.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./node_modules/xhr/index.js":
/*!***********************************!*\
  !*** ./node_modules/xhr/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar window = __webpack_require__(/*! global/window */ \"./node_modules/global/window.js\")\nvar isFunction = __webpack_require__(/*! is-function */ \"./node_modules/is-function/index.js\")\nvar parseHeaders = __webpack_require__(/*! parse-headers */ \"./node_modules/parse-headers/parse-headers.js\")\nvar xtend = __webpack_require__(/*! xtend */ \"./node_modules/xtend/immutable.js\")\n\nmodule.exports = createXHR\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\ncreateXHR.XDomainRequest = \"withCredentials\" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\n\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function(method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function(uri, options, callback) {\n        options = initParams(uri, options, callback)\n        options.method = method.toUpperCase()\n        return _createXHR(options)\n    }\n})\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i])\n    }\n}\n\nfunction isEmpty(obj){\n    for(var i in obj){\n        if(obj.hasOwnProperty(i)) return false\n    }\n    return true\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri\n\n    if (isFunction(options)) {\n        callback = options\n        if (typeof uri === \"string\") {\n            params = {uri:uri}\n        }\n    } else {\n        params = xtend(options, {uri: uri})\n    }\n\n    params.callback = callback\n    return params\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback)\n    return _createXHR(options)\n}\n\nfunction _createXHR(options) {\n    if(typeof options.callback === \"undefined\"){\n        throw new Error(\"callback argument missing\")\n    }\n\n    var called = false\n    var callback = function cbOnce(err, response, body){\n        if(!called){\n            called = true\n            options.callback(err, response, body)\n        }\n    }\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0)\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined\n\n        if (xhr.response) {\n            body = xhr.response\n        } else {\n            body = xhr.responseText || getXml(xhr)\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body)\n            } catch (e) {}\n        }\n\n        return body\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer)\n        if(!(evt instanceof Error)){\n            evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\") )\n        }\n        evt.statusCode = 0\n        return callback(evt, failureResponse)\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return\n        var status\n        clearTimeout(timeoutTimer)\n        if(options.useXDR && xhr.status===undefined) {\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\n            status = 200\n        } else {\n            status = (xhr.status === 1223 ? 204 : xhr.status)\n        }\n        var response = failureResponse\n        var err = null\n\n        if (status !== 0){\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            }\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\n            }\n        } else {\n            err = new Error(\"Internal XMLHttpRequest Error\")\n        }\n        return callback(err, response, response.body)\n    }\n\n    var xhr = options.xhr || null\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest()\n        }else{\n            xhr = new createXHR.XMLHttpRequest()\n        }\n    }\n\n    var key\n    var aborted\n    var uri = xhr.url = options.uri || options.url\n    var method = xhr.method = options.method || \"GET\"\n    var body = options.body || options.data\n    var headers = xhr.headers = options.headers || {}\n    var sync = !!options.sync\n    var isJson = false\n    var timeoutTimer\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    }\n\n    if (\"json\" in options && options.json !== false) {\n        isJson = true\n        headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\") //Don't override existing accept header declared by user\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\") //Don't override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json)\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange\n    xhr.onload = loadFunc\n    xhr.onerror = errorFunc\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    }\n    xhr.onabort = function(){\n        aborted = true;\n    }\n    xhr.ontimeout = errorFunc\n    xhr.open(method, uri, !sync, options.username, options.password)\n    //has to be after open\n    if(!sync) {\n        xhr.withCredentials = !!options.withCredentials\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0 ) {\n        timeoutTimer = setTimeout(function(){\n            if (aborted) return\n            aborted = true//IE9 may still call readystatechange\n            xhr.abort(\"timeout\")\n            var e = new Error(\"XMLHttpRequest timeout\")\n            e.code = \"ETIMEDOUT\"\n            errorFunc(e)\n        }, options.timeout )\n    }\n\n    if (xhr.setRequestHeader) {\n        for(key in headers){\n            if(headers.hasOwnProperty(key)){\n                xhr.setRequestHeader(key, headers[key])\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error(\"Headers cannot be set on an XDomainRequest object\")\n    }\n\n    if (\"responseType\" in options) {\n        xhr.responseType = options.responseType\n    }\n\n    if (\"beforeSend\" in options &&\n        typeof options.beforeSend === \"function\"\n    ) {\n        options.beforeSend(xhr)\n    }\n\n    // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null)\n\n    return xhr\n\n\n}\n\nfunction getXml(xhr) {\n    if (xhr.responseType === \"document\") {\n        return xhr.responseXML\n    }\n    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\"\n    if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n        return xhr.responseXML\n    }\n\n    return null\n}\n\nfunction noop() {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveGhyL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3hoci9pbmRleC5qcz9lZWM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHdpbmRvdyA9IHJlcXVpcmUoXCJnbG9iYWwvd2luZG93XCIpXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoXCJpcy1mdW5jdGlvblwiKVxudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoXCJwYXJzZS1oZWFkZXJzXCIpXG52YXIgeHRlbmQgPSByZXF1aXJlKFwieHRlbmRcIilcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVYSFJcbmNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCB8fCBub29wXG5jcmVhdGVYSFIuWERvbWFpblJlcXVlc3QgPSBcIndpdGhDcmVkZW50aWFsc1wiIGluIChuZXcgY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0KCkpID8gY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0IDogd2luZG93LlhEb21haW5SZXF1ZXN0XG5cbmZvckVhY2hBcnJheShbXCJnZXRcIiwgXCJwdXRcIiwgXCJwb3N0XCIsIFwicGF0Y2hcIiwgXCJoZWFkXCIsIFwiZGVsZXRlXCJdLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBjcmVhdGVYSFJbbWV0aG9kID09PSBcImRlbGV0ZVwiID8gXCJkZWxcIiA6IG1ldGhvZF0gPSBmdW5jdGlvbih1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVYSFIob3B0aW9ucylcbiAgICB9XG59KVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRvcihhcnJheVtpXSlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKXtcbiAgICBmb3IodmFyIGkgaW4gb2JqKXtcbiAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KGkpKSByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhcmFtcyA9IHVyaVxuXG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7dXJpOnVyaX1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcyA9IHh0ZW5kKG9wdGlvbnMsIHt1cmk6IHVyaX0pXG4gICAgfVxuXG4gICAgcGFyYW1zLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICByZXR1cm4gcGFyYW1zXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVhIUih1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgb3B0aW9ucyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICByZXR1cm4gX2NyZWF0ZVhIUihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlWEhSKG9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygb3B0aW9ucy5jYWxsYmFjayA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIilcbiAgICB9XG5cbiAgICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYk9uY2UoZXJyLCByZXNwb25zZSwgYm9keSl7XG4gICAgICAgIGlmKCFjYWxsZWQpe1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZVxuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhlcnIsIHJlc3BvbnNlLCBib2R5KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGxvYWRGdW5jLCAwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgICAgICAgLy8gQ2hyb21lIHdpdGggcmVxdWVzdFR5cGU9YmxvYiB0aHJvd3MgZXJyb3JzIGFycm91bmQgd2hlbiBldmVuIHRlc3RpbmcgYWNjZXNzIHRvIHJlc3BvbnNlVGV4dFxuICAgICAgICB2YXIgYm9keSA9IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmICh4aHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VUZXh0IHx8IGdldFhtbCh4aHIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNKc29uKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvZHlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvckZ1bmMoZXZ0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpXG4gICAgICAgIGlmKCEoZXZ0IGluc3RhbmNlb2YgRXJyb3IpKXtcbiAgICAgICAgICAgIGV2dCA9IG5ldyBFcnJvcihcIlwiICsgKGV2dCB8fCBcIlVua25vd24gWE1MSHR0cFJlcXVlc3QgRXJyb3JcIikgKVxuICAgICAgICB9XG4gICAgICAgIGV2dC5zdGF0dXNDb2RlID0gMFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXZ0LCBmYWlsdXJlUmVzcG9uc2UpXG4gICAgfVxuXG4gICAgLy8gd2lsbCBsb2FkIHRoZSBkYXRhICYgcHJvY2VzcyB0aGUgcmVzcG9uc2UgaW4gYSBzcGVjaWFsIHJlc3BvbnNlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGxvYWRGdW5jKCkge1xuICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuXG4gICAgICAgIHZhciBzdGF0dXNcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgaWYob3B0aW9ucy51c2VYRFIgJiYgeGhyLnN0YXR1cz09PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy9JRTggQ09SUyBHRVQgc3VjY2Vzc2Z1bCByZXNwb25zZSBkb2Vzbid0IGhhdmUgYSBzdGF0dXMgZmllbGQsIGJ1dCBib2R5IGlzIGZpbmVcbiAgICAgICAgICAgIHN0YXR1cyA9IDIwMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzKVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXNwb25zZSA9IGZhaWx1cmVSZXNwb25zZVxuICAgICAgICB2YXIgZXJyID0gbnVsbFxuXG4gICAgICAgIGlmIChzdGF0dXMgIT09IDApe1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogZ2V0Qm9keSgpLFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgICAgICAgICByYXdSZXF1ZXN0OiB4aHJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMpeyAvL3JlbWVtYmVyIHhociBjYW4gaW4gZmFjdCBiZSBYRFIgZm9yIENPUlMgaW4gSUVcbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihcIkludGVybmFsIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIHJlc3BvbnNlLmJvZHkpXG4gICAgfVxuXG4gICAgdmFyIHhociA9IG9wdGlvbnMueGhyIHx8IG51bGxcblxuICAgIGlmICgheGhyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvcnMgfHwgb3B0aW9ucy51c2VYRFIpIHtcbiAgICAgICAgICAgIHhociA9IG5ldyBjcmVhdGVYSFIuWERvbWFpblJlcXVlc3QoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHhociA9IG5ldyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleVxuICAgIHZhciBhYm9ydGVkXG4gICAgdmFyIHVyaSA9IHhoci51cmwgPSBvcHRpb25zLnVyaSB8fCBvcHRpb25zLnVybFxuICAgIHZhciBtZXRob2QgPSB4aHIubWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIlxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG9wdGlvbnMuZGF0YVxuICAgIHZhciBoZWFkZXJzID0geGhyLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge31cbiAgICB2YXIgc3luYyA9ICEhb3B0aW9ucy5zeW5jXG4gICAgdmFyIGlzSnNvbiA9IGZhbHNlXG4gICAgdmFyIHRpbWVvdXRUaW1lclxuICAgIHZhciBmYWlsdXJlUmVzcG9uc2UgPSB7XG4gICAgICAgIGJvZHk6IHVuZGVmaW5lZCxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIHN0YXR1c0NvZGU6IDAsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgfVxuXG4gICAgaWYgKFwianNvblwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5qc29uICE9PSBmYWxzZSkge1xuICAgICAgICBpc0pzb24gPSB0cnVlXG4gICAgICAgIGhlYWRlcnNbXCJhY2NlcHRcIl0gfHwgaGVhZGVyc1tcIkFjY2VwdFwiXSB8fCAoaGVhZGVyc1tcIkFjY2VwdFwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKSAvL0Rvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFjY2VwdCBoZWFkZXIgZGVjbGFyZWQgYnkgdXNlclxuICAgICAgICBpZiAobWV0aG9kICE9PSBcIkdFVFwiICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSB8fCAoaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKSAvL0Rvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFjY2VwdCBoZWFkZXIgZGVjbGFyZWQgYnkgdXNlclxuICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuanNvbiA9PT0gdHJ1ZSA/IGJvZHkgOiBvcHRpb25zLmpzb24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZVxuICAgIHhoci5vbmxvYWQgPSBsb2FkRnVuY1xuICAgIHhoci5vbmVycm9yID0gZXJyb3JGdW5jXG4gICAgLy8gSUU5IG11c3QgaGF2ZSBvbnByb2dyZXNzIGJlIHNldCB0byBhIHVuaXF1ZSBmdW5jdGlvbi5cbiAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSUUgbXVzdCBkaWVcbiAgICB9XG4gICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpe1xuICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgeGhyLm9udGltZW91dCA9IGVycm9yRnVuY1xuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJpLCAhc3luYywgb3B0aW9ucy51c2VybmFtZSwgb3B0aW9ucy5wYXNzd29yZClcbiAgICAvL2hhcyB0byBiZSBhZnRlciBvcGVuXG4gICAgaWYoIXN5bmMpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0aW9ucy53aXRoQ3JlZGVudGlhbHNcbiAgICB9XG4gICAgLy8gQ2Fubm90IHNldCB0aW1lb3V0IHdpdGggc3luYyByZXF1ZXN0XG4gICAgLy8gbm90IHNldHRpbmcgdGltZW91dCBvbiB0aGUgeGhyIG9iamVjdCwgYmVjYXVzZSBvZiBvbGQgd2Via2l0cyBldGMuIG5vdCBoYW5kbGluZyB0aGF0IGNvcnJlY3RseVxuICAgIC8vIGJvdGggbnBtJ3MgcmVxdWVzdCBhbmQganF1ZXJ5IDEueCB1c2UgdGhpcyBraW5kIG9mIHRpbWVvdXQsIHNvIHRoaXMgaXMgYmVpbmcgY29uc2lzdGVudFxuICAgIGlmICghc3luYyAmJiBvcHRpb25zLnRpbWVvdXQgPiAwICkge1xuICAgICAgICB0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuXG4gICAgICAgICAgICBhYm9ydGVkID0gdHJ1ZS8vSUU5IG1heSBzdGlsbCBjYWxsIHJlYWR5c3RhdGVjaGFuZ2VcbiAgICAgICAgICAgIHhoci5hYm9ydChcInRpbWVvdXRcIilcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKFwiWE1MSHR0cFJlcXVlc3QgdGltZW91dFwiKVxuICAgICAgICAgICAgZS5jb2RlID0gXCJFVElNRURPVVRcIlxuICAgICAgICAgICAgZXJyb3JGdW5jKGUpXG4gICAgICAgIH0sIG9wdGlvbnMudGltZW91dCApXG4gICAgfVxuXG4gICAgaWYgKHhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgIGZvcihrZXkgaW4gaGVhZGVycyl7XG4gICAgICAgICAgICBpZihoZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpe1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmhlYWRlcnMgJiYgIWlzRW1wdHkob3B0aW9ucy5oZWFkZXJzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWFkZXJzIGNhbm5vdCBiZSBzZXQgb24gYW4gWERvbWFpblJlcXVlc3Qgb2JqZWN0XCIpXG4gICAgfVxuXG4gICAgaWYgKFwicmVzcG9uc2VUeXBlXCIgaW4gb3B0aW9ucykge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGVcbiAgICB9XG5cbiAgICBpZiAoXCJiZWZvcmVTZW5kXCIgaW4gb3B0aW9ucyAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTZW5kID09PSBcImZ1bmN0aW9uXCJcbiAgICApIHtcbiAgICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kKHhocilcbiAgICB9XG5cbiAgICAvLyBNaWNyb3NvZnQgRWRnZSBicm93c2VyIHNlbmRzIFwidW5kZWZpbmVkXCIgd2hlbiBzZW5kIGlzIGNhbGxlZCB3aXRoIHVuZGVmaW5lZCB2YWx1ZS5cbiAgICAvLyBYTUxIdHRwUmVxdWVzdCBzcGVjIHNheXMgdG8gcGFzcyBudWxsIGFzIGJvZHkgdG8gaW5kaWNhdGUgbm8gYm9keVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbmF1Z3R1ci94aHIvaXNzdWVzLzEwMC5cbiAgICB4aHIuc2VuZChib2R5IHx8IG51bGwpXG5cbiAgICByZXR1cm4geGhyXG5cblxufVxuXG5mdW5jdGlvbiBnZXRYbWwoeGhyKSB7XG4gICAgaWYgKHhoci5yZXNwb25zZVR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlWE1MXG4gICAgfVxuICAgIHZhciBmaXJlZm94QnVnVGFrZW5FZmZlY3QgPSB4aHIucmVzcG9uc2VYTUwgJiYgeGhyLnJlc3BvbnNlWE1MLmRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSA9PT0gXCJwYXJzZXJlcnJvclwiXG4gICAgaWYgKHhoci5yZXNwb25zZVR5cGUgPT09IFwiXCIgJiYgIWZpcmVmb3hCdWdUYWtlbkVmZmVjdCkge1xuICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlWE1MXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/xhr/index.js\n");

/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcz81M2E4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/xtend/immutable.js\n");

/***/ }),

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Main application file.\n */\n\n\n\nvar m      = __webpack_require__(/*! mithril */ \"./node_modules/mithril/mithril.js\"),\n    player = __webpack_require__(/*! ./modules/player */ \"./src/js/modules/player.js\"),\n    doc    = document;\n\ndoc.addEventListener('DOMContentLoaded', function () {\n    m.render(doc.body, 'hello world');\n\n    m('video', {id: 'player', class: 'video-js'}, '');\n    m('div', {id: \"playerContainer\"}, \"\")\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9tYWluLmpzPzkyOTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNYWluIGFwcGxpY2F0aW9uIGZpbGUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbSAgICAgID0gcmVxdWlyZSgnbWl0aHJpbCcpLFxuICAgIHBsYXllciA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wbGF5ZXInKSxcbiAgICBkb2MgICAgPSBkb2N1bWVudDtcblxuZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgbS5yZW5kZXIoZG9jLmJvZHksICdoZWxsbyB3b3JsZCcpO1xuXG4gICAgbSgndmlkZW8nLCB7aWQ6ICdwbGF5ZXInLCBjbGFzczogJ3ZpZGVvLWpzJ30sICcnKTtcbiAgICBtKCdkaXYnLCB7aWQ6IFwicGxheWVyQ29udGFpbmVyXCJ9LCBcIlwiKVxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/main.js\n");

/***/ }),

/***/ "./src/js/modules/player.js":
/*!**********************************!*\
  !*** ./src/js/modules/player.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar videojsLib = __webpack_require__(/*! video.js */ \"./node_modules/video.js/dist/video.es.js\");\n\n//https://www.youtube.com/watch?v=twSn58BPgWM\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvbW9kdWxlcy9wbGF5ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvbW9kdWxlcy9wbGF5ZXIuanM/ZGY3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB2aWRlb2pzTGliID0gcmVxdWlyZSgndmlkZW8uanMnKTtcblxuLy9odHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PXR3U241OEJQZ1dNXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/modules/player.js\n");

/***/ }),

/***/ 0:
/*!******************************!*\
  !*** min-document (ignored) ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9taW4tZG9jdW1lbnQgKGlnbm9yZWQpPzlhMGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKGlnbm9yZWQpICovIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ })

/******/ });